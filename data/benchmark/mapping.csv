function_id,spec_idx,sr_text,met_constrains
12231,119,A server MUST ignore an If-Range header field received in a request that does not contain a Range header field.,"['range = apr_table_get(r->headers_in, ""Range"");\nif (!range || ap_cstr_casecmpn(range, ""bytes="", 6) || r->status != HTTP_OK) {\n    return 0;\n}', 'if (AP_CONDITION_NOMATCH == ap_condition_if_range(r, r->headers_out)) {\n    return 0;\n}']"
12231,122,A recipient of an If-Range header field MUST ignore the Range header field if the If-Range condition evaluates to false.,"['if (AP_CONDITION_NOMATCH == ap_condition_if_range(r, r->headers_out)) {\n        return 0;\n    }']"
12231,123,"Otherwise, the recipient SHOULD process the Range header field as requested.","['if (AP_CONDITION_NOMATCH == ap_condition_if_range(r, r->headers_out)) {\n    return 0;\n}', '/* after the If-Range check, the function continues to parse, merge, and process the Range header */\n\nrange = apr_table_get(r->headers_in, ""Range"");\n...\n/* processing and merging of ranges */\n\nr->status = HTTP_PARTIAL_CONTENT;\nr->range = apr_array_pstrcat(r->pool, merged, \',\');']"
12231,126,"Range requests are an OPTIONAL feature of HTTP, designed so that recipients not implementing this feature (or not supporting it for the target resource) can respond as if it is a normal GET request without impacting interoperability.","['if (!range || ap_cstr_casecmpn(range, ""bytes="", 6) || r->status != HTTP_OK) {\n    return 0;\n}', 'r->status = HTTP_PARTIAL_CONTENT;']"
12231,127,A server MAY ignore the Range header field.,"['if (!range || ap_cstr_casecmpn(range, ""bytes="", 6) || r->status != HTTP_OK) {\n    return 0;\n}\n\n/* is content already a single range? */\nif (apr_table_get(r->headers_out, ""Content-Range"")) {\n    return 0;\n}\n\n/* is content already a multiple range? */\nif ((ct = apr_table_get(r->headers_out, ""Content-Type""))\n    && ap_cstr_casecmpn(ct, ""multipart/byteranges"", 20) == 0) {\n        return 0;\n}\n\n/* Check the If-Range header for Etag or Date. */\nif (AP_CONDITION_NOMATCH == ap_condition_if_range(r, r->headers_out)) {\n    return 0;\n}']"
12231,129,An origin server MUST ignore a Range header field that contains a range unit it does not understand.,"['if (!range || ap_cstr_casecmpn(range, ""bytes="", 6) || r->status != HTTP_OK) {\n    return 0;\n}']"
12231,132,"If all of the preconditions are true, the server supports the Range header field for the target resource, the received Range field-value contains a valid ranges-specifier with a range-unit supported for that target resource, and that ranges-specifier is satisfiable with respect to the selected representation, the server SHOULD send a 206 (Partial Content) response with content containing one or more partial representations that correspond to the satisfiable range-spec(s) requested.","['range = apr_table_get(r->headers_in, ""Range"");\nif (!range || ap_cstr_casecmpn(range, ""bytes="", 6) || r->status != HTTP_OK) {\n    return 0;\n}', 'if (AP_CONDITION_NOMATCH == ap_condition_if_range(r, r->headers_out)) {\n    return 0;\n}', 'r->status = HTTP_PARTIAL_CONTENT;', ""r->range = apr_array_pstrcat(r->pool, merged, ',');""]"
12231,220,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.","[""if (!(dash = strchr(cur, '-'))) {\n    return 0;\n}\n\nif (!ap_parse_strict_length(&number, dash+1)) {\n    return 0;\n}"", 'if (ranges > MAX_PREALLOC_RANGES) {\n    ranges = MAX_PREALLOC_RANGES;\n}\n\n*indexes = apr_array_make(r->pool, ranges, sizeof(indexes_t));']"
12231,221,"At a minimum, a recipient MUST be able to parse and process protocol element lengths that are at least as long as the values that it generates for those same protocol elements in other messages.","['if (start >= clength) {\n    unsatisfiable = 1;\n    continue;\n}\nif (end >= clength) {\n    end = clength - 1;\n}\n...\nif (sum_lengths > clength) {\n    ap_log_rerror(..., ""Sum of ranges larger than file, ignoring."");\n    return 0;\n}']"
12234,36,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,"['bound_head = apr_pstrcat(r->pool, CRLF ""--"", ap_multipart_boundary,\n                              CRLF ""Content-type: "", orig_ct,\n                              CRLF ""Content-range: bytes "", NULL);\n\nap_xlate_proto_to_ascii(bound_head, strlen(bound_head));\n\n...\n\nts = apr_psprintf(r->pool, BYTERANGE_FMT CRLF CRLF,\n                   range_start, range_end, clength);\nap_xlate_proto_to_ascii(ts, strlen(ts));\n\n...\n\nend = apr_pstrcat(r->pool, CRLF ""--"", ap_multipart_boundary, ""--"" CRLF, NULL);\nap_xlate_proto_to_ascii(end, strlen(end));']"
12234,126,"Range requests are an OPTIONAL feature of HTTP, designed so that recipients not implementing this feature (or not supporting it for the target resource) can respond as if it is a normal GET request without impacting interoperability.","['if (!APR_BUCKET_IS_EOS(e) || clength <= 0) {\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}', 'if (num_ranges == 1) {\n    apr_table_setn(r->headers_out, ""Content-Range"",\n                       apr_psprintf(r->pool, ""bytes "" BYTERANGE_FMT,\n                                    range_start, range_end, clength));\n}', 'if (num_ranges > 1) {\n    const char *orig_ct = ap_make_content_type(r, r->content_type);\n    ap_set_content_type_ex(r, apr_pstrcat(r->pool,\n                                       ""multipart/byteranges; boundary="",\n                                       ap_multipart_boundary, NULL), 1);\n    if (orig_ct) {\n        bound_head = apr_pstrcat(r->pool,\n                                 CRLF ""--"", ap_multipart_boundary,\n                                 CRLF ""Content-type: "",\n                                 orig_ct,\n                                 CRLF ""Content-range: bytes "",\n                                 NULL);\n    } else {\n        bound_head = apr_pstrcat(r->pool,\n                                 CRLF ""--"", ap_multipart_boundary,\n                                 CRLF ""Content-range: bytes "",\n                                 NULL);\n    }\n    ap_xlate_proto_to_ascii(bound_head, strlen(bound_head));\n    // ... additional multipart boundaries and segment extraction logic ...\n}', 'if (num_ranges < 0)\n    return send_416(f, bsend);']"
12234,130,"A server that supports range requests MAY ignore or reject a Range header field that contains an invalid ranges-specifier (Section 14.1.1), a ranges-specifier with more than two overlapping ranges, or a set of many small ranges that are not listed in ascending order, since these are indications of either a broken client or a deliberate denial-of-service attack (Section 17.15).","['if (num_ranges < 0)\n    return send_416(f, bsend);', 'if (num_ranges == 0 ||\n    (max_ranges >= 0 && num_ranges > max_ranges) ||\n    (max_overlaps >= 0 && overlaps > max_overlaps) ||\n    (max_reversals >= 0 && reversals > max_reversals)) {\n    r->status = original_status;\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}', 'if (!APR_BUCKET_IS_EOS(e) || clength <= 0) {\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}']"
12234,131,"A server that supports range requests MAY ignore a Range header field when the selected representation has no content (i.e., the selected representation's data is of zero length).","['if (!APR_BUCKET_IS_EOS(e) || clength <= 0) {\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}']"
12234,132,"If all of the preconditions are true, the server supports the Range header field for the target resource, the received Range field-value contains a valid ranges-specifier with a range-unit supported for that target resource, and that ranges-specifier is satisfiable with respect to the selected representation, the server SHOULD send a 206 (Partial Content) response with content containing one or more partial representations that correspond to the satisfiable range-spec(s) requested.","['for (e = APR_BRIGADE_FIRST(bb);\n     (e != APR_BRIGADE_SENTINEL(bb) && !APR_BUCKET_IS_EOS(e)\n      && e->length != (apr_size_t)-1);\n     e = APR_BUCKET_NEXT(e)) {\n    clength += e->length;\n}\n\nif (!APR_BUCKET_IS_EOS(e) || clength <= 0) {\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}', 'if (num_ranges == 1) {\n    apr_table_setn(r->headers_out, ""Content-Range"",\n                   apr_psprintf(r->pool, ""bytes "" BYTERANGE_FMT,\n                                range_start, range_end, clength));\n}\nelse {\n    /* Construct multipart/byteranges response */\n    const char *orig_ct = ap_make_content_type(r, r->content_type);\n    ap_set_content_type_ex(r, apr_pstrcat(r->pool,\n                                       ""multipart/byteranges; boundary="",\n                                       ap_multipart_boundary, NULL), 1);\n    bound_head = apr_pstrcat(r->pool,\n                             CRLF ""--"", ap_multipart_boundary,\n                             CRLF ""Content-type: "",\n                             orig_ct ? orig_ct : """",\n                             CRLF ""Content-range: bytes "",\n                             NULL);\n    /* ... Additional code to add boundaries and content ... */\n}']"
12234,147,"If a single part is being transferred, the server generating the 206 response MUST generate a Content-Range header field, describing what range of the selected representation is enclosed, and a content consisting of the range.","['if (num_ranges == 1) {\n    apr_table_setn(r->headers_out, ""Content-Range"",\n                   apr_psprintf(r->pool, ""bytes "" BYTERANGE_FMT, range_start, range_end, clength));\n}', 'rv = copy_brigade_range(bb, tmpbb, range_start, range_end);\n...\nAPR_BRIGADE_CONCAT(bsend, tmpbb);']"
12234,148,"If multiple parts are being transferred, the server generating the 206 response MUST generate ""multipart/byteranges"" content, as defined in Section 14.6, and a Content-Type header field containing the ""multipart/byteranges"" media type and its required boundary parameter.","['if (num_ranges > 1) {\n    const char *orig_ct = ap_make_content_type(r, r->content_type);\n\n    ap_set_content_type_ex(r, apr_pstrcat(r->pool,\n                                       ""multipart/byteranges; boundary="",\n                                       ap_multipart_boundary, NULL), 1);\n\n    if (orig_ct) {\n        bound_head = apr_pstrcat(r->pool,\n                                 CRLF ""--"", ap_multipart_boundary,\n                                 CRLF ""Content-type: "",\n                                 orig_ct,\n                                 CRLF ""Content-range: bytes "",\n                                 NULL);\n    }\n    else {\n        bound_head = apr_pstrcat(r->pool,\n                                 CRLF ""--"", ap_multipart_boundary,\n                                 CRLF ""Content-range: bytes "",\n                                 NULL);\n    }\n    ap_xlate_proto_to_ascii(bound_head, strlen(bound_head));\n}', 'if (num_ranges == 1) {\n    apr_table_setn(r->headers_out, ""Content-Range"",\n                   apr_psprintf(r->pool, ""bytes "" BYTERANGE_FMT,\n                                range_start, range_end, clength));\n} else {\n    char *ts;\n\n    e = apr_bucket_pool_create(bound_head, strlen(bound_head), r->pool, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bsend, e);\n\n    ts = apr_psprintf(r->pool, BYTERANGE_FMT CRLF CRLF,\n                      range_start, range_end, clength);\n    ap_xlate_proto_to_ascii(ts, strlen(ts));\n    e = apr_bucket_pool_create(ts, strlen(ts), r->pool, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bsend, e);\n}']"
12234,149,"To avoid confusion with single-part responses, a server MUST NOT generate a Content-Range header field in the HTTP header section of a multiple part response (this field will be sent in each part instead).","['if (num_ranges > 1) {\n    /* Is ap_make_content_type required here? */\n    const char *orig_ct = ap_make_content_type(r, r->content_type);\n\n    ap_set_content_type_ex(r, apr_pstrcat(r->pool,\n                                       ""multipart/byteranges; boundary="",\n                                       ap_multipart_boundary, NULL), 1);\n\n    if (orig_ct) {\n        bound_head = apr_pstrcat(r->pool,\n                                 CRLF ""--"", ap_multipart_boundary,\n                                 CRLF ""Content-type: "",\n                                 orig_ct,\n                                 CRLF ""Content-range: bytes "",\n                                 NULL);\n    }\n    else {\n        /* if we have no type for the content, do our best */\n        bound_head = apr_pstrcat(r->pool,\n                                 CRLF ""--"", ap_multipart_boundary,\n                                 CRLF ""Content-range: bytes "",\n                                 NULL);\n    }\n    ap_xlate_proto_to_ascii(bound_head, strlen(bound_head));\n}', 'if (num_ranges == 1) {\n    apr_table_setn(r->headers_out, ""Content-Range"",\n                   apr_psprintf(r->pool, ""bytes "" BYTERANGE_FMT,\n                                range_start, range_end, clength));\n}\nelse {\n    // multipart response; each part will contain its own Content-range header\n    ...\n}']"
12234,150,"Within the header area of each body part in the multipart content, the server MUST generate a Content-Range header field corresponding to the range being enclosed in that body part.","['if (num_ranges == 1) {\n    apr_table_setn(r->headers_out, ""Content-Range"",\n                   apr_psprintf(r->pool, ""bytes "" BYTERANGE_FMT,\n                                range_start, range_end, clength));\n} else {\n    char *ts;\n\n    e = apr_bucket_pool_create(bound_head, strlen(bound_head),\n                                 r->pool, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bsend, e);\n\n    ts = apr_psprintf(r->pool, BYTERANGE_FMT CRLF CRLF,\n                      range_start, range_end, clength);\n    ap_xlate_proto_to_ascii(ts, strlen(ts));\n    e = apr_bucket_pool_create(ts, strlen(ts), r->pool,\n                               c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bsend, e);\n}', 'if (num_ranges > 1) {\n    const char *orig_ct = ap_make_content_type(r, r->content_type);\n\n    ap_set_content_type_ex(r, apr_pstrcat(r->pool,\n                                           ""multipart/byteranges; boundary="",\n                                           ap_multipart_boundary, NULL), 1);\n\n    if (orig_ct) {\n        bound_head = apr_pstrcat(r->pool,\n                                 CRLF ""--"", ap_multipart_boundary,\n                                 CRLF ""Content-type: "",\n                                 orig_ct,\n                                 CRLF ""Content-range: bytes "",\n                                 NULL);\n    }\n    else {\n        bound_head = apr_pstrcat(r->pool,\n                                 CRLF ""--"", ap_multipart_boundary,\n                                 CRLF ""Content-range: bytes "",\n                                 NULL);\n    }\n    ap_xlate_proto_to_ascii(bound_head, strlen(bound_head));\n}']"
12234,151,"If the selected representation would have had a Content-Type header field in a 200 (OK) response, the server SHOULD generate that same Content-Type header field in the header area of each body part.","['if (num_ranges > 1) {\n    const char *orig_ct = ap_make_content_type(r, r->content_type);\n    ap_set_content_type_ex(r, apr_pstrcat(r->pool,\n                                           ""multipart/byteranges; boundary="",\n                                           ap_multipart_boundary, NULL), 1);\n    if (orig_ct) {\n        bound_head = apr_pstrcat(r->pool,\n                                 CRLF ""--"", ap_multipart_boundary,\n                                 CRLF ""Content-type: "",\n                                 orig_ct,\n                                 CRLF ""Content-range: bytes "",\n                                 NULL);\n    } else {\n        bound_head = apr_pstrcat(r->pool,\n                                 CRLF ""--"", ap_multipart_boundary,\n                                 CRLF ""Content-range: bytes "",\n                                 NULL);\n    }\n    ap_xlate_proto_to_ascii(bound_head, strlen(bound_head));\n}']"
12234,153,"A server that generates a multipart response SHOULD send the parts in the same order that the corresponding range-spec appeared in the received Range header field, excluding those ranges that were deemed unsatisfiable or that were coalesced into other ranges.","['idx = (indexes_t *)indexes->elts;\n    for (i = 0; i < indexes->nelts; i++, idx++) {\n        range_start = idx->start;\n        range_end = idx->end;\n        ...\n    }', 'if (num_ranges == 1) {\n            apr_table_setn(r->headers_out, ""Content-Range"",\n                           apr_psprintf(r->pool, ""bytes "" BYTERANGE_FMT,\n                                        range_start, range_end, clength));\n        } else {\n            char *ts;\n\n            e = apr_bucket_pool_create(bound_head, strlen(bound_head),\n                                       r->pool, c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bsend, e);\n\n            ts = apr_psprintf(r->pool, BYTERANGE_FMT CRLF CRLF,\n                              range_start, range_end, clength);\n            ap_xlate_proto_to_ascii(ts, strlen(ts));\n            e = apr_bucket_pool_create(ts, strlen(ts), r->pool,\n                                       c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bsend, e);\n        }']"
12234,217,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,"['bound_head = apr_pstrcat(r->pool,\n                             CRLF ""--"", ap_multipart_boundary,\n                             CRLF ""Content-type: "", orig_ct,\n                             CRLF ""Content-range: bytes "",\n                             NULL);\nap_xlate_proto_to_ascii(bound_head, strlen(bound_head));\n\n...\n\nts = apr_psprintf(r->pool, BYTERANGE_FMT CRLF CRLF,\n                   range_start, range_end, clength);\nap_xlate_proto_to_ascii(ts, strlen(ts));\n\n...\n\nend = apr_pstrcat(r->pool, CRLF ""--"", ap_multipart_boundary, ""--"" CRLF,\n                  NULL);\nap_xlate_proto_to_ascii(end, strlen(end));']"
12234,292,"For byte ranges, a sender SHOULD indicate the complete length of the representation from which the range has been extracted, unless the complete length is unknown or difficult to determine.","['for (e = APR_BRIGADE_FIRST(bb);\n     (e != APR_BRIGADE_SENTINEL(bb) && !APR_BUCKET_IS_EOS(e)\n      && e->length != (apr_size_t)-1);\n     e = APR_BUCKET_NEXT(e)) {\n    clength += e->length;\n}\n...\nif (!APR_BUCKET_IS_EOS(e) || clength <= 0) {\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}', 'apr_table_setn(r->headers_out, ""Content-Range"",\n               apr_psprintf(r->pool, ""bytes "" BYTERANGE_FMT,\n                            range_start, range_end, clength));']"
12234,293,"A server MUST NOT generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses.","['if (num_ranges == 1) {\n    apr_table_setn(r->headers_out, ""Content-Range"",\n                   apr_psprintf(r->pool, ""bytes "" BYTERANGE_FMT,\n                                range_start, range_end, clength));\n}', 'if (num_ranges > 1) {\n    const char *orig_ct = ap_make_content_type(r, r->content_type);\n\n    ap_set_content_type_ex(r, apr_pstrcat(r->pool,\n                                       ""multipart/byteranges; boundary="",\n                                       ap_multipart_boundary, NULL), 1);\n\n    if (orig_ct) {\n        bound_head = apr_pstrcat(r->pool,\n                                 CRLF ""--"", ap_multipart_boundary,\n                                 CRLF ""Content-type: "",\n                                 orig_ct,\n                                 CRLF ""Content-range: bytes "",\n                                 NULL);\n    }\n    else {\n        bound_head = apr_pstrcat(r->pool,\n                                 CRLF ""--"", ap_multipart_boundary,\n                                 CRLF ""Content-range: bytes "",\n                                 NULL);\n    }\n    ap_xlate_proto_to_ascii(bound_head, strlen(bound_head));\n    \n    ...\n\n    /* Parts with boundaries are added for each range */\n}']"
12251,217,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,"[""if (!*cp) { ap_log_error(...); return (NULL); } ... if (*cp != '/') { ap_log_error(...); return (NULL); } ... if (value == NULL || *value == '\\0') { ap_log_error(...); return (NULL); }""]"
12251,238,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.","['cp = mp;\nwhile (apr_isspace(*cp)) {\n    cp++;\n}\n...\nwhile (apr_isspace(*cp)) {\n    cp++;\n}\n...\ncp = zap_sp(cp);\n...\nvalue = zap_sp_and_dup(p, mp, cp, NULL);']"
12251,244,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,['while (apr_isspace(*cp)) {\n    cp++;\n}\n\n... \n\ncp = zap_sp(cp);']
12251,245,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,"[""while (apr_isspace(*cp)) { cp++; }  ...  cp = zap_sp(cp);  ...  while (*cp == ' ' || *cp == '\\t' || *cp == '\\n') { cp++; }""]"
12251,246,Recipients that process the value of a quoted-string MUST handle a quoted-pair as if it were replaced by the octet following the backslash.,['else if (is_quoted_pair(cp) > 0) {\n                        cp += 2;\n                    }']
12251,263,The type/subtype MAY be followed by semicolon-delimited parameters (Section 5.6.6) in the form of name/value pairs.,"[""    /* getting a type */\n    cp = mp;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) { ... }\n    ctp->type = cp;\n    do {\n        cp++;\n    } while (*cp && (*cp != '/') && !apr_isspace(*cp) && (*cp != ';'));\n    if (!*cp || (*cp == ';')) { ... }\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (*cp != '/') { ... }\n    ctp->type_len = cp - ctp->type;\n\n    cp++; /* skip the '/' */\n\n    /* getting a subtype */\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) { ... }\n    ctp->subtype = cp;\n    do {\n        cp++;\n    } while (*cp && !apr_isspace(*cp) && (*cp != ';'));\n    ctp->subtype_len = cp - ctp->subtype;"", '    /* getting parameters */\n    cp++; /* skip the \';\' */\n    cp = zap_sp(cp);\n    if (cp == NULL || *cp == \'\\0\') { ... }\n    mp = cp;\n    attribute = NULL;\n    value = NULL;\n\n    while (cp != NULL && *cp != \'\\0\') {\n        if (attribute == NULL) {\n            if (is_token(*cp) > 0) {\n                cp++;\n                continue;\n            } else if (*cp == \' \' || *cp == \'\\t\' || *cp == \'\\n\') {\n                cp++;\n                continue;\n            } else if (*cp == \'=\') {\n                attribute = zap_sp_and_dup(p, mp, cp, NULL);\n                if (attribute == NULL || *attribute == \'\\0\') { ... }\n                cp++;\n                cp = zap_sp(cp);\n                if (cp == NULL || *cp == \'\\0\') { ... }\n                mp = cp;\n                continue;\n            } else {\n                ...\n            }\n        } else {\n            if (mp == cp) {\n                if (*cp == \'""\') {\n                    quoted = 1;\n                    cp++;\n                } else {\n                    quoted = 0;\n                }\n            }\n            if (quoted > 0) {\n                while (quoted && *cp != \'\\0\') {\n                    if (is_qtext(*cp) > 0) {\n                        cp++;\n                    } else if (is_quoted_pair(cp) > 0) {\n                        cp += 2;\n                    } else if (*cp == \'""\') {\n                        cp++;\n                        while (*cp == \' \' || *cp == \'\\t\' || *cp == \'\\n\') {\n                            cp++;\n                        }\n                        if (*cp != \';\' && *cp != \'\\0\') { ... }\n                        quoted = 0;\n                    } else {\n                        ...\n                    }\n                }\n            } else {\n                while (1) {\n                    if (is_token(*cp) > 0) {\n                        cp++;\n                    } else if (*cp == \'\\0\' || *cp == \';\') {\n                        break;\n                    } else {\n                        ...\n                    }\n                }\n            }\n            value = zap_sp_and_dup(p, mp, cp, NULL);\n            if (value == NULL || *value == \'\\0\') { ... }\n\n            pp = apr_palloc(p, sizeof(param));\n            pp->attr = attribute;\n            pp->val = value;\n            pp->next = NULL;\n\n            if (ctp->param == NULL) {\n                ctp->param = pp;\n            } else {\n                npp = ctp->param;\n                while (npp->next) {\n                    npp = npp->next;\n                }\n                npp->next = pp;\n            }\n            quoted = 0;\n            attribute = NULL;\n            value = NULL;\n            if (*cp == \'\\0\') {\n                break;\n            }\n            cp++;\n            mp = cp;\n        }\n    }']"
12252,34,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,"['if (r->finfo.filetype == APR_DIR) {\n    ap_set_content_type_ex(r, DIR_MAGIC_TYPE, 1);\n    return OK;\n}\n...\nif ((type = apr_hash_get(mime_type_extensions, ext, APR_HASH_KEY_STRING)) != NULL) {\n    ap_set_content_type_ex(r, (char*) type, 1);\n    found = 1;\n}\n...\nif (r->content_type) {\n    content_type *ctp;\n    ...\n    ap_set_content_type_ex(r, base_content_type, AP_REQUEST_IS_TRUSTED_CT(r));\n    ...\n    if (charset && !override) {\n        ap_set_content_type_ex(r, apr_pstrcat(r->pool, r->content_type, ""; charset="", charset, NULL), AP_REQUEST_IS_TRUSTED_CT(r));\n    }\n}', 'if (r->content_type) {\n    content_type *ctp;\n    int override = 0;\n\n    if ((ctp = analyze_ct(r, r->content_type))) {\n        ...\n        while (pp != NULL) {\n            if (charset && !strcmp(pp->attr, ""charset"")) {\n                if (!override) {\n                    ap_set_content_type_ex(r,\n                        apr_pstrcat(r->pool, r->content_type, ""; charset="", charset, NULL),\n                        AP_REQUEST_IS_TRUSTED_CT(r));\n                    override = 1;\n                }\n            }\n            else {\n                ap_set_content_type_ex(r,\n                    apr_pstrcat(r->pool, r->content_type, ""; "", pp->attr, ""="", pp->val, NULL),\n                    AP_REQUEST_IS_TRUSTED_CT(r));\n            }\n            pp = pp->next;\n        }\n        if (charset && !override) {\n            ap_set_content_type_ex(r, apr_pstrcat(r->pool, r->content_type, ""; charset="", charset, NULL), AP_REQUEST_IS_TRUSTED_CT(r));\n        }\n    }\n}']"
12252,264,Multiple languages MAY be listed for content that is intended for multiple audiences.,"['if (exinfo->language_type) {\n    if (!r->content_languages) {\n        r->content_languages = apr_array_make(r->pool, 2, sizeof(char *));\n    }\n    *((const char **)apr_array_push(r->content_languages)) = exinfo->language_type;\n}', 'if (!r->content_languages && conf->default_language) {\n    const char **new;\n    r->content_languages = apr_array_make(r->pool, 2, sizeof(char *));\n    new = (const char **)apr_array_push(r->content_languages);\n    *new = conf->default_language;\n}']"
12257,173,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,['if (ctx->state == BODY_CHUNK_END || ctx->state == BODY_CHUNK_END_LF) {\n    if (c == LF) {\n        if (strict && (ctx->state != BODY_CHUNK_END_LF)) {\n            /*\n             * CR missing before LF.\n             */\n            return APR_EINVAL;\n        }\n        ctx->state = BODY_CHUNK;\n    }\n    else if (c == CR && ctx->state == BODY_CHUNK_END) {\n        ctx->state = BODY_CHUNK_END_LF;\n    }\n    else {\n        /*\n         * CRLF expected.\n         */\n        return APR_EINVAL;\n    }\n}\n\n...\n\nif (c == LF) {\n    if (strict && (ctx->state != BODY_CHUNK_LF)) {\n        /*\n         * CR missing before LF.\n         */\n        return APR_EINVAL;\n    }\n    if (ctx->remaining) {\n        ctx->state = BODY_CHUNK_DATA;\n    } else {\n        ctx->state = BODY_CHUNK_TRAILER;\n    }\n}\nelse if (c == CR) {\n    ctx->state = BODY_CHUNK_LF;\n}']
12257,189,A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance.,"['while (i < len) {\n    char c = buffer[i];\n    \n    ap_xlate_proto_from_ascii(&c, 1);\n\n    /* handle CRLF after the chunk */\n    if (ctx->state == BODY_CHUNK_END\n            || ctx->state == BODY_CHUNK_END_LF) {\n        if (c == LF) {\n            if (strict && (ctx->state != BODY_CHUNK_END_LF)) {\n                return APR_EINVAL;\n            }\n            ctx->state = BODY_CHUNK;\n        } else if (c == CR && ctx->state == BODY_CHUNK_END) {\n            ctx->state = BODY_CHUNK_END_LF;\n        } else {\n            return APR_EINVAL;\n        }\n        i++;\n        continue;\n    }\n\n    /* handle start of the chunk */\n    if (ctx->state == BODY_CHUNK) {\n        if (!apr_isxdigit(c)) {\n            return APR_EINVAL;\n        } else {\n            ctx->state = BODY_CHUNK_PART;\n        }\n        ctx->remaining = 0;\n        ctx->chunkbits = sizeof(apr_off_t) * 8 - 4;\n        ctx->chunk_used = 0;\n        ctx->chunk_bws = 0;\n    }\n\n    ... (rest of function handling hex conversion, CRLF, chunk extension, and whitespace) ...']"
12257,207,A recipient MUST be able to parse and decode the chunked transfer coding.,"[""if (ctx->state == BODY_CHUNK) {\n    if (!apr_isxdigit(c)) {\n        /* Detect invalid character at beginning. This also works for\n         * empty chunk size lines.\n         */\n        return APR_EINVAL;\n    }\n    else {\n        ctx->state = BODY_CHUNK_PART;\n    }\n    ctx->remaining = 0;\n    /* The maximum number of bits that can be handled in a\n     * chunk size is in theory sizeof(apr_off_t)*8-1 since\n     * off_t is signed, but use -4 to avoid undefined\n     * behaviour when bitshifting left. */\n    ctx->chunkbits = sizeof(apr_off_t) * 8 - 4;\n    ctx->chunk_used = 0;\n    ctx->chunk_bws = 0;\n}\n\n... \n\nelse if (ctx->state == BODY_CHUNK_PART) {\n    int xvalue;\n\n    /* ignore leading zeros */\n    if (!ctx->remaining && c == '0') {\n        i++;\n        continue;\n    }\n\n    ctx->chunkbits -= 4;\n    if (ctx->chunkbits < 0) {\n        /* overflow */\n        return APR_ENOSPC;\n    }\n\n    if (c >= '0' && c <= '9') {\n        xvalue = c - '0';\n    }\n    else if (c >= 'A' && c <= 'F') {\n        xvalue = c - 'A' + 0xa;\n    }\n    else if (c >= 'a' && c <= 'f') {\n        xvalue = c - 'a' + 0xa;\n    }\n    else {\n        /* bogus character */\n        return APR_EINVAL;\n    }\n\n    ctx->remaining = (ctx->remaining << 4) | xvalue;\n    if (ctx->remaining < 0) {\n        /* Overflow - should be unreachable since the\n         * chunkbits limit will be reached first. */\n        return APR_ENOSPC;\n    }\n}"", 'ctx->chunkbits -= 4;\nif (ctx->chunkbits < 0) {\n    /* overflow */\n    return APR_ENOSPC;\n}']"
12257,222,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.","['if (strict && (ctx->state != BODY_CHUNK_END_LF)) {\n    /* CR missing before LF. */\n    return APR_EINVAL;\n}', '/* Be lenient up to 10 implied *LWS, a legacy of RFC 2616, ... */\nctx->state = BODY_CHUNK_CR;\nif (++ctx->chunk_bws > 10) {\n    return APR_EINVAL;\n}']"
12257,311,"Therefore, recipients MUST anticipate potentially large hexadecimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer representation.",['ctx->chunkbits = sizeof(apr_off_t) * 8 - 4;\n...\nif (ctx->chunkbits < 0) {\n    /* overflow */\n    return APR_ENOSPC;\n}\n\n... (inside BODY_CHUNK_PART) ...\nctx->remaining = (ctx->remaining << 4) | xvalue;']
12257,313,A recipient MUST ignore unrecognized chunk extensions.,"[""else if (c == ';') {\n    ctx->state = BODY_CHUNK_EXT;\n}\nelse if (ctx->state == BODY_CHUNK_EXT) {\n    /*\n     * Control chars (excluding tabs) are invalid.\n     * TODO: more precisely limit input\n     */\n    if (c != '\\t' && apr_iscntrl(c)) {\n        return APR_EINVAL;\n    }\n}""]"
12258,208,A recipient that removes the chunked coding from a message MAY selectively retain or discard the received trailer fields.,"['trailers = apr_table_make(r->pool, 5);\n...\nr->headers_in = trailers;\nap_get_mime_headers(r);\n...\nr->headers_in = saved_headers_in;', 'if (!apr_is_empty_table(trailers)) {\n    e = ap_bucket_headers_create(trailers, r->pool, b->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(b, e);\n}']"
12258,209,A recipient that retains a received trailer field MUST either store/ forward the trailer field separately from the received header fields or merge the received trailer field into the header section.,"['trailers = apr_table_make(r->pool, 5);\nr->headers_in = trailers;\nap_get_mime_headers(r);\nr->headers_in = saved_headers_in;\n\nif (!apr_is_empty_table(trailers)) {\n    e = ap_bucket_headers_create(trailers, r->pool, b->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(b, e);\n}']"
12258,210,A recipient MUST NOT merge a received trailer field into the header section unless its corresponding header field definition explicitly permits and instructs how the trailer field value can be safely merged.,"['trailers = apr_table_make(r->pool, 5);\n...\nsaved_headers_in = r->headers_in;\nr->headers_in = trailers;\nap_get_mime_headers(r);\nr->headers_in = saved_headers_in;']"
12258,267,"However, an origin server MUST NOT use such context information to alter the request semantics.","['request_rec *r = f->r;\napr_table_t *saved_headers_in = r->headers_in;\nint saved_status = r->status;\n\ntrailers = apr_table_make(r->pool, 5);\nr->status = HTTP_OK;\nr->headers_in = trailers;\nap_get_mime_headers(r);\nr->headers_in = saved_headers_in;\n\nif (r->status == HTTP_OK) {\n    r->status = saved_status;\n    ...']"
12259,14,"At the end of a message, a recipient MAY treat the set of received trailer fields as a data structure of name/value pairs, similar to (but separate from) the header fields.","['if (AP_BUCKET_IS_HEADERS(e)) {\n    /* trailers */\n    ap_bucket_headers * hdrs = e->data;\n\n    /* Allow multiple HEADERS buckets carrying trailers here,\n     * will not happen from HTTP/1.x and current H2 implementation,\n     * but is an option. */\n    ctx->at_trailers = 1;\n    if (!apr_is_empty_table(hdrs->headers)) {\n        r->trailers_in = apr_table_overlay(r->pool, r->trailers_in, hdrs->headers);\n    }\n    apr_bucket_delete(e);\n}', 'if (APR_BUCKET_IS_EOS(e)) {\n    ctx->at_eos = 1;\n    if (!apr_is_empty_table(r->trailers_in)) {\n        core_server_config *conf = ap_get_module_config(r->server->module_config, &core_module);\n        if (conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE) {\n            r->headers_in = apr_table_overlay(r->pool, r->headers_in, r->trailers_in);\n        }\n    }\n    goto cleanup;\n}']"
12259,80,* A server that receives a 100-continue expectation in an HTTP/1.0 request MUST ignore that expectation.,"['if (block == APR_BLOCK_READ\n        && r->expecting_100 && r->proto_num >= HTTP_VERSION(1,1)\n        && !(ctx->at_eos || r->eos_sent || r->bytes_sent)) { ... }', 'else {\n    /* https://tools.ietf.org/html/rfc7231#section-5.1.1\n     *   A server MAY omit sending a 100 (Continue) response if it\n     *   has already received some or all of the message body for\n     *   the corresponding request [...] \n     */\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(10260)\n                  ""request body already/partly received while ""\n                  ""100-continue is expected, omit sending interim ""\n                  ""response"");\n    r->expecting_100 = 0;\n}']"
12259,81,"* A server MAY omit sending a 100 (Continue) response if it has already received some or all of the content for the corresponding request, or if the framing indicates that there is no content.","['if (block == APR_BLOCK_READ\n        && r->expecting_100 && r->proto_num >= HTTP_VERSION(1,1)\n        && !(ctx->at_eos || r->eos_sent || r->bytes_sent)) { ... }', 'if (!ctx->seen_data) {\n    int saved_status = r->status;\n    const char *saved_status_line = r->status_line;\n    r->status = HTTP_CONTINUE;\n    r->status_line = NULL;\n    ap_send_interim_response(r, 0);\n    AP_DEBUG_ASSERT(!r->expecting_100);\n    r->status_line = saved_status_line;\n    r->status = saved_status;\n}', 'else {\n    /* https://tools.ietf.org/html/rfc7231#section-5.1.1\n     *   A server MAY omit sending a 100 (Continue) response if it\n     *   has already received some or all of the message body for\n     *   the corresponding request [...]\n     */\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(10260)\n                  ""request body already/partly received while ""\n                  ""100-continue is expected, omit sending interim ""\n                  ""response"");\n    r->expecting_100 = 0;\n}']"
12259,84,The origin server MUST NOT wait for the content before sending the 100 (Continue) response.,"['if (block == APR_BLOCK_READ\n        && r->expecting_100\n        && r->proto_num >= HTTP_VERSION(1,1)\n        && !(ctx->at_eos || r->eos_sent || r->bytes_sent)) {\n    ...\n    else if (!ctx->seen_data) {\n        int saved_status = r->status;\n        const char *saved_status_line = r->status_line;\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                      ""ap_http_in_filter: sending 100-continue"");\n        r->status = HTTP_CONTINUE;\n        r->status_line = NULL;\n        ap_send_interim_response(r, 0);\n        AP_DEBUG_ASSERT(!r->expecting_100);\n        r->status_line = saved_status_line;\n        r->status = saved_status;\n    }']"
12259,140,"Since HTTP/1.0 did not define any 1xx status codes, a server MUST NOT send a 1xx response to an HTTP/1.0 client.","['if (block == APR_BLOCK_READ\n        && r->expecting_100 && r->proto_num >= HTTP_VERSION(1,1)\n        && !(ctx->at_eos || r->eos_sent || r->bytes_sent)) { ... }']"
12259,208,A recipient that removes the chunked coding from a message MAY selectively retain or discard the received trailer fields.,"['if (AP_BUCKET_IS_HEADERS(e)) {\n    /* trailers */\n    ap_bucket_headers * hdrs = e->data;\n\n    /* Allow multiple HEADERS buckets carrying trailers here... */\n    ctx->at_trailers = 1;\n    if (!apr_is_empty_table(hdrs->headers)) {\n        r->trailers_in = apr_table_overlay(r->pool, r->trailers_in, hdrs->headers);\n    }\n    apr_bucket_delete(e);\n}', 'if (APR_BUCKET_IS_EOS(e)) {\n    ctx->at_eos = 1;\n    if (!apr_is_empty_table(r->trailers_in)) {\n        core_server_config *conf = ap_get_module_config(r->server->module_config, &core_module);\n        if (conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE) {\n            r->headers_in = apr_table_overlay(r->pool, r->headers_in, r->trailers_in);\n        }\n    }\n    goto cleanup;\n}']"
12259,209,A recipient that retains a received trailer field MUST either store/ forward the trailer field separately from the received header fields or merge the received trailer field into the header section.,"['if (AP_BUCKET_IS_HEADERS(e)) {\n    /* trailers */\n    ap_bucket_headers * hdrs = e->data;\n    ctx->at_trailers = 1;\n    if (!apr_is_empty_table(hdrs->headers)) {\n        r->trailers_in = apr_table_overlay(r->pool, r->trailers_in, hdrs->headers);\n    }\n    apr_bucket_delete(e);\n}', 'if (APR_BUCKET_IS_EOS(e)) {\n    ctx->at_eos = 1;\n    if (!apr_is_empty_table(r->trailers_in)) {\n        core_server_config *conf = ap_get_module_config(r->server->module_config, &core_module);\n        if (conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE) {\n            r->headers_in = apr_table_overlay(r->pool, r->headers_in, r->trailers_in);\n        }\n    }\n    goto cleanup;\n}']"
12259,210,A recipient MUST NOT merge a received trailer field into the header section unless its corresponding header field definition explicitly permits and instructs how the trailer field value can be safely merged.,"['if (!apr_is_empty_table(r->trailers_in)) {\n    core_server_config *conf = ap_get_module_config(r->server->module_config, &core_module);\n    if (conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE) {\n        r->headers_in = apr_table_overlay(r->pool, r->headers_in, r->trailers_in);\n    }\n}']"
12260,189,A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance.,"['tenc = apr_table_get(f->r->headers_in, ""Transfer-Encoding"");\nif (tenc) {\n    if (ap_is_chunked(f->r->pool, tenc)) {\n        ctx->state = BODY_CHUNK;\n    }\n    ...\n}\n\nswitch (ctx->state) {\n    case BODY_CHUNK:\n    case BODY_CHUNK_PART:\n    case BODY_CHUNK_EXT:\n    case BODY_CHUNK_CR:\n    case BODY_CHUNK_LF:\n    case BODY_CHUNK_END:\n    case BODY_CHUNK_END_LF: {\n        rv = ap_get_brigade(f->next, b, AP_MODE_GETLINE, block, 0);\n        ...\n        rv = parse_chunk_size(ctx, buffer, len, f->r->server->limit_req_fieldsize, strict);\n        ...\n        if (ctx->state == BODY_CHUNK_TRAILER) {\n            return read_chunked_trailers(ctx, f, b);\n        }\n        break;\n    }\n    ...\n}', 'rv = parse_chunk_size(ctx, buffer, len, f->r->server->limit_req_fieldsize, strict);\n...\nif (ctx->state == BODY_CHUNK_TRAILER) {\n    return read_chunked_trailers(ctx, f, b);\n}']"
12260,192,"If any transfer coding other than chunked is applied to a response's content, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection.","['tenc = apr_table_get(f->r->headers_in, ""Transfer-Encoding"");\nif (tenc) {\n    if (ap_is_chunked(f->r->pool, tenc)) {\n        ctx->state = BODY_CHUNK;\n    }\n    else if (f->r->proxyreq == PROXYREQ_RESPONSE) {\n        /* RFC: If a Transfer-Encoding header field is present in a response and the chunked transfer coding is not the final encoding,\n         * the message body length is determined by reading the connection until it is closed by the server. */\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02555)\n                      ""Unknown Transfer-Encoding: %s; using read-until-close"", tenc);\n        tenc = NULL;\n    }\n    else {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)\n                      ""Unknown Transfer-Encoding: %s"", tenc);\n        ap_die(HTTP_NOT_IMPLEMENTED, f->r);\n        return APR_EGENERAL;\n    }\n    lenp = NULL;\n}']"
12260,197,A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 (Not Implemented).,"['if (tenc) {\n    if (ap_is_chunked(f->r->pool, tenc)) {\n        ctx->state = BODY_CHUNK;\n    }\n    else if (f->r->proxyreq == PROXYREQ_RESPONSE) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02555)\n                      ""Unknown Transfer-Encoding: %s; using read-until-close"", tenc);\n        tenc = NULL;\n    }\n    else {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)\n                      ""Unknown Transfer-Encoding: %s"", tenc);\n        ap_die(HTTP_NOT_IMPLEMENTED, f->r);\n        return APR_EGENERAL;\n    }\n    lenp = NULL;\n}']"
12260,202,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,"['tenc = apr_table_get(f->r->headers_in, ""Transfer-Encoding"");\nlenp = apr_table_get(f->r->headers_in, ""Content-Length"");\n\nif (tenc) {\n    if (ap_is_chunked(f->r->pool, tenc)) {\n        ctx->state = BODY_CHUNK;\n    } else if (f->r->proxyreq == PROXYREQ_RESPONSE) {\n        /* Log warning and ignore the transfer encoding for proxied responses */\n        tenc = NULL;\n    } else {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)\n                      ""Unknown Transfer-Encoding: %s"", tenc);\n        ap_die(HTTP_NOT_IMPLEMENTED, f->r);\n        return APR_EGENERAL;\n    }\n    lenp = NULL;\n}']"
12260,206,"The chunked transfer coding wraps content in order to transfer it as a series of chunks, each with its own size indicator, followed by an OPTIONAL trailer section containing trailer fields.","['tenc = apr_table_get(f->r->headers_in, ""Transfer-Encoding"");\nif (tenc) {\n    if (ap_is_chunked(f->r->pool, tenc)) {\n        ctx->state = BODY_CHUNK;\n    }\n    ...', 'rv = parse_chunk_size(ctx, buffer, len,\n        f->r->server->limit_req_fieldsize, strict);', 'if (ctx->state == BODY_CHUNK_TRAILER) {\n    return read_chunked_trailers(ctx, f, b);\n}']"
12260,207,A recipient MUST be able to parse and decode the chunked transfer coding.,"['tenc = apr_table_get(f->r->headers_in, ""Transfer-Encoding"");\nif (tenc) {\n    if (ap_is_chunked(f->r->pool, tenc)) {\n        ctx->state = BODY_CHUNK;\n    } else if (f->r->proxyreq == PROXYREQ_RESPONSE) {\n        ...\n    } else {\n        ...\n    }\n    lenp = NULL;\n}\n\n...\n\ncase BODY_CHUNK:\ncase BODY_CHUNK_PART:\ncase BODY_CHUNK_EXT:\ncase BODY_CHUNK_CR:\ncase BODY_CHUNK_LF:\ncase BODY_CHUNK_END:\ncase BODY_CHUNK_END_LF: {\n    rv = ap_get_brigade(f->next, b, AP_MODE_GETLINE, block, 0);\n    ...\n    rv = parse_chunk_size(ctx, buffer, len,\n            f->r->server->limit_req_fieldsize, strict);\n    ...\n    if (ctx->state == BODY_CHUNK_TRAILER) {\n        return read_chunked_trailers(ctx, f, b);\n    }\n    break;\n}']"
12260,210,A recipient MUST NOT merge a received trailer field into the header section unless its corresponding header field definition explicitly permits and instructs how the trailer field value can be safely merged.,"[""if (ctx->state == BODY_CHUNK_TRAILER) {\n    /* Treat UNSET as DISABLE - trailers aren't merged by default */\n    return read_chunked_trailers(ctx, f, b);\n}""]"
12260,220,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.","['if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n    ctx->remaining = 0;\n    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)\n                  ""Invalid Content-Length"");\n    return APR_EINVAL;\n}', 'if (ctx->limit && ctx->limit < ctx->remaining) {\n    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01588)\n              ""Requested content-length of %"" APR_OFF_T_FMT\n              "" is larger than the configured limit of %"" APR_OFF_T_FMT, ctx->remaining, ctx->limit);\n    return APR_ENOSPC;\n}\n\n...\n\nif (ctx->limit) {\n    ctx->limit_used += totalread;\n    if (ctx->limit < ctx->limit_used) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r,\n                      APLOGNO(01591) ""Read content length of %"" APR_OFF_T_FMT\n                      "" is larger than the configured limit of %"" APR_OFF_T_FMT,\n                      ctx->limit_used, ctx->limit);\n        return APR_ENOSPC;\n    }\n}']"
12260,222,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.","['tenc = apr_table_get(f->r->headers_in, ""Transfer-Encoding"");\nlenp = apr_table_get(f->r->headers_in, ""Content-Length"");\n\nif (tenc) {\n    if (ap_is_chunked(f->r->pool, tenc)) {\n        ctx->state = BODY_CHUNK;\n    }\n    else if (f->r->proxyreq == PROXYREQ_RESPONSE) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02555)\n                      ""Unknown Transfer-Encoding: %s; using read-until-close"", tenc);\n        tenc = NULL;\n    }\n    else {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)\n                      ""Unknown Transfer-Encoding: %s"", tenc);\n        ap_die(HTTP_NOT_IMPLEMENTED, f->r);\n        return APR_EGENERAL;\n    }\n    lenp = NULL;\n}\n\nif (lenp) {\n    ctx->state = BODY_LENGTH;\n    if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n        ctx->remaining = 0;\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)\n                      ""Invalid Content-Length"");\n        return APR_EINVAL;\n    }\n    if (ctx->limit && ctx->limit < ctx->remaining) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01588)\n                      ""Requested content-length of %"" APR_OFF_T_FMT\n                      "" is larger than the configured limit of %"" APR_OFF_T_FMT, ctx->remaining, ctx->limit);\n        return APR_ENOSPC;\n    }\n}', 'else {\n    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)\n                  ""Unknown Transfer-Encoding: %s"", tenc);\n    ap_die(HTTP_NOT_IMPLEMENTED, f->r);\n    return APR_EGENERAL;\n}']"
12260,265,"Since there is no predefined limit to the length of content, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer conversion (Section 17.5).","['if (lenp) {\n    ctx->state = BODY_LENGTH;\n\n    /* Protects against over/underflow, non-digit chars in the\n     * string, leading plus/minus signs, trailing characters and\n     * a negative number.\n     */\n    if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n        ctx->remaining = 0;\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)\n                      ""Invalid Content-Length"");\n\n        return APR_EINVAL;\n    }\n\n    /* If we have a limit in effect and we know the C-L ahead of\n     * time, stop it here if it is invalid.\n     */\n    if (ctx->limit && ctx->limit < ctx->remaining) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01588)\n                  ""Requested content-length of %"" APR_OFF_T_FMT\n                  "" is larger than the configured limit""\n                  "" of %"" APR_OFF_T_FMT, ctx->remaining, ctx->limit);\n        return APR_ENOSPC;\n    }\n}']"
12260,309,"If the sender closes the connection or the recipient times out before the indicated number of octets are received, the recipient MUST consider the message to be incomplete and close the connection","['if (rv == APR_EOF && ctx->state != BODY_NONE && ctx->remaining > 0) {\n    return APR_INCOMPLETE;\n}\n...\ncase BODY_CHUNK:\n    rv = ap_get_brigade(f->next, b, AP_MODE_GETLINE, block, 0);\n    if (rv == APR_EOF) {\n        return APR_INCOMPLETE;\n    }']"
12260,311,"Therefore, recipients MUST anticipate potentially large hexadecimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer representation.","['if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n    ctx->remaining = 0;\n    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)\n                  ""Invalid Content-Length"");\n\n    return APR_EINVAL;\n}', 'rv = parse_chunk_size(ctx, buffer, len,\n                        f->r->server->limit_req_fieldsize, strict);']"
12261,3,"Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message.","['for (pos = *val; *pos; pos = end) {\n    end = ap_scan_http_field_content(pos);\n    if (*end) {\n        if (end[0] != CR || end[1] != LF || (end[2] != \' \' && end[2] != \'\\t\')) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                          ""Response header \'%s\' value of \'%s\' contains invalid characters, aborting request"",\n                          name, pos);\n            return 0;\n        }\n        ...\n    }\n}', 'if (dst) {\n    memcpy(dst, pos, end - pos);\n    dst += end - pos;\n    if (*end) {\n        /* skip folding and replace with a single space */\n        end += 3 + strspn(end + 3, ""\\t "");\n        *dst++ = \' \';\n    }\n}\n...']"
12261,5,"For protocol elements where optional whitespace is preferred to improve readability, a sender SHOULD generate the optional whitespace as a single SP; otherwise, a sender SHOULD NOT generate optional whitespace except as needed to overwrite invalid or unwanted protocol elements during in-place message filtering.","['if (*end) {\n    if (end[0] != CR || end[1] != LF || (end[2] != \' \' && end[2] != \'\\t\')) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                      ""Response header \'%s\' value of \'%s\' contains \n                      invalid characters, aborting request"",\n                      name, pos);\n        return 0;\n    }\n    if (!dst) {\n        *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n    }\n    memcpy(dst, pos, end - pos);\n    dst += end - pos;\n    if (*end) {\n        /* skip folding and replace with a single space */\n        end += 3 + strspn(end + 3, ""\\t "");\n        *dst++ = \' \';\n    }\n}']"
12261,6,A sender SHOULD generate RWS as a single SP.,"[""if (*end) {\n            if (end[0] != CR || end[1] != LF || (end[2] != ' ' &&\n                                                 end[2] != '\\t')) {"", '/* skip folding and replace with a single space */\n                end += 3 + strspn(end + 3, ""\\t "");\n                *dst++ = \' \';']"
12261,7,Any content known to be defined as OWS or RWS MAY be replaced with a single SP before interpreting it or forwarding the message downstream.,"['if (*end) {\n    if (end[0] != CR || end[1] != LF || (end[2] != \' \' && end[2] != \'\\t\')) {\n        ...\n    }\n    if (!dst) {\n        *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n    }\n    ...\n    memcpy(dst, pos, end - pos);\n    dst += end - pos;\n    if (*end) {\n        /* skip folding and replace with a single space */\n        end += 3 + strspn(end + 3, ""\\t "");\n        *dst++ = \' \';\n    }\n}']"
12261,173,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,"['if (*end) {\n    if (end[0] != CR || end[1] != LF || (end[2] != \' \' && end[2] != \'\\t\')) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                      ""Response header \'%s\' value of \'%s\' contains invalid characters, aborting request"",\n                      name, pos);\n        return 0;\n    }\n    if (!dst) {\n        *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n    }\n}', 'if (*end) {\n    ...\n    /* skip folding and replace with a single space */\n    end += 3 + strspn(end + 3, ""\\t "");\n    *dst++ = \' \';\n}']"
12261,174,A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.,"['if (*end) {\n    if (end[0] != CR || end[1] != LF || (end[2] != \' \' &&\n                              end[2] != \'\\t\')) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                      ""Response header \'%s\' value of \'%s\' contains \n                      invalid characters, aborting request"",\n                      name, pos);\n        return 0;\n    }', 'if (!dst) {\n    *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n}\n...\n/* skip folding and replace with a single space */\nend += 3 + strspn(end + 3, ""\\t "");\n*dst++ = \' \';']"
12261,216,"A recipient of ""message/http"" data MUST replace any obsolete line folding with one or more SP characters when the message is consumed.","['if (*end) {\n    if (end[0] != CR || end[1] != LF || (end[2] != \' \' &&\n                                     end[2] != \'\\t\')) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                      ""Response header \'%s\' value of \'%s\' contains ""\n                      ""invalid characters, aborting request"",\n                      name, pos);\n        return 0;\n    }\n    if (!dst) {\n        *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n    }\n}\n...\nif (dst) {\n    memcpy(dst, pos, end - pos);\n    dst += end - pos;\n    if (*end) {\n        /* skip folding and replace with a single space */\n        end += 3 + strspn(end + 3, ""\\t "");\n        *dst++ = \' \';\n    }\n}\nif (dst) {\n    *dst = \'\\0\';\n}']"
12261,217,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,"['if (name[0] == \'\\0\') {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02428)\n                  ""Empty response header name, aborting request"");\n    return 0;\n}\n\nif (ctx->strict) { \n    end = ap_scan_http_token(name);\n} else {\n    end = ap_scan_vchar_obstext(name);\n}\nif (*end) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02429)\n                  ""Response header name \'%s\' contains invalid characters, aborting request"",\n                  name);\n    return 0;\n}', 'for (pos = *val; *pos; pos = end) {\n    end = ap_scan_http_field_content(pos);\n    if (*end) {\n        if (end[0] != CR || end[1] != LF || (end[2] != \' \' && end[2] != \'\\t\')) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                          ""Response header \'%s\' value of \'%s\' contains invalid characters, aborting request"",\n                          name, pos);\n            return 0;\n        }\n        if (!dst) {\n            *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n        }\n    }\n    if (dst) {\n        memcpy(dst, pos, end - pos);\n        dst += end - pos;\n        if (*end) {\n            /* skip folding and replace with a single space */\n            end += 3 + strspn(end + 3, ""\\t "");\n            *dst++ = \' \';\n        }\n    }\n}\nif (dst) {\n    *dst = \'\\0\';\n}']"
12261,238,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.","['if (*end) {\n    if (end[0] != CR || end[1] != LF || (end[2] != \' \' && end[2] != \'\\t\')) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                      ""Response header \'%s\' value of \'%s\' contains invalid characters, aborting request"",\n                      name, pos);\n        return 0;\n    }\n    if (!dst) {\n        *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n    }\n}\n...\nif (dst) {\n    memcpy(dst, pos, end - pos);\n    dst += end - pos;\n    if (*end) {\n        /* skip folding and replace with a single space */\n        end += 3 + strspn(end + 3, ""\\t "");\n        *dst++ = \' \';\n    }\n}']"
12261,244,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,"['if (*end) {\n    if (end[0] != CR || end[1] != LF || (end[2] != \' \' && end[2] != \'\\t\')) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                      ""Response header \'%s\' value of \'%s\' contains \n                      invalid characters, aborting request"",\n                      name, pos);\n        return 0;\n    }\n    if (!dst) {\n        *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n    }\n}', 'if (dst) {\n    memcpy(dst, pos, end - pos);\n    dst += end - pos;\n    if (*end) {\n        /* skip folding and replace with a single space */\n        end += 3 + strspn(end + 3, ""\\t "");\n        *dst++ = \' \';\n    }\n}\nif (dst) {\n    *dst = \'\\0\';\n}']"
12261,307,"A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the ""message/http"" media type.","['if (*end) {\n    if (end[0] != CR || end[1] != LF || (end[2] != \' \' && end[2] != \'\\t\')) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                      ""Response header \'%s\' value of \'%s\' contains invalid characters, aborting request"",\n                      name, pos);\n        return 0;\n    }\n    ...\n}', 'if (dst) {\n    memcpy(dst, pos, end - pos);\n    dst += end - pos;\n    if (*end) {\n        /* skip folding and replace with a single space */\n        end += 3 + strspn(end + 3, ""\\t "");\n        *dst++ = \' \';\n    }\n}\n']"
12263,192,"If any transfer coding other than chunked is applied to a response's content, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection.","['if ((val = apr_table_get(r->headers_out, ""Transfer-Encoding""))) { ... }', 'if (!ap_is_chunked(r->pool, val)) {\n    r->connection->keepalive = AP_CONN_CLOSE;\n    return 0;\n}']"
12263,200,A server MAY reject a request that contains both Content-Length and Transfer-Encoding or process such a request in accordance with the Transfer-Encoding alone.,"['if ((val = apr_table_get(r->headers_out, ""Transfer-Encoding""))) {\n    if (apr_table_get(r->headers_out, ""Content-Length"")) {\n        apr_table_unset(r->headers_out, ""Content-Length"");\n        r->connection->keepalive = AP_CONN_CLOSE;\n    }\n    if (!ap_is_chunked(r->pool, val)) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n        return 0;\n    }\n}', 'r->connection->keepalive = AP_CONN_CLOSE;']"
12263,202,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,"['if ((val = apr_table_get(r->headers_out, ""Transfer-Encoding""))) {\n    if (apr_table_get(r->headers_out, ""Content-Length"")) {\n        apr_table_unset(r->headers_out, ""Content-Length"");\n        r->connection->keepalive = AP_CONN_CLOSE;\n    }\n    if (!ap_is_chunked(r->pool, val)) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n        return 0;\n    }\n}']"
12265,5,"For protocol elements where optional whitespace is preferred to improve readability, a sender SHOULD generate the optional whitespace as a single SP; otherwise, a sender SHOULD NOT generate optional whitespace except as needed to overwrite invalid or unwanted protocol elements during in-place message filtering.","['v->iov_base = "": "";\nv->iov_len = sizeof("": "") - 1;']"
12265,6,A sender SHOULD generate RWS as a single SP.,"['v->iov_base = "": "";\nv->iov_len = sizeof("": "") - 1;\n\n/* and in the APR_CHARSET_EBCDIC block:\n   headfield = apr_pstrcat(h->pool, fieldname, "": "", fieldval, CRLF, NULL); */']"
12265,36,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,['v->iov_base = CRLF;\nv->iov_len = sizeof(CRLF) - 1;']
12266,238,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.","[""while (*e == ',' || apr_isspace(*e)) {\n    ++e;\n}""]"
12266,240,"In any production that uses the list construct, a sender MUST NOT generate empty list elements.","[""while (*e == ',' || apr_isspace(*e)) {\n    ++e;\n}\nif (*e == '\\0') {\n    break;\n}""]"
12266,241,"A recipient MUST parse and ignore a reasonable number of empty list elements: enough to handle common mistakes by senders that merge values, but not so much that they could be used as a denial-of-service mechanism.","[""while (*e == ',' || apr_isspace(*e)) {\n    ++e;\n}\nif (*e == '\\0') {\n    break;\n}""]"
12266,244,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,"[""while (*e == ',' || apr_isspace(*e)) {\n    ++e;\n}""]"
12266,245,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,"[""while (*e == ',' || apr_isspace(*e)) {\n    ++e;\n}""]"
12266,261,"Although protocol names are registered with a preferred case, recipients SHOULD use case-insensitive comparison when matching each protocol-name to supported protocols.","['if (*strpp && ap_cstr_casecmp(*strpp, start) == 0) {\n                break;\n            }']"
12267,236,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).","['apr_table_do(uniq_field_values, varies, r->headers_out, ""Vary"", NULL);', 'if (varies->nelts > 0) {\n    apr_table_setn(r->headers_out, ""Vary"",\n                   apr_array_pstrcat(r->pool, varies, \',\'));\n}']"
12268,306,"A server MUST send the space that separates the status-code from the reason-phrase even when the reason-phrase is absent (i.e., the status-line would end with the space).","['if (len >= 4 && ! apr_isspace(r->status_line[3])) {\n    r->status_line = NULL;\n    return APR_EGENERAL;\n}', 'if (len == 3) {\n    r->status_line = apr_pstrcat(r->pool, r->status_line, "" "", NULL);\n    return APR_EGENERAL;\n}']"
12271,34,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,"['ap_set_content_type_ex(r, ""message/http"", 1);']"
12271,125,"Likewise, a server MUST ignore the conditional request header fields defined by this specification when received with a request method that does not involve the selection or modification of a selected representation, such as CONNECT, OPTIONS, or TRACE.","['if (r->method_number != M_TRACE) {\n        return DECLINED;\n    }\n    \n    ...\n    /* Now we recreate the request, and echo it back */\n    bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    apr_brigade_putstrs(bb, NULL, NULL, r->the_request, CRLF, NULL);\n    h.pool = r->pool;\n    h.bb = bb;\n    apr_table_do((int (*) (void *, const char *, const char *)) form_header_field, (void *) &h, r->headers_in, NULL);\n    \n    /* No conditional evaluation for preconditions is performed */']"
12271,267,"However, an origin server MUST NOT use such context information to alter the request semantics.","['/* Now we recreate the request, and echo it back */\n\napr_brigade_putstrs(bb, NULL, NULL, r->the_request, CRLF, NULL);\n\napr_table_do((int (*) (void *, const char *, const char *))\n             form_header_field, (void *) &h, r->headers_in, NULL);']"
12271,318,"A server MUST read the entire request message body or close the connection after sending its response; otherwise, the remaining data on a persistent connection would be misinterpreted as the next request.","['if (ap_should_client_block(r)) {\n    if (r->remaining > 0) {\n        if (r->remaining > 65536) {\n            apr_table_setn(r->notes, ""error-notes"",\n                   ""Extended TRACE request bodies cannot exceed 64k\\n"");\n            return HTTP_REQUEST_ENTITY_TOO_LARGE;\n        }\n        bodybuf = (apr_size_t)r->remaining + 32;\n    } else {\n        bodybuf = 73730;\n    }\n\n    bodyoff = bodyread = apr_palloc(r->pool, bodybuf);\n\n    while ((!bodylen || bodybuf >= 32) &&\n           (res = ap_get_client_block(r, bodyoff, bodybuf)) > 0) {\n        bodylen += res;\n        bodybuf -= res;\n        bodyoff += res;\n    }\n    if (res > 0 && bodybuf < 32) {\n        while (ap_get_client_block(r, bodyread, bodylen) > 0)\n            ;\n        apr_table_setn(r->notes, ""error-notes"",\n               ""Extended TRACE request bodies cannot exceed 64k\\n"");\n        return HTTP_REQUEST_ENTITY_TOO_LARGE;\n    }\n\n    if (res < 0) {\n        return HTTP_BAD_REQUEST;\n    }\n}']"
12272,61,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,"['if (ctx->final_status && ctx->final_header_only) {\n    for (e = bcontent ? bcontent : APR_BRIGADE_FIRST(b);\n         e != APR_BRIGADE_SENTINEL(b);\n         e = next)\n    {\n        next = APR_BUCKET_NEXT(e);\n        if (APR_BUCKET_IS_EOS(e)) {\n            eos = e;\n            break;\n        }\n        apr_bucket_delete(e);\n    }\n    if (eos) {\n        ap_remove_output_filter(f);\n    }\n    if (!APR_BRIGADE_EMPTY(b)) {\n        rv = ap_pass_brigade(f->next, b);\n    }\n    r->final_resp_passed = 1;\n    return rv;\n}']"
12272,62,The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request method had been GET,"['if (ctx->final_status && ctx->final_header_only) {\n    for (e = bcontent? bcontent : APR_BRIGADE_FIRST(b);\n         e != APR_BRIGADE_SENTINEL(b);\n         e = next) {\n        next = APR_BUCKET_NEXT(e);\n        if (APR_BUCKET_IS_EOS(e)) {\n            eos = e;\n            break;\n        }\n        apr_bucket_delete(e);\n    }\n    if (eos) {\n        ap_remove_output_filter(f);\n    }\n    if (!APR_BRIGADE_EMPTY(b)) {\n        rv = ap_pass_brigade(f->next, b);\n    }\n    r->final_resp_passed = 1;\n    return rv;\n}', 'if (!ctx->final_status && bcontent) {\n    /* insert the RESPONSE before the first content bucket */\n    respb = create_response_bucket(r, b->bucket_alloc);\n    APR_BUCKET_INSERT_BEFORE(bcontent, respb);\n    ctx->final_status = r->status;\n    ctx->final_header_only = (r->header_only || AP_STATUS_IS_HEADER_ONLY(r->status));\n    r->sent_bodyct = 1;         /* Whatever follows is real body stuff... */\n}\n\n... \n\nmerge_response_headers(r);']"
12272,143,"Since the 205 status code implies that no additional content will be provided, a server MUST NOT generate content in a 205 response.","['if (ctx->final_status && ctx->final_header_only) {\n    for (e = bcontent ? bcontent : APR_BRIGADE_FIRST(b);\n         e != APR_BRIGADE_SENTINEL(b);\n         e = next) {\n         next = APR_BUCKET_NEXT(e);\n         if (APR_BUCKET_IS_EOS(e)) {\n             eos = e;\n             break;\n         }\n         apr_bucket_delete(e);\n    }\n    if (eos) {\n         ap_remove_output_filter(f);\n    }\n    if (!APR_BRIGADE_EMPTY(b)) {\n         rv = ap_pass_brigade(f->next, b);\n    }\n    r->final_resp_passed = 1;\n    return rv;\n}']"
12272,209,A recipient that retains a received trailer field MUST either store/ forward the trailer field separately from the received header fields or merge the received trailer field into the header section.,"['if (eos) {\n    e = create_trailers_bucket(r, b->bucket_alloc);\n    if (e) {\n        APR_BUCKET_INSERT_BEFORE(eos, e);\n    }\n    ap_remove_output_filter(f);\n}']"
12272,210,A recipient MUST NOT merge a received trailer field into the header section unless its corresponding header field definition explicitly permits and instructs how the trailer field value can be safely merged.,"['if (eos) {\n    e = create_trailers_bucket(r, b->bucket_alloc);\n    if (e) {\n        APR_BUCKET_INSERT_BEFORE(eos, e);\n    }\n    ap_remove_output_filter(f);\n}']"
12273,59,An origin server that receives a request method that is unrecognized or not implemented SHOULD respond with the 501 (Not Implemented) status code.,['case APR_ENOTIMPL:\n        return HTTP_NOT_IMPLEMENTED;']
12274,318,"A server MUST read the entire request message body or close the connection after sending its response; otherwise, the remaining data on a persistent connection would be misinterpreted as the next request.","['for (;;) {\n    apr_status_t rv;\n\n    rv = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,\n                        APR_BLOCK_READ, HUGE_STRING_LEN);\n    if (rv != APR_SUCCESS) {\n        rc = ap_map_http_request_error(rv, HTTP_BAD_REQUEST);\n        goto cleanup;\n    }\n\n    while (!APR_BRIGADE_EMPTY(bb)) {\n        apr_bucket *b = APR_BRIGADE_FIRST(bb);\n\n        if (APR_BUCKET_IS_EOS(b)) {\n            goto cleanup;\n        }\n\n        if (b->length == (apr_size_t)-1) {\n            apr_size_t len;\n            const char *data;\n            rv = apr_bucket_read(b, &data, &len, APR_BLOCK_READ);\n            if (rv != APR_SUCCESS) {\n                rc = HTTP_BAD_REQUEST;\n                goto cleanup;\n            }\n        }\n\n        apr_bucket_delete(b);\n    }\n}']"
12275,205,A server MAY reject a request that contains a message body but not a Content-Length by responding with 411 (Length Required).,"['if (r->body_indeterminate) {\n    if (r->read_body == REQUEST_CHUNKED_ERROR) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01593) ""indeterminate request body length forbidden: %s"", r->uri);\n        r->read_chunked = 0;\n        return (lenp) ? HTTP_BAD_REQUEST : HTTP_LENGTH_REQUIRED;\n    }\n    r->read_chunked = 1;\n}']"
12276,81,"* A server MAY omit sending a 100 (Continue) response if it has already received some or all of the content for the corresponding request, or if the framing indicates that there is no content.","['if (r->read_length || ...)', '(!r->read_chunked && (r->remaining <= 0))', 'return 0;']"
12278,318,"A server MUST read the entire request message body or close the connection after sending its response; otherwise, the remaining data on a persistent connection would be misinterpreted as the next request.","['if (((ap_bucket_error *)(e->data))->status == HTTP_BAD_GATEWAY ||\n                ((ap_bucket_error *)(e->data))->status == HTTP_GATEWAY_TIME_OUT) {\n    r->connection->keepalive = AP_CONN_CLOSE;\n}\n\n...\n\nif (AP_BUCKET_IS_EOC(e)) {\n    r->connection->keepalive = AP_CONN_CLOSE;\n    ctx->seen_eoc = 1;\n}', 'if (ctx->seen_eoc) {\n    ...\n    e = APR_BRIGADE_FIRST(b);\n    while (e != APR_BRIGADE_SENTINEL(b)) {\n        apr_bucket *c = e;\n        e = APR_BUCKET_NEXT(e);\n        if (!APR_BUCKET_IS_METADATA(c)) {\n            apr_bucket_delete(c);\n        }\n    }\n}']"
12278,321,"Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.","['if (AP_BUCKET_IS_EOC(e)) {\n    r->connection->keepalive = AP_CONN_CLOSE;\n    ctx->seen_eoc = 1;\n}', 'r->connection->keepalive = AP_CONN_CLOSE;']"
12278,322,"A client, server, or proxy MAY close the transport connection at any time.","['if (((ap_bucket_error *)(e->data))->status == HTTP_BAD_GATEWAY ||\n                ((ap_bucket_error *)(e->data))->status == HTTP_GATEWAY_TIME_OUT) {\n                /* stream aborted and we have not ended it yet */\n                r->connection->keepalive = AP_CONN_CLOSE;\n            }', 'if (AP_BUCKET_IS_EOC(e)) {\n                r->connection->keepalive = AP_CONN_CLOSE;\n                ctx->seen_eoc = 1;\n            }']"
12278,326,The server MUST NOT process any further requests received on that connection.,"['if (((ap_bucket_error *)(e->data))->status == HTTP_BAD_GATEWAY ||\n    ((ap_bucket_error *)(e->data))->status == HTTP_GATEWAY_TIME_OUT) {\n    /* stream aborted and we have not ended it yet */\n    r->connection->keepalive = AP_CONN_CLOSE;\n}', 'if (AP_BUCKET_IS_EOC(e)) {\n    r->connection->keepalive = AP_CONN_CLOSE;\n    ctx->seen_eoc = 1;\n}\n...\nif (ctx->seen_eoc) {\n    ...\n    while (e != APR_BRIGADE_SENTINEL(b)) {\n        apr_bucket *c = e;\n        e = APR_BUCKET_NEXT(e);\n        if (!APR_BUCKET_IS_METADATA(c)) {\n            apr_bucket_delete(c);\n        }\n    }\n}']"
12278,327,"A server that sends a ""close"" connection option MUST initiate closure of the connection (see below) after it sends the response containing the ""close"" connection option.","['if (AP_BUCKET_IS_EOC(e)) {\n    r->connection->keepalive = AP_CONN_CLOSE;\n    ctx->seen_eoc = 1;\n}', 'if (((ap_bucket_error *)(e->data))->status == HTTP_BAD_GATEWAY ||\n    ((ap_bucket_error *)(e->data))->status == HTTP_GATEWAY_TIME_OUT) {\n  r->connection->keepalive = AP_CONN_CLOSE;\n}']"
12278,328,The server MUST NOT process any further requests received on that connection.,['if (((ap_bucket_error *)(e->data))->status == HTTP_BAD_GATEWAY ||\n                ((ap_bucket_error *)(e->data))->status == HTTP_GATEWAY_TIME_OUT) {\n                /* stream aborted and we have not ended it yet */\n                r->connection->keepalive = AP_CONN_CLOSE;\n            }\n            \n            ...\n            if (AP_BUCKET_IS_EOC(e)) {\n                r->connection->keepalive = AP_CONN_CLOSE;\n                ctx->seen_eoc = 1;\n            }']
12279,5,"For protocol elements where optional whitespace is preferred to improve readability, a sender SHOULD generate the optional whitespace as a single SP; otherwise, a sender SHOULD NOT generate optional whitespace except as needed to overwrite invalid or unwanted protocol elements during in-place message filtering.","['vec[1].iov_base = (void *)"" "";\nvec[1].iov_len  = sizeof("" "") - 1;']"
12279,6,A sender SHOULD generate RWS as a single SP.,"['vec[1].iov_base = (void *)"" "";\nvec[1].iov_len  = sizeof("" "") - 1;']"
12279,89,An origin server MAY generate a Server header field in its responses.,"['server = apr_table_get(resp->headers, ""Server"");\n    if (server) {\n        /* We always write that second, just because we\n         * always did and some quirky clients might rely on that.\n         */\n        ap_h1_append_header(bb, r->pool, ""Server"", server);\n        apr_table_unset(resp->headers, ""Server"");\n    }']"
12279,173,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,['vec[3].iov_base = (void *)CRLF;\nvec[3].iov_len  = sizeof(CRLF) - 1;']
12279,185,"The first line of a response message is the status-line, consisting of the protocol version, a space (SP), the status code, and another space and ending with an OPTIONAL textual phrase describing the status code.","['vec[0].iov_base = (void *)protocol;\nvec[1].iov_base = (void *)"" "";\nif (resp->reason) {\n    status_line = apr_psprintf(r->pool, ""%d %s"", resp->status, resp->reason);\n}\nelse {\n    status_line = ap_get_status_line_ex(r->pool, resp->status);\n}\nvec[2].iov_base = (void *)(status_line);\nvec[3].iov_base = (void *)CRLF;']"
12280,61,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,"['ctx->discard_body = ctx->final_response_sent &&\n                        (r->header_only || AP_STATUS_IS_HEADER_ONLY(resp->status));', 'else if (ctx->discard_body) {\n    apr_bucket_delete(e);\n}']"
12280,62,The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request method had been GET,"['h1_append_response_head(r, resp, proto, b);\nap_h1_append_headers(b, r, resp->headers);\nap_h1_terminate_header(b);', 'ctx->discard_body = ctx->final_response_sent && (r->header_only || AP_STATUS_IS_HEADER_ONLY(resp->status));\n...\nelse if (ctx->discard_body) {\n    apr_bucket_delete(e);\n}']"
12280,143,"Since the 205 status code implies that no additional content will be provided, a server MUST NOT generate content in a 205 response.",['ctx->discard_body = ctx->final_response_sent && (r->header_only || AP_STATUS_IS_HEADER_ONLY(resp->status));\n...\nelse if (ctx->discard_body) {\n    apr_bucket_delete(e);\n}']
12280,202,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,"['else if (r->chunked) {\n    apr_table_mergen(resp->headers, ""Transfer-Encoding"", ""chunked"");\n    apr_table_unset(resp->headers, ""Content-Length"");\n}']"
12280,317,HTTP implementations SHOULD support persistent connections.,"['if (ctx->final_response_sent) {\n    ap_h1_set_keepalive(r, resp);\n    \n    if (AP_STATUS_IS_HEADER_ONLY(resp->status)) {\n        apr_table_unset(resp->headers, ""Transfer-Encoding"");\n    }\n    else if (r->chunked) {\n        apr_table_mergen(resp->headers, ""Transfer-Encoding"", ""chunked"");\n        apr_table_unset(resp->headers, ""Content-Length"");\n    }\n    \n    // ... eventually adding the CHUNK filter if needed\n    \n    h1_append_response_head(r, resp, proto, b);\n    ap_h1_append_headers(b, r, resp->headers);\n    ap_h1_terminate_header(b);\n}', 'if (r->proto_num == HTTP_VERSION(1,0)\n    && apr_table_get(r->subprocess_env, ""force-response-1.0"")) {\n    r->connection->keepalive = AP_CONN_CLOSE;\n    proto = ""HTTP/1.0"";\n}']"
12282,34,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,"['ctype = ap_make_content_type(r, r->content_type);\n    if (ctype) {\n        apr_table_setn(r->headers_out, ""Content-Type"", ctype);\n    }']"
12282,42,Content-Language MAY be applied to any media type --it is not limited to textual documents.,"['if (!apr_is_empty_array(r->content_languages)) {\n    int i;\n    char *token;\n    char **languages = (char **)(r->content_languages->elts);\n    const char *field = apr_table_get(r->headers_out, ""Content-Language"");\n\n    while (field && (token = ap_get_list_item(r->pool, &field)) != NULL) {\n        for (i = 0; i < r->content_languages->nelts; ++i) {\n            if (!ap_cstr_casecmp(token, languages[i]) )\n                break;\n        }\n        if (i == r->content_languages->nelts) {\n            *((char **) apr_array_push(r->content_languages)) = token;\n        }\n    }\n\n    field = apr_array_pstrcat(r->pool, r->content_languages, \',\');\n    apr_table_setn(r->headers_out, ""Content-Language"", field);\n}']"
12282,43,A server MAY send a Content-Length header field in a response to a HEAD request (Section 9.3.2); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a response if the same request had used the GET method.,"['if (AP_STATUS_IS_HEADER_ONLY(r->status)) {\n    apr_table_unset(r->headers_out, ""Transfer-Encoding"");\n    apr_table_unset(r->headers_out, ""Content-Length"");\n    r->content_type = r->content_encoding = NULL;\n    r->content_languages = NULL;\n    r->clength = r->chunked = 0;\n}']"
12282,195,A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content).,"['if (AP_STATUS_IS_HEADER_ONLY(r->status)) {\n    apr_table_unset(r->headers_out, ""Transfer-Encoding"");\n    apr_table_unset(r->headers_out, ""Content-Length"");\n    r->content_type = r->content_encoding = NULL;\n    r->content_languages = NULL;\n    r->clength = r->chunked = 0;\n}']"
12282,274,"However, a server MAY omit header fields for which a value is determined only while generating the content.","['if (AP_STATUS_IS_HEADER_ONLY(r->status)) {\n    apr_table_unset(r->headers_out, ""Transfer-Encoding"");\n    apr_table_unset(r->headers_out, ""Content-Length"");\n    r->content_type = r->content_encoding = NULL;\n    r->content_languages = NULL;\n    r->clength = r->chunked = 0;\n}']"
12284,209,A recipient that retains a received trailer field MUST either store/ forward the trailer field separately from the received header fields or merge the received trailer field into the header section.,"['if (r->trailers_out && !apr_is_empty_table(r->trailers_out)) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, ""sending trailers"");\n        return ap_bucket_headers_create(r->trailers_out, r->pool, bucket_alloc);\n    }']"
12284,210,A recipient MUST NOT merge a received trailer field into the header section unless its corresponding header field definition explicitly permits and instructs how the trailer field value can be safely merged.,"['if (r->trailers_out && !apr_is_empty_table(r->trailers_out)) {\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, ""sending trailers"");\n    return ap_bucket_headers_create(r->trailers_out, r->pool, bucket_alloc);\n}']"
12285,220,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.","['do {\n    ctx->request_line = NULL;\n    len = 0;\n    rv = ap_rgetline(&ctx->request_line, (apr_size_t)(ctx->r->server->limit_req_line + 2),\n                     &len, ctx->r, strict ? AP_GETLINE_CRLF : 0, bb);\n\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n    else if (len > 0) {\n        return APR_SUCCESS;\n    }\n} while (--num_blank_lines >= 0);', 'rv = ap_rgetline(&ctx->request_line, (apr_size_t)(ctx->r->server->limit_req_line + 2), &len, ctx->r, strict ? AP_GETLINE_CRLF : 0, bb);']"
12285,223,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.","['do {\n    ctx->request_line = NULL;\n    len = 0;\n    rv = ap_rgetline(&ctx->request_line, (apr_size_t)(ctx->r->server->limit_req_line + 2),\n                     &len, ctx->r, strict ? AP_GETLINE_CRLF : 0, bb);\n\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n    else if (len > 0) {\n        return APR_SUCCESS;\n    }\n} while (--num_blank_lines >= 0);\nreturn APR_EINVAL;']"
12285,241,"A recipient MUST parse and ignore a reasonable number of empty list elements: enough to handle common mistakes by senders that merge values, but not so much that they could be used as a denial-of-service mechanism.","['do {\n    ctx->request_line = NULL;\n    len = 0;\n    rv = ap_rgetline(&ctx->request_line, (apr_size_t)(ctx->r->server->limit_req_line + 2),\n                     &len, ctx->r, strict ? AP_GETLINE_CRLF : 0, bb);\n\n    if (rv != APR_SUCCESS) {\n        return rv;\n    } else if (len > 0) {\n        return APR_SUCCESS;\n    }\n} while (--num_blank_lines >= 0);\n\nreturn APR_EINVAL;']"
12287,180,A server that receives a request-target longer than any URI it wishes to parse MUST respond with a 414 (URI Too Long) status code (see Section 15.5.15 of [HTTP]).,['if (APR_STATUS_IS_ENOSPC(rv)) {\n                    http_status = HTTP_REQUEST_URI_TOO_LARGE;\n                }']
12287,217,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,"['if (!ap_h1_tokenize_request_line(r, ctx->request_line, &ctx->method, &ctx->uri, &ctx->protocol)) {\n    http_status = HTTP_BAD_REQUEST;\n    goto cleanup;\n}\n...\n e = ap_bucket_request_createn(ctx->method, ctx->uri, ctx->protocol, r->headers_in, r->pool, r->connection->bucket_alloc);']"
12287,237,"A server MUST NOT apply a request to the target resource until it receives the entire request header section, since later header field lines might include conditionals, authentication credentials, or deliberately misleading duplicate header fields that could impact request processing.","['case REQ_HEADERS:\n    ap_get_mime_headers_core(r, bb);\n    if (r->status != HTTP_OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00567) ""request failed: error reading the headers"");\n        http_status = r->status;\n        goto cleanup;\n    }\n    /* clear the brigade, as ap_get_mime_headers_core() leaves the last\n     * empty line in there */\n    apr_brigade_cleanup(bb);\n    e = ap_bucket_request_createn(ctx->method, ctx->uri,\n                                  ctx->protocol, r->headers_in,\n                                  r->pool, r->connection->bucket_alloc);\n    APR_BRIGADE_INSERT_HEAD(bb, e);\n    ctx->state = REQ_BODY;\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, rv, r,\n                  ""http1 request and headers parsed: %s %s %s"",\n                  ctx->method, ctx->uri, ctx->protocol);\n    goto cleanup;']"
12287,304,"A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain.","['if (!ap_h1_tokenize_request_line(r, ctx->request_line,\n                                             &ctx->method, &ctx->uri, &ctx->protocol)) {\n                http_status = HTTP_BAD_REQUEST;\n                goto cleanup;\n            }', 'if (http_status != HTTP_OK) {\n    /* ... */\n    e = ap_bucket_error_create(http_status, NULL, r->pool,\n                                   f->c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, e);\n    ctx->state = REQ_ERROR;\n    return APR_SUCCESS;\n}']"
12287,316,"A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.","['if ((rv = read_request_line(ctx, bb)) != APR_SUCCESS) {\n    /* certain failures are answered with a HTTP error bucket\n     * and are terminal for parsing a request */\n    ctx->method = ctx->uri = ""-"";\n    ctx->protocol = ""HTTP/1.0"";\n    if (APR_STATUS_IS_ENOSPC(rv)) {\n        http_status = HTTP_REQUEST_URI_TOO_LARGE;\n    }\n    else if (APR_STATUS_IS_TIMEUP(rv)) {\n        http_status = HTTP_REQUEST_TIME_OUT;\n    }\n    else if (APR_STATUS_IS_BADARG(rv)) {\n        http_status = HTTP_BAD_REQUEST;\n    }\n    else if (APR_STATUS_IS_EINVAL(rv)) {\n        http_status = HTTP_BAD_REQUEST;\n    }\n    goto cleanup;\n}', 'if (http_status != HTTP_OK) {\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                  ""failed reading request line, returning error bucket %d"", http_status);\n    apr_brigade_cleanup(bb);\n    e = ap_bucket_error_create(http_status, NULL, r->pool, f->c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, e);\n    ctx->state = REQ_ERROR;\n    return APR_SUCCESS;\n}']"
12288,13,Trailer fields that might be generated more than once during a message MUST be defined as a list-based field even if each member value is only processed once per field line received.,"['if (AP_BUCKET_IS_HEADERS(e)) {\n    ap_bucket_headers *hdrs = e->data;\n    if (!apr_is_empty_table(hdrs->headers)) {\n        if (!ctx->trailers) {\n            ctx->trailers = apr_table_make(f->r->pool, 5);\n        }\n        apr_table_overlap(ctx->trailers, hdrs->headers, APR_OVERLAP_TABLES_MERGE);\n    }\n}']"
12288,36,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,"['hdr_len = apr_snprintf(chunk_hdr, sizeof(chunk_hdr), ""%"" APR_UINT64_T_HEX_FMT CRLF, (apr_uint64_t)bytes);\n...\n e = apr_bucket_immortal_create(CRLF_ASCII, 2, c->bucket_alloc);', 'if (eos && !ctx->bad_gateway_seen) {\n    ap_h1_add_end_chunk(b, eos, f->r, ctx->trailers);\n}']"
12288,173,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,"['hdr_len = apr_snprintf(chunk_hdr, sizeof(chunk_hdr), ""%"" APR_UINT64_T_HEX_FMT CRLF, (apr_uint64_t)bytes);\n...\n e = apr_bucket_immortal_create(CRLF_ASCII, 2, c->bucket_alloc);']"
12288,189,A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance.,"['{\'code\': \'if (bytes > 0) {\\n    ...\\n    hdr_len = apr_snprintf(chunk_hdr, sizeof(chunk_hdr),\\n                           ""%\', \',(apr_uint64_t)bytes); // Actual code for inserting the chunk header with CRLF after the chunk size is computed\\n    ...\\n    ap_xlate_proto_to_ascii(chunk_hdr, hdr_len);\\n    e = apr_bucket_transient_create(chunk_hdr, hdr_len, c->bucket_alloc);\\n    APR_BRIGADE_INSERT_HEAD(b, e);\\n    ...\\n    e = apr_bucket_immortal_create(CRLF_ASCII, 2, c->bucket_alloc);\\n    if (flush != NULL) {\\n         APR_BUCKET_INSERT_BEFORE(flush, e);\\n    } else if (eos != NULL) {\\n         APR_BUCKET_INSERT_BEFORE(eos, e);\\n    } else {\\n         APR_BRIGADE_INSERT_TAIL(b, e);\\n    }\\n    ...\\n    } else { /* no bytes in flush or end-of-stream*/\\n       // continue processing\\n    }  \\n    }  // end of if (bytes > 0)\\n    ""\\n                , ""explanation"": ""This code block computes the size of the data, formats it as a hexadecimal number followed by CRLF, and inserts it into the brigade. This mechanism is central to framing messages in chunked transfer encoding as required by the RFC.""}\': \'\'}', 'if (eos && !ctx->bad_gateway_seen) {\n    ap_h1_add_end_chunk(b, eos, f->r, ctx->trailers);\n}\n']"
12288,192,"If any transfer coding other than chunked is applied to a response's content, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection.","['if (eos && !ctx->bad_gateway_seen) {\n    ap_h1_add_end_chunk(b, eos, f->r, ctx->trailers);\n}', 'hdr_len = apr_snprintf(chunk_hdr, sizeof(chunk_hdr),\n                           ""%"" APR_UINT64_T_HEX_FMT CRLF, (apr_uint64_t)bytes);\n...\n/* Insert the end-of-chunk CRLF before an EOS or FLUSH bucket, or appended to the brigade */\ne = apr_bucket_immortal_create(CRLF_ASCII, 2, c->bucket_alloc);']"
12288,206,"The chunked transfer coding wraps content in order to transfer it as a series of chunks, each with its own size indicator, followed by an OPTIONAL trailer section containing trailer fields.","['hdr_len = apr_snprintf(chunk_hdr, sizeof(chunk_hdr), ""%', 'if (eos && !ctx->bad_gateway_seen) {\n    ap_h1_add_end_chunk(b, eos, f->r, ctx->trailers);\n}']"
12288,217,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,"['{\'code\': \'hdr_len = apr_snprintf(chunk_hdr, sizeof(chunk_hdr), ""%\', \'(apr_uint64_t)bytes);\\n\': \'explanation"": ""The code constructs the chunk header by converting the byte count into a hexadecimal string formatted according to the HTTP chunked transfer coding grammar (i.e., a hexadecimal number followed by CRLF). It then ensures translation to ASCII via ap_xlate_proto_to_ascii, thereby aligning with the ABNF grammar requirements specified (C1).""}\'}']"
12288,223,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.","['if (AP_BUCKET_IS_ERROR(e) &&\n                    (((ap_bucket_error *)(e->data))->status == HTTP_BAD_GATEWAY ||\n                     ((ap_bucket_error *)(e->data))->status == HTTP_GATEWAY_TIME_OUT)) {\n                    /*\n                     * We had a broken backend. Memorize this in the filter\n                     * context.\n                     */\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, f->r,\n                                  ""ap_http_chunk_filter bad gateway error, suppressing end chunk"");\n                    ctx->bad_gateway_seen = 1;\n                    continue;\n                }', 'if (eos && !ctx->bad_gateway_seen) {\n            ap_h1_add_end_chunk(b, eos, f->r, ctx->trailers);\n        }']"
12290,157,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,"['if (custom_response && custom_response[0] != \'""\') {\n    if (ap_is_url(custom_response)) {\n        r->status = HTTP_MOVED_TEMPORARILY;\n        apr_table_setn(r->headers_out, ""Location"", custom_response);\n    } else if (custom_response[0] == \'/\') {\n        // ... internal redirect case\n    } else {\n        // bad URL handling\n    }\n}']"
12290,214,"A server that does not support persistent connections MUST send the ""close"" connection option in every response message that does not have a 1xx (Informational) status code.",['if (ap_status_drops_connection(r->status)) {\n    r->connection->keepalive = AP_CONN_CLOSE;\n}']
12292,172,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.","['else {\n    if (buf[0] == APR_ASCII_LF) {\n        /* consume this LF */\n        mode = AP_MODE_READBYTES;\n        num_blank_lines++;\n    } else if (buf[0] == APR_ASCII_CR) {\n        cr = 1;\n    } ...\n    if (cr) {\n        AP_DEBUG_ASSERT(len == 2 && buf[0] == APR_ASCII_CR);\n        if (buf[1] == APR_ASCII_LF) {\n            /* consume this CRLF */\n            mode = AP_MODE_READBYTES;\n            num_blank_lines++;\n        } else {\n            /* CR not followed by LF, treat as data */\n            break;\n        }\n    }\n}']"
12292,241,"A recipient MUST parse and ignore a reasonable number of empty list elements: enough to handle common mistakes by senders that merge values, but not so much that they could be used as a denial-of-service mechanism.","['if (buf[0] == APR_ASCII_LF) {\n    /* consume this LF */\n    mode = AP_MODE_READBYTES;\n    num_blank_lines++;\n} else if (buf[0] == APR_ASCII_CR) {\n    cr = 1;\n} else {\n    /* Not [CR]LF, some data */\n    break;\n}', ""if (num_blank_lines > max_blank_lines) {\n    /* Enough blank lines with this connection,\n     * stop and don't recycle it.\n     */\n    c->keepalive = AP_CONN_CLOSE;\n    rv = APR_NOTFOUND;\n    break;\n}""]"
12297,209,A recipient that retains a received trailer field MUST either store/ forward the trailer field separately from the received header fields or merge the received trailer field into the header section.,['new->trailers_in     = r->trailers_in;']
12298,209,A recipient that retains a received trailer field MUST either store/ forward the trailer field separately from the received header fields or merge the received trailer field into the header section.,"['r->trailers_out = apr_table_overlay(r->pool, rr->trailers_out,\n                                       r->trailers_out);']"
12309,317,HTTP implementations SHOULD support persistent connections.,"['while ((r = ap_read_request(c)) != NULL) {\n    ...\n    if (c->keepalive != AP_CONN_KEEPALIVE || c->aborted)\n        break;\n    ...\n}', 'apr_socket_timeout_set(csd, keep_alive_timeout);']"
12312,199,A server MUST NOT send a response containing Transfer-Encoding unless the corresponding request indicates HTTP/1.1 (or later minor revisions).,"['if (!strcmp(AP_PROTOCOL_HTTP1, ap_get_protocol(c))) { ... }', 'ap_add_output_filter_handle(ap_h1_response_out_filter_handle, NULL, r, r->connection);']"
12313,191,"If any transfer coding other than chunked is applied to a request's content, the sender MUST apply chunked as the final transfer coding to ensure that the message is properly framed.","['if (tenc) {\n    r->body_indeterminate = 1;\n\n    if (!ap_is_chunked(r->pool, tenc)) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02539)\n                      ""client sent unknown Transfer-Encoding ""\n                      ""(%s): %s"", tenc, r->uri);\n        return HTTP_BAD_REQUEST;\n    }\n\n    if (apr_table_get(r->headers_in, ""Content-Length"")) {\n        apr_table_unset(r->headers_in, ""Content-Length"");\n        r->connection->keepalive = AP_CONN_CLOSE;\n    }\n}']"
12313,200,A server MAY reject a request that contains both Content-Length and Transfer-Encoding or process such a request in accordance with the Transfer-Encoding alone.,"['tenc = apr_table_get(r->headers_in, ""Transfer-Encoding"");\nif (tenc) {\n    r->body_indeterminate = 1;\n\n    if (!ap_is_chunked(r->pool, tenc)) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02539)\n                      ""client sent unknown Transfer-Encoding ""\n                      ""(%s): %s"", tenc, r->uri);\n        return HTTP_BAD_REQUEST;\n    }\n    ...\n}', 'if (apr_table_get(r->headers_in, ""Content-Length"")) {\n    apr_table_unset(r->headers_in, ""Content-Length"");\n    r->connection->keepalive = AP_CONN_CLOSE;\n}']"
12313,202,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,"['if (tenc) {\n    r->body_indeterminate = 1;\n    \n    if (!ap_is_chunked(r->pool, tenc)) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02539)\n                      ""client sent unknown Transfer-Encoding ""\n                      ""(%s): %s"", tenc, r->uri);\n        return HTTP_BAD_REQUEST;\n    }\n\n    if (apr_table_get(r->headers_in, ""Content-Length"")) {\n        apr_table_unset(r->headers_in, ""Content-Length"");\n        r->connection->keepalive = AP_CONN_CLOSE;\n    }\n}']"
12313,217,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,"['if (tenc) {\n    ...\n    if (!ap_is_chunked(r->pool, tenc)) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02539)\n                      ""client sent unknown Transfer-Encoding ""\n                      ""(%s): %s"", tenc, r->uri);\n        return HTTP_BAD_REQUEST;\n    }', 'if (apr_table_get(r->headers_in, ""Content-Length"")) {\n    apr_table_unset(r->headers_in, ""Content-Length"");\n    r->connection->keepalive = AP_CONN_CLOSE;\n}']"
12321,21,"When a field aside from Connection is used to supply control information for or about the current connection, the sender MUST list the corresponding field name within the Connection header field","['if (ka_sent) {\n    if (r->server->keep_alive_max) {\n        apr_table_setn(resp->headers, ""Keep-Alive"",\n               apr_psprintf(r->pool, ""timeout=%d, max=%d"",\n                    (int)apr_time_sec(r->server->keep_alive_timeout),\n                    left));\n    }\n    else {\n        apr_table_setn(resp->headers, ""Keep-Alive"",\n              apr_psprintf(r->pool, ""timeout=%d"",\n                    (int)apr_time_sec(r->server->keep_alive_timeout)));\n    }\n    apr_table_mergen(resp->headers, ""Connection"", ""Keep-Alive"");\n}', 'if (!wimpy) {\n    apr_table_mergen(resp->headers, ""Connection"", ""close"");\n}']"
12321,214,"A server that does not support persistent connections MUST send the ""close"" connection option in every response message that does not have a 1xx (Informational) status code.","['if (!wimpy) {\n    apr_table_mergen(resp->headers, ""Connection"", ""close"");\n}']"
12321,215,"A sender SHOULD send a Connection header field (Section 7.6.1 of [HTTP]) containing the ""close"" connection option when it intends to close a connection.","['if (!wimpy) {\n    apr_table_mergen(resp->headers, ""Connection"", ""close"");\n}']"
12321,222,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.","['if ((r->connection->keepalive != AP_CONN_CLOSE)\n        && !r->expecting_100\n        && (r->header_only\n            || AP_STATUS_IS_HEADER_ONLY(resp->status)\n            || apr_table_get(resp->headers, ""Content-Length"")\n            || ap_is_chunked(r->pool, apr_table_get(resp->headers, ""Transfer-Encoding""))\n            || ((r->proto_num >= HTTP_VERSION(1,1)) && (r->chunked = 1)))\n        && r->server->keep_alive\n        && (r->server->keep_alive_timeout > 0)\n        && ((r->server->keep_alive_max == 0) || (left > 0))\n        && !ap_status_drops_connection(resp->status)\n        && !wimpy\n        && !ap_find_token(r->pool, conn, ""close"")\n        && (!apr_table_get(r->subprocess_env, ""nokeepalive"") || apr_table_get(r->headers_in, ""Via""))\n        && ((ka_sent = ap_find_token(r->pool, conn, ""keep-alive"")) || (r->proto_num >= HTTP_VERSION(1,1)))\n        && is_mpm_running())', 'if (ka_sent) {\n    if (r->server->keep_alive_max) {\n        apr_table_setn(resp->headers, ""Keep-Alive"",\n               apr_psprintf(r->pool, ""timeout=%d, max=%d"",\n                    (int)apr_time_sec(r->server->keep_alive_timeout), left));\n    }\n    else {\n        apr_table_setn(resp->headers, ""Keep-Alive"",\n              apr_psprintf(r->pool, ""timeout=%d"",\n                    (int)apr_time_sec(r->server->keep_alive_timeout)));\n    }\n    apr_table_mergen(resp->headers, ""Connection"", ""Keep-Alive"");\n}']"
12321,278,"* A server that responds with a final status code before reading the entire request content SHOULD indicate whether it intends to close the connection (e.g., see Section 9.6 of [HTTP/1.1]) or continue reading the request content.","['if ((r->connection->keepalive != AP_CONN_CLOSE)\n    && !r->expecting_100\n    && (r->header_only\n        || AP_STATUS_IS_HEADER_ONLY(resp->status)\n        || apr_table_get(resp->headers, ""Content-Length"")\n        || ap_is_chunked(r->pool,\n                         apr_table_get(resp->headers, ""Transfer-Encoding""))\n        || ((r->proto_num >= HTTP_VERSION(1,1))\n            && (r->chunked = 1)))\n    && r->server->keep_alive\n    && (r->server->keep_alive_timeout > 0)\n    && ((r->server->keep_alive_max == 0)\n        || (left > 0))\n    && !ap_status_drops_connection(resp->status)\n    && !wimpy\n    && !ap_find_token(r->pool, conn, ""close"")\n    && (!apr_table_get(r->subprocess_env, ""nokeepalive"")\n        || apr_table_get(r->headers_in, ""Via""))\n    && ((ka_sent = ap_find_token(r->pool, conn, ""keep-alive""))\n        || (r->proto_num >= HTTP_VERSION(1,1)))\n    && is_mpm_running()) {\n\n    r->connection->keepalive = AP_CONN_KEEPALIVE;\n    r->connection->keepalives++;\n\n    if (ka_sent) {\n        if (r->server->keep_alive_max) {\n            apr_table_setn(resp->headers, ""Keep-Alive"",\n                   apr_psprintf(r->pool, ""timeout=%d, max=%d"",\n                        (int)apr_time_sec(r->server->keep_alive_timeout),\n                        left));\n        }\n        else {\n            apr_table_setn(resp->headers, ""Keep-Alive"",\n                  apr_psprintf(r->pool, ""timeout=%d"",\n                        (int)apr_time_sec(r->server->keep_alive_timeout)));\n        }\n        apr_table_mergen(resp->headers, ""Connection"", ""Keep-Alive"");\n    }\n\n    return 1;\n}\n\nif (!wimpy) {\n    apr_table_mergen(resp->headers, ""Connection"", ""close"");\n}']"
12321,317,HTTP implementations SHOULD support persistent connections.,"['if ((r->connection->keepalive != AP_CONN_CLOSE)\n    && !r->expecting_100\n    && (r->header_only\n        || AP_STATUS_IS_HEADER_ONLY(resp->status)\n        || apr_table_get(resp->headers, ""Content-Length"")\n        || ap_is_chunked(r->pool, apr_table_get(resp->headers, ""Transfer-Encoding""))\n        || ((r->proto_num >= HTTP_VERSION(1,1)) && (r->chunked = 1)))\n    && r->server->keep_alive\n    && (r->server->keep_alive_timeout > 0)\n    && ((r->server->keep_alive_max == 0) || (left > 0))\n    && !ap_status_drops_connection(resp->status)\n    && !wimpy\n    && !ap_find_token(r->pool, conn, ""close"")\n    && (!apr_table_get(r->subprocess_env, ""nokeepalive"") || apr_table_get(r->headers_in, ""Via""))\n    && ((ka_sent = ap_find_token(r->pool, conn, ""keep-alive"")) || (r->proto_num >= HTTP_VERSION(1,1)))\n    && is_mpm_running()) { ... }', 'r->connection->keepalive = AP_CONN_KEEPALIVE;\nr->connection->keepalives++;\n\nif (ka_sent) {\n    if (r->server->keep_alive_max) {\n        apr_table_setn(resp->headers, ""Keep-Alive"",\n           apr_psprintf(r->pool, ""timeout=%d, max=%d"",\n                (int)apr_time_sec(r->server->keep_alive_timeout),\n                left));\n    }\n    else {\n        apr_table_setn(resp->headers, ""Keep-Alive"",\n           apr_psprintf(r->pool, ""timeout=%d"",\n                (int)apr_time_sec(r->server->keep_alive_timeout)));\n    }\n    apr_table_mergen(resp->headers, ""Connection"", ""Keep-Alive"");\n}']"
12321,324,"A server that receives a ""close"" connection option MUST initiate closure of the connection (see below) after it sends the final response to the request that contained the ""close"" connection option","['conn = apr_table_get(r->headers_in, ""Connection"");\n...\n&& !ap_find_token(r->pool, conn, ""close"")', 'if (!wimpy) {\n    apr_table_mergen(resp->headers, ""Connection"", ""close"");\n}\n...\nupdate_keepalives:\n    /* ... */\n    r->connection->keepalive = AP_CONN_CLOSE;']"
12321,325,"The server SHOULD send a ""close"" connection option in its final response on that connection.","['if (!wimpy) {\n    apr_table_mergen(resp->headers, ""Connection"", ""close"");\n}\n\n...\n\nr->connection->keepalive = AP_CONN_CLOSE;']"
12321,326,The server MUST NOT process any further requests received on that connection.,"['if (!wimpy) {\n    apr_table_mergen(resp->headers, ""Connection"", ""close"");\n}\n\n...\nupdate_keepalives:\n    ...\n    r->connection->keepalive = AP_CONN_CLOSE;']"
12321,327,"A server that sends a ""close"" connection option MUST initiate closure of the connection (see below) after it sends the response containing the ""close"" connection option.","['if (!wimpy) {\n    apr_table_mergen(resp->headers, ""Connection"", ""close"");\n}\n...\nupdate_keepalives:\n    if ((r->connection->keepalive != AP_CONN_CLOSE)\n        && r->server->keep_alive_max\n        && !left) {\n        r->connection->keepalives++;\n    }\n    r->connection->keepalive = AP_CONN_CLOSE;']"
12321,328,The server MUST NOT process any further requests received on that connection.,"['if (!wimpy) {\n    apr_table_mergen(resp->headers, ""Connection"", ""close"");\n}\n\n...\n\nupdate_keepalives:\n    if ((r->connection->keepalive != AP_CONN_CLOSE)\n        && r->server->keep_alive_max\n        && !left) {\n        r->connection->keepalives++;\n    }\n    r->connection->keepalive = AP_CONN_CLOSE;\n\n    return 0;']"
12323,97,"An origin server MUST use the strong comparison function when comparing entity tags for If-Match (Section 8.8.3.2), since the client intends this precondition to prevent the method from being applied if there have been any changes to the representation data.","['if ((if_match = apr_table_get(r->headers_in, ""If-Match"")) != NULL) {\n    if (if_match[0] == \'*\'\n         || ((etag = apr_table_get(headers, ""ETag"")) != NULL\n             && ap_find_etag_strong(r->pool, if_match, etag))) {\n        return AP_CONDITION_STRONG;\n    } else {\n        return AP_CONDITION_NOMATCH;\n    }\n}\n\nreturn AP_CONDITION_NONE;']"
12323,98,"When an origin server receives a request that selects a representation and that request includes an If-Match header field, the origin server MUST evaluate the If-Match condition per Section 13.2 prior to performing the method.","['if ((if_match = apr_table_get(r->headers_in, ""If-Match"")) != NULL) { ... if (if_match[0] == \'*\') { ... }', '((etag = apr_table_get(headers, ""ETag"")) != NULL && ap_find_etag_strong(r->pool, if_match, etag))']"
12323,99,An origin server that evaluates an If-Match condition MUST NOT perform the requested method if the condition evaluates to false,"[""if (if_match[0] == '*')"", '((etag = apr_table_get(headers, ""ETag"")) != NULL && ap_find_etag_strong(r->pool, if_match, etag))']"
12323,222,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.","['if ((if_match = apr_table_get(r->headers_in, ""If-Match"")) != NULL)', 'if (if_match[0] == \'*\' || ((etag = apr_table_get(headers, ""ETag"")) != NULL && ap_find_etag_strong(r->pool, if_match, etag)))']"
12324,223,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.","['mtime = apr_time_sec(apr_date_parse_http(apr_table_get(headers, ""Last-Modified"")));\nif (mtime == APR_DATE_BAD) {\n    mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n}', 'reqtime = apr_time_sec(apr_date_parse_http(apr_table_get(headers, ""Date"")));\nif (!reqtime) {\n    reqtime = apr_time_sec(r->request_time);\n}']"
12326,223,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.","['mtime = apr_time_sec(apr_date_parse_http(apr_table_get(headers, ""Last-Modified"")));\nif (mtime == APR_DATE_BAD) {\n    mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n}', 'reqtime = apr_time_sec(apr_date_parse_http(apr_table_get(headers, ""Date"")));\nif (!reqtime) {\n    reqtime = apr_time_sec(r->request_time);\n}']"
12327,119,A server MUST ignore an If-Range header field received in a request that does not contain a Range header field.,"['if ((if_range = apr_table_get(r->headers_in, ""If-Range"")) && apr_table_get(r->headers_in, ""Range"")) {']"
12327,122,A recipient of an If-Range header field MUST ignore the Range header field if the If-Range condition evaluates to false.,"['if (if_range[0] == \'""\') {\n    if ((etag = apr_table_get(headers, ""ETag"")) && !strcmp(if_range, etag)) {\n        return AP_CONDITION_STRONG;\n    } else {\n        return AP_CONDITION_NOMATCH;\n    }\n}', 'else {\n    apr_int64_t mtime;\n    apr_int64_t rtime, reqtime;\n\n    mtime = apr_time_sec(apr_date_parse_http(apr_table_get(headers, ""Last-Modified"")));\n    if (mtime == APR_DATE_BAD) {\n        mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n    }\n\n    reqtime = apr_time_sec(apr_date_parse_http(apr_table_get(headers, ""Date"")));\n    if (!reqtime) {\n        reqtime = apr_time_sec(r->request_time);\n    }\n\n    rtime = apr_time_sec(apr_date_parse_http(if_range));\n\n    if (rtime == mtime) {\n        if (reqtime < mtime + 60) {\n            return AP_CONDITION_NOMATCH;\n        } else {\n            return AP_CONDITION_STRONG;\n        }\n    } else {\n        return AP_CONDITION_NOMATCH;\n    }\n}', 'return AP_CONDITION_NOMATCH;']"
12327,123,"Otherwise, the recipient SHOULD process the Range header field as requested.","['if (if_range[0] == \'""\') {\n    if ((etag = apr_table_get(headers, ""ETag"")) && !strcmp(if_range, etag)) {\n        return AP_CONDITION_STRONG;\n    }\n    else {\n        return AP_CONDITION_NOMATCH;\n    }\n}', 'else {\n    apr_int64_t mtime;\n    apr_int64_t rtime, reqtime;\n    mtime = apr_time_sec(apr_date_parse_http(apr_table_get(headers, ""Last-Modified"")));\n    if (mtime == APR_DATE_BAD) {\n        mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n    }\n    reqtime = apr_time_sec(apr_date_parse_http(apr_table_get(headers, ""Date"")));\n    if (!reqtime) {\n        reqtime = apr_time_sec(r->request_time);\n    }\n    rtime = apr_time_sec(apr_date_parse_http(if_range));\n    if (rtime == mtime) {\n        if (reqtime < mtime + 60) {\n            return AP_CONDITION_NOMATCH;\n        }\n        else {\n            return AP_CONDITION_STRONG;\n        }\n    }\n    else {\n        return AP_CONDITION_NOMATCH;\n    }\n}']"
12327,223,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.","['mtime = apr_time_sec(apr_date_parse_http(apr_table_get(headers, ""Last-Modified"")));\nif (mtime == APR_DATE_BAD) {\n    mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n}\n\nreqtime = apr_time_sec(apr_date_parse_http(apr_table_get(headers, ""Date"")));\nif (!reqtime) {\n    reqtime = apr_time_sec(r->request_time);\n}', 'if ((if_range = apr_table_get(r->headers_in, ""If-Range"")) && apr_table_get(r->headers_in, ""Range"")) {\n    if (if_range[0] == \'""\') {\n        if ((etag = apr_table_get(headers, ""ETag"")) && !strcmp(if_range, etag)) {\n            return AP_CONDITION_STRONG;\n        } else {\n            return AP_CONDITION_NOMATCH;\n        }\n    } else {\n        ...\n        if (rtime == mtime) {\n            if (reqtime < mtime + 60) {\n                return AP_CONDITION_NOMATCH;\n            } else {\n                return AP_CONDITION_STRONG;\n            }\n        } else {\n            return AP_CONDITION_NOMATCH;\n        }\n    }\n}']"
12327,282,"For historical reasons, a sender MUST only generate the quoted-string syntax.","['if (if_range[0] == \'""\') {\n\n    if ((etag = apr_table_get(headers, ""ETag"")) && !strcmp(if_range, etag)) {\n        return AP_CONDITION_STRONG;\n    }\n    else {\n        return AP_CONDITION_NOMATCH;\n    }\n\n}\nelse {\n    // Parsing as HTTP-date fallback, supporting interoperability with clients sending token/date syntax\n    apr_int64_t mtime;\n    apr_int64_t rtime, reqtime;\n    mtime = apr_time_sec(apr_date_parse_http(apr_table_get(headers, ""Last-Modified"")));\n    if (mtime == APR_DATE_BAD) {\n        mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n    }\n    reqtime = apr_time_sec(apr_date_parse_http(apr_table_get(headers, ""Date"")));\n    if (!reqtime) {\n        reqtime = apr_time_sec(r->request_time);\n    }\n    rtime = apr_time_sec(apr_date_parse_http(if_range));\n    if (rtime == mtime) {\n        if (reqtime < mtime + 60) {\n            return AP_CONDITION_NOMATCH;\n        }\n        else {\n            return AP_CONDITION_STRONG;\n        }\n    }\n    else {\n        return AP_CONDITION_NOMATCH;\n    }\n}']"
12328,97,"An origin server MUST use the strong comparison function when comparing entity tags for If-Match (Section 8.8.3.2), since the client intends this precondition to prevent the method from being applied if there have been any changes to the representation data.","['cond = ap_condition_if_match(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        return HTTP_PRECONDITION_FAILED;\n    }']"
12328,98,"When an origin server receives a request that selects a representation and that request includes an If-Match header field, the origin server MUST evaluate the If-Match condition per Section 13.2 prior to performing the method.","['cond = ap_condition_if_match(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        return HTTP_PRECONDITION_FAILED;\n    }']"
12328,99,An origin server that evaluates an If-Match condition MUST NOT perform the requested method if the condition evaluates to false,"['cond = ap_condition_if_match(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        return HTTP_PRECONDITION_FAILED;\n    }']"
12328,100,"Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code","['cond = ap_condition_if_match(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    return HTTP_PRECONDITION_FAILED;\n}', 'cond = ap_condition_if_unmodified_since(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    not_modified = 0;\n}\nelse if (cond >= AP_CONDITION_WEAK) {\n    return HTTP_PRECONDITION_FAILED;\n}\n\n...\n\ncond = ap_condition_if_none_match(r, r->headers_out);\nif (AP_CONDITION_NOMATCH != cond && cond >= AP_CONDITION_WEAK && r->method_number != M_GET) {\n    return HTTP_PRECONDITION_FAILED;\n}']"
12328,103,"When an origin server receives a request that selects a representation and that request includes an If-None-Match header field, the origin server MUST evaluate the If-None-Match condition per Section 13.2 prior to performing the method.","['/* If an If-None-Match request-header field was given\n * AND the field value is ""*"" (meaning match anything)\n *     OR our ETag matches any of the entity tags in that field, fail.\n *\n * If the request method was GET or HEAD, failure means the server\n *    SHOULD respond with a 304 (Not Modified) response.\n * For all other request methods, failure means the server MUST\n *    respond with a status of 412 (Precondition Failed).\n *\n * GET or HEAD allow weak etag comparison, all other methods require\n * strong comparison.  We can only use weak if it\'s not a range request.\n */\ncond = ap_condition_if_none_match(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    not_modified = 0;\n}\nelse if (cond >= AP_CONDITION_WEAK) {\n    if (r->method_number == M_GET) {\n        if (not_modified) {\n            not_modified = 1;\n        }\n    }\n    else {\n        return HTTP_PRECONDITION_FAILED;\n    }\n}']"
12328,115,"When an origin server receives a request that selects a representation and that request includes an If-Unmodified-Since header field without an If-Match header field, the origin server MUST evaluate the If-Unmodified-Since condition per Section 13.2 prior to performing the method.","['cond = ap_condition_if_unmodified_since(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    not_modified = 0;\n}\nelse if (cond >= AP_CONDITION_WEAK) {\n    return HTTP_PRECONDITION_FAILED;\n}', 'return HTTP_PRECONDITION_FAILED;']"
12328,116,An origin server that evaluates an If-Unmodified-Since condition MUST NOT perform the requested method if the condition evaluates to false,"['cond = ap_condition_if_unmodified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        return HTTP_PRECONDITION_FAILED;\n    }']"
12328,117,"Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code","['cond = ap_condition_if_unmodified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        return HTTP_PRECONDITION_FAILED;\n    }', 'return HTTP_PRECONDITION_FAILED;']"
12328,124,"A server MUST ignore all received preconditions if its response to the same request without those conditions, prior to processing the request content, would have been a status code other than a 2xx (Successful) or 412 (Precondition Failed).",['if (!ap_is_HTTP_SUCCESS(r->status) || r->no_local_copy) {\n    return OK;\n}']
12328,222,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.","['cond = ap_condition_if_match(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        return HTTP_PRECONDITION_FAILED;\n    }', 'cond = ap_condition_if_unmodified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        return HTTP_PRECONDITION_FAILED;\n    }', 'cond = ap_condition_if_none_match(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        if (r->method_number == M_GET) {\n            if (not_modified) {\n                not_modified = 1;\n            }\n        }\n        else {\n            return HTTP_PRECONDITION_FAILED;\n        }\n    }', 'cond = ap_condition_if_modified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        if (r->method_number == M_GET) {\n            if (not_modified) {\n                not_modified = 1;\n            }\n        }\n    }', 'if (not_modified == 1) {\n        return HTTP_NOT_MODIFIED;\n    }\n\n    return OK;']"
12328,289,A recipient cache or origin server MUST evaluate the request preconditions defined by this specification in the following order: 1.,"['cond = ap_condition_if_match(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    return HTTP_PRECONDITION_FAILED;\n}', 'cond = ap_condition_if_unmodified_since(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    not_modified = 0;\n}\nelse if (cond >= AP_CONDITION_WEAK) {\n    return HTTP_PRECONDITION_FAILED;\n}', '/* ... subsequent precondition checks ... */\nif (not_modified == 1) {\n    return HTTP_NOT_MODIFIED;\n}\nreturn OK;']"
12331,58,All general-purpose servers MUST support the methods GET and HEAD,"['register_one_method(p, ""GET"", M_GET);', 'register_one_method(p, ""HEAD"", M_GET);']"
12336,223,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",['return (index < 0) ? LEVEL_500 : index;']
12339,77,"A server generating a successful response to OPTIONS SHOULD send any header that might indicate optional features implemented by the server and applicable to the target resource (e.g., Allow), including potential extensions not defined by this specification.","['for (; hi; hi = apr_hash_next(hi)) {\n    const void *key;\n    void *val;\n\n    apr_hash_this(hi, &key, NULL, &val);\n    if ((mask & (AP_METHOD_BIT << *(int *)val)) != 0) {\n        APR_ARRAY_PUSH(allow, const char *) = key;\n    }\n}', 'if (conf->trace_enable != AP_TRACE_DISABLE)\n    *(const char **)apr_array_push(allow) = ""TRACE"";']"
12339,165,The origin server MUST generate an Allow header field in a 405 response containing a list of the target resource's currently supported methods.,"['mask = r->allowed_methods->method_mask;\nfor (; hi; hi = apr_hash_next(hi)) {\n    const void *key;\n    void *val;\n    apr_hash_this(hi, &key, NULL, &val);\n    if ((mask & (AP_METHOD_BIT << *(int *)val)) != 0) {\n        APR_ARRAY_PUSH(allow, const char *) = key;\n    }\n}', '*(const char **)apr_array_push(allow) = ""TRACE"";\n...\nreturn apr_array_pstrcat(r->pool, allow, \',\');']"
12340,30,A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.,"['if (r->assbackwards) {\n    return DECLINED;\n}\n\napr_table_setn(r->headers_out, ""Allow"", make_allow(r));\n\nreturn OK;']"
12340,77,"A server generating a successful response to OPTIONS SHOULD send any header that might indicate optional features implemented by the server and applicable to the target resource (e.g., Allow), including potential extensions not defined by this specification.","['apr_table_setn(r->headers_out, ""Allow"", make_allow(r));']"
12343,134,"The Accept-Ranges field MAY be sent in a trailer section, but is preferred to be sent as a header field because the information is particularly useful for restarting large information transfers that have failed in mid-content (before the trailer section is received).","['apr_table_setn(r->headers_out, ""Accept-Ranges"", (d->max_ranges == AP_MAXRANGES_NORANGES) ? ""none"" : ""bytes"");']"
12343,217,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,"['apr_table_setn(r->headers_out, ""Accept-Ranges"", (d->max_ranges == AP_MAXRANGES_NORANGES) ? ""none"" : ""bytes"");']"
12343,291,A server that does not support any kind of range request for the target resource MAY send,"['apr_table_setn(r->headers_out, ""Accept-Ranges"", (d->max_ranges == AP_MAXRANGES_NORANGES) ? ""none"" : ""bytes"");']"
12345,39,An origin server MAY respond with a status code of 415 (Unsupported Media Type) if a representation in the request message has a content coding that is not acceptable.,"['case HTTP_UNSUPPORTED_MEDIA_TYPE:\n    return(""<p>The supplied request data is not in a format\\nacceptable for processing by this resource.</p>\\n"");']"
12345,59,An origin server that receives a request method that is unrecognized or not implemented SHOULD respond with the 501 (Not Implemented) status code.,"['case HTTP_NOT_IMPLEMENTED:\n        s1 = apr_pstrcat(p,\n                         ""<p>"",\n                         ap_escape_html(r->pool, r->method),\n                         "" not supported for current URL.<br />\\n"",\n                         NULL);\n        return(add_optional_notes(r, s1, ""error-notes"", ""</p>\\n""));']"
12345,60,"An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.","['case HTTP_METHOD_NOT_ALLOWED:\n        return(apr_pstrcat(p,\n                           ""<p>The requested method "",\n                           ap_escape_html(r->pool, r->method),\n                           "" is not allowed for this URL.</p>\\n"",\n                           NULL));']"
12346,45,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,['if (AP_STATUS_IS_HEADER_ONLY(status)) {\n    ap_finalize_request_protocol(r);\n    return;\n}\n...\n    r->clength = 0;']
12346,61,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,"['if (AP_STATUS_IS_HEADER_ONLY(status)) {\n    ap_finalize_request_protocol(r);\n    return;\n}', 'if (r->header_only) {\n    ap_finalize_request_protocol(r);\n    return;\n}']"
12346,88,An origin server MUST generate an Allow header field in a 405 (Method Not Allowed) response and MAY do so in any other response.,"['if ((status == HTTP_METHOD_NOT_ALLOWED)\n            || (status == HTTP_NOT_IMPLEMENTED)) {\n            apr_table_setn(r->headers_out, ""Allow"", make_allow(r));\n        }']"
12346,157,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,"['if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {\n    if ((location != NULL) && *location) {\n        apr_table_setn(r->headers_out, ""Location"", location);\n    }\n    else {\n        location = """";   /* avoids coredump when printing, below */\n    }\n}']"
12346,159,"Since the goal of a 304 response is to minimize information transfer when the recipient already has one or more cached representations, a sender SHOULD NOT generate representation metadata other than the above listed fields unless said metadata exists for the purpose of guiding cache updates (e.g., Last-Modified might be useful if the response does not have an ETag field).",['if (AP_STATUS_IS_HEADER_ONLY(status)) {\n    ap_finalize_request_protocol(r);\n    return;\n}']
12346,165,The origin server MUST generate an Allow header field in a 405 response containing a list of the target resource's currently supported methods.,"['if ((status == HTTP_METHOD_NOT_ALLOWED)\n            || (status == HTTP_NOT_IMPLEMENTED)) {\n            apr_table_setn(r->headers_out, ""Allow"", make_allow(r));\n        }']"
12346,274,"However, a server MAY omit header fields for which a value is determined only while generating the content.",['if (AP_STATUS_IS_HEADER_ONLY(status)) {\n    ap_finalize_request_protocol(r);\n    return;\n}\n...\nif (r->header_only) {\n    ap_finalize_request_protocol(r);\n    return;\n}']
12346,282,"For historical reasons, a sender MUST only generate the quoted-string syntax.","['if (custom_response[0] == \'""\') {\n            ap_rvputs_proto_in_ascii(r, custom_response + 1, NULL);\n            ap_finalize_request_protocol(r);\n            return;\n        }']"
12346,306,"A server MUST send the space that separates the status-code from the reason-phrase even when the reason-phrase is absent (i.e., the status-line would end with the space).","['if (r->status_line) {\n    ...\n    if (len == 3) {\n        r->status_line = apr_pstrcat(r->pool, r->status_line, "" Unknown Reason"", NULL);\n    } else if (len == 4) {\n        r->status_line = apr_pstrcat(r->pool, r->status_line, ""Unknown Reason"", NULL);\n    }\n    ...\n}']"
12353,5,"For protocol elements where optional whitespace is preferred to improve readability, a sender SHOULD generate the optional whitespace as a single SP; otherwise, a sender SHOULD NOT generate optional whitespace except as needed to overwrite invalid or unwanted protocol elements during in-place message filtering.","['v->iov_base = "": "";\nv->iov_len = sizeof("": "") - 1;']"
12353,6,A sender SHOULD generate RWS as a single SP.,"['In the EBCDIC branch: apr_pstrcat(pool, name, "": "", value, CRLF, NULL);\nIn the non-EBCDIC branch: v->iov_base = "": ""; v->iov_len = sizeof("": "") - 1;']"
12354,5,"For protocol elements where optional whitespace is preferred to improve readability, a sender SHOULD generate the optional whitespace as a single SP; otherwise, a sender SHOULD NOT generate optional whitespace except as needed to overwrite invalid or unwanted protocol elements during in-place message filtering.","['vec_next->iov_base = (void*)("": "");\nvec_next->iov_len = sizeof("": "") - 1;']"
12354,6,A sender SHOULD generate RWS as a single SP.,"['vec_next->iov_base = "": "";\nvec_next->iov_len = sizeof("": "") - 1;']"
12354,36,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,['vec_next->iov_base = CRLF;\nvec_next->iov_len = sizeof(CRLF) - 1;']
12355,36,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,"['char crlf[] = CRLF;\n...\nreturn apr_brigade_write(bb, NULL, NULL, crlf, buflen);']"
12355,217,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,"['char crlf[] = CRLF;\n...\nap_xlate_proto_to_ascii(crlf, buflen);\nreturn apr_brigade_write(bb, NULL, NULL, crlf, buflen);']"
12356,36,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,"['apr_bucket *e;\n\nap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n              ""append empty end chunk"");\ne = apr_bucket_immortal_create(ZERO_ASCII CRLF_ASCII\n                                  CRLF_ASCII, 5, b->bucket_alloc);\n\n...\n\napr_brigade_write(b, NULL, NULL, ZERO_ASCII CRLF_ASCII, 3);']"
12356,173,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,"['e = apr_bucket_immortal_create(ZERO_ASCII CRLF_ASCII CRLF_ASCII, 5, b->bucket_alloc);\n...\napr_brigade_write(b, NULL, NULL, ZERO_ASCII CRLF_ASCII, 3);']"
12356,206,"The chunked transfer coding wraps content in order to transfer it as a series of chunks, each with its own size indicator, followed by an OPTIONAL trailer section containing trailer fields.","['if (!trailers || apr_is_empty_table(trailers)) {\n    ...\n    e = apr_bucket_immortal_create(ZERO_ASCII CRLF_ASCII CRLF_ASCII, 5, b->bucket_alloc);\n    ...\n}', 'else {\n    ...\n    apr_brigade_write(b, NULL, NULL, ZERO_ASCII CRLF_ASCII, 3);\n    ap_h1_append_headers(b, r, trailers);\n    ap_h1_terminate_header(b);\n    ...\n}']"
12356,217,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,"['if (!trailers || apr_is_empty_table(trailers)) {\n    ...\n    e = apr_bucket_immortal_create(ZERO_ASCII CRLF_ASCII CRLF_ASCII, 5, b->bucket_alloc);\n    ...\n} else {\n    ...\n    apr_brigade_write(b, NULL, NULL, ZERO_ASCII CRLF_ASCII, 3);\n    ap_h1_append_headers(b, r, trailers);\n    ap_h1_terminate_header(b);\n    ...\n}']"
12359,5,"For protocol elements where optional whitespace is preferred to improve readability, a sender SHOULD generate the optional whitespace as a single SP; otherwise, a sender SHOULD NOT generate optional whitespace except as needed to overwrite invalid or unwanted protocol elements during in-place message filtering.","[""for (uri = ll; apr_isspace(*uri); ++uri)\n    if (*uri != ' ')\n        RRL_ERROR(e, etoken, rrl_badwhitespace, uri);\n\nfor (protocol = ll; apr_isspace(*protocol); ++protocol)\n    if (*protocol != ' ')\n        RRL_ERROR(e, etoken, rrl_badwhitespace, protocol);"", 'if (strict && ll[0] && apr_isspace(ll[1])) {\n    RRL_ERROR(e, etoken, rrl_excesswhitespace, ll);\n}', 'if (apr_isspace(*method)) {\n    RRL_ERROR(e, etoken, rrl_badwhitespace, method);\n    for ( ; apr_isspace(*method); ++method)\n        ;\n}']"
12359,217,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,"['if (apr_isspace(*method)) {\n    RRL_ERROR(e, etoken, rrl_badwhitespace, method);\n    for ( ; apr_isspace(*method); ++method)\n        ;\n}\n\nif (strict) {\n    ll = (char*) ap_scan_http_token(method);\n}\nelse {\n    ll = (char*) ap_scan_vchar_obstext(method);\n}\n\nif ((ll == method) || (*ll && !apr_isspace(*ll))) {\n    RRL_ERROR(e, etoken, rrl_badmethod, ll);\n    ll = strpbrk(ll, ""\\t\\n\\v\\f\\r "");\n}\n\n... (additional similar checks for URI and protocol tokens)', '/* Verify method terminated with a single SP, or mark as specific error */\nif (!ll) {\n    RRL_ERROR(e, etoken, rrl_missinguri, NULL);\n    protocol = uri = """";\n    goto done;\n}\nelse if (strict && ll[0] && apr_isspace(ll[1])) {\n    RRL_ERROR(e, etoken, rrl_excesswhitespace, ll);\n}\n\n/* Advance uri pointer over leading whitespace, NUL terminate the method */\nfor (uri = ll; apr_isspace(*uri); ++uri)\n    if (*uri != \' \')\n        RRL_ERROR(e, etoken, rrl_badwhitespace, uri);\n*ll = \'\\0\';\n\n... (further checks on URI and protocol using similar error handling)']"
12359,223,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.","['if (apr_isspace(*method)) { RRL_ERROR(e, etoken, rrl_badwhitespace, method); for ( ; apr_isspace(*method); ++method) ; }', 'RRL_ERROR(e, etoken, rrl_badmethod, ll);  ...  if (!ll) { RRL_ERROR(e, etoken, rrl_missinguri, NULL); protocol = uri = """"; goto done; }']"
12359,244,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,"[""if (apr_isspace(*method)) {\n    RRL_ERROR(e, etoken, rrl_badwhitespace, method);\n    for ( ; apr_isspace(*method); ++method)\n        ;\n}\n...\nfor (uri = ll; apr_isspace(*uri); ++uri)\n    if (*uri != ' ')\n        RRL_ERROR(e, etoken, rrl_badwhitespace, uri);"", ""*ll = '\\0';\n...\n*((char *)protocol + len) = '\\0';""]"
