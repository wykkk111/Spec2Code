{
  "metadata": {
    "timestamp": "2025-03-17T15:37:27.781371",
    "num_files": 7,
    "num_functions": 127,
    "files_analyzed": [
      "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c",
      "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/chunk_filter.c",
      "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c",
      "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
      "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
      "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
      "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c"
    ]
  },
  "functions": {
    "ap_set_byterange@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c', line 80, column 12>": {
      "basic_info": {
        "function_id": 1413,
        "name": "ap_set_byterange",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c', line 80, column 12>",
        "is_definition": true,
        "start_line": 80,
        "end_line": 284,
        "return_type": "int",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "clength",
            "type": "apr_off_t"
          },
          {
            "name": "indexes",
            "type": "apr_array_header_t **"
          },
          {
            "name": "overlaps",
            "type": "int *"
          },
          {
            "name": "reversals",
            "type": "int *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "ap_cstr_casecmpn": {
            "declaration": "AP_DECLARE(int) ap_cstr_casecmpn(const char *s1, const char *s2, apr_size_t n)",
            "is_external": true,
            "definition": null
          },
          "ap_condition_if_range": {
            "declaration": "AP_DECLARE(ap_condition_e) ap_condition_if_range(request_rec *r,\n        apr_table_t *headers)",
            "is_external": false,
            "definition": "AP_DECLARE(ap_condition_e) ap_condition_if_range(request_rec *r,\n        apr_table_t *headers)\n{\n    const char *if_range, *etag;\n\n    if ((if_range = apr_table_get(r->headers_in, \"If-Range\"))\n            && apr_table_get(r->headers_in, \"Range\")) {\n        if (if_range[0] == '\"') {\n\n            if ((etag = apr_table_get(headers, \"ETag\"))\n                    && !strcmp(if_range, etag)) {\n                return AP_CONDITION_STRONG;\n            }\n            else {\n                return AP_CONDITION_NOMATCH;\n            }\n\n        }\n        else {\n            apr_int64_t mtime;\n            apr_int64_t rtime, reqtime;\n\n            /* All of our comparisons must be in seconds, because that's the\n             * highest time resolution the HTTP specification allows.\n             */\n\n            mtime = apr_time_sec(apr_date_parse_http(\n                            apr_table_get(headers, \"Last-Modified\")));\n            if (mtime == APR_DATE_BAD) {\n                mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n            }\n\n            reqtime = apr_time_sec(apr_date_parse_http(\n                            apr_table_get(headers, \"Date\")));\n            if (!reqtime) {\n                reqtime = apr_time_sec(r->request_time);\n            }\n\n            rtime = apr_time_sec(apr_date_parse_http(if_range));\n\n            if (rtime == mtime) {\n                if (reqtime < mtime + 60) {\n                    /* weak matches not allowed with Range requests */\n                    return AP_CONDITION_NOMATCH;\n                }\n                else {\n                    return AP_CONDITION_STRONG;\n                }\n            }\n            else {\n                return AP_CONDITION_NOMATCH;\n            }\n        }\n    }\n\n    return AP_CONDITION_NONE;\n}"
          },
          "apr_array_make": {
            "declaration": "APR_DECLARE(apr_array_header_t *) apr_array_make(apr_pool_t *p,\n                                                 int nelts, int elt_size)",
            "is_external": true,
            "definition": null
          },
          "ap_getword": {
            "declaration": "AP_DECLARE(char *) ap_getword(apr_pool_t *p, const char **line, char stop)",
            "is_external": true,
            "definition": null
          },
          "strchr": {
            "declaration": "extern char *strchr (const char *__s, int __c)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "ap_parse_strict_length": {
            "declaration": "AP_DECLARE(int) ap_parse_strict_length(apr_off_t *len, const char *str)",
            "is_external": true,
            "definition": null
          },
          "apr_array_clear": {
            "declaration": "APR_DECLARE(void) apr_array_clear(apr_array_header_t *arr)",
            "is_external": true,
            "definition": null
          },
          "apr_array_push": {
            "declaration": "APR_DECLARE(void *) apr_array_push(apr_array_header_t *arr)",
            "is_external": true,
            "definition": null
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "apr_psprintf": {
            "declaration": "APR_DECLARE_NONSTD(char *) apr_psprintf(apr_pool_t *p, const char *fmt, ...)\n        __attribute__((format(printf,2,3)))",
            "is_external": true,
            "definition": null
          },
          "apr_array_pstrcat": {
            "declaration": "APR_DECLARE(char *) apr_array_pstrcat(apr_pool_t *p,\n\t\t\t\t      const apr_array_header_t *arr,\n\t\t\t\t      const char sep)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_byterange_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c', line 399, column 38>": {
            "source_code": "AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(ap_filter_t *f,\n                                                         apr_bucket_brigade *bb)\n{\n    request_rec *r = f->r;\n    conn_rec *c = r->connection;\n    apr_bucket *e;\n    apr_bucket_brigade *bsend;\n    apr_bucket_brigade *tmpbb;\n    apr_off_t range_start;\n    apr_off_t range_end;\n    apr_off_t clength = 0;\n    apr_status_t rv;\n    int found = 0;\n    int num_ranges;\n    char *bound_head = NULL;\n    apr_array_header_t *indexes;\n    indexes_t *idx;\n    int i;\n    int original_status;\n    int max_ranges, max_overlaps, max_reversals;\n    int overlaps = 0, reversals = 0;\n    core_dir_config *core_conf = ap_get_core_module_config(r->per_dir_config);\n\n    max_ranges = ( (core_conf->max_ranges >= 0 || core_conf->max_ranges == AP_MAXRANGES_UNLIMITED)\n                   ? core_conf->max_ranges\n                   : AP_DEFAULT_MAX_RANGES );\n    max_overlaps = ( (core_conf->max_overlaps >= 0 || core_conf->max_overlaps == AP_MAXRANGES_UNLIMITED)\n                  ? core_conf->max_overlaps\n                  : AP_DEFAULT_MAX_OVERLAPS );\n    max_reversals = ( (core_conf->max_reversals >= 0 || core_conf->max_reversals == AP_MAXRANGES_UNLIMITED)\n                  ? core_conf->max_reversals\n                  : AP_DEFAULT_MAX_REVERSALS );\n    /*\n     * Iterate through the brigade until reaching EOS or a bucket with\n     * unknown length.\n     */\n    for (e = APR_BRIGADE_FIRST(bb);\n         (e != APR_BRIGADE_SENTINEL(bb) && !APR_BUCKET_IS_EOS(e)\n          && e->length != (apr_size_t)-1);\n         e = APR_BUCKET_NEXT(e)) {\n        clength += e->length;\n    }\n\n    /*\n     * Don't attempt to do byte range work if this brigade doesn't\n     * contain an EOS, or if any of the buckets has an unknown length;\n     * this avoids the cases where it is expensive to perform\n     * byteranging (i.e. may require arbitrary amounts of memory).\n     */\n    if (!APR_BUCKET_IS_EOS(e) || clength <= 0) {\n        ap_remove_output_filter(f);\n        return ap_pass_brigade(f->next, bb);\n    }\n\n    original_status = r->status;\n    num_ranges = ap_set_byterange(r, clength, &indexes, &overlaps, &reversals);\n\n    /* No Ranges or we hit a limit? We have nothing to do, get out of the way. */\n    if (num_ranges == 0 ||\n        (max_ranges >= 0 && num_ranges > max_ranges) ||\n        (max_overlaps >= 0 && overlaps > max_overlaps) ||\n        (max_reversals >= 0 && reversals > max_reversals)) {\n        r->status = original_status;\n        ap_remove_output_filter(f);\n        return ap_pass_brigade(f->next, bb);\n    }\n\n    /* this brigade holds what we will be sending */\n    bsend = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    if (num_ranges < 0)\n        return send_416(f, bsend);\n\n    if (num_ranges > 1) {\n        /* Is ap_make_content_type required here? */\n        const char *orig_ct = ap_make_content_type(r, r->content_type);\n\n        ap_set_content_type_ex(r, apr_pstrcat(r->pool,\n                                           \"multipart/byteranges; boundary=\",\n                                           ap_multipart_boundary, NULL), 1);\n\n        if (orig_ct) {\n            bound_head = apr_pstrcat(r->pool,\n                                     CRLF \"--\", ap_multipart_boundary,\n                                     CRLF \"Content-type: \",\n                                     orig_ct,\n                                     CRLF \"Content-range: bytes \",\n                                     NULL);\n        }\n        else {\n            /* if we have no type for the content, do our best */\n            bound_head = apr_pstrcat(r->pool,\n                                     CRLF \"--\", ap_multipart_boundary,\n                                     CRLF \"Content-range: bytes \",\n                                     NULL);\n        }\n        ap_xlate_proto_to_ascii(bound_head, strlen(bound_head));\n    }\n\n    tmpbb = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    idx = (indexes_t *)indexes->elts;\n    for (i = 0; i < indexes->nelts; i++, idx++) {\n        range_start = idx->start;\n        range_end = idx->end;\n\n        rv = copy_brigade_range(bb, tmpbb, range_start, range_end);\n        if (rv != APR_SUCCESS ) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01584)\n                          \"copy_brigade_range() failed [%\" APR_OFF_T_FMT\n                          \"-%\" APR_OFF_T_FMT \",%\" APR_OFF_T_FMT \"]\",\n                          range_start, range_end, clength);\n            continue;\n        }\n        found = 1;\n\n        /*\n         * For single range requests, we must produce Content-Range header.\n         * Otherwise, we need to produce the multipart boundaries.\n         */\n        if (num_ranges == 1) {\n            apr_table_setn(r->headers_out, \"Content-Range\",\n                           apr_psprintf(r->pool, \"bytes \" BYTERANGE_FMT,\n                                        range_start, range_end, clength));\n        }\n        else {\n            char *ts;\n\n            e = apr_bucket_pool_create(bound_head, strlen(bound_head),\n                                       r->pool, c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bsend, e);\n\n            ts = apr_psprintf(r->pool, BYTERANGE_FMT CRLF CRLF,\n                              range_start, range_end, clength);\n            ap_xlate_proto_to_ascii(ts, strlen(ts));\n            e = apr_bucket_pool_create(ts, strlen(ts), r->pool,\n                                       c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bsend, e);\n        }\n\n        APR_BRIGADE_CONCAT(bsend, tmpbb);\n        if (i && !(i & 0x1F)) {\n            /*\n             * Every now and then, pass what we have down the filter chain.\n             * In this case, the content-length filter cannot calculate and\n             * set the content length and we must remove any Content-Length\n             * header already present.\n             */\n            apr_table_unset(r->headers_out, \"Content-Length\");\n            if ((rv = ap_pass_brigade(f->next, bsend)) != APR_SUCCESS)\n                return rv;\n            apr_brigade_cleanup(bsend);\n        }\n    }\n\n    if (found == 0) {\n        /* bsend is assumed to be empty if we get here. */\n        return send_416(f, bsend);\n    }\n\n    if (num_ranges > 1) {\n        char *end;\n\n        /* add the final boundary */\n        end = apr_pstrcat(r->pool, CRLF \"--\", ap_multipart_boundary, \"--\" CRLF,\n                          NULL);\n        ap_xlate_proto_to_ascii(end, strlen(end));\n        e = apr_bucket_pool_create(end, strlen(end), r->pool, c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bsend, e);\n    }\n\n    e = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bsend, e);\n\n    /* we're done with the original content - all of our data is in bsend. */\n    apr_brigade_cleanup(bb);\n    apr_brigade_destroy(tmpbb);\n\n    /* send our multipart output */\n    return ap_pass_brigade(f->next, bsend);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c', line 399, column 38>"
          }
        },
        "used_macros": {
          "AP_CONDITION_NOMATCH": {
            "name": "AP_CONDITION_NOMATCH",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_NOMATCH = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 236, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_array_header_t": {
            "name": "apr_array_header_t",
            "definition": "struct apr_array_header_t {\n    /** The pool the array is allocated out of */\n    apr_pool_t *pool;\n    /** The amount of memory allocated for each element of the array */\n    int elt_size;\n    /** The number of active elements in the array */\n    int nelts;\n    /** The number of elements allocated in the array */\n    int nalloc;\n    /** The elements in the array */\n    char *elts;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "elt_size": "int",
              "nelts": "int",
              "nalloc": "int",
              "elts": "char *"
            },
            "condition": ""
          },
          "indexes_t": {
            "name": "indexes_t",
            "definition": "struct indexes_t {\n    apr_off_t start;\n    apr_off_t end;\n}",
            "typedef_name": null,
            "fields": {
              "start": "apr_off_t",
              "end": "apr_off_t"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "apr_off_t"
        ]
      },
      "source_code": "static int ap_set_byterange(request_rec *r, apr_off_t clength,\n                            apr_array_header_t **indexes,\n                            int *overlaps, int *reversals)\n{\n    const char *range;\n    const char *ct;\n    char *cur;\n    apr_array_header_t *merged;\n    int num_ranges = 0, unsatisfiable = 0;\n    apr_off_t ostart = 0, oend = 0, sum_lengths = 0;\n    int in_merge = 0;\n    indexes_t *idx;\n    int ranges = 1;\n    int i;\n    const char *it;\n\n    *overlaps = 0;\n    *reversals = 0;\n\n    if (r->assbackwards) {\n        return 0;\n    }\n\n    range = apr_table_get(r->headers_in, \"Range\");\n    if (!range || ap_cstr_casecmpn(range, \"bytes=\", 6) || r->status != HTTP_OK) {\n        return 0;\n    }\n\n    /* is content already a single range? */\n    if (apr_table_get(r->headers_out, \"Content-Range\")) {\n        return 0;\n    }\n\n    /* is content already a multiple range? */\n    if ((ct = apr_table_get(r->headers_out, \"Content-Type\"))\n        && ap_cstr_casecmpn(ct, \"multipart/byteranges\", 20) == 0) {\n            return 0;\n    }\n\n    /*\n     * Check the If-Range header for Etag or Date.\n     */\n    if (AP_CONDITION_NOMATCH == ap_condition_if_range(r, r->headers_out)) {\n        return 0;\n    }\n\n    range += 6;\n    it = range;\n    while (*it) {\n        if (*it++ == ',') {\n            ranges++;\n        }\n    }\n    it = range;\n    if (ranges > MAX_PREALLOC_RANGES) {\n        ranges = MAX_PREALLOC_RANGES;\n    }\n    *indexes = apr_array_make(r->pool, ranges, sizeof(indexes_t));\n    while ((cur = ap_getword(r->pool, &range, ','))) {\n        char *dash;\n        apr_off_t number, start, end;\n\n        if (!*cur)\n            break;\n\n        /*\n         * Per RFC 2616 14.35.1: If there is at least one syntactically invalid\n         * byte-range-spec, we must ignore the whole header.\n         */\n\n        if (!(dash = strchr(cur, '-'))) {\n            return 0;\n        }\n\n        if (dash == cur) {\n            /* In the form \"-5\" */\n            if (!ap_parse_strict_length(&number, dash+1)) {\n                return 0;\n            }\n            if (number < 1) {\n                return 0;\n            }\n            start = clength - number;\n            end = clength - 1;\n        }\n        else {\n            *dash++ = '\\0';\n            if (!ap_parse_strict_length(&number, cur)) {\n                return 0;\n            }\n            start = number;\n            if (*dash) {\n                if (!ap_parse_strict_length(&number, dash)) {\n                    return 0;\n                }\n                end = number;\n                if (start > end) {\n                    return 0;\n                }\n            }\n            else {                  /* \"5-\" */\n                end = clength - 1;\n                /*\n                 * special case: 0-\n                 *   ignore all other ranges provided\n                 *   return as a single range: 0-\n                 */\n                if (start == 0) {\n                    num_ranges = 0;\n                    sum_lengths = 0;\n                    in_merge = 1;\n                    oend = end;\n                    ostart = start;\n                    apr_array_clear(*indexes);\n                    break;\n                }\n            }\n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n        if (start >= clength) {\n            unsatisfiable = 1;\n            continue;\n        }\n        if (end >= clength) {\n            end = clength - 1;\n        }\n\n        if (!in_merge) {\n            /* new set */\n            ostart = start;\n            oend = end;\n            in_merge = 1;\n            continue;\n        }\n        in_merge = 0;\n\n        if (start >= ostart && end <= oend) {\n            in_merge = 1;\n        }\n\n        if (start < ostart && end >= ostart-1) {\n            ostart = start;\n            ++*reversals;\n            in_merge = 1;\n        }\n        if (end >= oend && start <= oend+1 ) {\n            oend = end;\n            in_merge = 1;\n        }\n\n        if (in_merge) {\n            ++*overlaps;\n            continue;\n        } else {\n            idx = (indexes_t *)apr_array_push(*indexes);\n            idx->start = ostart;\n            idx->end = oend;\n            sum_lengths += oend - ostart + 1;\n            /* new set again */\n            in_merge = 1;\n            ostart = start;\n            oend = end;\n            num_ranges++;\n        }\n    }\n\n    if (in_merge) {\n        idx = (indexes_t *)apr_array_push(*indexes);\n        idx->start = ostart;\n        idx->end = oend;\n        sum_lengths += oend - ostart + 1;\n        num_ranges++;\n    }\n    else if (num_ranges == 0 && unsatisfiable) {\n        /* If all ranges are unsatisfiable, we should return 416 */\n        return -1;\n    }\n    if (sum_lengths > clength) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                      \"Sum of ranges larger than file, ignoring.\");\n        return 0;\n    }\n\n    /*\n     * create the merged table now, now that we know we need it\n     */\n    merged = apr_array_make(r->pool, num_ranges, sizeof(char *));\n    idx = (indexes_t *)(*indexes)->elts;\n    for (i = 0; i < (*indexes)->nelts; i++, idx++) {\n        char **new = (char **)apr_array_push(merged);\n        *new = apr_psprintf(r->pool, \"%\" APR_OFF_T_FMT \"-%\" APR_OFF_T_FMT,\n                            idx->start, idx->end);\n    }\n\n    r->status = HTTP_PARTIAL_CONTENT;\n    r->range = apr_array_pstrcat(r->pool, merged, ',');\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01583)\n                  \"Range: %s | %s (%d : %d : %\"APR_OFF_T_FMT\")\",\n                  it, r->range, *overlaps, *reversals, clength);\n\n    return num_ranges;\n}"
    },
    "copy_brigade_range@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c', line 288, column 21>": {
      "basic_info": {
        "function_id": 1414,
        "name": "copy_brigade_range",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c', line 288, column 21>",
        "is_definition": true,
        "start_line": 288,
        "end_line": 383,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "bb",
            "type": "apr_bucket_brigade *"
          },
          {
            "name": "bbout",
            "type": "apr_bucket_brigade *"
          },
          {
            "name": "start",
            "type": "apr_off_t"
          },
          {
            "name": "end",
            "type": "apr_off_t"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "copy": {
            "declaration": "apr_bucket_copy(e, &copy)",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_cleanup": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_cleanup(void *data)",
            "is_external": true,
            "definition": null
          },
          "split": {
            "declaration": "apr_bucket_split(copy, (apr_size_t)(end64 + 1 - off_last))",
            "is_external": true,
            "definition": null
          },
          "destroy": {
            "declaration": "apr_bucket_delete(copy)",
            "is_external": true,
            "definition": null
          },
          "free": {
            "declaration": "void (*free)(void *e)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_byterange_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c', line 399, column 38>": {
            "source_code": "AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(ap_filter_t *f,\n                                                         apr_bucket_brigade *bb)\n{\n    request_rec *r = f->r;\n    conn_rec *c = r->connection;\n    apr_bucket *e;\n    apr_bucket_brigade *bsend;\n    apr_bucket_brigade *tmpbb;\n    apr_off_t range_start;\n    apr_off_t range_end;\n    apr_off_t clength = 0;\n    apr_status_t rv;\n    int found = 0;\n    int num_ranges;\n    char *bound_head = NULL;\n    apr_array_header_t *indexes;\n    indexes_t *idx;\n    int i;\n    int original_status;\n    int max_ranges, max_overlaps, max_reversals;\n    int overlaps = 0, reversals = 0;\n    core_dir_config *core_conf = ap_get_core_module_config(r->per_dir_config);\n\n    max_ranges = ( (core_conf->max_ranges >= 0 || core_conf->max_ranges == AP_MAXRANGES_UNLIMITED)\n                   ? core_conf->max_ranges\n                   : AP_DEFAULT_MAX_RANGES );\n    max_overlaps = ( (core_conf->max_overlaps >= 0 || core_conf->max_overlaps == AP_MAXRANGES_UNLIMITED)\n                  ? core_conf->max_overlaps\n                  : AP_DEFAULT_MAX_OVERLAPS );\n    max_reversals = ( (core_conf->max_reversals >= 0 || core_conf->max_reversals == AP_MAXRANGES_UNLIMITED)\n                  ? core_conf->max_reversals\n                  : AP_DEFAULT_MAX_REVERSALS );\n    /*\n     * Iterate through the brigade until reaching EOS or a bucket with\n     * unknown length.\n     */\n    for (e = APR_BRIGADE_FIRST(bb);\n         (e != APR_BRIGADE_SENTINEL(bb) && !APR_BUCKET_IS_EOS(e)\n          && e->length != (apr_size_t)-1);\n         e = APR_BUCKET_NEXT(e)) {\n        clength += e->length;\n    }\n\n    /*\n     * Don't attempt to do byte range work if this brigade doesn't\n     * contain an EOS, or if any of the buckets has an unknown length;\n     * this avoids the cases where it is expensive to perform\n     * byteranging (i.e. may require arbitrary amounts of memory).\n     */\n    if (!APR_BUCKET_IS_EOS(e) || clength <= 0) {\n        ap_remove_output_filter(f);\n        return ap_pass_brigade(f->next, bb);\n    }\n\n    original_status = r->status;\n    num_ranges = ap_set_byterange(r, clength, &indexes, &overlaps, &reversals);\n\n    /* No Ranges or we hit a limit? We have nothing to do, get out of the way. */\n    if (num_ranges == 0 ||\n        (max_ranges >= 0 && num_ranges > max_ranges) ||\n        (max_overlaps >= 0 && overlaps > max_overlaps) ||\n        (max_reversals >= 0 && reversals > max_reversals)) {\n        r->status = original_status;\n        ap_remove_output_filter(f);\n        return ap_pass_brigade(f->next, bb);\n    }\n\n    /* this brigade holds what we will be sending */\n    bsend = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    if (num_ranges < 0)\n        return send_416(f, bsend);\n\n    if (num_ranges > 1) {\n        /* Is ap_make_content_type required here? */\n        const char *orig_ct = ap_make_content_type(r, r->content_type);\n\n        ap_set_content_type_ex(r, apr_pstrcat(r->pool,\n                                           \"multipart/byteranges; boundary=\",\n                                           ap_multipart_boundary, NULL), 1);\n\n        if (orig_ct) {\n            bound_head = apr_pstrcat(r->pool,\n                                     CRLF \"--\", ap_multipart_boundary,\n                                     CRLF \"Content-type: \",\n                                     orig_ct,\n                                     CRLF \"Content-range: bytes \",\n                                     NULL);\n        }\n        else {\n            /* if we have no type for the content, do our best */\n            bound_head = apr_pstrcat(r->pool,\n                                     CRLF \"--\", ap_multipart_boundary,\n                                     CRLF \"Content-range: bytes \",\n                                     NULL);\n        }\n        ap_xlate_proto_to_ascii(bound_head, strlen(bound_head));\n    }\n\n    tmpbb = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    idx = (indexes_t *)indexes->elts;\n    for (i = 0; i < indexes->nelts; i++, idx++) {\n        range_start = idx->start;\n        range_end = idx->end;\n\n        rv = copy_brigade_range(bb, tmpbb, range_start, range_end);\n        if (rv != APR_SUCCESS ) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01584)\n                          \"copy_brigade_range() failed [%\" APR_OFF_T_FMT\n                          \"-%\" APR_OFF_T_FMT \",%\" APR_OFF_T_FMT \"]\",\n                          range_start, range_end, clength);\n            continue;\n        }\n        found = 1;\n\n        /*\n         * For single range requests, we must produce Content-Range header.\n         * Otherwise, we need to produce the multipart boundaries.\n         */\n        if (num_ranges == 1) {\n            apr_table_setn(r->headers_out, \"Content-Range\",\n                           apr_psprintf(r->pool, \"bytes \" BYTERANGE_FMT,\n                                        range_start, range_end, clength));\n        }\n        else {\n            char *ts;\n\n            e = apr_bucket_pool_create(bound_head, strlen(bound_head),\n                                       r->pool, c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bsend, e);\n\n            ts = apr_psprintf(r->pool, BYTERANGE_FMT CRLF CRLF,\n                              range_start, range_end, clength);\n            ap_xlate_proto_to_ascii(ts, strlen(ts));\n            e = apr_bucket_pool_create(ts, strlen(ts), r->pool,\n                                       c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bsend, e);\n        }\n\n        APR_BRIGADE_CONCAT(bsend, tmpbb);\n        if (i && !(i & 0x1F)) {\n            /*\n             * Every now and then, pass what we have down the filter chain.\n             * In this case, the content-length filter cannot calculate and\n             * set the content length and we must remove any Content-Length\n             * header already present.\n             */\n            apr_table_unset(r->headers_out, \"Content-Length\");\n            if ((rv = ap_pass_brigade(f->next, bsend)) != APR_SUCCESS)\n                return rv;\n            apr_brigade_cleanup(bsend);\n        }\n    }\n\n    if (found == 0) {\n        /* bsend is assumed to be empty if we get here. */\n        return send_416(f, bsend);\n    }\n\n    if (num_ranges > 1) {\n        char *end;\n\n        /* add the final boundary */\n        end = apr_pstrcat(r->pool, CRLF \"--\", ap_multipart_boundary, \"--\" CRLF,\n                          NULL);\n        ap_xlate_proto_to_ascii(end, strlen(end));\n        e = apr_bucket_pool_create(end, strlen(end), r->pool, c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bsend, e);\n    }\n\n    e = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bsend, e);\n\n    /* we're done with the original content - all of our data is in bsend. */\n    apr_brigade_cleanup(bb);\n    apr_brigade_destroy(tmpbb);\n\n    /* send our multipart output */\n    return ap_pass_brigade(f->next, bsend);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c', line 399, column 38>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "apr_size_t",
          "apr_uint64_t",
          "apr_off_t",
          "apr_status_t"
        ]
      },
      "source_code": "static apr_status_t copy_brigade_range(apr_bucket_brigade *bb,\n                                       apr_bucket_brigade *bbout,\n                                       apr_off_t start,\n                                       apr_off_t end)\n{\n    apr_bucket *first = NULL, *last = NULL, *out_first = NULL, *e;\n    apr_uint64_t pos = 0, off_first = 0, off_last = 0;\n    apr_status_t rv;\n    apr_uint64_t start64, end64;\n    apr_off_t pofft = 0;\n\n    /*\n     * Once we know that start and end are >= 0 convert everything to apr_uint64_t.\n     * See the comments in apr_brigade_partition why.\n     * In short apr_off_t (for values >= 0)and apr_size_t fit into apr_uint64_t.\n     */\n    start64 = (apr_uint64_t)start;\n    end64 = (apr_uint64_t)end;\n\n    if (start < 0 || end < 0 || start64 > end64)\n        return APR_EINVAL;\n\n    for (e = APR_BRIGADE_FIRST(bb);\n         e != APR_BRIGADE_SENTINEL(bb);\n         e = APR_BUCKET_NEXT(e))\n    {\n        apr_uint64_t elen64;\n        /* we know that no bucket has undefined length (-1) */\n        AP_DEBUG_ASSERT(e->length != (apr_size_t)(-1));\n        elen64 = (apr_uint64_t)e->length;\n        if (!first && (elen64 + pos > start64)) {\n            first = e;\n            off_first = pos;\n        }\n        if (elen64 + pos > end64) {\n            last = e;\n            off_last = pos;\n            break;\n        }\n        pos += elen64;\n    }\n    if (!first || !last)\n        return APR_EINVAL;\n\n    e = first;\n    while (1)\n    {\n        apr_bucket *copy;\n        AP_DEBUG_ASSERT(e != APR_BRIGADE_SENTINEL(bb));\n        rv = apr_bucket_copy(e, &copy);\n        if (rv != APR_SUCCESS) {\n            apr_brigade_cleanup(bbout);\n            return rv;\n        }\n\n        APR_BRIGADE_INSERT_TAIL(bbout, copy);\n        if (e == first) {\n            if (off_first != start64) {\n                rv = apr_bucket_split(copy, (apr_size_t)(start64 - off_first));\n                if (rv != APR_SUCCESS) {\n                    apr_brigade_cleanup(bbout);\n                    return rv;\n                }\n                out_first = APR_BUCKET_NEXT(copy);\n                apr_bucket_delete(copy);\n            }\n            else {\n                out_first = copy;\n            }\n        }\n        if (e == last) {\n            if (e == first) {\n                off_last += start64 - off_first;\n                copy = out_first;\n            }\n            if (end64 - off_last != (apr_uint64_t)e->length) {\n                rv = apr_bucket_split(copy, (apr_size_t)(end64 + 1 - off_last));\n                if (rv != APR_SUCCESS) {\n                    apr_brigade_cleanup(bbout);\n                    return rv;\n                }\n                copy = APR_BUCKET_NEXT(copy);\n                if (copy != APR_BRIGADE_SENTINEL(bbout)) {\n                    apr_bucket_delete(copy);\n                }\n            }\n            break;\n        }\n        e = APR_BUCKET_NEXT(e);\n    }\n\n    AP_DEBUG_ASSERT(APR_SUCCESS == apr_brigade_length(bbout, 1, &pofft));\n    pos = (apr_uint64_t)pofft;\n    AP_DEBUG_ASSERT(pos == end64 - start64 + 1);\n    return APR_SUCCESS;\n}"
    },
    "send_416@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c', line 385, column 21>": {
      "basic_info": {
        "function_id": 1415,
        "name": "send_416",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c', line 385, column 21>",
        "is_definition": true,
        "start_line": 385,
        "end_line": 397,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "f",
            "type": "ap_filter_t *"
          },
          {
            "name": "tmpbb",
            "type": "apr_bucket_brigade *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_remove_output_filter": {
            "declaration": "AP_DECLARE(void) ap_remove_output_filter(ap_filter_t *f)",
            "is_external": true,
            "definition": null
          },
          "ap_bucket_error_create": {
            "declaration": "AP_DECLARE(apr_bucket *) ap_bucket_error_create(int error, const char *buf,\n                                                apr_pool_t *p,\n                                                apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "apr_bucket_eos_create": {
            "declaration": "APU_DECLARE(apr_bucket *) apr_bucket_eos_create(apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "ap_pass_brigade": {
            "declaration": "AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *filter,\n                                         apr_bucket_brigade *bucket)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_byterange_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c', line 399, column 38>": {
            "source_code": "AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(ap_filter_t *f,\n                                                         apr_bucket_brigade *bb)\n{\n    request_rec *r = f->r;\n    conn_rec *c = r->connection;\n    apr_bucket *e;\n    apr_bucket_brigade *bsend;\n    apr_bucket_brigade *tmpbb;\n    apr_off_t range_start;\n    apr_off_t range_end;\n    apr_off_t clength = 0;\n    apr_status_t rv;\n    int found = 0;\n    int num_ranges;\n    char *bound_head = NULL;\n    apr_array_header_t *indexes;\n    indexes_t *idx;\n    int i;\n    int original_status;\n    int max_ranges, max_overlaps, max_reversals;\n    int overlaps = 0, reversals = 0;\n    core_dir_config *core_conf = ap_get_core_module_config(r->per_dir_config);\n\n    max_ranges = ( (core_conf->max_ranges >= 0 || core_conf->max_ranges == AP_MAXRANGES_UNLIMITED)\n                   ? core_conf->max_ranges\n                   : AP_DEFAULT_MAX_RANGES );\n    max_overlaps = ( (core_conf->max_overlaps >= 0 || core_conf->max_overlaps == AP_MAXRANGES_UNLIMITED)\n                  ? core_conf->max_overlaps\n                  : AP_DEFAULT_MAX_OVERLAPS );\n    max_reversals = ( (core_conf->max_reversals >= 0 || core_conf->max_reversals == AP_MAXRANGES_UNLIMITED)\n                  ? core_conf->max_reversals\n                  : AP_DEFAULT_MAX_REVERSALS );\n    /*\n     * Iterate through the brigade until reaching EOS or a bucket with\n     * unknown length.\n     */\n    for (e = APR_BRIGADE_FIRST(bb);\n         (e != APR_BRIGADE_SENTINEL(bb) && !APR_BUCKET_IS_EOS(e)\n          && e->length != (apr_size_t)-1);\n         e = APR_BUCKET_NEXT(e)) {\n        clength += e->length;\n    }\n\n    /*\n     * Don't attempt to do byte range work if this brigade doesn't\n     * contain an EOS, or if any of the buckets has an unknown length;\n     * this avoids the cases where it is expensive to perform\n     * byteranging (i.e. may require arbitrary amounts of memory).\n     */\n    if (!APR_BUCKET_IS_EOS(e) || clength <= 0) {\n        ap_remove_output_filter(f);\n        return ap_pass_brigade(f->next, bb);\n    }\n\n    original_status = r->status;\n    num_ranges = ap_set_byterange(r, clength, &indexes, &overlaps, &reversals);\n\n    /* No Ranges or we hit a limit? We have nothing to do, get out of the way. */\n    if (num_ranges == 0 ||\n        (max_ranges >= 0 && num_ranges > max_ranges) ||\n        (max_overlaps >= 0 && overlaps > max_overlaps) ||\n        (max_reversals >= 0 && reversals > max_reversals)) {\n        r->status = original_status;\n        ap_remove_output_filter(f);\n        return ap_pass_brigade(f->next, bb);\n    }\n\n    /* this brigade holds what we will be sending */\n    bsend = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    if (num_ranges < 0)\n        return send_416(f, bsend);\n\n    if (num_ranges > 1) {\n        /* Is ap_make_content_type required here? */\n        const char *orig_ct = ap_make_content_type(r, r->content_type);\n\n        ap_set_content_type_ex(r, apr_pstrcat(r->pool,\n                                           \"multipart/byteranges; boundary=\",\n                                           ap_multipart_boundary, NULL), 1);\n\n        if (orig_ct) {\n            bound_head = apr_pstrcat(r->pool,\n                                     CRLF \"--\", ap_multipart_boundary,\n                                     CRLF \"Content-type: \",\n                                     orig_ct,\n                                     CRLF \"Content-range: bytes \",\n                                     NULL);\n        }\n        else {\n            /* if we have no type for the content, do our best */\n            bound_head = apr_pstrcat(r->pool,\n                                     CRLF \"--\", ap_multipart_boundary,\n                                     CRLF \"Content-range: bytes \",\n                                     NULL);\n        }\n        ap_xlate_proto_to_ascii(bound_head, strlen(bound_head));\n    }\n\n    tmpbb = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    idx = (indexes_t *)indexes->elts;\n    for (i = 0; i < indexes->nelts; i++, idx++) {\n        range_start = idx->start;\n        range_end = idx->end;\n\n        rv = copy_brigade_range(bb, tmpbb, range_start, range_end);\n        if (rv != APR_SUCCESS ) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01584)\n                          \"copy_brigade_range() failed [%\" APR_OFF_T_FMT\n                          \"-%\" APR_OFF_T_FMT \",%\" APR_OFF_T_FMT \"]\",\n                          range_start, range_end, clength);\n            continue;\n        }\n        found = 1;\n\n        /*\n         * For single range requests, we must produce Content-Range header.\n         * Otherwise, we need to produce the multipart boundaries.\n         */\n        if (num_ranges == 1) {\n            apr_table_setn(r->headers_out, \"Content-Range\",\n                           apr_psprintf(r->pool, \"bytes \" BYTERANGE_FMT,\n                                        range_start, range_end, clength));\n        }\n        else {\n            char *ts;\n\n            e = apr_bucket_pool_create(bound_head, strlen(bound_head),\n                                       r->pool, c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bsend, e);\n\n            ts = apr_psprintf(r->pool, BYTERANGE_FMT CRLF CRLF,\n                              range_start, range_end, clength);\n            ap_xlate_proto_to_ascii(ts, strlen(ts));\n            e = apr_bucket_pool_create(ts, strlen(ts), r->pool,\n                                       c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bsend, e);\n        }\n\n        APR_BRIGADE_CONCAT(bsend, tmpbb);\n        if (i && !(i & 0x1F)) {\n            /*\n             * Every now and then, pass what we have down the filter chain.\n             * In this case, the content-length filter cannot calculate and\n             * set the content length and we must remove any Content-Length\n             * header already present.\n             */\n            apr_table_unset(r->headers_out, \"Content-Length\");\n            if ((rv = ap_pass_brigade(f->next, bsend)) != APR_SUCCESS)\n                return rv;\n            apr_brigade_cleanup(bsend);\n        }\n    }\n\n    if (found == 0) {\n        /* bsend is assumed to be empty if we get here. */\n        return send_416(f, bsend);\n    }\n\n    if (num_ranges > 1) {\n        char *end;\n\n        /* add the final boundary */\n        end = apr_pstrcat(r->pool, CRLF \"--\", ap_multipart_boundary, \"--\" CRLF,\n                          NULL);\n        ap_xlate_proto_to_ascii(end, strlen(end));\n        e = apr_bucket_pool_create(end, strlen(end), r->pool, c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bsend, e);\n    }\n\n    e = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bsend, e);\n\n    /* we're done with the original content - all of our data is in bsend. */\n    apr_brigade_cleanup(bb);\n    apr_brigade_destroy(tmpbb);\n\n    /* send our multipart output */\n    return ap_pass_brigade(f->next, bsend);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c', line 399, column 38>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "ap_filter_t": {
            "name": "ap_filter_t",
            "definition": "struct ap_filter_t {\n    /** The internal representation of this filter.  This includes\n     *  the filter's name, type, and the actual function pointer.\n     */\n    ap_filter_rec_t *frec;\n\n    /** A place to store any data associated with the current filter */\n    void *ctx;\n\n    /** The next filter in the chain */\n    ap_filter_t *next;\n\n    /** The request_rec associated with the current filter.  If a sub-request\n     *  adds filters, then the sub-request is the request associated with the\n     *  filter.\n     */\n    request_rec *r;\n\n    /** The conn_rec associated with the current filter.  This is analogous\n     *  to the request_rec, except that it is used for connection filters.\n     */\n    conn_rec *c;\n}",
            "typedef_name": null,
            "fields": {
              "frec": "ap_filter_rec_t *",
              "ctx": "void *",
              "next": "ap_filter_t *",
              "r": "request_rec *",
              "c": "conn_rec *"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "conn_rec": {
            "name": "conn_rec",
            "definition": "struct conn_rec {\n    /** Pool associated with this connection */\n    apr_pool_t *pool;\n    /** Physical vhost this conn came in on */\n    server_rec *base_server;\n    /** used by http_vhost.c */\n    void *vhost_lookup_data;\n\n    /* Information about the connection itself */\n    /** local address */\n    apr_sockaddr_t *local_addr;\n    /** remote address; this is the end-point of the next hop, for the address\n     *  of the request creator, see useragent_addr in request_rec\n     */\n    apr_sockaddr_t *client_addr;\n\n    /** Client's IP address; this is the end-point of the next hop, for the\n     *  IP of the request creator, see useragent_ip in request_rec\n     */\n    char *client_ip;\n    /** Client's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     * get_remote_host() */\n    char *remote_host;\n    /** Only ever set if doing rfc1413 lookups.  N.B. Only access this through\n     *  get_remote_logname() */\n    char *remote_logname;\n\n    /** server IP address */\n    char *local_ip;\n    /** used for ap_get_server_name when UseCanonicalName is set to DNS\n     *  (ignores setting of HostnameLookups) */\n    char *local_host;\n\n    /** ID of this connection; unique at any point in time */\n    long id;\n    /** Config vector containing pointers to connections per-server\n     *  config structures. */\n    struct ap_conf_vector_t *conn_config;\n    /** Notes on *this* connection: send note from one module to\n     *  another. must remain valid for all requests on this conn */\n    apr_table_t *notes;\n    /** A list of input filters to be used for this connection */\n    struct ap_filter_t *input_filters;\n    /** A list of output filters to be used for this connection */\n    struct ap_filter_t *output_filters;\n    /** handle to scoreboard information for this connection */\n    void *sbh;\n    /** The bucket allocator to use for all bucket/brigade creations */\n    struct apr_bucket_alloc_t *bucket_alloc;\n    /** The current state of this connection; may be NULL if not used by MPM */\n    conn_state_t *cs;\n    /** Is there data pending in the input filters? */\n    int data_in_input_filters;\n    /** Is there data pending in the output filters? */\n    int data_in_output_filters;\n\n    /** Are there any filters that clogg/buffer the input stream, breaking\n     *  the event mpm.\n     */\n    unsigned int clogging_input_filters:1;\n\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success */\n    signed int double_reverse:2;\n\n    /** Are we still talking? */\n    unsigned aborted;\n\n    /** Are we going to keep the connection alive for another request?\n     * @see ap_conn_keepalive_e */\n    ap_conn_keepalive_e keepalive;\n\n    /** How many times have we used it? */\n    int keepalives;\n\n    /** Optional connection log level configuration. May point to a server or\n     *  per_dir config, i.e. must be copied before modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify this connection in error log. Set when the first\n     *  error log entry for this connection is generated.\n     */\n    const char *log_id;\n\n\n    /** This points to the current thread being used to process this request,\n     * over the lifetime of a request, the value may change. Users of the connection\n     * record should not rely upon it staying the same between calls that involve\n     * the MPM.\n     */\n#if APR_HAS_THREADS\n    apr_thread_t *current_thread;\n#endif\n\n    /** The \"real\" master connection. NULL if I am the master. */\n    conn_rec *master;\n\n    int outgoing;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "base_server": "server_rec *",
              "vhost_lookup_data": "void *",
              "local_addr": "apr_sockaddr_t *",
              "client_addr": "apr_sockaddr_t *",
              "client_ip": "char *",
              "remote_host": "char *",
              "remote_logname": "char *",
              "local_ip": "char *",
              "local_host": "char *",
              "id": "long",
              "conn_config": "struct ap_conf_vector_t *",
              "notes": "apr_table_t *",
              "input_filters": "struct ap_filter_t *",
              "output_filters": "struct ap_filter_t *",
              "sbh": "void *",
              "bucket_alloc": "struct apr_bucket_alloc_t *",
              "cs": "conn_state_t *",
              "data_in_input_filters": "int",
              "data_in_output_filters": "int",
              "clogging_input_filters": "unsigned int",
              "double_reverse": "int",
              "aborted": "unsigned int",
              "keepalive": "ap_conn_keepalive_e",
              "keepalives": "int",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "current_thread": "apr_thread_t *",
              "master": "conn_rec *",
              "outgoing": "int"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "apr_status_t"
        ]
      },
      "source_code": "static apr_status_t send_416(ap_filter_t *f, apr_bucket_brigade *tmpbb)\n{\n    apr_bucket *e;\n    conn_rec *c = f->r->connection;\n    ap_remove_output_filter(f);\n    f->r->status = HTTP_OK;\n    e = ap_bucket_error_create(HTTP_RANGE_NOT_SATISFIABLE, NULL,\n                               f->r->pool, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(tmpbb, e);\n    e = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(tmpbb, e);\n    return ap_pass_brigade(f->next, tmpbb);\n}"
    },
    "ap_byterange_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c', line 399, column 38>": {
      "basic_info": {
        "function_id": 1416,
        "name": "ap_byterange_filter",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c', line 399, column 38>",
        "is_definition": true,
        "start_line": 399,
        "end_line": 579,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "f",
            "type": "ap_filter_t *"
          },
          {
            "name": "bb",
            "type": "apr_bucket_brigade *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_remove_output_filter": {
            "declaration": "AP_DECLARE(void) ap_remove_output_filter(ap_filter_t *f)",
            "is_external": true,
            "definition": null
          },
          "ap_pass_brigade": {
            "declaration": "AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *filter,\n                                         apr_bucket_brigade *bucket)",
            "is_external": true,
            "definition": null
          },
          "ap_set_byterange": {
            "declaration": "static int ap_set_byterange(request_rec *r, apr_off_t clength,\n                            apr_array_header_t **indexes,\n                            int *overlaps, int *reversals)\n{\n    const char *range;\n    const char *ct;\n    char *cur;\n    apr_array_header_t *merged;\n    int num_ranges = 0, unsatisfiable = 0;\n    apr_off_t ostart = 0, oend = 0, sum_lengths = 0;\n    int in_merge = 0;\n    indexes_t *idx;\n    int ranges = 1;\n    int i;\n    const char *it;\n\n    *overlaps = 0;\n    *reversals = 0;\n\n    if (r->assbackwards) {\n        return 0;\n    }\n\n    range = apr_table_get(r->headers_in, \"Range\");\n    if (!range || ap_cstr_casecmpn(range, \"bytes=\", 6) || r->status != HTTP_OK) {\n        return 0;\n    }\n\n    /* is content already a single range? */\n    if (apr_table_get(r->headers_out, \"Content-Range\")) {\n        return 0;\n    }\n\n    /* is content already a multiple range? */\n    if ((ct = apr_table_get(r->headers_out, \"Content-Type\"))\n        && ap_cstr_casecmpn(ct, \"multipart/byteranges\", 20) == 0) {\n            return 0;\n    }\n\n    /*\n     * Check the If-Range header for Etag or Date.\n     */\n    if (AP_CONDITION_NOMATCH == ap_condition_if_range(r, r->headers_out)) {\n        return 0;\n    }\n\n    range += 6;\n    it = range;\n    while (*it) {\n        if (*it++ == ',') {\n            ranges++;\n        }\n    }\n    it = range;\n    if (ranges > MAX_PREALLOC_RANGES) {\n        ranges = MAX_PREALLOC_RANGES;\n    }\n    *indexes = apr_array_make(r->pool, ranges, sizeof(indexes_t));\n    while ((cur = ap_getword(r->pool, &range, ','))) {\n        char *dash;\n        apr_off_t number, start, end;\n\n        if (!*cur)\n            break;\n\n        /*\n         * Per RFC 2616 14.35.1: If there is at least one syntactically invalid\n         * byte-range-spec, we must ignore the whole header.\n         */\n\n        if (!(dash = strchr(cur, '-'))) {\n            return 0;\n        }\n\n        if (dash == cur) {\n            /* In the form \"-5\" */\n            if (!ap_parse_strict_length(&number, dash+1)) {\n                return 0;\n            }\n            if (number < 1) {\n                return 0;\n            }\n            start = clength - number;\n            end = clength - 1;\n        }\n        else {\n            *dash++ = '\\0';\n            if (!ap_parse_strict_length(&number, cur)) {\n                return 0;\n            }\n            start = number;\n            if (*dash) {\n                if (!ap_parse_strict_length(&number, dash)) {\n                    return 0;\n                }\n                end = number;\n                if (start > end) {\n                    return 0;\n                }\n            }\n            else {                  /* \"5-\" */\n                end = clength - 1;\n                /*\n                 * special case: 0-\n                 *   ignore all other ranges provided\n                 *   return as a single range: 0-\n                 */\n                if (start == 0) {\n                    num_ranges = 0;\n                    sum_lengths = 0;\n                    in_merge = 1;\n                    oend = end;\n                    ostart = start;\n                    apr_array_clear(*indexes);\n                    break;\n                }\n            }\n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n        if (start >= clength) {\n            unsatisfiable = 1;\n            continue;\n        }\n        if (end >= clength) {\n            end = clength - 1;\n        }\n\n        if (!in_merge) {\n            /* new set */\n            ostart = start;\n            oend = end;\n            in_merge = 1;\n            continue;\n        }\n        in_merge = 0;\n\n        if (start >= ostart && end <= oend) {\n            in_merge = 1;\n        }\n\n        if (start < ostart && end >= ostart-1) {\n            ostart = start;\n            ++*reversals;\n            in_merge = 1;\n        }\n        if (end >= oend && start <= oend+1 ) {\n            oend = end;\n            in_merge = 1;\n        }\n\n        if (in_merge) {\n            ++*overlaps;\n            continue;\n        } else {\n            idx = (indexes_t *)apr_array_push(*indexes);\n            idx->start = ostart;\n            idx->end = oend;\n            sum_lengths += oend - ostart + 1;\n            /* new set again */\n            in_merge = 1;\n            ostart = start;\n            oend = end;\n            num_ranges++;\n        }\n    }\n\n    if (in_merge) {\n        idx = (indexes_t *)apr_array_push(*indexes);\n        idx->start = ostart;\n        idx->end = oend;\n        sum_lengths += oend - ostart + 1;\n        num_ranges++;\n    }\n    else if (num_ranges == 0 && unsatisfiable) {\n        /* If all ranges are unsatisfiable, we should return 416 */\n        return -1;\n    }\n    if (sum_lengths > clength) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                      \"Sum of ranges larger than file, ignoring.\");\n        return 0;\n    }\n\n    /*\n     * create the merged table now, now that we know we need it\n     */\n    merged = apr_array_make(r->pool, num_ranges, sizeof(char *));\n    idx = (indexes_t *)(*indexes)->elts;\n    for (i = 0; i < (*indexes)->nelts; i++, idx++) {\n        char **new = (char **)apr_array_push(merged);\n        *new = apr_psprintf(r->pool, \"%\" APR_OFF_T_FMT \"-%\" APR_OFF_T_FMT,\n                            idx->start, idx->end);\n    }\n\n    r->status = HTTP_PARTIAL_CONTENT;\n    r->range = apr_array_pstrcat(r->pool, merged, ',');\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01583)\n                  \"Range: %s | %s (%d : %d : %\"APR_OFF_T_FMT\")\",\n                  it, r->range, *overlaps, *reversals, clength);\n\n    return num_ranges;\n}",
            "is_external": false,
            "definition": "static int ap_set_byterange(request_rec *r, apr_off_t clength,\n                            apr_array_header_t **indexes,\n                            int *overlaps, int *reversals)\n{\n    const char *range;\n    const char *ct;\n    char *cur;\n    apr_array_header_t *merged;\n    int num_ranges = 0, unsatisfiable = 0;\n    apr_off_t ostart = 0, oend = 0, sum_lengths = 0;\n    int in_merge = 0;\n    indexes_t *idx;\n    int ranges = 1;\n    int i;\n    const char *it;\n\n    *overlaps = 0;\n    *reversals = 0;\n\n    if (r->assbackwards) {\n        return 0;\n    }\n\n    range = apr_table_get(r->headers_in, \"Range\");\n    if (!range || ap_cstr_casecmpn(range, \"bytes=\", 6) || r->status != HTTP_OK) {\n        return 0;\n    }\n\n    /* is content already a single range? */\n    if (apr_table_get(r->headers_out, \"Content-Range\")) {\n        return 0;\n    }\n\n    /* is content already a multiple range? */\n    if ((ct = apr_table_get(r->headers_out, \"Content-Type\"))\n        && ap_cstr_casecmpn(ct, \"multipart/byteranges\", 20) == 0) {\n            return 0;\n    }\n\n    /*\n     * Check the If-Range header for Etag or Date.\n     */\n    if (AP_CONDITION_NOMATCH == ap_condition_if_range(r, r->headers_out)) {\n        return 0;\n    }\n\n    range += 6;\n    it = range;\n    while (*it) {\n        if (*it++ == ',') {\n            ranges++;\n        }\n    }\n    it = range;\n    if (ranges > MAX_PREALLOC_RANGES) {\n        ranges = MAX_PREALLOC_RANGES;\n    }\n    *indexes = apr_array_make(r->pool, ranges, sizeof(indexes_t));\n    while ((cur = ap_getword(r->pool, &range, ','))) {\n        char *dash;\n        apr_off_t number, start, end;\n\n        if (!*cur)\n            break;\n\n        /*\n         * Per RFC 2616 14.35.1: If there is at least one syntactically invalid\n         * byte-range-spec, we must ignore the whole header.\n         */\n\n        if (!(dash = strchr(cur, '-'))) {\n            return 0;\n        }\n\n        if (dash == cur) {\n            /* In the form \"-5\" */\n            if (!ap_parse_strict_length(&number, dash+1)) {\n                return 0;\n            }\n            if (number < 1) {\n                return 0;\n            }\n            start = clength - number;\n            end = clength - 1;\n        }\n        else {\n            *dash++ = '\\0';\n            if (!ap_parse_strict_length(&number, cur)) {\n                return 0;\n            }\n            start = number;\n            if (*dash) {\n                if (!ap_parse_strict_length(&number, dash)) {\n                    return 0;\n                }\n                end = number;\n                if (start > end) {\n                    return 0;\n                }\n            }\n            else {                  /* \"5-\" */\n                end = clength - 1;\n                /*\n                 * special case: 0-\n                 *   ignore all other ranges provided\n                 *   return as a single range: 0-\n                 */\n                if (start == 0) {\n                    num_ranges = 0;\n                    sum_lengths = 0;\n                    in_merge = 1;\n                    oend = end;\n                    ostart = start;\n                    apr_array_clear(*indexes);\n                    break;\n                }\n            }\n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n        if (start >= clength) {\n            unsatisfiable = 1;\n            continue;\n        }\n        if (end >= clength) {\n            end = clength - 1;\n        }\n\n        if (!in_merge) {\n            /* new set */\n            ostart = start;\n            oend = end;\n            in_merge = 1;\n            continue;\n        }\n        in_merge = 0;\n\n        if (start >= ostart && end <= oend) {\n            in_merge = 1;\n        }\n\n        if (start < ostart && end >= ostart-1) {\n            ostart = start;\n            ++*reversals;\n            in_merge = 1;\n        }\n        if (end >= oend && start <= oend+1 ) {\n            oend = end;\n            in_merge = 1;\n        }\n\n        if (in_merge) {\n            ++*overlaps;\n            continue;\n        } else {\n            idx = (indexes_t *)apr_array_push(*indexes);\n            idx->start = ostart;\n            idx->end = oend;\n            sum_lengths += oend - ostart + 1;\n            /* new set again */\n            in_merge = 1;\n            ostart = start;\n            oend = end;\n            num_ranges++;\n        }\n    }\n\n    if (in_merge) {\n        idx = (indexes_t *)apr_array_push(*indexes);\n        idx->start = ostart;\n        idx->end = oend;\n        sum_lengths += oend - ostart + 1;\n        num_ranges++;\n    }\n    else if (num_ranges == 0 && unsatisfiable) {\n        /* If all ranges are unsatisfiable, we should return 416 */\n        return -1;\n    }\n    if (sum_lengths > clength) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                      \"Sum of ranges larger than file, ignoring.\");\n        return 0;\n    }\n\n    /*\n     * create the merged table now, now that we know we need it\n     */\n    merged = apr_array_make(r->pool, num_ranges, sizeof(char *));\n    idx = (indexes_t *)(*indexes)->elts;\n    for (i = 0; i < (*indexes)->nelts; i++, idx++) {\n        char **new = (char **)apr_array_push(merged);\n        *new = apr_psprintf(r->pool, \"%\" APR_OFF_T_FMT \"-%\" APR_OFF_T_FMT,\n                            idx->start, idx->end);\n    }\n\n    r->status = HTTP_PARTIAL_CONTENT;\n    r->range = apr_array_pstrcat(r->pool, merged, ',');\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01583)\n                  \"Range: %s | %s (%d : %d : %\"APR_OFF_T_FMT\")\",\n                  it, r->range, *overlaps, *reversals, clength);\n\n    return num_ranges;\n}"
          },
          "apr_brigade_create": {
            "declaration": "APU_DECLARE(apr_bucket_brigade *) apr_brigade_create(apr_pool_t *p,\n                                                     apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "send_416": {
            "declaration": "static apr_status_t send_416(ap_filter_t *f, apr_bucket_brigade *tmpbb)\n{\n    apr_bucket *e;\n    conn_rec *c = f->r->connection;\n    ap_remove_output_filter(f);\n    f->r->status = HTTP_OK;\n    e = ap_bucket_error_create(HTTP_RANGE_NOT_SATISFIABLE, NULL,\n                               f->r->pool, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(tmpbb, e);\n    e = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(tmpbb, e);\n    return ap_pass_brigade(f->next, tmpbb);\n}",
            "is_external": false,
            "definition": "static apr_status_t send_416(ap_filter_t *f, apr_bucket_brigade *tmpbb)\n{\n    apr_bucket *e;\n    conn_rec *c = f->r->connection;\n    ap_remove_output_filter(f);\n    f->r->status = HTTP_OK;\n    e = ap_bucket_error_create(HTTP_RANGE_NOT_SATISFIABLE, NULL,\n                               f->r->pool, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(tmpbb, e);\n    e = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(tmpbb, e);\n    return ap_pass_brigade(f->next, tmpbb);\n}"
          },
          "ap_make_content_type": {
            "declaration": "AP_DECLARE(const char *) ap_make_content_type(request_rec *r,\n                                              const char *type)",
            "is_external": true,
            "definition": null
          },
          "ap_set_content_type_ex": {
            "declaration": "AP_DECLARE(void) ap_set_content_type_ex(request_rec *r, const char *ct, int trusted)",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_set_content_type_ex(request_rec *r, const char *ct, int trusted)\n{\n    ap_set_content_type(r, ct);\n    AP_REQUEST_SET_BNOTE(r, AP_REQUEST_TRUSTED_CT, trusted ? AP_REQUEST_TRUSTED_CT : 0);\n}"
          },
          "apr_pstrcat": {
            "declaration": "APR_DECLARE_NONSTD(char *) apr_pstrcat(apr_pool_t *p, ...)\n#if defined(__GNUC__) && __GNUC__ >= 4\n    __attribute__((sentinel))",
            "is_external": true,
            "definition": null
          },
          "copy_brigade_range": {
            "declaration": "static apr_status_t copy_brigade_range(apr_bucket_brigade *bb,\n                                       apr_bucket_brigade *bbout,\n                                       apr_off_t start,\n                                       apr_off_t end)\n{\n    apr_bucket *first = NULL, *last = NULL, *out_first = NULL, *e;\n    apr_uint64_t pos = 0, off_first = 0, off_last = 0;\n    apr_status_t rv;\n    apr_uint64_t start64, end64;\n    apr_off_t pofft = 0;\n\n    /*\n     * Once we know that start and end are >= 0 convert everything to apr_uint64_t.\n     * See the comments in apr_brigade_partition why.\n     * In short apr_off_t (for values >= 0)and apr_size_t fit into apr_uint64_t.\n     */\n    start64 = (apr_uint64_t)start;\n    end64 = (apr_uint64_t)end;\n\n    if (start < 0 || end < 0 || start64 > end64)\n        return APR_EINVAL;\n\n    for (e = APR_BRIGADE_FIRST(bb);\n         e != APR_BRIGADE_SENTINEL(bb);\n         e = APR_BUCKET_NEXT(e))\n    {\n        apr_uint64_t elen64;\n        /* we know that no bucket has undefined length (-1) */\n        AP_DEBUG_ASSERT(e->length != (apr_size_t)(-1));\n        elen64 = (apr_uint64_t)e->length;\n        if (!first && (elen64 + pos > start64)) {\n            first = e;\n            off_first = pos;\n        }\n        if (elen64 + pos > end64) {\n            last = e;\n            off_last = pos;\n            break;\n        }\n        pos += elen64;\n    }\n    if (!first || !last)\n        return APR_EINVAL;\n\n    e = first;\n    while (1)\n    {\n        apr_bucket *copy;\n        AP_DEBUG_ASSERT(e != APR_BRIGADE_SENTINEL(bb));\n        rv = apr_bucket_copy(e, &copy);\n        if (rv != APR_SUCCESS) {\n            apr_brigade_cleanup(bbout);\n            return rv;\n        }\n\n        APR_BRIGADE_INSERT_TAIL(bbout, copy);\n        if (e == first) {\n            if (off_first != start64) {\n                rv = apr_bucket_split(copy, (apr_size_t)(start64 - off_first));\n                if (rv != APR_SUCCESS) {\n                    apr_brigade_cleanup(bbout);\n                    return rv;\n                }\n                out_first = APR_BUCKET_NEXT(copy);\n                apr_bucket_delete(copy);\n            }\n            else {\n                out_first = copy;\n            }\n        }\n        if (e == last) {\n            if (e == first) {\n                off_last += start64 - off_first;\n                copy = out_first;\n            }\n            if (end64 - off_last != (apr_uint64_t)e->length) {\n                rv = apr_bucket_split(copy, (apr_size_t)(end64 + 1 - off_last));\n                if (rv != APR_SUCCESS) {\n                    apr_brigade_cleanup(bbout);\n                    return rv;\n                }\n                copy = APR_BUCKET_NEXT(copy);\n                if (copy != APR_BRIGADE_SENTINEL(bbout)) {\n                    apr_bucket_delete(copy);\n                }\n            }\n            break;\n        }\n        e = APR_BUCKET_NEXT(e);\n    }\n\n    AP_DEBUG_ASSERT(APR_SUCCESS == apr_brigade_length(bbout, 1, &pofft));\n    pos = (apr_uint64_t)pofft;\n    AP_DEBUG_ASSERT(pos == end64 - start64 + 1);\n    return APR_SUCCESS;\n}",
            "is_external": false,
            "definition": "static apr_status_t copy_brigade_range(apr_bucket_brigade *bb,\n                                       apr_bucket_brigade *bbout,\n                                       apr_off_t start,\n                                       apr_off_t end)\n{\n    apr_bucket *first = NULL, *last = NULL, *out_first = NULL, *e;\n    apr_uint64_t pos = 0, off_first = 0, off_last = 0;\n    apr_status_t rv;\n    apr_uint64_t start64, end64;\n    apr_off_t pofft = 0;\n\n    /*\n     * Once we know that start and end are >= 0 convert everything to apr_uint64_t.\n     * See the comments in apr_brigade_partition why.\n     * In short apr_off_t (for values >= 0)and apr_size_t fit into apr_uint64_t.\n     */\n    start64 = (apr_uint64_t)start;\n    end64 = (apr_uint64_t)end;\n\n    if (start < 0 || end < 0 || start64 > end64)\n        return APR_EINVAL;\n\n    for (e = APR_BRIGADE_FIRST(bb);\n         e != APR_BRIGADE_SENTINEL(bb);\n         e = APR_BUCKET_NEXT(e))\n    {\n        apr_uint64_t elen64;\n        /* we know that no bucket has undefined length (-1) */\n        AP_DEBUG_ASSERT(e->length != (apr_size_t)(-1));\n        elen64 = (apr_uint64_t)e->length;\n        if (!first && (elen64 + pos > start64)) {\n            first = e;\n            off_first = pos;\n        }\n        if (elen64 + pos > end64) {\n            last = e;\n            off_last = pos;\n            break;\n        }\n        pos += elen64;\n    }\n    if (!first || !last)\n        return APR_EINVAL;\n\n    e = first;\n    while (1)\n    {\n        apr_bucket *copy;\n        AP_DEBUG_ASSERT(e != APR_BRIGADE_SENTINEL(bb));\n        rv = apr_bucket_copy(e, &copy);\n        if (rv != APR_SUCCESS) {\n            apr_brigade_cleanup(bbout);\n            return rv;\n        }\n\n        APR_BRIGADE_INSERT_TAIL(bbout, copy);\n        if (e == first) {\n            if (off_first != start64) {\n                rv = apr_bucket_split(copy, (apr_size_t)(start64 - off_first));\n                if (rv != APR_SUCCESS) {\n                    apr_brigade_cleanup(bbout);\n                    return rv;\n                }\n                out_first = APR_BUCKET_NEXT(copy);\n                apr_bucket_delete(copy);\n            }\n            else {\n                out_first = copy;\n            }\n        }\n        if (e == last) {\n            if (e == first) {\n                off_last += start64 - off_first;\n                copy = out_first;\n            }\n            if (end64 - off_last != (apr_uint64_t)e->length) {\n                rv = apr_bucket_split(copy, (apr_size_t)(end64 + 1 - off_last));\n                if (rv != APR_SUCCESS) {\n                    apr_brigade_cleanup(bbout);\n                    return rv;\n                }\n                copy = APR_BUCKET_NEXT(copy);\n                if (copy != APR_BRIGADE_SENTINEL(bbout)) {\n                    apr_bucket_delete(copy);\n                }\n            }\n            break;\n        }\n        e = APR_BUCKET_NEXT(e);\n    }\n\n    AP_DEBUG_ASSERT(APR_SUCCESS == apr_brigade_length(bbout, 1, &pofft));\n    pos = (apr_uint64_t)pofft;\n    AP_DEBUG_ASSERT(pos == end64 - start64 + 1);\n    return APR_SUCCESS;\n}"
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "apr_table_setn": {
            "declaration": "APR_DECLARE(void) apr_table_setn(apr_table_t *t, const char *key,\n                                 const char *val)",
            "is_external": true,
            "definition": null
          },
          "apr_psprintf": {
            "declaration": "APR_DECLARE_NONSTD(char *) apr_psprintf(apr_pool_t *p, const char *fmt, ...)\n        __attribute__((format(printf,2,3)))",
            "is_external": true,
            "definition": null
          },
          "apr_bucket_pool_create": {
            "declaration": "APU_DECLARE(apr_bucket *) apr_bucket_pool_create(const char *buf, \n                                                 apr_size_t length,\n                                                 apr_pool_t *pool,\n                                                 apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "strlen": {
            "declaration": "extern size_t strlen (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_table_unset": {
            "declaration": "APR_DECLARE(void) apr_table_unset(apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_cleanup": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_cleanup(void *data)",
            "is_external": true,
            "definition": null
          },
          "apr_bucket_eos_create": {
            "declaration": "APU_DECLARE(apr_bucket *) apr_bucket_eos_create(apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_destroy": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_destroy(apr_bucket_brigade *b)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {
          "BYTERANGE_FMT": {
            "name": "BYTERANGE_FMT",
            "value": "\"%\" APR_OFF_T_FMT \"-%\" APR_OFF_T_FMT \"/%\" APR_OFF_T_FMT",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "#define BYTERANGE_FMT \"%\" APR_OFF_T_FMT \"-%\" APR_OFF_T_FMT \"/%\" APR_OFF_T_FMT",
            "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c:286",
            "condition": ""
          },
          "AP_DEFAULT_MAX_RANGES": {
            "name": "AP_DEFAULT_MAX_RANGES",
            "value": "200",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "#define AP_DEFAULT_MAX_RANGES 200",
            "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c:59",
            "condition": "#ifndef AP_DEFAULT_MAX_RANGES"
          },
          "AP_DEFAULT_MAX_OVERLAPS": {
            "name": "AP_DEFAULT_MAX_OVERLAPS",
            "value": "20",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "#define AP_DEFAULT_MAX_OVERLAPS 20",
            "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c:62",
            "condition": "#ifndef AP_DEFAULT_MAX_OVERLAPS"
          },
          "AP_DEFAULT_MAX_REVERSALS": {
            "name": "AP_DEFAULT_MAX_REVERSALS",
            "value": "20",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "#define AP_DEFAULT_MAX_REVERSALS 20",
            "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c:65",
            "condition": "#ifndef AP_DEFAULT_MAX_REVERSALS"
          }
        },
        "used_structs": {
          "ap_filter_t": {
            "name": "ap_filter_t",
            "definition": "struct ap_filter_t {\n    /** The internal representation of this filter.  This includes\n     *  the filter's name, type, and the actual function pointer.\n     */\n    ap_filter_rec_t *frec;\n\n    /** A place to store any data associated with the current filter */\n    void *ctx;\n\n    /** The next filter in the chain */\n    ap_filter_t *next;\n\n    /** The request_rec associated with the current filter.  If a sub-request\n     *  adds filters, then the sub-request is the request associated with the\n     *  filter.\n     */\n    request_rec *r;\n\n    /** The conn_rec associated with the current filter.  This is analogous\n     *  to the request_rec, except that it is used for connection filters.\n     */\n    conn_rec *c;\n}",
            "typedef_name": null,
            "fields": {
              "frec": "ap_filter_rec_t *",
              "ctx": "void *",
              "next": "ap_filter_t *",
              "r": "request_rec *",
              "c": "conn_rec *"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "conn_rec": {
            "name": "conn_rec",
            "definition": "struct conn_rec {\n    /** Pool associated with this connection */\n    apr_pool_t *pool;\n    /** Physical vhost this conn came in on */\n    server_rec *base_server;\n    /** used by http_vhost.c */\n    void *vhost_lookup_data;\n\n    /* Information about the connection itself */\n    /** local address */\n    apr_sockaddr_t *local_addr;\n    /** remote address; this is the end-point of the next hop, for the address\n     *  of the request creator, see useragent_addr in request_rec\n     */\n    apr_sockaddr_t *client_addr;\n\n    /** Client's IP address; this is the end-point of the next hop, for the\n     *  IP of the request creator, see useragent_ip in request_rec\n     */\n    char *client_ip;\n    /** Client's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     * get_remote_host() */\n    char *remote_host;\n    /** Only ever set if doing rfc1413 lookups.  N.B. Only access this through\n     *  get_remote_logname() */\n    char *remote_logname;\n\n    /** server IP address */\n    char *local_ip;\n    /** used for ap_get_server_name when UseCanonicalName is set to DNS\n     *  (ignores setting of HostnameLookups) */\n    char *local_host;\n\n    /** ID of this connection; unique at any point in time */\n    long id;\n    /** Config vector containing pointers to connections per-server\n     *  config structures. */\n    struct ap_conf_vector_t *conn_config;\n    /** Notes on *this* connection: send note from one module to\n     *  another. must remain valid for all requests on this conn */\n    apr_table_t *notes;\n    /** A list of input filters to be used for this connection */\n    struct ap_filter_t *input_filters;\n    /** A list of output filters to be used for this connection */\n    struct ap_filter_t *output_filters;\n    /** handle to scoreboard information for this connection */\n    void *sbh;\n    /** The bucket allocator to use for all bucket/brigade creations */\n    struct apr_bucket_alloc_t *bucket_alloc;\n    /** The current state of this connection; may be NULL if not used by MPM */\n    conn_state_t *cs;\n    /** Is there data pending in the input filters? */\n    int data_in_input_filters;\n    /** Is there data pending in the output filters? */\n    int data_in_output_filters;\n\n    /** Are there any filters that clogg/buffer the input stream, breaking\n     *  the event mpm.\n     */\n    unsigned int clogging_input_filters:1;\n\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success */\n    signed int double_reverse:2;\n\n    /** Are we still talking? */\n    unsigned aborted;\n\n    /** Are we going to keep the connection alive for another request?\n     * @see ap_conn_keepalive_e */\n    ap_conn_keepalive_e keepalive;\n\n    /** How many times have we used it? */\n    int keepalives;\n\n    /** Optional connection log level configuration. May point to a server or\n     *  per_dir config, i.e. must be copied before modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify this connection in error log. Set when the first\n     *  error log entry for this connection is generated.\n     */\n    const char *log_id;\n\n\n    /** This points to the current thread being used to process this request,\n     * over the lifetime of a request, the value may change. Users of the connection\n     * record should not rely upon it staying the same between calls that involve\n     * the MPM.\n     */\n#if APR_HAS_THREADS\n    apr_thread_t *current_thread;\n#endif\n\n    /** The \"real\" master connection. NULL if I am the master. */\n    conn_rec *master;\n\n    int outgoing;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "base_server": "server_rec *",
              "vhost_lookup_data": "void *",
              "local_addr": "apr_sockaddr_t *",
              "client_addr": "apr_sockaddr_t *",
              "client_ip": "char *",
              "remote_host": "char *",
              "remote_logname": "char *",
              "local_ip": "char *",
              "local_host": "char *",
              "id": "long",
              "conn_config": "struct ap_conf_vector_t *",
              "notes": "apr_table_t *",
              "input_filters": "struct ap_filter_t *",
              "output_filters": "struct ap_filter_t *",
              "sbh": "void *",
              "bucket_alloc": "struct apr_bucket_alloc_t *",
              "cs": "conn_state_t *",
              "data_in_input_filters": "int",
              "data_in_output_filters": "int",
              "clogging_input_filters": "unsigned int",
              "double_reverse": "int",
              "aborted": "unsigned int",
              "keepalive": "ap_conn_keepalive_e",
              "keepalives": "int",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "current_thread": "apr_thread_t *",
              "master": "conn_rec *",
              "outgoing": "int"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "apr_array_header_t": {
            "name": "apr_array_header_t",
            "definition": "struct apr_array_header_t {\n    /** The pool the array is allocated out of */\n    apr_pool_t *pool;\n    /** The amount of memory allocated for each element of the array */\n    int elt_size;\n    /** The number of active elements in the array */\n    int nelts;\n    /** The number of elements allocated in the array */\n    int nalloc;\n    /** The elements in the array */\n    char *elts;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "elt_size": "int",
              "nelts": "int",
              "nalloc": "int",
              "elts": "char *"
            },
            "condition": ""
          },
          "indexes_t": {
            "name": "indexes_t",
            "definition": "struct indexes_t {\n    apr_off_t start;\n    apr_off_t end;\n}",
            "typedef_name": null,
            "fields": {
              "start": "apr_off_t",
              "end": "apr_off_t"
            },
            "condition": ""
          },
          "core_dir_config": {
            "name": "core_dir_config",
            "definition": "struct {\n    /** path of the directory/regex/etc. see also d_is_fnmatch/absolute below */\n    char *d;\n    /** the number of slashes in d */\n    unsigned d_components;\n\n    /** If (opts & OPT_UNSET) then no absolute assignment to options has\n     * been made.\n     * invariant: (opts_add & opts_remove) == 0\n     * Which said another way means that the last relative (options + or -)\n     * assignment made to each bit is recorded in exactly one of opts_add\n     * or opts_remove.\n     */\n    allow_options_t opts;\n    allow_options_t opts_add;\n    allow_options_t opts_remove;\n    overrides_t override;\n    allow_options_t override_opts;\n\n    /* Used to be the custom response config. No longer used. */\n    char **response_code_strings; /* from ErrorDocument, not from\n                                   * ap_custom_response() */\n\n    /* Hostname resolution etc */\n#define HOSTNAME_LOOKUP_OFF     0\n#define HOSTNAME_LOOKUP_ON      1\n#define HOSTNAME_LOOKUP_DOUBLE  2\n#define HOSTNAME_LOOKUP_UNSET   3\n    unsigned int hostname_lookups : 4;\n\n    unsigned int content_md5 : 2;  /* calculate Content-MD5? */\n\n#define USE_CANONICAL_NAME_OFF   (0)\n#define USE_CANONICAL_NAME_ON    (1)\n#define USE_CANONICAL_NAME_DNS   (2)\n#define USE_CANONICAL_NAME_UNSET (3)\n    unsigned use_canonical_name : 2;\n\n    /* since is_fnmatch(conf->d) was being called so frequently in\n     * directory_walk() and its relatives, this field was created and\n     * is set to the result of that call.\n     */\n    unsigned d_is_fnmatch : 1;\n\n    /* should we force a charset on any outgoing parameterless content-type?\n     * if so, which charset?\n     */\n#define ADD_DEFAULT_CHARSET_OFF   (0)\n#define ADD_DEFAULT_CHARSET_ON    (1)\n#define ADD_DEFAULT_CHARSET_UNSET (2)\n    unsigned add_default_charset : 2;\n    const char *add_default_charset_name;\n\n    /* System Resource Control */\n#ifdef RLIMIT_CPU\n    struct rlimit *limit_cpu;\n#endif\n#if defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined(RLIMIT_AS)\n    struct rlimit *limit_mem;\n#endif\n#ifdef RLIMIT_NPROC\n    struct rlimit *limit_nproc;\n#endif\n    apr_off_t limit_req_body;      /* limit on bytes in request msg body */\n    long limit_xml_body;           /* limit on bytes in XML request msg body */\n\n    /* logging options */\n\n    server_signature_e server_signature;\n\n    /* Access control */\n    apr_array_header_t *sec_file;\n    apr_array_header_t *sec_if;\n    ap_regex_t *r;\n\n    const char *mime_type;       /* forced with ForceType  */\n    const char *handler;         /* forced by something other than SetHandler */\n    const char *output_filters;  /* forced with SetOutputFilters */\n    const char *input_filters;   /* forced with SetInputFilters */\n    int accept_path_info;        /* forced with AcceptPathInfo */\n\n    /*\n     * What attributes/data should be included in ETag generation?\n     */\n    etag_components_t etag_bits;\n    etag_components_t etag_add;\n    etag_components_t etag_remove;\n\n    /*\n     * Run-time performance tuning\n     */\n#define ENABLE_MMAP_OFF    (0)\n#define ENABLE_MMAP_ON     (1)\n#define ENABLE_MMAP_UNSET  (2)\n    unsigned int enable_mmap : 2;  /* whether files in this dir can be mmap'ed */\n\n#define ENABLE_SENDFILE_OFF    (0)\n#define ENABLE_SENDFILE_ON     (1)\n#define ENABLE_SENDFILE_UNSET  (2)\n    unsigned int enable_sendfile : 2;  /* files in this dir can be sendfile'ed */\n\n#define USE_CANONICAL_PHYS_PORT_OFF   (0)\n#define USE_CANONICAL_PHYS_PORT_ON    (1)\n#define USE_CANONICAL_PHYS_PORT_UNSET (2)\n    unsigned int use_canonical_phys_port : 2;\n\n    unsigned int allow_encoded_slashes : 1; /* URLs may contain %2f w/o being\n                                             * pitched indiscriminately */\n    unsigned int decode_encoded_slashes : 1; /* whether to decode encoded slashes in URLs */\n\n#define AP_CONDITION_IF        1\n#define AP_CONDITION_ELSE      2\n#define AP_CONDITION_ELSEIF    (AP_CONDITION_ELSE|AP_CONDITION_IF)\n    unsigned int condition_ifelse : 2; /* is this an <If>, <ElseIf>, or <Else> */\n\n    ap_expr_info_t *condition;   /* Conditionally merge <If> sections */\n\n    /** per-dir log config */\n    struct ap_logconf *log;\n\n    /** Table of directives allowed per AllowOverrideList */\n    apr_table_t *override_list;\n\n#define AP_MAXRANGES_UNSET     -1\n#define AP_MAXRANGES_DEFAULT   -2\n#define AP_MAXRANGES_UNLIMITED -3\n#define AP_MAXRANGES_NORANGES   0\n    /** Number of Ranges before returning HTTP_OK. **/\n    int max_ranges;\n    /** Max number of Range overlaps (merges) allowed **/\n    int max_overlaps;\n    /** Max number of Range reversals (eg: 200-300, 100-125) allowed **/\n    int max_reversals;\n\n    /** Named back references */\n    apr_array_header_t *refs;\n\n    /** Custom response config with expression support. The hash table\n     * contains compiled expressions keyed against the custom response\n     * code.\n     */\n    apr_hash_t *response_code_exprs;\n\n#define AP_CGI_PASS_AUTH_OFF     (0)\n#define AP_CGI_PASS_AUTH_ON      (1)\n#define AP_CGI_PASS_AUTH_UNSET   (2)\n    /** CGIPassAuth: Whether HTTP authorization headers will be passed to\n     * scripts as CGI variables; affects all modules calling\n     * ap_add_common_vars(), as well as any others using this field as \n     * advice\n     */\n    unsigned int cgi_pass_auth : 2;\n    unsigned int qualify_redirect_url :2;\n    ap_expr_info_t  *expr_handler;         /* forced with SetHandler */\n\n    /** Table of rules for building CGI variables, NULL if none configured */\n    apr_hash_t *cgi_var_rules;\n\n    apr_size_t read_buf_size;\n}",
            "typedef_name": null,
            "fields": {
              "d": "char *",
              "d_components": "unsigned int",
              "opts": "allow_options_t",
              "opts_add": "allow_options_t",
              "opts_remove": "allow_options_t",
              "override": "overrides_t",
              "override_opts": "allow_options_t",
              "response_code_strings": "char **",
              "hostname_lookups": "unsigned int",
              "content_md5": "unsigned int",
              "use_canonical_name": "unsigned int",
              "d_is_fnmatch": "unsigned int",
              "add_default_charset": "unsigned int",
              "add_default_charset_name": "const char *",
              "limit_cpu": "struct rlimit *",
              "limit_mem": "struct rlimit *",
              "limit_nproc": "struct rlimit *",
              "limit_req_body": "apr_off_t",
              "limit_xml_body": "long",
              "server_signature": "server_signature_e",
              "sec_file": "apr_array_header_t *",
              "sec_if": "apr_array_header_t *",
              "r": "ap_regex_t *",
              "mime_type": "const char *",
              "handler": "const char *",
              "output_filters": "const char *",
              "input_filters": "const char *",
              "accept_path_info": "int",
              "etag_bits": "etag_components_t",
              "etag_add": "etag_components_t",
              "etag_remove": "etag_components_t",
              "enable_mmap": "unsigned int",
              "enable_sendfile": "unsigned int",
              "use_canonical_phys_port": "unsigned int",
              "allow_encoded_slashes": "unsigned int",
              "decode_encoded_slashes": "unsigned int",
              "condition_ifelse": "unsigned int",
              "condition": "ap_expr_info_t *",
              "log": "struct ap_logconf *",
              "override_list": "apr_table_t *",
              "max_ranges": "int",
              "max_overlaps": "int",
              "max_reversals": "int",
              "refs": "apr_array_header_t *",
              "response_code_exprs": "apr_hash_t *",
              "cgi_pass_auth": "unsigned int",
              "qualify_redirect_url": "unsigned int",
              "expr_handler": "ap_expr_info_t *",
              "cgi_var_rules": "apr_hash_t *",
              "read_buf_size": "apr_size_t"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "apr_bucket_type_eos": {
            "name": "apr_bucket_type_eos",
            "type": "const apr_bucket_type_t",
            "is_extern": true,
            "is_static": false,
            "definition": "extern const apr_bucket_type_t apr_bucket_type_eos",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "ap_multipart_boundary": {
            "name": "ap_multipart_boundary",
            "type": "const char *",
            "is_extern": true,
            "is_static": false,
            "definition": "extern const char *ap_multipart_boundary",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "apr_size_t",
          "apr_off_t",
          "apr_status_t"
        ]
      },
      "source_code": "AP_CORE_DECLARE_NONSTD(apr_status_t) ap_byterange_filter(ap_filter_t *f,\n                                                         apr_bucket_brigade *bb)\n{\n    request_rec *r = f->r;\n    conn_rec *c = r->connection;\n    apr_bucket *e;\n    apr_bucket_brigade *bsend;\n    apr_bucket_brigade *tmpbb;\n    apr_off_t range_start;\n    apr_off_t range_end;\n    apr_off_t clength = 0;\n    apr_status_t rv;\n    int found = 0;\n    int num_ranges;\n    char *bound_head = NULL;\n    apr_array_header_t *indexes;\n    indexes_t *idx;\n    int i;\n    int original_status;\n    int max_ranges, max_overlaps, max_reversals;\n    int overlaps = 0, reversals = 0;\n    core_dir_config *core_conf = ap_get_core_module_config(r->per_dir_config);\n\n    max_ranges = ( (core_conf->max_ranges >= 0 || core_conf->max_ranges == AP_MAXRANGES_UNLIMITED)\n                   ? core_conf->max_ranges\n                   : AP_DEFAULT_MAX_RANGES );\n    max_overlaps = ( (core_conf->max_overlaps >= 0 || core_conf->max_overlaps == AP_MAXRANGES_UNLIMITED)\n                  ? core_conf->max_overlaps\n                  : AP_DEFAULT_MAX_OVERLAPS );\n    max_reversals = ( (core_conf->max_reversals >= 0 || core_conf->max_reversals == AP_MAXRANGES_UNLIMITED)\n                  ? core_conf->max_reversals\n                  : AP_DEFAULT_MAX_REVERSALS );\n    /*\n     * Iterate through the brigade until reaching EOS or a bucket with\n     * unknown length.\n     */\n    for (e = APR_BRIGADE_FIRST(bb);\n         (e != APR_BRIGADE_SENTINEL(bb) && !APR_BUCKET_IS_EOS(e)\n          && e->length != (apr_size_t)-1);\n         e = APR_BUCKET_NEXT(e)) {\n        clength += e->length;\n    }\n\n    /*\n     * Don't attempt to do byte range work if this brigade doesn't\n     * contain an EOS, or if any of the buckets has an unknown length;\n     * this avoids the cases where it is expensive to perform\n     * byteranging (i.e. may require arbitrary amounts of memory).\n     */\n    if (!APR_BUCKET_IS_EOS(e) || clength <= 0) {\n        ap_remove_output_filter(f);\n        return ap_pass_brigade(f->next, bb);\n    }\n\n    original_status = r->status;\n    num_ranges = ap_set_byterange(r, clength, &indexes, &overlaps, &reversals);\n\n    /* No Ranges or we hit a limit? We have nothing to do, get out of the way. */\n    if (num_ranges == 0 ||\n        (max_ranges >= 0 && num_ranges > max_ranges) ||\n        (max_overlaps >= 0 && overlaps > max_overlaps) ||\n        (max_reversals >= 0 && reversals > max_reversals)) {\n        r->status = original_status;\n        ap_remove_output_filter(f);\n        return ap_pass_brigade(f->next, bb);\n    }\n\n    /* this brigade holds what we will be sending */\n    bsend = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    if (num_ranges < 0)\n        return send_416(f, bsend);\n\n    if (num_ranges > 1) {\n        /* Is ap_make_content_type required here? */\n        const char *orig_ct = ap_make_content_type(r, r->content_type);\n\n        ap_set_content_type_ex(r, apr_pstrcat(r->pool,\n                                           \"multipart/byteranges; boundary=\",\n                                           ap_multipart_boundary, NULL), 1);\n\n        if (orig_ct) {\n            bound_head = apr_pstrcat(r->pool,\n                                     CRLF \"--\", ap_multipart_boundary,\n                                     CRLF \"Content-type: \",\n                                     orig_ct,\n                                     CRLF \"Content-range: bytes \",\n                                     NULL);\n        }\n        else {\n            /* if we have no type for the content, do our best */\n            bound_head = apr_pstrcat(r->pool,\n                                     CRLF \"--\", ap_multipart_boundary,\n                                     CRLF \"Content-range: bytes \",\n                                     NULL);\n        }\n        ap_xlate_proto_to_ascii(bound_head, strlen(bound_head));\n    }\n\n    tmpbb = apr_brigade_create(r->pool, c->bucket_alloc);\n\n    idx = (indexes_t *)indexes->elts;\n    for (i = 0; i < indexes->nelts; i++, idx++) {\n        range_start = idx->start;\n        range_end = idx->end;\n\n        rv = copy_brigade_range(bb, tmpbb, range_start, range_end);\n        if (rv != APR_SUCCESS ) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01584)\n                          \"copy_brigade_range() failed [%\" APR_OFF_T_FMT\n                          \"-%\" APR_OFF_T_FMT \",%\" APR_OFF_T_FMT \"]\",\n                          range_start, range_end, clength);\n            continue;\n        }\n        found = 1;\n\n        /*\n         * For single range requests, we must produce Content-Range header.\n         * Otherwise, we need to produce the multipart boundaries.\n         */\n        if (num_ranges == 1) {\n            apr_table_setn(r->headers_out, \"Content-Range\",\n                           apr_psprintf(r->pool, \"bytes \" BYTERANGE_FMT,\n                                        range_start, range_end, clength));\n        }\n        else {\n            char *ts;\n\n            e = apr_bucket_pool_create(bound_head, strlen(bound_head),\n                                       r->pool, c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bsend, e);\n\n            ts = apr_psprintf(r->pool, BYTERANGE_FMT CRLF CRLF,\n                              range_start, range_end, clength);\n            ap_xlate_proto_to_ascii(ts, strlen(ts));\n            e = apr_bucket_pool_create(ts, strlen(ts), r->pool,\n                                       c->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(bsend, e);\n        }\n\n        APR_BRIGADE_CONCAT(bsend, tmpbb);\n        if (i && !(i & 0x1F)) {\n            /*\n             * Every now and then, pass what we have down the filter chain.\n             * In this case, the content-length filter cannot calculate and\n             * set the content length and we must remove any Content-Length\n             * header already present.\n             */\n            apr_table_unset(r->headers_out, \"Content-Length\");\n            if ((rv = ap_pass_brigade(f->next, bsend)) != APR_SUCCESS)\n                return rv;\n            apr_brigade_cleanup(bsend);\n        }\n    }\n\n    if (found == 0) {\n        /* bsend is assumed to be empty if we get here. */\n        return send_416(f, bsend);\n    }\n\n    if (num_ranges > 1) {\n        char *end;\n\n        /* add the final boundary */\n        end = apr_pstrcat(r->pool, CRLF \"--\", ap_multipart_boundary, \"--\" CRLF,\n                          NULL);\n        ap_xlate_proto_to_ascii(end, strlen(end));\n        e = apr_bucket_pool_create(end, strlen(end), r->pool, c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bsend, e);\n    }\n\n    e = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bsend, e);\n\n    /* we're done with the original content - all of our data is in bsend. */\n    apr_brigade_cleanup(bb);\n    apr_brigade_destroy(tmpbb);\n\n    /* send our multipart output */\n    return ap_pass_brigade(f->next, bsend);\n}"
    },
    "create_mime_dir_config@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 124, column 14>": {
      "basic_info": {
        "function_id": 1425,
        "name": "create_mime_dir_config",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 124, column 14>",
        "is_definition": true,
        "start_line": 124,
        "end_line": 141,
        "return_type": "void *",
        "parameters": [
          {
            "name": "p",
            "type": "apr_pool_t *"
          },
          {
            "name": "dummy",
            "type": "char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {
          "CT_LAST_INIT": {
            "name": "CT_LAST_INIT",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:95:5) CT_LAST_INIT = 0",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 95, column 11>",
            "condition": ""
          },
          "ALL_LAST_INIT": {
            "name": "ALL_LAST_INIT",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:97:5) ALL_LAST_INIT = 0",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 97, column 11>",
            "condition": ""
          },
          "NOMIME_INIT": {
            "name": "NOMIME_INIT",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:99:5) NOMIME_INIT = 0",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 99, column 11>",
            "condition": ""
          }
        },
        "used_structs": {
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          },
          "mime_dir_config": {
            "name": "mime_dir_config",
            "definition": "struct {\n    apr_hash_t *extension_mappings;  /* Map from extension name to\n                                      * extension_info structure */\n\n    apr_array_header_t *remove_mappings; /* A simple list, walked once */\n\n    char *default_language;     /* Language if no AddLanguage ext found */\n\n    int multimatch;       /* Extensions to include in multiview matching\n                           * for filenames, e.g. Filters and Handlers\n                           */\n    int use_path_info;    /* If set to 0, only use filename.\n                           * If set to 1, append PATH_INFO to filename for\n                           *   lookups.\n                           * If set to 2, this value is unset and is\n                           *   effectively 0.\n                           */\n    /* Only use the final extension for Content-Type */\n    enum {CT_LAST_INIT, CT_LAST_ON, CT_LAST_OFF} ct_last_ext;\n    /* Only use the final extension for anything */\n    enum {ALL_LAST_INIT, ALL_LAST_ON, ALL_LAST_OFF} all_last_ext;\n    /* don't do any detection */\n    enum {NOMIME_INIT, NOMIME_ON, NOMIME_OFF} nomime;\n}",
            "typedef_name": null,
            "fields": {
              "extension_mappings": "apr_hash_t *",
              "remove_mappings": "apr_array_header_t *",
              "default_language": "char *",
              "multimatch": "int",
              "use_path_info": "int",
              "ct_last_ext": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:95:5)",
              "all_last_ext": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:97:5)",
              "nomime": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:99:5)"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static void *create_mime_dir_config(apr_pool_t *p, char *dummy)\n{\n    mime_dir_config *new = apr_palloc(p, sizeof(mime_dir_config));\n\n    new->extension_mappings = NULL;\n    new->remove_mappings = NULL;\n\n    new->default_language = NULL;\n\n    new->multimatch = MULTIMATCH_UNSET;\n\n    new->use_path_info = 2;\n    new->ct_last_ext = CT_LAST_INIT;\n    new->all_last_ext = ALL_LAST_INIT;\n    new->nomime = NOMIME_INIT;\n\n    return new;\n}"
    },
    "overlay_extension_mappings@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 145, column 14>": {
      "basic_info": {
        "function_id": 1426,
        "name": "overlay_extension_mappings",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 145, column 14>",
        "is_definition": true,
        "start_line": 145,
        "end_line": 179,
        "return_type": "void *",
        "parameters": [
          {
            "name": "p",
            "type": "apr_pool_t *"
          },
          {
            "name": "key",
            "type": "const void *"
          },
          {
            "name": "klen",
            "type": "apr_ssize_t"
          },
          {
            "name": "overlay_val",
            "type": "const void *"
          },
          {
            "name": "base_val",
            "type": "const void *"
          },
          {
            "name": "data",
            "type": "const void *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_pmemdup": {
            "declaration": "APR_DECLARE(void *) apr_pmemdup(apr_pool_t *p, const void *m, apr_size_t n)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          },
          "extension_info": {
            "name": "extension_info",
            "definition": "struct extension_info {\n    char *forced_type;                /* Additional AddTyped stuff */\n    char *encoding_type;              /* Added with AddEncoding... */\n    char *language_type;              /* Added with AddLanguage... */\n    char *handler;                    /* Added with AddHandler... */\n    char *charset_type;               /* Added with AddCharset... */\n    char *input_filters;              /* Added with AddInputFilter... */\n    char *output_filters;             /* Added with AddOutputFilter... */\n}",
            "typedef_name": null,
            "fields": {
              "forced_type": "char *",
              "encoding_type": "char *",
              "language_type": "char *",
              "handler": "char *",
              "charset_type": "char *",
              "input_filters": "char *",
              "output_filters": "char *"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "apr_ssize_t"
        ]
      },
      "source_code": "static void *overlay_extension_mappings(apr_pool_t *p,\n                                        const void *key,\n                                        apr_ssize_t klen,\n                                        const void *overlay_val,\n                                        const void *base_val,\n                                        const void *data)\n{\n    const extension_info *overlay_info = (const extension_info *)overlay_val;\n    const extension_info *base_info = (const extension_info *)base_val;\n    extension_info *new_info = apr_pmemdup(p, base_info, sizeof(extension_info));\n\n    if (overlay_info->forced_type) {\n        new_info->forced_type = overlay_info->forced_type;\n    }\n    if (overlay_info->encoding_type) {\n        new_info->encoding_type = overlay_info->encoding_type;\n    }\n    if (overlay_info->language_type) {\n        new_info->language_type = overlay_info->language_type;\n    }\n    if (overlay_info->handler) {\n        new_info->handler = overlay_info->handler;\n    }\n    if (overlay_info->charset_type) {\n        new_info->charset_type = overlay_info->charset_type;\n    }\n    if (overlay_info->input_filters) {\n        new_info->input_filters = overlay_info->input_filters;\n    }\n    if (overlay_info->output_filters) {\n        new_info->output_filters = overlay_info->output_filters;\n    }\n\n    return new_info;\n}"
    },
    "remove_items@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 183, column 13>": {
      "basic_info": {
        "function_id": 1427,
        "name": "remove_items",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 183, column 13>",
        "is_definition": true,
        "start_line": 183,
        "end_line": 201,
        "return_type": "void",
        "parameters": [
          {
            "name": "p",
            "type": "apr_pool_t *"
          },
          {
            "name": "remove",
            "type": "apr_array_header_t *"
          },
          {
            "name": "mappings",
            "type": "apr_hash_t *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_hash_get": {
            "declaration": "APR_DECLARE(void *) apr_hash_get(apr_hash_t *ht, const void *key,\n                                 apr_ssize_t klen)",
            "is_external": true,
            "definition": null
          },
          "apr_pmemdup": {
            "declaration": "APR_DECLARE(void *) apr_pmemdup(apr_pool_t *p, const void *m, apr_size_t n)",
            "is_external": true,
            "definition": null
          },
          "apr_hash_set": {
            "declaration": "APR_DECLARE(void) apr_hash_set(apr_hash_t *ht, const void *key,\n                               apr_ssize_t klen, const void *val)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "merge_mime_dir_configs@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 203, column 14>": {
            "source_code": "static void *merge_mime_dir_configs(apr_pool_t *p, void *basev, void *addv)\n{\n    mime_dir_config *base = (mime_dir_config *)basev;\n    mime_dir_config *add = (mime_dir_config *)addv;\n    mime_dir_config *new = apr_palloc(p, sizeof(mime_dir_config));\n\n    if (base->extension_mappings && add->extension_mappings) {\n        new->extension_mappings = apr_hash_merge(p, add->extension_mappings,\n                                                 base->extension_mappings,\n                                                 overlay_extension_mappings,\n                                                 NULL);\n    }\n    else {\n        if (base->extension_mappings == NULL) {\n            new->extension_mappings = add->extension_mappings;\n        }\n        else {\n            new->extension_mappings = base->extension_mappings;\n        }\n        /* We may not be merging the tables, but if we potentially will change\n         * an exinfo member, then we are about to trounce it anyways.\n         * We must have a copy for safety.\n         */\n        if (new->extension_mappings && add->remove_mappings) {\n            new->extension_mappings =\n                apr_hash_copy(p, new->extension_mappings);\n        }\n    }\n\n    if (new->extension_mappings) {\n        if (add->remove_mappings)\n            remove_items(p, add->remove_mappings, new->extension_mappings);\n    }\n    new->remove_mappings = NULL;\n\n    new->default_language = add->default_language ?\n        add->default_language : base->default_language;\n\n    new->multimatch = (add->multimatch != MULTIMATCH_UNSET) ?\n        add->multimatch : base->multimatch;\n\n    if ((add->use_path_info & 2) == 0) {\n        new->use_path_info = add->use_path_info;\n    }\n    else {\n        new->use_path_info = base->use_path_info;\n    }\n\n    new->ct_last_ext = (add->ct_last_ext != CT_LAST_INIT)\n                           ? add->ct_last_ext\n                           : base->ct_last_ext;\n    new->all_last_ext = (add->all_last_ext != ALL_LAST_INIT)\n                           ? add->all_last_ext\n                           : base->all_last_ext;\n    new->nomime = (add->nomime != NOMIME_INIT)\n                           ? add->nomime\n                           : base->nomime;\n\n\n    return new;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 203, column 14>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          },
          "apr_array_header_t": {
            "name": "apr_array_header_t",
            "definition": "struct apr_array_header_t {\n    /** The pool the array is allocated out of */\n    apr_pool_t *pool;\n    /** The amount of memory allocated for each element of the array */\n    int elt_size;\n    /** The number of active elements in the array */\n    int nelts;\n    /** The number of elements allocated in the array */\n    int nalloc;\n    /** The elements in the array */\n    char *elts;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "elt_size": "int",
              "nelts": "int",
              "nalloc": "int",
              "elts": "char *"
            },
            "condition": ""
          },
          "apr_hash_t": {
            "name": "apr_hash_t",
            "definition": "struct apr_hash_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          },
          "attrib_info": {
            "name": "attrib_info",
            "definition": "struct attrib_info {\n    char *name;\n    int   offset;\n}",
            "typedef_name": null,
            "fields": {
              "name": "char *",
              "offset": "int"
            },
            "condition": ""
          },
          "extension_info": {
            "name": "extension_info",
            "definition": "struct extension_info {\n    char *forced_type;                /* Additional AddTyped stuff */\n    char *encoding_type;              /* Added with AddEncoding... */\n    char *language_type;              /* Added with AddLanguage... */\n    char *handler;                    /* Added with AddHandler... */\n    char *charset_type;               /* Added with AddCharset... */\n    char *input_filters;              /* Added with AddInputFilter... */\n    char *output_filters;             /* Added with AddOutputFilter... */\n}",
            "typedef_name": null,
            "fields": {
              "forced_type": "char *",
              "encoding_type": "char *",
              "language_type": "char *",
              "handler": "char *",
              "charset_type": "char *",
              "input_filters": "char *",
              "output_filters": "char *"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static void remove_items(apr_pool_t *p, apr_array_header_t *remove,\n                         apr_hash_t *mappings)\n{\n    attrib_info *suffix = (attrib_info *) remove->elts;\n    int i;\n    for (i = 0; i < remove->nelts; i++) {\n        extension_info *exinfo = apr_hash_get(mappings,\n                                              suffix[i].name,\n                                              APR_HASH_KEY_STRING);\n        if (exinfo && *(const char**)((char *)exinfo + suffix[i].offset)) {\n            extension_info *copyinfo = exinfo;\n            exinfo = apr_pmemdup(p, copyinfo, sizeof(*exinfo));\n            apr_hash_set(mappings, suffix[i].name,\n                         APR_HASH_KEY_STRING, exinfo);\n\n            *(const char**)((char *)exinfo + suffix[i].offset) = NULL;\n        }\n    }\n}"
    },
    "merge_mime_dir_configs@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 203, column 14>": {
      "basic_info": {
        "function_id": 1428,
        "name": "merge_mime_dir_configs",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 203, column 14>",
        "is_definition": true,
        "start_line": 203,
        "end_line": 263,
        "return_type": "void *",
        "parameters": [
          {
            "name": "p",
            "type": "apr_pool_t *"
          },
          {
            "name": "basev",
            "type": "void *"
          },
          {
            "name": "addv",
            "type": "void *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "apr_hash_merge": {
            "declaration": "APR_DECLARE(apr_hash_t *) apr_hash_merge(apr_pool_t *p,\n                                         const apr_hash_t *h1,\n                                         const apr_hash_t *h2,\n                                         void * (*merger)(apr_pool_t *p,\n                                                     const void *key,\n                                                     apr_ssize_t klen,\n                                                     const void *h1_val,\n                                                     const void *h2_val,\n                                                     const void *data),\n                                         const void *data)",
            "is_external": true,
            "definition": null
          },
          "apr_hash_copy": {
            "declaration": "APR_DECLARE(apr_hash_t *) apr_hash_copy(apr_pool_t *pool,\n                                        const apr_hash_t *h)",
            "is_external": true,
            "definition": null
          },
          "remove_items": {
            "declaration": "static void remove_items(apr_pool_t *p, apr_array_header_t *remove,\n                         apr_hash_t *mappings)\n{\n    attrib_info *suffix = (attrib_info *) remove->elts;\n    int i;\n    for (i = 0; i < remove->nelts; i++) {\n        extension_info *exinfo = apr_hash_get(mappings,\n                                              suffix[i].name,\n                                              APR_HASH_KEY_STRING);\n        if (exinfo && *(const char**)((char *)exinfo + suffix[i].offset)) {\n            extension_info *copyinfo = exinfo;\n            exinfo = apr_pmemdup(p, copyinfo, sizeof(*exinfo));\n            apr_hash_set(mappings, suffix[i].name,\n                         APR_HASH_KEY_STRING, exinfo);\n\n            *(const char**)((char *)exinfo + suffix[i].offset) = NULL;\n        }\n    }\n}",
            "is_external": false,
            "definition": "static void remove_items(apr_pool_t *p, apr_array_header_t *remove,\n                         apr_hash_t *mappings)\n{\n    attrib_info *suffix = (attrib_info *) remove->elts;\n    int i;\n    for (i = 0; i < remove->nelts; i++) {\n        extension_info *exinfo = apr_hash_get(mappings,\n                                              suffix[i].name,\n                                              APR_HASH_KEY_STRING);\n        if (exinfo && *(const char**)((char *)exinfo + suffix[i].offset)) {\n            extension_info *copyinfo = exinfo;\n            exinfo = apr_pmemdup(p, copyinfo, sizeof(*exinfo));\n            apr_hash_set(mappings, suffix[i].name,\n                         APR_HASH_KEY_STRING, exinfo);\n\n            *(const char**)((char *)exinfo + suffix[i].offset) = NULL;\n        }\n    }\n}"
          }
        },
        "callers": {},
        "used_macros": {
          "CT_LAST_INIT": {
            "name": "CT_LAST_INIT",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:95:5) CT_LAST_INIT = 0",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 95, column 11>",
            "condition": ""
          },
          "ALL_LAST_INIT": {
            "name": "ALL_LAST_INIT",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:97:5) ALL_LAST_INIT = 0",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 97, column 11>",
            "condition": ""
          },
          "NOMIME_INIT": {
            "name": "NOMIME_INIT",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:99:5) NOMIME_INIT = 0",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 99, column 11>",
            "condition": ""
          }
        },
        "used_structs": {
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          },
          "mime_dir_config": {
            "name": "mime_dir_config",
            "definition": "struct {\n    apr_hash_t *extension_mappings;  /* Map from extension name to\n                                      * extension_info structure */\n\n    apr_array_header_t *remove_mappings; /* A simple list, walked once */\n\n    char *default_language;     /* Language if no AddLanguage ext found */\n\n    int multimatch;       /* Extensions to include in multiview matching\n                           * for filenames, e.g. Filters and Handlers\n                           */\n    int use_path_info;    /* If set to 0, only use filename.\n                           * If set to 1, append PATH_INFO to filename for\n                           *   lookups.\n                           * If set to 2, this value is unset and is\n                           *   effectively 0.\n                           */\n    /* Only use the final extension for Content-Type */\n    enum {CT_LAST_INIT, CT_LAST_ON, CT_LAST_OFF} ct_last_ext;\n    /* Only use the final extension for anything */\n    enum {ALL_LAST_INIT, ALL_LAST_ON, ALL_LAST_OFF} all_last_ext;\n    /* don't do any detection */\n    enum {NOMIME_INIT, NOMIME_ON, NOMIME_OFF} nomime;\n}",
            "typedef_name": null,
            "fields": {
              "extension_mappings": "apr_hash_t *",
              "remove_mappings": "apr_array_header_t *",
              "default_language": "char *",
              "multimatch": "int",
              "use_path_info": "int",
              "ct_last_ext": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:95:5)",
              "all_last_ext": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:97:5)",
              "nomime": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:99:5)"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static void *merge_mime_dir_configs(apr_pool_t *p, void *basev, void *addv)\n{\n    mime_dir_config *base = (mime_dir_config *)basev;\n    mime_dir_config *add = (mime_dir_config *)addv;\n    mime_dir_config *new = apr_palloc(p, sizeof(mime_dir_config));\n\n    if (base->extension_mappings && add->extension_mappings) {\n        new->extension_mappings = apr_hash_merge(p, add->extension_mappings,\n                                                 base->extension_mappings,\n                                                 overlay_extension_mappings,\n                                                 NULL);\n    }\n    else {\n        if (base->extension_mappings == NULL) {\n            new->extension_mappings = add->extension_mappings;\n        }\n        else {\n            new->extension_mappings = base->extension_mappings;\n        }\n        /* We may not be merging the tables, but if we potentially will change\n         * an exinfo member, then we are about to trounce it anyways.\n         * We must have a copy for safety.\n         */\n        if (new->extension_mappings && add->remove_mappings) {\n            new->extension_mappings =\n                apr_hash_copy(p, new->extension_mappings);\n        }\n    }\n\n    if (new->extension_mappings) {\n        if (add->remove_mappings)\n            remove_items(p, add->remove_mappings, new->extension_mappings);\n    }\n    new->remove_mappings = NULL;\n\n    new->default_language = add->default_language ?\n        add->default_language : base->default_language;\n\n    new->multimatch = (add->multimatch != MULTIMATCH_UNSET) ?\n        add->multimatch : base->multimatch;\n\n    if ((add->use_path_info & 2) == 0) {\n        new->use_path_info = add->use_path_info;\n    }\n    else {\n        new->use_path_info = base->use_path_info;\n    }\n\n    new->ct_last_ext = (add->ct_last_ext != CT_LAST_INIT)\n                           ? add->ct_last_ext\n                           : base->ct_last_ext;\n    new->all_last_ext = (add->all_last_ext != ALL_LAST_INIT)\n                           ? add->all_last_ext\n                           : base->all_last_ext;\n    new->nomime = (add->nomime != NOMIME_INIT)\n                           ? add->nomime\n                           : base->nomime;\n\n\n    return new;\n}"
    },
    "add_extension_info@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 265, column 20>": {
      "basic_info": {
        "function_id": 1429,
        "name": "add_extension_info",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 265, column 20>",
        "is_definition": true,
        "start_line": 265,
        "end_line": 294,
        "return_type": "const char *",
        "parameters": [
          {
            "name": "cmd",
            "type": "cmd_parms *"
          },
          {
            "name": "m_",
            "type": "void *"
          },
          {
            "name": "value_",
            "type": "const char *"
          },
          {
            "name": "ext",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_pstrdup": {
            "declaration": "APR_DECLARE(char *) apr_pstrdup(apr_pool_t *p, const char *s)",
            "is_external": true,
            "definition": null
          },
          "ap_str_tolower": {
            "declaration": "AP_DECLARE(void) ap_str_tolower(char *s)",
            "is_external": true,
            "definition": null
          },
          "apr_hash_make": {
            "declaration": "APR_DECLARE(apr_hash_t *) apr_hash_make(apr_pool_t *pool)",
            "is_external": true,
            "definition": null
          },
          "apr_hash_get": {
            "declaration": "APR_DECLARE(void *) apr_hash_get(apr_hash_t *ht, const void *key,\n                                 apr_ssize_t klen)",
            "is_external": true,
            "definition": null
          },
          "memset": {
            "declaration": "extern void *memset (void *__s, int __c, size_t __n) __THROW __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "apr_hash_set": {
            "declaration": "APR_DECLARE(void) apr_hash_set(apr_hash_t *ht, const void *key,\n                               apr_ssize_t klen, const void *val)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "remove_extension_type@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 300, column 20>": {
            "source_code": "static const char *remove_extension_type(cmd_parms *cmd, void *m_,\n                                         const char *ext)\n{\n    return add_extension_info(cmd, m_, \"\", ext);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 300, column 20>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "mime_dir_config": {
            "name": "mime_dir_config",
            "definition": "struct {\n    apr_hash_t *extension_mappings;  /* Map from extension name to\n                                      * extension_info structure */\n\n    apr_array_header_t *remove_mappings; /* A simple list, walked once */\n\n    char *default_language;     /* Language if no AddLanguage ext found */\n\n    int multimatch;       /* Extensions to include in multiview matching\n                           * for filenames, e.g. Filters and Handlers\n                           */\n    int use_path_info;    /* If set to 0, only use filename.\n                           * If set to 1, append PATH_INFO to filename for\n                           *   lookups.\n                           * If set to 2, this value is unset and is\n                           *   effectively 0.\n                           */\n    /* Only use the final extension for Content-Type */\n    enum {CT_LAST_INIT, CT_LAST_ON, CT_LAST_OFF} ct_last_ext;\n    /* Only use the final extension for anything */\n    enum {ALL_LAST_INIT, ALL_LAST_ON, ALL_LAST_OFF} all_last_ext;\n    /* don't do any detection */\n    enum {NOMIME_INIT, NOMIME_ON, NOMIME_OFF} nomime;\n}",
            "typedef_name": null,
            "fields": {
              "extension_mappings": "apr_hash_t *",
              "remove_mappings": "apr_array_header_t *",
              "default_language": "char *",
              "multimatch": "int",
              "use_path_info": "int",
              "ct_last_ext": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:95:5)",
              "all_last_ext": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:97:5)",
              "nomime": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:99:5)"
            },
            "condition": ""
          },
          "extension_info": {
            "name": "extension_info",
            "definition": "struct extension_info {\n    char *forced_type;                /* Additional AddTyped stuff */\n    char *encoding_type;              /* Added with AddEncoding... */\n    char *language_type;              /* Added with AddLanguage... */\n    char *handler;                    /* Added with AddHandler... */\n    char *charset_type;               /* Added with AddCharset... */\n    char *input_filters;              /* Added with AddInputFilter... */\n    char *output_filters;             /* Added with AddOutputFilter... */\n}",
            "typedef_name": null,
            "fields": {
              "forced_type": "char *",
              "encoding_type": "char *",
              "language_type": "char *",
              "handler": "char *",
              "charset_type": "char *",
              "input_filters": "char *",
              "output_filters": "char *"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "cmd_parms"
        ]
      },
      "source_code": "static const char *add_extension_info(cmd_parms *cmd, void *m_,\n                                      const char *value_, const char* ext)\n{\n    mime_dir_config *m=m_;\n    extension_info *exinfo;\n    int offset = (int) (long) cmd->info;\n    char *key = apr_pstrdup(cmd->temp_pool, ext);\n    char *value = apr_pstrdup(cmd->pool, value_);\n    ap_str_tolower(value);\n    ap_str_tolower(key);\n\n    if (*key == '.') {\n        ++key;\n    }\n    if (!m->extension_mappings) {\n        m->extension_mappings = apr_hash_make(cmd->pool);\n        exinfo = NULL;\n    }\n    else {\n        exinfo = (extension_info*)apr_hash_get(m->extension_mappings, key,\n                                               APR_HASH_KEY_STRING);\n    }\n    if (!exinfo) {\n        exinfo = apr_pcalloc(cmd->pool, sizeof(extension_info));\n        key = apr_pstrdup(cmd->pool, key);\n        apr_hash_set(m->extension_mappings, key, APR_HASH_KEY_STRING, exinfo);\n    }\n    *(const char**)((char *)exinfo + offset) = value;\n    return NULL;\n}"
    },
    "remove_extension_type@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 300, column 20>": {
      "basic_info": {
        "function_id": 1430,
        "name": "remove_extension_type",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 300, column 20>",
        "is_definition": true,
        "start_line": 300,
        "end_line": 304,
        "return_type": "const char *",
        "parameters": [
          {
            "name": "cmd",
            "type": "cmd_parms *"
          },
          {
            "name": "m_",
            "type": "void *"
          },
          {
            "name": "ext",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "add_extension_info": {
            "declaration": "static const char *add_extension_info(cmd_parms *cmd, void *m_,\n                                      const char *value_, const char* ext)\n{\n    mime_dir_config *m=m_;\n    extension_info *exinfo;\n    int offset = (int) (long) cmd->info;\n    char *key = apr_pstrdup(cmd->temp_pool, ext);\n    char *value = apr_pstrdup(cmd->pool, value_);\n    ap_str_tolower(value);\n    ap_str_tolower(key);\n\n    if (*key == '.') {\n        ++key;\n    }\n    if (!m->extension_mappings) {\n        m->extension_mappings = apr_hash_make(cmd->pool);\n        exinfo = NULL;\n    }\n    else {\n        exinfo = (extension_info*)apr_hash_get(m->extension_mappings, key,\n                                               APR_HASH_KEY_STRING);\n    }\n    if (!exinfo) {\n        exinfo = apr_pcalloc(cmd->pool, sizeof(extension_info));\n        key = apr_pstrdup(cmd->pool, key);\n        apr_hash_set(m->extension_mappings, key, APR_HASH_KEY_STRING, exinfo);\n    }\n    *(const char**)((char *)exinfo + offset) = value;\n    return NULL;\n}",
            "is_external": false,
            "definition": "static const char *add_extension_info(cmd_parms *cmd, void *m_,\n                                      const char *value_, const char* ext)\n{\n    mime_dir_config *m=m_;\n    extension_info *exinfo;\n    int offset = (int) (long) cmd->info;\n    char *key = apr_pstrdup(cmd->temp_pool, ext);\n    char *value = apr_pstrdup(cmd->pool, value_);\n    ap_str_tolower(value);\n    ap_str_tolower(key);\n\n    if (*key == '.') {\n        ++key;\n    }\n    if (!m->extension_mappings) {\n        m->extension_mappings = apr_hash_make(cmd->pool);\n        exinfo = NULL;\n    }\n    else {\n        exinfo = (extension_info*)apr_hash_get(m->extension_mappings, key,\n                                               APR_HASH_KEY_STRING);\n    }\n    if (!exinfo) {\n        exinfo = apr_pcalloc(cmd->pool, sizeof(extension_info));\n        key = apr_pstrdup(cmd->pool, key);\n        apr_hash_set(m->extension_mappings, key, APR_HASH_KEY_STRING, exinfo);\n    }\n    *(const char**)((char *)exinfo + offset) = value;\n    return NULL;\n}"
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {},
        "used_globals": {},
        "used_typedefs": [
          "cmd_parms"
        ]
      },
      "source_code": "static const char *remove_extension_type(cmd_parms *cmd, void *m_,\n                                         const char *ext)\n{\n    return add_extension_info(cmd, m_, \"\", ext);\n}"
    },
    "remove_extension_info@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 311, column 20>": {
      "basic_info": {
        "function_id": 1431,
        "name": "remove_extension_info",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 311, column 20>",
        "is_definition": true,
        "start_line": 311,
        "end_line": 327,
        "return_type": "const char *",
        "parameters": [
          {
            "name": "cmd",
            "type": "cmd_parms *"
          },
          {
            "name": "m_",
            "type": "void *"
          },
          {
            "name": "ext",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_array_make": {
            "declaration": "APR_DECLARE(apr_array_header_t *) apr_array_make(apr_pool_t *p,\n                                                 int nelts, int elt_size)",
            "is_external": true,
            "definition": null
          },
          "apr_array_push": {
            "declaration": "APR_DECLARE(void *) apr_array_push(apr_array_header_t *arr)",
            "is_external": true,
            "definition": null
          },
          "apr_pstrdup": {
            "declaration": "APR_DECLARE(char *) apr_pstrdup(apr_pool_t *p, const char *s)",
            "is_external": true,
            "definition": null
          },
          "ap_str_tolower": {
            "declaration": "AP_DECLARE(void) ap_str_tolower(char *s)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "mime_dir_config": {
            "name": "mime_dir_config",
            "definition": "struct {\n    apr_hash_t *extension_mappings;  /* Map from extension name to\n                                      * extension_info structure */\n\n    apr_array_header_t *remove_mappings; /* A simple list, walked once */\n\n    char *default_language;     /* Language if no AddLanguage ext found */\n\n    int multimatch;       /* Extensions to include in multiview matching\n                           * for filenames, e.g. Filters and Handlers\n                           */\n    int use_path_info;    /* If set to 0, only use filename.\n                           * If set to 1, append PATH_INFO to filename for\n                           *   lookups.\n                           * If set to 2, this value is unset and is\n                           *   effectively 0.\n                           */\n    /* Only use the final extension for Content-Type */\n    enum {CT_LAST_INIT, CT_LAST_ON, CT_LAST_OFF} ct_last_ext;\n    /* Only use the final extension for anything */\n    enum {ALL_LAST_INIT, ALL_LAST_ON, ALL_LAST_OFF} all_last_ext;\n    /* don't do any detection */\n    enum {NOMIME_INIT, NOMIME_ON, NOMIME_OFF} nomime;\n}",
            "typedef_name": null,
            "fields": {
              "extension_mappings": "apr_hash_t *",
              "remove_mappings": "apr_array_header_t *",
              "default_language": "char *",
              "multimatch": "int",
              "use_path_info": "int",
              "ct_last_ext": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:95:5)",
              "all_last_ext": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:97:5)",
              "nomime": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:99:5)"
            },
            "condition": ""
          },
          "attrib_info": {
            "name": "attrib_info",
            "definition": "struct attrib_info {\n    char *name;\n    int   offset;\n}",
            "typedef_name": null,
            "fields": {
              "name": "char *",
              "offset": "int"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "cmd_parms"
        ]
      },
      "source_code": "static const char *remove_extension_info(cmd_parms *cmd, void *m_,\n                                         const char *ext)\n{\n    mime_dir_config *m = (mime_dir_config *) m_;\n    attrib_info *suffix;\n    if (*ext == '.') {\n        ++ext;\n    }\n    if (!m->remove_mappings) {\n        m->remove_mappings = apr_array_make(cmd->pool, 4, sizeof(*suffix));\n    }\n    suffix = (attrib_info *)apr_array_push(m->remove_mappings);\n    suffix->name = apr_pstrdup(cmd->pool, ext);\n    ap_str_tolower(suffix->name);\n    suffix->offset = (int) (long) cmd->info;\n    return NULL;\n}"
    },
    "set_types_config@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 333, column 20>": {
      "basic_info": {
        "function_id": 1432,
        "name": "set_types_config",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 333, column 20>",
        "is_definition": true,
        "start_line": 333,
        "end_line": 339,
        "return_type": "const char *",
        "parameters": [
          {
            "name": "cmd",
            "type": "cmd_parms *"
          },
          {
            "name": "dummy",
            "type": "void *"
          },
          {
            "name": "arg",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {},
        "callers": {},
        "used_macros": {},
        "used_structs": {},
        "used_globals": {
          "mime_module": {
            "name": "mime_module",
            "type": "module",
            "is_extern": false,
            "is_static": false,
            "definition": "AP_DECLARE_MODULE(mime) = {\n    STANDARD20_MODULE_STUFF,\n    create_mime_dir_config,     /* create per-directory config structure */\n    merge_mime_dir_configs,     /* merge per-directory config structures */\n    NULL,                       /* create per-server config structure */\n    NULL,                       /* merge per-server config structures */\n    mime_cmds,                  /* command apr_table_t */\n    register_hooks              /* register hooks */\n}",
            "initializer": "{\n    STANDARD20_MODULE_STUFF,\n    create_mime_dir_config,     /* create per-directory config structure */\n    merge_mime_dir_configs,     /* merge per-directory config structures */\n    NULL,                       /* create per-server config structure */\n    NULL,                       /* merge per-server config structures */\n    mime_cmds,                  /* command apr_table_t */\n    register_hooks              /* register hooks */\n}",
            "full_definition": "AP_DECLARE_MODULE(mime) = {\n    STANDARD20_MODULE_STUFF,\n    create_mime_dir_config,     /* create per-directory config structure */\n    merge_mime_dir_configs,     /* merge per-directory config structures */\n    NULL,                       /* create per-server config structure */\n    NULL,                       /* merge per-server config structures */\n    mime_cmds,                  /* command apr_table_t */\n    register_hooks              /* register hooks */\n}",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "cmd_parms"
        ]
      },
      "source_code": "static const char *set_types_config(cmd_parms *cmd, void *dummy,\n                                    const char *arg)\n{\n    ap_set_module_config(cmd->server->module_config, &mime_module,\n                         (void *)arg);\n    return NULL;\n}"
    },
    "multiviews_match@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 341, column 20>": {
      "basic_info": {
        "function_id": 1433,
        "name": "multiviews_match",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 341, column 20>",
        "is_definition": true,
        "start_line": 341,
        "end_line": 385,
        "return_type": "const char *",
        "parameters": [
          {
            "name": "cmd",
            "type": "cmd_parms *"
          },
          {
            "name": "m_",
            "type": "void *"
          },
          {
            "name": "include",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_check_cmd_context": {
            "declaration": "AP_DECLARE(const char *) ap_check_cmd_context(cmd_parms *cmd,\n                                              unsigned forbidden)",
            "is_external": true,
            "definition": null
          },
          "strcasecmp": {
            "declaration": "extern int strcasecmp (const char *__s1, const char *__s2)\n     __THROW __attribute_pure__ __nonnull ((1, 2))",
            "is_external": true,
            "definition": null
          },
          "apr_psprintf": {
            "declaration": "APR_DECLARE_NONSTD(char *) apr_psprintf(apr_pool_t *p, const char *fmt, ...)\n        __attribute__((format(printf,2,3)))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "mime_dir_config": {
            "name": "mime_dir_config",
            "definition": "struct {\n    apr_hash_t *extension_mappings;  /* Map from extension name to\n                                      * extension_info structure */\n\n    apr_array_header_t *remove_mappings; /* A simple list, walked once */\n\n    char *default_language;     /* Language if no AddLanguage ext found */\n\n    int multimatch;       /* Extensions to include in multiview matching\n                           * for filenames, e.g. Filters and Handlers\n                           */\n    int use_path_info;    /* If set to 0, only use filename.\n                           * If set to 1, append PATH_INFO to filename for\n                           *   lookups.\n                           * If set to 2, this value is unset and is\n                           *   effectively 0.\n                           */\n    /* Only use the final extension for Content-Type */\n    enum {CT_LAST_INIT, CT_LAST_ON, CT_LAST_OFF} ct_last_ext;\n    /* Only use the final extension for anything */\n    enum {ALL_LAST_INIT, ALL_LAST_ON, ALL_LAST_OFF} all_last_ext;\n    /* don't do any detection */\n    enum {NOMIME_INIT, NOMIME_ON, NOMIME_OFF} nomime;\n}",
            "typedef_name": null,
            "fields": {
              "extension_mappings": "apr_hash_t *",
              "remove_mappings": "apr_array_header_t *",
              "default_language": "char *",
              "multimatch": "int",
              "use_path_info": "int",
              "ct_last_ext": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:95:5)",
              "all_last_ext": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:97:5)",
              "nomime": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:99:5)"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "cmd_parms"
        ]
      },
      "source_code": "static const char *multiviews_match(cmd_parms *cmd, void *m_,\n                                    const char *include)\n{\n    mime_dir_config *m = (mime_dir_config *) m_;\n    const char *errmsg;\n\n    errmsg = ap_check_cmd_context(cmd, NOT_IN_LOCATION);\n    if (errmsg != NULL) {\n        return errmsg;\n    }\n\n    if (strcasecmp(include, \"Any\") == 0) {\n        if (m->multimatch && (m->multimatch & ~MULTIMATCH_ANY)) {\n            return \"Any is incompatible with NegotiatedOnly, \"\n                   \"Filters and Handlers\";\n        }\n        m->multimatch |= MULTIMATCH_ANY;\n    }\n    else if (strcasecmp(include, \"NegotiatedOnly\") == 0) {\n        if (m->multimatch && (m->multimatch & ~MULTIMATCH_NEGOTIATED)) {\n            return \"NegotiatedOnly is incompatible with Any, \"\n                   \"Filters and Handlers\";\n        }\n        m->multimatch |= MULTIMATCH_NEGOTIATED;\n    }\n    else if (strcasecmp(include, \"Filters\") == 0) {\n        if (m->multimatch && (m->multimatch & (MULTIMATCH_NEGOTIATED\n                                             | MULTIMATCH_ANY))) {\n            return \"Filters is incompatible with Any and NegotiatedOnly\";\n        }\n        m->multimatch |= MULTIMATCH_FILTERS;\n    }\n    else if (strcasecmp(include, \"Handlers\") == 0) {\n        if (m->multimatch && (m->multimatch & (MULTIMATCH_NEGOTIATED\n                                             | MULTIMATCH_ANY))) {\n            return \"Handlers is incompatible with Any and NegotiatedOnly\";\n        }\n        m->multimatch |= MULTIMATCH_HANDLERS;\n    }\n    else {\n        return apr_psprintf(cmd->pool, \"Unrecognized option '%s'\", include);\n    }\n\n    return NULL;\n}"
    },
    "add_mime_options@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 387, column 20>": {
      "basic_info": {
        "function_id": 1434,
        "name": "add_mime_options",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 387, column 20>",
        "is_definition": true,
        "start_line": 387,
        "end_line": 418,
        "return_type": "const char *",
        "parameters": [
          {
            "name": "cmd",
            "type": "cmd_parms *"
          },
          {
            "name": "in_dc",
            "type": "void *"
          },
          {
            "name": "flag",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "strcasecmp": {
            "declaration": "extern int strcasecmp (const char *__s1, const char *__s2)\n     __THROW __attribute_pure__ __nonnull ((1, 2))",
            "is_external": true,
            "definition": null
          },
          "apr_pstrcat": {
            "declaration": "APR_DECLARE_NONSTD(char *) apr_pstrcat(apr_pool_t *p, ...)\n#if defined(__GNUC__) && __GNUC__ >= 4\n    __attribute__((sentinel))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {
          "CT_LAST_ON": {
            "name": "CT_LAST_ON",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:95:5) CT_LAST_ON = 1",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 95, column 25>",
            "condition": ""
          },
          "CT_LAST_OFF": {
            "name": "CT_LAST_OFF",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:95:5) CT_LAST_OFF = 2",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 95, column 37>",
            "condition": ""
          },
          "ALL_LAST_ON": {
            "name": "ALL_LAST_ON",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:97:5) ALL_LAST_ON = 1",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 97, column 26>",
            "condition": ""
          },
          "ALL_LAST_OFF": {
            "name": "ALL_LAST_OFF",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:97:5) ALL_LAST_OFF = 2",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 97, column 39>",
            "condition": ""
          },
          "NOMIME_ON": {
            "name": "NOMIME_ON",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:99:5) NOMIME_ON = 1",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 99, column 24>",
            "condition": ""
          },
          "NOMIME_OFF": {
            "name": "NOMIME_OFF",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:99:5) NOMIME_OFF = 2",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 99, column 35>",
            "condition": ""
          }
        },
        "used_structs": {
          "mime_dir_config": {
            "name": "mime_dir_config",
            "definition": "struct {\n    apr_hash_t *extension_mappings;  /* Map from extension name to\n                                      * extension_info structure */\n\n    apr_array_header_t *remove_mappings; /* A simple list, walked once */\n\n    char *default_language;     /* Language if no AddLanguage ext found */\n\n    int multimatch;       /* Extensions to include in multiview matching\n                           * for filenames, e.g. Filters and Handlers\n                           */\n    int use_path_info;    /* If set to 0, only use filename.\n                           * If set to 1, append PATH_INFO to filename for\n                           *   lookups.\n                           * If set to 2, this value is unset and is\n                           *   effectively 0.\n                           */\n    /* Only use the final extension for Content-Type */\n    enum {CT_LAST_INIT, CT_LAST_ON, CT_LAST_OFF} ct_last_ext;\n    /* Only use the final extension for anything */\n    enum {ALL_LAST_INIT, ALL_LAST_ON, ALL_LAST_OFF} all_last_ext;\n    /* don't do any detection */\n    enum {NOMIME_INIT, NOMIME_ON, NOMIME_OFF} nomime;\n}",
            "typedef_name": null,
            "fields": {
              "extension_mappings": "apr_hash_t *",
              "remove_mappings": "apr_array_header_t *",
              "default_language": "char *",
              "multimatch": "int",
              "use_path_info": "int",
              "ct_last_ext": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:95:5)",
              "all_last_ext": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:97:5)",
              "nomime": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:99:5)"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "cmd_parms"
        ]
      },
      "source_code": "static const char *add_mime_options(cmd_parms *cmd, void *in_dc,\n                                    const char *flag)\n{\n    mime_dir_config *dc = in_dc;\n\n    if (!strcasecmp(flag, \"TypesLastExtension\")) {\n        dc->ct_last_ext = CT_LAST_ON;\n    }\n    else if (!strcasecmp(flag, \"NoTypesLastExtension\")) {\n        dc->ct_last_ext = CT_LAST_OFF;\n    }\n    else if (!strcasecmp(flag, \"AllLastExtension\")) {\n        dc->all_last_ext = ALL_LAST_ON;\n    }\n    else if (!strcasecmp(flag, \"NoAllLastExtension\")) {\n        dc->all_last_ext = ALL_LAST_OFF;\n    }\n    else if (!strcasecmp(flag, \"Disable\")) {\n        dc->nomime = NOMIME_ON;\n    }\n    else if (!strcasecmp(flag, \"Enable\")) {\n        dc->nomime = NOMIME_OFF;\n    }\n    else {\n        return apr_pstrcat(cmd->temp_pool,\n                           \"Invalid MimeOptions option: \",\n                           flag,\n                           NULL);\n    }\n\n    return NULL;\n}"
    },
    "mime_post_config@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 487, column 12>": {
      "basic_info": {
        "function_id": 1435,
        "name": "mime_post_config",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 487, column 12>",
        "is_definition": true,
        "start_line": 487,
        "end_line": 533,
        "return_type": "int",
        "parameters": [
          {
            "name": "p",
            "type": "apr_pool_t *"
          },
          {
            "name": "plog",
            "type": "apr_pool_t *"
          },
          {
            "name": "ptemp",
            "type": "apr_pool_t *"
          },
          {
            "name": "s",
            "type": "server_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_server_root_relative": {
            "declaration": "AP_DECLARE(char *) ap_server_root_relative(apr_pool_t *p, const char *fname)",
            "is_external": true,
            "definition": null
          },
          "ap_log_error_": {
            "declaration": "AP_DECLARE(void) ap_log_error_(const char *file, int line, int module_index,\n                               int level, apr_status_t status,\n                               const server_rec *s, const char *fmt, ...)\n                              __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "ap_pcfg_openfile": {
            "declaration": "AP_DECLARE(apr_status_t) ap_pcfg_openfile(ap_configfile_t **ret_cfg,\n                                          apr_pool_t *p, const char *name)",
            "is_external": true,
            "definition": null
          },
          "apr_hash_make": {
            "declaration": "APR_DECLARE(apr_hash_t *) apr_hash_make(apr_pool_t *pool)",
            "is_external": true,
            "definition": null
          },
          "ap_cfg_getline": {
            "declaration": "AP_DECLARE(apr_status_t) ap_cfg_getline(char *buf, apr_size_t bufsize, ap_configfile_t *cfp)",
            "is_external": true,
            "definition": null
          },
          "ap_getword_conf": {
            "declaration": "AP_DECLARE(char *) ap_getword_conf(apr_pool_t *p, const char **line)",
            "is_external": true,
            "definition": null
          },
          "ap_str_tolower": {
            "declaration": "AP_DECLARE(void) ap_str_tolower(char *s)",
            "is_external": true,
            "definition": null
          },
          "apr_hash_set": {
            "declaration": "APR_DECLARE(void) apr_hash_set(apr_hash_t *ht, const void *key,\n                               apr_ssize_t klen, const void *val)",
            "is_external": true,
            "definition": null
          },
          "ap_cfg_closefile": {
            "declaration": "AP_DECLARE(int) ap_cfg_closefile(ap_configfile_t *cfp)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          },
          "server_rec": {
            "name": "server_rec",
            "definition": "struct server_rec {\n    /** The process this server is running in */\n    process_rec *process;\n    /** The next server in the list */\n    server_rec *next;\n\n    /* Log files --- note that transfer log is now in the modules... */\n\n    /** The name of the error log */\n    char *error_fname;\n    /** A file descriptor that references the error log */\n    apr_file_t *error_log;\n    /** The log level configuration */\n    struct ap_logconf log;\n\n    /* Module-specific configuration for server, and defaults... */\n\n    /** Config vector containing pointers to modules' per-server config\n     *  structures. */\n    struct ap_conf_vector_t *module_config;\n    /** MIME type info, etc., before we start checking per-directory info */\n    struct ap_conf_vector_t *lookup_defaults;\n\n    /** The path to the config file that the server was defined in */\n    const char *defn_name;\n    /** The line of the config file that the server was defined on */\n    unsigned defn_line_number;\n    /** true if this is the virtual server */\n    char is_virtual;\n\n\n    /* Information for redirects */\n\n    /** for redirects, etc. */\n    apr_port_t port;\n    /** The server request scheme for redirect responses */\n    const char *server_scheme;\n\n    /* Contact information */\n\n    /** The admin's contact information */\n    char *server_admin;\n    /** The server hostname */\n    char *server_hostname;\n\n    /* Transaction handling */\n\n    /** I haven't got a clue */\n    server_addr_rec *addrs;\n    /** Timeout, as an apr interval, before we give up */\n    apr_interval_time_t timeout;\n    /** The apr interval we will wait for another request */\n    apr_interval_time_t keep_alive_timeout;\n    /** Maximum requests per connection */\n    int keep_alive_max;\n    /** Use persistent connections? */\n    int keep_alive;\n\n    /** Normal names for ServerAlias servers */\n    apr_array_header_t *names;\n    /** Wildcarded names for ServerAlias servers */\n    apr_array_header_t *wild_names;\n\n    /** Pathname for ServerPath */\n    const char *path;\n    /** Length of path */\n    int pathlen;\n\n    /** limit on size of the HTTP request line    */\n    int limit_req_line;\n    /** limit on size of any request header field */\n    int limit_req_fieldsize;\n    /** limit on number of request header fields  */\n    int limit_req_fields;\n\n    /** Opaque storage location */\n    void *context;\n\n    /** Whether the keepalive timeout is explicit (1) or\n     *  inherited (0) from the base server (either first\n     *  server on the same IP:port or main server) */\n    unsigned int keep_alive_timeout_set:1;\n}",
            "typedef_name": null,
            "fields": {
              "process": "process_rec *",
              "next": "server_rec *",
              "error_fname": "char *",
              "error_log": "apr_file_t *",
              "log": "struct ap_logconf",
              "module_config": "struct ap_conf_vector_t *",
              "lookup_defaults": "struct ap_conf_vector_t *",
              "defn_name": "const char *",
              "defn_line_number": "unsigned int",
              "is_virtual": "char",
              "port": "apr_port_t",
              "server_scheme": "const char *",
              "server_admin": "char *",
              "server_hostname": "char *",
              "addrs": "server_addr_rec *",
              "timeout": "apr_interval_time_t",
              "keep_alive_timeout": "apr_interval_time_t",
              "keep_alive_max": "int",
              "keep_alive": "int",
              "names": "apr_array_header_t *",
              "wild_names": "apr_array_header_t *",
              "path": "const char *",
              "pathlen": "int",
              "limit_req_line": "int",
              "limit_req_fieldsize": "int",
              "limit_req_fields": "int",
              "context": "void *",
              "keep_alive_timeout_set": "unsigned int"
            },
            "condition": ""
          },
          "ap_configfile_t": {
            "name": "ap_configfile_t",
            "definition": "struct ap_configfile_t {\n    /**< an apr_file_getc()-like function */\n    apr_status_t (*getch) (char *ch, void *param);\n    /**< an apr_file_gets()-like function */\n    apr_status_t (*getstr) (void *buf, apr_size_t bufsiz, void *param);\n    /**< a close handler function */\n    apr_status_t (*close) (void *param);\n    /**< the argument passed to getch/getstr/close */\n    void *param;\n    /**< the filename / description */\n    const char *name;\n    /**< current line number, starting at 1 */\n    unsigned line_number;\n}",
            "typedef_name": null,
            "fields": {
              "getch": "apr_status_t (*)(char *, void *)",
              "getstr": "apr_status_t (*)(void *, apr_size_t, void *)",
              "close": "apr_status_t (*)(void *)",
              "param": "void *",
              "name": "const char *",
              "line_number": "unsigned int"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "mime_module": {
            "name": "mime_module",
            "type": "module",
            "is_extern": false,
            "is_static": false,
            "definition": "AP_DECLARE_MODULE(mime) = {\n    STANDARD20_MODULE_STUFF,\n    create_mime_dir_config,     /* create per-directory config structure */\n    merge_mime_dir_configs,     /* merge per-directory config structures */\n    NULL,                       /* create per-server config structure */\n    NULL,                       /* merge per-server config structures */\n    mime_cmds,                  /* command apr_table_t */\n    register_hooks              /* register hooks */\n}",
            "initializer": "{\n    STANDARD20_MODULE_STUFF,\n    create_mime_dir_config,     /* create per-directory config structure */\n    merge_mime_dir_configs,     /* merge per-directory config structures */\n    NULL,                       /* create per-server config structure */\n    NULL,                       /* merge per-server config structures */\n    mime_cmds,                  /* command apr_table_t */\n    register_hooks              /* register hooks */\n}",
            "full_definition": "AP_DECLARE_MODULE(mime) = {\n    STANDARD20_MODULE_STUFF,\n    create_mime_dir_config,     /* create per-directory config structure */\n    merge_mime_dir_configs,     /* merge per-directory config structures */\n    NULL,                       /* create per-server config structure */\n    NULL,                       /* merge per-server config structures */\n    mime_cmds,                  /* command apr_table_t */\n    register_hooks              /* register hooks */\n}",
            "used_macros": {},
            "condition": ""
          },
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "AP_DECLARE_MODULE(mime)",
            "initializer": null,
            "full_definition": "AP_DECLARE_MODULE(mime)",
            "used_macros": {},
            "condition": ""
          },
          "mime_type_extensions": {
            "name": "mime_type_extensions",
            "type": "apr_hash_t *",
            "is_extern": false,
            "is_static": true,
            "definition": "static apr_hash_t *mime_type_extensions",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "apr_status_t"
        ]
      },
      "source_code": "static int mime_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)\n{\n    ap_configfile_t *f;\n    char l[MAX_STRING_LEN];\n    const char *types_confname = ap_get_module_config(s->module_config,\n                                                      &mime_module);\n    apr_status_t status;\n\n    if (!types_confname) {\n        types_confname = AP_TYPES_CONFIG_FILE;\n    }\n\n    types_confname = ap_server_root_relative(p, types_confname);\n    if (!types_confname) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, APR_EBADPATH, s, APLOGNO(01596)\n                     \"Invalid mime types config path %s\",\n                     (const char *)ap_get_module_config(s->module_config,\n                                                        &mime_module));\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    if ((status = ap_pcfg_openfile(&f, ptemp, types_confname))\n                != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, status, s, APLOGNO(01597)\n                     \"could not open mime types config file %s.\",\n                     types_confname);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    mime_type_extensions = apr_hash_make(p);\n\n    while (!(ap_cfg_getline(l, MAX_STRING_LEN, f))) {\n        const char *ll = l, *ct;\n\n        if (l[0] == '#') {\n            continue;\n        }\n        ct = ap_getword_conf(p, &ll);\n\n        while (ll[0]) {\n            char *ext = ap_getword_conf(p, &ll);\n            ap_str_tolower(ext);\n            apr_hash_set(mime_type_extensions, ext, APR_HASH_KEY_STRING, ct);\n        }\n    }\n    ap_cfg_closefile(f);\n    return OK;\n}"
    },
    "zap_sp@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 535, column 20>": {
      "basic_info": {
        "function_id": 1436,
        "name": "zap_sp",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 535, column 20>",
        "is_definition": true,
        "start_line": 535,
        "end_line": 549,
        "return_type": "const char *",
        "parameters": [
          {
            "name": "s",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {},
        "callers": {
          "analyze_ct@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 598, column 22>": {
            "source_code": "static content_type *analyze_ct(request_rec *r, const char *s)\n{\n    const char *cp, *mp;\n    char *attribute, *value;\n    int quoted = 0;\n    server_rec * ss = r->server;\n    apr_pool_t * p = r->pool;\n\n    content_type *ctp;\n    param *pp, *npp;\n\n    /* initialize ctp */\n    ctp = (content_type *)apr_palloc(p, sizeof(content_type));\n    ctp->type = NULL;\n    ctp->subtype = NULL;\n    ctp->param = NULL;\n\n    mp = s;\n\n    /* getting a type */\n    cp = mp;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01598)\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type = cp;\n    do {\n        cp++;\n    } while (*cp && (*cp != '/') && !apr_isspace(*cp) && (*cp != ';'));\n    if (!*cp || (*cp == ';')) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01599)\n                     \"Cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (*cp != '/') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01600)\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type_len = cp - ctp->type;\n\n    cp++; /* skip the '/' */\n\n    /* getting a subtype */\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01601)\n                     \"Cannot get media subtype.\");\n        return (NULL);\n    }\n    ctp->subtype = cp;\n    do {\n        cp++;\n    } while (*cp && !apr_isspace(*cp) && (*cp != ';'));\n    ctp->subtype_len = cp - ctp->subtype;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n\n    if (*cp == '\\0') {\n        return (ctp);\n    }\n\n    /* getting parameters */\n    cp++; /* skip the ';' */\n    cp = zap_sp(cp);\n    if (cp == NULL || *cp == '\\0') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01602)\n                     \"Cannot get media parameter.\");\n        return (NULL);\n    }\n    mp = cp;\n    attribute = NULL;\n    value = NULL;\n\n    while (cp != NULL && *cp != '\\0') {\n        if (attribute == NULL) {\n            if (is_token(*cp) > 0) {\n                cp++;\n                continue;\n            }\n            else if (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                cp++;\n                continue;\n            }\n            else if (*cp == '=') {\n                attribute = zap_sp_and_dup(p, mp, cp, NULL);\n                if (attribute == NULL || *attribute == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01603)\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                cp++;\n                cp = zap_sp(cp);\n                if (cp == NULL || *cp == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01604)\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                mp = cp;\n                continue;\n            }\n            else {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01605)\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n        }\n        else {\n            if (mp == cp) {\n                if (*cp == '\"') {\n                    quoted = 1;\n                    cp++;\n                }\n                else {\n                    quoted = 0;\n                }\n            }\n            if (quoted > 0) {\n                while (quoted && *cp != '\\0') {\n                    if (is_qtext(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (is_quoted_pair(cp) > 0) {\n                        cp += 2;\n                    }\n                    else if (*cp == '\"') {\n                        cp++;\n                        while (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                            cp++;\n                        }\n                        if (*cp != ';' && *cp != '\\0') {\n                            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01606)\n                                         \"Cannot get media parameter.\");\n                            return(NULL);\n                        }\n                        quoted = 0;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01607)\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            else {\n                while (1) {\n                    if (is_token(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (*cp == '\\0' || *cp == ';') {\n                        break;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01608)\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            value = zap_sp_and_dup(p, mp, cp, NULL);\n            if (value == NULL || *value == '\\0') {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01609)\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n\n            pp = apr_palloc(p, sizeof(param));\n            pp->attr = attribute;\n            pp->val = value;\n            pp->next = NULL;\n\n            if (ctp->param == NULL) {\n                ctp->param = pp;\n            }\n            else {\n                npp = ctp->param;\n                while (npp->next) {\n                    npp = npp->next;\n                }\n                npp->next = pp;\n            }\n            quoted = 0;\n            attribute = NULL;\n            value = NULL;\n            if (*cp == '\\0') {\n                break;\n            }\n            cp++;\n            mp = cp;\n        }\n    }\n    return (ctp);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 598, column 22>"
          }
        },
        "used_macros": {},
        "used_structs": {},
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static const char *zap_sp(const char *s)\n{\n    if (s == NULL) {\n        return (NULL);\n    }\n    if (*s == '\\0') {\n        return (s);\n    }\n\n    /* skip prefixed white space */\n    for (; *s == ' ' || *s == '\\t' || *s == '\\n'; s++)\n        ;\n\n    return (s);\n}"
    },
    "zap_sp_and_dup@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 551, column 14>": {
      "basic_info": {
        "function_id": 1437,
        "name": "zap_sp_and_dup",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 551, column 14>",
        "is_definition": true,
        "start_line": 551,
        "end_line": 564,
        "return_type": "char *",
        "parameters": [
          {
            "name": "p",
            "type": "apr_pool_t *"
          },
          {
            "name": "start",
            "type": "const char *"
          },
          {
            "name": "end",
            "type": "const char *"
          },
          {
            "name": "len",
            "type": "apr_size_t *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "__ctype_b_loc": {
            "declaration": "extern const unsigned short int **__ctype_b_loc (void)\n     __THROW __attribute__ ((__const__))",
            "is_external": true,
            "definition": null
          },
          "apr_pstrmemdup": {
            "declaration": "APR_DECLARE(char *) apr_pstrmemdup(apr_pool_t *p, const char *s, apr_size_t n)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "analyze_ct@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 598, column 22>": {
            "source_code": "static content_type *analyze_ct(request_rec *r, const char *s)\n{\n    const char *cp, *mp;\n    char *attribute, *value;\n    int quoted = 0;\n    server_rec * ss = r->server;\n    apr_pool_t * p = r->pool;\n\n    content_type *ctp;\n    param *pp, *npp;\n\n    /* initialize ctp */\n    ctp = (content_type *)apr_palloc(p, sizeof(content_type));\n    ctp->type = NULL;\n    ctp->subtype = NULL;\n    ctp->param = NULL;\n\n    mp = s;\n\n    /* getting a type */\n    cp = mp;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01598)\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type = cp;\n    do {\n        cp++;\n    } while (*cp && (*cp != '/') && !apr_isspace(*cp) && (*cp != ';'));\n    if (!*cp || (*cp == ';')) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01599)\n                     \"Cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (*cp != '/') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01600)\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type_len = cp - ctp->type;\n\n    cp++; /* skip the '/' */\n\n    /* getting a subtype */\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01601)\n                     \"Cannot get media subtype.\");\n        return (NULL);\n    }\n    ctp->subtype = cp;\n    do {\n        cp++;\n    } while (*cp && !apr_isspace(*cp) && (*cp != ';'));\n    ctp->subtype_len = cp - ctp->subtype;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n\n    if (*cp == '\\0') {\n        return (ctp);\n    }\n\n    /* getting parameters */\n    cp++; /* skip the ';' */\n    cp = zap_sp(cp);\n    if (cp == NULL || *cp == '\\0') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01602)\n                     \"Cannot get media parameter.\");\n        return (NULL);\n    }\n    mp = cp;\n    attribute = NULL;\n    value = NULL;\n\n    while (cp != NULL && *cp != '\\0') {\n        if (attribute == NULL) {\n            if (is_token(*cp) > 0) {\n                cp++;\n                continue;\n            }\n            else if (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                cp++;\n                continue;\n            }\n            else if (*cp == '=') {\n                attribute = zap_sp_and_dup(p, mp, cp, NULL);\n                if (attribute == NULL || *attribute == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01603)\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                cp++;\n                cp = zap_sp(cp);\n                if (cp == NULL || *cp == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01604)\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                mp = cp;\n                continue;\n            }\n            else {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01605)\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n        }\n        else {\n            if (mp == cp) {\n                if (*cp == '\"') {\n                    quoted = 1;\n                    cp++;\n                }\n                else {\n                    quoted = 0;\n                }\n            }\n            if (quoted > 0) {\n                while (quoted && *cp != '\\0') {\n                    if (is_qtext(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (is_quoted_pair(cp) > 0) {\n                        cp += 2;\n                    }\n                    else if (*cp == '\"') {\n                        cp++;\n                        while (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                            cp++;\n                        }\n                        if (*cp != ';' && *cp != '\\0') {\n                            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01606)\n                                         \"Cannot get media parameter.\");\n                            return(NULL);\n                        }\n                        quoted = 0;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01607)\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            else {\n                while (1) {\n                    if (is_token(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (*cp == '\\0' || *cp == ';') {\n                        break;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01608)\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            value = zap_sp_and_dup(p, mp, cp, NULL);\n            if (value == NULL || *value == '\\0') {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01609)\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n\n            pp = apr_palloc(p, sizeof(param));\n            pp->attr = attribute;\n            pp->val = value;\n            pp->next = NULL;\n\n            if (ctp->param == NULL) {\n                ctp->param = pp;\n            }\n            else {\n                npp = ctp->param;\n                while (npp->next) {\n                    npp = npp->next;\n                }\n                npp->next = pp;\n            }\n            quoted = 0;\n            attribute = NULL;\n            value = NULL;\n            if (*cp == '\\0') {\n                break;\n            }\n            cp++;\n            mp = cp;\n        }\n    }\n    return (ctp);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 598, column 22>"
          }
        },
        "used_macros": {
          "_ISalnum": {
            "name": "_ISalnum",
            "value": "8",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISalnum = 8",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 59, column 3>",
            "condition": ""
          },
          "_ISalpha": {
            "name": "_ISalpha",
            "value": "1024",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISalpha = 1024",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 50, column 3>",
            "condition": ""
          },
          "_IScntrl": {
            "name": "_IScntrl",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _IScntrl = 2",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 57, column 3>",
            "condition": ""
          },
          "_ISdigit": {
            "name": "_ISdigit",
            "value": "2048",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISdigit = 2048",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 51, column 3>",
            "condition": ""
          },
          "_ISlower": {
            "name": "_ISlower",
            "value": "512",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISlower = 512",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 49, column 3>",
            "condition": ""
          },
          "_ISgraph": {
            "name": "_ISgraph",
            "value": "32768",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISgraph = 32768",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 55, column 3>",
            "condition": ""
          },
          "_ISprint": {
            "name": "_ISprint",
            "value": "16384",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISprint = 16384",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 54, column 3>",
            "condition": ""
          },
          "_ISpunct": {
            "name": "_ISpunct",
            "value": "4",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISpunct = 4",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 58, column 3>",
            "condition": ""
          },
          "_ISspace": {
            "name": "_ISspace",
            "value": "8192",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISspace = 8192",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 53, column 3>",
            "condition": ""
          }
        },
        "used_structs": {
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "apr_size_t"
        ]
      },
      "source_code": "static char *zap_sp_and_dup(apr_pool_t *p, const char *start,\n                            const char *end, apr_size_t *len)\n{\n    while ((start < end) && apr_isspace(*start)) {\n        start++;\n    }\n    while ((end > start) && apr_isspace(*(end - 1))) {\n        end--;\n    }\n    if (len) {\n        *len = end - start;\n    }\n    return apr_pstrmemdup(p, start, end - start);\n}"
    },
    "is_token@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 566, column 12>": {
      "basic_info": {
        "function_id": 1438,
        "name": "is_token",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 566, column 12>",
        "is_definition": true,
        "start_line": 566,
        "end_line": 573,
        "return_type": "int",
        "parameters": [
          {
            "name": "c",
            "type": "char"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "__ctype_b_loc": {
            "declaration": "extern const unsigned short int **__ctype_b_loc (void)\n     __THROW __attribute__ ((__const__))",
            "is_external": true,
            "definition": null
          },
          "strchr": {
            "declaration": "extern char *strchr (const char *__s, int __c)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "analyze_ct@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 598, column 22>": {
            "source_code": "static content_type *analyze_ct(request_rec *r, const char *s)\n{\n    const char *cp, *mp;\n    char *attribute, *value;\n    int quoted = 0;\n    server_rec * ss = r->server;\n    apr_pool_t * p = r->pool;\n\n    content_type *ctp;\n    param *pp, *npp;\n\n    /* initialize ctp */\n    ctp = (content_type *)apr_palloc(p, sizeof(content_type));\n    ctp->type = NULL;\n    ctp->subtype = NULL;\n    ctp->param = NULL;\n\n    mp = s;\n\n    /* getting a type */\n    cp = mp;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01598)\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type = cp;\n    do {\n        cp++;\n    } while (*cp && (*cp != '/') && !apr_isspace(*cp) && (*cp != ';'));\n    if (!*cp || (*cp == ';')) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01599)\n                     \"Cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (*cp != '/') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01600)\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type_len = cp - ctp->type;\n\n    cp++; /* skip the '/' */\n\n    /* getting a subtype */\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01601)\n                     \"Cannot get media subtype.\");\n        return (NULL);\n    }\n    ctp->subtype = cp;\n    do {\n        cp++;\n    } while (*cp && !apr_isspace(*cp) && (*cp != ';'));\n    ctp->subtype_len = cp - ctp->subtype;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n\n    if (*cp == '\\0') {\n        return (ctp);\n    }\n\n    /* getting parameters */\n    cp++; /* skip the ';' */\n    cp = zap_sp(cp);\n    if (cp == NULL || *cp == '\\0') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01602)\n                     \"Cannot get media parameter.\");\n        return (NULL);\n    }\n    mp = cp;\n    attribute = NULL;\n    value = NULL;\n\n    while (cp != NULL && *cp != '\\0') {\n        if (attribute == NULL) {\n            if (is_token(*cp) > 0) {\n                cp++;\n                continue;\n            }\n            else if (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                cp++;\n                continue;\n            }\n            else if (*cp == '=') {\n                attribute = zap_sp_and_dup(p, mp, cp, NULL);\n                if (attribute == NULL || *attribute == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01603)\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                cp++;\n                cp = zap_sp(cp);\n                if (cp == NULL || *cp == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01604)\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                mp = cp;\n                continue;\n            }\n            else {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01605)\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n        }\n        else {\n            if (mp == cp) {\n                if (*cp == '\"') {\n                    quoted = 1;\n                    cp++;\n                }\n                else {\n                    quoted = 0;\n                }\n            }\n            if (quoted > 0) {\n                while (quoted && *cp != '\\0') {\n                    if (is_qtext(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (is_quoted_pair(cp) > 0) {\n                        cp += 2;\n                    }\n                    else if (*cp == '\"') {\n                        cp++;\n                        while (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                            cp++;\n                        }\n                        if (*cp != ';' && *cp != '\\0') {\n                            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01606)\n                                         \"Cannot get media parameter.\");\n                            return(NULL);\n                        }\n                        quoted = 0;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01607)\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            else {\n                while (1) {\n                    if (is_token(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (*cp == '\\0' || *cp == ';') {\n                        break;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01608)\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            value = zap_sp_and_dup(p, mp, cp, NULL);\n            if (value == NULL || *value == '\\0') {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01609)\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n\n            pp = apr_palloc(p, sizeof(param));\n            pp->attr = attribute;\n            pp->val = value;\n            pp->next = NULL;\n\n            if (ctp->param == NULL) {\n                ctp->param = pp;\n            }\n            else {\n                npp = ctp->param;\n                while (npp->next) {\n                    npp = npp->next;\n                }\n                npp->next = pp;\n            }\n            quoted = 0;\n            attribute = NULL;\n            value = NULL;\n            if (*cp == '\\0') {\n                break;\n            }\n            cp++;\n            mp = cp;\n        }\n    }\n    return (ctp);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 598, column 22>"
          }
        },
        "used_macros": {
          "_ISalnum": {
            "name": "_ISalnum",
            "value": "8",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISalnum = 8",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 59, column 3>",
            "condition": ""
          },
          "_ISalpha": {
            "name": "_ISalpha",
            "value": "1024",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISalpha = 1024",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 50, column 3>",
            "condition": ""
          },
          "_IScntrl": {
            "name": "_IScntrl",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _IScntrl = 2",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 57, column 3>",
            "condition": ""
          },
          "_ISdigit": {
            "name": "_ISdigit",
            "value": "2048",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISdigit = 2048",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 51, column 3>",
            "condition": ""
          },
          "_ISlower": {
            "name": "_ISlower",
            "value": "512",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISlower = 512",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 49, column 3>",
            "condition": ""
          },
          "_ISgraph": {
            "name": "_ISgraph",
            "value": "32768",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISgraph = 32768",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 55, column 3>",
            "condition": ""
          }
        },
        "used_structs": {},
        "used_globals": {
          "tspecial": {
            "name": "tspecial",
            "type": "char[16]",
            "is_extern": false,
            "is_static": true,
            "definition": "static char tspecial[] = {\n    '(', ')', '<', '>', '@', ',', ';', ':',\n    '\\\\', '\"', '/', '[', ']', '?', '=',\n    '\\0'\n}",
            "initializer": "{\n    '(', ')', '<', '>', '@', ',', ';', ':',\n    '\\\\', '\"', '/', '[', ']', '?', '=',\n    '\\0'\n}",
            "full_definition": "static char tspecial[] = {\n    '(', ')', '<', '>', '@', ',', ';', ':',\n    '\\\\', '\"', '/', '[', ']', '?', '=',\n    '\\0'\n}",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "static int is_token(char c)\n{\n    int res;\n\n    res = (apr_isascii(c) && apr_isgraph(c)\n           && (strchr(tspecial, c) == NULL)) ? 1 : -1;\n    return res;\n}"
    },
    "is_qtext@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 575, column 12>": {
      "basic_info": {
        "function_id": 1439,
        "name": "is_qtext",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 575, column 12>",
        "is_definition": true,
        "start_line": 575,
        "end_line": 582,
        "return_type": "int",
        "parameters": [
          {
            "name": "c",
            "type": "char"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {},
        "callers": {
          "analyze_ct@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 598, column 22>": {
            "source_code": "static content_type *analyze_ct(request_rec *r, const char *s)\n{\n    const char *cp, *mp;\n    char *attribute, *value;\n    int quoted = 0;\n    server_rec * ss = r->server;\n    apr_pool_t * p = r->pool;\n\n    content_type *ctp;\n    param *pp, *npp;\n\n    /* initialize ctp */\n    ctp = (content_type *)apr_palloc(p, sizeof(content_type));\n    ctp->type = NULL;\n    ctp->subtype = NULL;\n    ctp->param = NULL;\n\n    mp = s;\n\n    /* getting a type */\n    cp = mp;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01598)\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type = cp;\n    do {\n        cp++;\n    } while (*cp && (*cp != '/') && !apr_isspace(*cp) && (*cp != ';'));\n    if (!*cp || (*cp == ';')) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01599)\n                     \"Cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (*cp != '/') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01600)\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type_len = cp - ctp->type;\n\n    cp++; /* skip the '/' */\n\n    /* getting a subtype */\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01601)\n                     \"Cannot get media subtype.\");\n        return (NULL);\n    }\n    ctp->subtype = cp;\n    do {\n        cp++;\n    } while (*cp && !apr_isspace(*cp) && (*cp != ';'));\n    ctp->subtype_len = cp - ctp->subtype;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n\n    if (*cp == '\\0') {\n        return (ctp);\n    }\n\n    /* getting parameters */\n    cp++; /* skip the ';' */\n    cp = zap_sp(cp);\n    if (cp == NULL || *cp == '\\0') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01602)\n                     \"Cannot get media parameter.\");\n        return (NULL);\n    }\n    mp = cp;\n    attribute = NULL;\n    value = NULL;\n\n    while (cp != NULL && *cp != '\\0') {\n        if (attribute == NULL) {\n            if (is_token(*cp) > 0) {\n                cp++;\n                continue;\n            }\n            else if (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                cp++;\n                continue;\n            }\n            else if (*cp == '=') {\n                attribute = zap_sp_and_dup(p, mp, cp, NULL);\n                if (attribute == NULL || *attribute == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01603)\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                cp++;\n                cp = zap_sp(cp);\n                if (cp == NULL || *cp == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01604)\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                mp = cp;\n                continue;\n            }\n            else {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01605)\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n        }\n        else {\n            if (mp == cp) {\n                if (*cp == '\"') {\n                    quoted = 1;\n                    cp++;\n                }\n                else {\n                    quoted = 0;\n                }\n            }\n            if (quoted > 0) {\n                while (quoted && *cp != '\\0') {\n                    if (is_qtext(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (is_quoted_pair(cp) > 0) {\n                        cp += 2;\n                    }\n                    else if (*cp == '\"') {\n                        cp++;\n                        while (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                            cp++;\n                        }\n                        if (*cp != ';' && *cp != '\\0') {\n                            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01606)\n                                         \"Cannot get media parameter.\");\n                            return(NULL);\n                        }\n                        quoted = 0;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01607)\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            else {\n                while (1) {\n                    if (is_token(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (*cp == '\\0' || *cp == ';') {\n                        break;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01608)\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            value = zap_sp_and_dup(p, mp, cp, NULL);\n            if (value == NULL || *value == '\\0') {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01609)\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n\n            pp = apr_palloc(p, sizeof(param));\n            pp->attr = attribute;\n            pp->val = value;\n            pp->next = NULL;\n\n            if (ctp->param == NULL) {\n                ctp->param = pp;\n            }\n            else {\n                npp = ctp->param;\n                while (npp->next) {\n                    npp = npp->next;\n                }\n                npp->next = pp;\n            }\n            quoted = 0;\n            attribute = NULL;\n            value = NULL;\n            if (*cp == '\\0') {\n                break;\n            }\n            cp++;\n            mp = cp;\n        }\n    }\n    return (ctp);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 598, column 22>"
          }
        },
        "used_macros": {},
        "used_structs": {},
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static int is_qtext(char c)\n{\n    int res;\n\n    res = (apr_isascii(c) && (c != '\"') && (c != '\\\\') && (c != '\\n'))\n        ? 1 : -1;\n    return res;\n}"
    },
    "is_quoted_pair@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 584, column 12>": {
      "basic_info": {
        "function_id": 1440,
        "name": "is_quoted_pair",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 584, column 12>",
        "is_definition": true,
        "start_line": 584,
        "end_line": 596,
        "return_type": "int",
        "parameters": [
          {
            "name": "s",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {},
        "callers": {
          "analyze_ct@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 598, column 22>": {
            "source_code": "static content_type *analyze_ct(request_rec *r, const char *s)\n{\n    const char *cp, *mp;\n    char *attribute, *value;\n    int quoted = 0;\n    server_rec * ss = r->server;\n    apr_pool_t * p = r->pool;\n\n    content_type *ctp;\n    param *pp, *npp;\n\n    /* initialize ctp */\n    ctp = (content_type *)apr_palloc(p, sizeof(content_type));\n    ctp->type = NULL;\n    ctp->subtype = NULL;\n    ctp->param = NULL;\n\n    mp = s;\n\n    /* getting a type */\n    cp = mp;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01598)\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type = cp;\n    do {\n        cp++;\n    } while (*cp && (*cp != '/') && !apr_isspace(*cp) && (*cp != ';'));\n    if (!*cp || (*cp == ';')) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01599)\n                     \"Cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (*cp != '/') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01600)\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type_len = cp - ctp->type;\n\n    cp++; /* skip the '/' */\n\n    /* getting a subtype */\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01601)\n                     \"Cannot get media subtype.\");\n        return (NULL);\n    }\n    ctp->subtype = cp;\n    do {\n        cp++;\n    } while (*cp && !apr_isspace(*cp) && (*cp != ';'));\n    ctp->subtype_len = cp - ctp->subtype;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n\n    if (*cp == '\\0') {\n        return (ctp);\n    }\n\n    /* getting parameters */\n    cp++; /* skip the ';' */\n    cp = zap_sp(cp);\n    if (cp == NULL || *cp == '\\0') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01602)\n                     \"Cannot get media parameter.\");\n        return (NULL);\n    }\n    mp = cp;\n    attribute = NULL;\n    value = NULL;\n\n    while (cp != NULL && *cp != '\\0') {\n        if (attribute == NULL) {\n            if (is_token(*cp) > 0) {\n                cp++;\n                continue;\n            }\n            else if (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                cp++;\n                continue;\n            }\n            else if (*cp == '=') {\n                attribute = zap_sp_and_dup(p, mp, cp, NULL);\n                if (attribute == NULL || *attribute == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01603)\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                cp++;\n                cp = zap_sp(cp);\n                if (cp == NULL || *cp == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01604)\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                mp = cp;\n                continue;\n            }\n            else {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01605)\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n        }\n        else {\n            if (mp == cp) {\n                if (*cp == '\"') {\n                    quoted = 1;\n                    cp++;\n                }\n                else {\n                    quoted = 0;\n                }\n            }\n            if (quoted > 0) {\n                while (quoted && *cp != '\\0') {\n                    if (is_qtext(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (is_quoted_pair(cp) > 0) {\n                        cp += 2;\n                    }\n                    else if (*cp == '\"') {\n                        cp++;\n                        while (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                            cp++;\n                        }\n                        if (*cp != ';' && *cp != '\\0') {\n                            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01606)\n                                         \"Cannot get media parameter.\");\n                            return(NULL);\n                        }\n                        quoted = 0;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01607)\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            else {\n                while (1) {\n                    if (is_token(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (*cp == '\\0' || *cp == ';') {\n                        break;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01608)\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            value = zap_sp_and_dup(p, mp, cp, NULL);\n            if (value == NULL || *value == '\\0') {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01609)\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n\n            pp = apr_palloc(p, sizeof(param));\n            pp->attr = attribute;\n            pp->val = value;\n            pp->next = NULL;\n\n            if (ctp->param == NULL) {\n                ctp->param = pp;\n            }\n            else {\n                npp = ctp->param;\n                while (npp->next) {\n                    npp = npp->next;\n                }\n                npp->next = pp;\n            }\n            quoted = 0;\n            attribute = NULL;\n            value = NULL;\n            if (*cp == '\\0') {\n                break;\n            }\n            cp++;\n            mp = cp;\n        }\n    }\n    return (ctp);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 598, column 22>"
          }
        },
        "used_macros": {},
        "used_structs": {},
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static int is_quoted_pair(const char *s)\n{\n    int res = -1;\n    int c;\n\n    if (*s == '\\\\') {\n        c = (int) *(s + 1);\n        if (c && apr_isascii(c)) {\n            res = 1;\n        }\n    }\n    return (res);\n}"
    },
    "analyze_ct@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 598, column 22>": {
      "basic_info": {
        "function_id": 1441,
        "name": "analyze_ct",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 598, column 22>",
        "is_definition": true,
        "start_line": 598,
        "end_line": 803,
        "return_type": "content_type *",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "s",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "__ctype_b_loc": {
            "declaration": "extern const unsigned short int **__ctype_b_loc (void)\n     __THROW __attribute__ ((__const__))",
            "is_external": true,
            "definition": null
          },
          "ap_log_error_": {
            "declaration": "AP_DECLARE(void) ap_log_error_(const char *file, int line, int module_index,\n                               int level, apr_status_t status,\n                               const server_rec *s, const char *fmt, ...)\n                              __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "zap_sp": {
            "declaration": "static const char *zap_sp(const char *s)\n{\n    if (s == NULL) {\n        return (NULL);\n    }\n    if (*s == '\\0') {\n        return (s);\n    }\n\n    /* skip prefixed white space */\n    for (; *s == ' ' || *s == '\\t' || *s == '\\n'; s++)\n        ;\n\n    return (s);\n}",
            "is_external": false,
            "definition": "static const char *zap_sp(const char *s)\n{\n    if (s == NULL) {\n        return (NULL);\n    }\n    if (*s == '\\0') {\n        return (s);\n    }\n\n    /* skip prefixed white space */\n    for (; *s == ' ' || *s == '\\t' || *s == '\\n'; s++)\n        ;\n\n    return (s);\n}"
          },
          "is_token": {
            "declaration": "static int is_token(char c)\n{\n    int res;\n\n    res = (apr_isascii(c) && apr_isgraph(c)\n           && (strchr(tspecial, c) == NULL)) ? 1 : -1;\n    return res;\n}",
            "is_external": false,
            "definition": "static int is_token(char c)\n{\n    int res;\n\n    res = (apr_isascii(c) && apr_isgraph(c)\n           && (strchr(tspecial, c) == NULL)) ? 1 : -1;\n    return res;\n}"
          },
          "zap_sp_and_dup": {
            "declaration": "static char *zap_sp_and_dup(apr_pool_t *p, const char *start,\n                            const char *end, apr_size_t *len)\n{\n    while ((start < end) && apr_isspace(*start)) {\n        start++;\n    }\n    while ((end > start) && apr_isspace(*(end - 1))) {\n        end--;\n    }\n    if (len) {\n        *len = end - start;\n    }\n    return apr_pstrmemdup(p, start, end - start);\n}",
            "is_external": false,
            "definition": "static char *zap_sp_and_dup(apr_pool_t *p, const char *start,\n                            const char *end, apr_size_t *len)\n{\n    while ((start < end) && apr_isspace(*start)) {\n        start++;\n    }\n    while ((end > start) && apr_isspace(*(end - 1))) {\n        end--;\n    }\n    if (len) {\n        *len = end - start;\n    }\n    return apr_pstrmemdup(p, start, end - start);\n}"
          },
          "is_qtext": {
            "declaration": "static int is_qtext(char c)\n{\n    int res;\n\n    res = (apr_isascii(c) && (c != '\"') && (c != '\\\\') && (c != '\\n'))\n        ? 1 : -1;\n    return res;\n}",
            "is_external": false,
            "definition": "static int is_qtext(char c)\n{\n    int res;\n\n    res = (apr_isascii(c) && (c != '\"') && (c != '\\\\') && (c != '\\n'))\n        ? 1 : -1;\n    return res;\n}"
          },
          "is_quoted_pair": {
            "declaration": "static int is_quoted_pair(const char *s)\n{\n    int res = -1;\n    int c;\n\n    if (*s == '\\\\') {\n        c = (int) *(s + 1);\n        if (c && apr_isascii(c)) {\n            res = 1;\n        }\n    }\n    return (res);\n}",
            "is_external": false,
            "definition": "static int is_quoted_pair(const char *s)\n{\n    int res = -1;\n    int c;\n\n    if (*s == '\\\\') {\n        c = (int) *(s + 1);\n        if (c && apr_isascii(c)) {\n            res = 1;\n        }\n    }\n    return (res);\n}"
          }
        },
        "callers": {
          "find_ct@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 811, column 12>": {
            "source_code": "static int find_ct(request_rec *r)\n{\n    mime_dir_config *conf;\n    apr_array_header_t *exception_list;\n    char *ext;\n    const char *fn, *fntmp, *type, *charset = NULL, *resource_name, *qm;\n    int found_metadata = 0;\n\n    if (r->finfo.filetype == APR_DIR) {\n        ap_set_content_type_ex(r, DIR_MAGIC_TYPE, 1);\n        return OK;\n    }\n\n    if (!r->filename) {\n        return DECLINED;\n    }\n\n    conf = (mime_dir_config *)ap_get_module_config(r->per_dir_config,\n                                                   &mime_module);\n    if (conf->nomime == NOMIME_ON) {\n        return DECLINED;\n    }\n\n    exception_list = apr_array_make(r->pool, 2, sizeof(char *));\n\n    /* If use_path_info is explicitly set to on (value & 1 == 1), append. */\n    if (conf->use_path_info & 1) {\n        resource_name = apr_pstrcat(r->pool, r->filename, r->path_info, NULL);\n    }\n    /*\n     * In the reverse proxy case r->filename might contain a query string if\n     * the nocanon option was used with ProxyPass.\n     * If this is the case cut off the query string as the last parameter in\n     * this query string might end up on an extension we take care about, but\n     * we only want to match against path components not against query\n     * parameters.\n     */\n    else if ((r->proxyreq == PROXYREQ_REVERSE)\n             && (apr_table_get(r->notes, \"proxy-nocanon\"))\n             && ((qm = ap_strchr_c(r->filename, '?')) != NULL)) {\n        resource_name = apr_pstrmemdup(r->pool, r->filename, qm - r->filename);\n    }\n    else {\n        resource_name = r->filename;\n    }\n\n    /* Always drop the path leading up to the file name.\n     */\n    if ((fn = ap_strrchr_c(resource_name, '/')) == NULL) {\n        fn = resource_name;\n    }\n    else {\n        ++fn;\n    }\n\n\n    /* The exception list keeps track of those filename components that\n     * are not associated with extensions indicating metadata.\n     * The base name is always the first exception (i.e., \"txt.html\" has\n     * a basename of \"txt\" even though it might look like an extension).\n     * Leading dots are considered to be part of the base name (a file named\n     * \".png\" is likely not a png file but just a hidden file called png).\n     */\n    fntmp = fn;\n    while (*fntmp == '.')\n        fntmp++;\n    fntmp = ap_strchr_c(fntmp, '.');\n    if (fntmp) {\n        ext = apr_pstrmemdup(r->pool, fn, fntmp - fn);\n        fn = fntmp + 1;\n    }\n    else {\n        ext = apr_pstrdup(r->pool, fn);\n        fn += strlen(fn);\n    }\n\n    *((const char **)apr_array_push(exception_list)) = ext;\n\n    /* Parse filename extensions which can be in any order\n     */\n    while (*fn && (ext = ap_getword(r->pool, &fn, '.'))) {\n        const extension_info *exinfo = NULL;\n        int found;\n        char *extcase;\n        int skipct = (conf->ct_last_ext == CT_LAST_ON) && (*fn);\n        int skipall = (conf->all_last_ext == ALL_LAST_ON) && (*fn);\n\n        if (*ext == '\\0') {  /* ignore empty extensions \"bad..html\" */\n            continue;\n        }\n\n        if (skipall) { \n            continue; \n        }\n\n        found = 0;\n\n        /* Save the ext in extcase before converting it to lower case.\n         */\n        extcase = apr_pstrdup(r->pool, ext);\n        ap_str_tolower(ext);\n\n        if (conf->extension_mappings != NULL) {\n            exinfo = (extension_info*)apr_hash_get(conf->extension_mappings,\n                                                   ext, APR_HASH_KEY_STRING);\n        }\n\n        if ((exinfo == NULL || !exinfo->forced_type) && !skipct) {\n            if ((type = apr_hash_get(mime_type_extensions, ext,\n                                     APR_HASH_KEY_STRING)) != NULL) {\n                ap_set_content_type_ex(r, (char*) type, 1);\n                found = 1;\n            }\n        }\n\n        if (exinfo != NULL) {\n\n            /* empty string is treated as special case for RemoveType */\n            if ((exinfo->forced_type && *exinfo->forced_type) && !skipct) {\n                ap_set_content_type_ex(r, exinfo->forced_type, 1);\n                found = 1;\n            }\n\n            if (exinfo->charset_type) {\n                charset = exinfo->charset_type;\n                found = 1;\n            }\n            if (exinfo->language_type) {\n                if (!r->content_languages) {\n                    r->content_languages = apr_array_make(r->pool, 2,\n                                                          sizeof(char *));\n                }\n                *((const char **)apr_array_push(r->content_languages))\n                    = exinfo->language_type;\n                found = 1;\n            }\n            if (exinfo->encoding_type) {\n                if (!r->content_encoding) {\n                    r->content_encoding = exinfo->encoding_type;\n                }\n                else {\n                    /* XXX should eliminate duplicate entities\n                     *\n                     * ah no. Order is important and double encoding is neither\n                     * forbidden nor impossible. -- nd\n                     */\n                    r->content_encoding = apr_pstrcat(r->pool,\n                                                      r->content_encoding,\n                                                      \", \",\n                                                      exinfo->encoding_type,\n                                                      NULL);\n                }\n                found = 1;\n            }\n            /* The following extensions are not 'Found'.  That is, they don't\n             * make any contribution to metadata negotiation, so they must have\n             * been explicitly requested by name.\n             */\n            if (exinfo->handler && r->proxyreq == PROXYREQ_NONE) {\n                r->handler = exinfo->handler;\n                if (conf->multimatch & MULTIMATCH_HANDLERS) {\n                    found = 1;\n                }\n            }\n            /* XXX Two significant problems; 1, we don't check to see if we are\n             * setting redundant filters.    2, we insert these in the types\n             * config hook, which may be too early (dunno.)\n             */\n            if (exinfo->input_filters) {\n                const char *filter, *filters = exinfo->input_filters;\n                while (*filters\n                    && (filter = ap_getword(r->pool, &filters, ';'))) {\n                    ap_add_input_filter(filter, NULL, r, r->connection);\n                }\n                if (conf->multimatch & MULTIMATCH_FILTERS) {\n                    found = 1;\n                }\n            }\n            if (exinfo->output_filters) {\n                const char *filter, *filters = exinfo->output_filters;\n                while (*filters\n                    && (filter = ap_getword(r->pool, &filters, ';'))) {\n                    ap_add_output_filter(filter, NULL, r, r->connection);\n                }\n                if (conf->multimatch & MULTIMATCH_FILTERS) {\n                    found = 1;\n                }\n            }\n        }\n\n        if (found || (conf->multimatch & MULTIMATCH_ANY)) {\n            found_metadata = 1;\n        }\n        else {\n            *((const char **) apr_array_push(exception_list)) = extcase;\n        }\n    }\n\n    /*\n     * Need to set a notes entry on r for unrecognized elements.\n     * Somebody better claim them!  If we did absolutely nothing,\n     * skip the notes to alert mod_negotiation we are clueless.\n     */\n    if (found_metadata) {\n        apr_table_setn(r->notes, \"ap-mime-exceptions-list\",\n                       (void *)exception_list);\n    }\n\n    if (r->content_type) {\n        content_type *ctp;\n        int override = 0;\n\n        if ((ctp = analyze_ct(r, r->content_type))) {\n            param *pp = ctp->param;\n            char *base_content_type = apr_palloc(r->pool, ctp->type_len +\n                                                 ctp->subtype_len +\n                                                 sizeof(\"/\"));\n            char *tmp = base_content_type;\n            memcpy(tmp, ctp->type, ctp->type_len);\n            tmp += ctp->type_len;\n            *tmp++ = '/';\n            memcpy(tmp, ctp->subtype, ctp->subtype_len);\n            tmp += ctp->subtype_len;\n            *tmp = 0;\n            ap_set_content_type_ex(r, base_content_type, AP_REQUEST_IS_TRUSTED_CT(r));\n            while (pp != NULL) {\n                if (charset && !strcmp(pp->attr, \"charset\")) {\n                    if (!override) {\n                        ap_set_content_type_ex(r,\n                                            apr_pstrcat(r->pool,\n                                                        r->content_type,\n                                                        \"; charset=\",\n                                                        charset,\n                                                        NULL), AP_REQUEST_IS_TRUSTED_CT(r));\n                        override = 1;\n                    }\n                }\n                else {\n                    ap_set_content_type_ex(r,\n                                        apr_pstrcat(r->pool,\n                                                    r->content_type,\n                                                    \"; \", pp->attr,\n                                                    \"=\", pp->val,\n                                                    NULL), AP_REQUEST_IS_TRUSTED_CT(r));\n                }\n                pp = pp->next;\n            }\n            if (charset && !override) {\n                ap_set_content_type_ex(r, apr_pstrcat(r->pool, r->content_type,\n                                                   \"; charset=\", charset,\n                                                   NULL), AP_REQUEST_IS_TRUSTED_CT(r));\n            }\n        }\n    }\n\n    /* Set default language, if none was specified by the extensions\n     * and we have a DefaultLanguage setting in force\n     */\n\n    if (!r->content_languages && conf->default_language) {\n        const char **new;\n\n        r->content_languages = apr_array_make(r->pool, 2, sizeof(char *));\n        new = (const char **)apr_array_push(r->content_languages);\n        *new = conf->default_language;\n    }\n\n    if (!r->content_type) {\n        return DECLINED;\n    }\n\n    return OK;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 811, column 12>"
          }
        },
        "used_macros": {
          "_ISalnum": {
            "name": "_ISalnum",
            "value": "8",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISalnum = 8",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 59, column 3>",
            "condition": ""
          },
          "_ISalpha": {
            "name": "_ISalpha",
            "value": "1024",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISalpha = 1024",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 50, column 3>",
            "condition": ""
          },
          "_IScntrl": {
            "name": "_IScntrl",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _IScntrl = 2",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 57, column 3>",
            "condition": ""
          },
          "_ISdigit": {
            "name": "_ISdigit",
            "value": "2048",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISdigit = 2048",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 51, column 3>",
            "condition": ""
          },
          "_ISlower": {
            "name": "_ISlower",
            "value": "512",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISlower = 512",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 49, column 3>",
            "condition": ""
          },
          "_ISgraph": {
            "name": "_ISgraph",
            "value": "32768",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISgraph = 32768",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 55, column 3>",
            "condition": ""
          },
          "_ISprint": {
            "name": "_ISprint",
            "value": "16384",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISprint = 16384",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 54, column 3>",
            "condition": ""
          },
          "_ISpunct": {
            "name": "_ISpunct",
            "value": "4",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISpunct = 4",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 58, column 3>",
            "condition": ""
          },
          "_ISspace": {
            "name": "_ISspace",
            "value": "8192",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISspace = 8192",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 53, column 3>",
            "condition": ""
          }
        },
        "used_structs": {
          "content_type": {
            "name": "content_type",
            "definition": "struct {\n    const char *type;\n    apr_size_t type_len;\n    const char *subtype;\n    apr_size_t subtype_len;\n    param *param;\n}",
            "typedef_name": null,
            "fields": {
              "type": "const char *",
              "type_len": "apr_size_t",
              "subtype": "const char *",
              "subtype_len": "apr_size_t",
              "param": "param *"
            },
            "condition": ""
          },
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "server_rec": {
            "name": "server_rec",
            "definition": "struct server_rec {\n    /** The process this server is running in */\n    process_rec *process;\n    /** The next server in the list */\n    server_rec *next;\n\n    /* Log files --- note that transfer log is now in the modules... */\n\n    /** The name of the error log */\n    char *error_fname;\n    /** A file descriptor that references the error log */\n    apr_file_t *error_log;\n    /** The log level configuration */\n    struct ap_logconf log;\n\n    /* Module-specific configuration for server, and defaults... */\n\n    /** Config vector containing pointers to modules' per-server config\n     *  structures. */\n    struct ap_conf_vector_t *module_config;\n    /** MIME type info, etc., before we start checking per-directory info */\n    struct ap_conf_vector_t *lookup_defaults;\n\n    /** The path to the config file that the server was defined in */\n    const char *defn_name;\n    /** The line of the config file that the server was defined on */\n    unsigned defn_line_number;\n    /** true if this is the virtual server */\n    char is_virtual;\n\n\n    /* Information for redirects */\n\n    /** for redirects, etc. */\n    apr_port_t port;\n    /** The server request scheme for redirect responses */\n    const char *server_scheme;\n\n    /* Contact information */\n\n    /** The admin's contact information */\n    char *server_admin;\n    /** The server hostname */\n    char *server_hostname;\n\n    /* Transaction handling */\n\n    /** I haven't got a clue */\n    server_addr_rec *addrs;\n    /** Timeout, as an apr interval, before we give up */\n    apr_interval_time_t timeout;\n    /** The apr interval we will wait for another request */\n    apr_interval_time_t keep_alive_timeout;\n    /** Maximum requests per connection */\n    int keep_alive_max;\n    /** Use persistent connections? */\n    int keep_alive;\n\n    /** Normal names for ServerAlias servers */\n    apr_array_header_t *names;\n    /** Wildcarded names for ServerAlias servers */\n    apr_array_header_t *wild_names;\n\n    /** Pathname for ServerPath */\n    const char *path;\n    /** Length of path */\n    int pathlen;\n\n    /** limit on size of the HTTP request line    */\n    int limit_req_line;\n    /** limit on size of any request header field */\n    int limit_req_fieldsize;\n    /** limit on number of request header fields  */\n    int limit_req_fields;\n\n    /** Opaque storage location */\n    void *context;\n\n    /** Whether the keepalive timeout is explicit (1) or\n     *  inherited (0) from the base server (either first\n     *  server on the same IP:port or main server) */\n    unsigned int keep_alive_timeout_set:1;\n}",
            "typedef_name": null,
            "fields": {
              "process": "process_rec *",
              "next": "server_rec *",
              "error_fname": "char *",
              "error_log": "apr_file_t *",
              "log": "struct ap_logconf",
              "module_config": "struct ap_conf_vector_t *",
              "lookup_defaults": "struct ap_conf_vector_t *",
              "defn_name": "const char *",
              "defn_line_number": "unsigned int",
              "is_virtual": "char",
              "port": "apr_port_t",
              "server_scheme": "const char *",
              "server_admin": "char *",
              "server_hostname": "char *",
              "addrs": "server_addr_rec *",
              "timeout": "apr_interval_time_t",
              "keep_alive_timeout": "apr_interval_time_t",
              "keep_alive_max": "int",
              "keep_alive": "int",
              "names": "apr_array_header_t *",
              "wild_names": "apr_array_header_t *",
              "path": "const char *",
              "pathlen": "int",
              "limit_req_line": "int",
              "limit_req_fieldsize": "int",
              "limit_req_fields": "int",
              "context": "void *",
              "keep_alive_timeout_set": "unsigned int"
            },
            "condition": ""
          },
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "AP_DECLARE_MODULE(mime)",
            "initializer": null,
            "full_definition": "AP_DECLARE_MODULE(mime)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "param"
        ]
      },
      "source_code": "static content_type *analyze_ct(request_rec *r, const char *s)\n{\n    const char *cp, *mp;\n    char *attribute, *value;\n    int quoted = 0;\n    server_rec * ss = r->server;\n    apr_pool_t * p = r->pool;\n\n    content_type *ctp;\n    param *pp, *npp;\n\n    /* initialize ctp */\n    ctp = (content_type *)apr_palloc(p, sizeof(content_type));\n    ctp->type = NULL;\n    ctp->subtype = NULL;\n    ctp->param = NULL;\n\n    mp = s;\n\n    /* getting a type */\n    cp = mp;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01598)\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type = cp;\n    do {\n        cp++;\n    } while (*cp && (*cp != '/') && !apr_isspace(*cp) && (*cp != ';'));\n    if (!*cp || (*cp == ';')) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01599)\n                     \"Cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (*cp != '/') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01600)\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type_len = cp - ctp->type;\n\n    cp++; /* skip the '/' */\n\n    /* getting a subtype */\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01601)\n                     \"Cannot get media subtype.\");\n        return (NULL);\n    }\n    ctp->subtype = cp;\n    do {\n        cp++;\n    } while (*cp && !apr_isspace(*cp) && (*cp != ';'));\n    ctp->subtype_len = cp - ctp->subtype;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n\n    if (*cp == '\\0') {\n        return (ctp);\n    }\n\n    /* getting parameters */\n    cp++; /* skip the ';' */\n    cp = zap_sp(cp);\n    if (cp == NULL || *cp == '\\0') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01602)\n                     \"Cannot get media parameter.\");\n        return (NULL);\n    }\n    mp = cp;\n    attribute = NULL;\n    value = NULL;\n\n    while (cp != NULL && *cp != '\\0') {\n        if (attribute == NULL) {\n            if (is_token(*cp) > 0) {\n                cp++;\n                continue;\n            }\n            else if (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                cp++;\n                continue;\n            }\n            else if (*cp == '=') {\n                attribute = zap_sp_and_dup(p, mp, cp, NULL);\n                if (attribute == NULL || *attribute == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01603)\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                cp++;\n                cp = zap_sp(cp);\n                if (cp == NULL || *cp == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01604)\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                mp = cp;\n                continue;\n            }\n            else {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01605)\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n        }\n        else {\n            if (mp == cp) {\n                if (*cp == '\"') {\n                    quoted = 1;\n                    cp++;\n                }\n                else {\n                    quoted = 0;\n                }\n            }\n            if (quoted > 0) {\n                while (quoted && *cp != '\\0') {\n                    if (is_qtext(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (is_quoted_pair(cp) > 0) {\n                        cp += 2;\n                    }\n                    else if (*cp == '\"') {\n                        cp++;\n                        while (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                            cp++;\n                        }\n                        if (*cp != ';' && *cp != '\\0') {\n                            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01606)\n                                         \"Cannot get media parameter.\");\n                            return(NULL);\n                        }\n                        quoted = 0;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01607)\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            else {\n                while (1) {\n                    if (is_token(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (*cp == '\\0' || *cp == ';') {\n                        break;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01608)\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            value = zap_sp_and_dup(p, mp, cp, NULL);\n            if (value == NULL || *value == '\\0') {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01609)\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n\n            pp = apr_palloc(p, sizeof(param));\n            pp->attr = attribute;\n            pp->val = value;\n            pp->next = NULL;\n\n            if (ctp->param == NULL) {\n                ctp->param = pp;\n            }\n            else {\n                npp = ctp->param;\n                while (npp->next) {\n                    npp = npp->next;\n                }\n                npp->next = pp;\n            }\n            quoted = 0;\n            attribute = NULL;\n            value = NULL;\n            if (*cp == '\\0') {\n                break;\n            }\n            cp++;\n            mp = cp;\n        }\n    }\n    return (ctp);\n}"
    },
    "find_ct@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 811, column 12>": {
      "basic_info": {
        "function_id": 1442,
        "name": "find_ct",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 811, column 12>",
        "is_definition": true,
        "start_line": 811,
        "end_line": 1083,
        "return_type": "int",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_set_content_type_ex": {
            "declaration": "AP_DECLARE(void) ap_set_content_type_ex(request_rec *r, const char *ct, int trusted)",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_set_content_type_ex(request_rec *r, const char *ct, int trusted)\n{\n    ap_set_content_type(r, ct);\n    AP_REQUEST_SET_BNOTE(r, AP_REQUEST_TRUSTED_CT, trusted ? AP_REQUEST_TRUSTED_CT : 0);\n}"
          },
          "apr_array_make": {
            "declaration": "APR_DECLARE(apr_array_header_t *) apr_array_make(apr_pool_t *p,\n                                                 int nelts, int elt_size)",
            "is_external": true,
            "definition": null
          },
          "apr_pstrcat": {
            "declaration": "APR_DECLARE_NONSTD(char *) apr_pstrcat(apr_pool_t *p, ...)\n#if defined(__GNUC__) && __GNUC__ >= 4\n    __attribute__((sentinel))",
            "is_external": true,
            "definition": null
          },
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "strchr": {
            "declaration": "extern char *strchr (const char *__s, int __c)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_pstrmemdup": {
            "declaration": "APR_DECLARE(char *) apr_pstrmemdup(apr_pool_t *p, const char *s, apr_size_t n)",
            "is_external": true,
            "definition": null
          },
          "strrchr": {
            "declaration": "extern char *strrchr (const char *__s, int __c)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_pstrdup": {
            "declaration": "APR_DECLARE(char *) apr_pstrdup(apr_pool_t *p, const char *s)",
            "is_external": true,
            "definition": null
          },
          "strlen": {
            "declaration": "extern size_t strlen (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_array_push": {
            "declaration": "APR_DECLARE(void *) apr_array_push(apr_array_header_t *arr)",
            "is_external": true,
            "definition": null
          },
          "ap_getword": {
            "declaration": "AP_DECLARE(char *) ap_getword(apr_pool_t *p, const char **line, char stop)",
            "is_external": true,
            "definition": null
          },
          "ap_str_tolower": {
            "declaration": "AP_DECLARE(void) ap_str_tolower(char *s)",
            "is_external": true,
            "definition": null
          },
          "apr_hash_get": {
            "declaration": "APR_DECLARE(void *) apr_hash_get(apr_hash_t *ht, const void *key,\n                                 apr_ssize_t klen)",
            "is_external": true,
            "definition": null
          },
          "ap_add_input_filter": {
            "declaration": "AP_DECLARE(ap_filter_t *) ap_add_input_filter(const char *name, void *ctx,\n                                              request_rec *r, conn_rec *c)",
            "is_external": true,
            "definition": null
          },
          "ap_add_output_filter": {
            "declaration": "AP_DECLARE(ap_filter_t *) ap_add_output_filter(const char *name, void *ctx,\n                                               request_rec *r, conn_rec *c)",
            "is_external": true,
            "definition": null
          },
          "apr_table_setn": {
            "declaration": "APR_DECLARE(void) apr_table_setn(apr_table_t *t, const char *key,\n                                 const char *val)",
            "is_external": true,
            "definition": null
          },
          "analyze_ct": {
            "declaration": "static content_type *analyze_ct(request_rec *r, const char *s)\n{\n    const char *cp, *mp;\n    char *attribute, *value;\n    int quoted = 0;\n    server_rec * ss = r->server;\n    apr_pool_t * p = r->pool;\n\n    content_type *ctp;\n    param *pp, *npp;\n\n    /* initialize ctp */\n    ctp = (content_type *)apr_palloc(p, sizeof(content_type));\n    ctp->type = NULL;\n    ctp->subtype = NULL;\n    ctp->param = NULL;\n\n    mp = s;\n\n    /* getting a type */\n    cp = mp;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01598)\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type = cp;\n    do {\n        cp++;\n    } while (*cp && (*cp != '/') && !apr_isspace(*cp) && (*cp != ';'));\n    if (!*cp || (*cp == ';')) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01599)\n                     \"Cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (*cp != '/') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01600)\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type_len = cp - ctp->type;\n\n    cp++; /* skip the '/' */\n\n    /* getting a subtype */\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01601)\n                     \"Cannot get media subtype.\");\n        return (NULL);\n    }\n    ctp->subtype = cp;\n    do {\n        cp++;\n    } while (*cp && !apr_isspace(*cp) && (*cp != ';'));\n    ctp->subtype_len = cp - ctp->subtype;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n\n    if (*cp == '\\0') {\n        return (ctp);\n    }\n\n    /* getting parameters */\n    cp++; /* skip the ';' */\n    cp = zap_sp(cp);\n    if (cp == NULL || *cp == '\\0') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01602)\n                     \"Cannot get media parameter.\");\n        return (NULL);\n    }\n    mp = cp;\n    attribute = NULL;\n    value = NULL;\n\n    while (cp != NULL && *cp != '\\0') {\n        if (attribute == NULL) {\n            if (is_token(*cp) > 0) {\n                cp++;\n                continue;\n            }\n            else if (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                cp++;\n                continue;\n            }\n            else if (*cp == '=') {\n                attribute = zap_sp_and_dup(p, mp, cp, NULL);\n                if (attribute == NULL || *attribute == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01603)\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                cp++;\n                cp = zap_sp(cp);\n                if (cp == NULL || *cp == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01604)\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                mp = cp;\n                continue;\n            }\n            else {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01605)\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n        }\n        else {\n            if (mp == cp) {\n                if (*cp == '\"') {\n                    quoted = 1;\n                    cp++;\n                }\n                else {\n                    quoted = 0;\n                }\n            }\n            if (quoted > 0) {\n                while (quoted && *cp != '\\0') {\n                    if (is_qtext(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (is_quoted_pair(cp) > 0) {\n                        cp += 2;\n                    }\n                    else if (*cp == '\"') {\n                        cp++;\n                        while (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                            cp++;\n                        }\n                        if (*cp != ';' && *cp != '\\0') {\n                            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01606)\n                                         \"Cannot get media parameter.\");\n                            return(NULL);\n                        }\n                        quoted = 0;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01607)\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            else {\n                while (1) {\n                    if (is_token(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (*cp == '\\0' || *cp == ';') {\n                        break;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01608)\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            value = zap_sp_and_dup(p, mp, cp, NULL);\n            if (value == NULL || *value == '\\0') {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01609)\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n\n            pp = apr_palloc(p, sizeof(param));\n            pp->attr = attribute;\n            pp->val = value;\n            pp->next = NULL;\n\n            if (ctp->param == NULL) {\n                ctp->param = pp;\n            }\n            else {\n                npp = ctp->param;\n                while (npp->next) {\n                    npp = npp->next;\n                }\n                npp->next = pp;\n            }\n            quoted = 0;\n            attribute = NULL;\n            value = NULL;\n            if (*cp == '\\0') {\n                break;\n            }\n            cp++;\n            mp = cp;\n        }\n    }\n    return (ctp);\n}",
            "is_external": false,
            "definition": "static content_type *analyze_ct(request_rec *r, const char *s)\n{\n    const char *cp, *mp;\n    char *attribute, *value;\n    int quoted = 0;\n    server_rec * ss = r->server;\n    apr_pool_t * p = r->pool;\n\n    content_type *ctp;\n    param *pp, *npp;\n\n    /* initialize ctp */\n    ctp = (content_type *)apr_palloc(p, sizeof(content_type));\n    ctp->type = NULL;\n    ctp->subtype = NULL;\n    ctp->param = NULL;\n\n    mp = s;\n\n    /* getting a type */\n    cp = mp;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01598)\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type = cp;\n    do {\n        cp++;\n    } while (*cp && (*cp != '/') && !apr_isspace(*cp) && (*cp != ';'));\n    if (!*cp || (*cp == ';')) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01599)\n                     \"Cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (*cp != '/') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01600)\n                     \"mod_mime: analyze_ct: cannot get media type from '%s'\",\n                     (const char *) mp);\n        return (NULL);\n    }\n    ctp->type_len = cp - ctp->type;\n\n    cp++; /* skip the '/' */\n\n    /* getting a subtype */\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n    if (!*cp) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01601)\n                     \"Cannot get media subtype.\");\n        return (NULL);\n    }\n    ctp->subtype = cp;\n    do {\n        cp++;\n    } while (*cp && !apr_isspace(*cp) && (*cp != ';'));\n    ctp->subtype_len = cp - ctp->subtype;\n    while (apr_isspace(*cp)) {\n        cp++;\n    }\n\n    if (*cp == '\\0') {\n        return (ctp);\n    }\n\n    /* getting parameters */\n    cp++; /* skip the ';' */\n    cp = zap_sp(cp);\n    if (cp == NULL || *cp == '\\0') {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01602)\n                     \"Cannot get media parameter.\");\n        return (NULL);\n    }\n    mp = cp;\n    attribute = NULL;\n    value = NULL;\n\n    while (cp != NULL && *cp != '\\0') {\n        if (attribute == NULL) {\n            if (is_token(*cp) > 0) {\n                cp++;\n                continue;\n            }\n            else if (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                cp++;\n                continue;\n            }\n            else if (*cp == '=') {\n                attribute = zap_sp_and_dup(p, mp, cp, NULL);\n                if (attribute == NULL || *attribute == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01603)\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                cp++;\n                cp = zap_sp(cp);\n                if (cp == NULL || *cp == '\\0') {\n                    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01604)\n                                 \"Cannot get media parameter.\");\n                    return (NULL);\n                }\n                mp = cp;\n                continue;\n            }\n            else {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01605)\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n        }\n        else {\n            if (mp == cp) {\n                if (*cp == '\"') {\n                    quoted = 1;\n                    cp++;\n                }\n                else {\n                    quoted = 0;\n                }\n            }\n            if (quoted > 0) {\n                while (quoted && *cp != '\\0') {\n                    if (is_qtext(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (is_quoted_pair(cp) > 0) {\n                        cp += 2;\n                    }\n                    else if (*cp == '\"') {\n                        cp++;\n                        while (*cp == ' ' || *cp == '\\t' || *cp == '\\n') {\n                            cp++;\n                        }\n                        if (*cp != ';' && *cp != '\\0') {\n                            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01606)\n                                         \"Cannot get media parameter.\");\n                            return(NULL);\n                        }\n                        quoted = 0;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01607)\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            else {\n                while (1) {\n                    if (is_token(*cp) > 0) {\n                        cp++;\n                    }\n                    else if (*cp == '\\0' || *cp == ';') {\n                        break;\n                    }\n                    else {\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01608)\n                                     \"Cannot get media parameter.\");\n                        return (NULL);\n                    }\n                }\n            }\n            value = zap_sp_and_dup(p, mp, cp, NULL);\n            if (value == NULL || *value == '\\0') {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01609)\n                             \"Cannot get media parameter.\");\n                return (NULL);\n            }\n\n            pp = apr_palloc(p, sizeof(param));\n            pp->attr = attribute;\n            pp->val = value;\n            pp->next = NULL;\n\n            if (ctp->param == NULL) {\n                ctp->param = pp;\n            }\n            else {\n                npp = ctp->param;\n                while (npp->next) {\n                    npp = npp->next;\n                }\n                npp->next = pp;\n            }\n            quoted = 0;\n            attribute = NULL;\n            value = NULL;\n            if (*cp == '\\0') {\n                break;\n            }\n            cp++;\n            mp = cp;\n        }\n    }\n    return (ctp);\n}"
          },
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "memcpy": {
            "declaration": "extern void *memcpy (void *__restrict __dest, const void *__restrict __src,\n\t\t     size_t __n) __THROW __nonnull ((1, 2))",
            "is_external": true,
            "definition": null
          },
          "strcmp": {
            "declaration": "extern int strcmp (const char *__s1, const char *__s2)\n     __THROW __attribute_pure__ __nonnull ((1, 2))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {
          "APR_DIR": {
            "name": "APR_DIR",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum apr_filetype_e APR_DIR = 2",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/apr_file_info.h', line 65, column 5>",
            "condition": ""
          },
          "NOMIME_ON": {
            "name": "NOMIME_ON",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:99:5) NOMIME_ON = 1",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 99, column 24>",
            "condition": ""
          },
          "CT_LAST_ON": {
            "name": "CT_LAST_ON",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:95:5) CT_LAST_ON = 1",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 95, column 25>",
            "condition": ""
          },
          "ALL_LAST_ON": {
            "name": "ALL_LAST_ON",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:97:5) ALL_LAST_ON = 1",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 97, column 26>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "mime_dir_config": {
            "name": "mime_dir_config",
            "definition": "struct {\n    apr_hash_t *extension_mappings;  /* Map from extension name to\n                                      * extension_info structure */\n\n    apr_array_header_t *remove_mappings; /* A simple list, walked once */\n\n    char *default_language;     /* Language if no AddLanguage ext found */\n\n    int multimatch;       /* Extensions to include in multiview matching\n                           * for filenames, e.g. Filters and Handlers\n                           */\n    int use_path_info;    /* If set to 0, only use filename.\n                           * If set to 1, append PATH_INFO to filename for\n                           *   lookups.\n                           * If set to 2, this value is unset and is\n                           *   effectively 0.\n                           */\n    /* Only use the final extension for Content-Type */\n    enum {CT_LAST_INIT, CT_LAST_ON, CT_LAST_OFF} ct_last_ext;\n    /* Only use the final extension for anything */\n    enum {ALL_LAST_INIT, ALL_LAST_ON, ALL_LAST_OFF} all_last_ext;\n    /* don't do any detection */\n    enum {NOMIME_INIT, NOMIME_ON, NOMIME_OFF} nomime;\n}",
            "typedef_name": null,
            "fields": {
              "extension_mappings": "apr_hash_t *",
              "remove_mappings": "apr_array_header_t *",
              "default_language": "char *",
              "multimatch": "int",
              "use_path_info": "int",
              "ct_last_ext": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:95:5)",
              "all_last_ext": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:97:5)",
              "nomime": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:99:5)"
            },
            "condition": ""
          },
          "apr_array_header_t": {
            "name": "apr_array_header_t",
            "definition": "struct apr_array_header_t {\n    /** The pool the array is allocated out of */\n    apr_pool_t *pool;\n    /** The amount of memory allocated for each element of the array */\n    int elt_size;\n    /** The number of active elements in the array */\n    int nelts;\n    /** The number of elements allocated in the array */\n    int nalloc;\n    /** The elements in the array */\n    char *elts;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "elt_size": "int",
              "nelts": "int",
              "nalloc": "int",
              "elts": "char *"
            },
            "condition": ""
          },
          "extension_info": {
            "name": "extension_info",
            "definition": "struct extension_info {\n    char *forced_type;                /* Additional AddTyped stuff */\n    char *encoding_type;              /* Added with AddEncoding... */\n    char *language_type;              /* Added with AddLanguage... */\n    char *handler;                    /* Added with AddHandler... */\n    char *charset_type;               /* Added with AddCharset... */\n    char *input_filters;              /* Added with AddInputFilter... */\n    char *output_filters;             /* Added with AddOutputFilter... */\n}",
            "typedef_name": null,
            "fields": {
              "forced_type": "char *",
              "encoding_type": "char *",
              "language_type": "char *",
              "handler": "char *",
              "charset_type": "char *",
              "input_filters": "char *",
              "output_filters": "char *"
            },
            "condition": ""
          },
          "content_type": {
            "name": "content_type",
            "definition": "struct {\n    const char *type;\n    apr_size_t type_len;\n    const char *subtype;\n    apr_size_t subtype_len;\n    param *param;\n}",
            "typedef_name": null,
            "fields": {
              "type": "const char *",
              "type_len": "apr_size_t",
              "subtype": "const char *",
              "subtype_len": "apr_size_t",
              "param": "param *"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "mime_module": {
            "name": "mime_module",
            "type": "module",
            "is_extern": false,
            "is_static": false,
            "definition": "AP_DECLARE_MODULE(mime) = {\n    STANDARD20_MODULE_STUFF,\n    create_mime_dir_config,     /* create per-directory config structure */\n    merge_mime_dir_configs,     /* merge per-directory config structures */\n    NULL,                       /* create per-server config structure */\n    NULL,                       /* merge per-server config structures */\n    mime_cmds,                  /* command apr_table_t */\n    register_hooks              /* register hooks */\n}",
            "initializer": "{\n    STANDARD20_MODULE_STUFF,\n    create_mime_dir_config,     /* create per-directory config structure */\n    merge_mime_dir_configs,     /* merge per-directory config structures */\n    NULL,                       /* create per-server config structure */\n    NULL,                       /* merge per-server config structures */\n    mime_cmds,                  /* command apr_table_t */\n    register_hooks              /* register hooks */\n}",
            "full_definition": "AP_DECLARE_MODULE(mime) = {\n    STANDARD20_MODULE_STUFF,\n    create_mime_dir_config,     /* create per-directory config structure */\n    merge_mime_dir_configs,     /* merge per-directory config structures */\n    NULL,                       /* create per-server config structure */\n    NULL,                       /* merge per-server config structures */\n    mime_cmds,                  /* command apr_table_t */\n    register_hooks              /* register hooks */\n}",
            "used_macros": {},
            "condition": ""
          },
          "mime_type_extensions": {
            "name": "mime_type_extensions",
            "type": "apr_hash_t *",
            "is_extern": false,
            "is_static": true,
            "definition": "static apr_hash_t *mime_type_extensions",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "param"
        ]
      },
      "source_code": "static int find_ct(request_rec *r)\n{\n    mime_dir_config *conf;\n    apr_array_header_t *exception_list;\n    char *ext;\n    const char *fn, *fntmp, *type, *charset = NULL, *resource_name, *qm;\n    int found_metadata = 0;\n\n    if (r->finfo.filetype == APR_DIR) {\n        ap_set_content_type_ex(r, DIR_MAGIC_TYPE, 1);\n        return OK;\n    }\n\n    if (!r->filename) {\n        return DECLINED;\n    }\n\n    conf = (mime_dir_config *)ap_get_module_config(r->per_dir_config,\n                                                   &mime_module);\n    if (conf->nomime == NOMIME_ON) {\n        return DECLINED;\n    }\n\n    exception_list = apr_array_make(r->pool, 2, sizeof(char *));\n\n    /* If use_path_info is explicitly set to on (value & 1 == 1), append. */\n    if (conf->use_path_info & 1) {\n        resource_name = apr_pstrcat(r->pool, r->filename, r->path_info, NULL);\n    }\n    /*\n     * In the reverse proxy case r->filename might contain a query string if\n     * the nocanon option was used with ProxyPass.\n     * If this is the case cut off the query string as the last parameter in\n     * this query string might end up on an extension we take care about, but\n     * we only want to match against path components not against query\n     * parameters.\n     */\n    else if ((r->proxyreq == PROXYREQ_REVERSE)\n             && (apr_table_get(r->notes, \"proxy-nocanon\"))\n             && ((qm = ap_strchr_c(r->filename, '?')) != NULL)) {\n        resource_name = apr_pstrmemdup(r->pool, r->filename, qm - r->filename);\n    }\n    else {\n        resource_name = r->filename;\n    }\n\n    /* Always drop the path leading up to the file name.\n     */\n    if ((fn = ap_strrchr_c(resource_name, '/')) == NULL) {\n        fn = resource_name;\n    }\n    else {\n        ++fn;\n    }\n\n\n    /* The exception list keeps track of those filename components that\n     * are not associated with extensions indicating metadata.\n     * The base name is always the first exception (i.e., \"txt.html\" has\n     * a basename of \"txt\" even though it might look like an extension).\n     * Leading dots are considered to be part of the base name (a file named\n     * \".png\" is likely not a png file but just a hidden file called png).\n     */\n    fntmp = fn;\n    while (*fntmp == '.')\n        fntmp++;\n    fntmp = ap_strchr_c(fntmp, '.');\n    if (fntmp) {\n        ext = apr_pstrmemdup(r->pool, fn, fntmp - fn);\n        fn = fntmp + 1;\n    }\n    else {\n        ext = apr_pstrdup(r->pool, fn);\n        fn += strlen(fn);\n    }\n\n    *((const char **)apr_array_push(exception_list)) = ext;\n\n    /* Parse filename extensions which can be in any order\n     */\n    while (*fn && (ext = ap_getword(r->pool, &fn, '.'))) {\n        const extension_info *exinfo = NULL;\n        int found;\n        char *extcase;\n        int skipct = (conf->ct_last_ext == CT_LAST_ON) && (*fn);\n        int skipall = (conf->all_last_ext == ALL_LAST_ON) && (*fn);\n\n        if (*ext == '\\0') {  /* ignore empty extensions \"bad..html\" */\n            continue;\n        }\n\n        if (skipall) { \n            continue; \n        }\n\n        found = 0;\n\n        /* Save the ext in extcase before converting it to lower case.\n         */\n        extcase = apr_pstrdup(r->pool, ext);\n        ap_str_tolower(ext);\n\n        if (conf->extension_mappings != NULL) {\n            exinfo = (extension_info*)apr_hash_get(conf->extension_mappings,\n                                                   ext, APR_HASH_KEY_STRING);\n        }\n\n        if ((exinfo == NULL || !exinfo->forced_type) && !skipct) {\n            if ((type = apr_hash_get(mime_type_extensions, ext,\n                                     APR_HASH_KEY_STRING)) != NULL) {\n                ap_set_content_type_ex(r, (char*) type, 1);\n                found = 1;\n            }\n        }\n\n        if (exinfo != NULL) {\n\n            /* empty string is treated as special case for RemoveType */\n            if ((exinfo->forced_type && *exinfo->forced_type) && !skipct) {\n                ap_set_content_type_ex(r, exinfo->forced_type, 1);\n                found = 1;\n            }\n\n            if (exinfo->charset_type) {\n                charset = exinfo->charset_type;\n                found = 1;\n            }\n            if (exinfo->language_type) {\n                if (!r->content_languages) {\n                    r->content_languages = apr_array_make(r->pool, 2,\n                                                          sizeof(char *));\n                }\n                *((const char **)apr_array_push(r->content_languages))\n                    = exinfo->language_type;\n                found = 1;\n            }\n            if (exinfo->encoding_type) {\n                if (!r->content_encoding) {\n                    r->content_encoding = exinfo->encoding_type;\n                }\n                else {\n                    /* XXX should eliminate duplicate entities\n                     *\n                     * ah no. Order is important and double encoding is neither\n                     * forbidden nor impossible. -- nd\n                     */\n                    r->content_encoding = apr_pstrcat(r->pool,\n                                                      r->content_encoding,\n                                                      \", \",\n                                                      exinfo->encoding_type,\n                                                      NULL);\n                }\n                found = 1;\n            }\n            /* The following extensions are not 'Found'.  That is, they don't\n             * make any contribution to metadata negotiation, so they must have\n             * been explicitly requested by name.\n             */\n            if (exinfo->handler && r->proxyreq == PROXYREQ_NONE) {\n                r->handler = exinfo->handler;\n                if (conf->multimatch & MULTIMATCH_HANDLERS) {\n                    found = 1;\n                }\n            }\n            /* XXX Two significant problems; 1, we don't check to see if we are\n             * setting redundant filters.    2, we insert these in the types\n             * config hook, which may be too early (dunno.)\n             */\n            if (exinfo->input_filters) {\n                const char *filter, *filters = exinfo->input_filters;\n                while (*filters\n                    && (filter = ap_getword(r->pool, &filters, ';'))) {\n                    ap_add_input_filter(filter, NULL, r, r->connection);\n                }\n                if (conf->multimatch & MULTIMATCH_FILTERS) {\n                    found = 1;\n                }\n            }\n            if (exinfo->output_filters) {\n                const char *filter, *filters = exinfo->output_filters;\n                while (*filters\n                    && (filter = ap_getword(r->pool, &filters, ';'))) {\n                    ap_add_output_filter(filter, NULL, r, r->connection);\n                }\n                if (conf->multimatch & MULTIMATCH_FILTERS) {\n                    found = 1;\n                }\n            }\n        }\n\n        if (found || (conf->multimatch & MULTIMATCH_ANY)) {\n            found_metadata = 1;\n        }\n        else {\n            *((const char **) apr_array_push(exception_list)) = extcase;\n        }\n    }\n\n    /*\n     * Need to set a notes entry on r for unrecognized elements.\n     * Somebody better claim them!  If we did absolutely nothing,\n     * skip the notes to alert mod_negotiation we are clueless.\n     */\n    if (found_metadata) {\n        apr_table_setn(r->notes, \"ap-mime-exceptions-list\",\n                       (void *)exception_list);\n    }\n\n    if (r->content_type) {\n        content_type *ctp;\n        int override = 0;\n\n        if ((ctp = analyze_ct(r, r->content_type))) {\n            param *pp = ctp->param;\n            char *base_content_type = apr_palloc(r->pool, ctp->type_len +\n                                                 ctp->subtype_len +\n                                                 sizeof(\"/\"));\n            char *tmp = base_content_type;\n            memcpy(tmp, ctp->type, ctp->type_len);\n            tmp += ctp->type_len;\n            *tmp++ = '/';\n            memcpy(tmp, ctp->subtype, ctp->subtype_len);\n            tmp += ctp->subtype_len;\n            *tmp = 0;\n            ap_set_content_type_ex(r, base_content_type, AP_REQUEST_IS_TRUSTED_CT(r));\n            while (pp != NULL) {\n                if (charset && !strcmp(pp->attr, \"charset\")) {\n                    if (!override) {\n                        ap_set_content_type_ex(r,\n                                            apr_pstrcat(r->pool,\n                                                        r->content_type,\n                                                        \"; charset=\",\n                                                        charset,\n                                                        NULL), AP_REQUEST_IS_TRUSTED_CT(r));\n                        override = 1;\n                    }\n                }\n                else {\n                    ap_set_content_type_ex(r,\n                                        apr_pstrcat(r->pool,\n                                                    r->content_type,\n                                                    \"; \", pp->attr,\n                                                    \"=\", pp->val,\n                                                    NULL), AP_REQUEST_IS_TRUSTED_CT(r));\n                }\n                pp = pp->next;\n            }\n            if (charset && !override) {\n                ap_set_content_type_ex(r, apr_pstrcat(r->pool, r->content_type,\n                                                   \"; charset=\", charset,\n                                                   NULL), AP_REQUEST_IS_TRUSTED_CT(r));\n            }\n        }\n    }\n\n    /* Set default language, if none was specified by the extensions\n     * and we have a DefaultLanguage setting in force\n     */\n\n    if (!r->content_languages && conf->default_language) {\n        const char **new;\n\n        r->content_languages = apr_array_make(r->pool, 2, sizeof(char *));\n        new = (const char **)apr_array_push(r->content_languages);\n        *new = conf->default_language;\n    }\n\n    if (!r->content_type) {\n        return DECLINED;\n    }\n\n    return OK;\n}"
    },
    "register_hooks@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 1085, column 13>": {
      "basic_info": {
        "function_id": 1443,
        "name": "register_hooks",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c', line 1085, column 13>",
        "is_definition": true,
        "start_line": 1085,
        "end_line": 1095,
        "return_type": "void",
        "parameters": [
          {
            "name": "p",
            "type": "apr_pool_t *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_hook_post_config": {
            "declaration": "AP_DECLARE_HOOK(int,post_config,(apr_pool_t *pconf,apr_pool_t *plog,\n                                 apr_pool_t *ptemp,server_rec *s))",
            "is_external": true,
            "definition": null
          },
          "ap_hook_type_checker": {
            "declaration": "AP_DECLARE_HOOK(int,type_checker,(request_rec *r))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static void register_hooks(apr_pool_t *p)\n{\n    ap_hook_post_config(mime_post_config,NULL,NULL,APR_HOOK_MIDDLE);\n    ap_hook_type_checker(find_ct,NULL,NULL,APR_HOOK_MIDDLE);\n    /*\n     * this hook seems redundant ... is there any reason a type checker isn't\n     * allowed to do this already?  I'd think that fixups in general would be\n     * the last opportunity to get the filters right.\n     * ap_hook_insert_filter(mime_insert_filters,NULL,NULL,APR_HOOK_MIDDLE);\n     */\n}"
    },
    "parse_chunk_size@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 99, column 21>": {
      "basic_info": {
        "function_id": 1468,
        "name": "parse_chunk_size",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 99, column 21>",
        "is_definition": true,
        "start_line": 99,
        "end_line": 258,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "ctx",
            "type": "http_ctx_t *"
          },
          {
            "name": "buffer",
            "type": "const char *"
          },
          {
            "name": "len",
            "type": "apr_size_t"
          },
          {
            "name": "linelimit",
            "type": "int"
          },
          {
            "name": "strict",
            "type": "int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "__ctype_b_loc": {
            "declaration": "extern const unsigned short int **__ctype_b_loc (void)\n     __THROW __attribute__ ((__const__))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_h1_body_in_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 429, column 14>": {
            "source_code": "apr_status_t ap_h1_body_in_filter(ap_filter_t *f, apr_bucket_brigade *b,\n                                     ap_input_mode_t mode, apr_read_type_e block,\n                                     apr_off_t readbytes)\n{\n    core_server_config *conf =\n        (core_server_config *) ap_get_module_config(f->r->server->module_config,\n                                                    &core_module);\n    int strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n    apr_bucket *e;\n    http_ctx_t *ctx = f->ctx;\n    apr_status_t rv;\n    int again;\n\n    /* just get out of the way of things we don't want. */\n    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {\n        return ap_get_brigade(f->next, b, mode, block, readbytes);\n    }\n\n    if (!ctx) {\n        const char *tenc, *lenp;\n        f->ctx = ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));\n        ctx->state = BODY_NONE;\n\n        /* LimitRequestBody does not apply to proxied responses.\n         * Consider implementing this check in its own filter.\n         * Would adding a directive to limit the size of proxied\n         * responses be useful?\n         */\n        if (f->r->proxyreq != PROXYREQ_RESPONSE) {\n            ctx->limit = ap_get_limit_req_body(f->r);\n        }\n        else {\n            ctx->limit = 0;\n        }\n\n        tenc = apr_table_get(f->r->headers_in, \"Transfer-Encoding\");\n        lenp = apr_table_get(f->r->headers_in, \"Content-Length\");\n\n        if (tenc) {\n            if (ap_is_chunked(f->r->pool, tenc)) {\n                ctx->state = BODY_CHUNK;\n            }\n            else if (f->r->proxyreq == PROXYREQ_RESPONSE) {\n                /* http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-23\n                 * Section 3.3.3.3: \"If a Transfer-Encoding header field is\n                 * present in a response and the chunked transfer coding is not\n                 * the final encoding, the message body length is determined by\n                 * reading the connection until it is closed by the server.\"\n                 */\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02555)\n                              \"Unknown Transfer-Encoding: %s; \"\n                              \"using read-until-close\", tenc);\n                tenc = NULL;\n            }\n            else {\n                /* Something that isn't a HTTP request, unless some future\n                 * edition defines new transfer encodings, is unsupported.\n                 */\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)\n                              \"Unknown Transfer-Encoding: %s\", tenc);\n                ap_die(HTTP_NOT_IMPLEMENTED, f->r);\n                return APR_EGENERAL;\n            }\n            lenp = NULL;\n        }\n        if (lenp) {\n            ctx->state = BODY_LENGTH;\n\n            /* Protects against over/underflow, non-digit chars in the\n             * string, leading plus/minus signs, trailing characters and\n             * a negative number.\n             */\n            if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n                ctx->remaining = 0;\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)\n                              \"Invalid Content-Length\");\n\n                return APR_EINVAL;\n            }\n\n            /* If we have a limit in effect and we know the C-L ahead of\n             * time, stop it here if it is invalid.\n             */\n            if (ctx->limit && ctx->limit < ctx->remaining) {\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01588)\n                          \"Requested content-length of %\" APR_OFF_T_FMT\n                          \" is larger than the configured limit\"\n                          \" of %\" APR_OFF_T_FMT, ctx->remaining, ctx->limit);\n                return APR_ENOSPC;\n            }\n        }\n\n        /* If we don't have a request entity indicated by the headers, EOS.\n         * (BODY_NONE is a valid intermediate state due to trailers,\n         *  but it isn't a valid starting state.)\n         *\n         * RFC 2616 Section 4.4 note 5 states that connection-close\n         * is invalid for a request entity - request bodies must be\n         * denoted by C-L or T-E: chunked.\n         *\n         * Note that since the proxy uses this filter to handle the\n         * proxied *response*, proxy responses MUST be exempt.\n         */\n        if (ctx->state == BODY_NONE && f->r->proxyreq != PROXYREQ_RESPONSE) {\n            ctx->at_eos = 1; /* send EOS below */\n        }\n    }\n\n    /* sanity check in case we're read twice */\n    if (ctx->at_eos) {\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n        return APR_SUCCESS;\n    }\n\n    do {\n        apr_brigade_cleanup(b);\n        again = 0; /* until further notice */\n\n        /* read and handle the brigade */\n        switch (ctx->state) {\n        case BODY_CHUNK:\n        case BODY_CHUNK_PART:\n        case BODY_CHUNK_EXT:\n        case BODY_CHUNK_CR:\n        case BODY_CHUNK_LF:\n        case BODY_CHUNK_END:\n        case BODY_CHUNK_END_LF: {\n\n            rv = ap_get_brigade(f->next, b, AP_MODE_GETLINE, block, 0);\n\n            /* for timeout */\n            if (block == APR_NONBLOCK_READ\n                    && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n                            || (APR_STATUS_IS_EAGAIN(rv)))) {\n                return APR_EAGAIN;\n            }\n\n            if (rv == APR_EOF) {\n                return APR_INCOMPLETE;\n            }\n\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n\n            e = APR_BRIGADE_FIRST(b);\n            while (e != APR_BRIGADE_SENTINEL(b)) {\n                const char *buffer;\n                apr_size_t len;\n\n                if (!APR_BUCKET_IS_METADATA(e)) {\n                    rv = apr_bucket_read(e, &buffer, &len, APR_BLOCK_READ);\n                    if (rv == APR_SUCCESS) {\n                        if (len > 0) {\n                            ctx->seen_data = 1;\n                        }\n                        rv = parse_chunk_size(ctx, buffer, len,\n                                f->r->server->limit_req_fieldsize, strict);\n                    }\n                    if (rv != APR_SUCCESS) {\n                        ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, f->r, APLOGNO(01590)\n                                      \"Error reading/parsing chunk %s \",\n                                      (APR_ENOSPC == rv) ? \"(overflow)\" : \"\");\n                        return rv;\n                    }\n                }\n\n                apr_bucket_delete(e);\n                e = APR_BRIGADE_FIRST(b);\n            }\n            again = 1; /* come around again */\n\n            if (ctx->state == BODY_CHUNK_TRAILER) {\n                /* Treat UNSET as DISABLE - trailers aren't merged by default */\n                return read_chunked_trailers(ctx, f, b);\n            }\n\n            break;\n        }\n        case BODY_NONE:\n        case BODY_LENGTH:\n        case BODY_CHUNK_DATA: {\n\n            /* Ensure that the caller can not go over our boundary point. */\n            if (ctx->state != BODY_NONE && ctx->remaining < readbytes) {\n                readbytes = ctx->remaining;\n            }\n            if (readbytes > 0) {\n                apr_off_t totalread;\n\n                rv = ap_get_brigade(f->next, b, mode, block, readbytes);\n\n                /* for timeout */\n                if (block == APR_NONBLOCK_READ\n                        && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n                                || (APR_STATUS_IS_EAGAIN(rv)))) {\n                    return APR_EAGAIN;\n                }\n\n                if (rv == APR_EOF && ctx->state != BODY_NONE\n                        && ctx->remaining > 0) {\n                    return APR_INCOMPLETE;\n                }\n\n                if (rv != APR_SUCCESS) {\n                    return rv;\n                }\n\n                /* How many bytes did we just read? */\n                apr_brigade_length(b, 0, &totalread);\n                if (totalread > 0) {\n                    ctx->seen_data = 1;\n                }\n\n                /* If this happens, we have a bucket of unknown length.  Die because\n                 * it means our assumptions have changed. */\n                AP_DEBUG_ASSERT(totalread >= 0);\n\n                if (ctx->state != BODY_NONE) {\n                    ctx->remaining -= totalread;\n                    if (ctx->remaining > 0) {\n                        e = APR_BRIGADE_LAST(b);\n                        if (APR_BUCKET_IS_EOS(e)) {\n                            apr_bucket_delete(e);\n                            return APR_INCOMPLETE;\n                        }\n                    }\n                    else if (ctx->state == BODY_CHUNK_DATA) {\n                        /* next chunk please */\n                        ctx->state = BODY_CHUNK_END;\n                        ctx->chunk_used = 0;\n                    }\n                }\n\n                /* We have a limit in effect. */\n                if (ctx->limit) {\n                    /* FIXME: Note that we might get slightly confused on\n                     * chunked inputs as we'd need to compensate for the chunk\n                     * lengths which may not really count.  This seems to be up\n                     * for interpretation.\n                     */\n                    ctx->limit_used += totalread;\n                    if (ctx->limit < ctx->limit_used) {\n                        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r,\n                                      APLOGNO(01591) \"Read content length of \"\n                                      \"%\" APR_OFF_T_FMT \" is larger than the \"\n                                      \"configured limit of %\" APR_OFF_T_FMT,\n                                      ctx->limit_used, ctx->limit);\n                        return APR_ENOSPC;\n                    }\n                }\n            }\n\n            /* If we have no more bytes remaining on a C-L request,\n             * save the caller a round trip to discover EOS.\n             */\n            if (ctx->state == BODY_LENGTH && ctx->remaining == 0) {\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(b, e);\n                ctx->at_eos = 1;\n            }\n\n            break;\n        }\n        case BODY_CHUNK_TRAILER: {\n\n            rv = ap_get_brigade(f->next, b, mode, block, readbytes);\n\n            /* for timeout */\n            if (block == APR_NONBLOCK_READ\n                    && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n                            || (APR_STATUS_IS_EAGAIN(rv)))) {\n                return APR_EAGAIN;\n            }\n\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n\n            break;\n        }\n        default: {\n            /* Should not happen */\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02901)\n                          \"Unexpected body state (%i)\", (int)ctx->state);\n            return APR_EGENERAL;\n        }\n        }\n\n    } while (again);\n\n    return APR_SUCCESS;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 429, column 14>"
          }
        },
        "used_macros": {
          "BODY_CHUNK_END": {
            "name": "BODY_CHUNK_END",
            "value": "8",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK_END = 8",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 82, column 9>",
            "condition": ""
          },
          "BODY_CHUNK_END_LF": {
            "name": "BODY_CHUNK_END_LF",
            "value": "9",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK_END_LF = 9",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 83, column 9>",
            "condition": ""
          },
          "BODY_CHUNK": {
            "name": "BODY_CHUNK",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK = 2",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 76, column 9>",
            "condition": ""
          },
          "_ISalnum": {
            "name": "_ISalnum",
            "value": "8",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISalnum = 8",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 59, column 3>",
            "condition": ""
          },
          "_ISalpha": {
            "name": "_ISalpha",
            "value": "1024",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISalpha = 1024",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 50, column 3>",
            "condition": ""
          },
          "_IScntrl": {
            "name": "_IScntrl",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _IScntrl = 2",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 57, column 3>",
            "condition": ""
          },
          "_ISdigit": {
            "name": "_ISdigit",
            "value": "2048",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISdigit = 2048",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 51, column 3>",
            "condition": ""
          },
          "_ISlower": {
            "name": "_ISlower",
            "value": "512",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISlower = 512",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 49, column 3>",
            "condition": ""
          },
          "_ISgraph": {
            "name": "_ISgraph",
            "value": "32768",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISgraph = 32768",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 55, column 3>",
            "condition": ""
          },
          "_ISprint": {
            "name": "_ISprint",
            "value": "16384",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISprint = 16384",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 54, column 3>",
            "condition": ""
          },
          "_ISpunct": {
            "name": "_ISpunct",
            "value": "4",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISpunct = 4",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 58, column 3>",
            "condition": ""
          },
          "_ISspace": {
            "name": "_ISspace",
            "value": "8192",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISspace = 8192",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 53, column 3>",
            "condition": ""
          },
          "_ISupper": {
            "name": "_ISupper",
            "value": "256",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISupper = 256",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 48, column 3>",
            "condition": ""
          },
          "_ISxdigit": {
            "name": "_ISxdigit",
            "value": "4096",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISxdigit = 4096",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 52, column 3>",
            "condition": ""
          },
          "BODY_CHUNK_PART": {
            "name": "BODY_CHUNK_PART",
            "value": "3",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK_PART = 3",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 77, column 9>",
            "condition": ""
          },
          "BODY_CHUNK_LF": {
            "name": "BODY_CHUNK_LF",
            "value": "6",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK_LF = 6",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 80, column 9>",
            "condition": ""
          },
          "BODY_CHUNK_DATA": {
            "name": "BODY_CHUNK_DATA",
            "value": "7",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK_DATA = 7",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 81, column 9>",
            "condition": ""
          },
          "BODY_CHUNK_TRAILER": {
            "name": "BODY_CHUNK_TRAILER",
            "value": "10",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK_TRAILER = 10",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 84, column 9>",
            "condition": ""
          },
          "BODY_CHUNK_EXT": {
            "name": "BODY_CHUNK_EXT",
            "value": "4",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK_EXT = 4",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 78, column 9>",
            "condition": ""
          },
          "BODY_CHUNK_CR": {
            "name": "BODY_CHUNK_CR",
            "value": "5",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK_CR = 5",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 79, column 9>",
            "condition": ""
          }
        },
        "used_structs": {},
        "used_globals": {},
        "used_typedefs": [
          "http_ctx_t",
          "apr_off_t",
          "apr_size_t",
          "apr_status_t"
        ]
      },
      "source_code": "static apr_status_t parse_chunk_size(http_ctx_t *ctx, const char *buffer,\n                                     apr_size_t len, int linelimit, int strict)\n{\n    apr_size_t i = 0;\n\n    while (i < len) {\n        char c = buffer[i];\n\n        ap_xlate_proto_from_ascii(&c, 1);\n\n        /* handle CRLF after the chunk */\n        if (ctx->state == BODY_CHUNK_END\n                || ctx->state == BODY_CHUNK_END_LF) {\n            if (c == LF) {\n                if (strict && (ctx->state != BODY_CHUNK_END_LF)) {\n                    /*\n                     * CR missing before LF.\n                     */\n                    return APR_EINVAL;\n                }\n                ctx->state = BODY_CHUNK;\n            }\n            else if (c == CR && ctx->state == BODY_CHUNK_END) {\n                ctx->state = BODY_CHUNK_END_LF;\n            }\n            else {\n                /*\n                 * CRLF expected.\n                 */\n                return APR_EINVAL;\n            }\n            i++;\n            continue;\n        }\n\n        /* handle start of the chunk */\n        if (ctx->state == BODY_CHUNK) {\n            if (!apr_isxdigit(c)) {\n                /*\n                 * Detect invalid character at beginning. This also works for\n                 * empty chunk size lines.\n                 */\n                return APR_EINVAL;\n            }\n            else {\n                ctx->state = BODY_CHUNK_PART;\n            }\n            ctx->remaining = 0;\n            /* The maximum number of bits that can be handled in a\n             * chunk size is in theory sizeof(apr_off_t)*8-1 since\n             * off_t is signed, but use -4 to avoid undefined\n             * behaviour when bitshifting left. */\n            ctx->chunkbits = sizeof(apr_off_t) * 8 - 4;\n            ctx->chunk_used = 0;\n            ctx->chunk_bws = 0;\n        }\n\n        if (c == LF) {\n            if (strict && (ctx->state != BODY_CHUNK_LF)) {\n                /*\n                 * CR missing before LF.\n                 */\n                return APR_EINVAL;\n            }\n            if (ctx->remaining) {\n                ctx->state = BODY_CHUNK_DATA;\n            }\n            else {\n                ctx->state = BODY_CHUNK_TRAILER;\n            }\n        }\n        else if (ctx->state == BODY_CHUNK_LF) {\n            /*\n             * LF expected.\n             */\n            return APR_EINVAL;\n        }\n        else if (c == CR) {\n            ctx->state = BODY_CHUNK_LF;\n        }\n        else if (c == ';') {\n            ctx->state = BODY_CHUNK_EXT;\n        }\n        else if (ctx->state == BODY_CHUNK_EXT) {\n            /*\n             * Control chars (excluding tabs) are invalid.\n             * TODO: more precisely limit input\n             */\n            if (c != '\\t' && apr_iscntrl(c)) {\n                return APR_EINVAL;\n            }\n        }\n        else if (c == ' ' || c == '\\t') {\n            /* Be lenient up to 10 implied *LWS, a legacy of RFC 2616,\n             * and noted as errata to RFC7230;\n             * https://www.rfc-editor.org/errata_search.php?rfc=7230&eid=4667\n             */\n            ctx->state = BODY_CHUNK_CR;\n            if (++ctx->chunk_bws > 10) {\n                return APR_EINVAL;\n            }\n        }\n        else if (ctx->state == BODY_CHUNK_CR) {\n            /*\n             * ';', CR or LF expected.\n             */\n            return APR_EINVAL;\n        }\n        else if (ctx->state == BODY_CHUNK_PART) {\n            int xvalue;\n\n            /* ignore leading zeros */\n            if (!ctx->remaining && c == '0') {\n                i++;\n                continue;\n            }\n\n            ctx->chunkbits -= 4;\n            if (ctx->chunkbits < 0) {\n                /* overflow */\n                return APR_ENOSPC;\n            }\n\n            if (c >= '0' && c <= '9') {\n                xvalue = c - '0';\n            }\n            else if (c >= 'A' && c <= 'F') {\n                xvalue = c - 'A' + 0xa;\n            }\n            else if (c >= 'a' && c <= 'f') {\n                xvalue = c - 'a' + 0xa;\n            }\n            else {\n                /* bogus character */\n                return APR_EINVAL;\n            }\n\n            ctx->remaining = (ctx->remaining << 4) | xvalue;\n            if (ctx->remaining < 0) {\n                /* Overflow - should be unreachable since the\n                 * chunkbits limit will be reached first. */\n                return APR_ENOSPC;\n            }\n        }\n        else {\n            /* Should not happen */\n            return APR_EGENERAL;\n        }\n\n        i++;\n    }\n\n    /* sanity check */\n    ctx->chunk_used += len;\n    if (ctx->chunk_used < 0 || ctx->chunk_used > linelimit) {\n        return APR_ENOSPC;\n    }\n\n    return APR_SUCCESS;\n}"
    },
    "read_chunked_trailers@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 260, column 21>": {
      "basic_info": {
        "function_id": 1469,
        "name": "read_chunked_trailers",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 260, column 21>",
        "is_definition": true,
        "start_line": 260,
        "end_line": 299,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "ctx",
            "type": "http_ctx_t *"
          },
          {
            "name": "f",
            "type": "ap_filter_t *"
          },
          {
            "name": "b",
            "type": "apr_bucket_brigade *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_table_make": {
            "declaration": "APR_DECLARE(apr_table_t *) apr_table_make(apr_pool_t *p, int nelts)",
            "is_external": true,
            "definition": null
          },
          "ap_get_mime_headers": {
            "declaration": "AP_DECLARE(void) ap_get_mime_headers(request_rec *r)",
            "is_external": true,
            "definition": null
          },
          "apr_is_empty_table": {
            "declaration": "APR_DECLARE(int) apr_is_empty_table(const apr_table_t *t)",
            "is_external": true,
            "definition": null
          },
          "ap_bucket_headers_create": {
            "declaration": "ap_bucket_headers_create(trailers, r->pool, b->bucket_alloc)",
            "is_external": true,
            "definition": null
          },
          "apr_bucket_eos_create": {
            "declaration": "APU_DECLARE(apr_bucket *) apr_bucket_eos_create(apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_h1_body_in_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 429, column 14>": {
            "source_code": "apr_status_t ap_h1_body_in_filter(ap_filter_t *f, apr_bucket_brigade *b,\n                                     ap_input_mode_t mode, apr_read_type_e block,\n                                     apr_off_t readbytes)\n{\n    core_server_config *conf =\n        (core_server_config *) ap_get_module_config(f->r->server->module_config,\n                                                    &core_module);\n    int strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n    apr_bucket *e;\n    http_ctx_t *ctx = f->ctx;\n    apr_status_t rv;\n    int again;\n\n    /* just get out of the way of things we don't want. */\n    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {\n        return ap_get_brigade(f->next, b, mode, block, readbytes);\n    }\n\n    if (!ctx) {\n        const char *tenc, *lenp;\n        f->ctx = ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));\n        ctx->state = BODY_NONE;\n\n        /* LimitRequestBody does not apply to proxied responses.\n         * Consider implementing this check in its own filter.\n         * Would adding a directive to limit the size of proxied\n         * responses be useful?\n         */\n        if (f->r->proxyreq != PROXYREQ_RESPONSE) {\n            ctx->limit = ap_get_limit_req_body(f->r);\n        }\n        else {\n            ctx->limit = 0;\n        }\n\n        tenc = apr_table_get(f->r->headers_in, \"Transfer-Encoding\");\n        lenp = apr_table_get(f->r->headers_in, \"Content-Length\");\n\n        if (tenc) {\n            if (ap_is_chunked(f->r->pool, tenc)) {\n                ctx->state = BODY_CHUNK;\n            }\n            else if (f->r->proxyreq == PROXYREQ_RESPONSE) {\n                /* http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-23\n                 * Section 3.3.3.3: \"If a Transfer-Encoding header field is\n                 * present in a response and the chunked transfer coding is not\n                 * the final encoding, the message body length is determined by\n                 * reading the connection until it is closed by the server.\"\n                 */\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02555)\n                              \"Unknown Transfer-Encoding: %s; \"\n                              \"using read-until-close\", tenc);\n                tenc = NULL;\n            }\n            else {\n                /* Something that isn't a HTTP request, unless some future\n                 * edition defines new transfer encodings, is unsupported.\n                 */\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)\n                              \"Unknown Transfer-Encoding: %s\", tenc);\n                ap_die(HTTP_NOT_IMPLEMENTED, f->r);\n                return APR_EGENERAL;\n            }\n            lenp = NULL;\n        }\n        if (lenp) {\n            ctx->state = BODY_LENGTH;\n\n            /* Protects against over/underflow, non-digit chars in the\n             * string, leading plus/minus signs, trailing characters and\n             * a negative number.\n             */\n            if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n                ctx->remaining = 0;\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)\n                              \"Invalid Content-Length\");\n\n                return APR_EINVAL;\n            }\n\n            /* If we have a limit in effect and we know the C-L ahead of\n             * time, stop it here if it is invalid.\n             */\n            if (ctx->limit && ctx->limit < ctx->remaining) {\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01588)\n                          \"Requested content-length of %\" APR_OFF_T_FMT\n                          \" is larger than the configured limit\"\n                          \" of %\" APR_OFF_T_FMT, ctx->remaining, ctx->limit);\n                return APR_ENOSPC;\n            }\n        }\n\n        /* If we don't have a request entity indicated by the headers, EOS.\n         * (BODY_NONE is a valid intermediate state due to trailers,\n         *  but it isn't a valid starting state.)\n         *\n         * RFC 2616 Section 4.4 note 5 states that connection-close\n         * is invalid for a request entity - request bodies must be\n         * denoted by C-L or T-E: chunked.\n         *\n         * Note that since the proxy uses this filter to handle the\n         * proxied *response*, proxy responses MUST be exempt.\n         */\n        if (ctx->state == BODY_NONE && f->r->proxyreq != PROXYREQ_RESPONSE) {\n            ctx->at_eos = 1; /* send EOS below */\n        }\n    }\n\n    /* sanity check in case we're read twice */\n    if (ctx->at_eos) {\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n        return APR_SUCCESS;\n    }\n\n    do {\n        apr_brigade_cleanup(b);\n        again = 0; /* until further notice */\n\n        /* read and handle the brigade */\n        switch (ctx->state) {\n        case BODY_CHUNK:\n        case BODY_CHUNK_PART:\n        case BODY_CHUNK_EXT:\n        case BODY_CHUNK_CR:\n        case BODY_CHUNK_LF:\n        case BODY_CHUNK_END:\n        case BODY_CHUNK_END_LF: {\n\n            rv = ap_get_brigade(f->next, b, AP_MODE_GETLINE, block, 0);\n\n            /* for timeout */\n            if (block == APR_NONBLOCK_READ\n                    && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n                            || (APR_STATUS_IS_EAGAIN(rv)))) {\n                return APR_EAGAIN;\n            }\n\n            if (rv == APR_EOF) {\n                return APR_INCOMPLETE;\n            }\n\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n\n            e = APR_BRIGADE_FIRST(b);\n            while (e != APR_BRIGADE_SENTINEL(b)) {\n                const char *buffer;\n                apr_size_t len;\n\n                if (!APR_BUCKET_IS_METADATA(e)) {\n                    rv = apr_bucket_read(e, &buffer, &len, APR_BLOCK_READ);\n                    if (rv == APR_SUCCESS) {\n                        if (len > 0) {\n                            ctx->seen_data = 1;\n                        }\n                        rv = parse_chunk_size(ctx, buffer, len,\n                                f->r->server->limit_req_fieldsize, strict);\n                    }\n                    if (rv != APR_SUCCESS) {\n                        ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, f->r, APLOGNO(01590)\n                                      \"Error reading/parsing chunk %s \",\n                                      (APR_ENOSPC == rv) ? \"(overflow)\" : \"\");\n                        return rv;\n                    }\n                }\n\n                apr_bucket_delete(e);\n                e = APR_BRIGADE_FIRST(b);\n            }\n            again = 1; /* come around again */\n\n            if (ctx->state == BODY_CHUNK_TRAILER) {\n                /* Treat UNSET as DISABLE - trailers aren't merged by default */\n                return read_chunked_trailers(ctx, f, b);\n            }\n\n            break;\n        }\n        case BODY_NONE:\n        case BODY_LENGTH:\n        case BODY_CHUNK_DATA: {\n\n            /* Ensure that the caller can not go over our boundary point. */\n            if (ctx->state != BODY_NONE && ctx->remaining < readbytes) {\n                readbytes = ctx->remaining;\n            }\n            if (readbytes > 0) {\n                apr_off_t totalread;\n\n                rv = ap_get_brigade(f->next, b, mode, block, readbytes);\n\n                /* for timeout */\n                if (block == APR_NONBLOCK_READ\n                        && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n                                || (APR_STATUS_IS_EAGAIN(rv)))) {\n                    return APR_EAGAIN;\n                }\n\n                if (rv == APR_EOF && ctx->state != BODY_NONE\n                        && ctx->remaining > 0) {\n                    return APR_INCOMPLETE;\n                }\n\n                if (rv != APR_SUCCESS) {\n                    return rv;\n                }\n\n                /* How many bytes did we just read? */\n                apr_brigade_length(b, 0, &totalread);\n                if (totalread > 0) {\n                    ctx->seen_data = 1;\n                }\n\n                /* If this happens, we have a bucket of unknown length.  Die because\n                 * it means our assumptions have changed. */\n                AP_DEBUG_ASSERT(totalread >= 0);\n\n                if (ctx->state != BODY_NONE) {\n                    ctx->remaining -= totalread;\n                    if (ctx->remaining > 0) {\n                        e = APR_BRIGADE_LAST(b);\n                        if (APR_BUCKET_IS_EOS(e)) {\n                            apr_bucket_delete(e);\n                            return APR_INCOMPLETE;\n                        }\n                    }\n                    else if (ctx->state == BODY_CHUNK_DATA) {\n                        /* next chunk please */\n                        ctx->state = BODY_CHUNK_END;\n                        ctx->chunk_used = 0;\n                    }\n                }\n\n                /* We have a limit in effect. */\n                if (ctx->limit) {\n                    /* FIXME: Note that we might get slightly confused on\n                     * chunked inputs as we'd need to compensate for the chunk\n                     * lengths which may not really count.  This seems to be up\n                     * for interpretation.\n                     */\n                    ctx->limit_used += totalread;\n                    if (ctx->limit < ctx->limit_used) {\n                        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r,\n                                      APLOGNO(01591) \"Read content length of \"\n                                      \"%\" APR_OFF_T_FMT \" is larger than the \"\n                                      \"configured limit of %\" APR_OFF_T_FMT,\n                                      ctx->limit_used, ctx->limit);\n                        return APR_ENOSPC;\n                    }\n                }\n            }\n\n            /* If we have no more bytes remaining on a C-L request,\n             * save the caller a round trip to discover EOS.\n             */\n            if (ctx->state == BODY_LENGTH && ctx->remaining == 0) {\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(b, e);\n                ctx->at_eos = 1;\n            }\n\n            break;\n        }\n        case BODY_CHUNK_TRAILER: {\n\n            rv = ap_get_brigade(f->next, b, mode, block, readbytes);\n\n            /* for timeout */\n            if (block == APR_NONBLOCK_READ\n                    && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n                            || (APR_STATUS_IS_EAGAIN(rv)))) {\n                return APR_EAGAIN;\n            }\n\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n\n            break;\n        }\n        default: {\n            /* Should not happen */\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02901)\n                          \"Unexpected body state (%i)\", (int)ctx->state);\n            return APR_EGENERAL;\n        }\n        }\n\n    } while (again);\n\n    return APR_SUCCESS;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 429, column 14>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "ap_filter_t": {
            "name": "ap_filter_t",
            "definition": "struct ap_filter_t {\n    /** The internal representation of this filter.  This includes\n     *  the filter's name, type, and the actual function pointer.\n     */\n    ap_filter_rec_t *frec;\n\n    /** A place to store any data associated with the current filter */\n    void *ctx;\n\n    /** The next filter in the chain */\n    ap_filter_t *next;\n\n    /** The request_rec associated with the current filter.  If a sub-request\n     *  adds filters, then the sub-request is the request associated with the\n     *  filter.\n     */\n    request_rec *r;\n\n    /** The conn_rec associated with the current filter.  This is analogous\n     *  to the request_rec, except that it is used for connection filters.\n     */\n    conn_rec *c;\n}",
            "typedef_name": null,
            "fields": {
              "frec": "ap_filter_rec_t *",
              "ctx": "void *",
              "next": "ap_filter_t *",
              "r": "request_rec *",
              "c": "conn_rec *"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_table_t": {
            "name": "apr_table_t",
            "definition": "struct apr_table_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "http_ctx_t",
          "apr_status_t"
        ]
      },
      "source_code": "static apr_status_t read_chunked_trailers(http_ctx_t *ctx, ap_filter_t *f,\n                                          apr_bucket_brigade *b)\n{\n    int rv;\n    apr_bucket *e;\n    request_rec *r = f->r;\n    apr_table_t *trailers;\n    apr_table_t *saved_headers_in = r->headers_in;\n    int saved_status = r->status;\n\n    trailers = apr_table_make(r->pool, 5);\n    r->status = HTTP_OK;\n    r->headers_in = trailers;\n    ap_get_mime_headers(r);\n    r->headers_in = saved_headers_in;\n\n    if (r->status == HTTP_OK) {\n        r->status = saved_status;\n\n        if (!apr_is_empty_table(trailers)) {\n            e = ap_bucket_headers_create(trailers, r->pool, b->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(b, e);\n        }\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n        ctx->at_eos = 1;\n        rv = APR_SUCCESS;\n    }\n    else {\n        const char *error_notes = apr_table_get(r->notes,\n                                                \"error-notes\");\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02656)\n                      \"Error while reading HTTP trailer: %i%s%s\",\n                      r->status, error_notes ? \": \" : \"\",\n                      error_notes ? error_notes : \"\");\n        rv = APR_EINVAL;\n    }\n\n    return rv;\n}"
    },
    "ap_http_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 313, column 14>": {
      "basic_info": {
        "function_id": 1470,
        "name": "ap_http_filter",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 313, column 14>",
        "is_definition": true,
        "start_line": 313,
        "end_line": 427,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "f",
            "type": "ap_filter_t *"
          },
          {
            "name": "b",
            "type": "apr_bucket_brigade *"
          },
          {
            "name": "mode",
            "type": "ap_input_mode_t"
          },
          {
            "name": "block",
            "type": "apr_read_type_e"
          },
          {
            "name": "readbytes",
            "type": "apr_off_t"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "memset": {
            "declaration": "extern void *memset (void *__s, int __c, size_t __n) __THROW __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "ap_send_interim_response": {
            "declaration": "AP_DECLARE(void) ap_send_interim_response(request_rec *r, int send_headers)",
            "is_external": true,
            "definition": null
          },
          "apr_bucket_eos_create": {
            "declaration": "APU_DECLARE(apr_bucket *) apr_bucket_eos_create(apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "ap_get_brigade": {
            "declaration": "AP_DECLARE(apr_status_t) ap_get_brigade(ap_filter_t *filter,\n                                        apr_bucket_brigade *bucket,\n                                        ap_input_mode_t mode,\n                                        apr_read_type_e block,\n                                        apr_off_t readbytes)",
            "is_external": true,
            "definition": null
          },
          "AP_BUCKET_IS_HEADERS": {
            "declaration": "AP_BUCKET_IS_HEADERS(e)",
            "is_external": true,
            "definition": null
          },
          "destroy": {
            "declaration": "apr_bucket_delete(e)",
            "is_external": true,
            "definition": null
          },
          "free": {
            "declaration": "void (*free)(void *e)",
            "is_external": true,
            "definition": null
          },
          "apr_is_empty_table": {
            "declaration": "APR_DECLARE(int) apr_is_empty_table(const apr_table_t *t)",
            "is_external": true,
            "definition": null
          },
          "apr_table_overlay": {
            "declaration": "APR_DECLARE(apr_table_t *) apr_table_overlay(apr_pool_t *p,\n                                             const apr_table_t *overlay,\n                                             const apr_table_t *base)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {
          "APR_BLOCK_READ": {
            "name": "APR_BLOCK_READ",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum apr_read_type_e APR_BLOCK_READ = 0",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/apr_buckets.h', line 58, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "ap_filter_t": {
            "name": "ap_filter_t",
            "definition": "struct ap_filter_t {\n    /** The internal representation of this filter.  This includes\n     *  the filter's name, type, and the actual function pointer.\n     */\n    ap_filter_rec_t *frec;\n\n    /** A place to store any data associated with the current filter */\n    void *ctx;\n\n    /** The next filter in the chain */\n    ap_filter_t *next;\n\n    /** The request_rec associated with the current filter.  If a sub-request\n     *  adds filters, then the sub-request is the request associated with the\n     *  filter.\n     */\n    request_rec *r;\n\n    /** The conn_rec associated with the current filter.  This is analogous\n     *  to the request_rec, except that it is used for connection filters.\n     */\n    conn_rec *c;\n}",
            "typedef_name": null,
            "fields": {
              "frec": "ap_filter_rec_t *",
              "ctx": "void *",
              "next": "ap_filter_t *",
              "r": "request_rec *",
              "c": "conn_rec *"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "h1_in_ctx_t": {
            "name": "h1_in_ctx_t",
            "definition": "struct h1_in_ctx_t\n{\n    unsigned int at_trailers:1;\n    unsigned int at_eos:1;\n    unsigned int seen_data:1;\n}",
            "typedef_name": null,
            "fields": {
              "at_trailers": "unsigned int",
              "at_eos": "unsigned int",
              "seen_data": "unsigned int"
            },
            "condition": ""
          },
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "core_server_config": {
            "name": "core_server_config",
            "definition": "struct {\n\n    char *gprof_dir;\n\n    /* Name translations --- we want the core to be able to do *something*\n     * so it's at least a minimally functional web server on its own (and\n     * can be tested that way).  But let's keep it to the bare minimum:\n     */\n    const char *ap_document_root;\n\n    /* Access control */\n\n    char *access_name;\n    apr_array_header_t *sec_dir;\n    apr_array_header_t *sec_url;\n\n    /* recursion backstopper */\n    int redirect_limit; /* maximum number of internal redirects */\n    int subreq_limit;   /* maximum nesting level of subrequests */\n\n    const char *protocol;\n    apr_table_t *accf_map;\n\n    /* array of ap_errorlog_format_item for error log format string */\n    apr_array_header_t *error_log_format;\n    /*\n     * two arrays of arrays of ap_errorlog_format_item for additional information\n     * logged to the error log once per connection/request\n     */\n    apr_array_header_t *error_log_conn;\n    apr_array_header_t *error_log_req;\n\n    /* TRACE control */\n#define AP_TRACE_UNSET    -1\n#define AP_TRACE_DISABLE   0\n#define AP_TRACE_ENABLE    1\n#define AP_TRACE_EXTENDED  2\n    int trace_enable;\n#define AP_MERGE_TRAILERS_UNSET    0\n#define AP_MERGE_TRAILERS_ENABLE   1\n#define AP_MERGE_TRAILERS_DISABLE  2\n    int merge_trailers;\n\n    apr_array_header_t *protocols;\n    int protocols_honor_order;\n\n#define AP_HTTP09_UNSET   0\n#define AP_HTTP09_ENABLE  1\n#define AP_HTTP09_DISABLE 2\n    char http09_enable;\n\n#define AP_HTTP_CONFORMANCE_UNSET     0\n#define AP_HTTP_CONFORMANCE_UNSAFE    1\n#define AP_HTTP_CONFORMANCE_STRICT    2\n    char http_conformance;\n\n#define AP_HTTP_METHODS_UNSET         0\n#define AP_HTTP_METHODS_LENIENT       1\n#define AP_HTTP_METHODS_REGISTERED    2\n    char http_methods;\n    unsigned int merge_slashes;\n \n    apr_size_t   flush_max_threshold;\n    apr_int32_t  flush_max_pipelined;\n    unsigned int strict_host_check;\n#ifdef WIN32\n    apr_array_header_t *unc_list;\n#endif\n}",
            "typedef_name": null,
            "fields": {
              "gprof_dir": "char *",
              "ap_document_root": "const char *",
              "access_name": "char *",
              "sec_dir": "apr_array_header_t *",
              "sec_url": "apr_array_header_t *",
              "redirect_limit": "int",
              "subreq_limit": "int",
              "protocol": "const char *",
              "accf_map": "apr_table_t *",
              "error_log_format": "apr_array_header_t *",
              "error_log_conn": "apr_array_header_t *",
              "error_log_req": "apr_array_header_t *",
              "trace_enable": "int",
              "merge_trailers": "int",
              "protocols": "apr_array_header_t *",
              "protocols_honor_order": "int",
              "http09_enable": "char",
              "http_conformance": "char",
              "http_methods": "char",
              "merge_slashes": "unsigned int",
              "flush_max_threshold": "apr_size_t",
              "flush_max_pipelined": "apr_int32_t",
              "strict_host_check": "unsigned int"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          },
          "apr_bucket_type_eos": {
            "name": "apr_bucket_type_eos",
            "type": "const apr_bucket_type_t",
            "is_extern": true,
            "is_static": false,
            "definition": "extern const apr_bucket_type_t apr_bucket_type_eos",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "core_module": {
            "name": "core_module",
            "type": "module",
            "is_extern": true,
            "is_static": false,
            "definition": "extern module core_module",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "ap_input_mode_t",
          "apr_off_t",
          "apr_status_t",
          "apr_read_type_e"
        ]
      },
      "source_code": "apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,\n                            ap_input_mode_t mode, apr_read_type_e block,\n                            apr_off_t readbytes)\n{\n    apr_bucket *e, *next;\n    h1_in_ctx_t *ctx = f->ctx;\n    request_rec *r = f->r;\n    apr_status_t rv;\n\n    if (!ctx) {\n        f->ctx = ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));\n    }\n\n    /* Since we're about to read data, send 100-Continue if needed.\n     * Only valid on chunked and C-L bodies where the C-L is > 0.\n     *\n     * If the read is to be nonblocking though, the caller may not want to\n     * handle this just now (e.g. mod_proxy_http), and is prepared to read\n     * nothing if the client really waits for 100 continue, so we don't\n     * send it now and wait for later blocking read.\n     *\n     * In any case, even if r->expecting remains set at the end of the\n     * request handling, ap_set_keepalive() will finally do the right\n     * thing (i.e. \"Connection: close\" the connection).\n     */\n    if (block == APR_BLOCK_READ\n            && r->expecting_100 && r->proto_num >= HTTP_VERSION(1,1)\n            && !(ctx->at_eos || r->eos_sent || r->bytes_sent)) {\n        if (!ap_is_HTTP_SUCCESS(r->status)) {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                          \"ap_http_in_filter: status != OK, not sending 100-continue\");\n            ctx->at_eos = 1; /* send EOS below */\n        }\n        else if (!ctx->seen_data) {\n            int saved_status = r->status;\n            const char *saved_status_line = r->status_line;\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                          \"ap_http_in_filter: sending 100-continue\");\n            r->status = HTTP_CONTINUE;\n            r->status_line = NULL;\n            ap_send_interim_response(r, 0);\n            AP_DEBUG_ASSERT(!r->expecting_100);\n            r->status_line = saved_status_line;\n            r->status = saved_status;\n        }\n        else {\n            /* https://tools.ietf.org/html/rfc7231#section-5.1.1\n             *   A server MAY omit sending a 100 (Continue) response if it\n             *   has already received some or all of the message body for\n             *   the corresponding request [...]\n             */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(10260)\n                          \"request body already/partly received while \"\n                          \"100-continue is expected, omit sending interim \"\n                          \"response\");\n            r->expecting_100 = 0;\n        }\n    }\n\n    /* sanity check in case we're read twice */\n    if (ctx->at_eos) {\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n        rv = APR_SUCCESS;\n        goto cleanup;\n    }\n\n    rv = ap_get_brigade(f->next, b, mode, block, readbytes);\n    if (APR_SUCCESS == rv) {\n        for (e = APR_BRIGADE_FIRST(b);\n             e != APR_BRIGADE_SENTINEL(b);\n             e = next)\n        {\n            next = APR_BUCKET_NEXT(e);\n            if (!APR_BUCKET_IS_METADATA(e)) {\n                if (e->length != 0) {\n                    ctx->seen_data = 1;\n                }\n                if (ctx->at_trailers) {\n                    /* DATA after trailers? Someone smuggling something? */\n                    rv = AP_FILTER_ERROR;\n                    goto cleanup;\n                }\n                continue;\n            }\n            if (AP_BUCKET_IS_HEADERS(e)) {\n                /* trailers */\n                ap_bucket_headers * hdrs = e->data;\n\n                /* Allow multiple HEADERS buckets carrying trailers here,\n                 * will not happen from HTTP/1.x and current H2 implementation,\n                 * but is an option. */\n                ctx->at_trailers = 1;\n                if (!apr_is_empty_table(hdrs->headers)) {\n                    r->trailers_in = apr_table_overlay(r->pool, r->trailers_in, hdrs->headers);\n                }\n                apr_bucket_delete(e);\n            }\n            if (APR_BUCKET_IS_EOS(e)) {\n                ctx->at_eos = 1;\n                if (!apr_is_empty_table(r->trailers_in)) {\n                    core_server_config *conf = ap_get_module_config(\n                        r->server->module_config, &core_module);\n                    if (conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE) {\n                        r->headers_in = apr_table_overlay(r->pool, r->headers_in, r->trailers_in);\n                    }\n                }\n                goto cleanup;\n            }\n        }\n    }\n\ncleanup:\n    return rv;\n}"
    },
    "ap_h1_body_in_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 429, column 14>": {
      "basic_info": {
        "function_id": 1471,
        "name": "ap_h1_body_in_filter",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 429, column 14>",
        "is_definition": true,
        "start_line": 429,
        "end_line": 722,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "f",
            "type": "ap_filter_t *"
          },
          {
            "name": "b",
            "type": "apr_bucket_brigade *"
          },
          {
            "name": "mode",
            "type": "ap_input_mode_t"
          },
          {
            "name": "block",
            "type": "apr_read_type_e"
          },
          {
            "name": "readbytes",
            "type": "apr_off_t"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_get_brigade": {
            "declaration": "AP_DECLARE(apr_status_t) ap_get_brigade(ap_filter_t *filter,\n                                        apr_bucket_brigade *bucket,\n                                        ap_input_mode_t mode,\n                                        apr_read_type_e block,\n                                        apr_off_t readbytes)",
            "is_external": true,
            "definition": null
          },
          "memset": {
            "declaration": "extern void *memset (void *__s, int __c, size_t __n) __THROW __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "ap_get_limit_req_body": {
            "declaration": "AP_DECLARE(apr_off_t) ap_get_limit_req_body(const request_rec *r)",
            "is_external": true,
            "definition": null
          },
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "ap_is_chunked": {
            "declaration": "AP_DECLARE(int) ap_is_chunked(apr_pool_t *p, const char *line)",
            "is_external": true,
            "definition": null
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "ap_die": {
            "declaration": "AP_DECLARE(void) ap_die(int type, request_rec *r)",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_die(int type, request_rec *r)\n{\n    ap_die_r(type, r, r->status);\n}"
          },
          "ap_parse_strict_length": {
            "declaration": "AP_DECLARE(int) ap_parse_strict_length(apr_off_t *len, const char *str)",
            "is_external": true,
            "definition": null
          },
          "apr_bucket_eos_create": {
            "declaration": "APU_DECLARE(apr_bucket *) apr_bucket_eos_create(apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_cleanup": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_cleanup(void *data)",
            "is_external": true,
            "definition": null
          },
          "read": {
            "declaration": "apr_status_t (*read)(apr_bucket *b, const char **str, apr_size_t *len, \n                         apr_read_type_e block)",
            "is_external": true,
            "definition": null
          },
          "parse_chunk_size": {
            "declaration": "static apr_status_t parse_chunk_size(http_ctx_t *ctx, const char *buffer,\n                                     apr_size_t len, int linelimit, int strict)\n{\n    apr_size_t i = 0;\n\n    while (i < len) {\n        char c = buffer[i];\n\n        ap_xlate_proto_from_ascii(&c, 1);\n\n        /* handle CRLF after the chunk */\n        if (ctx->state == BODY_CHUNK_END\n                || ctx->state == BODY_CHUNK_END_LF) {\n            if (c == LF) {\n                if (strict && (ctx->state != BODY_CHUNK_END_LF)) {\n                    /*\n                     * CR missing before LF.\n                     */\n                    return APR_EINVAL;\n                }\n                ctx->state = BODY_CHUNK;\n            }\n            else if (c == CR && ctx->state == BODY_CHUNK_END) {\n                ctx->state = BODY_CHUNK_END_LF;\n            }\n            else {\n                /*\n                 * CRLF expected.\n                 */\n                return APR_EINVAL;\n            }\n            i++;\n            continue;\n        }\n\n        /* handle start of the chunk */\n        if (ctx->state == BODY_CHUNK) {\n            if (!apr_isxdigit(c)) {\n                /*\n                 * Detect invalid character at beginning. This also works for\n                 * empty chunk size lines.\n                 */\n                return APR_EINVAL;\n            }\n            else {\n                ctx->state = BODY_CHUNK_PART;\n            }\n            ctx->remaining = 0;\n            /* The maximum number of bits that can be handled in a\n             * chunk size is in theory sizeof(apr_off_t)*8-1 since\n             * off_t is signed, but use -4 to avoid undefined\n             * behaviour when bitshifting left. */\n            ctx->chunkbits = sizeof(apr_off_t) * 8 - 4;\n            ctx->chunk_used = 0;\n            ctx->chunk_bws = 0;\n        }\n\n        if (c == LF) {\n            if (strict && (ctx->state != BODY_CHUNK_LF)) {\n                /*\n                 * CR missing before LF.\n                 */\n                return APR_EINVAL;\n            }\n            if (ctx->remaining) {\n                ctx->state = BODY_CHUNK_DATA;\n            }\n            else {\n                ctx->state = BODY_CHUNK_TRAILER;\n            }\n        }\n        else if (ctx->state == BODY_CHUNK_LF) {\n            /*\n             * LF expected.\n             */\n            return APR_EINVAL;\n        }\n        else if (c == CR) {\n            ctx->state = BODY_CHUNK_LF;\n        }\n        else if (c == ';') {\n            ctx->state = BODY_CHUNK_EXT;\n        }\n        else if (ctx->state == BODY_CHUNK_EXT) {\n            /*\n             * Control chars (excluding tabs) are invalid.\n             * TODO: more precisely limit input\n             */\n            if (c != '\\t' && apr_iscntrl(c)) {\n                return APR_EINVAL;\n            }\n        }\n        else if (c == ' ' || c == '\\t') {\n            /* Be lenient up to 10 implied *LWS, a legacy of RFC 2616,\n             * and noted as errata to RFC7230;\n             * https://www.rfc-editor.org/errata_search.php?rfc=7230&eid=4667\n             */\n            ctx->state = BODY_CHUNK_CR;\n            if (++ctx->chunk_bws > 10) {\n                return APR_EINVAL;\n            }\n        }\n        else if (ctx->state == BODY_CHUNK_CR) {\n            /*\n             * ';', CR or LF expected.\n             */\n            return APR_EINVAL;\n        }\n        else if (ctx->state == BODY_CHUNK_PART) {\n            int xvalue;\n\n            /* ignore leading zeros */\n            if (!ctx->remaining && c == '0') {\n                i++;\n                continue;\n            }\n\n            ctx->chunkbits -= 4;\n            if (ctx->chunkbits < 0) {\n                /* overflow */\n                return APR_ENOSPC;\n            }\n\n            if (c >= '0' && c <= '9') {\n                xvalue = c - '0';\n            }\n            else if (c >= 'A' && c <= 'F') {\n                xvalue = c - 'A' + 0xa;\n            }\n            else if (c >= 'a' && c <= 'f') {\n                xvalue = c - 'a' + 0xa;\n            }\n            else {\n                /* bogus character */\n                return APR_EINVAL;\n            }\n\n            ctx->remaining = (ctx->remaining << 4) | xvalue;\n            if (ctx->remaining < 0) {\n                /* Overflow - should be unreachable since the\n                 * chunkbits limit will be reached first. */\n                return APR_ENOSPC;\n            }\n        }\n        else {\n            /* Should not happen */\n            return APR_EGENERAL;\n        }\n\n        i++;\n    }\n\n    /* sanity check */\n    ctx->chunk_used += len;\n    if (ctx->chunk_used < 0 || ctx->chunk_used > linelimit) {\n        return APR_ENOSPC;\n    }\n\n    return APR_SUCCESS;\n}",
            "is_external": false,
            "definition": "static apr_status_t parse_chunk_size(http_ctx_t *ctx, const char *buffer,\n                                     apr_size_t len, int linelimit, int strict)\n{\n    apr_size_t i = 0;\n\n    while (i < len) {\n        char c = buffer[i];\n\n        ap_xlate_proto_from_ascii(&c, 1);\n\n        /* handle CRLF after the chunk */\n        if (ctx->state == BODY_CHUNK_END\n                || ctx->state == BODY_CHUNK_END_LF) {\n            if (c == LF) {\n                if (strict && (ctx->state != BODY_CHUNK_END_LF)) {\n                    /*\n                     * CR missing before LF.\n                     */\n                    return APR_EINVAL;\n                }\n                ctx->state = BODY_CHUNK;\n            }\n            else if (c == CR && ctx->state == BODY_CHUNK_END) {\n                ctx->state = BODY_CHUNK_END_LF;\n            }\n            else {\n                /*\n                 * CRLF expected.\n                 */\n                return APR_EINVAL;\n            }\n            i++;\n            continue;\n        }\n\n        /* handle start of the chunk */\n        if (ctx->state == BODY_CHUNK) {\n            if (!apr_isxdigit(c)) {\n                /*\n                 * Detect invalid character at beginning. This also works for\n                 * empty chunk size lines.\n                 */\n                return APR_EINVAL;\n            }\n            else {\n                ctx->state = BODY_CHUNK_PART;\n            }\n            ctx->remaining = 0;\n            /* The maximum number of bits that can be handled in a\n             * chunk size is in theory sizeof(apr_off_t)*8-1 since\n             * off_t is signed, but use -4 to avoid undefined\n             * behaviour when bitshifting left. */\n            ctx->chunkbits = sizeof(apr_off_t) * 8 - 4;\n            ctx->chunk_used = 0;\n            ctx->chunk_bws = 0;\n        }\n\n        if (c == LF) {\n            if (strict && (ctx->state != BODY_CHUNK_LF)) {\n                /*\n                 * CR missing before LF.\n                 */\n                return APR_EINVAL;\n            }\n            if (ctx->remaining) {\n                ctx->state = BODY_CHUNK_DATA;\n            }\n            else {\n                ctx->state = BODY_CHUNK_TRAILER;\n            }\n        }\n        else if (ctx->state == BODY_CHUNK_LF) {\n            /*\n             * LF expected.\n             */\n            return APR_EINVAL;\n        }\n        else if (c == CR) {\n            ctx->state = BODY_CHUNK_LF;\n        }\n        else if (c == ';') {\n            ctx->state = BODY_CHUNK_EXT;\n        }\n        else if (ctx->state == BODY_CHUNK_EXT) {\n            /*\n             * Control chars (excluding tabs) are invalid.\n             * TODO: more precisely limit input\n             */\n            if (c != '\\t' && apr_iscntrl(c)) {\n                return APR_EINVAL;\n            }\n        }\n        else if (c == ' ' || c == '\\t') {\n            /* Be lenient up to 10 implied *LWS, a legacy of RFC 2616,\n             * and noted as errata to RFC7230;\n             * https://www.rfc-editor.org/errata_search.php?rfc=7230&eid=4667\n             */\n            ctx->state = BODY_CHUNK_CR;\n            if (++ctx->chunk_bws > 10) {\n                return APR_EINVAL;\n            }\n        }\n        else if (ctx->state == BODY_CHUNK_CR) {\n            /*\n             * ';', CR or LF expected.\n             */\n            return APR_EINVAL;\n        }\n        else if (ctx->state == BODY_CHUNK_PART) {\n            int xvalue;\n\n            /* ignore leading zeros */\n            if (!ctx->remaining && c == '0') {\n                i++;\n                continue;\n            }\n\n            ctx->chunkbits -= 4;\n            if (ctx->chunkbits < 0) {\n                /* overflow */\n                return APR_ENOSPC;\n            }\n\n            if (c >= '0' && c <= '9') {\n                xvalue = c - '0';\n            }\n            else if (c >= 'A' && c <= 'F') {\n                xvalue = c - 'A' + 0xa;\n            }\n            else if (c >= 'a' && c <= 'f') {\n                xvalue = c - 'a' + 0xa;\n            }\n            else {\n                /* bogus character */\n                return APR_EINVAL;\n            }\n\n            ctx->remaining = (ctx->remaining << 4) | xvalue;\n            if (ctx->remaining < 0) {\n                /* Overflow - should be unreachable since the\n                 * chunkbits limit will be reached first. */\n                return APR_ENOSPC;\n            }\n        }\n        else {\n            /* Should not happen */\n            return APR_EGENERAL;\n        }\n\n        i++;\n    }\n\n    /* sanity check */\n    ctx->chunk_used += len;\n    if (ctx->chunk_used < 0 || ctx->chunk_used > linelimit) {\n        return APR_ENOSPC;\n    }\n\n    return APR_SUCCESS;\n}"
          },
          "destroy": {
            "declaration": "apr_bucket_delete(e)",
            "is_external": true,
            "definition": null
          },
          "free": {
            "declaration": "void (*free)(void *e)",
            "is_external": true,
            "definition": null
          },
          "read_chunked_trailers": {
            "declaration": "static apr_status_t read_chunked_trailers(http_ctx_t *ctx, ap_filter_t *f,\n                                          apr_bucket_brigade *b)\n{\n    int rv;\n    apr_bucket *e;\n    request_rec *r = f->r;\n    apr_table_t *trailers;\n    apr_table_t *saved_headers_in = r->headers_in;\n    int saved_status = r->status;\n\n    trailers = apr_table_make(r->pool, 5);\n    r->status = HTTP_OK;\n    r->headers_in = trailers;\n    ap_get_mime_headers(r);\n    r->headers_in = saved_headers_in;\n\n    if (r->status == HTTP_OK) {\n        r->status = saved_status;\n\n        if (!apr_is_empty_table(trailers)) {\n            e = ap_bucket_headers_create(trailers, r->pool, b->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(b, e);\n        }\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n        ctx->at_eos = 1;\n        rv = APR_SUCCESS;\n    }\n    else {\n        const char *error_notes = apr_table_get(r->notes,\n                                                \"error-notes\");\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02656)\n                      \"Error while reading HTTP trailer: %i%s%s\",\n                      r->status, error_notes ? \": \" : \"\",\n                      error_notes ? error_notes : \"\");\n        rv = APR_EINVAL;\n    }\n\n    return rv;\n}",
            "is_external": false,
            "definition": "static apr_status_t read_chunked_trailers(http_ctx_t *ctx, ap_filter_t *f,\n                                          apr_bucket_brigade *b)\n{\n    int rv;\n    apr_bucket *e;\n    request_rec *r = f->r;\n    apr_table_t *trailers;\n    apr_table_t *saved_headers_in = r->headers_in;\n    int saved_status = r->status;\n\n    trailers = apr_table_make(r->pool, 5);\n    r->status = HTTP_OK;\n    r->headers_in = trailers;\n    ap_get_mime_headers(r);\n    r->headers_in = saved_headers_in;\n\n    if (r->status == HTTP_OK) {\n        r->status = saved_status;\n\n        if (!apr_is_empty_table(trailers)) {\n            e = ap_bucket_headers_create(trailers, r->pool, b->bucket_alloc);\n            APR_BRIGADE_INSERT_TAIL(b, e);\n        }\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n        ctx->at_eos = 1;\n        rv = APR_SUCCESS;\n    }\n    else {\n        const char *error_notes = apr_table_get(r->notes,\n                                                \"error-notes\");\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02656)\n                      \"Error while reading HTTP trailer: %i%s%s\",\n                      r->status, error_notes ? \": \" : \"\",\n                      error_notes ? error_notes : \"\");\n        rv = APR_EINVAL;\n    }\n\n    return rv;\n}"
          },
          "apr_brigade_length": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_length(apr_bucket_brigade *bb,\n                                             int read_all,\n                                             apr_off_t *length)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {
          "AP_MODE_READBYTES": {
            "name": "AP_MODE_READBYTES",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_input_mode_t AP_MODE_READBYTES = 0",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/util_filter.h', line 43, column 5>",
            "condition": ""
          },
          "AP_MODE_GETLINE": {
            "name": "AP_MODE_GETLINE",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_input_mode_t AP_MODE_GETLINE = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/util_filter.h', line 48, column 5>",
            "condition": ""
          },
          "BODY_NONE": {
            "name": "BODY_NONE",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_NONE = 0",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 74, column 9>",
            "condition": ""
          },
          "BODY_CHUNK": {
            "name": "BODY_CHUNK",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK = 2",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 76, column 9>",
            "condition": ""
          },
          "BODY_LENGTH": {
            "name": "BODY_LENGTH",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_LENGTH = 1",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 75, column 9>",
            "condition": ""
          },
          "BODY_CHUNK_PART": {
            "name": "BODY_CHUNK_PART",
            "value": "3",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK_PART = 3",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 77, column 9>",
            "condition": ""
          },
          "BODY_CHUNK_EXT": {
            "name": "BODY_CHUNK_EXT",
            "value": "4",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK_EXT = 4",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 78, column 9>",
            "condition": ""
          },
          "BODY_CHUNK_CR": {
            "name": "BODY_CHUNK_CR",
            "value": "5",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK_CR = 5",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 79, column 9>",
            "condition": ""
          },
          "BODY_CHUNK_LF": {
            "name": "BODY_CHUNK_LF",
            "value": "6",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK_LF = 6",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 80, column 9>",
            "condition": ""
          },
          "BODY_CHUNK_END": {
            "name": "BODY_CHUNK_END",
            "value": "8",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK_END = 8",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 82, column 9>",
            "condition": ""
          },
          "BODY_CHUNK_END_LF": {
            "name": "BODY_CHUNK_END_LF",
            "value": "9",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK_END_LF = 9",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 83, column 9>",
            "condition": ""
          },
          "APR_NONBLOCK_READ": {
            "name": "APR_NONBLOCK_READ",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum apr_read_type_e APR_NONBLOCK_READ = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/apr_buckets.h', line 59, column 5>",
            "condition": ""
          },
          "APR_BLOCK_READ": {
            "name": "APR_BLOCK_READ",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum apr_read_type_e APR_BLOCK_READ = 0",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/apr_buckets.h', line 58, column 5>",
            "condition": ""
          },
          "BODY_CHUNK_TRAILER": {
            "name": "BODY_CHUNK_TRAILER",
            "value": "10",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK_TRAILER = 10",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 84, column 9>",
            "condition": ""
          },
          "BODY_CHUNK_DATA": {
            "name": "BODY_CHUNK_DATA",
            "value": "7",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:72:5) BODY_CHUNK_DATA = 7",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 81, column 9>",
            "condition": ""
          }
        },
        "used_structs": {
          "ap_filter_t": {
            "name": "ap_filter_t",
            "definition": "struct ap_filter_t {\n    /** The internal representation of this filter.  This includes\n     *  the filter's name, type, and the actual function pointer.\n     */\n    ap_filter_rec_t *frec;\n\n    /** A place to store any data associated with the current filter */\n    void *ctx;\n\n    /** The next filter in the chain */\n    ap_filter_t *next;\n\n    /** The request_rec associated with the current filter.  If a sub-request\n     *  adds filters, then the sub-request is the request associated with the\n     *  filter.\n     */\n    request_rec *r;\n\n    /** The conn_rec associated with the current filter.  This is analogous\n     *  to the request_rec, except that it is used for connection filters.\n     */\n    conn_rec *c;\n}",
            "typedef_name": null,
            "fields": {
              "frec": "ap_filter_rec_t *",
              "ctx": "void *",
              "next": "ap_filter_t *",
              "r": "request_rec *",
              "c": "conn_rec *"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "core_server_config": {
            "name": "core_server_config",
            "definition": "struct {\n\n    char *gprof_dir;\n\n    /* Name translations --- we want the core to be able to do *something*\n     * so it's at least a minimally functional web server on its own (and\n     * can be tested that way).  But let's keep it to the bare minimum:\n     */\n    const char *ap_document_root;\n\n    /* Access control */\n\n    char *access_name;\n    apr_array_header_t *sec_dir;\n    apr_array_header_t *sec_url;\n\n    /* recursion backstopper */\n    int redirect_limit; /* maximum number of internal redirects */\n    int subreq_limit;   /* maximum nesting level of subrequests */\n\n    const char *protocol;\n    apr_table_t *accf_map;\n\n    /* array of ap_errorlog_format_item for error log format string */\n    apr_array_header_t *error_log_format;\n    /*\n     * two arrays of arrays of ap_errorlog_format_item for additional information\n     * logged to the error log once per connection/request\n     */\n    apr_array_header_t *error_log_conn;\n    apr_array_header_t *error_log_req;\n\n    /* TRACE control */\n#define AP_TRACE_UNSET    -1\n#define AP_TRACE_DISABLE   0\n#define AP_TRACE_ENABLE    1\n#define AP_TRACE_EXTENDED  2\n    int trace_enable;\n#define AP_MERGE_TRAILERS_UNSET    0\n#define AP_MERGE_TRAILERS_ENABLE   1\n#define AP_MERGE_TRAILERS_DISABLE  2\n    int merge_trailers;\n\n    apr_array_header_t *protocols;\n    int protocols_honor_order;\n\n#define AP_HTTP09_UNSET   0\n#define AP_HTTP09_ENABLE  1\n#define AP_HTTP09_DISABLE 2\n    char http09_enable;\n\n#define AP_HTTP_CONFORMANCE_UNSET     0\n#define AP_HTTP_CONFORMANCE_UNSAFE    1\n#define AP_HTTP_CONFORMANCE_STRICT    2\n    char http_conformance;\n\n#define AP_HTTP_METHODS_UNSET         0\n#define AP_HTTP_METHODS_LENIENT       1\n#define AP_HTTP_METHODS_REGISTERED    2\n    char http_methods;\n    unsigned int merge_slashes;\n \n    apr_size_t   flush_max_threshold;\n    apr_int32_t  flush_max_pipelined;\n    unsigned int strict_host_check;\n#ifdef WIN32\n    apr_array_header_t *unc_list;\n#endif\n}",
            "typedef_name": null,
            "fields": {
              "gprof_dir": "char *",
              "ap_document_root": "const char *",
              "access_name": "char *",
              "sec_dir": "apr_array_header_t *",
              "sec_url": "apr_array_header_t *",
              "redirect_limit": "int",
              "subreq_limit": "int",
              "protocol": "const char *",
              "accf_map": "apr_table_t *",
              "error_log_format": "apr_array_header_t *",
              "error_log_conn": "apr_array_header_t *",
              "error_log_req": "apr_array_header_t *",
              "trace_enable": "int",
              "merge_trailers": "int",
              "protocols": "apr_array_header_t *",
              "protocols_honor_order": "int",
              "http09_enable": "char",
              "http_conformance": "char",
              "http_methods": "char",
              "merge_slashes": "unsigned int",
              "flush_max_threshold": "apr_size_t",
              "flush_max_pipelined": "apr_int32_t",
              "strict_host_check": "unsigned int"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "core_module": {
            "name": "core_module",
            "type": "module",
            "is_extern": true,
            "is_static": false,
            "definition": "extern module core_module",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          },
          "apr_bucket_type_eos": {
            "name": "apr_bucket_type_eos",
            "type": "const apr_bucket_type_t",
            "is_extern": true,
            "is_static": false,
            "definition": "extern const apr_bucket_type_t apr_bucket_type_eos",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "ap_input_mode_t",
          "apr_status_t",
          "http_ctx_t",
          "apr_read_type_e",
          "apr_off_t",
          "apr_size_t"
        ]
      },
      "source_code": "apr_status_t ap_h1_body_in_filter(ap_filter_t *f, apr_bucket_brigade *b,\n                                     ap_input_mode_t mode, apr_read_type_e block,\n                                     apr_off_t readbytes)\n{\n    core_server_config *conf =\n        (core_server_config *) ap_get_module_config(f->r->server->module_config,\n                                                    &core_module);\n    int strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n    apr_bucket *e;\n    http_ctx_t *ctx = f->ctx;\n    apr_status_t rv;\n    int again;\n\n    /* just get out of the way of things we don't want. */\n    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {\n        return ap_get_brigade(f->next, b, mode, block, readbytes);\n    }\n\n    if (!ctx) {\n        const char *tenc, *lenp;\n        f->ctx = ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));\n        ctx->state = BODY_NONE;\n\n        /* LimitRequestBody does not apply to proxied responses.\n         * Consider implementing this check in its own filter.\n         * Would adding a directive to limit the size of proxied\n         * responses be useful?\n         */\n        if (f->r->proxyreq != PROXYREQ_RESPONSE) {\n            ctx->limit = ap_get_limit_req_body(f->r);\n        }\n        else {\n            ctx->limit = 0;\n        }\n\n        tenc = apr_table_get(f->r->headers_in, \"Transfer-Encoding\");\n        lenp = apr_table_get(f->r->headers_in, \"Content-Length\");\n\n        if (tenc) {\n            if (ap_is_chunked(f->r->pool, tenc)) {\n                ctx->state = BODY_CHUNK;\n            }\n            else if (f->r->proxyreq == PROXYREQ_RESPONSE) {\n                /* http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-23\n                 * Section 3.3.3.3: \"If a Transfer-Encoding header field is\n                 * present in a response and the chunked transfer coding is not\n                 * the final encoding, the message body length is determined by\n                 * reading the connection until it is closed by the server.\"\n                 */\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02555)\n                              \"Unknown Transfer-Encoding: %s; \"\n                              \"using read-until-close\", tenc);\n                tenc = NULL;\n            }\n            else {\n                /* Something that isn't a HTTP request, unless some future\n                 * edition defines new transfer encodings, is unsupported.\n                 */\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)\n                              \"Unknown Transfer-Encoding: %s\", tenc);\n                ap_die(HTTP_NOT_IMPLEMENTED, f->r);\n                return APR_EGENERAL;\n            }\n            lenp = NULL;\n        }\n        if (lenp) {\n            ctx->state = BODY_LENGTH;\n\n            /* Protects against over/underflow, non-digit chars in the\n             * string, leading plus/minus signs, trailing characters and\n             * a negative number.\n             */\n            if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n                ctx->remaining = 0;\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)\n                              \"Invalid Content-Length\");\n\n                return APR_EINVAL;\n            }\n\n            /* If we have a limit in effect and we know the C-L ahead of\n             * time, stop it here if it is invalid.\n             */\n            if (ctx->limit && ctx->limit < ctx->remaining) {\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01588)\n                          \"Requested content-length of %\" APR_OFF_T_FMT\n                          \" is larger than the configured limit\"\n                          \" of %\" APR_OFF_T_FMT, ctx->remaining, ctx->limit);\n                return APR_ENOSPC;\n            }\n        }\n\n        /* If we don't have a request entity indicated by the headers, EOS.\n         * (BODY_NONE is a valid intermediate state due to trailers,\n         *  but it isn't a valid starting state.)\n         *\n         * RFC 2616 Section 4.4 note 5 states that connection-close\n         * is invalid for a request entity - request bodies must be\n         * denoted by C-L or T-E: chunked.\n         *\n         * Note that since the proxy uses this filter to handle the\n         * proxied *response*, proxy responses MUST be exempt.\n         */\n        if (ctx->state == BODY_NONE && f->r->proxyreq != PROXYREQ_RESPONSE) {\n            ctx->at_eos = 1; /* send EOS below */\n        }\n    }\n\n    /* sanity check in case we're read twice */\n    if (ctx->at_eos) {\n        e = apr_bucket_eos_create(f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(b, e);\n        return APR_SUCCESS;\n    }\n\n    do {\n        apr_brigade_cleanup(b);\n        again = 0; /* until further notice */\n\n        /* read and handle the brigade */\n        switch (ctx->state) {\n        case BODY_CHUNK:\n        case BODY_CHUNK_PART:\n        case BODY_CHUNK_EXT:\n        case BODY_CHUNK_CR:\n        case BODY_CHUNK_LF:\n        case BODY_CHUNK_END:\n        case BODY_CHUNK_END_LF: {\n\n            rv = ap_get_brigade(f->next, b, AP_MODE_GETLINE, block, 0);\n\n            /* for timeout */\n            if (block == APR_NONBLOCK_READ\n                    && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n                            || (APR_STATUS_IS_EAGAIN(rv)))) {\n                return APR_EAGAIN;\n            }\n\n            if (rv == APR_EOF) {\n                return APR_INCOMPLETE;\n            }\n\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n\n            e = APR_BRIGADE_FIRST(b);\n            while (e != APR_BRIGADE_SENTINEL(b)) {\n                const char *buffer;\n                apr_size_t len;\n\n                if (!APR_BUCKET_IS_METADATA(e)) {\n                    rv = apr_bucket_read(e, &buffer, &len, APR_BLOCK_READ);\n                    if (rv == APR_SUCCESS) {\n                        if (len > 0) {\n                            ctx->seen_data = 1;\n                        }\n                        rv = parse_chunk_size(ctx, buffer, len,\n                                f->r->server->limit_req_fieldsize, strict);\n                    }\n                    if (rv != APR_SUCCESS) {\n                        ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, f->r, APLOGNO(01590)\n                                      \"Error reading/parsing chunk %s \",\n                                      (APR_ENOSPC == rv) ? \"(overflow)\" : \"\");\n                        return rv;\n                    }\n                }\n\n                apr_bucket_delete(e);\n                e = APR_BRIGADE_FIRST(b);\n            }\n            again = 1; /* come around again */\n\n            if (ctx->state == BODY_CHUNK_TRAILER) {\n                /* Treat UNSET as DISABLE - trailers aren't merged by default */\n                return read_chunked_trailers(ctx, f, b);\n            }\n\n            break;\n        }\n        case BODY_NONE:\n        case BODY_LENGTH:\n        case BODY_CHUNK_DATA: {\n\n            /* Ensure that the caller can not go over our boundary point. */\n            if (ctx->state != BODY_NONE && ctx->remaining < readbytes) {\n                readbytes = ctx->remaining;\n            }\n            if (readbytes > 0) {\n                apr_off_t totalread;\n\n                rv = ap_get_brigade(f->next, b, mode, block, readbytes);\n\n                /* for timeout */\n                if (block == APR_NONBLOCK_READ\n                        && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n                                || (APR_STATUS_IS_EAGAIN(rv)))) {\n                    return APR_EAGAIN;\n                }\n\n                if (rv == APR_EOF && ctx->state != BODY_NONE\n                        && ctx->remaining > 0) {\n                    return APR_INCOMPLETE;\n                }\n\n                if (rv != APR_SUCCESS) {\n                    return rv;\n                }\n\n                /* How many bytes did we just read? */\n                apr_brigade_length(b, 0, &totalread);\n                if (totalread > 0) {\n                    ctx->seen_data = 1;\n                }\n\n                /* If this happens, we have a bucket of unknown length.  Die because\n                 * it means our assumptions have changed. */\n                AP_DEBUG_ASSERT(totalread >= 0);\n\n                if (ctx->state != BODY_NONE) {\n                    ctx->remaining -= totalread;\n                    if (ctx->remaining > 0) {\n                        e = APR_BRIGADE_LAST(b);\n                        if (APR_BUCKET_IS_EOS(e)) {\n                            apr_bucket_delete(e);\n                            return APR_INCOMPLETE;\n                        }\n                    }\n                    else if (ctx->state == BODY_CHUNK_DATA) {\n                        /* next chunk please */\n                        ctx->state = BODY_CHUNK_END;\n                        ctx->chunk_used = 0;\n                    }\n                }\n\n                /* We have a limit in effect. */\n                if (ctx->limit) {\n                    /* FIXME: Note that we might get slightly confused on\n                     * chunked inputs as we'd need to compensate for the chunk\n                     * lengths which may not really count.  This seems to be up\n                     * for interpretation.\n                     */\n                    ctx->limit_used += totalread;\n                    if (ctx->limit < ctx->limit_used) {\n                        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r,\n                                      APLOGNO(01591) \"Read content length of \"\n                                      \"%\" APR_OFF_T_FMT \" is larger than the \"\n                                      \"configured limit of %\" APR_OFF_T_FMT,\n                                      ctx->limit_used, ctx->limit);\n                        return APR_ENOSPC;\n                    }\n                }\n            }\n\n            /* If we have no more bytes remaining on a C-L request,\n             * save the caller a round trip to discover EOS.\n             */\n            if (ctx->state == BODY_LENGTH && ctx->remaining == 0) {\n                e = apr_bucket_eos_create(f->c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(b, e);\n                ctx->at_eos = 1;\n            }\n\n            break;\n        }\n        case BODY_CHUNK_TRAILER: {\n\n            rv = ap_get_brigade(f->next, b, mode, block, readbytes);\n\n            /* for timeout */\n            if (block == APR_NONBLOCK_READ\n                    && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))\n                            || (APR_STATUS_IS_EAGAIN(rv)))) {\n                return APR_EAGAIN;\n            }\n\n            if (rv != APR_SUCCESS) {\n                return rv;\n            }\n\n            break;\n        }\n        default: {\n            /* Should not happen */\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02901)\n                          \"Unexpected body state (%i)\", (int)ctx->state);\n            return APR_EGENERAL;\n        }\n        }\n\n    } while (again);\n\n    return APR_SUCCESS;\n}"
    },
    "check_header@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 730, column 12>": {
      "basic_info": {
        "function_id": 1472,
        "name": "check_header",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 730, column 12>",
        "is_definition": true,
        "start_line": 730,
        "end_line": 785,
        "return_type": "int",
        "parameters": [
          {
            "name": "ctx",
            "type": "struct check_header_ctx *"
          },
          {
            "name": "name",
            "type": "const char *"
          },
          {
            "name": "val",
            "type": "const char **"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "ap_scan_http_token": {
            "declaration": "AP_DECLARE(const char *) ap_scan_http_token(const char *ptr)",
            "is_external": true,
            "definition": null
          },
          "ap_scan_vchar_obstext": {
            "declaration": "AP_DECLARE(const char *) ap_scan_vchar_obstext(const char *ptr)",
            "is_external": true,
            "definition": null
          },
          "ap_scan_http_field_content": {
            "declaration": "AP_DECLARE(const char *) ap_scan_http_field_content(const char *ptr)",
            "is_external": true,
            "definition": null
          },
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "strlen": {
            "declaration": "extern size_t strlen (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "memcpy": {
            "declaration": "extern void *memcpy (void *__restrict __dest, const void *__restrict __src,\n\t\t     size_t __n) __THROW __nonnull ((1, 2))",
            "is_external": true,
            "definition": null
          },
          "strspn": {
            "declaration": "extern size_t strspn (const char *__s, const char *__accept)\n     __THROW __attribute_pure__ __nonnull ((1, 2))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "check_headers_table@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 787, column 12>": {
            "source_code": "static int check_headers_table(apr_table_t *t, struct check_header_ctx *ctx)\n{\n    const apr_array_header_t *headers = apr_table_elts(t);\n    apr_table_entry_t *header;\n    int i;\n\n    for (i = 0; i < headers->nelts; ++i) {\n        header = &APR_ARRAY_IDX(headers, i, apr_table_entry_t);\n        if (!header->key) {\n            continue;\n        }\n        if (!check_header(ctx, header->key, (const char **)&header->val)) {\n            return 0;\n        }\n    }\n    return 1;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 787, column 12>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "check_header_ctx": {
            "name": "check_header_ctx",
            "definition": "struct check_header_ctx {\n    request_rec *r;\n    int strict;\n}",
            "typedef_name": null,
            "fields": {
              "r": "request_rec *",
              "strict": "int"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "static int check_header(struct check_header_ctx *ctx,\n                        const char *name, const char **val)\n{\n    const char *pos, *end;\n    char *dst = NULL;\n\n    if (name[0] == '\\0') {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02428)\n                      \"Empty response header name, aborting request\");\n        return 0;\n    }\n\n    if (ctx->strict) { \n        end = ap_scan_http_token(name);\n    }\n    else {\n        end = ap_scan_vchar_obstext(name);\n    }\n    if (*end) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02429)\n                      \"Response header name '%s' contains invalid \"\n                      \"characters, aborting request\",\n                      name);\n        return 0;\n    }\n\n    for (pos = *val; *pos; pos = end) {\n        end = ap_scan_http_field_content(pos);\n        if (*end) {\n            if (end[0] != CR || end[1] != LF || (end[2] != ' ' &&\n                                                 end[2] != '\\t')) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                              \"Response header '%s' value of '%s' contains \"\n                              \"invalid characters, aborting request\",\n                              name, pos);\n                return 0;\n            }\n            if (!dst) {\n                *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n            }\n        }\n        if (dst) {\n            memcpy(dst, pos, end - pos);\n            dst += end - pos;\n            if (*end) {\n                /* skip folding and replace with a single space */\n                end += 3 + strspn(end + 3, \"\\t \");\n                *dst++ = ' ';\n            }\n        }\n    }\n    if (dst) {\n        *dst = '\\0';\n    }\n    return 1;\n}"
    },
    "check_headers_table@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 787, column 12>": {
      "basic_info": {
        "function_id": 1473,
        "name": "check_headers_table",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 787, column 12>",
        "is_definition": true,
        "start_line": 787,
        "end_line": 803,
        "return_type": "int",
        "parameters": [
          {
            "name": "t",
            "type": "apr_table_t *"
          },
          {
            "name": "ctx",
            "type": "struct check_header_ctx *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_table_elts": {
            "declaration": "APR_DECLARE(const apr_array_header_t *) apr_table_elts(const apr_table_t *t)",
            "is_external": true,
            "definition": null
          },
          "check_header": {
            "declaration": "static int check_header(struct check_header_ctx *ctx,\n                        const char *name, const char **val)\n{\n    const char *pos, *end;\n    char *dst = NULL;\n\n    if (name[0] == '\\0') {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02428)\n                      \"Empty response header name, aborting request\");\n        return 0;\n    }\n\n    if (ctx->strict) { \n        end = ap_scan_http_token(name);\n    }\n    else {\n        end = ap_scan_vchar_obstext(name);\n    }\n    if (*end) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02429)\n                      \"Response header name '%s' contains invalid \"\n                      \"characters, aborting request\",\n                      name);\n        return 0;\n    }\n\n    for (pos = *val; *pos; pos = end) {\n        end = ap_scan_http_field_content(pos);\n        if (*end) {\n            if (end[0] != CR || end[1] != LF || (end[2] != ' ' &&\n                                                 end[2] != '\\t')) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                              \"Response header '%s' value of '%s' contains \"\n                              \"invalid characters, aborting request\",\n                              name, pos);\n                return 0;\n            }\n            if (!dst) {\n                *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n            }\n        }\n        if (dst) {\n            memcpy(dst, pos, end - pos);\n            dst += end - pos;\n            if (*end) {\n                /* skip folding and replace with a single space */\n                end += 3 + strspn(end + 3, \"\\t \");\n                *dst++ = ' ';\n            }\n        }\n    }\n    if (dst) {\n        *dst = '\\0';\n    }\n    return 1;\n}",
            "is_external": false,
            "definition": "static int check_header(struct check_header_ctx *ctx,\n                        const char *name, const char **val)\n{\n    const char *pos, *end;\n    char *dst = NULL;\n\n    if (name[0] == '\\0') {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02428)\n                      \"Empty response header name, aborting request\");\n        return 0;\n    }\n\n    if (ctx->strict) { \n        end = ap_scan_http_token(name);\n    }\n    else {\n        end = ap_scan_vchar_obstext(name);\n    }\n    if (*end) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02429)\n                      \"Response header name '%s' contains invalid \"\n                      \"characters, aborting request\",\n                      name);\n        return 0;\n    }\n\n    for (pos = *val; *pos; pos = end) {\n        end = ap_scan_http_field_content(pos);\n        if (*end) {\n            if (end[0] != CR || end[1] != LF || (end[2] != ' ' &&\n                                                 end[2] != '\\t')) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                              \"Response header '%s' value of '%s' contains \"\n                              \"invalid characters, aborting request\",\n                              name, pos);\n                return 0;\n            }\n            if (!dst) {\n                *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n            }\n        }\n        if (dst) {\n            memcpy(dst, pos, end - pos);\n            dst += end - pos;\n            if (*end) {\n                /* skip folding and replace with a single space */\n                end += 3 + strspn(end + 3, \"\\t \");\n                *dst++ = ' ';\n            }\n        }\n    }\n    if (dst) {\n        *dst = '\\0';\n    }\n    return 1;\n}"
          }
        },
        "callers": {
          "check_headers@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 809, column 23>": {
            "source_code": "static APR_INLINE int check_headers(request_rec *r)\n{\n    struct check_header_ctx ctx;\n    core_server_config *conf =\n            ap_get_core_module_config(r->server->module_config);\n    const char *val;\n \n    if ((val = apr_table_get(r->headers_out, \"Transfer-Encoding\"))) {\n        if (apr_table_get(r->headers_out, \"Content-Length\")) {\n            apr_table_unset(r->headers_out, \"Content-Length\");\n            r->connection->keepalive = AP_CONN_CLOSE;\n        }\n        if (!ap_is_chunked(r->pool, val)) {\n            r->connection->keepalive = AP_CONN_CLOSE;\n            return 0;\n        }\n    }\n\n    ctx.r = r;\n    ctx.strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n    return check_headers_table(r->headers_out, &ctx) &&\n           check_headers_table(r->err_headers_out, &ctx);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 809, column 23>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "apr_table_t": {
            "name": "apr_table_t",
            "definition": "struct apr_table_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          },
          "check_header_ctx": {
            "name": "check_header_ctx",
            "definition": "struct check_header_ctx {\n    request_rec *r;\n    int strict;\n}",
            "typedef_name": null,
            "fields": {
              "r": "request_rec *",
              "strict": "int"
            },
            "condition": ""
          },
          "apr_array_header_t": {
            "name": "apr_array_header_t",
            "definition": "struct apr_array_header_t {\n    /** The pool the array is allocated out of */\n    apr_pool_t *pool;\n    /** The amount of memory allocated for each element of the array */\n    int elt_size;\n    /** The number of active elements in the array */\n    int nelts;\n    /** The number of elements allocated in the array */\n    int nalloc;\n    /** The elements in the array */\n    char *elts;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "elt_size": "int",
              "nelts": "int",
              "nalloc": "int",
              "elts": "char *"
            },
            "condition": ""
          },
          "apr_table_entry_t": {
            "name": "apr_table_entry_t",
            "definition": "struct apr_table_entry_t {\n    /** The key for the current table entry */\n    char *key;          /* maybe NULL in future;\n                         * check when iterating thru table_elts\n                         */\n    /** The value for the current table entry */\n    char *val;\n\n    /** A checksum for the key, for use by the apr_table internals */\n    apr_uint32_t key_checksum;\n}",
            "typedef_name": null,
            "fields": {
              "key": "char *",
              "val": "char *",
              "key_checksum": "apr_uint32_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static int check_headers_table(apr_table_t *t, struct check_header_ctx *ctx)\n{\n    const apr_array_header_t *headers = apr_table_elts(t);\n    apr_table_entry_t *header;\n    int i;\n\n    for (i = 0; i < headers->nelts; ++i) {\n        header = &APR_ARRAY_IDX(headers, i, apr_table_entry_t);\n        if (!header->key) {\n            continue;\n        }\n        if (!check_header(ctx, header->key, (const char **)&header->val)) {\n            return 0;\n        }\n    }\n    return 1;\n}"
    },
    "check_headers@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 809, column 23>": {
      "basic_info": {
        "function_id": 1474,
        "name": "check_headers",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 809, column 23>",
        "is_definition": true,
        "start_line": 809,
        "end_line": 831,
        "return_type": "int",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "apr_table_unset": {
            "declaration": "APR_DECLARE(void) apr_table_unset(apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "ap_is_chunked": {
            "declaration": "AP_DECLARE(int) ap_is_chunked(apr_pool_t *p, const char *line)",
            "is_external": true,
            "definition": null
          },
          "check_headers_table": {
            "declaration": "static int check_headers_table(apr_table_t *t, struct check_header_ctx *ctx)\n{\n    const apr_array_header_t *headers = apr_table_elts(t);\n    apr_table_entry_t *header;\n    int i;\n\n    for (i = 0; i < headers->nelts; ++i) {\n        header = &APR_ARRAY_IDX(headers, i, apr_table_entry_t);\n        if (!header->key) {\n            continue;\n        }\n        if (!check_header(ctx, header->key, (const char **)&header->val)) {\n            return 0;\n        }\n    }\n    return 1;\n}",
            "is_external": false,
            "definition": "static int check_headers_table(apr_table_t *t, struct check_header_ctx *ctx)\n{\n    const apr_array_header_t *headers = apr_table_elts(t);\n    apr_table_entry_t *header;\n    int i;\n\n    for (i = 0; i < headers->nelts; ++i) {\n        header = &APR_ARRAY_IDX(headers, i, apr_table_entry_t);\n        if (!header->key) {\n            continue;\n        }\n        if (!check_header(ctx, header->key, (const char **)&header->val)) {\n            return 0;\n        }\n    }\n    return 1;\n}"
          }
        },
        "callers": {
          "ap_http_header_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1159, column 38>": {
            "source_code": "AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f,\n                                                           apr_bucket_brigade *b)\n{\n    request_rec *r = f->r;\n    conn_rec *c = r->connection;\n    apr_bucket *e, *next, *eos = NULL, *bcontent = NULL;\n    header_filter_ctx *ctx = f->ctx;\n    ap_bucket_error *eb = NULL;\n    apr_status_t rv = APR_SUCCESS;\n    int recursive_error = 0;\n\n    AP_DEBUG_ASSERT(!r->main);\n\n    if (!ctx) {\n        ctx = f->ctx = apr_pcalloc(r->pool, sizeof(header_filter_ctx));\n    }\n\n    if (!ctx->final_status) {\n        /* Determine if it is time to insert the response bucket for\n         * the request. Request handlers just write content or an EOS\n         * and that needs to take the current state of request_rec to\n         * send on status and headers as a response bucket.\n         *\n         * But we also send interim responses (as response buckets)\n         * through this filter and that must not trigger generating\n         * an additional response bucket.\n         *\n         * Waiting on a DATA/ERROR/EOS bucket alone is not enough,\n         * unfortunately, as some handlers trigger response generation\n         * by just writing a FLUSH (see mod_lua's websocket for example).\n         */\n        apr_bucket *respb = NULL;\n        ap_bucket_response *resp;\n\n        for (e = APR_BRIGADE_FIRST(b);\n             e != APR_BRIGADE_SENTINEL(b) && !bcontent;\n             e = APR_BUCKET_NEXT(e))\n        {\n            if (APR_BUCKET_IS_METADATA(e)) {\n                if (AP_BUCKET_IS_RESPONSE(e)) {\n                    /* RESPONSE buckets may get passed by others, for\n                     * example ap_send_interim_response() or ap_die().\n                     * We examine the status code of such a RESPONSE below\n                     * to determine if the response answers the request\n                     * or is just interim.\n                     */\n                    respb = e;\n                    resp = respb->data;\n                    if (!ctx->final_status\n                        && (resp->status >= 200 || resp->status == HTTP_SWITCHING_PROTOCOLS)) {\n                        ctx->final_status = resp->status;\n                        ctx->final_header_only = AP_STATUS_IS_HEADER_ONLY(resp->status);\n                        bcontent = APR_BUCKET_NEXT(e);\n                        break;\n                    }\n                }\n                else if (APR_BUCKET_IS_FLUSH(e)) {\n                    /* flush without response bucket triggers */\n                    if (!respb) bcontent = e;\n                }\n                else if (APR_BUCKET_IS_EOS(e)) {\n                    bcontent = e;\n                }\n                else if (AP_BUCKET_IS_ERROR(e)) {\n                    /* Need to handle this below via ap_die() */\n                    break;\n                }\n                else if (AP_BUCKET_IS_EOC(e)) {\n                    /* Need to handle this below. EOC prevents generating\n                     * a RESPONSE if not already triggered by buckets preceding\n                     * it. */\n                    break;\n                }\n            }\n            else {\n                /* First content bucket, always triggering the response.*/\n                bcontent = e;\n            }\n        }\n\n        if (!ctx->final_status && bcontent) {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                          \"ap_http_header_filter prep response status %d\",\n                          r->status);\n            merge_response_headers(r);\n            if (!check_headers(r)) {\n                /* We may come back here from ap_die() below,\n                 * so clear anything from this response.\n                 */\n                apr_table_clear(r->headers_out);\n                apr_table_clear(r->err_headers_out);\n                r->content_type = r->content_encoding = NULL;\n                r->content_languages = NULL;\n                r->clength = r->chunked = 0;\n                apr_brigade_cleanup(b);\n\n                /* Don't recall ap_die() if we come back here (from its own internal\n                 * redirect or error response), otherwise we can end up in infinite\n                 * recursion; better fall through with 500, minimal headers and an\n                 * empty body (EOS only).\n                 */\n                if (!check_headers_recursion(r)) {\n                    ap_die(HTTP_INTERNAL_SERVER_ERROR, r);\n                    return AP_FILTER_ERROR;\n                }\n                r->status = HTTP_INTERNAL_SERVER_ERROR;\n                e = ap_bucket_eoc_create(c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(b, e);\n                e = apr_bucket_eos_create(c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(b, e);\n                ap_set_content_length(r, 0);\n                recursive_error = 1;\n            }\n            /* insert the RESPONSE before the first content bucket */\n            respb = create_response_bucket(r, b->bucket_alloc);\n            APR_BUCKET_INSERT_BEFORE(bcontent, respb);\n            ctx->final_status = r->status;\n            ctx->final_header_only = (r->header_only || AP_STATUS_IS_HEADER_ONLY(r->status));\n            r->sent_bodyct = 1;         /* Whatever follows is real body stuff... */\n        }\n    }\n\n    if (ctx->final_status && ctx->final_header_only) {\n        /* The final RESPONSE has already been sent or is in front of `bcontent`\n         * in the brigade. For a header_only respone, remove all content buckets\n         * up to the first EOS. On seeing EOS, we remove ourself and are done.\n         * NOTE that `header_only` responses never generate trailes.\n         */\n        for (e = bcontent? bcontent : APR_BRIGADE_FIRST(b);\n             e != APR_BRIGADE_SENTINEL(b);\n             e = next)\n        {\n            next = APR_BUCKET_NEXT(e);\n            if (APR_BUCKET_IS_EOS(e)) {\n                eos = e;\n                break;\n            }\n            apr_bucket_delete(e);\n        }\n\n        if (eos) {\n            ap_remove_output_filter(f);\n        }\n        if (!APR_BRIGADE_EMPTY(b)) {\n            rv = ap_pass_brigade(f->next, b);\n        }\n        r->final_resp_passed = 1;\n        return rv;\n    }\n\n    /* Look for ERROR/EOC/EOS that require special handling. */\n    for (e = APR_BRIGADE_FIRST(b);\n         e != APR_BRIGADE_SENTINEL(b);\n         e = APR_BUCKET_NEXT(e))\n    {\n        if (APR_BUCKET_IS_METADATA(e)) {\n            if (APR_BUCKET_IS_EOS(e)) {\n                if (!eos) eos = e;\n            }\n            else if (AP_BUCKET_IS_EOC(e)) {\n                /* If we see an EOC bucket it is a signal that we should get out\n                 * of the way doing nothing.\n                 */\n                ap_remove_output_filter(f);\n                return ap_pass_brigade(f->next, b);\n            }\n            else if (AP_BUCKET_IS_ERROR(e)) {\n                int status;\n                eb = e->data;\n                status = eb->status;\n                if (r->final_resp_passed) {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                                  \"ap_http_header_filter error bucket, should \"\n                                  \"die with status=%d but final response already \"\n                                  \"underway\", status);\n                    ap_remove_output_filter(f);\n                    APR_BUCKET_REMOVE(e);\n                    apr_brigade_cleanup(b);\n                    APR_BRIGADE_INSERT_TAIL(b, e);\n                    e = ap_bucket_eoc_create(c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(b, e);\n                    e = apr_bucket_eos_create(c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(b, e);\n                    c->aborted = 1;\n                    return ap_pass_brigade(f->next, b);\n                }\n                else {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                                  \"ap_http_header_filter error bucket, die with %d and error\",\n                                  status);\n                    apr_brigade_cleanup(b);\n                    /* This will invoke us again */\n                    ctx->dying = 1;\n                    ap_die(status, r);\n                    return AP_FILTER_ERROR;\n                }\n            }\n        }\n    }\n\n    if (r->assbackwards) {\n        r->sent_bodyct = 1;\n        ap_remove_output_filter(f);\n        rv = ap_pass_brigade(f->next, b);\n        goto out;\n    }\n\n    if (eos) {\n        e = create_trailers_bucket(r, b->bucket_alloc);\n        if (e) {\n            APR_BUCKET_INSERT_BEFORE(eos, e);\n        }\n        ap_remove_output_filter(f);\n    }\n    else if (ctx->final_status == HTTP_SWITCHING_PROTOCOLS) {\n        /* switching protocol, whatever comes next is not HTTP/1.x */\n        ap_remove_output_filter(f);\n    }\n\n    rv = ap_pass_brigade(f->next, b);\nout:\n    if (ctx->final_status)\n        r->final_resp_passed = 1;\n    if (recursive_error) {\n        return AP_FILTER_ERROR;\n    }\n    return rv;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1159, column 38>"
          }
        },
        "used_macros": {
          "AP_CONN_CLOSE": {
            "name": "AP_CONN_CLOSE",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_conn_keepalive_e AP_CONN_CLOSE = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1145, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "check_header_ctx": {
            "name": "check_header_ctx",
            "definition": "struct check_header_ctx {\n    request_rec *r;\n    int strict;\n}",
            "typedef_name": null,
            "fields": {
              "r": "request_rec *",
              "strict": "int"
            },
            "condition": ""
          },
          "core_server_config": {
            "name": "core_server_config",
            "definition": "struct {\n\n    char *gprof_dir;\n\n    /* Name translations --- we want the core to be able to do *something*\n     * so it's at least a minimally functional web server on its own (and\n     * can be tested that way).  But let's keep it to the bare minimum:\n     */\n    const char *ap_document_root;\n\n    /* Access control */\n\n    char *access_name;\n    apr_array_header_t *sec_dir;\n    apr_array_header_t *sec_url;\n\n    /* recursion backstopper */\n    int redirect_limit; /* maximum number of internal redirects */\n    int subreq_limit;   /* maximum nesting level of subrequests */\n\n    const char *protocol;\n    apr_table_t *accf_map;\n\n    /* array of ap_errorlog_format_item for error log format string */\n    apr_array_header_t *error_log_format;\n    /*\n     * two arrays of arrays of ap_errorlog_format_item for additional information\n     * logged to the error log once per connection/request\n     */\n    apr_array_header_t *error_log_conn;\n    apr_array_header_t *error_log_req;\n\n    /* TRACE control */\n#define AP_TRACE_UNSET    -1\n#define AP_TRACE_DISABLE   0\n#define AP_TRACE_ENABLE    1\n#define AP_TRACE_EXTENDED  2\n    int trace_enable;\n#define AP_MERGE_TRAILERS_UNSET    0\n#define AP_MERGE_TRAILERS_ENABLE   1\n#define AP_MERGE_TRAILERS_DISABLE  2\n    int merge_trailers;\n\n    apr_array_header_t *protocols;\n    int protocols_honor_order;\n\n#define AP_HTTP09_UNSET   0\n#define AP_HTTP09_ENABLE  1\n#define AP_HTTP09_DISABLE 2\n    char http09_enable;\n\n#define AP_HTTP_CONFORMANCE_UNSET     0\n#define AP_HTTP_CONFORMANCE_UNSAFE    1\n#define AP_HTTP_CONFORMANCE_STRICT    2\n    char http_conformance;\n\n#define AP_HTTP_METHODS_UNSET         0\n#define AP_HTTP_METHODS_LENIENT       1\n#define AP_HTTP_METHODS_REGISTERED    2\n    char http_methods;\n    unsigned int merge_slashes;\n \n    apr_size_t   flush_max_threshold;\n    apr_int32_t  flush_max_pipelined;\n    unsigned int strict_host_check;\n#ifdef WIN32\n    apr_array_header_t *unc_list;\n#endif\n}",
            "typedef_name": null,
            "fields": {
              "gprof_dir": "char *",
              "ap_document_root": "const char *",
              "access_name": "char *",
              "sec_dir": "apr_array_header_t *",
              "sec_url": "apr_array_header_t *",
              "redirect_limit": "int",
              "subreq_limit": "int",
              "protocol": "const char *",
              "accf_map": "apr_table_t *",
              "error_log_format": "apr_array_header_t *",
              "error_log_conn": "apr_array_header_t *",
              "error_log_req": "apr_array_header_t *",
              "trace_enable": "int",
              "merge_trailers": "int",
              "protocols": "apr_array_header_t *",
              "protocols_honor_order": "int",
              "http09_enable": "char",
              "http_conformance": "char",
              "http_methods": "char",
              "merge_slashes": "unsigned int",
              "flush_max_threshold": "apr_size_t",
              "flush_max_pipelined": "apr_int32_t",
              "strict_host_check": "unsigned int"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static APR_INLINE int check_headers(request_rec *r)\n{\n    struct check_header_ctx ctx;\n    core_server_config *conf =\n            ap_get_core_module_config(r->server->module_config);\n    const char *val;\n \n    if ((val = apr_table_get(r->headers_out, \"Transfer-Encoding\"))) {\n        if (apr_table_get(r->headers_out, \"Content-Length\")) {\n            apr_table_unset(r->headers_out, \"Content-Length\");\n            r->connection->keepalive = AP_CONN_CLOSE;\n        }\n        if (!ap_is_chunked(r->pool, val)) {\n            r->connection->keepalive = AP_CONN_CLOSE;\n            return 0;\n        }\n    }\n\n    ctx.r = r;\n    ctx.strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n    return check_headers_table(r->headers_out, &ctx) &&\n           check_headers_table(r->err_headers_out, &ctx);\n}"
    },
    "check_headers_recursion@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 833, column 12>": {
      "basic_info": {
        "function_id": 1475,
        "name": "check_headers_recursion",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 833, column 12>",
        "is_definition": true,
        "start_line": 833,
        "end_line": 842,
        "return_type": "int",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_pool_userdata_get": {
            "declaration": "APR_DECLARE(apr_status_t) apr_pool_userdata_get(void **data, const char *key,\n                                                apr_pool_t *pool)\n                          __attribute__((nonnull(1,2,3)))",
            "is_external": true,
            "definition": null
          },
          "apr_pool_userdata_setn": {
            "declaration": "APR_DECLARE(apr_status_t) apr_pool_userdata_setn(\n                                const void *data, const char *key,\n                                apr_status_t (*cleanup)(void *),\n                                apr_pool_t *pool)\n                          __attribute__((nonnull(2,4)))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_http_header_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1159, column 38>": {
            "source_code": "AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f,\n                                                           apr_bucket_brigade *b)\n{\n    request_rec *r = f->r;\n    conn_rec *c = r->connection;\n    apr_bucket *e, *next, *eos = NULL, *bcontent = NULL;\n    header_filter_ctx *ctx = f->ctx;\n    ap_bucket_error *eb = NULL;\n    apr_status_t rv = APR_SUCCESS;\n    int recursive_error = 0;\n\n    AP_DEBUG_ASSERT(!r->main);\n\n    if (!ctx) {\n        ctx = f->ctx = apr_pcalloc(r->pool, sizeof(header_filter_ctx));\n    }\n\n    if (!ctx->final_status) {\n        /* Determine if it is time to insert the response bucket for\n         * the request. Request handlers just write content or an EOS\n         * and that needs to take the current state of request_rec to\n         * send on status and headers as a response bucket.\n         *\n         * But we also send interim responses (as response buckets)\n         * through this filter and that must not trigger generating\n         * an additional response bucket.\n         *\n         * Waiting on a DATA/ERROR/EOS bucket alone is not enough,\n         * unfortunately, as some handlers trigger response generation\n         * by just writing a FLUSH (see mod_lua's websocket for example).\n         */\n        apr_bucket *respb = NULL;\n        ap_bucket_response *resp;\n\n        for (e = APR_BRIGADE_FIRST(b);\n             e != APR_BRIGADE_SENTINEL(b) && !bcontent;\n             e = APR_BUCKET_NEXT(e))\n        {\n            if (APR_BUCKET_IS_METADATA(e)) {\n                if (AP_BUCKET_IS_RESPONSE(e)) {\n                    /* RESPONSE buckets may get passed by others, for\n                     * example ap_send_interim_response() or ap_die().\n                     * We examine the status code of such a RESPONSE below\n                     * to determine if the response answers the request\n                     * or is just interim.\n                     */\n                    respb = e;\n                    resp = respb->data;\n                    if (!ctx->final_status\n                        && (resp->status >= 200 || resp->status == HTTP_SWITCHING_PROTOCOLS)) {\n                        ctx->final_status = resp->status;\n                        ctx->final_header_only = AP_STATUS_IS_HEADER_ONLY(resp->status);\n                        bcontent = APR_BUCKET_NEXT(e);\n                        break;\n                    }\n                }\n                else if (APR_BUCKET_IS_FLUSH(e)) {\n                    /* flush without response bucket triggers */\n                    if (!respb) bcontent = e;\n                }\n                else if (APR_BUCKET_IS_EOS(e)) {\n                    bcontent = e;\n                }\n                else if (AP_BUCKET_IS_ERROR(e)) {\n                    /* Need to handle this below via ap_die() */\n                    break;\n                }\n                else if (AP_BUCKET_IS_EOC(e)) {\n                    /* Need to handle this below. EOC prevents generating\n                     * a RESPONSE if not already triggered by buckets preceding\n                     * it. */\n                    break;\n                }\n            }\n            else {\n                /* First content bucket, always triggering the response.*/\n                bcontent = e;\n            }\n        }\n\n        if (!ctx->final_status && bcontent) {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                          \"ap_http_header_filter prep response status %d\",\n                          r->status);\n            merge_response_headers(r);\n            if (!check_headers(r)) {\n                /* We may come back here from ap_die() below,\n                 * so clear anything from this response.\n                 */\n                apr_table_clear(r->headers_out);\n                apr_table_clear(r->err_headers_out);\n                r->content_type = r->content_encoding = NULL;\n                r->content_languages = NULL;\n                r->clength = r->chunked = 0;\n                apr_brigade_cleanup(b);\n\n                /* Don't recall ap_die() if we come back here (from its own internal\n                 * redirect or error response), otherwise we can end up in infinite\n                 * recursion; better fall through with 500, minimal headers and an\n                 * empty body (EOS only).\n                 */\n                if (!check_headers_recursion(r)) {\n                    ap_die(HTTP_INTERNAL_SERVER_ERROR, r);\n                    return AP_FILTER_ERROR;\n                }\n                r->status = HTTP_INTERNAL_SERVER_ERROR;\n                e = ap_bucket_eoc_create(c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(b, e);\n                e = apr_bucket_eos_create(c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(b, e);\n                ap_set_content_length(r, 0);\n                recursive_error = 1;\n            }\n            /* insert the RESPONSE before the first content bucket */\n            respb = create_response_bucket(r, b->bucket_alloc);\n            APR_BUCKET_INSERT_BEFORE(bcontent, respb);\n            ctx->final_status = r->status;\n            ctx->final_header_only = (r->header_only || AP_STATUS_IS_HEADER_ONLY(r->status));\n            r->sent_bodyct = 1;         /* Whatever follows is real body stuff... */\n        }\n    }\n\n    if (ctx->final_status && ctx->final_header_only) {\n        /* The final RESPONSE has already been sent or is in front of `bcontent`\n         * in the brigade. For a header_only respone, remove all content buckets\n         * up to the first EOS. On seeing EOS, we remove ourself and are done.\n         * NOTE that `header_only` responses never generate trailes.\n         */\n        for (e = bcontent? bcontent : APR_BRIGADE_FIRST(b);\n             e != APR_BRIGADE_SENTINEL(b);\n             e = next)\n        {\n            next = APR_BUCKET_NEXT(e);\n            if (APR_BUCKET_IS_EOS(e)) {\n                eos = e;\n                break;\n            }\n            apr_bucket_delete(e);\n        }\n\n        if (eos) {\n            ap_remove_output_filter(f);\n        }\n        if (!APR_BRIGADE_EMPTY(b)) {\n            rv = ap_pass_brigade(f->next, b);\n        }\n        r->final_resp_passed = 1;\n        return rv;\n    }\n\n    /* Look for ERROR/EOC/EOS that require special handling. */\n    for (e = APR_BRIGADE_FIRST(b);\n         e != APR_BRIGADE_SENTINEL(b);\n         e = APR_BUCKET_NEXT(e))\n    {\n        if (APR_BUCKET_IS_METADATA(e)) {\n            if (APR_BUCKET_IS_EOS(e)) {\n                if (!eos) eos = e;\n            }\n            else if (AP_BUCKET_IS_EOC(e)) {\n                /* If we see an EOC bucket it is a signal that we should get out\n                 * of the way doing nothing.\n                 */\n                ap_remove_output_filter(f);\n                return ap_pass_brigade(f->next, b);\n            }\n            else if (AP_BUCKET_IS_ERROR(e)) {\n                int status;\n                eb = e->data;\n                status = eb->status;\n                if (r->final_resp_passed) {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                                  \"ap_http_header_filter error bucket, should \"\n                                  \"die with status=%d but final response already \"\n                                  \"underway\", status);\n                    ap_remove_output_filter(f);\n                    APR_BUCKET_REMOVE(e);\n                    apr_brigade_cleanup(b);\n                    APR_BRIGADE_INSERT_TAIL(b, e);\n                    e = ap_bucket_eoc_create(c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(b, e);\n                    e = apr_bucket_eos_create(c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(b, e);\n                    c->aborted = 1;\n                    return ap_pass_brigade(f->next, b);\n                }\n                else {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                                  \"ap_http_header_filter error bucket, die with %d and error\",\n                                  status);\n                    apr_brigade_cleanup(b);\n                    /* This will invoke us again */\n                    ctx->dying = 1;\n                    ap_die(status, r);\n                    return AP_FILTER_ERROR;\n                }\n            }\n        }\n    }\n\n    if (r->assbackwards) {\n        r->sent_bodyct = 1;\n        ap_remove_output_filter(f);\n        rv = ap_pass_brigade(f->next, b);\n        goto out;\n    }\n\n    if (eos) {\n        e = create_trailers_bucket(r, b->bucket_alloc);\n        if (e) {\n            APR_BUCKET_INSERT_BEFORE(eos, e);\n        }\n        ap_remove_output_filter(f);\n    }\n    else if (ctx->final_status == HTTP_SWITCHING_PROTOCOLS) {\n        /* switching protocol, whatever comes next is not HTTP/1.x */\n        ap_remove_output_filter(f);\n    }\n\n    rv = ap_pass_brigade(f->next, b);\nout:\n    if (ctx->final_status)\n        r->final_resp_passed = 1;\n    if (recursive_error) {\n        return AP_FILTER_ERROR;\n    }\n    return rv;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1159, column 38>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static int check_headers_recursion(request_rec *r)\n{\n    void *check = NULL;\n    apr_pool_userdata_get(&check, \"check_headers_recursion\", r->pool);\n    if (check) {\n        return 1;\n    }\n    apr_pool_userdata_setn(\"true\", \"check_headers_recursion\", NULL, r->pool);\n    return 0;\n}"
    },
    "form_header_field@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 853, column 12>": {
      "basic_info": {
        "function_id": 1476,
        "name": "form_header_field",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 853, column 12>",
        "is_definition": true,
        "start_line": 853,
        "end_line": 882,
        "return_type": "int",
        "parameters": [
          {
            "name": "h",
            "type": "header_struct *"
          },
          {
            "name": "fieldname",
            "type": "const char *"
          },
          {
            "name": "fieldval",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "strlen": {
            "declaration": "extern size_t strlen (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_writev": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_writev(apr_bucket_brigade *b,\n                                             apr_brigade_flush flush,\n                                             void *ctx,\n                                             const struct iovec *vec,\n                                             apr_size_t nvec)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "header_struct": {
            "name": "header_struct",
            "definition": "struct header_struct {\n    apr_pool_t *pool;\n    apr_bucket_brigade *bb;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "bb": "apr_bucket_brigade *"
            },
            "condition": ""
          },
          "iovec": {
            "name": "iovec",
            "definition": "struct iovec\n  {\n    void *iov_base;\t/* Pointer to data.  */\n    size_t iov_len;\t/* Length of data.  */\n  }",
            "typedef_name": null,
            "fields": {
              "iov_base": "void *",
              "iov_len": "size_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static int form_header_field(header_struct *h,\n                             const char *fieldname, const char *fieldval)\n{\n#if APR_CHARSET_EBCDIC\n    char *headfield;\n    apr_size_t len;\n\n    headfield = apr_pstrcat(h->pool, fieldname, \": \", fieldval, CRLF, NULL);\n    len = strlen(headfield);\n\n    ap_xlate_proto_to_ascii(headfield, len);\n    apr_brigade_write(h->bb, NULL, NULL, headfield, len);\n#else\n    struct iovec vec[4];\n    struct iovec *v = vec;\n    v->iov_base = (void *)fieldname;\n    v->iov_len = strlen(fieldname);\n    v++;\n    v->iov_base = \": \";\n    v->iov_len = sizeof(\": \") - 1;\n    v++;\n    v->iov_base = (void *)fieldval;\n    v->iov_len = strlen(fieldval);\n    v++;\n    v->iov_base = CRLF;\n    v->iov_len = sizeof(CRLF) - 1;\n    apr_brigade_writev(h->bb, NULL, NULL, vec, 4);\n#endif /* !APR_CHARSET_EBCDIC */\n    return 1;\n}"
    },
    "uniq_field_values@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 890, column 12>": {
      "basic_info": {
        "function_id": 1477,
        "name": "uniq_field_values",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 890, column 12>",
        "is_definition": true,
        "start_line": 890,
        "end_line": 934,
        "return_type": "int",
        "parameters": [
          {
            "name": "d",
            "type": "void *"
          },
          {
            "name": "key",
            "type": "const char *"
          },
          {
            "name": "val",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_pstrdup": {
            "declaration": "APR_DECLARE(char *) apr_pstrdup(apr_pool_t *p, const char *s)",
            "is_external": true,
            "definition": null
          },
          "__ctype_b_loc": {
            "declaration": "extern const unsigned short int **__ctype_b_loc (void)\n     __THROW __attribute__ ((__const__))",
            "is_external": true,
            "definition": null
          },
          "ap_cstr_casecmp": {
            "declaration": "AP_DECLARE(int) ap_cstr_casecmp(const char *s1, const char *s2)",
            "is_external": true,
            "definition": null
          },
          "apr_array_push": {
            "declaration": "APR_DECLARE(void *) apr_array_push(apr_array_header_t *arr)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {
          "_ISalnum": {
            "name": "_ISalnum",
            "value": "8",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISalnum = 8",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 59, column 3>",
            "condition": ""
          },
          "_ISalpha": {
            "name": "_ISalpha",
            "value": "1024",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISalpha = 1024",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 50, column 3>",
            "condition": ""
          },
          "_IScntrl": {
            "name": "_IScntrl",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _IScntrl = 2",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 57, column 3>",
            "condition": ""
          },
          "_ISdigit": {
            "name": "_ISdigit",
            "value": "2048",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISdigit = 2048",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 51, column 3>",
            "condition": ""
          },
          "_ISlower": {
            "name": "_ISlower",
            "value": "512",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISlower = 512",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 49, column 3>",
            "condition": ""
          },
          "_ISgraph": {
            "name": "_ISgraph",
            "value": "32768",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISgraph = 32768",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 55, column 3>",
            "condition": ""
          },
          "_ISprint": {
            "name": "_ISprint",
            "value": "16384",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISprint = 16384",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 54, column 3>",
            "condition": ""
          },
          "_ISpunct": {
            "name": "_ISpunct",
            "value": "4",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISpunct = 4",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 58, column 3>",
            "condition": ""
          },
          "_ISspace": {
            "name": "_ISspace",
            "value": "8192",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISspace = 8192",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 53, column 3>",
            "condition": ""
          }
        },
        "used_structs": {
          "apr_array_header_t": {
            "name": "apr_array_header_t",
            "definition": "struct apr_array_header_t {\n    /** The pool the array is allocated out of */\n    apr_pool_t *pool;\n    /** The amount of memory allocated for each element of the array */\n    int elt_size;\n    /** The number of active elements in the array */\n    int nelts;\n    /** The number of elements allocated in the array */\n    int nalloc;\n    /** The elements in the array */\n    char *elts;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "elt_size": "int",
              "nelts": "int",
              "nalloc": "int",
              "elts": "char *"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static int uniq_field_values(void *d, const char *key, const char *val)\n{\n    apr_array_header_t *values;\n    char *start;\n    char *e;\n    char **strpp;\n    int  i;\n\n    values = (apr_array_header_t *)d;\n\n    e = apr_pstrdup(values->pool, val);\n\n    do {\n        /* Find a non-empty fieldname */\n\n        while (*e == ',' || apr_isspace(*e)) {\n            ++e;\n        }\n        if (*e == '\\0') {\n            break;\n        }\n        start = e;\n        while (*e != '\\0' && *e != ',' && !apr_isspace(*e)) {\n            ++e;\n        }\n        if (*e != '\\0') {\n            *e++ = '\\0';\n        }\n\n        /* Now add it to values if it isn't already represented.\n         * Could be replaced by a ap_array_strcasecmp() if we had one.\n         */\n        for (i = 0, strpp = (char **) values->elts; i < values->nelts;\n             ++i, ++strpp) {\n            if (*strpp && ap_cstr_casecmp(*strpp, start) == 0) {\n                break;\n            }\n        }\n        if (i == values->nelts) {  /* if not found */\n            *(char **)apr_array_push(values) = start;\n        }\n    } while (*e != '\\0');\n\n    return 1;\n}"
    },
    "fixup_vary@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 941, column 13>": {
      "basic_info": {
        "function_id": 1478,
        "name": "fixup_vary",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 941, column 13>",
        "is_definition": true,
        "start_line": 941,
        "end_line": 959,
        "return_type": "void",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_array_make": {
            "declaration": "APR_DECLARE(apr_array_header_t *) apr_array_make(apr_pool_t *p,\n                                                 int nelts, int elt_size)",
            "is_external": true,
            "definition": null
          },
          "apr_table_do": {
            "declaration": "APR_DECLARE_NONSTD(int) apr_table_do(apr_table_do_callback_fn_t *comp,\n                                     void *rec, const apr_table_t *t, ...)\n#if defined(__GNUC__) && __GNUC__ >= 4\n    __attribute__((sentinel))",
            "is_external": true,
            "definition": null
          },
          "apr_table_setn": {
            "declaration": "APR_DECLARE(void) apr_table_setn(apr_table_t *t, const char *key,\n                                 const char *val)",
            "is_external": true,
            "definition": null
          },
          "apr_array_pstrcat": {
            "declaration": "APR_DECLARE(char *) apr_array_pstrcat(apr_pool_t *p,\n\t\t\t\t      const apr_array_header_t *arr,\n\t\t\t\t      const char sep)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "merge_response_headers@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2050, column 13>": {
            "source_code": "static void merge_response_headers(request_rec *r)\n{\n    const char *ctype;\n\n    /*\n     * Now that we are ready to send a response, we need to combine the two\n     * header field tables into a single table.  If we don't do this, our\n     * later attempts to set or unset a given fieldname might be bypassed.\n     */\n    if (!apr_is_empty_table(r->err_headers_out)) {\n        r->headers_out = apr_table_overlay(r->pool, r->err_headers_out,\n                                           r->headers_out);\n        apr_table_clear(r->err_headers_out);\n    }\n\n    ap_set_std_response_headers(r);\n\n    /*\n     * Remove the 'Vary' header field if the client can't handle it.\n     * Since this will have nasty effects on HTTP/1.1 caches, force\n     * the response into HTTP/1.0 mode.\n     *\n     * Note: the force-response-1.0 should come before the call to\n     *       basic_http_header_check()\n     */\n    if (apr_table_get(r->subprocess_env, \"force-no-vary\") != NULL) {\n        apr_table_unset(r->headers_out, \"Vary\");\n        r->proto_num = HTTP_VERSION(1,0);\n        apr_table_setn(r->subprocess_env, \"force-response-1.0\", \"1\");\n    }\n    else {\n        fixup_vary(r);\n    }\n\n    /* Determine the protocol and whether we should use keepalives. */\n    basic_http_header_check(r);\n\n    /*\n     * Now remove any ETag response header field if earlier processing\n     * says so (such as a 'FileETag None' directive).\n     */\n    if (apr_table_get(r->notes, \"no-etag\") != NULL) {\n        apr_table_unset(r->headers_out, \"ETag\");\n    }\n\n    /*\n     * Control cachability for non-cacheable responses if not already set by\n     * some other part of the server configuration.\n     */\n    if (r->no_cache && !apr_table_get(r->headers_out, \"Expires\")) {\n        char *date = apr_palloc(r->pool, APR_RFC822_DATE_LEN);\n        ap_recent_rfc822_date(date, r->request_time);\n        apr_table_addn(r->headers_out, \"Expires\", date);\n    }\n\n    /* 204/304 responses don't have content related headers */\n    if (AP_STATUS_IS_HEADER_ONLY(r->status)) {\n        apr_table_unset(r->headers_out, \"Transfer-Encoding\");\n        apr_table_unset(r->headers_out, \"Content-Length\");\n        r->content_type = r->content_encoding = NULL;\n        r->content_languages = NULL;\n        r->clength = r->chunked = 0;\n    }\n\n    ctype = ap_make_content_type(r, r->content_type);\n    if (ctype) {\n        apr_table_setn(r->headers_out, \"Content-Type\", ctype);\n    }\n\n    if (r->content_encoding) {\n        apr_table_setn(r->headers_out, \"Content-Encoding\",\n                       r->content_encoding);\n    }\n\n    if (!apr_is_empty_array(r->content_languages)) {\n        int i;\n        char *token;\n        char **languages = (char **)(r->content_languages->elts);\n        const char *field = apr_table_get(r->headers_out, \"Content-Language\");\n\n        while (field && (token = ap_get_list_item(r->pool, &field)) != NULL) {\n            for (i = 0; i < r->content_languages->nelts; ++i) {\n                if (!ap_cstr_casecmp(token, languages[i]))\n                    break;\n            }\n            if (i == r->content_languages->nelts) {\n                *((char **) apr_array_push(r->content_languages)) = token;\n            }\n        }\n\n        field = apr_array_pstrcat(r->pool, r->content_languages, ',');\n        apr_table_setn(r->headers_out, \"Content-Language\", field);\n    }\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2050, column 13>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_array_header_t": {
            "name": "apr_array_header_t",
            "definition": "struct apr_array_header_t {\n    /** The pool the array is allocated out of */\n    apr_pool_t *pool;\n    /** The amount of memory allocated for each element of the array */\n    int elt_size;\n    /** The number of active elements in the array */\n    int nelts;\n    /** The number of elements allocated in the array */\n    int nalloc;\n    /** The elements in the array */\n    char *elts;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "elt_size": "int",
              "nelts": "int",
              "nalloc": "int",
              "elts": "char *"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static void fixup_vary(request_rec *r)\n{\n    apr_array_header_t *varies;\n\n    varies = apr_array_make(r->pool, 5, sizeof(char *));\n\n    /* Extract all Vary fields from the headers_out, separate each into\n     * its comma-separated fieldname values, and then add them to varies\n     * if not already present in the array.\n     */\n    apr_table_do(uniq_field_values, varies, r->headers_out, \"Vary\", NULL);\n\n    /* If we found any, replace old Vary fields with unique-ified value */\n\n    if (varies->nelts > 0) {\n        apr_table_setn(r->headers_out, \"Vary\",\n                       apr_array_pstrcat(r->pool, varies, ','));\n    }\n}"
    },
    "validate_status_line@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 966, column 21>": {
      "basic_info": {
        "function_id": 1479,
        "name": "validate_status_line",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 966, column 21>",
        "is_definition": true,
        "start_line": 966,
        "end_line": 990,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "strlen": {
            "declaration": "extern size_t strlen (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_strtoi64": {
            "declaration": "APR_DECLARE(apr_int64_t) apr_strtoi64(const char *buf, char **end, int base)",
            "is_external": true,
            "definition": null
          },
          "__ctype_b_loc": {
            "declaration": "extern const unsigned short int **__ctype_b_loc (void)\n     __THROW __attribute__ ((__const__))",
            "is_external": true,
            "definition": null
          },
          "apr_pstrcat": {
            "declaration": "APR_DECLARE_NONSTD(char *) apr_pstrcat(apr_pool_t *p, ...)\n#if defined(__GNUC__) && __GNUC__ >= 4\n    __attribute__((sentinel))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "basic_http_header_check@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 998, column 13>": {
            "source_code": "static void basic_http_header_check(request_rec *r)\n{\n    apr_status_t rv;\n\n    if (r->assbackwards) {\n        /* no such thing as a response protocol */\n        return;\n    }\n\n    rv = validate_status_line(r);\n\n    if (!r->status_line) {\n        r->status_line = ap_get_status_line(r->status);\n    } else if (rv != APR_SUCCESS) {\n        /* Status line is OK but our own reason phrase\n         * would be preferred if defined\n         */\n        const char *tmp = ap_get_status_line(r->status);\n        if (!strncmp(tmp, r->status_line, 3)) {\n            r->status_line = tmp;\n        }\n    }\n\n    /* Note that we must downgrade before checking for force responses. */\n    if (r->proto_num > HTTP_VERSION(1,0)\n        && apr_table_get(r->subprocess_env, \"downgrade-1.0\")) {\n        r->proto_num = HTTP_VERSION(1,0);\n    }\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 998, column 13>"
          }
        },
        "used_macros": {
          "_ISalnum": {
            "name": "_ISalnum",
            "value": "8",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISalnum = 8",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 59, column 3>",
            "condition": ""
          },
          "_ISalpha": {
            "name": "_ISalpha",
            "value": "1024",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISalpha = 1024",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 50, column 3>",
            "condition": ""
          },
          "_IScntrl": {
            "name": "_IScntrl",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _IScntrl = 2",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 57, column 3>",
            "condition": ""
          },
          "_ISdigit": {
            "name": "_ISdigit",
            "value": "2048",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISdigit = 2048",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 51, column 3>",
            "condition": ""
          },
          "_ISlower": {
            "name": "_ISlower",
            "value": "512",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISlower = 512",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 49, column 3>",
            "condition": ""
          },
          "_ISgraph": {
            "name": "_ISgraph",
            "value": "32768",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISgraph = 32768",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 55, column 3>",
            "condition": ""
          },
          "_ISprint": {
            "name": "_ISprint",
            "value": "16384",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISprint = 16384",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 54, column 3>",
            "condition": ""
          },
          "_ISpunct": {
            "name": "_ISpunct",
            "value": "4",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISpunct = 4",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 58, column 3>",
            "condition": ""
          },
          "_ISspace": {
            "name": "_ISspace",
            "value": "8192",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISspace = 8192",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 53, column 3>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "apr_status_t"
        ]
      },
      "source_code": "static apr_status_t validate_status_line(request_rec *r)\n{\n    char *end;\n\n    if (r->status_line) {\n        int len = strlen(r->status_line);\n        if (len < 3\n            || apr_strtoi64(r->status_line, &end, 10) != r->status\n            || (end - 3) != r->status_line\n            || (len >= 4 && ! apr_isspace(r->status_line[3]))) {\n            r->status_line = NULL;\n            return APR_EGENERAL;\n        }\n        /* Since we passed the above check, we know that length three\n         * is equivalent to only a 3 digit numeric http status.\n         * RFC2616 mandates a trailing space, let's add it.\n         */\n        if (len == 3) {\n            r->status_line = apr_pstrcat(r->pool, r->status_line, \" \", NULL);\n            return APR_EGENERAL;\n        }\n        return APR_SUCCESS;\n    }\n    return APR_EGENERAL;\n}"
    },
    "basic_http_header_check@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 998, column 13>": {
      "basic_info": {
        "function_id": 1480,
        "name": "basic_http_header_check",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 998, column 13>",
        "is_definition": true,
        "start_line": 998,
        "end_line": 1026,
        "return_type": "void",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "validate_status_line": {
            "declaration": "static apr_status_t validate_status_line(request_rec *r)\n{\n    char *end;\n\n    if (r->status_line) {\n        int len = strlen(r->status_line);\n        if (len < 3\n            || apr_strtoi64(r->status_line, &end, 10) != r->status\n            || (end - 3) != r->status_line\n            || (len >= 4 && ! apr_isspace(r->status_line[3]))) {\n            r->status_line = NULL;\n            return APR_EGENERAL;\n        }\n        /* Since we passed the above check, we know that length three\n         * is equivalent to only a 3 digit numeric http status.\n         * RFC2616 mandates a trailing space, let's add it.\n         */\n        if (len == 3) {\n            r->status_line = apr_pstrcat(r->pool, r->status_line, \" \", NULL);\n            return APR_EGENERAL;\n        }\n        return APR_SUCCESS;\n    }\n    return APR_EGENERAL;\n}",
            "is_external": false,
            "definition": "static apr_status_t validate_status_line(request_rec *r)\n{\n    char *end;\n\n    if (r->status_line) {\n        int len = strlen(r->status_line);\n        if (len < 3\n            || apr_strtoi64(r->status_line, &end, 10) != r->status\n            || (end - 3) != r->status_line\n            || (len >= 4 && ! apr_isspace(r->status_line[3]))) {\n            r->status_line = NULL;\n            return APR_EGENERAL;\n        }\n        /* Since we passed the above check, we know that length three\n         * is equivalent to only a 3 digit numeric http status.\n         * RFC2616 mandates a trailing space, let's add it.\n         */\n        if (len == 3) {\n            r->status_line = apr_pstrcat(r->pool, r->status_line, \" \", NULL);\n            return APR_EGENERAL;\n        }\n        return APR_SUCCESS;\n    }\n    return APR_EGENERAL;\n}"
          },
          "ap_get_status_line": {
            "declaration": "AP_DECLARE(const char *) ap_get_status_line(int status)",
            "is_external": false,
            "definition": "AP_DECLARE(const char *) ap_get_status_line(int status)\n{\n    return status_lines[ap_index_of_response(status)];\n}"
          },
          "strncmp": {
            "declaration": "extern int strncmp (const char *__s1, const char *__s2, size_t __n)\n     __THROW __attribute_pure__ __nonnull ((1, 2))",
            "is_external": true,
            "definition": null
          },
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_basic_http_header@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1028, column 18>": {
            "source_code": "AP_DECLARE(void) ap_basic_http_header(request_rec *r, apr_bucket_brigade *bb)\n{\n    apr_bucket *b;\n\n    basic_http_header_check(r);\n    b = create_response_bucket(r, bb->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1028, column 18>"
          },
          "merge_response_headers@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2050, column 13>": {
            "source_code": "static void merge_response_headers(request_rec *r)\n{\n    const char *ctype;\n\n    /*\n     * Now that we are ready to send a response, we need to combine the two\n     * header field tables into a single table.  If we don't do this, our\n     * later attempts to set or unset a given fieldname might be bypassed.\n     */\n    if (!apr_is_empty_table(r->err_headers_out)) {\n        r->headers_out = apr_table_overlay(r->pool, r->err_headers_out,\n                                           r->headers_out);\n        apr_table_clear(r->err_headers_out);\n    }\n\n    ap_set_std_response_headers(r);\n\n    /*\n     * Remove the 'Vary' header field if the client can't handle it.\n     * Since this will have nasty effects on HTTP/1.1 caches, force\n     * the response into HTTP/1.0 mode.\n     *\n     * Note: the force-response-1.0 should come before the call to\n     *       basic_http_header_check()\n     */\n    if (apr_table_get(r->subprocess_env, \"force-no-vary\") != NULL) {\n        apr_table_unset(r->headers_out, \"Vary\");\n        r->proto_num = HTTP_VERSION(1,0);\n        apr_table_setn(r->subprocess_env, \"force-response-1.0\", \"1\");\n    }\n    else {\n        fixup_vary(r);\n    }\n\n    /* Determine the protocol and whether we should use keepalives. */\n    basic_http_header_check(r);\n\n    /*\n     * Now remove any ETag response header field if earlier processing\n     * says so (such as a 'FileETag None' directive).\n     */\n    if (apr_table_get(r->notes, \"no-etag\") != NULL) {\n        apr_table_unset(r->headers_out, \"ETag\");\n    }\n\n    /*\n     * Control cachability for non-cacheable responses if not already set by\n     * some other part of the server configuration.\n     */\n    if (r->no_cache && !apr_table_get(r->headers_out, \"Expires\")) {\n        char *date = apr_palloc(r->pool, APR_RFC822_DATE_LEN);\n        ap_recent_rfc822_date(date, r->request_time);\n        apr_table_addn(r->headers_out, \"Expires\", date);\n    }\n\n    /* 204/304 responses don't have content related headers */\n    if (AP_STATUS_IS_HEADER_ONLY(r->status)) {\n        apr_table_unset(r->headers_out, \"Transfer-Encoding\");\n        apr_table_unset(r->headers_out, \"Content-Length\");\n        r->content_type = r->content_encoding = NULL;\n        r->content_languages = NULL;\n        r->clength = r->chunked = 0;\n    }\n\n    ctype = ap_make_content_type(r, r->content_type);\n    if (ctype) {\n        apr_table_setn(r->headers_out, \"Content-Type\", ctype);\n    }\n\n    if (r->content_encoding) {\n        apr_table_setn(r->headers_out, \"Content-Encoding\",\n                       r->content_encoding);\n    }\n\n    if (!apr_is_empty_array(r->content_languages)) {\n        int i;\n        char *token;\n        char **languages = (char **)(r->content_languages->elts);\n        const char *field = apr_table_get(r->headers_out, \"Content-Language\");\n\n        while (field && (token = ap_get_list_item(r->pool, &field)) != NULL) {\n            for (i = 0; i < r->content_languages->nelts; ++i) {\n                if (!ap_cstr_casecmp(token, languages[i]))\n                    break;\n            }\n            if (i == r->content_languages->nelts) {\n                *((char **) apr_array_push(r->content_languages)) = token;\n            }\n        }\n\n        field = apr_array_pstrcat(r->pool, r->content_languages, ',');\n        apr_table_setn(r->headers_out, \"Content-Language\", field);\n    }\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2050, column 13>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "apr_status_t"
        ]
      },
      "source_code": "static void basic_http_header_check(request_rec *r)\n{\n    apr_status_t rv;\n\n    if (r->assbackwards) {\n        /* no such thing as a response protocol */\n        return;\n    }\n\n    rv = validate_status_line(r);\n\n    if (!r->status_line) {\n        r->status_line = ap_get_status_line(r->status);\n    } else if (rv != APR_SUCCESS) {\n        /* Status line is OK but our own reason phrase\n         * would be preferred if defined\n         */\n        const char *tmp = ap_get_status_line(r->status);\n        if (!strncmp(tmp, r->status_line, 3)) {\n            r->status_line = tmp;\n        }\n    }\n\n    /* Note that we must downgrade before checking for force responses. */\n    if (r->proto_num > HTTP_VERSION(1,0)\n        && apr_table_get(r->subprocess_env, \"downgrade-1.0\")) {\n        r->proto_num = HTTP_VERSION(1,0);\n    }\n}"
    },
    "ap_basic_http_header@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1028, column 18>": {
      "basic_info": {
        "function_id": 1481,
        "name": "ap_basic_http_header",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1028, column 18>",
        "is_definition": true,
        "start_line": 1028,
        "end_line": 1035,
        "return_type": "void",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "bb",
            "type": "apr_bucket_brigade *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "basic_http_header_check": {
            "declaration": "static void basic_http_header_check(request_rec *r)\n{\n    apr_status_t rv;\n\n    if (r->assbackwards) {\n        /* no such thing as a response protocol */\n        return;\n    }\n\n    rv = validate_status_line(r);\n\n    if (!r->status_line) {\n        r->status_line = ap_get_status_line(r->status);\n    } else if (rv != APR_SUCCESS) {\n        /* Status line is OK but our own reason phrase\n         * would be preferred if defined\n         */\n        const char *tmp = ap_get_status_line(r->status);\n        if (!strncmp(tmp, r->status_line, 3)) {\n            r->status_line = tmp;\n        }\n    }\n\n    /* Note that we must downgrade before checking for force responses. */\n    if (r->proto_num > HTTP_VERSION(1,0)\n        && apr_table_get(r->subprocess_env, \"downgrade-1.0\")) {\n        r->proto_num = HTTP_VERSION(1,0);\n    }\n}",
            "is_external": false,
            "definition": "static void basic_http_header_check(request_rec *r)\n{\n    apr_status_t rv;\n\n    if (r->assbackwards) {\n        /* no such thing as a response protocol */\n        return;\n    }\n\n    rv = validate_status_line(r);\n\n    if (!r->status_line) {\n        r->status_line = ap_get_status_line(r->status);\n    } else if (rv != APR_SUCCESS) {\n        /* Status line is OK but our own reason phrase\n         * would be preferred if defined\n         */\n        const char *tmp = ap_get_status_line(r->status);\n        if (!strncmp(tmp, r->status_line, 3)) {\n            r->status_line = tmp;\n        }\n    }\n\n    /* Note that we must downgrade before checking for force responses. */\n    if (r->proto_num > HTTP_VERSION(1,0)\n        && apr_table_get(r->subprocess_env, \"downgrade-1.0\")) {\n        r->proto_num = HTTP_VERSION(1,0);\n    }\n}"
          },
          "create_response_bucket": {
            "declaration": "static apr_bucket *create_response_bucket(request_rec *r, apr_bucket_alloc_t *bucket_alloc)",
            "is_external": false,
            "definition": "static apr_bucket *create_response_bucket(request_rec *r, apr_bucket_alloc_t *bucket_alloc)\n{\n    /* r->headers_out fully prepared. Create a headers bucket\n     * containing the response to send down the filter chain.\n     */\n    return ap_bucket_response_create(r->status, get_status_reason(r->status_line),\n                                     r->headers_out, r->notes, r->pool, bucket_alloc);\n}"
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(void) ap_basic_http_header(request_rec *r, apr_bucket_brigade *bb)\n{\n    apr_bucket *b;\n\n    basic_http_header_check(r);\n    b = create_response_bucket(r, bb->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, b);\n}"
    },
    "ap_send_http_trace@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1037, column 24>": {
      "basic_info": {
        "function_id": 1482,
        "name": "ap_send_http_trace",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1037, column 24>",
        "is_definition": true,
        "start_line": 1037,
        "end_line": 1151,
        "return_type": "int",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_table_setn": {
            "declaration": "APR_DECLARE(void) apr_table_setn(apr_table_t *t, const char *key,\n                                 const char *val)",
            "is_external": true,
            "definition": null
          },
          "ap_setup_client_block": {
            "declaration": "AP_DECLARE(int) ap_setup_client_block(request_rec *r, int read_policy)",
            "is_external": false,
            "definition": "AP_DECLARE(int) ap_setup_client_block(request_rec *r, int read_policy)\n{\n    const char *lenp = apr_table_get(r->headers_in, \"Content-Length\");\n    apr_off_t limit_req_body = ap_get_limit_req_body(r);\n\n    r->read_body = read_policy;\n    r->read_chunked = 0;\n    r->remaining = 0;\n\n    if (r->body_indeterminate) {\n        /* Protocols like HTTP/2 can carry bodies without length and\n         * HTTP/1.1 has chunked encoding signalled via this note.\n         */\n        if (r->read_body == REQUEST_CHUNKED_ERROR) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01593)\n                          \"indeterminate request body length forbidden: %s\", r->uri);\n            r->read_chunked = 0;\n            return (lenp) ? HTTP_BAD_REQUEST : HTTP_LENGTH_REQUIRED;\n        }\n        r->read_chunked = 1;\n    }\n    else if (lenp) {\n        if (!ap_parse_strict_length(&r->remaining, lenp)) {\n            r->remaining = 0;\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01594)\n                          \"Invalid Content-Length '%s'\", lenp);\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    if ((r->read_body == REQUEST_NO_BODY)\n        && (r->read_chunked || (r->remaining > 0))) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01595)\n                      \"%s with body is not allowed for %s\", r->method, r->uri);\n        return HTTP_REQUEST_ENTITY_TOO_LARGE;\n    }\n\n    if (limit_req_body > 0 && (r->remaining > limit_req_body)) {\n        /* 01588 msg in HTTP_IN filter will be skipped for a connection-dropping status,\n         * in r->status, so log a similar message here.\n         */\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(10483)\n                \"Requested content-length of %\" APR_OFF_T_FMT\n                \" is larger than the configured limit\"\n                \" of %\" APR_OFF_T_FMT, r->remaining, limit_req_body);\n\n        return HTTP_REQUEST_ENTITY_TOO_LARGE;\n    }\n\n#ifdef AP_DEBUG\n    {\n        /* Make sure ap_getline() didn't leave any droppings. */\n        core_request_config *req_cfg =\n            (core_request_config *)ap_get_core_module_config(r->request_config);\n        AP_DEBUG_ASSERT(APR_BRIGADE_EMPTY(req_cfg->bb));\n    }\n#endif\n\n    return OK;\n}"
          },
          "ap_should_client_block": {
            "declaration": "AP_DECLARE(int) ap_should_client_block(request_rec *r)",
            "is_external": false,
            "definition": "AP_DECLARE(int) ap_should_client_block(request_rec *r)\n{\n    /* First check if we have already read the request body */\n\n    if (r->read_length || (!r->read_chunked && (r->remaining <= 0))) {\n        return 0;\n    }\n\n    return 1;\n}"
          },
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "ap_get_client_block": {
            "declaration": "AP_DECLARE(long) ap_get_client_block(request_rec *r, char *buffer, apr_size_t bufsiz)",
            "is_external": false,
            "definition": "AP_DECLARE(long) ap_get_client_block(request_rec *r, char *buffer,\n                                     apr_size_t bufsiz)\n{\n    apr_status_t rv;\n    apr_bucket_brigade *bb;\n\n    if (r->remaining < 0 || (!r->read_chunked && r->remaining == 0)) {\n        return 0;\n    }\n\n    bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    if (bb == NULL) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n        return -1;\n    }\n\n    rv = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,\n                        APR_BLOCK_READ, bufsiz);\n\n    /* We lose the failure code here.  This is why ap_get_client_block should\n     * not be used.\n     */\n    if (rv == AP_FILTER_ERROR) {\n        /* AP_FILTER_ERROR means a filter has responded already,\n         * we are DONE.\n         */\n        apr_brigade_destroy(bb);\n        return -1;\n    }\n    if (rv != APR_SUCCESS) {\n        apr_bucket *e;\n\n        /* work around our silent swallowing of error messages by mapping\n         * error codes at this point, and sending an error bucket back\n         * upstream.\n         */\n        apr_brigade_cleanup(bb);\n\n        e = ap_bucket_error_create(\n                ap_map_http_request_error(rv, HTTP_BAD_REQUEST), NULL, r->pool,\n                r->connection->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n\n        e = apr_bucket_eos_create(r->connection->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n\n        rv = ap_pass_brigade(r->output_filters, bb);\n        if (APR_SUCCESS != rv) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, r, APLOGNO(02484)\n                          \"Error while writing error response\");\n        }\n\n        /* if we actually fail here, we want to just return and\n         * stop trying to read data from the client.\n         */\n        r->connection->keepalive = AP_CONN_CLOSE;\n        apr_brigade_destroy(bb);\n        return -1;\n    }\n\n    /* If this fails, it means that a filter is written incorrectly and that\n     * it needs to learn how to properly handle APR_BLOCK_READ requests by\n     * returning data when requested.\n     */\n    AP_DEBUG_ASSERT(!APR_BRIGADE_EMPTY(bb));\n\n    /* Check to see if EOS in the brigade.\n     *\n     * If so, we have to leave a nugget for the *next* ap_get_client_block\n     * call to return 0.\n     */\n    if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {\n        if (r->read_chunked) {\n            r->remaining = -1;\n        }\n        else {\n            r->remaining = 0;\n        }\n    }\n\n    rv = apr_brigade_flatten(bb, buffer, &bufsiz);\n    if (rv != APR_SUCCESS) {\n        apr_brigade_destroy(bb);\n        return -1;\n    }\n\n    /* XXX yank me? */\n    r->read_length += bufsiz;\n\n    apr_brigade_destroy(bb);\n    return bufsiz;\n}"
          },
          "ap_set_content_type_ex": {
            "declaration": "AP_DECLARE(void) ap_set_content_type_ex(request_rec *r, const char *ct, int trusted)",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_set_content_type_ex(request_rec *r, const char *ct, int trusted)\n{\n    ap_set_content_type(r, ct);\n    AP_REQUEST_SET_BNOTE(r, AP_REQUEST_TRUSTED_CT, trusted ? AP_REQUEST_TRUSTED_CT : 0);\n}"
          },
          "apr_brigade_create": {
            "declaration": "APU_DECLARE(apr_bucket_brigade *) apr_brigade_create(apr_pool_t *p,\n                                                     apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_putstrs": {
            "declaration": "APU_DECLARE_NONSTD(apr_status_t) apr_brigade_putstrs(apr_bucket_brigade *b,\n                                                     apr_brigade_flush flush,\n                                                     void *ctx, ...)",
            "is_external": true,
            "definition": null
          },
          "apr_table_do": {
            "declaration": "APR_DECLARE_NONSTD(int) apr_table_do(apr_table_do_callback_fn_t *comp,\n                                     void *rec, const apr_table_t *t, ...)\n#if defined(__GNUC__) && __GNUC__ >= 4\n    __attribute__((sentinel))",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_puts": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_puts(apr_bucket_brigade *bb,\n                                           apr_brigade_flush flush, void *ctx,\n                                           const char *str)",
            "is_external": true,
            "definition": null
          },
          "apr_bucket_pool_create": {
            "declaration": "APU_DECLARE(apr_bucket *) apr_bucket_pool_create(const char *buf, \n                                                 apr_size_t length,\n                                                 apr_pool_t *pool,\n                                                 apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "ap_pass_brigade": {
            "declaration": "AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *filter,\n                                         apr_bucket_brigade *bucket)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "core_server_config": {
            "name": "core_server_config",
            "definition": "struct {\n\n    char *gprof_dir;\n\n    /* Name translations --- we want the core to be able to do *something*\n     * so it's at least a minimally functional web server on its own (and\n     * can be tested that way).  But let's keep it to the bare minimum:\n     */\n    const char *ap_document_root;\n\n    /* Access control */\n\n    char *access_name;\n    apr_array_header_t *sec_dir;\n    apr_array_header_t *sec_url;\n\n    /* recursion backstopper */\n    int redirect_limit; /* maximum number of internal redirects */\n    int subreq_limit;   /* maximum nesting level of subrequests */\n\n    const char *protocol;\n    apr_table_t *accf_map;\n\n    /* array of ap_errorlog_format_item for error log format string */\n    apr_array_header_t *error_log_format;\n    /*\n     * two arrays of arrays of ap_errorlog_format_item for additional information\n     * logged to the error log once per connection/request\n     */\n    apr_array_header_t *error_log_conn;\n    apr_array_header_t *error_log_req;\n\n    /* TRACE control */\n#define AP_TRACE_UNSET    -1\n#define AP_TRACE_DISABLE   0\n#define AP_TRACE_ENABLE    1\n#define AP_TRACE_EXTENDED  2\n    int trace_enable;\n#define AP_MERGE_TRAILERS_UNSET    0\n#define AP_MERGE_TRAILERS_ENABLE   1\n#define AP_MERGE_TRAILERS_DISABLE  2\n    int merge_trailers;\n\n    apr_array_header_t *protocols;\n    int protocols_honor_order;\n\n#define AP_HTTP09_UNSET   0\n#define AP_HTTP09_ENABLE  1\n#define AP_HTTP09_DISABLE 2\n    char http09_enable;\n\n#define AP_HTTP_CONFORMANCE_UNSET     0\n#define AP_HTTP_CONFORMANCE_UNSAFE    1\n#define AP_HTTP_CONFORMANCE_STRICT    2\n    char http_conformance;\n\n#define AP_HTTP_METHODS_UNSET         0\n#define AP_HTTP_METHODS_LENIENT       1\n#define AP_HTTP_METHODS_REGISTERED    2\n    char http_methods;\n    unsigned int merge_slashes;\n \n    apr_size_t   flush_max_threshold;\n    apr_int32_t  flush_max_pipelined;\n    unsigned int strict_host_check;\n#ifdef WIN32\n    apr_array_header_t *unc_list;\n#endif\n}",
            "typedef_name": null,
            "fields": {
              "gprof_dir": "char *",
              "ap_document_root": "const char *",
              "access_name": "char *",
              "sec_dir": "apr_array_header_t *",
              "sec_url": "apr_array_header_t *",
              "redirect_limit": "int",
              "subreq_limit": "int",
              "protocol": "const char *",
              "accf_map": "apr_table_t *",
              "error_log_format": "apr_array_header_t *",
              "error_log_conn": "apr_array_header_t *",
              "error_log_req": "apr_array_header_t *",
              "trace_enable": "int",
              "merge_trailers": "int",
              "protocols": "apr_array_header_t *",
              "protocols_honor_order": "int",
              "http09_enable": "char",
              "http_conformance": "char",
              "http_methods": "char",
              "merge_slashes": "unsigned int",
              "flush_max_threshold": "apr_size_t",
              "flush_max_pipelined": "apr_int32_t",
              "strict_host_check": "unsigned int"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "header_struct": {
            "name": "header_struct",
            "definition": "struct header_struct {\n    apr_pool_t *pool;\n    apr_bucket_brigade *bb;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "bb": "apr_bucket_brigade *"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "apr_size_t"
        ]
      },
      "source_code": "AP_DECLARE_NONSTD(int) ap_send_http_trace(request_rec *r)\n{\n    core_server_config *conf;\n    int rv;\n    apr_bucket_brigade *bb;\n    header_struct h;\n    apr_bucket *b;\n    int body;\n    char *bodyread = NULL, *bodyoff;\n    apr_size_t bodylen = 0;\n    apr_size_t bodybuf;\n    long res = -1; /* init to avoid gcc -Wall warning */\n\n    if (r->method_number != M_TRACE) {\n        return DECLINED;\n    }\n\n    /* Get the original request */\n    while (r->prev) {\n        r = r->prev;\n    }\n    conf = ap_get_core_module_config(r->server->module_config);\n\n    if (conf->trace_enable == AP_TRACE_DISABLE) {\n        apr_table_setn(r->notes, \"error-notes\",\n                      \"TRACE denied by server configuration\");\n        return HTTP_METHOD_NOT_ALLOWED;\n    }\n\n    if (conf->trace_enable == AP_TRACE_EXTENDED)\n        /* XXX: should be = REQUEST_CHUNKED_PASS */\n        body = REQUEST_CHUNKED_DECHUNK;\n    else\n        body = REQUEST_NO_BODY;\n\n    if ((rv = ap_setup_client_block(r, body))) {\n        if (rv == HTTP_REQUEST_ENTITY_TOO_LARGE)\n            apr_table_setn(r->notes, \"error-notes\",\n                          \"TRACE with a request body is not allowed\");\n        return rv;\n    }\n\n    if (ap_should_client_block(r)) {\n\n        if (r->remaining > 0) {\n            if (r->remaining > 65536) {\n                apr_table_setn(r->notes, \"error-notes\",\n                       \"Extended TRACE request bodies cannot exceed 64k\\n\");\n                return HTTP_REQUEST_ENTITY_TOO_LARGE;\n            }\n            /* always 32 extra bytes to catch chunk header exceptions */\n            bodybuf = (apr_size_t)r->remaining + 32;\n        }\n        else {\n            /* Add an extra 8192 for chunk headers */\n            bodybuf = 73730;\n        }\n\n        bodyoff = bodyread = apr_palloc(r->pool, bodybuf);\n\n        /* only while we have enough for a chunked header */\n        while ((!bodylen || bodybuf >= 32) &&\n               (res = ap_get_client_block(r, bodyoff, bodybuf)) > 0) {\n            bodylen += res;\n            bodybuf -= res;\n            bodyoff += res;\n        }\n        if (res > 0 && bodybuf < 32) {\n            /* discard_rest_of_request_body into our buffer */\n            while (ap_get_client_block(r, bodyread, bodylen) > 0)\n                ;\n            apr_table_setn(r->notes, \"error-notes\",\n                   \"Extended TRACE request bodies cannot exceed 64k\\n\");\n            return HTTP_REQUEST_ENTITY_TOO_LARGE;\n        }\n\n        if (res < 0) {\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    ap_set_content_type_ex(r, \"message/http\", 1);\n\n    /* Now we recreate the request, and echo it back */\n\n    bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n#if APR_CHARSET_EBCDIC\n    {\n        char *tmp;\n        apr_size_t len;\n        len = strlen(r->the_request);\n        tmp = apr_pmemdup(r->pool, r->the_request, len);\n        ap_xlate_proto_to_ascii(tmp, len);\n        apr_brigade_putstrs(bb, NULL, NULL, tmp, CRLF_ASCII, NULL);\n    }\n#else\n    apr_brigade_putstrs(bb, NULL, NULL, r->the_request, CRLF, NULL);\n#endif\n    h.pool = r->pool;\n    h.bb = bb;\n    apr_table_do((int (*) (void *, const char *, const char *))\n                 form_header_field, (void *) &h, r->headers_in, NULL);\n    apr_brigade_puts(bb, NULL, NULL, CRLF_ASCII);\n\n    /* If configured to accept a body, echo the body */\n    if (bodylen) {\n        b = apr_bucket_pool_create(bodyread, bodylen,\n                                   r->pool, bb->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, b);\n    }\n\n    ap_pass_brigade(r->output_filters,  bb);\n\n    return DONE;\n}"
    },
    "ap_http_header_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1159, column 38>": {
      "basic_info": {
        "function_id": 1483,
        "name": "ap_http_header_filter",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1159, column 38>",
        "is_definition": true,
        "start_line": 1159,
        "end_line": 1386,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "f",
            "type": "ap_filter_t *"
          },
          {
            "name": "b",
            "type": "apr_bucket_brigade *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "memset": {
            "declaration": "extern void *memset (void *__s, int __c, size_t __n) __THROW __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "AP_BUCKET_IS_RESPONSE": {
            "declaration": "AP_BUCKET_IS_RESPONSE(e)",
            "is_external": true,
            "definition": null
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "merge_response_headers": {
            "declaration": "static void merge_response_headers(request_rec *r)",
            "is_external": false,
            "definition": "static void merge_response_headers(request_rec *r)\n{\n    const char *ctype;\n\n    /*\n     * Now that we are ready to send a response, we need to combine the two\n     * header field tables into a single table.  If we don't do this, our\n     * later attempts to set or unset a given fieldname might be bypassed.\n     */\n    if (!apr_is_empty_table(r->err_headers_out)) {\n        r->headers_out = apr_table_overlay(r->pool, r->err_headers_out,\n                                           r->headers_out);\n        apr_table_clear(r->err_headers_out);\n    }\n\n    ap_set_std_response_headers(r);\n\n    /*\n     * Remove the 'Vary' header field if the client can't handle it.\n     * Since this will have nasty effects on HTTP/1.1 caches, force\n     * the response into HTTP/1.0 mode.\n     *\n     * Note: the force-response-1.0 should come before the call to\n     *       basic_http_header_check()\n     */\n    if (apr_table_get(r->subprocess_env, \"force-no-vary\") != NULL) {\n        apr_table_unset(r->headers_out, \"Vary\");\n        r->proto_num = HTTP_VERSION(1,0);\n        apr_table_setn(r->subprocess_env, \"force-response-1.0\", \"1\");\n    }\n    else {\n        fixup_vary(r);\n    }\n\n    /* Determine the protocol and whether we should use keepalives. */\n    basic_http_header_check(r);\n\n    /*\n     * Now remove any ETag response header field if earlier processing\n     * says so (such as a 'FileETag None' directive).\n     */\n    if (apr_table_get(r->notes, \"no-etag\") != NULL) {\n        apr_table_unset(r->headers_out, \"ETag\");\n    }\n\n    /*\n     * Control cachability for non-cacheable responses if not already set by\n     * some other part of the server configuration.\n     */\n    if (r->no_cache && !apr_table_get(r->headers_out, \"Expires\")) {\n        char *date = apr_palloc(r->pool, APR_RFC822_DATE_LEN);\n        ap_recent_rfc822_date(date, r->request_time);\n        apr_table_addn(r->headers_out, \"Expires\", date);\n    }\n\n    /* 204/304 responses don't have content related headers */\n    if (AP_STATUS_IS_HEADER_ONLY(r->status)) {\n        apr_table_unset(r->headers_out, \"Transfer-Encoding\");\n        apr_table_unset(r->headers_out, \"Content-Length\");\n        r->content_type = r->content_encoding = NULL;\n        r->content_languages = NULL;\n        r->clength = r->chunked = 0;\n    }\n\n    ctype = ap_make_content_type(r, r->content_type);\n    if (ctype) {\n        apr_table_setn(r->headers_out, \"Content-Type\", ctype);\n    }\n\n    if (r->content_encoding) {\n        apr_table_setn(r->headers_out, \"Content-Encoding\",\n                       r->content_encoding);\n    }\n\n    if (!apr_is_empty_array(r->content_languages)) {\n        int i;\n        char *token;\n        char **languages = (char **)(r->content_languages->elts);\n        const char *field = apr_table_get(r->headers_out, \"Content-Language\");\n\n        while (field && (token = ap_get_list_item(r->pool, &field)) != NULL) {\n            for (i = 0; i < r->content_languages->nelts; ++i) {\n                if (!ap_cstr_casecmp(token, languages[i]))\n                    break;\n            }\n            if (i == r->content_languages->nelts) {\n                *((char **) apr_array_push(r->content_languages)) = token;\n            }\n        }\n\n        field = apr_array_pstrcat(r->pool, r->content_languages, ',');\n        apr_table_setn(r->headers_out, \"Content-Language\", field);\n    }\n}"
          },
          "check_headers": {
            "declaration": "static APR_INLINE int check_headers(request_rec *r)\n{\n    struct check_header_ctx ctx;\n    core_server_config *conf =\n            ap_get_core_module_config(r->server->module_config);\n    const char *val;\n \n    if ((val = apr_table_get(r->headers_out, \"Transfer-Encoding\"))) {\n        if (apr_table_get(r->headers_out, \"Content-Length\")) {\n            apr_table_unset(r->headers_out, \"Content-Length\");\n            r->connection->keepalive = AP_CONN_CLOSE;\n        }\n        if (!ap_is_chunked(r->pool, val)) {\n            r->connection->keepalive = AP_CONN_CLOSE;\n            return 0;\n        }\n    }\n\n    ctx.r = r;\n    ctx.strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n    return check_headers_table(r->headers_out, &ctx) &&\n           check_headers_table(r->err_headers_out, &ctx);\n}",
            "is_external": false,
            "definition": "static APR_INLINE int check_headers(request_rec *r)\n{\n    struct check_header_ctx ctx;\n    core_server_config *conf =\n            ap_get_core_module_config(r->server->module_config);\n    const char *val;\n \n    if ((val = apr_table_get(r->headers_out, \"Transfer-Encoding\"))) {\n        if (apr_table_get(r->headers_out, \"Content-Length\")) {\n            apr_table_unset(r->headers_out, \"Content-Length\");\n            r->connection->keepalive = AP_CONN_CLOSE;\n        }\n        if (!ap_is_chunked(r->pool, val)) {\n            r->connection->keepalive = AP_CONN_CLOSE;\n            return 0;\n        }\n    }\n\n    ctx.r = r;\n    ctx.strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n    return check_headers_table(r->headers_out, &ctx) &&\n           check_headers_table(r->err_headers_out, &ctx);\n}"
          },
          "apr_table_clear": {
            "declaration": "APR_DECLARE(void) apr_table_clear(apr_table_t *t)",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_cleanup": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_cleanup(void *data)",
            "is_external": true,
            "definition": null
          },
          "check_headers_recursion": {
            "declaration": "static int check_headers_recursion(request_rec *r)\n{\n    void *check = NULL;\n    apr_pool_userdata_get(&check, \"check_headers_recursion\", r->pool);\n    if (check) {\n        return 1;\n    }\n    apr_pool_userdata_setn(\"true\", \"check_headers_recursion\", NULL, r->pool);\n    return 0;\n}",
            "is_external": false,
            "definition": "static int check_headers_recursion(request_rec *r)\n{\n    void *check = NULL;\n    apr_pool_userdata_get(&check, \"check_headers_recursion\", r->pool);\n    if (check) {\n        return 1;\n    }\n    apr_pool_userdata_setn(\"true\", \"check_headers_recursion\", NULL, r->pool);\n    return 0;\n}"
          },
          "ap_die": {
            "declaration": "AP_DECLARE(void) ap_die(int type, request_rec *r)",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_die(int type, request_rec *r)\n{\n    ap_die_r(type, r, r->status);\n}"
          },
          "ap_bucket_eoc_create": {
            "declaration": "AP_DECLARE(apr_bucket *) ap_bucket_eoc_create(apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "apr_bucket_eos_create": {
            "declaration": "APU_DECLARE(apr_bucket *) apr_bucket_eos_create(apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "ap_set_content_length": {
            "declaration": "AP_DECLARE(void) ap_set_content_length(request_rec *r, apr_off_t length)",
            "is_external": true,
            "definition": null
          },
          "create_response_bucket": {
            "declaration": "static apr_bucket *create_response_bucket(request_rec *r, apr_bucket_alloc_t *bucket_alloc)",
            "is_external": false,
            "definition": "static apr_bucket *create_response_bucket(request_rec *r, apr_bucket_alloc_t *bucket_alloc)\n{\n    /* r->headers_out fully prepared. Create a headers bucket\n     * containing the response to send down the filter chain.\n     */\n    return ap_bucket_response_create(r->status, get_status_reason(r->status_line),\n                                     r->headers_out, r->notes, r->pool, bucket_alloc);\n}"
          },
          "destroy": {
            "declaration": "apr_bucket_delete(e)",
            "is_external": true,
            "definition": null
          },
          "free": {
            "declaration": "void (*free)(void *e)",
            "is_external": true,
            "definition": null
          },
          "ap_remove_output_filter": {
            "declaration": "AP_DECLARE(void) ap_remove_output_filter(ap_filter_t *f)",
            "is_external": true,
            "definition": null
          },
          "ap_pass_brigade": {
            "declaration": "AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *filter,\n                                         apr_bucket_brigade *bucket)",
            "is_external": true,
            "definition": null
          },
          "create_trailers_bucket": {
            "declaration": "static apr_bucket *create_trailers_bucket(request_rec *r, apr_bucket_alloc_t *bucket_alloc)",
            "is_external": false,
            "definition": "static apr_bucket *create_trailers_bucket(request_rec *r, apr_bucket_alloc_t *bucket_alloc)\n{\n    if (r->trailers_out && !apr_is_empty_table(r->trailers_out)) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, \"sending trailers\");\n        return ap_bucket_headers_create(r->trailers_out, r->pool, bucket_alloc);\n    }\n    return NULL;\n}"
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "ap_filter_t": {
            "name": "ap_filter_t",
            "definition": "struct ap_filter_t {\n    /** The internal representation of this filter.  This includes\n     *  the filter's name, type, and the actual function pointer.\n     */\n    ap_filter_rec_t *frec;\n\n    /** A place to store any data associated with the current filter */\n    void *ctx;\n\n    /** The next filter in the chain */\n    ap_filter_t *next;\n\n    /** The request_rec associated with the current filter.  If a sub-request\n     *  adds filters, then the sub-request is the request associated with the\n     *  filter.\n     */\n    request_rec *r;\n\n    /** The conn_rec associated with the current filter.  This is analogous\n     *  to the request_rec, except that it is used for connection filters.\n     */\n    conn_rec *c;\n}",
            "typedef_name": null,
            "fields": {
              "frec": "ap_filter_rec_t *",
              "ctx": "void *",
              "next": "ap_filter_t *",
              "r": "request_rec *",
              "c": "conn_rec *"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "conn_rec": {
            "name": "conn_rec",
            "definition": "struct conn_rec {\n    /** Pool associated with this connection */\n    apr_pool_t *pool;\n    /** Physical vhost this conn came in on */\n    server_rec *base_server;\n    /** used by http_vhost.c */\n    void *vhost_lookup_data;\n\n    /* Information about the connection itself */\n    /** local address */\n    apr_sockaddr_t *local_addr;\n    /** remote address; this is the end-point of the next hop, for the address\n     *  of the request creator, see useragent_addr in request_rec\n     */\n    apr_sockaddr_t *client_addr;\n\n    /** Client's IP address; this is the end-point of the next hop, for the\n     *  IP of the request creator, see useragent_ip in request_rec\n     */\n    char *client_ip;\n    /** Client's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     * get_remote_host() */\n    char *remote_host;\n    /** Only ever set if doing rfc1413 lookups.  N.B. Only access this through\n     *  get_remote_logname() */\n    char *remote_logname;\n\n    /** server IP address */\n    char *local_ip;\n    /** used for ap_get_server_name when UseCanonicalName is set to DNS\n     *  (ignores setting of HostnameLookups) */\n    char *local_host;\n\n    /** ID of this connection; unique at any point in time */\n    long id;\n    /** Config vector containing pointers to connections per-server\n     *  config structures. */\n    struct ap_conf_vector_t *conn_config;\n    /** Notes on *this* connection: send note from one module to\n     *  another. must remain valid for all requests on this conn */\n    apr_table_t *notes;\n    /** A list of input filters to be used for this connection */\n    struct ap_filter_t *input_filters;\n    /** A list of output filters to be used for this connection */\n    struct ap_filter_t *output_filters;\n    /** handle to scoreboard information for this connection */\n    void *sbh;\n    /** The bucket allocator to use for all bucket/brigade creations */\n    struct apr_bucket_alloc_t *bucket_alloc;\n    /** The current state of this connection; may be NULL if not used by MPM */\n    conn_state_t *cs;\n    /** Is there data pending in the input filters? */\n    int data_in_input_filters;\n    /** Is there data pending in the output filters? */\n    int data_in_output_filters;\n\n    /** Are there any filters that clogg/buffer the input stream, breaking\n     *  the event mpm.\n     */\n    unsigned int clogging_input_filters:1;\n\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success */\n    signed int double_reverse:2;\n\n    /** Are we still talking? */\n    unsigned aborted;\n\n    /** Are we going to keep the connection alive for another request?\n     * @see ap_conn_keepalive_e */\n    ap_conn_keepalive_e keepalive;\n\n    /** How many times have we used it? */\n    int keepalives;\n\n    /** Optional connection log level configuration. May point to a server or\n     *  per_dir config, i.e. must be copied before modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify this connection in error log. Set when the first\n     *  error log entry for this connection is generated.\n     */\n    const char *log_id;\n\n\n    /** This points to the current thread being used to process this request,\n     * over the lifetime of a request, the value may change. Users of the connection\n     * record should not rely upon it staying the same between calls that involve\n     * the MPM.\n     */\n#if APR_HAS_THREADS\n    apr_thread_t *current_thread;\n#endif\n\n    /** The \"real\" master connection. NULL if I am the master. */\n    conn_rec *master;\n\n    int outgoing;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "base_server": "server_rec *",
              "vhost_lookup_data": "void *",
              "local_addr": "apr_sockaddr_t *",
              "client_addr": "apr_sockaddr_t *",
              "client_ip": "char *",
              "remote_host": "char *",
              "remote_logname": "char *",
              "local_ip": "char *",
              "local_host": "char *",
              "id": "long",
              "conn_config": "struct ap_conf_vector_t *",
              "notes": "apr_table_t *",
              "input_filters": "struct ap_filter_t *",
              "output_filters": "struct ap_filter_t *",
              "sbh": "void *",
              "bucket_alloc": "struct apr_bucket_alloc_t *",
              "cs": "conn_state_t *",
              "data_in_input_filters": "int",
              "data_in_output_filters": "int",
              "clogging_input_filters": "unsigned int",
              "double_reverse": "int",
              "aborted": "unsigned int",
              "keepalive": "ap_conn_keepalive_e",
              "keepalives": "int",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "current_thread": "apr_thread_t *",
              "master": "conn_rec *",
              "outgoing": "int"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "header_filter_ctx": {
            "name": "header_filter_ctx",
            "definition": "struct header_filter_ctx {\n    int final_status;\n    int final_header_only;\n    int dying;\n}",
            "typedef_name": null,
            "fields": {
              "final_status": "int",
              "final_header_only": "int",
              "dying": "int"
            },
            "condition": ""
          },
          "ap_bucket_error": {
            "name": "ap_bucket_error",
            "definition": "struct ap_bucket_error {\n    /** Number of buckets using this memory */\n    apr_bucket_refcount refcount;\n    /** The error code */\n    int status;\n    /** The error string */\n    const char    *data;\n}",
            "typedef_name": null,
            "fields": {
              "refcount": "apr_bucket_refcount",
              "status": "int",
              "data": "const char *"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "apr_bucket_type_flush": {
            "name": "apr_bucket_type_flush",
            "type": "const apr_bucket_type_t",
            "is_extern": true,
            "is_static": false,
            "definition": "extern const apr_bucket_type_t apr_bucket_type_flush",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "apr_bucket_type_eos": {
            "name": "apr_bucket_type_eos",
            "type": "const apr_bucket_type_t",
            "is_extern": true,
            "is_static": false,
            "definition": "extern const apr_bucket_type_t apr_bucket_type_eos",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "ap_bucket_type_error": {
            "name": "ap_bucket_type_error",
            "type": "const apr_bucket_type_t",
            "is_extern": true,
            "is_static": false,
            "definition": "extern const apr_bucket_type_t ap_bucket_type_error",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "ap_bucket_type_eoc": {
            "name": "ap_bucket_type_eoc",
            "type": "const apr_bucket_type_t",
            "is_extern": true,
            "is_static": false,
            "definition": "extern const apr_bucket_type_t ap_bucket_type_eoc",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "apr_status_t"
        ]
      },
      "source_code": "AP_CORE_DECLARE_NONSTD(apr_status_t) ap_http_header_filter(ap_filter_t *f,\n                                                           apr_bucket_brigade *b)\n{\n    request_rec *r = f->r;\n    conn_rec *c = r->connection;\n    apr_bucket *e, *next, *eos = NULL, *bcontent = NULL;\n    header_filter_ctx *ctx = f->ctx;\n    ap_bucket_error *eb = NULL;\n    apr_status_t rv = APR_SUCCESS;\n    int recursive_error = 0;\n\n    AP_DEBUG_ASSERT(!r->main);\n\n    if (!ctx) {\n        ctx = f->ctx = apr_pcalloc(r->pool, sizeof(header_filter_ctx));\n    }\n\n    if (!ctx->final_status) {\n        /* Determine if it is time to insert the response bucket for\n         * the request. Request handlers just write content or an EOS\n         * and that needs to take the current state of request_rec to\n         * send on status and headers as a response bucket.\n         *\n         * But we also send interim responses (as response buckets)\n         * through this filter and that must not trigger generating\n         * an additional response bucket.\n         *\n         * Waiting on a DATA/ERROR/EOS bucket alone is not enough,\n         * unfortunately, as some handlers trigger response generation\n         * by just writing a FLUSH (see mod_lua's websocket for example).\n         */\n        apr_bucket *respb = NULL;\n        ap_bucket_response *resp;\n\n        for (e = APR_BRIGADE_FIRST(b);\n             e != APR_BRIGADE_SENTINEL(b) && !bcontent;\n             e = APR_BUCKET_NEXT(e))\n        {\n            if (APR_BUCKET_IS_METADATA(e)) {\n                if (AP_BUCKET_IS_RESPONSE(e)) {\n                    /* RESPONSE buckets may get passed by others, for\n                     * example ap_send_interim_response() or ap_die().\n                     * We examine the status code of such a RESPONSE below\n                     * to determine if the response answers the request\n                     * or is just interim.\n                     */\n                    respb = e;\n                    resp = respb->data;\n                    if (!ctx->final_status\n                        && (resp->status >= 200 || resp->status == HTTP_SWITCHING_PROTOCOLS)) {\n                        ctx->final_status = resp->status;\n                        ctx->final_header_only = AP_STATUS_IS_HEADER_ONLY(resp->status);\n                        bcontent = APR_BUCKET_NEXT(e);\n                        break;\n                    }\n                }\n                else if (APR_BUCKET_IS_FLUSH(e)) {\n                    /* flush without response bucket triggers */\n                    if (!respb) bcontent = e;\n                }\n                else if (APR_BUCKET_IS_EOS(e)) {\n                    bcontent = e;\n                }\n                else if (AP_BUCKET_IS_ERROR(e)) {\n                    /* Need to handle this below via ap_die() */\n                    break;\n                }\n                else if (AP_BUCKET_IS_EOC(e)) {\n                    /* Need to handle this below. EOC prevents generating\n                     * a RESPONSE if not already triggered by buckets preceding\n                     * it. */\n                    break;\n                }\n            }\n            else {\n                /* First content bucket, always triggering the response.*/\n                bcontent = e;\n            }\n        }\n\n        if (!ctx->final_status && bcontent) {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                          \"ap_http_header_filter prep response status %d\",\n                          r->status);\n            merge_response_headers(r);\n            if (!check_headers(r)) {\n                /* We may come back here from ap_die() below,\n                 * so clear anything from this response.\n                 */\n                apr_table_clear(r->headers_out);\n                apr_table_clear(r->err_headers_out);\n                r->content_type = r->content_encoding = NULL;\n                r->content_languages = NULL;\n                r->clength = r->chunked = 0;\n                apr_brigade_cleanup(b);\n\n                /* Don't recall ap_die() if we come back here (from its own internal\n                 * redirect or error response), otherwise we can end up in infinite\n                 * recursion; better fall through with 500, minimal headers and an\n                 * empty body (EOS only).\n                 */\n                if (!check_headers_recursion(r)) {\n                    ap_die(HTTP_INTERNAL_SERVER_ERROR, r);\n                    return AP_FILTER_ERROR;\n                }\n                r->status = HTTP_INTERNAL_SERVER_ERROR;\n                e = ap_bucket_eoc_create(c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(b, e);\n                e = apr_bucket_eos_create(c->bucket_alloc);\n                APR_BRIGADE_INSERT_TAIL(b, e);\n                ap_set_content_length(r, 0);\n                recursive_error = 1;\n            }\n            /* insert the RESPONSE before the first content bucket */\n            respb = create_response_bucket(r, b->bucket_alloc);\n            APR_BUCKET_INSERT_BEFORE(bcontent, respb);\n            ctx->final_status = r->status;\n            ctx->final_header_only = (r->header_only || AP_STATUS_IS_HEADER_ONLY(r->status));\n            r->sent_bodyct = 1;         /* Whatever follows is real body stuff... */\n        }\n    }\n\n    if (ctx->final_status && ctx->final_header_only) {\n        /* The final RESPONSE has already been sent or is in front of `bcontent`\n         * in the brigade. For a header_only respone, remove all content buckets\n         * up to the first EOS. On seeing EOS, we remove ourself and are done.\n         * NOTE that `header_only` responses never generate trailes.\n         */\n        for (e = bcontent? bcontent : APR_BRIGADE_FIRST(b);\n             e != APR_BRIGADE_SENTINEL(b);\n             e = next)\n        {\n            next = APR_BUCKET_NEXT(e);\n            if (APR_BUCKET_IS_EOS(e)) {\n                eos = e;\n                break;\n            }\n            apr_bucket_delete(e);\n        }\n\n        if (eos) {\n            ap_remove_output_filter(f);\n        }\n        if (!APR_BRIGADE_EMPTY(b)) {\n            rv = ap_pass_brigade(f->next, b);\n        }\n        r->final_resp_passed = 1;\n        return rv;\n    }\n\n    /* Look for ERROR/EOC/EOS that require special handling. */\n    for (e = APR_BRIGADE_FIRST(b);\n         e != APR_BRIGADE_SENTINEL(b);\n         e = APR_BUCKET_NEXT(e))\n    {\n        if (APR_BUCKET_IS_METADATA(e)) {\n            if (APR_BUCKET_IS_EOS(e)) {\n                if (!eos) eos = e;\n            }\n            else if (AP_BUCKET_IS_EOC(e)) {\n                /* If we see an EOC bucket it is a signal that we should get out\n                 * of the way doing nothing.\n                 */\n                ap_remove_output_filter(f);\n                return ap_pass_brigade(f->next, b);\n            }\n            else if (AP_BUCKET_IS_ERROR(e)) {\n                int status;\n                eb = e->data;\n                status = eb->status;\n                if (r->final_resp_passed) {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                                  \"ap_http_header_filter error bucket, should \"\n                                  \"die with status=%d but final response already \"\n                                  \"underway\", status);\n                    ap_remove_output_filter(f);\n                    APR_BUCKET_REMOVE(e);\n                    apr_brigade_cleanup(b);\n                    APR_BRIGADE_INSERT_TAIL(b, e);\n                    e = ap_bucket_eoc_create(c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(b, e);\n                    e = apr_bucket_eos_create(c->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(b, e);\n                    c->aborted = 1;\n                    return ap_pass_brigade(f->next, b);\n                }\n                else {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                                  \"ap_http_header_filter error bucket, die with %d and error\",\n                                  status);\n                    apr_brigade_cleanup(b);\n                    /* This will invoke us again */\n                    ctx->dying = 1;\n                    ap_die(status, r);\n                    return AP_FILTER_ERROR;\n                }\n            }\n        }\n    }\n\n    if (r->assbackwards) {\n        r->sent_bodyct = 1;\n        ap_remove_output_filter(f);\n        rv = ap_pass_brigade(f->next, b);\n        goto out;\n    }\n\n    if (eos) {\n        e = create_trailers_bucket(r, b->bucket_alloc);\n        if (e) {\n            APR_BUCKET_INSERT_BEFORE(eos, e);\n        }\n        ap_remove_output_filter(f);\n    }\n    else if (ctx->final_status == HTTP_SWITCHING_PROTOCOLS) {\n        /* switching protocol, whatever comes next is not HTTP/1.x */\n        ap_remove_output_filter(f);\n    }\n\n    rv = ap_pass_brigade(f->next, b);\nout:\n    if (ctx->final_status)\n        r->final_resp_passed = 1;\n    if (recursive_error) {\n        return AP_FILTER_ERROR;\n    }\n    return rv;\n}"
    },
    "ap_map_http_request_error@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1400, column 17>": {
      "basic_info": {
        "function_id": 1484,
        "name": "ap_map_http_request_error",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1400, column 17>",
        "is_definition": true,
        "start_line": 1400,
        "end_line": 1422,
        "return_type": "int",
        "parameters": [
          {
            "name": "rv",
            "type": "apr_status_t"
          },
          {
            "name": "status",
            "type": "int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {},
        "callers": {
          "ap_discard_request_body@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1438, column 17>": {
            "source_code": "AP_DECLARE(int) ap_discard_request_body(request_rec *r)\n{\n    int rc = OK;\n    conn_rec *c = r->connection;\n    apr_bucket_brigade *bb;\n\n    /* Sometimes we'll get in a state where the input handling has\n     * detected an error where we want to drop the connection, so if\n     * that's the case, don't read the data as that is what we're trying\n     * to avoid.\n     *\n     * This function is also a no-op on a subrequest.\n     */\n    if (r->main || c->keepalive == AP_CONN_CLOSE) {\n        return OK;\n    }\n    if (ap_status_drops_connection(r->status)) {\n        c->keepalive = AP_CONN_CLOSE;\n        return OK;\n    }\n\n    bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    for (;;) {\n        apr_status_t rv;\n\n        rv = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,\n                            APR_BLOCK_READ, HUGE_STRING_LEN);\n        if (rv != APR_SUCCESS) {\n            rc = ap_map_http_request_error(rv, HTTP_BAD_REQUEST);\n            goto cleanup;\n        }\n\n        while (!APR_BRIGADE_EMPTY(bb)) {\n            apr_bucket *b = APR_BRIGADE_FIRST(bb);\n\n            if (APR_BUCKET_IS_EOS(b)) {\n                goto cleanup;\n            }\n\n            /* There is no need to read empty or metadata buckets or\n             * buckets of known length, but we MUST read buckets of\n             * unknown length in order to exhaust them.\n             */\n            if (b->length == (apr_size_t)-1) {\n                apr_size_t len;\n                const char *data;\n\n                rv = apr_bucket_read(b, &data, &len, APR_BLOCK_READ);\n                if (rv != APR_SUCCESS) {\n                    rc = HTTP_BAD_REQUEST;\n                    goto cleanup;\n                }\n            }\n\n            apr_bucket_delete(b);\n        }\n    }\n\ncleanup:\n    apr_brigade_cleanup(bb);\n    if (rc != OK) {\n        c->keepalive = AP_CONN_CLOSE;\n    }\n    return rc;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1438, column 17>"
          },
          "ap_get_client_block@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1623, column 18>": {
            "source_code": "AP_DECLARE(long) ap_get_client_block(request_rec *r, char *buffer,\n                                     apr_size_t bufsiz)\n{\n    apr_status_t rv;\n    apr_bucket_brigade *bb;\n\n    if (r->remaining < 0 || (!r->read_chunked && r->remaining == 0)) {\n        return 0;\n    }\n\n    bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    if (bb == NULL) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n        return -1;\n    }\n\n    rv = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,\n                        APR_BLOCK_READ, bufsiz);\n\n    /* We lose the failure code here.  This is why ap_get_client_block should\n     * not be used.\n     */\n    if (rv == AP_FILTER_ERROR) {\n        /* AP_FILTER_ERROR means a filter has responded already,\n         * we are DONE.\n         */\n        apr_brigade_destroy(bb);\n        return -1;\n    }\n    if (rv != APR_SUCCESS) {\n        apr_bucket *e;\n\n        /* work around our silent swallowing of error messages by mapping\n         * error codes at this point, and sending an error bucket back\n         * upstream.\n         */\n        apr_brigade_cleanup(bb);\n\n        e = ap_bucket_error_create(\n                ap_map_http_request_error(rv, HTTP_BAD_REQUEST), NULL, r->pool,\n                r->connection->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n\n        e = apr_bucket_eos_create(r->connection->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n\n        rv = ap_pass_brigade(r->output_filters, bb);\n        if (APR_SUCCESS != rv) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, r, APLOGNO(02484)\n                          \"Error while writing error response\");\n        }\n\n        /* if we actually fail here, we want to just return and\n         * stop trying to read data from the client.\n         */\n        r->connection->keepalive = AP_CONN_CLOSE;\n        apr_brigade_destroy(bb);\n        return -1;\n    }\n\n    /* If this fails, it means that a filter is written incorrectly and that\n     * it needs to learn how to properly handle APR_BLOCK_READ requests by\n     * returning data when requested.\n     */\n    AP_DEBUG_ASSERT(!APR_BRIGADE_EMPTY(bb));\n\n    /* Check to see if EOS in the brigade.\n     *\n     * If so, we have to leave a nugget for the *next* ap_get_client_block\n     * call to return 0.\n     */\n    if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {\n        if (r->read_chunked) {\n            r->remaining = -1;\n        }\n        else {\n            r->remaining = 0;\n        }\n    }\n\n    rv = apr_brigade_flatten(bb, buffer, &bufsiz);\n    if (rv != APR_SUCCESS) {\n        apr_brigade_destroy(bb);\n        return -1;\n    }\n\n    /* XXX yank me? */\n    r->read_length += bufsiz;\n\n    apr_brigade_destroy(bb);\n    return bufsiz;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1623, column 18>"
          }
        },
        "used_macros": {},
        "used_structs": {},
        "used_globals": {},
        "used_typedefs": [
          "apr_status_t"
        ]
      },
      "source_code": "AP_DECLARE(int) ap_map_http_request_error(apr_status_t rv, int status)\n{\n    switch (rv) {\n    case AP_FILTER_ERROR:\n        return AP_FILTER_ERROR;\n\n    case APR_EGENERAL:\n        return HTTP_BAD_REQUEST;\n\n    case APR_ENOSPC:\n        return HTTP_REQUEST_ENTITY_TOO_LARGE;\n\n    case APR_ENOTIMPL:\n        return HTTP_NOT_IMPLEMENTED;\n\n    case APR_TIMEUP:\n    case APR_ETIMEDOUT:\n        return HTTP_REQUEST_TIME_OUT;\n\n    default:\n        return status;\n    }\n}"
    },
    "ap_discard_request_body@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1438, column 17>": {
      "basic_info": {
        "function_id": 1485,
        "name": "ap_discard_request_body",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1438, column 17>",
        "is_definition": true,
        "start_line": 1438,
        "end_line": 1502,
        "return_type": "int",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_brigade_create": {
            "declaration": "APU_DECLARE(apr_bucket_brigade *) apr_brigade_create(apr_pool_t *p,\n                                                     apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "ap_get_brigade": {
            "declaration": "AP_DECLARE(apr_status_t) ap_get_brigade(ap_filter_t *filter,\n                                        apr_bucket_brigade *bucket,\n                                        ap_input_mode_t mode,\n                                        apr_read_type_e block,\n                                        apr_off_t readbytes)",
            "is_external": true,
            "definition": null
          },
          "ap_map_http_request_error": {
            "declaration": "AP_DECLARE(int) ap_map_http_request_error(apr_status_t rv, int status)\n{\n    switch (rv) {\n    case AP_FILTER_ERROR:\n        return AP_FILTER_ERROR;\n\n    case APR_EGENERAL:\n        return HTTP_BAD_REQUEST;\n\n    case APR_ENOSPC:\n        return HTTP_REQUEST_ENTITY_TOO_LARGE;\n\n    case APR_ENOTIMPL:\n        return HTTP_NOT_IMPLEMENTED;\n\n    case APR_TIMEUP:\n    case APR_ETIMEDOUT:\n        return HTTP_REQUEST_TIME_OUT;\n\n    default:\n        return status;\n    }\n}",
            "is_external": false,
            "definition": "AP_DECLARE(int) ap_map_http_request_error(apr_status_t rv, int status)\n{\n    switch (rv) {\n    case AP_FILTER_ERROR:\n        return AP_FILTER_ERROR;\n\n    case APR_EGENERAL:\n        return HTTP_BAD_REQUEST;\n\n    case APR_ENOSPC:\n        return HTTP_REQUEST_ENTITY_TOO_LARGE;\n\n    case APR_ENOTIMPL:\n        return HTTP_NOT_IMPLEMENTED;\n\n    case APR_TIMEUP:\n    case APR_ETIMEDOUT:\n        return HTTP_REQUEST_TIME_OUT;\n\n    default:\n        return status;\n    }\n}"
          },
          "read": {
            "declaration": "apr_status_t (*read)(apr_bucket *b, const char **str, apr_size_t *len, \n                         apr_read_type_e block)",
            "is_external": true,
            "definition": null
          },
          "destroy": {
            "declaration": "apr_bucket_delete(b)",
            "is_external": true,
            "definition": null
          },
          "free": {
            "declaration": "void (*free)(void *e)",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_cleanup": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_cleanup(void *data)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {
          "AP_CONN_CLOSE": {
            "name": "AP_CONN_CLOSE",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_conn_keepalive_e AP_CONN_CLOSE = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1145, column 5>",
            "condition": ""
          },
          "AP_MODE_READBYTES": {
            "name": "AP_MODE_READBYTES",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_input_mode_t AP_MODE_READBYTES = 0",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/util_filter.h', line 43, column 5>",
            "condition": ""
          },
          "APR_BLOCK_READ": {
            "name": "APR_BLOCK_READ",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum apr_read_type_e APR_BLOCK_READ = 0",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/apr_buckets.h', line 58, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "conn_rec": {
            "name": "conn_rec",
            "definition": "struct conn_rec {\n    /** Pool associated with this connection */\n    apr_pool_t *pool;\n    /** Physical vhost this conn came in on */\n    server_rec *base_server;\n    /** used by http_vhost.c */\n    void *vhost_lookup_data;\n\n    /* Information about the connection itself */\n    /** local address */\n    apr_sockaddr_t *local_addr;\n    /** remote address; this is the end-point of the next hop, for the address\n     *  of the request creator, see useragent_addr in request_rec\n     */\n    apr_sockaddr_t *client_addr;\n\n    /** Client's IP address; this is the end-point of the next hop, for the\n     *  IP of the request creator, see useragent_ip in request_rec\n     */\n    char *client_ip;\n    /** Client's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     * get_remote_host() */\n    char *remote_host;\n    /** Only ever set if doing rfc1413 lookups.  N.B. Only access this through\n     *  get_remote_logname() */\n    char *remote_logname;\n\n    /** server IP address */\n    char *local_ip;\n    /** used for ap_get_server_name when UseCanonicalName is set to DNS\n     *  (ignores setting of HostnameLookups) */\n    char *local_host;\n\n    /** ID of this connection; unique at any point in time */\n    long id;\n    /** Config vector containing pointers to connections per-server\n     *  config structures. */\n    struct ap_conf_vector_t *conn_config;\n    /** Notes on *this* connection: send note from one module to\n     *  another. must remain valid for all requests on this conn */\n    apr_table_t *notes;\n    /** A list of input filters to be used for this connection */\n    struct ap_filter_t *input_filters;\n    /** A list of output filters to be used for this connection */\n    struct ap_filter_t *output_filters;\n    /** handle to scoreboard information for this connection */\n    void *sbh;\n    /** The bucket allocator to use for all bucket/brigade creations */\n    struct apr_bucket_alloc_t *bucket_alloc;\n    /** The current state of this connection; may be NULL if not used by MPM */\n    conn_state_t *cs;\n    /** Is there data pending in the input filters? */\n    int data_in_input_filters;\n    /** Is there data pending in the output filters? */\n    int data_in_output_filters;\n\n    /** Are there any filters that clogg/buffer the input stream, breaking\n     *  the event mpm.\n     */\n    unsigned int clogging_input_filters:1;\n\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success */\n    signed int double_reverse:2;\n\n    /** Are we still talking? */\n    unsigned aborted;\n\n    /** Are we going to keep the connection alive for another request?\n     * @see ap_conn_keepalive_e */\n    ap_conn_keepalive_e keepalive;\n\n    /** How many times have we used it? */\n    int keepalives;\n\n    /** Optional connection log level configuration. May point to a server or\n     *  per_dir config, i.e. must be copied before modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify this connection in error log. Set when the first\n     *  error log entry for this connection is generated.\n     */\n    const char *log_id;\n\n\n    /** This points to the current thread being used to process this request,\n     * over the lifetime of a request, the value may change. Users of the connection\n     * record should not rely upon it staying the same between calls that involve\n     * the MPM.\n     */\n#if APR_HAS_THREADS\n    apr_thread_t *current_thread;\n#endif\n\n    /** The \"real\" master connection. NULL if I am the master. */\n    conn_rec *master;\n\n    int outgoing;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "base_server": "server_rec *",
              "vhost_lookup_data": "void *",
              "local_addr": "apr_sockaddr_t *",
              "client_addr": "apr_sockaddr_t *",
              "client_ip": "char *",
              "remote_host": "char *",
              "remote_logname": "char *",
              "local_ip": "char *",
              "local_host": "char *",
              "id": "long",
              "conn_config": "struct ap_conf_vector_t *",
              "notes": "apr_table_t *",
              "input_filters": "struct ap_filter_t *",
              "output_filters": "struct ap_filter_t *",
              "sbh": "void *",
              "bucket_alloc": "struct apr_bucket_alloc_t *",
              "cs": "conn_state_t *",
              "data_in_input_filters": "int",
              "data_in_output_filters": "int",
              "clogging_input_filters": "unsigned int",
              "double_reverse": "int",
              "aborted": "unsigned int",
              "keepalive": "ap_conn_keepalive_e",
              "keepalives": "int",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "current_thread": "apr_thread_t *",
              "master": "conn_rec *",
              "outgoing": "int"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "apr_bucket_type_eos": {
            "name": "apr_bucket_type_eos",
            "type": "const apr_bucket_type_t",
            "is_extern": true,
            "is_static": false,
            "definition": "extern const apr_bucket_type_t apr_bucket_type_eos",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "apr_size_t",
          "apr_status_t"
        ]
      },
      "source_code": "AP_DECLARE(int) ap_discard_request_body(request_rec *r)\n{\n    int rc = OK;\n    conn_rec *c = r->connection;\n    apr_bucket_brigade *bb;\n\n    /* Sometimes we'll get in a state where the input handling has\n     * detected an error where we want to drop the connection, so if\n     * that's the case, don't read the data as that is what we're trying\n     * to avoid.\n     *\n     * This function is also a no-op on a subrequest.\n     */\n    if (r->main || c->keepalive == AP_CONN_CLOSE) {\n        return OK;\n    }\n    if (ap_status_drops_connection(r->status)) {\n        c->keepalive = AP_CONN_CLOSE;\n        return OK;\n    }\n\n    bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    for (;;) {\n        apr_status_t rv;\n\n        rv = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,\n                            APR_BLOCK_READ, HUGE_STRING_LEN);\n        if (rv != APR_SUCCESS) {\n            rc = ap_map_http_request_error(rv, HTTP_BAD_REQUEST);\n            goto cleanup;\n        }\n\n        while (!APR_BRIGADE_EMPTY(bb)) {\n            apr_bucket *b = APR_BRIGADE_FIRST(bb);\n\n            if (APR_BUCKET_IS_EOS(b)) {\n                goto cleanup;\n            }\n\n            /* There is no need to read empty or metadata buckets or\n             * buckets of known length, but we MUST read buckets of\n             * unknown length in order to exhaust them.\n             */\n            if (b->length == (apr_size_t)-1) {\n                apr_size_t len;\n                const char *data;\n\n                rv = apr_bucket_read(b, &data, &len, APR_BLOCK_READ);\n                if (rv != APR_SUCCESS) {\n                    rc = HTTP_BAD_REQUEST;\n                    goto cleanup;\n                }\n            }\n\n            apr_bucket_delete(b);\n        }\n    }\n\ncleanup:\n    apr_brigade_cleanup(bb);\n    if (rc != OK) {\n        c->keepalive = AP_CONN_CLOSE;\n    }\n    return rc;\n}"
    },
    "ap_setup_client_block@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1541, column 17>": {
      "basic_info": {
        "function_id": 1486,
        "name": "ap_setup_client_block",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1541, column 17>",
        "is_definition": true,
        "start_line": 1541,
        "end_line": 1600,
        "return_type": "int",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "read_policy",
            "type": "int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "ap_get_limit_req_body": {
            "declaration": "AP_DECLARE(apr_off_t) ap_get_limit_req_body(const request_rec *r)",
            "is_external": true,
            "definition": null
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "ap_parse_strict_length": {
            "declaration": "AP_DECLARE(int) ap_parse_strict_length(apr_off_t *len, const char *str)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "apr_off_t"
        ]
      },
      "source_code": "AP_DECLARE(int) ap_setup_client_block(request_rec *r, int read_policy)\n{\n    const char *lenp = apr_table_get(r->headers_in, \"Content-Length\");\n    apr_off_t limit_req_body = ap_get_limit_req_body(r);\n\n    r->read_body = read_policy;\n    r->read_chunked = 0;\n    r->remaining = 0;\n\n    if (r->body_indeterminate) {\n        /* Protocols like HTTP/2 can carry bodies without length and\n         * HTTP/1.1 has chunked encoding signalled via this note.\n         */\n        if (r->read_body == REQUEST_CHUNKED_ERROR) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01593)\n                          \"indeterminate request body length forbidden: %s\", r->uri);\n            r->read_chunked = 0;\n            return (lenp) ? HTTP_BAD_REQUEST : HTTP_LENGTH_REQUIRED;\n        }\n        r->read_chunked = 1;\n    }\n    else if (lenp) {\n        if (!ap_parse_strict_length(&r->remaining, lenp)) {\n            r->remaining = 0;\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01594)\n                          \"Invalid Content-Length '%s'\", lenp);\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    if ((r->read_body == REQUEST_NO_BODY)\n        && (r->read_chunked || (r->remaining > 0))) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01595)\n                      \"%s with body is not allowed for %s\", r->method, r->uri);\n        return HTTP_REQUEST_ENTITY_TOO_LARGE;\n    }\n\n    if (limit_req_body > 0 && (r->remaining > limit_req_body)) {\n        /* 01588 msg in HTTP_IN filter will be skipped for a connection-dropping status,\n         * in r->status, so log a similar message here.\n         */\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(10483)\n                \"Requested content-length of %\" APR_OFF_T_FMT\n                \" is larger than the configured limit\"\n                \" of %\" APR_OFF_T_FMT, r->remaining, limit_req_body);\n\n        return HTTP_REQUEST_ENTITY_TOO_LARGE;\n    }\n\n#ifdef AP_DEBUG\n    {\n        /* Make sure ap_getline() didn't leave any droppings. */\n        core_request_config *req_cfg =\n            (core_request_config *)ap_get_core_module_config(r->request_config);\n        AP_DEBUG_ASSERT(APR_BRIGADE_EMPTY(req_cfg->bb));\n    }\n#endif\n\n    return OK;\n}"
    },
    "ap_should_client_block@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1602, column 17>": {
      "basic_info": {
        "function_id": 1487,
        "name": "ap_should_client_block",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1602, column 17>",
        "is_definition": true,
        "start_line": 1602,
        "end_line": 1611,
        "return_type": "int",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {},
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(int) ap_should_client_block(request_rec *r)\n{\n    /* First check if we have already read the request body */\n\n    if (r->read_length || (!r->read_chunked && (r->remaining <= 0))) {\n        return 0;\n    }\n\n    return 1;\n}"
    },
    "ap_get_client_block@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1623, column 18>": {
      "basic_info": {
        "function_id": 1488,
        "name": "ap_get_client_block",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1623, column 18>",
        "is_definition": true,
        "start_line": 1623,
        "end_line": 1714,
        "return_type": "long",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "buffer",
            "type": "char *"
          },
          {
            "name": "bufsiz",
            "type": "apr_size_t"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_brigade_create": {
            "declaration": "APU_DECLARE(apr_bucket_brigade *) apr_brigade_create(apr_pool_t *p,\n                                                     apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "ap_get_brigade": {
            "declaration": "AP_DECLARE(apr_status_t) ap_get_brigade(ap_filter_t *filter,\n                                        apr_bucket_brigade *bucket,\n                                        ap_input_mode_t mode,\n                                        apr_read_type_e block,\n                                        apr_off_t readbytes)",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_destroy": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_destroy(apr_bucket_brigade *b)",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_cleanup": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_cleanup(void *data)",
            "is_external": true,
            "definition": null
          },
          "ap_bucket_error_create": {
            "declaration": "AP_DECLARE(apr_bucket *) ap_bucket_error_create(int error, const char *buf,\n                                                apr_pool_t *p,\n                                                apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "ap_map_http_request_error": {
            "declaration": "AP_DECLARE(int) ap_map_http_request_error(apr_status_t rv, int status)\n{\n    switch (rv) {\n    case AP_FILTER_ERROR:\n        return AP_FILTER_ERROR;\n\n    case APR_EGENERAL:\n        return HTTP_BAD_REQUEST;\n\n    case APR_ENOSPC:\n        return HTTP_REQUEST_ENTITY_TOO_LARGE;\n\n    case APR_ENOTIMPL:\n        return HTTP_NOT_IMPLEMENTED;\n\n    case APR_TIMEUP:\n    case APR_ETIMEDOUT:\n        return HTTP_REQUEST_TIME_OUT;\n\n    default:\n        return status;\n    }\n}",
            "is_external": false,
            "definition": "AP_DECLARE(int) ap_map_http_request_error(apr_status_t rv, int status)\n{\n    switch (rv) {\n    case AP_FILTER_ERROR:\n        return AP_FILTER_ERROR;\n\n    case APR_EGENERAL:\n        return HTTP_BAD_REQUEST;\n\n    case APR_ENOSPC:\n        return HTTP_REQUEST_ENTITY_TOO_LARGE;\n\n    case APR_ENOTIMPL:\n        return HTTP_NOT_IMPLEMENTED;\n\n    case APR_TIMEUP:\n    case APR_ETIMEDOUT:\n        return HTTP_REQUEST_TIME_OUT;\n\n    default:\n        return status;\n    }\n}"
          },
          "apr_bucket_eos_create": {
            "declaration": "APU_DECLARE(apr_bucket *) apr_bucket_eos_create(apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "ap_pass_brigade": {
            "declaration": "AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *filter,\n                                         apr_bucket_brigade *bucket)",
            "is_external": true,
            "definition": null
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_flatten": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_flatten(apr_bucket_brigade *bb,\n                                              char *c,\n                                              apr_size_t *len)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {
          "AP_CONN_CLOSE": {
            "name": "AP_CONN_CLOSE",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_conn_keepalive_e AP_CONN_CLOSE = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1145, column 5>",
            "condition": ""
          },
          "AP_MODE_READBYTES": {
            "name": "AP_MODE_READBYTES",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_input_mode_t AP_MODE_READBYTES = 0",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/util_filter.h', line 43, column 5>",
            "condition": ""
          },
          "APR_BLOCK_READ": {
            "name": "APR_BLOCK_READ",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum apr_read_type_e APR_BLOCK_READ = 0",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/apr_buckets.h', line 58, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          },
          "apr_bucket_type_eos": {
            "name": "apr_bucket_type_eos",
            "type": "const apr_bucket_type_t",
            "is_extern": true,
            "is_static": false,
            "definition": "extern const apr_bucket_type_t apr_bucket_type_eos",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "apr_status_t",
          "apr_size_t"
        ]
      },
      "source_code": "AP_DECLARE(long) ap_get_client_block(request_rec *r, char *buffer,\n                                     apr_size_t bufsiz)\n{\n    apr_status_t rv;\n    apr_bucket_brigade *bb;\n\n    if (r->remaining < 0 || (!r->read_chunked && r->remaining == 0)) {\n        return 0;\n    }\n\n    bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    if (bb == NULL) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n        return -1;\n    }\n\n    rv = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,\n                        APR_BLOCK_READ, bufsiz);\n\n    /* We lose the failure code here.  This is why ap_get_client_block should\n     * not be used.\n     */\n    if (rv == AP_FILTER_ERROR) {\n        /* AP_FILTER_ERROR means a filter has responded already,\n         * we are DONE.\n         */\n        apr_brigade_destroy(bb);\n        return -1;\n    }\n    if (rv != APR_SUCCESS) {\n        apr_bucket *e;\n\n        /* work around our silent swallowing of error messages by mapping\n         * error codes at this point, and sending an error bucket back\n         * upstream.\n         */\n        apr_brigade_cleanup(bb);\n\n        e = ap_bucket_error_create(\n                ap_map_http_request_error(rv, HTTP_BAD_REQUEST), NULL, r->pool,\n                r->connection->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n\n        e = apr_bucket_eos_create(r->connection->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n\n        rv = ap_pass_brigade(r->output_filters, bb);\n        if (APR_SUCCESS != rv) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, r, APLOGNO(02484)\n                          \"Error while writing error response\");\n        }\n\n        /* if we actually fail here, we want to just return and\n         * stop trying to read data from the client.\n         */\n        r->connection->keepalive = AP_CONN_CLOSE;\n        apr_brigade_destroy(bb);\n        return -1;\n    }\n\n    /* If this fails, it means that a filter is written incorrectly and that\n     * it needs to learn how to properly handle APR_BLOCK_READ requests by\n     * returning data when requested.\n     */\n    AP_DEBUG_ASSERT(!APR_BRIGADE_EMPTY(bb));\n\n    /* Check to see if EOS in the brigade.\n     *\n     * If so, we have to leave a nugget for the *next* ap_get_client_block\n     * call to return 0.\n     */\n    if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) {\n        if (r->read_chunked) {\n            r->remaining = -1;\n        }\n        else {\n            r->remaining = 0;\n        }\n    }\n\n    rv = apr_brigade_flatten(bb, buffer, &bufsiz);\n    if (rv != APR_SUCCESS) {\n        apr_brigade_destroy(bb);\n        return -1;\n    }\n\n    /* XXX yank me? */\n    r->read_length += bufsiz;\n\n    apr_brigade_destroy(bb);\n    return bufsiz;\n}"
    },
    "ap_http_outerror_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1723, column 14>": {
      "basic_info": {
        "function_id": 1489,
        "name": "ap_http_outerror_filter",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1723, column 14>",
        "is_definition": true,
        "start_line": 1723,
        "end_line": 1807,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "f",
            "type": "ap_filter_t *"
          },
          {
            "name": "b",
            "type": "apr_bucket_brigade *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "memset": {
            "declaration": "extern void *memset (void *__s, int __c, size_t __n) __THROW __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "destroy": {
            "declaration": "apr_bucket_delete(c)",
            "is_external": true,
            "definition": null
          },
          "free": {
            "declaration": "void (*free)(void *e)",
            "is_external": true,
            "definition": null
          },
          "ap_pass_brigade": {
            "declaration": "AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *filter,\n                                         apr_bucket_brigade *bucket)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {
          "AP_CONN_CLOSE": {
            "name": "AP_CONN_CLOSE",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_conn_keepalive_e AP_CONN_CLOSE = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1145, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "ap_filter_t": {
            "name": "ap_filter_t",
            "definition": "struct ap_filter_t {\n    /** The internal representation of this filter.  This includes\n     *  the filter's name, type, and the actual function pointer.\n     */\n    ap_filter_rec_t *frec;\n\n    /** A place to store any data associated with the current filter */\n    void *ctx;\n\n    /** The next filter in the chain */\n    ap_filter_t *next;\n\n    /** The request_rec associated with the current filter.  If a sub-request\n     *  adds filters, then the sub-request is the request associated with the\n     *  filter.\n     */\n    request_rec *r;\n\n    /** The conn_rec associated with the current filter.  This is analogous\n     *  to the request_rec, except that it is used for connection filters.\n     */\n    conn_rec *c;\n}",
            "typedef_name": null,
            "fields": {
              "frec": "ap_filter_rec_t *",
              "ctx": "void *",
              "next": "ap_filter_t *",
              "r": "request_rec *",
              "c": "conn_rec *"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "outerror_filter_ctx_t": {
            "name": "outerror_filter_ctx_t",
            "definition": "struct {\n    int seen_eoc;\n    int first_error;\n}",
            "typedef_name": null,
            "fields": {
              "seen_eoc": "int",
              "first_error": "int"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "ap_bucket_error": {
            "name": "ap_bucket_error",
            "definition": "struct ap_bucket_error {\n    /** Number of buckets using this memory */\n    apr_bucket_refcount refcount;\n    /** The error code */\n    int status;\n    /** The error string */\n    const char    *data;\n}",
            "typedef_name": null,
            "fields": {
              "refcount": "apr_bucket_refcount",
              "status": "int",
              "data": "const char *"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "ap_bucket_type_error": {
            "name": "ap_bucket_type_error",
            "type": "const apr_bucket_type_t",
            "is_extern": true,
            "is_static": false,
            "definition": "extern const apr_bucket_type_t ap_bucket_type_error",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "ap_bucket_type_eoc": {
            "name": "ap_bucket_type_eoc",
            "type": "const apr_bucket_type_t",
            "is_extern": true,
            "is_static": false,
            "definition": "extern const apr_bucket_type_t ap_bucket_type_eoc",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "apr_status_t"
        ]
      },
      "source_code": "apr_status_t ap_http_outerror_filter(ap_filter_t *f,\n                                     apr_bucket_brigade *b)\n{\n    request_rec *r = f->r;\n    outerror_filter_ctx_t *ctx = (outerror_filter_ctx_t *)(f->ctx);\n    apr_bucket *e;\n\n    /* Create context if none is present */\n    if (!ctx) {\n        ctx = apr_pcalloc(r->pool, sizeof(outerror_filter_ctx_t));\n        f->ctx = ctx;\n    }\n    for (e = APR_BRIGADE_FIRST(b);\n         e != APR_BRIGADE_SENTINEL(b);\n         e = APR_BUCKET_NEXT(e))\n    {\n        if (AP_BUCKET_IS_ERROR(e)) {\n            /*\n             * Start of error handling state tree. Just one condition\n             * right now :)\n             */\n            if (((ap_bucket_error *)(e->data))->status == HTTP_BAD_GATEWAY ||\n                ((ap_bucket_error *)(e->data))->status == HTTP_GATEWAY_TIME_OUT) {\n                /* stream aborted and we have not ended it yet */\n                r->connection->keepalive = AP_CONN_CLOSE;\n            }\n            /*\n             * Memorize the status code of the first error bucket for possible\n             * later use.\n             */\n            if (!ctx->first_error) {\n                ctx->first_error = ((ap_bucket_error *)(e->data))->status;\n            }\n            continue;\n        }\n        /* Detect EOC buckets and memorize this in the context. */\n        if (AP_BUCKET_IS_EOC(e)) {\n            r->connection->keepalive = AP_CONN_CLOSE;\n            ctx->seen_eoc = 1;\n        }\n    }\n    /*\n     * Remove all data buckets that are in a brigade after an EOC bucket\n     * was seen, as an EOC bucket tells us that no (further) resource\n     * and protocol data should go out to the client. OTOH meta buckets\n     * are still welcome as they might trigger needed actions down in\n     * the chain (e.g. in network filters like SSL).\n     * Remark 1: It is needed to dump ALL data buckets in the brigade\n     *           since an filter in between might have inserted data\n     *           buckets BEFORE the EOC bucket sent by the original\n     *           sender and we do NOT want this data to be sent.\n     * Remark 2: Dumping all data buckets here does not necessarily mean\n     *           that no further data is send to the client as:\n     *           1. Network filters like SSL can still be triggered via\n     *              meta buckets to talk with the client e.g. for a\n     *              clean shutdown.\n     *           2. There could be still data that was buffered before\n     *              down in the chain that gets flushed by a FLUSH or an\n     *              EOS bucket.\n     */\n    if (ctx->seen_eoc) {\n        /*\n         * Set the request status to the status of the first error bucket.\n         * This should ensure that we log an appropriate status code in\n         * the access log.\n         * We need to set r->status on each call after we noticed an EOC as\n         * data bucket generators like ap_die might have changed the status\n         * code. But we know better in this case and insist on the status\n         * code that we have seen in the error bucket.\n         */\n        if (ctx->first_error) {\n            r->status = ctx->first_error;\n        }\n        e = APR_BRIGADE_FIRST(b);\n        while (e != APR_BRIGADE_SENTINEL(b)) {\n            apr_bucket *c = e;\n            e = APR_BUCKET_NEXT(e);\n            if (!APR_BUCKET_IS_METADATA(c)) {\n                apr_bucket_delete(c);\n            }\n        }\n    }\n\n    return ap_pass_brigade(f->next,  b);\n}"
    },
    "h1_append_response_head@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1811, column 13>": {
      "basic_info": {
        "function_id": 1490,
        "name": "h1_append_response_head",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1811, column 13>",
        "is_definition": true,
        "start_line": 1811,
        "end_line": 1888,
        "return_type": "void",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "resp",
            "type": "int *"
          },
          {
            "name": "protocol",
            "type": "const char *"
          },
          {
            "name": "bb",
            "type": "apr_bucket_brigade *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_psprintf": {
            "declaration": "APR_DECLARE_NONSTD(char *) apr_psprintf(apr_pool_t *p, const char *fmt, ...)\n        __attribute__((format(printf,2,3)))",
            "is_external": true,
            "definition": null
          },
          "ap_get_status_line_ex": {
            "declaration": "AP_DECLARE(const char *) ap_get_status_line_ex(apr_pool_t *p, int status)",
            "is_external": false,
            "definition": "AP_DECLARE(const char *) ap_get_status_line_ex(apr_pool_t *p, int status)\n{\n    int index = index_of_response(status);\n    if (index >= 0) {\n        return status_lines[index];\n    }\n    else if (index == -2) {\n        return apr_psprintf(p, \"%i Status %i\", status, status);\n    }\n    return status_lines[LEVEL_500];\n}"
          },
          "strlen": {
            "declaration": "extern size_t strlen (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_writev": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_writev(apr_bucket_brigade *b,\n                                             apr_brigade_flush flush,\n                                             void *ctx,\n                                             const struct iovec *vec,\n                                             apr_size_t nvec)",
            "is_external": true,
            "definition": null
          },
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "ap_h1_append_header": {
            "declaration": "ap_h1_append_header(bb, r->pool, \"Server\", server)",
            "is_external": false,
            "definition": "AP_DECLARE(apr_status_t) ap_h1_append_header(apr_bucket_brigade *bb,\n                                             apr_pool_t *pool,\n                                             const char *name, const char *value)\n{\n#if APR_CHARSET_EBCDIC\n    char *headfield;\n    apr_size_t len;\n\n    headfield = apr_pstrcat(pool, name, \": \", value, CRLF, NULL);\n    len = strlen(headfield);\n\n    ap_xlate_proto_to_ascii(headfield, len);\n    return apr_brigade_write(bb, NULL, NULL, headfield, len);\n#else\n    struct iovec vec[4];\n    struct iovec *v = vec;\n    v->iov_base = (void *)name;\n    v->iov_len = strlen(name);\n    v++;\n    v->iov_base = \": \";\n    v->iov_len = sizeof(\": \") - 1;\n    v++;\n    v->iov_base = (void *)value;\n    v->iov_len = strlen(value);\n    v++;\n    v->iov_base = CRLF;\n    v->iov_len = sizeof(CRLF) - 1;\n    return apr_brigade_writev(bb, NULL, NULL, vec, 4);\n#endif /* !APR_CHARSET_EBCDIC */\n}"
          },
          "apr_table_unset": {
            "declaration": "APR_DECLARE(void) apr_table_unset(apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "iovec": {
            "name": "iovec",
            "definition": "struct iovec\n  {\n    void *iov_base;\t/* Pointer to data.  */\n    size_t iov_len;\t/* Length of data.  */\n  }",
            "typedef_name": null,
            "fields": {
              "iov_base": "void *",
              "iov_len": "size_t"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "static void h1_append_response_head(request_rec *r,\n                                    ap_bucket_response *resp,\n                                    const char *protocol,\n                                    apr_bucket_brigade *bb)\n{\n    const char *date = NULL;\n    const char *server = NULL;\n    const char *status_line;\n    struct iovec vec[4];\n\n    if (r->assbackwards) {\n        /* there are no headers to send */\n        return;\n    }\n\n    /* Output the HTTP/1.x Status-Line and the Date and Server fields */\n    if (resp->reason) {\n        status_line =  apr_psprintf(r->pool, \"%d %s\", resp->status, resp->reason);\n    }\n    else {\n        status_line = ap_get_status_line_ex(r->pool, resp->status);\n    }\n\n    vec[0].iov_base = (void *)protocol;\n    vec[0].iov_len  = strlen(protocol);\n    vec[1].iov_base = (void *)\" \";\n    vec[1].iov_len  = sizeof(\" \") - 1;\n    vec[2].iov_base = (void *)(status_line);\n    vec[2].iov_len  = strlen(status_line);\n    vec[3].iov_base = (void *)CRLF;\n    vec[3].iov_len  = sizeof(CRLF) - 1;\n#if APR_CHARSET_EBCDIC\n    {\n        char *tmp;\n        apr_size_t len;\n        tmp = apr_pstrcatv(r->pool, vec, 4, &len);\n        ap_xlate_proto_to_ascii(tmp, len);\n        apr_brigade_write(bb, NULL, NULL, tmp, len);\n    }\n#else\n    apr_brigade_writev(bb, NULL, NULL, vec, 4);\n#endif\n\n    date = apr_table_get(resp->headers, \"Date\");\n    server = apr_table_get(resp->headers, \"Server\");\n    if (date) {\n        /* We always write that as first, just because we\n         * always did and some quirky clients might rely on that.\n         */\n        ap_h1_append_header(bb, r->pool, \"Date\", date);\n        apr_table_unset(resp->headers, \"Date\");\n    }\n    if (server) {\n        /* We always write that second, just because we\n         * always did and some quirky clients might rely on that.\n         */\n        ap_h1_append_header(bb, r->pool, \"Server\", server);\n        apr_table_unset(resp->headers, \"Server\");\n    }\n\n    if (APLOGrtrace3(r)) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                      \"Response sent with status %d%s\",\n                      r->status,\n                      APLOGrtrace4(r) ? \", headers:\" : \"\");\n\n        /*\n         * Date and Server are less interesting, use TRACE5 for them while\n         * using TRACE4 for the other headers.\n         */\n        if (date)\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE5, 0, r, \"  Date: %s\",\n                          date);\n        if (server)\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE5, 0, r, \"  Server: %s\",\n                          server);\n    }\n}"
    },
    "ap_h1_response_out_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1896, column 14>": {
      "basic_info": {
        "function_id": 1491,
        "name": "ap_h1_response_out_filter",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 1896, column 14>",
        "is_definition": true,
        "start_line": 1896,
        "end_line": 2040,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "f",
            "type": "ap_filter_t *"
          },
          {
            "name": "b",
            "type": "apr_bucket_brigade *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "memset": {
            "declaration": "extern void *memset (void *__s, int __c, size_t __n) __THROW __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "ap_remove_output_filter": {
            "declaration": "AP_DECLARE(void) ap_remove_output_filter(ap_filter_t *f)",
            "is_external": true,
            "definition": null
          },
          "AP_BUCKET_IS_RESPONSE": {
            "declaration": "AP_BUCKET_IS_RESPONSE(e)",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_create": {
            "declaration": "APU_DECLARE(apr_bucket_brigade *) apr_brigade_create(apr_pool_t *p,\n                                                     apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_split_ex": {
            "declaration": "APU_DECLARE(apr_bucket_brigade *) apr_brigade_split_ex(apr_bucket_brigade *b,\n                                                       apr_bucket *e,\n                                                       apr_bucket_brigade *a)",
            "is_external": true,
            "definition": null
          },
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "ap_h1_terminate_header": {
            "declaration": "ap_h1_terminate_header(b)",
            "is_external": false,
            "definition": "AP_DECLARE(apr_status_t) ap_h1_terminate_header(apr_bucket_brigade *bb)\n{\n    char crlf[] = CRLF;\n    apr_size_t buflen;\n\n    buflen = strlen(crlf);\n    ap_xlate_proto_to_ascii(crlf, buflen);\n    return apr_brigade_write(bb, NULL, NULL, crlf, buflen);\n}"
          },
          "destroy": {
            "declaration": "apr_bucket_delete(e)",
            "is_external": true,
            "definition": null
          },
          "free": {
            "declaration": "void (*free)(void *e)",
            "is_external": true,
            "definition": null
          },
          "ap_pass_brigade": {
            "declaration": "AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *filter,\n                                         apr_bucket_brigade *bucket)",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_cleanup": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_cleanup(void *data)",
            "is_external": true,
            "definition": null
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "ap_add_output_filter": {
            "declaration": "AP_DECLARE(ap_filter_t *) ap_add_output_filter(const char *name, void *ctx,\n                                               request_rec *r, conn_rec *c)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {
          "AP_CONN_CLOSE": {
            "name": "AP_CONN_CLOSE",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_conn_keepalive_e AP_CONN_CLOSE = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1145, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "ap_filter_t": {
            "name": "ap_filter_t",
            "definition": "struct ap_filter_t {\n    /** The internal representation of this filter.  This includes\n     *  the filter's name, type, and the actual function pointer.\n     */\n    ap_filter_rec_t *frec;\n\n    /** A place to store any data associated with the current filter */\n    void *ctx;\n\n    /** The next filter in the chain */\n    ap_filter_t *next;\n\n    /** The request_rec associated with the current filter.  If a sub-request\n     *  adds filters, then the sub-request is the request associated with the\n     *  filter.\n     */\n    request_rec *r;\n\n    /** The conn_rec associated with the current filter.  This is analogous\n     *  to the request_rec, except that it is used for connection filters.\n     */\n    conn_rec *c;\n}",
            "typedef_name": null,
            "fields": {
              "frec": "ap_filter_rec_t *",
              "ctx": "void *",
              "next": "ap_filter_t *",
              "r": "request_rec *",
              "c": "conn_rec *"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "conn_rec": {
            "name": "conn_rec",
            "definition": "struct conn_rec {\n    /** Pool associated with this connection */\n    apr_pool_t *pool;\n    /** Physical vhost this conn came in on */\n    server_rec *base_server;\n    /** used by http_vhost.c */\n    void *vhost_lookup_data;\n\n    /* Information about the connection itself */\n    /** local address */\n    apr_sockaddr_t *local_addr;\n    /** remote address; this is the end-point of the next hop, for the address\n     *  of the request creator, see useragent_addr in request_rec\n     */\n    apr_sockaddr_t *client_addr;\n\n    /** Client's IP address; this is the end-point of the next hop, for the\n     *  IP of the request creator, see useragent_ip in request_rec\n     */\n    char *client_ip;\n    /** Client's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     * get_remote_host() */\n    char *remote_host;\n    /** Only ever set if doing rfc1413 lookups.  N.B. Only access this through\n     *  get_remote_logname() */\n    char *remote_logname;\n\n    /** server IP address */\n    char *local_ip;\n    /** used for ap_get_server_name when UseCanonicalName is set to DNS\n     *  (ignores setting of HostnameLookups) */\n    char *local_host;\n\n    /** ID of this connection; unique at any point in time */\n    long id;\n    /** Config vector containing pointers to connections per-server\n     *  config structures. */\n    struct ap_conf_vector_t *conn_config;\n    /** Notes on *this* connection: send note from one module to\n     *  another. must remain valid for all requests on this conn */\n    apr_table_t *notes;\n    /** A list of input filters to be used for this connection */\n    struct ap_filter_t *input_filters;\n    /** A list of output filters to be used for this connection */\n    struct ap_filter_t *output_filters;\n    /** handle to scoreboard information for this connection */\n    void *sbh;\n    /** The bucket allocator to use for all bucket/brigade creations */\n    struct apr_bucket_alloc_t *bucket_alloc;\n    /** The current state of this connection; may be NULL if not used by MPM */\n    conn_state_t *cs;\n    /** Is there data pending in the input filters? */\n    int data_in_input_filters;\n    /** Is there data pending in the output filters? */\n    int data_in_output_filters;\n\n    /** Are there any filters that clogg/buffer the input stream, breaking\n     *  the event mpm.\n     */\n    unsigned int clogging_input_filters:1;\n\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success */\n    signed int double_reverse:2;\n\n    /** Are we still talking? */\n    unsigned aborted;\n\n    /** Are we going to keep the connection alive for another request?\n     * @see ap_conn_keepalive_e */\n    ap_conn_keepalive_e keepalive;\n\n    /** How many times have we used it? */\n    int keepalives;\n\n    /** Optional connection log level configuration. May point to a server or\n     *  per_dir config, i.e. must be copied before modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify this connection in error log. Set when the first\n     *  error log entry for this connection is generated.\n     */\n    const char *log_id;\n\n\n    /** This points to the current thread being used to process this request,\n     * over the lifetime of a request, the value may change. Users of the connection\n     * record should not rely upon it staying the same between calls that involve\n     * the MPM.\n     */\n#if APR_HAS_THREADS\n    apr_thread_t *current_thread;\n#endif\n\n    /** The \"real\" master connection. NULL if I am the master. */\n    conn_rec *master;\n\n    int outgoing;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "base_server": "server_rec *",
              "vhost_lookup_data": "void *",
              "local_addr": "apr_sockaddr_t *",
              "client_addr": "apr_sockaddr_t *",
              "client_ip": "char *",
              "remote_host": "char *",
              "remote_logname": "char *",
              "local_ip": "char *",
              "local_host": "char *",
              "id": "long",
              "conn_config": "struct ap_conf_vector_t *",
              "notes": "apr_table_t *",
              "input_filters": "struct ap_filter_t *",
              "output_filters": "struct ap_filter_t *",
              "sbh": "void *",
              "bucket_alloc": "struct apr_bucket_alloc_t *",
              "cs": "conn_state_t *",
              "data_in_input_filters": "int",
              "data_in_output_filters": "int",
              "clogging_input_filters": "unsigned int",
              "double_reverse": "int",
              "aborted": "unsigned int",
              "keepalive": "ap_conn_keepalive_e",
              "keepalives": "int",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "current_thread": "apr_thread_t *",
              "master": "conn_rec *",
              "outgoing": "int"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "h1_response_ctx": {
            "name": "h1_response_ctx",
            "definition": "struct h1_response_ctx {\n    int final_response_sent;    /* strict: a response status >= 200 was sent */\n    int discard_body;           /* the response is header only, discard body */\n    apr_bucket_brigade *tmpbb;\n}",
            "typedef_name": null,
            "fields": {
              "final_response_sent": "int",
              "discard_body": "int",
              "tmpbb": "apr_bucket_brigade *"
            },
            "condition": ""
          },
          "core_server_config": {
            "name": "core_server_config",
            "definition": "struct {\n\n    char *gprof_dir;\n\n    /* Name translations --- we want the core to be able to do *something*\n     * so it's at least a minimally functional web server on its own (and\n     * can be tested that way).  But let's keep it to the bare minimum:\n     */\n    const char *ap_document_root;\n\n    /* Access control */\n\n    char *access_name;\n    apr_array_header_t *sec_dir;\n    apr_array_header_t *sec_url;\n\n    /* recursion backstopper */\n    int redirect_limit; /* maximum number of internal redirects */\n    int subreq_limit;   /* maximum nesting level of subrequests */\n\n    const char *protocol;\n    apr_table_t *accf_map;\n\n    /* array of ap_errorlog_format_item for error log format string */\n    apr_array_header_t *error_log_format;\n    /*\n     * two arrays of arrays of ap_errorlog_format_item for additional information\n     * logged to the error log once per connection/request\n     */\n    apr_array_header_t *error_log_conn;\n    apr_array_header_t *error_log_req;\n\n    /* TRACE control */\n#define AP_TRACE_UNSET    -1\n#define AP_TRACE_DISABLE   0\n#define AP_TRACE_ENABLE    1\n#define AP_TRACE_EXTENDED  2\n    int trace_enable;\n#define AP_MERGE_TRAILERS_UNSET    0\n#define AP_MERGE_TRAILERS_ENABLE   1\n#define AP_MERGE_TRAILERS_DISABLE  2\n    int merge_trailers;\n\n    apr_array_header_t *protocols;\n    int protocols_honor_order;\n\n#define AP_HTTP09_UNSET   0\n#define AP_HTTP09_ENABLE  1\n#define AP_HTTP09_DISABLE 2\n    char http09_enable;\n\n#define AP_HTTP_CONFORMANCE_UNSET     0\n#define AP_HTTP_CONFORMANCE_UNSAFE    1\n#define AP_HTTP_CONFORMANCE_STRICT    2\n    char http_conformance;\n\n#define AP_HTTP_METHODS_UNSET         0\n#define AP_HTTP_METHODS_LENIENT       1\n#define AP_HTTP_METHODS_REGISTERED    2\n    char http_methods;\n    unsigned int merge_slashes;\n \n    apr_size_t   flush_max_threshold;\n    apr_int32_t  flush_max_pipelined;\n    unsigned int strict_host_check;\n#ifdef WIN32\n    apr_array_header_t *unc_list;\n#endif\n}",
            "typedef_name": null,
            "fields": {
              "gprof_dir": "char *",
              "ap_document_root": "const char *",
              "access_name": "char *",
              "sec_dir": "apr_array_header_t *",
              "sec_url": "apr_array_header_t *",
              "redirect_limit": "int",
              "subreq_limit": "int",
              "protocol": "const char *",
              "accf_map": "apr_table_t *",
              "error_log_format": "apr_array_header_t *",
              "error_log_conn": "apr_array_header_t *",
              "error_log_req": "apr_array_header_t *",
              "trace_enable": "int",
              "merge_trailers": "int",
              "protocols": "apr_array_header_t *",
              "protocols_honor_order": "int",
              "http09_enable": "char",
              "http_conformance": "char",
              "http_methods": "char",
              "merge_slashes": "unsigned int",
              "flush_max_threshold": "apr_size_t",
              "flush_max_pipelined": "apr_int32_t",
              "strict_host_check": "unsigned int"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "apr_bucket_type_eos": {
            "name": "apr_bucket_type_eos",
            "type": "const apr_bucket_type_t",
            "is_extern": true,
            "is_static": false,
            "definition": "extern const apr_bucket_type_t apr_bucket_type_eos",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "apr_status_t"
        ]
      },
      "source_code": "apr_status_t ap_h1_response_out_filter(ap_filter_t *f,\n                                                               apr_bucket_brigade *b)\n{\n    request_rec *r = f->r;\n    conn_rec *c = r->connection;\n    apr_bucket *e, *next = NULL;\n    h1_response_ctx *ctx = f->ctx;\n    apr_status_t rv = APR_SUCCESS;\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    int strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n\n    AP_DEBUG_ASSERT(!r->main);\n\n    if (!ctx) {\n        ctx = f->ctx = apr_pcalloc(r->pool, sizeof(*ctx));\n    }\n\n    for (e = APR_BRIGADE_FIRST(b);\n         e != APR_BRIGADE_SENTINEL(b);\n         e = next)\n    {\n        next = APR_BUCKET_NEXT(e);\n\n        if (APR_BUCKET_IS_METADATA(e)) {\n\n            if (APR_BUCKET_IS_EOS(e)) {\n                if (!ctx->final_response_sent) {\n                    /* should not happen. do we generate a 500 here? */\n                }\n                ap_remove_output_filter(f);\n                goto pass;\n            }\n            else if (AP_BUCKET_IS_RESPONSE(e)) {\n                ap_bucket_response *resp = e->data;\n\n                ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                              \"ap_h1_response_out_filter seeing response bucket status=%d\",\n                              resp->status);\n                if (strict && resp->status < 100) {\n                    /* error, not a valid http status */\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10386)\n                                  \"ap_h1_response_out_filter seeing headers \"\n                                  \"status=%d in strict mode\",\n                                  resp->status);\n                    rv = AP_FILTER_ERROR;\n                    goto cleanup;\n                }\n                else if (ctx->final_response_sent) {\n                    /* already sent the final response for the request.\n                     */\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10387)\n                                  \"ap_h1_response_out_filter seeing headers \"\n                                  \"status=%d after final response already sent\",\n                                  resp->status);\n                    rv = AP_FILTER_ERROR;\n                    goto cleanup;\n                }\n                else {\n                    /* a response status to transcode, might be final or interim\n                     */\n                    const char *proto = AP_SERVER_PROTOCOL;\n\n                    ctx->final_response_sent = (resp->status >= 200)\n                        || (!strict && resp->status < 100);\n                    ctx->discard_body = ctx->final_response_sent &&\n                        (r->header_only || AP_STATUS_IS_HEADER_ONLY(resp->status));\n\n                    if (!ctx->tmpbb) {\n                        ctx->tmpbb = apr_brigade_create(r->pool, c->bucket_alloc);\n                    }\n                    if (next != APR_BRIGADE_SENTINEL(b)) {\n                        apr_brigade_split_ex(b, next, ctx->tmpbb);\n                    }\n\n                    if (ctx->final_response_sent) {\n                        ap_h1_set_keepalive(r, resp);\n\n                        if (AP_STATUS_IS_HEADER_ONLY(resp->status)) {\n                            apr_table_unset(resp->headers, \"Transfer-Encoding\");\n                        }\n                        else if (r->chunked) {\n                            apr_table_mergen(resp->headers, \"Transfer-Encoding\", \"chunked\");\n                            apr_table_unset(resp->headers, \"Content-Length\");\n                        }\n                    }\n\n                    /* kludge around broken browsers when indicated by force-response-1.0\n                     */\n                    if (r->proto_num == HTTP_VERSION(1,0)\n                        && apr_table_get(r->subprocess_env, \"force-response-1.0\")) {\n                        r->connection->keepalive = AP_CONN_CLOSE;\n                        proto = \"HTTP/1.0\";\n                    }\n                    h1_append_response_head(r, resp, proto, b);\n                    ap_h1_append_headers(b, r, resp->headers);\n                    ap_h1_terminate_header(b);\n                    apr_bucket_delete(e);\n\n                    if (ctx->final_response_sent && r->chunked) {\n                        /* We can't add this filter until we have already sent the headers.\n                         * If we add it before this point, then the headers will be chunked\n                         * as well, and that is just wrong.\n                         */\n                        rv = ap_pass_brigade(f->next, b);\n                        apr_brigade_cleanup(b);\n                        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, rv, r,\n                                      \"ap_h1_response_out_filter passed response\"\n                                      \", add CHUNK filter\");\n                        if (APR_SUCCESS != rv) {\n                            apr_brigade_cleanup(ctx->tmpbb);\n                            goto cleanup;\n                        }\n                        ap_add_output_filter(\"CHUNK\", NULL, r, r->connection);\n                    }\n\n                    APR_BRIGADE_CONCAT(b, ctx->tmpbb);\n\n                    if (resp->status == HTTP_SWITCHING_PROTOCOLS) {\n                        /* switched to another protocol, get out of the way */\n                        AP_DEBUG_ASSERT(!r->chunked);\n                        ap_remove_output_filter(f);\n                        goto pass;\n                    }\n                }\n            }\n        }\n        else if (!ctx->final_response_sent && strict) {\n            /* data buckets before seeing the final response are in error.\n             */\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10390)\n                          \"ap_h1_response_out_filter seeing data before headers, %ld bytes \",\n                          (long)e->length);\n            rv = AP_FILTER_ERROR;\n            goto cleanup;\n        }\n        else if (ctx->discard_body) {\n            apr_bucket_delete(e);\n        }\n    }\n\npass:\n    rv = ap_pass_brigade(f->next, b);\ncleanup:\n    return rv;\n}"
    },
    "get_status_reason@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2042, column 20>": {
      "basic_info": {
        "function_id": 1492,
        "name": "get_status_reason",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2042, column 20>",
        "is_definition": true,
        "start_line": 2042,
        "end_line": 2048,
        "return_type": "const char *",
        "parameters": [
          {
            "name": "status_line",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "strlen": {
            "declaration": "extern size_t strlen (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "create_response_bucket@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2145, column 20>": {
            "source_code": "static apr_bucket *create_response_bucket(request_rec *r, apr_bucket_alloc_t *bucket_alloc)\n{\n    /* r->headers_out fully prepared. Create a headers bucket\n     * containing the response to send down the filter chain.\n     */\n    return ap_bucket_response_create(r->status, get_status_reason(r->status_line),\n                                     r->headers_out, r->notes, r->pool, bucket_alloc);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2145, column 20>"
          }
        },
        "used_macros": {},
        "used_structs": {},
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static const char *get_status_reason(const char *status_line)\n{\n    if (status_line && strlen(status_line) > 4) {\n        return status_line + 4;\n    }\n    return NULL;\n}"
    },
    "merge_response_headers@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2050, column 13>": {
      "basic_info": {
        "function_id": 1493,
        "name": "merge_response_headers",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2050, column 13>",
        "is_definition": true,
        "start_line": 2050,
        "end_line": 2143,
        "return_type": "void",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_is_empty_table": {
            "declaration": "APR_DECLARE(int) apr_is_empty_table(const apr_table_t *t)",
            "is_external": true,
            "definition": null
          },
          "apr_table_overlay": {
            "declaration": "APR_DECLARE(apr_table_t *) apr_table_overlay(apr_pool_t *p,\n                                             const apr_table_t *overlay,\n                                             const apr_table_t *base)",
            "is_external": true,
            "definition": null
          },
          "apr_table_clear": {
            "declaration": "APR_DECLARE(void) apr_table_clear(apr_table_t *t)",
            "is_external": true,
            "definition": null
          },
          "ap_set_std_response_headers": {
            "declaration": "ap_set_std_response_headers(r)",
            "is_external": true,
            "definition": null
          },
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "apr_table_unset": {
            "declaration": "APR_DECLARE(void) apr_table_unset(apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "apr_table_setn": {
            "declaration": "APR_DECLARE(void) apr_table_setn(apr_table_t *t, const char *key,\n                                 const char *val)",
            "is_external": true,
            "definition": null
          },
          "fixup_vary": {
            "declaration": "static void fixup_vary(request_rec *r)\n{\n    apr_array_header_t *varies;\n\n    varies = apr_array_make(r->pool, 5, sizeof(char *));\n\n    /* Extract all Vary fields from the headers_out, separate each into\n     * its comma-separated fieldname values, and then add them to varies\n     * if not already present in the array.\n     */\n    apr_table_do(uniq_field_values, varies, r->headers_out, \"Vary\", NULL);\n\n    /* If we found any, replace old Vary fields with unique-ified value */\n\n    if (varies->nelts > 0) {\n        apr_table_setn(r->headers_out, \"Vary\",\n                       apr_array_pstrcat(r->pool, varies, ','));\n    }\n}",
            "is_external": false,
            "definition": "static void fixup_vary(request_rec *r)\n{\n    apr_array_header_t *varies;\n\n    varies = apr_array_make(r->pool, 5, sizeof(char *));\n\n    /* Extract all Vary fields from the headers_out, separate each into\n     * its comma-separated fieldname values, and then add them to varies\n     * if not already present in the array.\n     */\n    apr_table_do(uniq_field_values, varies, r->headers_out, \"Vary\", NULL);\n\n    /* If we found any, replace old Vary fields with unique-ified value */\n\n    if (varies->nelts > 0) {\n        apr_table_setn(r->headers_out, \"Vary\",\n                       apr_array_pstrcat(r->pool, varies, ','));\n    }\n}"
          },
          "basic_http_header_check": {
            "declaration": "static void basic_http_header_check(request_rec *r)\n{\n    apr_status_t rv;\n\n    if (r->assbackwards) {\n        /* no such thing as a response protocol */\n        return;\n    }\n\n    rv = validate_status_line(r);\n\n    if (!r->status_line) {\n        r->status_line = ap_get_status_line(r->status);\n    } else if (rv != APR_SUCCESS) {\n        /* Status line is OK but our own reason phrase\n         * would be preferred if defined\n         */\n        const char *tmp = ap_get_status_line(r->status);\n        if (!strncmp(tmp, r->status_line, 3)) {\n            r->status_line = tmp;\n        }\n    }\n\n    /* Note that we must downgrade before checking for force responses. */\n    if (r->proto_num > HTTP_VERSION(1,0)\n        && apr_table_get(r->subprocess_env, \"downgrade-1.0\")) {\n        r->proto_num = HTTP_VERSION(1,0);\n    }\n}",
            "is_external": false,
            "definition": "static void basic_http_header_check(request_rec *r)\n{\n    apr_status_t rv;\n\n    if (r->assbackwards) {\n        /* no such thing as a response protocol */\n        return;\n    }\n\n    rv = validate_status_line(r);\n\n    if (!r->status_line) {\n        r->status_line = ap_get_status_line(r->status);\n    } else if (rv != APR_SUCCESS) {\n        /* Status line is OK but our own reason phrase\n         * would be preferred if defined\n         */\n        const char *tmp = ap_get_status_line(r->status);\n        if (!strncmp(tmp, r->status_line, 3)) {\n            r->status_line = tmp;\n        }\n    }\n\n    /* Note that we must downgrade before checking for force responses. */\n    if (r->proto_num > HTTP_VERSION(1,0)\n        && apr_table_get(r->subprocess_env, \"downgrade-1.0\")) {\n        r->proto_num = HTTP_VERSION(1,0);\n    }\n}"
          },
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "ap_recent_rfc822_date": {
            "declaration": "AP_DECLARE(apr_status_t) ap_recent_rfc822_date(char *date_str, apr_time_t t)",
            "is_external": true,
            "definition": null
          },
          "apr_table_addn": {
            "declaration": "APR_DECLARE(void) apr_table_addn(apr_table_t *t, const char *key,\n                                 const char *val)",
            "is_external": true,
            "definition": null
          },
          "ap_make_content_type": {
            "declaration": "AP_DECLARE(const char *) ap_make_content_type(request_rec *r,\n                                              const char *type)",
            "is_external": true,
            "definition": null
          },
          "apr_is_empty_array": {
            "declaration": "APR_DECLARE(int) apr_is_empty_array(const apr_array_header_t *a)",
            "is_external": true,
            "definition": null
          },
          "ap_get_list_item": {
            "declaration": "AP_DECLARE(char *) ap_get_list_item(apr_pool_t *p, const char **field)",
            "is_external": true,
            "definition": null
          },
          "ap_cstr_casecmp": {
            "declaration": "AP_DECLARE(int) ap_cstr_casecmp(const char *s1, const char *s2)",
            "is_external": true,
            "definition": null
          },
          "apr_array_push": {
            "declaration": "APR_DECLARE(void *) apr_array_push(apr_array_header_t *arr)",
            "is_external": true,
            "definition": null
          },
          "apr_array_pstrcat": {
            "declaration": "APR_DECLARE(char *) apr_array_pstrcat(apr_pool_t *p,\n\t\t\t\t      const apr_array_header_t *arr,\n\t\t\t\t      const char sep)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static void merge_response_headers(request_rec *r)\n{\n    const char *ctype;\n\n    /*\n     * Now that we are ready to send a response, we need to combine the two\n     * header field tables into a single table.  If we don't do this, our\n     * later attempts to set or unset a given fieldname might be bypassed.\n     */\n    if (!apr_is_empty_table(r->err_headers_out)) {\n        r->headers_out = apr_table_overlay(r->pool, r->err_headers_out,\n                                           r->headers_out);\n        apr_table_clear(r->err_headers_out);\n    }\n\n    ap_set_std_response_headers(r);\n\n    /*\n     * Remove the 'Vary' header field if the client can't handle it.\n     * Since this will have nasty effects on HTTP/1.1 caches, force\n     * the response into HTTP/1.0 mode.\n     *\n     * Note: the force-response-1.0 should come before the call to\n     *       basic_http_header_check()\n     */\n    if (apr_table_get(r->subprocess_env, \"force-no-vary\") != NULL) {\n        apr_table_unset(r->headers_out, \"Vary\");\n        r->proto_num = HTTP_VERSION(1,0);\n        apr_table_setn(r->subprocess_env, \"force-response-1.0\", \"1\");\n    }\n    else {\n        fixup_vary(r);\n    }\n\n    /* Determine the protocol and whether we should use keepalives. */\n    basic_http_header_check(r);\n\n    /*\n     * Now remove any ETag response header field if earlier processing\n     * says so (such as a 'FileETag None' directive).\n     */\n    if (apr_table_get(r->notes, \"no-etag\") != NULL) {\n        apr_table_unset(r->headers_out, \"ETag\");\n    }\n\n    /*\n     * Control cachability for non-cacheable responses if not already set by\n     * some other part of the server configuration.\n     */\n    if (r->no_cache && !apr_table_get(r->headers_out, \"Expires\")) {\n        char *date = apr_palloc(r->pool, APR_RFC822_DATE_LEN);\n        ap_recent_rfc822_date(date, r->request_time);\n        apr_table_addn(r->headers_out, \"Expires\", date);\n    }\n\n    /* 204/304 responses don't have content related headers */\n    if (AP_STATUS_IS_HEADER_ONLY(r->status)) {\n        apr_table_unset(r->headers_out, \"Transfer-Encoding\");\n        apr_table_unset(r->headers_out, \"Content-Length\");\n        r->content_type = r->content_encoding = NULL;\n        r->content_languages = NULL;\n        r->clength = r->chunked = 0;\n    }\n\n    ctype = ap_make_content_type(r, r->content_type);\n    if (ctype) {\n        apr_table_setn(r->headers_out, \"Content-Type\", ctype);\n    }\n\n    if (r->content_encoding) {\n        apr_table_setn(r->headers_out, \"Content-Encoding\",\n                       r->content_encoding);\n    }\n\n    if (!apr_is_empty_array(r->content_languages)) {\n        int i;\n        char *token;\n        char **languages = (char **)(r->content_languages->elts);\n        const char *field = apr_table_get(r->headers_out, \"Content-Language\");\n\n        while (field && (token = ap_get_list_item(r->pool, &field)) != NULL) {\n            for (i = 0; i < r->content_languages->nelts; ++i) {\n                if (!ap_cstr_casecmp(token, languages[i]))\n                    break;\n            }\n            if (i == r->content_languages->nelts) {\n                *((char **) apr_array_push(r->content_languages)) = token;\n            }\n        }\n\n        field = apr_array_pstrcat(r->pool, r->content_languages, ',');\n        apr_table_setn(r->headers_out, \"Content-Language\", field);\n    }\n}"
    },
    "create_response_bucket@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2145, column 20>": {
      "basic_info": {
        "function_id": 1494,
        "name": "create_response_bucket",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2145, column 20>",
        "is_definition": true,
        "start_line": 2145,
        "end_line": 2152,
        "return_type": "apr_bucket *",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "bucket_alloc",
            "type": "apr_bucket_alloc_t *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_bucket_response_create": {
            "declaration": "ap_bucket_response_create(r->status, get_status_reason(r->status_line),\n                                     r->headers_out, r->notes, r->pool, bucket_alloc)",
            "is_external": true,
            "definition": null
          },
          "get_status_reason": {
            "declaration": "static const char *get_status_reason(const char *status_line)\n{\n    if (status_line && strlen(status_line) > 4) {\n        return status_line + 4;\n    }\n    return NULL;\n}",
            "is_external": false,
            "definition": "static const char *get_status_reason(const char *status_line)\n{\n    if (status_line && strlen(status_line) > 4) {\n        return status_line + 4;\n    }\n    return NULL;\n}"
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_bucket_alloc_t": {
            "name": "apr_bucket_alloc_t",
            "definition": "struct apr_bucket_alloc_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static apr_bucket *create_response_bucket(request_rec *r, apr_bucket_alloc_t *bucket_alloc)\n{\n    /* r->headers_out fully prepared. Create a headers bucket\n     * containing the response to send down the filter chain.\n     */\n    return ap_bucket_response_create(r->status, get_status_reason(r->status_line),\n                                     r->headers_out, r->notes, r->pool, bucket_alloc);\n}"
    },
    "create_trailers_bucket@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2154, column 20>": {
      "basic_info": {
        "function_id": 1495,
        "name": "create_trailers_bucket",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2154, column 20>",
        "is_definition": true,
        "start_line": 2154,
        "end_line": 2161,
        "return_type": "apr_bucket *",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "bucket_alloc",
            "type": "apr_bucket_alloc_t *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_is_empty_table": {
            "declaration": "APR_DECLARE(int) apr_is_empty_table(const apr_table_t *t)",
            "is_external": true,
            "definition": null
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "ap_bucket_headers_create": {
            "declaration": "ap_bucket_headers_create(r->trailers_out, r->pool, bucket_alloc)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_bucket_alloc_t": {
            "name": "apr_bucket_alloc_t",
            "definition": "struct apr_bucket_alloc_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "static apr_bucket *create_trailers_bucket(request_rec *r, apr_bucket_alloc_t *bucket_alloc)\n{\n    if (r->trailers_out && !apr_is_empty_table(r->trailers_out)) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, \"sending trailers\");\n        return ap_bucket_headers_create(r->trailers_out, r->pool, bucket_alloc);\n    }\n    return NULL;\n}"
    },
    "read_request_line@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2179, column 21>": {
      "basic_info": {
        "function_id": 1496,
        "name": "read_request_line",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2179, column 21>",
        "is_definition": true,
        "start_line": 2179,
        "end_line": 2220,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "ctx",
            "type": "h1_request_ctx *"
          },
          {
            "name": "bb",
            "type": "apr_bucket_brigade *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_rgetline_core": {
            "declaration": "AP_DECLARE(apr_status_t) ap_rgetline_core(char **s, apr_size_t n,\n                                          apr_size_t *read,\n                                          request_rec *r, int flags,\n                                          apr_bucket_brigade *bb)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_h1_request_in_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2237, column 14>": {
            "source_code": "apr_status_t ap_h1_request_in_filter(ap_filter_t *f,\n                                     apr_bucket_brigade *bb,\n                                     ap_input_mode_t mode,\n                                     apr_read_type_e block,\n                                     apr_off_t readbytes)\n{\n    request_rec *r = f->r;\n    apr_bucket *e;\n    h1_request_ctx *ctx = f->ctx;\n    apr_status_t rv = APR_SUCCESS;\n    int http_status = HTTP_OK;\n\n    /* just get out of the way for things we don't want to handle. */\n    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {\n        return ap_get_brigade(f->next, bb, mode, block, readbytes);\n    }\n\n    if (!ctx) {\n        f->ctx = ctx = apr_pcalloc(r->pool, sizeof(*ctx));\n        ctx->r = r;\n        ctx->state = REQ_LINE;\n    }\n\n    /* This filter needs to get out of the way of read_request_line() */\n    ap_remove_input_filter(f);\n\n    while (APR_SUCCESS == rv) {\n        switch (ctx->state) {\n        case REQ_LINE:\n            if ((rv = read_request_line(ctx, bb)) != APR_SUCCESS) {\n                /* certain failures are answered with a HTTP error bucket\n                 * and are terminal for parsing a request */\n                ctx->method = ctx->uri = \"-\";\n                ctx->protocol = \"HTTP/1.0\";\n                if (APR_STATUS_IS_ENOSPC(rv)) {\n                    http_status = HTTP_REQUEST_URI_TOO_LARGE;\n                }\n                else if (APR_STATUS_IS_TIMEUP(rv)) {\n                    http_status = HTTP_REQUEST_TIME_OUT;\n                }\n                else if (APR_STATUS_IS_BADARG(rv)) {\n                    http_status = HTTP_BAD_REQUEST;\n                }\n                else if (APR_STATUS_IS_EINVAL(rv)) {\n                    http_status = HTTP_BAD_REQUEST;\n                }\n                goto cleanup;\n            }\n\n            if (!ap_h1_tokenize_request_line(r, ctx->request_line,\n                                             &ctx->method, &ctx->uri, &ctx->protocol)) {\n                http_status = HTTP_BAD_REQUEST;\n                goto cleanup;\n            }\n            /* got the request line and it looked to contain what we need */\n            ctx->state = REQ_HEADERS;\n            break;\n\n        case REQ_HEADERS:\n            ap_get_mime_headers_core(r, bb);\n            if (r->status != HTTP_OK) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00567)\n                              \"request failed: error reading the headers\");\n                http_status = r->status;\n                goto cleanup;\n            }\n            /* clear the brigade, as ap_get_mime_headers_core() leaves the last\n             * empty line in there, insert the REQUEST bucket and return */\n            apr_brigade_cleanup(bb);\n            e = ap_bucket_request_createn(ctx->method, ctx->uri,\n                                          ctx->protocol, r->headers_in,\n                                          r->pool, r->connection->bucket_alloc);\n            /* reading may leave 0 length data buckets in the brigade,\n             * get rid of those. */\n            sanitize_brigade(bb);\n            APR_BRIGADE_INSERT_HEAD(bb, e);\n            ctx->state = REQ_BODY;\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE1, rv, r,\n                          \"http1 request and headers parsed: %s %s %s\",\n                          ctx->method, ctx->uri, ctx->protocol);\n            goto cleanup;\n\n        case REQ_BODY:\n            /* we should not come here */\n            AP_DEBUG_ASSERT(0);\n            rv = ap_get_brigade(f->next, bb, mode, block, readbytes);\n            goto cleanup;\n\n        case REQ_ERROR:\n        default:\n            rv = APR_EINVAL;\n            goto cleanup;\n        }\n    } /* while(APR_SUCCESS == rv) */\n\ncleanup:\n    if (http_status != HTTP_OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                      \"failed reading request line, returning error bucket %d\", http_status);\n        apr_brigade_cleanup(bb);\n        e = ap_bucket_error_create(http_status, NULL, r->pool,\n                                   f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n        ctx->state = REQ_ERROR;\n        return APR_SUCCESS;\n    }\n    return rv;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2237, column 14>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "h1_request_ctx": {
            "name": "h1_request_ctx",
            "definition": "struct h1_request_ctx {\n    enum\n    {\n        REQ_LINE, /* reading 1st request line */\n        REQ_HEADERS, /* reading header lines */\n        REQ_BODY, /* reading body follows, terminal */\n        REQ_ERROR, /* failed, terminal */\n    } state;\n\n    request_rec *r;\n    char *request_line;\n    const char *method;\n    const char *uri;\n    const char *protocol;\n}",
            "typedef_name": null,
            "fields": {
              "state": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:2164:5)",
              "r": "request_rec *",
              "request_line": "char *",
              "method": "const char *",
              "uri": "const char *",
              "protocol": "const char *"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "core_server_config": {
            "name": "core_server_config",
            "definition": "struct {\n\n    char *gprof_dir;\n\n    /* Name translations --- we want the core to be able to do *something*\n     * so it's at least a minimally functional web server on its own (and\n     * can be tested that way).  But let's keep it to the bare minimum:\n     */\n    const char *ap_document_root;\n\n    /* Access control */\n\n    char *access_name;\n    apr_array_header_t *sec_dir;\n    apr_array_header_t *sec_url;\n\n    /* recursion backstopper */\n    int redirect_limit; /* maximum number of internal redirects */\n    int subreq_limit;   /* maximum nesting level of subrequests */\n\n    const char *protocol;\n    apr_table_t *accf_map;\n\n    /* array of ap_errorlog_format_item for error log format string */\n    apr_array_header_t *error_log_format;\n    /*\n     * two arrays of arrays of ap_errorlog_format_item for additional information\n     * logged to the error log once per connection/request\n     */\n    apr_array_header_t *error_log_conn;\n    apr_array_header_t *error_log_req;\n\n    /* TRACE control */\n#define AP_TRACE_UNSET    -1\n#define AP_TRACE_DISABLE   0\n#define AP_TRACE_ENABLE    1\n#define AP_TRACE_EXTENDED  2\n    int trace_enable;\n#define AP_MERGE_TRAILERS_UNSET    0\n#define AP_MERGE_TRAILERS_ENABLE   1\n#define AP_MERGE_TRAILERS_DISABLE  2\n    int merge_trailers;\n\n    apr_array_header_t *protocols;\n    int protocols_honor_order;\n\n#define AP_HTTP09_UNSET   0\n#define AP_HTTP09_ENABLE  1\n#define AP_HTTP09_DISABLE 2\n    char http09_enable;\n\n#define AP_HTTP_CONFORMANCE_UNSET     0\n#define AP_HTTP_CONFORMANCE_UNSAFE    1\n#define AP_HTTP_CONFORMANCE_STRICT    2\n    char http_conformance;\n\n#define AP_HTTP_METHODS_UNSET         0\n#define AP_HTTP_METHODS_LENIENT       1\n#define AP_HTTP_METHODS_REGISTERED    2\n    char http_methods;\n    unsigned int merge_slashes;\n \n    apr_size_t   flush_max_threshold;\n    apr_int32_t  flush_max_pipelined;\n    unsigned int strict_host_check;\n#ifdef WIN32\n    apr_array_header_t *unc_list;\n#endif\n}",
            "typedef_name": null,
            "fields": {
              "gprof_dir": "char *",
              "ap_document_root": "const char *",
              "access_name": "char *",
              "sec_dir": "apr_array_header_t *",
              "sec_url": "apr_array_header_t *",
              "redirect_limit": "int",
              "subreq_limit": "int",
              "protocol": "const char *",
              "accf_map": "apr_table_t *",
              "error_log_format": "apr_array_header_t *",
              "error_log_conn": "apr_array_header_t *",
              "error_log_req": "apr_array_header_t *",
              "trace_enable": "int",
              "merge_trailers": "int",
              "protocols": "apr_array_header_t *",
              "protocols_honor_order": "int",
              "http09_enable": "char",
              "http_conformance": "char",
              "http_methods": "char",
              "merge_slashes": "unsigned int",
              "flush_max_threshold": "apr_size_t",
              "flush_max_pipelined": "apr_int32_t",
              "strict_host_check": "unsigned int"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "apr_size_t",
          "apr_status_t"
        ]
      },
      "source_code": "static apr_status_t read_request_line(h1_request_ctx *ctx, apr_bucket_brigade *bb)\n{\n    apr_size_t len;\n    int num_blank_lines = DEFAULT_LIMIT_BLANK_LINES;\n    core_server_config *conf = ap_get_core_module_config(ctx->r->server->module_config);\n    int strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n    apr_status_t rv;\n\n    /* Read past empty lines until we get a real request line,\n     * a read error, the connection closes (EOF), or we timeout.\n     *\n     * We skip empty lines because browsers have to tack a CRLF on to the end\n     * of POSTs to support old CERN webservers.  But note that we may not\n     * have flushed any previous response completely to the client yet.\n     * We delay the flush as long as possible so that we can improve\n     * performance for clients that are pipelining requests.  If a request\n     * is pipelined then we won't block during the (implicit) read() below.\n     * If the requests aren't pipelined, then the client is still waiting\n     * for the final buffer flush from us, and we will block in the implicit\n     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will\n     * have to block during a read.\n     */\n    do {\n        /* ensure ap_rgetline allocates memory each time thru the loop\n         * if there are empty lines\n         */\n        ctx->request_line = NULL;\n        len = 0;\n        rv = ap_rgetline(&ctx->request_line, (apr_size_t)(ctx->r->server->limit_req_line + 2),\n                         &len, ctx->r, strict ? AP_GETLINE_CRLF : 0, bb);\n\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n        else if (len > 0) {\n            /* got the line in ctx->r->the_request */\n            return APR_SUCCESS;\n        }\n    } while (--num_blank_lines >= 0);\n    /* too many blank lines */\n    return APR_EINVAL;\n}"
    },
    "sanitize_brigade@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2222, column 13>": {
      "basic_info": {
        "function_id": 1497,
        "name": "sanitize_brigade",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2222, column 13>",
        "is_definition": true,
        "start_line": 2222,
        "end_line": 2235,
        "return_type": "void",
        "parameters": [
          {
            "name": "bb",
            "type": "apr_bucket_brigade *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "destroy": {
            "declaration": "apr_bucket_delete(e)",
            "is_external": true,
            "definition": null
          },
          "free": {
            "declaration": "void (*free)(void *e)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_h1_request_in_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2237, column 14>": {
            "source_code": "apr_status_t ap_h1_request_in_filter(ap_filter_t *f,\n                                     apr_bucket_brigade *bb,\n                                     ap_input_mode_t mode,\n                                     apr_read_type_e block,\n                                     apr_off_t readbytes)\n{\n    request_rec *r = f->r;\n    apr_bucket *e;\n    h1_request_ctx *ctx = f->ctx;\n    apr_status_t rv = APR_SUCCESS;\n    int http_status = HTTP_OK;\n\n    /* just get out of the way for things we don't want to handle. */\n    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {\n        return ap_get_brigade(f->next, bb, mode, block, readbytes);\n    }\n\n    if (!ctx) {\n        f->ctx = ctx = apr_pcalloc(r->pool, sizeof(*ctx));\n        ctx->r = r;\n        ctx->state = REQ_LINE;\n    }\n\n    /* This filter needs to get out of the way of read_request_line() */\n    ap_remove_input_filter(f);\n\n    while (APR_SUCCESS == rv) {\n        switch (ctx->state) {\n        case REQ_LINE:\n            if ((rv = read_request_line(ctx, bb)) != APR_SUCCESS) {\n                /* certain failures are answered with a HTTP error bucket\n                 * and are terminal for parsing a request */\n                ctx->method = ctx->uri = \"-\";\n                ctx->protocol = \"HTTP/1.0\";\n                if (APR_STATUS_IS_ENOSPC(rv)) {\n                    http_status = HTTP_REQUEST_URI_TOO_LARGE;\n                }\n                else if (APR_STATUS_IS_TIMEUP(rv)) {\n                    http_status = HTTP_REQUEST_TIME_OUT;\n                }\n                else if (APR_STATUS_IS_BADARG(rv)) {\n                    http_status = HTTP_BAD_REQUEST;\n                }\n                else if (APR_STATUS_IS_EINVAL(rv)) {\n                    http_status = HTTP_BAD_REQUEST;\n                }\n                goto cleanup;\n            }\n\n            if (!ap_h1_tokenize_request_line(r, ctx->request_line,\n                                             &ctx->method, &ctx->uri, &ctx->protocol)) {\n                http_status = HTTP_BAD_REQUEST;\n                goto cleanup;\n            }\n            /* got the request line and it looked to contain what we need */\n            ctx->state = REQ_HEADERS;\n            break;\n\n        case REQ_HEADERS:\n            ap_get_mime_headers_core(r, bb);\n            if (r->status != HTTP_OK) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00567)\n                              \"request failed: error reading the headers\");\n                http_status = r->status;\n                goto cleanup;\n            }\n            /* clear the brigade, as ap_get_mime_headers_core() leaves the last\n             * empty line in there, insert the REQUEST bucket and return */\n            apr_brigade_cleanup(bb);\n            e = ap_bucket_request_createn(ctx->method, ctx->uri,\n                                          ctx->protocol, r->headers_in,\n                                          r->pool, r->connection->bucket_alloc);\n            /* reading may leave 0 length data buckets in the brigade,\n             * get rid of those. */\n            sanitize_brigade(bb);\n            APR_BRIGADE_INSERT_HEAD(bb, e);\n            ctx->state = REQ_BODY;\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE1, rv, r,\n                          \"http1 request and headers parsed: %s %s %s\",\n                          ctx->method, ctx->uri, ctx->protocol);\n            goto cleanup;\n\n        case REQ_BODY:\n            /* we should not come here */\n            AP_DEBUG_ASSERT(0);\n            rv = ap_get_brigade(f->next, bb, mode, block, readbytes);\n            goto cleanup;\n\n        case REQ_ERROR:\n        default:\n            rv = APR_EINVAL;\n            goto cleanup;\n        }\n    } /* while(APR_SUCCESS == rv) */\n\ncleanup:\n    if (http_status != HTTP_OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                      \"failed reading request line, returning error bucket %d\", http_status);\n        apr_brigade_cleanup(bb);\n        e = ap_bucket_error_create(http_status, NULL, r->pool,\n                                   f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n        ctx->state = REQ_ERROR;\n        return APR_SUCCESS;\n    }\n    return rv;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2237, column 14>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static void sanitize_brigade(apr_bucket_brigade *bb)\n{\n    apr_bucket *e, *next;\n\n    for (e = APR_BRIGADE_FIRST(bb);\n         e != APR_BRIGADE_SENTINEL(bb);\n         e = next)\n    {\n        next = APR_BUCKET_NEXT(e);\n        if (!APR_BUCKET_IS_METADATA(e) && e->length == 0) {\n            apr_bucket_delete(e);\n        }\n    }\n}"
    },
    "ap_h1_request_in_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2237, column 14>": {
      "basic_info": {
        "function_id": 1498,
        "name": "ap_h1_request_in_filter",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2237, column 14>",
        "is_definition": true,
        "start_line": 2237,
        "end_line": 2344,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "f",
            "type": "ap_filter_t *"
          },
          {
            "name": "bb",
            "type": "apr_bucket_brigade *"
          },
          {
            "name": "mode",
            "type": "ap_input_mode_t"
          },
          {
            "name": "block",
            "type": "apr_read_type_e"
          },
          {
            "name": "readbytes",
            "type": "apr_off_t"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_get_brigade": {
            "declaration": "AP_DECLARE(apr_status_t) ap_get_brigade(ap_filter_t *filter,\n                                        apr_bucket_brigade *bucket,\n                                        ap_input_mode_t mode,\n                                        apr_read_type_e block,\n                                        apr_off_t readbytes)",
            "is_external": true,
            "definition": null
          },
          "memset": {
            "declaration": "extern void *memset (void *__s, int __c, size_t __n) __THROW __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "ap_remove_input_filter": {
            "declaration": "AP_DECLARE(void) ap_remove_input_filter(ap_filter_t *f)",
            "is_external": true,
            "definition": null
          },
          "read_request_line": {
            "declaration": "static apr_status_t read_request_line(h1_request_ctx *ctx, apr_bucket_brigade *bb)\n{\n    apr_size_t len;\n    int num_blank_lines = DEFAULT_LIMIT_BLANK_LINES;\n    core_server_config *conf = ap_get_core_module_config(ctx->r->server->module_config);\n    int strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n    apr_status_t rv;\n\n    /* Read past empty lines until we get a real request line,\n     * a read error, the connection closes (EOF), or we timeout.\n     *\n     * We skip empty lines because browsers have to tack a CRLF on to the end\n     * of POSTs to support old CERN webservers.  But note that we may not\n     * have flushed any previous response completely to the client yet.\n     * We delay the flush as long as possible so that we can improve\n     * performance for clients that are pipelining requests.  If a request\n     * is pipelined then we won't block during the (implicit) read() below.\n     * If the requests aren't pipelined, then the client is still waiting\n     * for the final buffer flush from us, and we will block in the implicit\n     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will\n     * have to block during a read.\n     */\n    do {\n        /* ensure ap_rgetline allocates memory each time thru the loop\n         * if there are empty lines\n         */\n        ctx->request_line = NULL;\n        len = 0;\n        rv = ap_rgetline(&ctx->request_line, (apr_size_t)(ctx->r->server->limit_req_line + 2),\n                         &len, ctx->r, strict ? AP_GETLINE_CRLF : 0, bb);\n\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n        else if (len > 0) {\n            /* got the line in ctx->r->the_request */\n            return APR_SUCCESS;\n        }\n    } while (--num_blank_lines >= 0);\n    /* too many blank lines */\n    return APR_EINVAL;\n}",
            "is_external": false,
            "definition": "static apr_status_t read_request_line(h1_request_ctx *ctx, apr_bucket_brigade *bb)\n{\n    apr_size_t len;\n    int num_blank_lines = DEFAULT_LIMIT_BLANK_LINES;\n    core_server_config *conf = ap_get_core_module_config(ctx->r->server->module_config);\n    int strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n    apr_status_t rv;\n\n    /* Read past empty lines until we get a real request line,\n     * a read error, the connection closes (EOF), or we timeout.\n     *\n     * We skip empty lines because browsers have to tack a CRLF on to the end\n     * of POSTs to support old CERN webservers.  But note that we may not\n     * have flushed any previous response completely to the client yet.\n     * We delay the flush as long as possible so that we can improve\n     * performance for clients that are pipelining requests.  If a request\n     * is pipelined then we won't block during the (implicit) read() below.\n     * If the requests aren't pipelined, then the client is still waiting\n     * for the final buffer flush from us, and we will block in the implicit\n     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will\n     * have to block during a read.\n     */\n    do {\n        /* ensure ap_rgetline allocates memory each time thru the loop\n         * if there are empty lines\n         */\n        ctx->request_line = NULL;\n        len = 0;\n        rv = ap_rgetline(&ctx->request_line, (apr_size_t)(ctx->r->server->limit_req_line + 2),\n                         &len, ctx->r, strict ? AP_GETLINE_CRLF : 0, bb);\n\n        if (rv != APR_SUCCESS) {\n            return rv;\n        }\n        else if (len > 0) {\n            /* got the line in ctx->r->the_request */\n            return APR_SUCCESS;\n        }\n    } while (--num_blank_lines >= 0);\n    /* too many blank lines */\n    return APR_EINVAL;\n}"
          },
          "ap_h1_tokenize_request_line": {
            "declaration": "ap_h1_tokenize_request_line(r, ctx->request_line,\n                                             &ctx->method, &ctx->uri, &ctx->protocol)",
            "is_external": false,
            "definition": "AP_DECLARE(int) ap_h1_tokenize_request_line(\n        request_rec *r, const char *line,\n        const char **pmethod, const char **puri, const char **pprotocol)\n{\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    int strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n    rrl_error error;\n    const char *error_token;\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                  \"ap_tokenize_request_line: '%s'\", line);\n    error = tokenize_request_line(apr_pstrdup(r->pool, line), strict, pmethod,\n                                  puri, pprotocol, &error_token);\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                  \"ap_tokenize_request: error=%d, method=%s, uri=%s, protocol=%s\",\n                  error, *pmethod, *puri, *pprotocol);\n    if (error != rrl_none) {\n        rrl_log_error(r, error, error_token);\n        return 0;\n    }\n    return 1;\n}"
          },
          "ap_get_mime_headers_core": {
            "declaration": "AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r,\n                                          apr_bucket_brigade *bb)",
            "is_external": true,
            "definition": null
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_cleanup": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_cleanup(void *data)",
            "is_external": true,
            "definition": null
          },
          "ap_bucket_request_createn": {
            "declaration": "ap_bucket_request_createn(ctx->method, ctx->uri,\n                                          ctx->protocol, r->headers_in,\n                                          r->pool, r->connection->bucket_alloc)",
            "is_external": true,
            "definition": null
          },
          "sanitize_brigade": {
            "declaration": "static void sanitize_brigade(apr_bucket_brigade *bb)\n{\n    apr_bucket *e, *next;\n\n    for (e = APR_BRIGADE_FIRST(bb);\n         e != APR_BRIGADE_SENTINEL(bb);\n         e = next)\n    {\n        next = APR_BUCKET_NEXT(e);\n        if (!APR_BUCKET_IS_METADATA(e) && e->length == 0) {\n            apr_bucket_delete(e);\n        }\n    }\n}",
            "is_external": false,
            "definition": "static void sanitize_brigade(apr_bucket_brigade *bb)\n{\n    apr_bucket *e, *next;\n\n    for (e = APR_BRIGADE_FIRST(bb);\n         e != APR_BRIGADE_SENTINEL(bb);\n         e = next)\n    {\n        next = APR_BUCKET_NEXT(e);\n        if (!APR_BUCKET_IS_METADATA(e) && e->length == 0) {\n            apr_bucket_delete(e);\n        }\n    }\n}"
          },
          "ap_bucket_error_create": {
            "declaration": "AP_DECLARE(apr_bucket *) ap_bucket_error_create(int error, const char *buf,\n                                                apr_pool_t *p,\n                                                apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {
          "AP_MODE_READBYTES": {
            "name": "AP_MODE_READBYTES",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_input_mode_t AP_MODE_READBYTES = 0",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/util_filter.h', line 43, column 5>",
            "condition": ""
          },
          "AP_MODE_GETLINE": {
            "name": "AP_MODE_GETLINE",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_input_mode_t AP_MODE_GETLINE = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/util_filter.h', line 48, column 5>",
            "condition": ""
          },
          "REQ_LINE": {
            "name": "REQ_LINE",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:2164:5) REQ_LINE = 0",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2166, column 9>",
            "condition": ""
          },
          "REQ_HEADERS": {
            "name": "REQ_HEADERS",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:2164:5) REQ_HEADERS = 1",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2167, column 9>",
            "condition": ""
          },
          "REQ_BODY": {
            "name": "REQ_BODY",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:2164:5) REQ_BODY = 2",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2168, column 9>",
            "condition": ""
          },
          "REQ_ERROR": {
            "name": "REQ_ERROR",
            "value": "3",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:2164:5) REQ_ERROR = 3",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c', line 2169, column 9>",
            "condition": ""
          }
        },
        "used_structs": {
          "ap_filter_t": {
            "name": "ap_filter_t",
            "definition": "struct ap_filter_t {\n    /** The internal representation of this filter.  This includes\n     *  the filter's name, type, and the actual function pointer.\n     */\n    ap_filter_rec_t *frec;\n\n    /** A place to store any data associated with the current filter */\n    void *ctx;\n\n    /** The next filter in the chain */\n    ap_filter_t *next;\n\n    /** The request_rec associated with the current filter.  If a sub-request\n     *  adds filters, then the sub-request is the request associated with the\n     *  filter.\n     */\n    request_rec *r;\n\n    /** The conn_rec associated with the current filter.  This is analogous\n     *  to the request_rec, except that it is used for connection filters.\n     */\n    conn_rec *c;\n}",
            "typedef_name": null,
            "fields": {
              "frec": "ap_filter_rec_t *",
              "ctx": "void *",
              "next": "ap_filter_t *",
              "r": "request_rec *",
              "c": "conn_rec *"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "h1_request_ctx": {
            "name": "h1_request_ctx",
            "definition": "struct h1_request_ctx {\n    enum\n    {\n        REQ_LINE, /* reading 1st request line */\n        REQ_HEADERS, /* reading header lines */\n        REQ_BODY, /* reading body follows, terminal */\n        REQ_ERROR, /* failed, terminal */\n    } state;\n\n    request_rec *r;\n    char *request_line;\n    const char *method;\n    const char *uri;\n    const char *protocol;\n}",
            "typedef_name": null,
            "fields": {
              "state": "enum (unnamed enum at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_filters.c:2164:5)",
              "r": "request_rec *",
              "request_line": "char *",
              "method": "const char *",
              "uri": "const char *",
              "protocol": "const char *"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "ap_input_mode_t",
          "apr_off_t",
          "apr_status_t",
          "apr_read_type_e"
        ]
      },
      "source_code": "apr_status_t ap_h1_request_in_filter(ap_filter_t *f,\n                                     apr_bucket_brigade *bb,\n                                     ap_input_mode_t mode,\n                                     apr_read_type_e block,\n                                     apr_off_t readbytes)\n{\n    request_rec *r = f->r;\n    apr_bucket *e;\n    h1_request_ctx *ctx = f->ctx;\n    apr_status_t rv = APR_SUCCESS;\n    int http_status = HTTP_OK;\n\n    /* just get out of the way for things we don't want to handle. */\n    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {\n        return ap_get_brigade(f->next, bb, mode, block, readbytes);\n    }\n\n    if (!ctx) {\n        f->ctx = ctx = apr_pcalloc(r->pool, sizeof(*ctx));\n        ctx->r = r;\n        ctx->state = REQ_LINE;\n    }\n\n    /* This filter needs to get out of the way of read_request_line() */\n    ap_remove_input_filter(f);\n\n    while (APR_SUCCESS == rv) {\n        switch (ctx->state) {\n        case REQ_LINE:\n            if ((rv = read_request_line(ctx, bb)) != APR_SUCCESS) {\n                /* certain failures are answered with a HTTP error bucket\n                 * and are terminal for parsing a request */\n                ctx->method = ctx->uri = \"-\";\n                ctx->protocol = \"HTTP/1.0\";\n                if (APR_STATUS_IS_ENOSPC(rv)) {\n                    http_status = HTTP_REQUEST_URI_TOO_LARGE;\n                }\n                else if (APR_STATUS_IS_TIMEUP(rv)) {\n                    http_status = HTTP_REQUEST_TIME_OUT;\n                }\n                else if (APR_STATUS_IS_BADARG(rv)) {\n                    http_status = HTTP_BAD_REQUEST;\n                }\n                else if (APR_STATUS_IS_EINVAL(rv)) {\n                    http_status = HTTP_BAD_REQUEST;\n                }\n                goto cleanup;\n            }\n\n            if (!ap_h1_tokenize_request_line(r, ctx->request_line,\n                                             &ctx->method, &ctx->uri, &ctx->protocol)) {\n                http_status = HTTP_BAD_REQUEST;\n                goto cleanup;\n            }\n            /* got the request line and it looked to contain what we need */\n            ctx->state = REQ_HEADERS;\n            break;\n\n        case REQ_HEADERS:\n            ap_get_mime_headers_core(r, bb);\n            if (r->status != HTTP_OK) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00567)\n                              \"request failed: error reading the headers\");\n                http_status = r->status;\n                goto cleanup;\n            }\n            /* clear the brigade, as ap_get_mime_headers_core() leaves the last\n             * empty line in there, insert the REQUEST bucket and return */\n            apr_brigade_cleanup(bb);\n            e = ap_bucket_request_createn(ctx->method, ctx->uri,\n                                          ctx->protocol, r->headers_in,\n                                          r->pool, r->connection->bucket_alloc);\n            /* reading may leave 0 length data buckets in the brigade,\n             * get rid of those. */\n            sanitize_brigade(bb);\n            APR_BRIGADE_INSERT_HEAD(bb, e);\n            ctx->state = REQ_BODY;\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE1, rv, r,\n                          \"http1 request and headers parsed: %s %s %s\",\n                          ctx->method, ctx->uri, ctx->protocol);\n            goto cleanup;\n\n        case REQ_BODY:\n            /* we should not come here */\n            AP_DEBUG_ASSERT(0);\n            rv = ap_get_brigade(f->next, bb, mode, block, readbytes);\n            goto cleanup;\n\n        case REQ_ERROR:\n        default:\n            rv = APR_EINVAL;\n            goto cleanup;\n        }\n    } /* while(APR_SUCCESS == rv) */\n\ncleanup:\n    if (http_status != HTTP_OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                      \"failed reading request line, returning error bucket %d\", http_status);\n        apr_brigade_cleanup(bb);\n        e = ap_bucket_error_create(http_status, NULL, r->pool,\n                                   f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n        ctx->state = REQ_ERROR;\n        return APR_SUCCESS;\n    }\n    return rv;\n}"
    },
    "ap_http_chunk_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/chunk_filter.c', line 53, column 14>": {
      "basic_info": {
        "function_id": 1541,
        "name": "ap_http_chunk_filter",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/chunk_filter.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/chunk_filter.c', line 53, column 14>",
        "is_definition": true,
        "start_line": 53,
        "end_line": 232,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "f",
            "type": "ap_filter_t *"
          },
          {
            "name": "b",
            "type": "apr_bucket_brigade *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "memset": {
            "declaration": "extern void *memset (void *__s, int __c, size_t __n) __THROW __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "ap_remove_output_filter": {
            "declaration": "AP_DECLARE(void) ap_remove_output_filter(ap_filter_t *f)",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_split_ex": {
            "declaration": "APU_DECLARE(apr_bucket_brigade *) apr_brigade_split_ex(apr_bucket_brigade *b,\n                                                       apr_bucket *e,\n                                                       apr_bucket_brigade *a)",
            "is_external": true,
            "definition": null
          },
          "AP_BUCKET_IS_HEADERS": {
            "declaration": "AP_BUCKET_IS_HEADERS(e)",
            "is_external": true,
            "definition": null
          },
          "apr_table_make": {
            "declaration": "APR_DECLARE(apr_table_t *) apr_table_make(apr_pool_t *p, int nelts)",
            "is_external": true,
            "definition": null
          },
          "read": {
            "declaration": "apr_status_t (*read)(apr_bucket *b, const char **str, apr_size_t *len, \n                         apr_read_type_e block)",
            "is_external": true,
            "definition": null
          },
          "apr_snprintf": {
            "declaration": "APR_DECLARE_NONSTD(int) apr_snprintf(char *buf, apr_size_t len,\n                                     const char *format, ...)\n        __attribute__((format(printf,3,4)))",
            "is_external": true,
            "definition": null
          },
          "apr_bucket_transient_create": {
            "declaration": "APU_DECLARE(apr_bucket *) apr_bucket_transient_create(const char *buf, \n                                                      apr_size_t nbyte,\n                                                      apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "apr_bucket_immortal_create": {
            "declaration": "APU_DECLARE(apr_bucket *) apr_bucket_immortal_create(const char *buf, \n                                                     apr_size_t nbyte,\n                                                     apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "ap_h1_add_end_chunk": {
            "declaration": "ap_h1_add_end_chunk(b, eos, f->r, ctx->trailers)",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_h1_add_end_chunk(apr_bucket_brigade *b,\n                                     apr_bucket *eos,\n                                     request_rec *r,\n                                     apr_table_t *trailers)\n{\n    if (!trailers || apr_is_empty_table(trailers)) {\n        apr_bucket *e;\n\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                      \"append empty end chunk\");\n        e = apr_bucket_immortal_create(ZERO_ASCII CRLF_ASCII\n                                       CRLF_ASCII, 5, b->bucket_alloc);\n        if (eos) {\n            APR_BUCKET_INSERT_BEFORE(eos, e);\n        }\n        else {\n            APR_BRIGADE_INSERT_TAIL(b, e);\n        }\n    }\n    else {\n        apr_bucket_brigade *tmp;\n\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                      \"append end chunk with trailers\");\n        tmp = eos? apr_brigade_split_ex(b, eos, NULL) : NULL;\n        apr_brigade_write(b, NULL, NULL, ZERO_ASCII CRLF_ASCII, 3);\n        ap_h1_append_headers(b, r, trailers);\n        ap_h1_terminate_header(b);\n        if (tmp) APR_BRIGADE_CONCAT(b, tmp);\n    }\n}"
          },
          "ap_pass_brigade": {
            "declaration": "AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *filter,\n                                         apr_bucket_brigade *bucket)",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_cleanup": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_cleanup(void *data)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {
          "APR_BLOCK_READ": {
            "name": "APR_BLOCK_READ",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum apr_read_type_e APR_BLOCK_READ = 0",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/apr_buckets.h', line 58, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "ap_filter_t": {
            "name": "ap_filter_t",
            "definition": "struct ap_filter_t {\n    /** The internal representation of this filter.  This includes\n     *  the filter's name, type, and the actual function pointer.\n     */\n    ap_filter_rec_t *frec;\n\n    /** A place to store any data associated with the current filter */\n    void *ctx;\n\n    /** The next filter in the chain */\n    ap_filter_t *next;\n\n    /** The request_rec associated with the current filter.  If a sub-request\n     *  adds filters, then the sub-request is the request associated with the\n     *  filter.\n     */\n    request_rec *r;\n\n    /** The conn_rec associated with the current filter.  This is analogous\n     *  to the request_rec, except that it is used for connection filters.\n     */\n    conn_rec *c;\n}",
            "typedef_name": null,
            "fields": {
              "frec": "ap_filter_rec_t *",
              "ctx": "void *",
              "next": "ap_filter_t *",
              "r": "request_rec *",
              "c": "conn_rec *"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "conn_rec": {
            "name": "conn_rec",
            "definition": "struct conn_rec {\n    /** Pool associated with this connection */\n    apr_pool_t *pool;\n    /** Physical vhost this conn came in on */\n    server_rec *base_server;\n    /** used by http_vhost.c */\n    void *vhost_lookup_data;\n\n    /* Information about the connection itself */\n    /** local address */\n    apr_sockaddr_t *local_addr;\n    /** remote address; this is the end-point of the next hop, for the address\n     *  of the request creator, see useragent_addr in request_rec\n     */\n    apr_sockaddr_t *client_addr;\n\n    /** Client's IP address; this is the end-point of the next hop, for the\n     *  IP of the request creator, see useragent_ip in request_rec\n     */\n    char *client_ip;\n    /** Client's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     * get_remote_host() */\n    char *remote_host;\n    /** Only ever set if doing rfc1413 lookups.  N.B. Only access this through\n     *  get_remote_logname() */\n    char *remote_logname;\n\n    /** server IP address */\n    char *local_ip;\n    /** used for ap_get_server_name when UseCanonicalName is set to DNS\n     *  (ignores setting of HostnameLookups) */\n    char *local_host;\n\n    /** ID of this connection; unique at any point in time */\n    long id;\n    /** Config vector containing pointers to connections per-server\n     *  config structures. */\n    struct ap_conf_vector_t *conn_config;\n    /** Notes on *this* connection: send note from one module to\n     *  another. must remain valid for all requests on this conn */\n    apr_table_t *notes;\n    /** A list of input filters to be used for this connection */\n    struct ap_filter_t *input_filters;\n    /** A list of output filters to be used for this connection */\n    struct ap_filter_t *output_filters;\n    /** handle to scoreboard information for this connection */\n    void *sbh;\n    /** The bucket allocator to use for all bucket/brigade creations */\n    struct apr_bucket_alloc_t *bucket_alloc;\n    /** The current state of this connection; may be NULL if not used by MPM */\n    conn_state_t *cs;\n    /** Is there data pending in the input filters? */\n    int data_in_input_filters;\n    /** Is there data pending in the output filters? */\n    int data_in_output_filters;\n\n    /** Are there any filters that clogg/buffer the input stream, breaking\n     *  the event mpm.\n     */\n    unsigned int clogging_input_filters:1;\n\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success */\n    signed int double_reverse:2;\n\n    /** Are we still talking? */\n    unsigned aborted;\n\n    /** Are we going to keep the connection alive for another request?\n     * @see ap_conn_keepalive_e */\n    ap_conn_keepalive_e keepalive;\n\n    /** How many times have we used it? */\n    int keepalives;\n\n    /** Optional connection log level configuration. May point to a server or\n     *  per_dir config, i.e. must be copied before modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify this connection in error log. Set when the first\n     *  error log entry for this connection is generated.\n     */\n    const char *log_id;\n\n\n    /** This points to the current thread being used to process this request,\n     * over the lifetime of a request, the value may change. Users of the connection\n     * record should not rely upon it staying the same between calls that involve\n     * the MPM.\n     */\n#if APR_HAS_THREADS\n    apr_thread_t *current_thread;\n#endif\n\n    /** The \"real\" master connection. NULL if I am the master. */\n    conn_rec *master;\n\n    int outgoing;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "base_server": "server_rec *",
              "vhost_lookup_data": "void *",
              "local_addr": "apr_sockaddr_t *",
              "client_addr": "apr_sockaddr_t *",
              "client_ip": "char *",
              "remote_host": "char *",
              "remote_logname": "char *",
              "local_ip": "char *",
              "local_host": "char *",
              "id": "long",
              "conn_config": "struct ap_conf_vector_t *",
              "notes": "apr_table_t *",
              "input_filters": "struct ap_filter_t *",
              "output_filters": "struct ap_filter_t *",
              "sbh": "void *",
              "bucket_alloc": "struct apr_bucket_alloc_t *",
              "cs": "conn_state_t *",
              "data_in_input_filters": "int",
              "data_in_output_filters": "int",
              "clogging_input_filters": "unsigned int",
              "double_reverse": "int",
              "aborted": "unsigned int",
              "keepalive": "ap_conn_keepalive_e",
              "keepalives": "int",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "current_thread": "apr_thread_t *",
              "master": "conn_rec *",
              "outgoing": "int"
            },
            "condition": ""
          },
          "chunk_out_ctx": {
            "name": "chunk_out_ctx",
            "definition": "struct chunk_out_ctx {\n    int bad_gateway_seen;\n    apr_table_t *trailers;\n}",
            "typedef_name": null,
            "fields": {
              "bad_gateway_seen": "int",
              "trailers": "apr_table_t *"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "ap_bucket_error": {
            "name": "ap_bucket_error",
            "definition": "struct ap_bucket_error {\n    /** Number of buckets using this memory */\n    apr_bucket_refcount refcount;\n    /** The error code */\n    int status;\n    /** The error string */\n    const char    *data;\n}",
            "typedef_name": null,
            "fields": {
              "refcount": "apr_bucket_refcount",
              "status": "int",
              "data": "const char *"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "apr_bucket_type_eos": {
            "name": "apr_bucket_type_eos",
            "type": "const apr_bucket_type_t",
            "is_extern": true,
            "is_static": false,
            "definition": "extern const apr_bucket_type_t apr_bucket_type_eos",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          },
          "ap_bucket_type_error": {
            "name": "ap_bucket_type_error",
            "type": "const apr_bucket_type_t",
            "is_extern": true,
            "is_static": false,
            "definition": "extern const apr_bucket_type_t ap_bucket_type_error",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "apr_bucket_type_flush": {
            "name": "apr_bucket_type_flush",
            "type": "const apr_bucket_type_t",
            "is_extern": true,
            "is_static": false,
            "definition": "extern const apr_bucket_type_t apr_bucket_type_flush",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "apr_size_t",
          "apr_uint64_t",
          "apr_off_t",
          "apr_status_t"
        ]
      },
      "source_code": "apr_status_t ap_http_chunk_filter(ap_filter_t *f, apr_bucket_brigade *b)\n{\n    conn_rec *c = f->r->connection;\n    chunk_out_ctx *ctx = f->ctx;\n    apr_bucket_brigade *more, *tmp;\n    apr_bucket *e;\n    apr_status_t rv;\n\n    if (!ctx) {\n        ctx = f->ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));\n    }\n\n    for (more = tmp = NULL; b; b = more, more = NULL) {\n        apr_off_t bytes = 0;\n        apr_bucket *eos = NULL; /* EOS bucket, or FLUSH preceding EOS */\n        apr_bucket *flush = NULL;\n        /* XXX: chunk_hdr must remain at this scope since it is used in a\n         *      transient bucket.\n         */\n        char chunk_hdr[20]; /* enough space for the snprintf below */\n\n\n        for (e = APR_BRIGADE_FIRST(b);\n             e != APR_BRIGADE_SENTINEL(b);\n             e = APR_BUCKET_NEXT(e))\n        {\n            if (APR_BUCKET_IS_METADATA(e)) {\n                if (APR_BUCKET_IS_EOS(e)) {\n                    /* there shouldn't be anything after the eos */\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, f->r,\n                                  \"ap_http_chunk_filter eos seen, removing filter\");\n                    ap_remove_output_filter(f);\n                    eos = e;\n                    break;\n                }\n                if (AP_BUCKET_IS_ERROR(e) &&\n                    (((ap_bucket_error *)(e->data))->status == HTTP_BAD_GATEWAY ||\n                     ((ap_bucket_error *)(e->data))->status == HTTP_GATEWAY_TIME_OUT)) {\n                    /*\n                     * We had a broken backend. Memorize this in the filter\n                     * context.\n                     */\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, f->r,\n                                  \"ap_http_chunk_filter bad gateway error, suppressing end chunk\");\n                    ctx->bad_gateway_seen = 1;\n                    continue;\n                }\n                if (APR_BUCKET_IS_FLUSH(e)) {\n                    flush = e;\n\n                    /* Special case to catch common brigade ending of\n                     * [FLUSH] [EOS] - insert the last_chunk before\n                     * the FLUSH rather than between the FLUSH and the\n                     * EOS. */\n                    if (e != APR_BRIGADE_LAST(b)) {\n                        if (APR_BUCKET_IS_EOS(APR_BUCKET_NEXT(e))) {\n                            eos = e;\n                            /* anything after EOS is dropped, no need\n                             * to split. */\n                        }\n                        else {\n                            more = apr_brigade_split_ex(b, APR_BUCKET_NEXT(e), tmp);\n                        }\n                    }\n                    break;\n                }\n                if (AP_BUCKET_IS_HEADERS(e)) {\n                    ap_bucket_headers *hdrs = e->data;\n                    if (!apr_is_empty_table(hdrs->headers)) {\n                        if (!ctx->trailers) {\n                            ctx->trailers = apr_table_make(f->r->pool, 5);\n                        }\n                        apr_table_overlap(ctx->trailers, hdrs->headers, APR_OVERLAP_TABLES_MERGE);\n                    }\n                }\n            }\n            else if (e->length == (apr_size_t)-1) {\n                /* unknown amount of data (e.g. a pipe) */\n                const char *data;\n                apr_size_t len;\n\n                rv = apr_bucket_read(e, &data, &len, APR_BLOCK_READ);\n                if (rv != APR_SUCCESS) {\n                    return rv;\n                }\n                if (len > 0) {\n                    /*\n                     * There may be a new next bucket representing the\n                     * rest of the data stream on which a read() may\n                     * block so we pass down what we have so far.\n                     */\n                    bytes += len;\n                    more = apr_brigade_split_ex(b, APR_BUCKET_NEXT(e), tmp);\n                    break;\n                }\n                else {\n                    /* If there was nothing in this bucket then we can\n                     * safely move on to the next one without pausing\n                     * to pass down what we have counted up so far.\n                     */\n                    continue;\n                }\n            }\n            else {\n                bytes += e->length;\n            }\n        }\n\n        /*\n         * XXX: if there aren't very many bytes at this point it may\n         * be a good idea to set them aside and return for more,\n         * unless we haven't finished counting this brigade yet.\n         */\n        /* if there are content bytes, then wrap them in a chunk */\n        if (bytes > 0) {\n            apr_size_t hdr_len;\n            /*\n             * Insert the chunk header, specifying the number of bytes in\n             * the chunk.\n             */\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, f->r,\n                          \"ap_http_chunk_filter sending chunk of %\"\n                          APR_UINT64_T_HEX_FMT \" bytes\", (apr_uint64_t)bytes);\n            hdr_len = apr_snprintf(chunk_hdr, sizeof(chunk_hdr),\n                                   \"%\" APR_UINT64_T_HEX_FMT CRLF, (apr_uint64_t)bytes);\n            ap_xlate_proto_to_ascii(chunk_hdr, hdr_len);\n            e = apr_bucket_transient_create(chunk_hdr, hdr_len,\n                                            c->bucket_alloc);\n            APR_BRIGADE_INSERT_HEAD(b, e);\n\n            /*\n             * Insert the end-of-chunk CRLF before an EOS or\n             * FLUSH bucket, or appended to the brigade\n             */\n            e = apr_bucket_immortal_create(CRLF_ASCII, 2, c->bucket_alloc);\n            if (flush != NULL) {\n                APR_BUCKET_INSERT_BEFORE(flush, e);\n            }\n            else if (eos != NULL) {\n                APR_BUCKET_INSERT_BEFORE(eos, e);\n            }\n            else {\n                APR_BRIGADE_INSERT_TAIL(b, e);\n            }\n        }\n\n        /* RFC 2616, Section 3.6.1\n         *\n         * If there is an EOS bucket, then prefix it with:\n         *   1) the last-chunk marker (\"0\" CRLF)\n         *   2) the trailer\n         *   3) the end-of-chunked body CRLF\n         *\n         * We only do this if we have not seen an error bucket with\n         * status HTTP_BAD_GATEWAY. We have memorized an\n         * error bucket that we had seen in the filter context.\n         * The error bucket with status HTTP_BAD_GATEWAY indicates that the\n         * connection to the backend (mod_proxy) broke in the middle of the\n         * response. In order to signal the client that something went wrong\n         * we do not create the last-chunk marker and set c->keepalive to\n         * AP_CONN_CLOSE in the core output filter.\n         *\n         * XXX: it would be nice to combine this with the end-of-chunk\n         * marker above, but this is a bit more straight-forward for\n         * now.\n         */\n        if (eos && !ctx->bad_gateway_seen) {\n            ap_h1_add_end_chunk(b, eos, f->r, ctx->trailers);\n        }\n\n        /* pass the brigade to the next filter. */\n        rv = ap_pass_brigade(f->next, b);\n        apr_brigade_cleanup(b);\n        if (rv != APR_SUCCESS || eos != NULL) {\n            return rv;\n        }\n        tmp = b;\n    }\n    return APR_SUCCESS;\n}"
    },
    "update_r_in_filters@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 65, column 13>": {
      "basic_info": {
        "function_id": 1605,
        "name": "update_r_in_filters",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 65, column 13>",
        "is_definition": true,
        "start_line": 65,
        "end_line": 75,
        "return_type": "void",
        "parameters": [
          {
            "name": "f",
            "type": "ap_filter_t *"
          },
          {
            "name": "from",
            "type": "request_rec *"
          },
          {
            "name": "to",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {},
        "callers": {
          "ap_die_r@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 77, column 13>": {
            "source_code": "static void ap_die_r(int type, request_rec *r, int recursive_error)\n{\n    char *custom_response;\n    request_rec *r_1st_err = r;\n\n    if (type == OK || type == DONE) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    /*\n     * if we have already passed the final response down the\n     * output filter chain, we cannot generate a second final\n     * response here.\n     */\n    if (r->final_resp_passed) {\n        return;\n    }\n\n    if (!ap_is_HTTP_VALID_RESPONSE(type)) {\n        if (type != AP_FILTER_ERROR) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01579)\n                          \"Invalid response status %i\", type);\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02831)\n                          \"Response from AP_FILTER_ERROR\");\n        }\n        type = HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /*\n     * The following takes care of Apache redirects to custom response URLs\n     * Note that if we are already dealing with the response to some other\n     * error condition, we just report on the original error, and give up on\n     * any attempt to handle the other thing \"intelligently\"...\n     */\n    if (recursive_error != HTTP_OK) {\n        while (r_1st_err->prev && (r_1st_err->prev->status != HTTP_OK))\n            r_1st_err = r_1st_err->prev;  /* Get back to original error */\n\n        if (r_1st_err != r) {\n            /* The recursive error was caused by an ErrorDocument specifying\n             * an internal redirect to a bad URI.  ap_internal_redirect has\n             * changed the filter chains to point to the ErrorDocument's\n             * request_rec.  Back out those changes so we can safely use the\n             * original failing request_rec to send the canned error message.\n             *\n             * ap_send_error_response gets rid of existing resource filters\n             * on the output side, so we can skip those.\n             */\n            update_r_in_filters(r_1st_err->proto_output_filters, r, r_1st_err);\n            update_r_in_filters(r_1st_err->input_filters, r, r_1st_err);\n        }\n\n        custom_response = NULL; /* Do NOT retry the custom thing! */\n    }\n    else {\n        int error_index = ap_index_of_response(type);\n        custom_response = ap_response_code_string(r, error_index);\n        recursive_error = 0;\n    }\n\n    r->status = type;\n\n    /*\n     * This test is done here so that none of the auth modules needs to know\n     * about proxy authentication.  They treat it like normal auth, and then\n     * we tweak the status.\n     */\n    if (HTTP_UNAUTHORIZED == r->status && PROXYREQ_PROXY == r->proxyreq) {\n        r->status = HTTP_PROXY_AUTHENTICATION_REQUIRED;\n    }\n\n    /* If we don't want to keep the connection, make sure we mark that the\n     * connection is not eligible for keepalive.  If we want to keep the\n     * connection, be sure that the request body (if any) has been read.\n     */\n    if (ap_status_drops_connection(r->status)) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n    }\n\n    /*\n     * Two types of custom redirects --- plain text, and URLs. Plain text has\n     * a leading '\"', so the URL code, here, is triggered on its absence\n     */\n\n    if (custom_response && custom_response[0] != '\"') {\n\n        if (ap_is_url(custom_response)) {\n            /*\n             * The URL isn't local, so lets drop through the rest of this\n             * apache code, and continue with the usual REDIRECT handler.\n             * But note that the client will ultimately see the wrong\n             * status...\n             */\n            r->status = HTTP_MOVED_TEMPORARILY;\n            apr_table_setn(r->headers_out, \"Location\", custom_response);\n        }\n        else if (custom_response[0] == '/') {\n            const char *error_notes, *original_method;\n            int original_method_number;\n            r->no_local_copy = 1;       /* Do NOT send HTTP_NOT_MODIFIED for\n                                         * error documents! */\n            /*\n             * This redirect needs to be a GET no matter what the original\n             * method was.\n             */\n            apr_table_setn(r->subprocess_env, \"REQUEST_METHOD\", r->method);\n\n            /*\n             * Provide a special method for modules to communicate\n             * more informative (than the plain canned) messages to us.\n             * Propagate them to ErrorDocuments via the ERROR_NOTES variable:\n             */\n            if ((error_notes = apr_table_get(r->notes,\n                                             \"error-notes\")) != NULL) {\n                apr_table_setn(r->subprocess_env, \"ERROR_NOTES\", error_notes);\n            }\n            original_method = r->method;\n            original_method_number = r->method_number;\n            r->method = \"GET\";\n            r->method_number = M_GET;\n            ap_internal_redirect(custom_response, r);\n            /* preserve ability to see %<m in the access log */\n            r->method = original_method;\n            r->method_number = original_method_number;\n            return;\n        }\n        else {\n            /*\n             * Dumb user has given us a bad url to redirect to --- fake up\n             * dying with a recursive server error...\n             */\n            recursive_error = HTTP_INTERNAL_SERVER_ERROR;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01580)\n                        \"Invalid error redirection directive: %s\",\n                        custom_response);\n        }\n    }\n    ap_send_error_response(r_1st_err, recursive_error);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 77, column 13>"
          },
          "ap_internal_fast_redirect@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 689, column 18>": {
            "source_code": "AP_DECLARE(void) ap_internal_fast_redirect(request_rec *rr, request_rec *r)\n{\n    /* We need to tell POOL_DEBUG that we're guaranteeing that rr->pool\n     * will exist as long as r->pool.  Otherwise we run into troubles because\n     * some values in this request will be allocated in r->pool, and others in\n     * rr->pool.\n     */\n    apr_pool_join(r->pool, rr->pool);\n    r->proxyreq = rr->proxyreq;\n    r->no_cache = (r->no_cache && rr->no_cache);\n    r->no_local_copy = (r->no_local_copy && rr->no_local_copy);\n    r->mtime = rr->mtime;\n    r->uri = rr->uri;\n    r->filename = rr->filename;\n    r->canonical_filename = rr->canonical_filename;\n    r->path_info = rr->path_info;\n    r->args = rr->args;\n    r->finfo = rr->finfo;\n    r->handler = rr->handler;\n    ap_set_content_type_ex(r, rr->content_type, AP_REQUEST_IS_TRUSTED_CT(rr));\n    r->content_encoding = rr->content_encoding;\n    r->content_languages = rr->content_languages;\n    r->per_dir_config = rr->per_dir_config;\n    /* copy output headers from subrequest, but leave negotiation headers */\n    r->notes = apr_table_overlay(r->pool, rr->notes, r->notes);\n    r->headers_out = apr_table_overlay(r->pool, rr->headers_out,\n                                       r->headers_out);\n    r->err_headers_out = apr_table_overlay(r->pool, rr->err_headers_out,\n                                           r->err_headers_out);\n    r->trailers_out = apr_table_overlay(r->pool, rr->trailers_out,\n                                           r->trailers_out);\n    r->subprocess_env = apr_table_overlay(r->pool, rr->subprocess_env,\n                                          r->subprocess_env);\n\n    r->output_filters = rr->output_filters;\n    r->input_filters = rr->input_filters;\n\n    /* If any filters pointed at the now-defunct rr, we must point them\n     * at our \"new\" instance of r.  In particular, some of rr's structures\n     * will now be bogus (say rr->headers_out).  If a filter tried to modify\n     * their f->r structure when it is pointing to rr, the real request_rec\n     * will not get updated.  Fix that here.\n     */\n    update_r_in_filters(r->input_filters, rr, r);\n    update_r_in_filters(r->output_filters, rr, r);\n\n    if (r->main) {\n        ap_filter_t *next = r->output_filters;\n        while (next && (next != r->proto_output_filters)) {\n            if (next->frec == ap_subreq_core_filter_handle) {\n                break;\n            }\n            next = next->next;\n        }\n        if (!next || next == r->proto_output_filters) {\n            ap_add_output_filter_handle(ap_subreq_core_filter_handle,\n                                        NULL, r, r->connection);\n        }\n    }\n    else {\n        /*\n         * We need to check if we now have the SUBREQ_CORE filter in our filter\n         * chain. If this is the case we need to remove it since we are NO\n         * subrequest. But we need to keep in mind that the SUBREQ_CORE filter\n         * does not necessarily need to be the first filter in our chain. So we\n         * need to go through the chain. But we only need to walk up the chain\n         * until the proto_output_filters as the SUBREQ_CORE filter is below the\n         * protocol filters.\n         */\n        ap_filter_t *next;\n\n        next = r->output_filters;\n        while (next && (next->frec != ap_subreq_core_filter_handle)\n               && (next != r->proto_output_filters)) {\n                next = next->next;\n        }\n        if (next && (next->frec == ap_subreq_core_filter_handle)) {\n            ap_remove_output_filter(next);\n        }\n    }\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 689, column 18>"
          },
          "internal_internal_redirect@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 525, column 21>": {
            "source_code": "static request_rec *internal_internal_redirect(const char *new_uri,\n                                               request_rec *r) {\n    int access_status;\n    request_rec *new;\n    const char *vary_header;\n\n    if (ap_is_recursion_limit_exceeded(r)) {\n        ap_die(HTTP_INTERNAL_SERVER_ERROR, r);\n        return NULL;\n    }\n\n    new = (request_rec *) apr_pcalloc(r->pool, sizeof(request_rec));\n\n    new->connection = r->connection;\n    new->server     = r->server;\n    new->pool       = r->pool;\n\n    /*\n     * A whole lot of this really ought to be shared with http_protocol.c...\n     * another missing cleanup.  It's particularly inappropriate to be\n     * setting header_only, etc., here.\n     */\n\n    new->method          = r->method;\n    new->method_number   = r->method_number;\n    new->allowed_methods = ap_make_method_list(new->pool, 2);\n    ap_parse_uri(new, new_uri);\n    new->parsed_uri.port_str = r->parsed_uri.port_str;\n    new->parsed_uri.port = r->parsed_uri.port;\n\n    new->request_config = ap_create_request_config(r->pool);\n\n    new->per_dir_config = r->server->lookup_defaults;\n\n    new->prev = r;\n    r->next   = new;\n\n    new->useragent_addr = r->useragent_addr;\n    new->useragent_ip = r->useragent_ip;\n\n    /* Must have prev and next pointers set before calling create_request\n     * hook.\n     */\n    ap_run_create_request(new);\n\n    /* Inherit the rest of the protocol info... */\n\n    new->the_request = r->the_request;\n\n    new->allowed         = r->allowed;\n\n    new->status          = r->status;\n    new->assbackwards    = r->assbackwards;\n    new->header_only     = r->header_only;\n    new->protocol        = r->protocol;\n    new->proto_num       = r->proto_num;\n    new->hostname        = r->hostname;\n    new->request_time    = r->request_time;\n    new->main            = r->main;\n\n    new->headers_in      = r->headers_in;\n    new->trailers_in     = r->trailers_in;\n    new->headers_out     = apr_table_make(r->pool, 12);\n    if (ap_is_HTTP_REDIRECT(new->status)) {\n        const char *location = apr_table_get(r->headers_out, \"Location\");\n        if (location)\n            apr_table_setn(new->headers_out, \"Location\", location);\n    }\n\n    /* A module (like mod_rewrite) can force an internal redirect\n     * to carry over the Vary header (if present).\n     */\n    if (apr_table_get(r->notes, \"redirect-keeps-vary\")) {\n        if((vary_header = apr_table_get(r->headers_out, \"Vary\"))) {\n            apr_table_setn(new->headers_out, \"Vary\", vary_header);\n        }\n    }\n\n    new->err_headers_out = r->err_headers_out;\n    new->trailers_out    = apr_table_make(r->pool, 5);\n    new->subprocess_env  = rename_original_env(r->pool, r->subprocess_env);\n    new->notes           = apr_table_make(r->pool, 5);\n\n    new->htaccess        = r->htaccess;\n    new->no_cache        = r->no_cache;\n    new->expecting_100   = r->expecting_100;\n    new->no_local_copy   = r->no_local_copy;\n    new->read_length     = r->read_length;     /* We can only read it once */\n    new->vlist_validator = r->vlist_validator;\n\n    new->proto_output_filters  = r->proto_output_filters;\n    new->proto_input_filters   = r->proto_input_filters;\n\n    new->input_filters   = new->proto_input_filters;\n\n    if (new->main) {\n        ap_filter_t *f, *nextf;\n\n        /* If this is a subrequest, the filter chain may contain a\n         * mixture of filters specific to the old request (r), and\n         * some inherited from r->main.  Here, inherit that filter\n         * chain, and remove all those which are specific to the old\n         * request; ensuring the subreq filter is left in place. */\n        new->output_filters = r->output_filters;\n\n        f = new->output_filters;\n        do {\n            nextf = f->next;\n\n            if (f->r == r && f->frec != ap_subreq_core_filter_handle) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01582)\n                              \"dropping filter '%s' in internal redirect from %s to %s\",\n                              f->frec->name, r->unparsed_uri, new_uri);\n\n                /* To remove the filter, first set f->r to the *new*\n                 * request_rec, so that ->output_filters on 'new' is\n                 * changed (if necessary) when removing the filter. */\n                f->r = new;\n                ap_remove_output_filter(f);\n            }\n\n            f = nextf;\n\n            /* Stop at the protocol filters.  If a protocol filter has\n             * been newly installed for this resource, better leave it\n             * in place, though it's probably a misconfiguration or\n             * filter bug to get into this state. */\n        } while (f && f != new->proto_output_filters);\n    }\n    else {\n        /* If this is not a subrequest, clear out all\n         * resource-specific filters. */\n        new->output_filters  = new->proto_output_filters;\n    }\n\n    update_r_in_filters(new->input_filters, r, new);\n    update_r_in_filters(new->output_filters, r, new);\n\n    apr_table_setn(new->subprocess_env, \"REDIRECT_STATUS\",\n                   apr_itoa(r->pool, r->status));\n\n    /* Begin by presuming any module can make its own path_info assumptions,\n     * until some module interjects and changes the value.\n     */\n    new->used_path_info = AP_REQ_DEFAULT_PATH_INFO;\n\n#if APR_HAS_THREADS\n    new->invoke_mtx = r->invoke_mtx;\n#endif\n\n    /*\n     * XXX: hmm.  This is because mod_setenvif and mod_unique_id really need\n     * to do their thing on internal redirects as well.  Perhaps this is a\n     * misnamed function.\n     */\n    if ((access_status = ap_post_read_request(new))) {\n        ap_die(access_status, new);\n        return NULL;\n    }\n\n    return new;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 525, column 21>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "ap_filter_t": {
            "name": "ap_filter_t",
            "definition": "struct ap_filter_t {\n    /** The internal representation of this filter.  This includes\n     *  the filter's name, type, and the actual function pointer.\n     */\n    ap_filter_rec_t *frec;\n\n    /** A place to store any data associated with the current filter */\n    void *ctx;\n\n    /** The next filter in the chain */\n    ap_filter_t *next;\n\n    /** The request_rec associated with the current filter.  If a sub-request\n     *  adds filters, then the sub-request is the request associated with the\n     *  filter.\n     */\n    request_rec *r;\n\n    /** The conn_rec associated with the current filter.  This is analogous\n     *  to the request_rec, except that it is used for connection filters.\n     */\n    conn_rec *c;\n}",
            "typedef_name": null,
            "fields": {
              "frec": "ap_filter_rec_t *",
              "ctx": "void *",
              "next": "ap_filter_t *",
              "r": "request_rec *",
              "c": "conn_rec *"
            },
            "condition": ""
          },
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static void update_r_in_filters(ap_filter_t *f,\n                                request_rec *from,\n                                request_rec *to)\n{\n    while (f) {\n        if (f->r == from) {\n            f->r = to;\n        }\n        f = f->next;\n    }\n}"
    },
    "ap_die_r@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 77, column 13>": {
      "basic_info": {
        "function_id": 1606,
        "name": "ap_die_r",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 77, column 13>",
        "is_definition": true,
        "start_line": 77,
        "end_line": 218,
        "return_type": "void",
        "parameters": [
          {
            "name": "type",
            "type": "int"
          },
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "recursive_error",
            "type": "int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_finalize_request_protocol": {
            "declaration": "AP_DECLARE(void) ap_finalize_request_protocol(request_rec *r)",
            "is_external": true,
            "definition": null
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "update_r_in_filters": {
            "declaration": "static void update_r_in_filters(ap_filter_t *f,\n                                request_rec *from,\n                                request_rec *to)\n{\n    while (f) {\n        if (f->r == from) {\n            f->r = to;\n        }\n        f = f->next;\n    }\n}",
            "is_external": false,
            "definition": "static void update_r_in_filters(ap_filter_t *f,\n                                request_rec *from,\n                                request_rec *to)\n{\n    while (f) {\n        if (f->r == from) {\n            f->r = to;\n        }\n        f = f->next;\n    }\n}"
          },
          "ap_index_of_response": {
            "declaration": "AP_DECLARE(int) ap_index_of_response(int status)",
            "is_external": false,
            "definition": "AP_DECLARE(int) ap_index_of_response(int status)\n{\n    int index = index_of_response(status);\n    return (index < 0) ? LEVEL_500 : index;\n}"
          },
          "ap_response_code_string": {
            "declaration": "char *ap_response_code_string(request_rec *r, int error_index)",
            "is_external": true,
            "definition": null
          },
          "ap_is_url": {
            "declaration": "AP_DECLARE(int) ap_is_url(const char *u)",
            "is_external": true,
            "definition": null
          },
          "apr_table_setn": {
            "declaration": "APR_DECLARE(void) apr_table_setn(apr_table_t *t, const char *key,\n                                 const char *val)",
            "is_external": true,
            "definition": null
          },
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "ap_internal_redirect": {
            "declaration": "AP_DECLARE(void) ap_internal_redirect(const char *new_uri, request_rec *r)",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_internal_redirect(const char *new_uri, request_rec *r)\n{\n    int access_status;\n    request_rec *new = internal_internal_redirect(new_uri, r);\n\n    AP_INTERNAL_REDIRECT(r->uri, new_uri);\n\n    /* ap_die was already called, if an error occurred */\n    if (!new) {\n        return;\n    }\n\n    access_status = ap_run_quick_handler(new, 0);  /* Not a look-up request */\n    if (access_status == DECLINED) {\n        access_status = ap_process_request_internal(new);\n        if (access_status == OK) {\n            access_status = ap_invoke_handler(new);\n        }\n    }\n    ap_die(access_status, new);\n}"
          },
          "ap_send_error_response": {
            "declaration": "AP_DECLARE(void) ap_send_error_response(request_rec *r, int recursive_error)",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_send_error_response(request_rec *r, int recursive_error)\n{\n    int status = r->status;\n    int idx = ap_index_of_response(status);\n    char *custom_response;\n    const char *location = apr_table_get(r->headers_out, \"Location\");\n\n    /* At this point, we are starting the response over, so we have to reset\n     * this value.\n     */\n    r->eos_sent = 0;\n\n    /* and we need to get rid of any RESOURCE filters that might be lurking\n     * around, thinking they are in the middle of the original request\n     */\n\n    r->output_filters = r->proto_output_filters;\n\n    ap_run_insert_error_filter(r);\n\n    /* We need to special-case the handling of 204 and 304 responses,\n     * since they have specific HTTP requirements and do not include a\n     * message body.  Note that being assbackwards here is not an option.\n     */\n    if (AP_STATUS_IS_HEADER_ONLY(status)) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    /*\n     * It's possible that the Location field might be in r->err_headers_out\n     * instead of r->headers_out; use the latter if possible, else the\n     * former.\n     */\n    if (location == NULL) {\n        location = apr_table_get(r->err_headers_out, \"Location\");\n    }\n\n    if (!r->assbackwards) {\n\n        /* For all HTTP/1.x responses for which we generate the message,\n         * we need to avoid inheriting the \"normal status\" header fields\n         * that may have been set by the request handler before the\n         * error or redirect, except for Location on external redirects.\n         */\n        apr_table_clear(r->headers_out);\n\n        if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {\n            if ((location != NULL) && *location) {\n                apr_table_setn(r->headers_out, \"Location\", location);\n            }\n            else {\n                location = \"\";   /* avoids coredump when printing, below */\n            }\n        }\n\n        r->content_languages = NULL;\n        r->content_encoding = NULL;\n        r->clength = 0;\n\n        if (apr_table_get(r->subprocess_env,\n                          \"suppress-error-charset\") != NULL) {\n            core_request_config *request_conf =\n                        ap_get_core_module_config(r->request_config);\n            request_conf->suppress_charset = 1; /* avoid adding default\n                                                 * charset later\n                                                 */\n            ap_set_content_type_ex(r, \"text/html\", 1);\n        }\n        else {\n            ap_set_content_type_ex(r, \"text/html; charset=iso-8859-1\", 1);\n        }\n\n        if ((status == HTTP_METHOD_NOT_ALLOWED)\n            || (status == HTTP_NOT_IMPLEMENTED)) {\n            apr_table_setn(r->headers_out, \"Allow\", make_allow(r));\n        }\n\n        if (r->header_only) {\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n\n    if ((custom_response = ap_response_code_string(r, idx))) {\n        /*\n         * We have a custom response output. This should only be\n         * a text-string to write back. But if the ErrorDocument\n         * was a local redirect and the requested resource failed\n         * for any reason, the custom_response will still hold the\n         * redirect URL. We don't really want to output this URL\n         * as a text message, so first check the custom response\n         * string to ensure that it is a text-string (using the\n         * same test used in ap_die(), i.e. does it start with a \").\n         *\n         * If it's not a text string, we've got a recursive error or\n         * an external redirect.  If it's a recursive error, ap_die passes\n         * us the second error code so we can write both, and has already\n         * backed up to the original error.  If it's an external redirect,\n         * it hasn't happened yet; we may never know if it fails.\n         */\n        if (custom_response[0] == '\\\"') {\n            ap_rvputs_proto_in_ascii(r, custom_response + 1, NULL);\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n    {\n        const char *title = status_lines[idx];\n        const char *h1;\n\n        /* Accept a status_line set by a module, but only if it begins\n         * with the correct 3 digit status code\n         */\n        if (r->status_line) {\n            char *end;\n            int len = strlen(r->status_line);\n            if (len >= 3\n                && apr_strtoi64(r->status_line, &end, 10) == r->status\n                && (end - 3) == r->status_line\n                && (len < 4 || apr_isspace(r->status_line[3]))\n                && (len < 5 || apr_isalnum(r->status_line[4]))) {\n                /* Since we passed the above check, we know that length three\n                 * is equivalent to only a 3 digit numeric http status.\n                 * RFC2616 mandates a trailing space, let's add it.\n                 * If we have an empty reason phrase, we also add \"Unknown Reason\".\n                 */\n                if (len == 3) {\n                    r->status_line = apr_pstrcat(r->pool, r->status_line, \" Unknown Reason\", NULL);\n                } else if (len == 4) {\n                    r->status_line = apr_pstrcat(r->pool, r->status_line, \"Unknown Reason\", NULL);\n                }\n                title = r->status_line;\n            }\n        }\n\n        /* folks decided they didn't want the error code in the H1 text */\n        h1 = &title[4];\n\n        /* can't count on a charset filter being in place here,\n         * so do ebcdic->ascii translation explicitly (if needed)\n         */\n\n        ap_rvputs_proto_in_ascii(r,\n                  DOCTYPE_HTML_4_01\n                  \"<html><head>\\n<title>\", title,\n                  \"</title>\\n</head><body>\\n<h1>\", h1, \"</h1>\\n\",\n                  NULL);\n\n        ap_rvputs_proto_in_ascii(r,\n                                 get_canned_error_string(status, r, location),\n                                 NULL);\n\n        if (recursive_error) {\n            ap_rvputs_proto_in_ascii(r, \"<p>Additionally, a \",\n                      status_lines[ap_index_of_response(recursive_error)],\n                      \"\\nerror was encountered while trying to use an \"\n                      \"ErrorDocument to handle the request.</p>\\n\", NULL);\n        }\n        ap_rvputs_proto_in_ascii(r, ap_psignature(\"<hr>\\n\", r), NULL);\n        ap_rvputs_proto_in_ascii(r, \"</body></html>\\n\", NULL);\n    }\n    ap_finalize_request_protocol(r);\n}"
          }
        },
        "callers": {
          "ap_die@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 220, column 18>": {
            "source_code": "AP_DECLARE(void) ap_die(int type, request_rec *r)\n{\n    ap_die_r(type, r, r->status);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 220, column 18>"
          },
          "ap_process_async_request@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 405, column 6>": {
            "source_code": "void ap_process_async_request(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    int access_status;\n\n    /* Give quick handlers a shot at serving the request on the fast\n     * path, bypassing all of the other Apache hooks.\n     *\n     * This hook was added to enable serving files out of a URI keyed\n     * content cache ( e.g., Mike Abbott's Quick Shortcut Cache,\n     * described here: http://oss.sgi.com/projects/apache/mod_qsc.html )\n     *\n     * It may have other uses as well, such as routing requests directly to\n     * content handlers that have the ability to grok HTTP and do their\n     * own access checking, etc (e.g. servlet engines).\n     *\n     * Use this hook with extreme care and only if you know what you are\n     * doing.\n     */\n    AP_PROCESS_REQUEST_ENTRY((uintptr_t)r, r->uri);\n    if (ap_extended_status) {\n        ap_time_process_request(r->connection->sbh, START_PREQUEST);\n    }\n\n    if (APLOGrtrace4(r)) {\n        int i;\n        const apr_array_header_t *t_h = apr_table_elts(r->headers_in);\n        const apr_table_entry_t *t_elt = (apr_table_entry_t *)t_h->elts;\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                      \"Headers received from client:\");\n        for (i = 0; i < t_h->nelts; i++, t_elt++) {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r, \"  %s: %s\",\n                          ap_escape_logitem(r->pool, t_elt->key),\n                          ap_escape_logitem(r->pool, t_elt->val));\n        }\n    }\n\n#if APR_HAS_THREADS\n    apr_thread_mutex_create(&r->invoke_mtx, APR_THREAD_MUTEX_DEFAULT, r->pool);\n    apr_thread_mutex_lock(r->invoke_mtx);\n#endif\n    access_status = ap_run_quick_handler(r, 0);  /* Not a look-up request */\n    if (access_status == DECLINED) {\n        access_status = ap_process_request_internal(r);\n        if (access_status == OK) {\n            access_status = ap_invoke_handler(r);\n        }\n    }\n\n    if (access_status == SUSPENDED) {\n        /* TODO: Should move these steps into a generic function, so modules\n         * working on a suspended request can also call _ENTRY again.\n         */\n        AP_PROCESS_REQUEST_RETURN((uintptr_t)r, r->uri, access_status);\n        if (ap_extended_status) {\n            ap_time_process_request(c->sbh, STOP_PREQUEST);\n        }\n        if (c->cs)\n            c->cs->state = CONN_STATE_SUSPENDED;\n#if APR_HAS_THREADS\n        apr_thread_mutex_unlock(r->invoke_mtx);\n#endif\n        return;\n    }\n#if APR_HAS_THREADS\n    apr_thread_mutex_unlock(r->invoke_mtx);\n#endif\n\n    ap_die_r(access_status, r, HTTP_OK);\n\n    ap_process_request_after_handler(r);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 405, column 6>"
          }
        },
        "used_macros": {
          "AP_CONN_CLOSE": {
            "name": "AP_CONN_CLOSE",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_conn_keepalive_e AP_CONN_CLOSE = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1145, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "static void ap_die_r(int type, request_rec *r, int recursive_error)\n{\n    char *custom_response;\n    request_rec *r_1st_err = r;\n\n    if (type == OK || type == DONE) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    /*\n     * if we have already passed the final response down the\n     * output filter chain, we cannot generate a second final\n     * response here.\n     */\n    if (r->final_resp_passed) {\n        return;\n    }\n\n    if (!ap_is_HTTP_VALID_RESPONSE(type)) {\n        if (type != AP_FILTER_ERROR) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01579)\n                          \"Invalid response status %i\", type);\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02831)\n                          \"Response from AP_FILTER_ERROR\");\n        }\n        type = HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /*\n     * The following takes care of Apache redirects to custom response URLs\n     * Note that if we are already dealing with the response to some other\n     * error condition, we just report on the original error, and give up on\n     * any attempt to handle the other thing \"intelligently\"...\n     */\n    if (recursive_error != HTTP_OK) {\n        while (r_1st_err->prev && (r_1st_err->prev->status != HTTP_OK))\n            r_1st_err = r_1st_err->prev;  /* Get back to original error */\n\n        if (r_1st_err != r) {\n            /* The recursive error was caused by an ErrorDocument specifying\n             * an internal redirect to a bad URI.  ap_internal_redirect has\n             * changed the filter chains to point to the ErrorDocument's\n             * request_rec.  Back out those changes so we can safely use the\n             * original failing request_rec to send the canned error message.\n             *\n             * ap_send_error_response gets rid of existing resource filters\n             * on the output side, so we can skip those.\n             */\n            update_r_in_filters(r_1st_err->proto_output_filters, r, r_1st_err);\n            update_r_in_filters(r_1st_err->input_filters, r, r_1st_err);\n        }\n\n        custom_response = NULL; /* Do NOT retry the custom thing! */\n    }\n    else {\n        int error_index = ap_index_of_response(type);\n        custom_response = ap_response_code_string(r, error_index);\n        recursive_error = 0;\n    }\n\n    r->status = type;\n\n    /*\n     * This test is done here so that none of the auth modules needs to know\n     * about proxy authentication.  They treat it like normal auth, and then\n     * we tweak the status.\n     */\n    if (HTTP_UNAUTHORIZED == r->status && PROXYREQ_PROXY == r->proxyreq) {\n        r->status = HTTP_PROXY_AUTHENTICATION_REQUIRED;\n    }\n\n    /* If we don't want to keep the connection, make sure we mark that the\n     * connection is not eligible for keepalive.  If we want to keep the\n     * connection, be sure that the request body (if any) has been read.\n     */\n    if (ap_status_drops_connection(r->status)) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n    }\n\n    /*\n     * Two types of custom redirects --- plain text, and URLs. Plain text has\n     * a leading '\"', so the URL code, here, is triggered on its absence\n     */\n\n    if (custom_response && custom_response[0] != '\"') {\n\n        if (ap_is_url(custom_response)) {\n            /*\n             * The URL isn't local, so lets drop through the rest of this\n             * apache code, and continue with the usual REDIRECT handler.\n             * But note that the client will ultimately see the wrong\n             * status...\n             */\n            r->status = HTTP_MOVED_TEMPORARILY;\n            apr_table_setn(r->headers_out, \"Location\", custom_response);\n        }\n        else if (custom_response[0] == '/') {\n            const char *error_notes, *original_method;\n            int original_method_number;\n            r->no_local_copy = 1;       /* Do NOT send HTTP_NOT_MODIFIED for\n                                         * error documents! */\n            /*\n             * This redirect needs to be a GET no matter what the original\n             * method was.\n             */\n            apr_table_setn(r->subprocess_env, \"REQUEST_METHOD\", r->method);\n\n            /*\n             * Provide a special method for modules to communicate\n             * more informative (than the plain canned) messages to us.\n             * Propagate them to ErrorDocuments via the ERROR_NOTES variable:\n             */\n            if ((error_notes = apr_table_get(r->notes,\n                                             \"error-notes\")) != NULL) {\n                apr_table_setn(r->subprocess_env, \"ERROR_NOTES\", error_notes);\n            }\n            original_method = r->method;\n            original_method_number = r->method_number;\n            r->method = \"GET\";\n            r->method_number = M_GET;\n            ap_internal_redirect(custom_response, r);\n            /* preserve ability to see %<m in the access log */\n            r->method = original_method;\n            r->method_number = original_method_number;\n            return;\n        }\n        else {\n            /*\n             * Dumb user has given us a bad url to redirect to --- fake up\n             * dying with a recursive server error...\n             */\n            recursive_error = HTTP_INTERNAL_SERVER_ERROR;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01580)\n                        \"Invalid error redirection directive: %s\",\n                        custom_response);\n        }\n    }\n    ap_send_error_response(r_1st_err, recursive_error);\n}"
    },
    "ap_die@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 220, column 18>": {
      "basic_info": {
        "function_id": 1607,
        "name": "ap_die",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 220, column 18>",
        "is_definition": true,
        "start_line": 220,
        "end_line": 223,
        "return_type": "void",
        "parameters": [
          {
            "name": "type",
            "type": "int"
          },
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_die_r": {
            "declaration": "static void ap_die_r(int type, request_rec *r, int recursive_error)\n{\n    char *custom_response;\n    request_rec *r_1st_err = r;\n\n    if (type == OK || type == DONE) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    /*\n     * if we have already passed the final response down the\n     * output filter chain, we cannot generate a second final\n     * response here.\n     */\n    if (r->final_resp_passed) {\n        return;\n    }\n\n    if (!ap_is_HTTP_VALID_RESPONSE(type)) {\n        if (type != AP_FILTER_ERROR) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01579)\n                          \"Invalid response status %i\", type);\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02831)\n                          \"Response from AP_FILTER_ERROR\");\n        }\n        type = HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /*\n     * The following takes care of Apache redirects to custom response URLs\n     * Note that if we are already dealing with the response to some other\n     * error condition, we just report on the original error, and give up on\n     * any attempt to handle the other thing \"intelligently\"...\n     */\n    if (recursive_error != HTTP_OK) {\n        while (r_1st_err->prev && (r_1st_err->prev->status != HTTP_OK))\n            r_1st_err = r_1st_err->prev;  /* Get back to original error */\n\n        if (r_1st_err != r) {\n            /* The recursive error was caused by an ErrorDocument specifying\n             * an internal redirect to a bad URI.  ap_internal_redirect has\n             * changed the filter chains to point to the ErrorDocument's\n             * request_rec.  Back out those changes so we can safely use the\n             * original failing request_rec to send the canned error message.\n             *\n             * ap_send_error_response gets rid of existing resource filters\n             * on the output side, so we can skip those.\n             */\n            update_r_in_filters(r_1st_err->proto_output_filters, r, r_1st_err);\n            update_r_in_filters(r_1st_err->input_filters, r, r_1st_err);\n        }\n\n        custom_response = NULL; /* Do NOT retry the custom thing! */\n    }\n    else {\n        int error_index = ap_index_of_response(type);\n        custom_response = ap_response_code_string(r, error_index);\n        recursive_error = 0;\n    }\n\n    r->status = type;\n\n    /*\n     * This test is done here so that none of the auth modules needs to know\n     * about proxy authentication.  They treat it like normal auth, and then\n     * we tweak the status.\n     */\n    if (HTTP_UNAUTHORIZED == r->status && PROXYREQ_PROXY == r->proxyreq) {\n        r->status = HTTP_PROXY_AUTHENTICATION_REQUIRED;\n    }\n\n    /* If we don't want to keep the connection, make sure we mark that the\n     * connection is not eligible for keepalive.  If we want to keep the\n     * connection, be sure that the request body (if any) has been read.\n     */\n    if (ap_status_drops_connection(r->status)) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n    }\n\n    /*\n     * Two types of custom redirects --- plain text, and URLs. Plain text has\n     * a leading '\"', so the URL code, here, is triggered on its absence\n     */\n\n    if (custom_response && custom_response[0] != '\"') {\n\n        if (ap_is_url(custom_response)) {\n            /*\n             * The URL isn't local, so lets drop through the rest of this\n             * apache code, and continue with the usual REDIRECT handler.\n             * But note that the client will ultimately see the wrong\n             * status...\n             */\n            r->status = HTTP_MOVED_TEMPORARILY;\n            apr_table_setn(r->headers_out, \"Location\", custom_response);\n        }\n        else if (custom_response[0] == '/') {\n            const char *error_notes, *original_method;\n            int original_method_number;\n            r->no_local_copy = 1;       /* Do NOT send HTTP_NOT_MODIFIED for\n                                         * error documents! */\n            /*\n             * This redirect needs to be a GET no matter what the original\n             * method was.\n             */\n            apr_table_setn(r->subprocess_env, \"REQUEST_METHOD\", r->method);\n\n            /*\n             * Provide a special method for modules to communicate\n             * more informative (than the plain canned) messages to us.\n             * Propagate them to ErrorDocuments via the ERROR_NOTES variable:\n             */\n            if ((error_notes = apr_table_get(r->notes,\n                                             \"error-notes\")) != NULL) {\n                apr_table_setn(r->subprocess_env, \"ERROR_NOTES\", error_notes);\n            }\n            original_method = r->method;\n            original_method_number = r->method_number;\n            r->method = \"GET\";\n            r->method_number = M_GET;\n            ap_internal_redirect(custom_response, r);\n            /* preserve ability to see %<m in the access log */\n            r->method = original_method;\n            r->method_number = original_method_number;\n            return;\n        }\n        else {\n            /*\n             * Dumb user has given us a bad url to redirect to --- fake up\n             * dying with a recursive server error...\n             */\n            recursive_error = HTTP_INTERNAL_SERVER_ERROR;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01580)\n                        \"Invalid error redirection directive: %s\",\n                        custom_response);\n        }\n    }\n    ap_send_error_response(r_1st_err, recursive_error);\n}",
            "is_external": false,
            "definition": "static void ap_die_r(int type, request_rec *r, int recursive_error)\n{\n    char *custom_response;\n    request_rec *r_1st_err = r;\n\n    if (type == OK || type == DONE) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    /*\n     * if we have already passed the final response down the\n     * output filter chain, we cannot generate a second final\n     * response here.\n     */\n    if (r->final_resp_passed) {\n        return;\n    }\n\n    if (!ap_is_HTTP_VALID_RESPONSE(type)) {\n        if (type != AP_FILTER_ERROR) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01579)\n                          \"Invalid response status %i\", type);\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02831)\n                          \"Response from AP_FILTER_ERROR\");\n        }\n        type = HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /*\n     * The following takes care of Apache redirects to custom response URLs\n     * Note that if we are already dealing with the response to some other\n     * error condition, we just report on the original error, and give up on\n     * any attempt to handle the other thing \"intelligently\"...\n     */\n    if (recursive_error != HTTP_OK) {\n        while (r_1st_err->prev && (r_1st_err->prev->status != HTTP_OK))\n            r_1st_err = r_1st_err->prev;  /* Get back to original error */\n\n        if (r_1st_err != r) {\n            /* The recursive error was caused by an ErrorDocument specifying\n             * an internal redirect to a bad URI.  ap_internal_redirect has\n             * changed the filter chains to point to the ErrorDocument's\n             * request_rec.  Back out those changes so we can safely use the\n             * original failing request_rec to send the canned error message.\n             *\n             * ap_send_error_response gets rid of existing resource filters\n             * on the output side, so we can skip those.\n             */\n            update_r_in_filters(r_1st_err->proto_output_filters, r, r_1st_err);\n            update_r_in_filters(r_1st_err->input_filters, r, r_1st_err);\n        }\n\n        custom_response = NULL; /* Do NOT retry the custom thing! */\n    }\n    else {\n        int error_index = ap_index_of_response(type);\n        custom_response = ap_response_code_string(r, error_index);\n        recursive_error = 0;\n    }\n\n    r->status = type;\n\n    /*\n     * This test is done here so that none of the auth modules needs to know\n     * about proxy authentication.  They treat it like normal auth, and then\n     * we tweak the status.\n     */\n    if (HTTP_UNAUTHORIZED == r->status && PROXYREQ_PROXY == r->proxyreq) {\n        r->status = HTTP_PROXY_AUTHENTICATION_REQUIRED;\n    }\n\n    /* If we don't want to keep the connection, make sure we mark that the\n     * connection is not eligible for keepalive.  If we want to keep the\n     * connection, be sure that the request body (if any) has been read.\n     */\n    if (ap_status_drops_connection(r->status)) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n    }\n\n    /*\n     * Two types of custom redirects --- plain text, and URLs. Plain text has\n     * a leading '\"', so the URL code, here, is triggered on its absence\n     */\n\n    if (custom_response && custom_response[0] != '\"') {\n\n        if (ap_is_url(custom_response)) {\n            /*\n             * The URL isn't local, so lets drop through the rest of this\n             * apache code, and continue with the usual REDIRECT handler.\n             * But note that the client will ultimately see the wrong\n             * status...\n             */\n            r->status = HTTP_MOVED_TEMPORARILY;\n            apr_table_setn(r->headers_out, \"Location\", custom_response);\n        }\n        else if (custom_response[0] == '/') {\n            const char *error_notes, *original_method;\n            int original_method_number;\n            r->no_local_copy = 1;       /* Do NOT send HTTP_NOT_MODIFIED for\n                                         * error documents! */\n            /*\n             * This redirect needs to be a GET no matter what the original\n             * method was.\n             */\n            apr_table_setn(r->subprocess_env, \"REQUEST_METHOD\", r->method);\n\n            /*\n             * Provide a special method for modules to communicate\n             * more informative (than the plain canned) messages to us.\n             * Propagate them to ErrorDocuments via the ERROR_NOTES variable:\n             */\n            if ((error_notes = apr_table_get(r->notes,\n                                             \"error-notes\")) != NULL) {\n                apr_table_setn(r->subprocess_env, \"ERROR_NOTES\", error_notes);\n            }\n            original_method = r->method;\n            original_method_number = r->method_number;\n            r->method = \"GET\";\n            r->method_number = M_GET;\n            ap_internal_redirect(custom_response, r);\n            /* preserve ability to see %<m in the access log */\n            r->method = original_method;\n            r->method_number = original_method_number;\n            return;\n        }\n        else {\n            /*\n             * Dumb user has given us a bad url to redirect to --- fake up\n             * dying with a recursive server error...\n             */\n            recursive_error = HTTP_INTERNAL_SERVER_ERROR;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01580)\n                        \"Invalid error redirection directive: %s\",\n                        custom_response);\n        }\n    }\n    ap_send_error_response(r_1st_err, recursive_error);\n}"
          }
        },
        "callers": {
          "ap_internal_redirect@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 771, column 18>": {
            "source_code": "AP_DECLARE(void) ap_internal_redirect(const char *new_uri, request_rec *r)\n{\n    int access_status;\n    request_rec *new = internal_internal_redirect(new_uri, r);\n\n    AP_INTERNAL_REDIRECT(r->uri, new_uri);\n\n    /* ap_die was already called, if an error occurred */\n    if (!new) {\n        return;\n    }\n\n    access_status = ap_run_quick_handler(new, 0);  /* Not a look-up request */\n    if (access_status == DECLINED) {\n        access_status = ap_process_request_internal(new);\n        if (access_status == OK) {\n            access_status = ap_invoke_handler(new);\n        }\n    }\n    ap_die(access_status, new);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 771, column 18>"
          },
          "ap_internal_redirect_handler@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 797, column 18>": {
            "source_code": "AP_DECLARE(void) ap_internal_redirect_handler(const char *new_uri, request_rec *r)\n{\n    int access_status;\n    request_rec *new = internal_internal_redirect(new_uri, r);\n\n    /* ap_die was already called, if an error occurred */\n    if (!new) {\n        return;\n    }\n\n    if (r->handler)\n        ap_set_content_type_ex(new, r->content_type, AP_REQUEST_IS_TRUSTED_CT(r));\n    access_status = ap_process_request_internal(new);\n    if (access_status == OK) {\n        access_status = ap_invoke_handler(new);\n    }\n    ap_die(access_status, new);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 797, column 18>"
          },
          "internal_internal_redirect@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 525, column 21>": {
            "source_code": "static request_rec *internal_internal_redirect(const char *new_uri,\n                                               request_rec *r) {\n    int access_status;\n    request_rec *new;\n    const char *vary_header;\n\n    if (ap_is_recursion_limit_exceeded(r)) {\n        ap_die(HTTP_INTERNAL_SERVER_ERROR, r);\n        return NULL;\n    }\n\n    new = (request_rec *) apr_pcalloc(r->pool, sizeof(request_rec));\n\n    new->connection = r->connection;\n    new->server     = r->server;\n    new->pool       = r->pool;\n\n    /*\n     * A whole lot of this really ought to be shared with http_protocol.c...\n     * another missing cleanup.  It's particularly inappropriate to be\n     * setting header_only, etc., here.\n     */\n\n    new->method          = r->method;\n    new->method_number   = r->method_number;\n    new->allowed_methods = ap_make_method_list(new->pool, 2);\n    ap_parse_uri(new, new_uri);\n    new->parsed_uri.port_str = r->parsed_uri.port_str;\n    new->parsed_uri.port = r->parsed_uri.port;\n\n    new->request_config = ap_create_request_config(r->pool);\n\n    new->per_dir_config = r->server->lookup_defaults;\n\n    new->prev = r;\n    r->next   = new;\n\n    new->useragent_addr = r->useragent_addr;\n    new->useragent_ip = r->useragent_ip;\n\n    /* Must have prev and next pointers set before calling create_request\n     * hook.\n     */\n    ap_run_create_request(new);\n\n    /* Inherit the rest of the protocol info... */\n\n    new->the_request = r->the_request;\n\n    new->allowed         = r->allowed;\n\n    new->status          = r->status;\n    new->assbackwards    = r->assbackwards;\n    new->header_only     = r->header_only;\n    new->protocol        = r->protocol;\n    new->proto_num       = r->proto_num;\n    new->hostname        = r->hostname;\n    new->request_time    = r->request_time;\n    new->main            = r->main;\n\n    new->headers_in      = r->headers_in;\n    new->trailers_in     = r->trailers_in;\n    new->headers_out     = apr_table_make(r->pool, 12);\n    if (ap_is_HTTP_REDIRECT(new->status)) {\n        const char *location = apr_table_get(r->headers_out, \"Location\");\n        if (location)\n            apr_table_setn(new->headers_out, \"Location\", location);\n    }\n\n    /* A module (like mod_rewrite) can force an internal redirect\n     * to carry over the Vary header (if present).\n     */\n    if (apr_table_get(r->notes, \"redirect-keeps-vary\")) {\n        if((vary_header = apr_table_get(r->headers_out, \"Vary\"))) {\n            apr_table_setn(new->headers_out, \"Vary\", vary_header);\n        }\n    }\n\n    new->err_headers_out = r->err_headers_out;\n    new->trailers_out    = apr_table_make(r->pool, 5);\n    new->subprocess_env  = rename_original_env(r->pool, r->subprocess_env);\n    new->notes           = apr_table_make(r->pool, 5);\n\n    new->htaccess        = r->htaccess;\n    new->no_cache        = r->no_cache;\n    new->expecting_100   = r->expecting_100;\n    new->no_local_copy   = r->no_local_copy;\n    new->read_length     = r->read_length;     /* We can only read it once */\n    new->vlist_validator = r->vlist_validator;\n\n    new->proto_output_filters  = r->proto_output_filters;\n    new->proto_input_filters   = r->proto_input_filters;\n\n    new->input_filters   = new->proto_input_filters;\n\n    if (new->main) {\n        ap_filter_t *f, *nextf;\n\n        /* If this is a subrequest, the filter chain may contain a\n         * mixture of filters specific to the old request (r), and\n         * some inherited from r->main.  Here, inherit that filter\n         * chain, and remove all those which are specific to the old\n         * request; ensuring the subreq filter is left in place. */\n        new->output_filters = r->output_filters;\n\n        f = new->output_filters;\n        do {\n            nextf = f->next;\n\n            if (f->r == r && f->frec != ap_subreq_core_filter_handle) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01582)\n                              \"dropping filter '%s' in internal redirect from %s to %s\",\n                              f->frec->name, r->unparsed_uri, new_uri);\n\n                /* To remove the filter, first set f->r to the *new*\n                 * request_rec, so that ->output_filters on 'new' is\n                 * changed (if necessary) when removing the filter. */\n                f->r = new;\n                ap_remove_output_filter(f);\n            }\n\n            f = nextf;\n\n            /* Stop at the protocol filters.  If a protocol filter has\n             * been newly installed for this resource, better leave it\n             * in place, though it's probably a misconfiguration or\n             * filter bug to get into this state. */\n        } while (f && f != new->proto_output_filters);\n    }\n    else {\n        /* If this is not a subrequest, clear out all\n         * resource-specific filters. */\n        new->output_filters  = new->proto_output_filters;\n    }\n\n    update_r_in_filters(new->input_filters, r, new);\n    update_r_in_filters(new->output_filters, r, new);\n\n    apr_table_setn(new->subprocess_env, \"REDIRECT_STATUS\",\n                   apr_itoa(r->pool, r->status));\n\n    /* Begin by presuming any module can make its own path_info assumptions,\n     * until some module interjects and changes the value.\n     */\n    new->used_path_info = AP_REQ_DEFAULT_PATH_INFO;\n\n#if APR_HAS_THREADS\n    new->invoke_mtx = r->invoke_mtx;\n#endif\n\n    /*\n     * XXX: hmm.  This is because mod_setenvif and mod_unique_id really need\n     * to do their thing on internal redirects as well.  Perhaps this is a\n     * misnamed function.\n     */\n    if ((access_status = ap_post_read_request(new))) {\n        ap_die(access_status, new);\n        return NULL;\n    }\n\n    return new;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 525, column 21>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(void) ap_die(int type, request_rec *r)\n{\n    ap_die_r(type, r, r->status);\n}"
    },
    "ap_check_pipeline@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 225, column 26>": {
      "basic_info": {
        "function_id": 1608,
        "name": "ap_check_pipeline",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 225, column 26>",
        "is_definition": true,
        "start_line": 225,
        "end_line": 333,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "c",
            "type": "conn_rec *"
          },
          {
            "name": "bb",
            "type": "apr_bucket_brigade *"
          },
          {
            "name": "max_blank_lines",
            "type": "unsigned int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_brigade_cleanup": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_cleanup(void *data)",
            "is_external": true,
            "definition": null
          },
          "ap_get_brigade": {
            "declaration": "AP_DECLARE(apr_status_t) ap_get_brigade(ap_filter_t *filter,\n                                        apr_bucket_brigade *bucket,\n                                        ap_input_mode_t mode,\n                                        apr_read_type_e block,\n                                        apr_off_t readbytes)",
            "is_external": true,
            "definition": null
          },
          "ap_log_cerror_": {
            "declaration": "AP_DECLARE(void) ap_log_cerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const conn_rec *c, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_length": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_length(apr_bucket_brigade *bb,\n                                             int read_all,\n                                             apr_off_t *length)",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_flatten": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_flatten(apr_bucket_brigade *bb,\n                                              char *c,\n                                              apr_size_t *len)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_process_request_after_handler@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 335, column 18>": {
            "source_code": "AP_DECLARE(void) ap_process_request_after_handler(request_rec *r)\n{\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n    conn_rec *c = r->connection;\n\n    bb = ap_acquire_brigade(c);\n\n    /* Send an EOR bucket through the output filter chain.  When\n     * this bucket is destroyed, the request will be logged and\n     * its pool will be freed\n     */\n    b = ap_bucket_eor_create(c->bucket_alloc, r);\n    APR_BRIGADE_INSERT_HEAD(bb, b);\n\n    /* Find the last request, taking into account internal\n     * redirects. We want to send the EOR bucket at the end of\n     * all the buckets so it does not jump the queue.\n     */\n    while (r->next) {\n        r = r->next;\n    }\n\n    /* All the request filters should have bailed out on EOS, and in any\n     * case they shouldn't have to handle this EOR which will destroy the\n     * request underneath them. So go straight to the connection filters.\n     */\n    ap_pass_brigade(c->output_filters, bb);\n\n    /* The EOR bucket has either been handled by an output filter (eg.\n     * deleted or moved to a buffered_bb => no more in bb), or an error\n     * occurred before that (eg. c->aborted => still in bb) and we ought\n     * to destroy it now. So cleanup any remaining bucket along with\n     * the orphan request (if any).\n     */\n    apr_brigade_cleanup(bb);\n\n    /* From here onward, it is no longer safe to reference r\n     * or r->pool, because r->pool may have been destroyed\n     * already by the EOR bucket's cleanup function.\n     */\n\n    /* Check pipeline consuming blank lines, they must not be interpreted as\n     * the next pipelined request, otherwise we would block on the next read\n     * without flushing data, and hence possibly delay pending response(s)\n     * until the next/real request comes in or the keepalive timeout expires.\n     */\n    (void)ap_check_pipeline(c, bb, DEFAULT_LIMIT_BLANK_LINES);\n\n    ap_release_brigade(c, bb);\n\n    if (c->cs) {\n        if (c->aborted) {\n            c->cs->state = CONN_STATE_LINGER;\n        }\n        else {\n            /* If we have still data in the output filters here it means that\n             * the last (recent) nonblocking write was EAGAIN, so tell the MPM\n             * to not try another useless/stressful one but to go straight to\n             * POLLOUT.\n            */\n            c->cs->state = CONN_STATE_WRITE_COMPLETION;\n        }\n    }\n    AP_PROCESS_REQUEST_RETURN((uintptr_t)r, r->uri, r->status);\n    if (ap_extended_status) {\n        ap_time_process_request(c->sbh, STOP_PREQUEST);\n    }\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 335, column 18>"
          }
        },
        "used_macros": {
          "AP_MODE_SPECULATIVE": {
            "name": "AP_MODE_SPECULATIVE",
            "value": "3",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_input_mode_t AP_MODE_SPECULATIVE = 3",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/util_filter.h', line 53, column 5>",
            "condition": ""
          },
          "AP_CONN_CLOSE": {
            "name": "AP_CONN_CLOSE",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_conn_keepalive_e AP_CONN_CLOSE = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1145, column 5>",
            "condition": ""
          },
          "APR_NONBLOCK_READ": {
            "name": "APR_NONBLOCK_READ",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum apr_read_type_e APR_NONBLOCK_READ = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/apr_buckets.h', line 59, column 5>",
            "condition": ""
          },
          "AP_MODE_READBYTES": {
            "name": "AP_MODE_READBYTES",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_input_mode_t AP_MODE_READBYTES = 0",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/util_filter.h', line 43, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "conn_rec": {
            "name": "conn_rec",
            "definition": "struct conn_rec {\n    /** Pool associated with this connection */\n    apr_pool_t *pool;\n    /** Physical vhost this conn came in on */\n    server_rec *base_server;\n    /** used by http_vhost.c */\n    void *vhost_lookup_data;\n\n    /* Information about the connection itself */\n    /** local address */\n    apr_sockaddr_t *local_addr;\n    /** remote address; this is the end-point of the next hop, for the address\n     *  of the request creator, see useragent_addr in request_rec\n     */\n    apr_sockaddr_t *client_addr;\n\n    /** Client's IP address; this is the end-point of the next hop, for the\n     *  IP of the request creator, see useragent_ip in request_rec\n     */\n    char *client_ip;\n    /** Client's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     * get_remote_host() */\n    char *remote_host;\n    /** Only ever set if doing rfc1413 lookups.  N.B. Only access this through\n     *  get_remote_logname() */\n    char *remote_logname;\n\n    /** server IP address */\n    char *local_ip;\n    /** used for ap_get_server_name when UseCanonicalName is set to DNS\n     *  (ignores setting of HostnameLookups) */\n    char *local_host;\n\n    /** ID of this connection; unique at any point in time */\n    long id;\n    /** Config vector containing pointers to connections per-server\n     *  config structures. */\n    struct ap_conf_vector_t *conn_config;\n    /** Notes on *this* connection: send note from one module to\n     *  another. must remain valid for all requests on this conn */\n    apr_table_t *notes;\n    /** A list of input filters to be used for this connection */\n    struct ap_filter_t *input_filters;\n    /** A list of output filters to be used for this connection */\n    struct ap_filter_t *output_filters;\n    /** handle to scoreboard information for this connection */\n    void *sbh;\n    /** The bucket allocator to use for all bucket/brigade creations */\n    struct apr_bucket_alloc_t *bucket_alloc;\n    /** The current state of this connection; may be NULL if not used by MPM */\n    conn_state_t *cs;\n    /** Is there data pending in the input filters? */\n    int data_in_input_filters;\n    /** Is there data pending in the output filters? */\n    int data_in_output_filters;\n\n    /** Are there any filters that clogg/buffer the input stream, breaking\n     *  the event mpm.\n     */\n    unsigned int clogging_input_filters:1;\n\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success */\n    signed int double_reverse:2;\n\n    /** Are we still talking? */\n    unsigned aborted;\n\n    /** Are we going to keep the connection alive for another request?\n     * @see ap_conn_keepalive_e */\n    ap_conn_keepalive_e keepalive;\n\n    /** How many times have we used it? */\n    int keepalives;\n\n    /** Optional connection log level configuration. May point to a server or\n     *  per_dir config, i.e. must be copied before modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify this connection in error log. Set when the first\n     *  error log entry for this connection is generated.\n     */\n    const char *log_id;\n\n\n    /** This points to the current thread being used to process this request,\n     * over the lifetime of a request, the value may change. Users of the connection\n     * record should not rely upon it staying the same between calls that involve\n     * the MPM.\n     */\n#if APR_HAS_THREADS\n    apr_thread_t *current_thread;\n#endif\n\n    /** The \"real\" master connection. NULL if I am the master. */\n    conn_rec *master;\n\n    int outgoing;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "base_server": "server_rec *",
              "vhost_lookup_data": "void *",
              "local_addr": "apr_sockaddr_t *",
              "client_addr": "apr_sockaddr_t *",
              "client_ip": "char *",
              "remote_host": "char *",
              "remote_logname": "char *",
              "local_ip": "char *",
              "local_host": "char *",
              "id": "long",
              "conn_config": "struct ap_conf_vector_t *",
              "notes": "apr_table_t *",
              "input_filters": "struct ap_filter_t *",
              "output_filters": "struct ap_filter_t *",
              "sbh": "void *",
              "bucket_alloc": "struct apr_bucket_alloc_t *",
              "cs": "conn_state_t *",
              "data_in_input_filters": "int",
              "data_in_output_filters": "int",
              "clogging_input_filters": "unsigned int",
              "double_reverse": "int",
              "aborted": "unsigned int",
              "keepalive": "ap_conn_keepalive_e",
              "keepalives": "int",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "current_thread": "apr_thread_t *",
              "master": "conn_rec *",
              "outgoing": "int"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "ap_input_mode_t",
          "apr_off_t",
          "apr_size_t",
          "apr_status_t"
        ]
      },
      "source_code": "AP_DECLARE(apr_status_t) ap_check_pipeline(conn_rec *c, apr_bucket_brigade *bb,\n                                           unsigned int max_blank_lines)\n{\n    apr_status_t rv = APR_EOF;\n    ap_input_mode_t mode = AP_MODE_SPECULATIVE;\n    unsigned int num_blank_lines = 0;\n    apr_size_t cr = 0;\n    char buf[2];\n\n    while (c->keepalive != AP_CONN_CLOSE && !c->aborted) {\n        apr_size_t len = cr + 1;\n\n        apr_brigade_cleanup(bb);\n        rv = ap_get_brigade(c->input_filters, bb, mode,\n                            APR_NONBLOCK_READ, len);\n        if (rv != APR_SUCCESS || APR_BRIGADE_EMPTY(bb)) {\n            if (mode == AP_MODE_READBYTES) {\n                /* Unexpected error, stop with this connection */\n                ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c, APLOGNO(02967)\n                              \"Can't consume pipelined empty lines\");\n                c->keepalive = AP_CONN_CLOSE;\n                rv = APR_EGENERAL;\n            }\n            else if (rv != APR_SUCCESS && !APR_STATUS_IS_EAGAIN(rv)) {\n                /* Pipe is dead */\n                c->keepalive = AP_CONN_CLOSE;\n            }\n            else {\n                /* Pipe is up and empty */\n                rv = APR_EAGAIN;\n            }\n            break;\n        }\n        if (!max_blank_lines) {\n            apr_off_t n = 0;\n            /* Single read asked, (non-meta-)data available? */\n            rv = apr_brigade_length(bb, 0, &n);\n            if (rv == APR_SUCCESS && n <= 0) {\n                rv = APR_EAGAIN;\n            }\n            break;\n        }\n\n        /* Lookup and consume blank lines */\n        rv = apr_brigade_flatten(bb, buf, &len);\n        if (rv != APR_SUCCESS || len != cr + 1) {\n            int log_level;\n            if (mode == AP_MODE_READBYTES) {\n                /* Unexpected error, stop with this connection */\n                c->keepalive = AP_CONN_CLOSE;\n                log_level = APLOG_ERR;\n                rv = APR_EGENERAL;\n            }\n            else {\n                /* Let outside (non-speculative/blocking) read determine\n                 * where this possible failure comes from (metadata,\n                 * morphed EOF socket, ...). Debug only here.\n                 */\n                log_level = APLOG_DEBUG;\n                rv = APR_SUCCESS;\n            }\n            ap_log_cerror(APLOG_MARK, log_level, rv, c, APLOGNO(02968)\n                          \"Can't check pipelined data\");\n            break;\n        }\n\n        if (mode == AP_MODE_READBYTES) {\n            /* [CR]LF consumed, try next */\n            mode = AP_MODE_SPECULATIVE;\n            cr = 0;\n        }\n        else if (cr) {\n            AP_DEBUG_ASSERT(len == 2 && buf[0] == APR_ASCII_CR);\n            if (buf[1] == APR_ASCII_LF) {\n                /* consume this CRLF */\n                mode = AP_MODE_READBYTES;\n                num_blank_lines++;\n            }\n            else {\n                /* CR(?!LF) is data */\n                break;\n            }\n        }\n        else {\n            if (buf[0] == APR_ASCII_LF) {\n                /* consume this LF */\n                mode = AP_MODE_READBYTES;\n                num_blank_lines++;\n            }\n            else if (buf[0] == APR_ASCII_CR) {\n                cr = 1;\n            }\n            else {\n                /* Not [CR]LF, some data */\n                break;\n            }\n        }\n        if (num_blank_lines > max_blank_lines) {\n            /* Enough blank lines with this connection,\n             * stop and don't recycle it.\n             */\n            c->keepalive = AP_CONN_CLOSE;\n            rv = APR_NOTFOUND;\n            break;\n        }\n    }\n\n    return rv;\n}"
    },
    "ap_process_request_after_handler@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 335, column 18>": {
      "basic_info": {
        "function_id": 1609,
        "name": "ap_process_request_after_handler",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 335, column 18>",
        "is_definition": true,
        "start_line": 335,
        "end_line": 403,
        "return_type": "void",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_acquire_brigade": {
            "declaration": "ap_acquire_brigade(c)",
            "is_external": true,
            "definition": null
          },
          "ap_bucket_eor_create": {
            "declaration": "AP_DECLARE(apr_bucket *) ap_bucket_eor_create(apr_bucket_alloc_t *list,\n                                              request_rec *r)",
            "is_external": true,
            "definition": null
          },
          "ap_pass_brigade": {
            "declaration": "AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *filter,\n                                         apr_bucket_brigade *bucket)",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_cleanup": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_cleanup(void *data)",
            "is_external": true,
            "definition": null
          },
          "ap_check_pipeline": {
            "declaration": "AP_DECLARE(apr_status_t) ap_check_pipeline(conn_rec *c, apr_bucket_brigade *bb,\n                                           unsigned int max_blank_lines)\n{\n    apr_status_t rv = APR_EOF;\n    ap_input_mode_t mode = AP_MODE_SPECULATIVE;\n    unsigned int num_blank_lines = 0;\n    apr_size_t cr = 0;\n    char buf[2];\n\n    while (c->keepalive != AP_CONN_CLOSE && !c->aborted) {\n        apr_size_t len = cr + 1;\n\n        apr_brigade_cleanup(bb);\n        rv = ap_get_brigade(c->input_filters, bb, mode,\n                            APR_NONBLOCK_READ, len);\n        if (rv != APR_SUCCESS || APR_BRIGADE_EMPTY(bb)) {\n            if (mode == AP_MODE_READBYTES) {\n                /* Unexpected error, stop with this connection */\n                ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c, APLOGNO(02967)\n                              \"Can't consume pipelined empty lines\");\n                c->keepalive = AP_CONN_CLOSE;\n                rv = APR_EGENERAL;\n            }\n            else if (rv != APR_SUCCESS && !APR_STATUS_IS_EAGAIN(rv)) {\n                /* Pipe is dead */\n                c->keepalive = AP_CONN_CLOSE;\n            }\n            else {\n                /* Pipe is up and empty */\n                rv = APR_EAGAIN;\n            }\n            break;\n        }\n        if (!max_blank_lines) {\n            apr_off_t n = 0;\n            /* Single read asked, (non-meta-)data available? */\n            rv = apr_brigade_length(bb, 0, &n);\n            if (rv == APR_SUCCESS && n <= 0) {\n                rv = APR_EAGAIN;\n            }\n            break;\n        }\n\n        /* Lookup and consume blank lines */\n        rv = apr_brigade_flatten(bb, buf, &len);\n        if (rv != APR_SUCCESS || len != cr + 1) {\n            int log_level;\n            if (mode == AP_MODE_READBYTES) {\n                /* Unexpected error, stop with this connection */\n                c->keepalive = AP_CONN_CLOSE;\n                log_level = APLOG_ERR;\n                rv = APR_EGENERAL;\n            }\n            else {\n                /* Let outside (non-speculative/blocking) read determine\n                 * where this possible failure comes from (metadata,\n                 * morphed EOF socket, ...). Debug only here.\n                 */\n                log_level = APLOG_DEBUG;\n                rv = APR_SUCCESS;\n            }\n            ap_log_cerror(APLOG_MARK, log_level, rv, c, APLOGNO(02968)\n                          \"Can't check pipelined data\");\n            break;\n        }\n\n        if (mode == AP_MODE_READBYTES) {\n            /* [CR]LF consumed, try next */\n            mode = AP_MODE_SPECULATIVE;\n            cr = 0;\n        }\n        else if (cr) {\n            AP_DEBUG_ASSERT(len == 2 && buf[0] == APR_ASCII_CR);\n            if (buf[1] == APR_ASCII_LF) {\n                /* consume this CRLF */\n                mode = AP_MODE_READBYTES;\n                num_blank_lines++;\n            }\n            else {\n                /* CR(?!LF) is data */\n                break;\n            }\n        }\n        else {\n            if (buf[0] == APR_ASCII_LF) {\n                /* consume this LF */\n                mode = AP_MODE_READBYTES;\n                num_blank_lines++;\n            }\n            else if (buf[0] == APR_ASCII_CR) {\n                cr = 1;\n            }\n            else {\n                /* Not [CR]LF, some data */\n                break;\n            }\n        }\n        if (num_blank_lines > max_blank_lines) {\n            /* Enough blank lines with this connection,\n             * stop and don't recycle it.\n             */\n            c->keepalive = AP_CONN_CLOSE;\n            rv = APR_NOTFOUND;\n            break;\n        }\n    }\n\n    return rv;\n}",
            "is_external": false,
            "definition": "AP_DECLARE(apr_status_t) ap_check_pipeline(conn_rec *c, apr_bucket_brigade *bb,\n                                           unsigned int max_blank_lines)\n{\n    apr_status_t rv = APR_EOF;\n    ap_input_mode_t mode = AP_MODE_SPECULATIVE;\n    unsigned int num_blank_lines = 0;\n    apr_size_t cr = 0;\n    char buf[2];\n\n    while (c->keepalive != AP_CONN_CLOSE && !c->aborted) {\n        apr_size_t len = cr + 1;\n\n        apr_brigade_cleanup(bb);\n        rv = ap_get_brigade(c->input_filters, bb, mode,\n                            APR_NONBLOCK_READ, len);\n        if (rv != APR_SUCCESS || APR_BRIGADE_EMPTY(bb)) {\n            if (mode == AP_MODE_READBYTES) {\n                /* Unexpected error, stop with this connection */\n                ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c, APLOGNO(02967)\n                              \"Can't consume pipelined empty lines\");\n                c->keepalive = AP_CONN_CLOSE;\n                rv = APR_EGENERAL;\n            }\n            else if (rv != APR_SUCCESS && !APR_STATUS_IS_EAGAIN(rv)) {\n                /* Pipe is dead */\n                c->keepalive = AP_CONN_CLOSE;\n            }\n            else {\n                /* Pipe is up and empty */\n                rv = APR_EAGAIN;\n            }\n            break;\n        }\n        if (!max_blank_lines) {\n            apr_off_t n = 0;\n            /* Single read asked, (non-meta-)data available? */\n            rv = apr_brigade_length(bb, 0, &n);\n            if (rv == APR_SUCCESS && n <= 0) {\n                rv = APR_EAGAIN;\n            }\n            break;\n        }\n\n        /* Lookup and consume blank lines */\n        rv = apr_brigade_flatten(bb, buf, &len);\n        if (rv != APR_SUCCESS || len != cr + 1) {\n            int log_level;\n            if (mode == AP_MODE_READBYTES) {\n                /* Unexpected error, stop with this connection */\n                c->keepalive = AP_CONN_CLOSE;\n                log_level = APLOG_ERR;\n                rv = APR_EGENERAL;\n            }\n            else {\n                /* Let outside (non-speculative/blocking) read determine\n                 * where this possible failure comes from (metadata,\n                 * morphed EOF socket, ...). Debug only here.\n                 */\n                log_level = APLOG_DEBUG;\n                rv = APR_SUCCESS;\n            }\n            ap_log_cerror(APLOG_MARK, log_level, rv, c, APLOGNO(02968)\n                          \"Can't check pipelined data\");\n            break;\n        }\n\n        if (mode == AP_MODE_READBYTES) {\n            /* [CR]LF consumed, try next */\n            mode = AP_MODE_SPECULATIVE;\n            cr = 0;\n        }\n        else if (cr) {\n            AP_DEBUG_ASSERT(len == 2 && buf[0] == APR_ASCII_CR);\n            if (buf[1] == APR_ASCII_LF) {\n                /* consume this CRLF */\n                mode = AP_MODE_READBYTES;\n                num_blank_lines++;\n            }\n            else {\n                /* CR(?!LF) is data */\n                break;\n            }\n        }\n        else {\n            if (buf[0] == APR_ASCII_LF) {\n                /* consume this LF */\n                mode = AP_MODE_READBYTES;\n                num_blank_lines++;\n            }\n            else if (buf[0] == APR_ASCII_CR) {\n                cr = 1;\n            }\n            else {\n                /* Not [CR]LF, some data */\n                break;\n            }\n        }\n        if (num_blank_lines > max_blank_lines) {\n            /* Enough blank lines with this connection,\n             * stop and don't recycle it.\n             */\n            c->keepalive = AP_CONN_CLOSE;\n            rv = APR_NOTFOUND;\n            break;\n        }\n    }\n\n    return rv;\n}"
          },
          "ap_release_brigade": {
            "declaration": "ap_release_brigade(c, bb)",
            "is_external": true,
            "definition": null
          },
          "ap_time_process_request": {
            "declaration": "AP_DECLARE(void) ap_time_process_request(ap_sb_handle_t *sbh, int status)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_process_async_request@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 405, column 6>": {
            "source_code": "void ap_process_async_request(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    int access_status;\n\n    /* Give quick handlers a shot at serving the request on the fast\n     * path, bypassing all of the other Apache hooks.\n     *\n     * This hook was added to enable serving files out of a URI keyed\n     * content cache ( e.g., Mike Abbott's Quick Shortcut Cache,\n     * described here: http://oss.sgi.com/projects/apache/mod_qsc.html )\n     *\n     * It may have other uses as well, such as routing requests directly to\n     * content handlers that have the ability to grok HTTP and do their\n     * own access checking, etc (e.g. servlet engines).\n     *\n     * Use this hook with extreme care and only if you know what you are\n     * doing.\n     */\n    AP_PROCESS_REQUEST_ENTRY((uintptr_t)r, r->uri);\n    if (ap_extended_status) {\n        ap_time_process_request(r->connection->sbh, START_PREQUEST);\n    }\n\n    if (APLOGrtrace4(r)) {\n        int i;\n        const apr_array_header_t *t_h = apr_table_elts(r->headers_in);\n        const apr_table_entry_t *t_elt = (apr_table_entry_t *)t_h->elts;\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                      \"Headers received from client:\");\n        for (i = 0; i < t_h->nelts; i++, t_elt++) {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r, \"  %s: %s\",\n                          ap_escape_logitem(r->pool, t_elt->key),\n                          ap_escape_logitem(r->pool, t_elt->val));\n        }\n    }\n\n#if APR_HAS_THREADS\n    apr_thread_mutex_create(&r->invoke_mtx, APR_THREAD_MUTEX_DEFAULT, r->pool);\n    apr_thread_mutex_lock(r->invoke_mtx);\n#endif\n    access_status = ap_run_quick_handler(r, 0);  /* Not a look-up request */\n    if (access_status == DECLINED) {\n        access_status = ap_process_request_internal(r);\n        if (access_status == OK) {\n            access_status = ap_invoke_handler(r);\n        }\n    }\n\n    if (access_status == SUSPENDED) {\n        /* TODO: Should move these steps into a generic function, so modules\n         * working on a suspended request can also call _ENTRY again.\n         */\n        AP_PROCESS_REQUEST_RETURN((uintptr_t)r, r->uri, access_status);\n        if (ap_extended_status) {\n            ap_time_process_request(c->sbh, STOP_PREQUEST);\n        }\n        if (c->cs)\n            c->cs->state = CONN_STATE_SUSPENDED;\n#if APR_HAS_THREADS\n        apr_thread_mutex_unlock(r->invoke_mtx);\n#endif\n        return;\n    }\n#if APR_HAS_THREADS\n    apr_thread_mutex_unlock(r->invoke_mtx);\n#endif\n\n    ap_die_r(access_status, r, HTTP_OK);\n\n    ap_process_request_after_handler(r);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 405, column 6>"
          }
        },
        "used_macros": {
          "CONN_STATE_LINGER": {
            "name": "CONN_STATE_LINGER",
            "value": "5",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum conn_state_e CONN_STATE_LINGER = 5",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1264, column 5>",
            "condition": ""
          },
          "CONN_STATE_WRITE_COMPLETION": {
            "name": "CONN_STATE_WRITE_COMPLETION",
            "value": "3",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum conn_state_e CONN_STATE_WRITE_COMPLETION = 3",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1262, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "conn_rec": {
            "name": "conn_rec",
            "definition": "struct conn_rec {\n    /** Pool associated with this connection */\n    apr_pool_t *pool;\n    /** Physical vhost this conn came in on */\n    server_rec *base_server;\n    /** used by http_vhost.c */\n    void *vhost_lookup_data;\n\n    /* Information about the connection itself */\n    /** local address */\n    apr_sockaddr_t *local_addr;\n    /** remote address; this is the end-point of the next hop, for the address\n     *  of the request creator, see useragent_addr in request_rec\n     */\n    apr_sockaddr_t *client_addr;\n\n    /** Client's IP address; this is the end-point of the next hop, for the\n     *  IP of the request creator, see useragent_ip in request_rec\n     */\n    char *client_ip;\n    /** Client's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     * get_remote_host() */\n    char *remote_host;\n    /** Only ever set if doing rfc1413 lookups.  N.B. Only access this through\n     *  get_remote_logname() */\n    char *remote_logname;\n\n    /** server IP address */\n    char *local_ip;\n    /** used for ap_get_server_name when UseCanonicalName is set to DNS\n     *  (ignores setting of HostnameLookups) */\n    char *local_host;\n\n    /** ID of this connection; unique at any point in time */\n    long id;\n    /** Config vector containing pointers to connections per-server\n     *  config structures. */\n    struct ap_conf_vector_t *conn_config;\n    /** Notes on *this* connection: send note from one module to\n     *  another. must remain valid for all requests on this conn */\n    apr_table_t *notes;\n    /** A list of input filters to be used for this connection */\n    struct ap_filter_t *input_filters;\n    /** A list of output filters to be used for this connection */\n    struct ap_filter_t *output_filters;\n    /** handle to scoreboard information for this connection */\n    void *sbh;\n    /** The bucket allocator to use for all bucket/brigade creations */\n    struct apr_bucket_alloc_t *bucket_alloc;\n    /** The current state of this connection; may be NULL if not used by MPM */\n    conn_state_t *cs;\n    /** Is there data pending in the input filters? */\n    int data_in_input_filters;\n    /** Is there data pending in the output filters? */\n    int data_in_output_filters;\n\n    /** Are there any filters that clogg/buffer the input stream, breaking\n     *  the event mpm.\n     */\n    unsigned int clogging_input_filters:1;\n\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success */\n    signed int double_reverse:2;\n\n    /** Are we still talking? */\n    unsigned aborted;\n\n    /** Are we going to keep the connection alive for another request?\n     * @see ap_conn_keepalive_e */\n    ap_conn_keepalive_e keepalive;\n\n    /** How many times have we used it? */\n    int keepalives;\n\n    /** Optional connection log level configuration. May point to a server or\n     *  per_dir config, i.e. must be copied before modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify this connection in error log. Set when the first\n     *  error log entry for this connection is generated.\n     */\n    const char *log_id;\n\n\n    /** This points to the current thread being used to process this request,\n     * over the lifetime of a request, the value may change. Users of the connection\n     * record should not rely upon it staying the same between calls that involve\n     * the MPM.\n     */\n#if APR_HAS_THREADS\n    apr_thread_t *current_thread;\n#endif\n\n    /** The \"real\" master connection. NULL if I am the master. */\n    conn_rec *master;\n\n    int outgoing;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "base_server": "server_rec *",
              "vhost_lookup_data": "void *",
              "local_addr": "apr_sockaddr_t *",
              "client_addr": "apr_sockaddr_t *",
              "client_ip": "char *",
              "remote_host": "char *",
              "remote_logname": "char *",
              "local_ip": "char *",
              "local_host": "char *",
              "id": "long",
              "conn_config": "struct ap_conf_vector_t *",
              "notes": "apr_table_t *",
              "input_filters": "struct ap_filter_t *",
              "output_filters": "struct ap_filter_t *",
              "sbh": "void *",
              "bucket_alloc": "struct apr_bucket_alloc_t *",
              "cs": "conn_state_t *",
              "data_in_input_filters": "int",
              "data_in_output_filters": "int",
              "clogging_input_filters": "unsigned int",
              "double_reverse": "int",
              "aborted": "unsigned int",
              "keepalive": "ap_conn_keepalive_e",
              "keepalives": "int",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "current_thread": "apr_thread_t *",
              "master": "conn_rec *",
              "outgoing": "int"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "ap_extended_status": {
            "name": "ap_extended_status",
            "type": "int",
            "is_extern": true,
            "is_static": false,
            "definition": "extern int ap_extended_status",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(void) ap_process_request_after_handler(request_rec *r)\n{\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n    conn_rec *c = r->connection;\n\n    bb = ap_acquire_brigade(c);\n\n    /* Send an EOR bucket through the output filter chain.  When\n     * this bucket is destroyed, the request will be logged and\n     * its pool will be freed\n     */\n    b = ap_bucket_eor_create(c->bucket_alloc, r);\n    APR_BRIGADE_INSERT_HEAD(bb, b);\n\n    /* Find the last request, taking into account internal\n     * redirects. We want to send the EOR bucket at the end of\n     * all the buckets so it does not jump the queue.\n     */\n    while (r->next) {\n        r = r->next;\n    }\n\n    /* All the request filters should have bailed out on EOS, and in any\n     * case they shouldn't have to handle this EOR which will destroy the\n     * request underneath them. So go straight to the connection filters.\n     */\n    ap_pass_brigade(c->output_filters, bb);\n\n    /* The EOR bucket has either been handled by an output filter (eg.\n     * deleted or moved to a buffered_bb => no more in bb), or an error\n     * occurred before that (eg. c->aborted => still in bb) and we ought\n     * to destroy it now. So cleanup any remaining bucket along with\n     * the orphan request (if any).\n     */\n    apr_brigade_cleanup(bb);\n\n    /* From here onward, it is no longer safe to reference r\n     * or r->pool, because r->pool may have been destroyed\n     * already by the EOR bucket's cleanup function.\n     */\n\n    /* Check pipeline consuming blank lines, they must not be interpreted as\n     * the next pipelined request, otherwise we would block on the next read\n     * without flushing data, and hence possibly delay pending response(s)\n     * until the next/real request comes in or the keepalive timeout expires.\n     */\n    (void)ap_check_pipeline(c, bb, DEFAULT_LIMIT_BLANK_LINES);\n\n    ap_release_brigade(c, bb);\n\n    if (c->cs) {\n        if (c->aborted) {\n            c->cs->state = CONN_STATE_LINGER;\n        }\n        else {\n            /* If we have still data in the output filters here it means that\n             * the last (recent) nonblocking write was EAGAIN, so tell the MPM\n             * to not try another useless/stressful one but to go straight to\n             * POLLOUT.\n            */\n            c->cs->state = CONN_STATE_WRITE_COMPLETION;\n        }\n    }\n    AP_PROCESS_REQUEST_RETURN((uintptr_t)r, r->uri, r->status);\n    if (ap_extended_status) {\n        ap_time_process_request(c->sbh, STOP_PREQUEST);\n    }\n}"
    },
    "ap_process_async_request@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 405, column 6>": {
      "basic_info": {
        "function_id": 1610,
        "name": "ap_process_async_request",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 405, column 6>",
        "is_definition": true,
        "start_line": 405,
        "end_line": 476,
        "return_type": "void",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_time_process_request": {
            "declaration": "AP_DECLARE(void) ap_time_process_request(ap_sb_handle_t *sbh, int status)",
            "is_external": true,
            "definition": null
          },
          "apr_table_elts": {
            "declaration": "APR_DECLARE(const apr_array_header_t *) apr_table_elts(const apr_table_t *t)",
            "is_external": true,
            "definition": null
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "ap_escape_logitem": {
            "declaration": "AP_DECLARE(char *) ap_escape_logitem(apr_pool_t *p, const char *str)",
            "is_external": true,
            "definition": null
          },
          "apr_thread_mutex_create": {
            "declaration": "APR_DECLARE(apr_status_t) apr_thread_mutex_create(apr_thread_mutex_t **mutex,\n                                                  unsigned int flags,\n                                                  apr_pool_t *pool)",
            "is_external": true,
            "definition": null
          },
          "apr_thread_mutex_lock": {
            "declaration": "APR_DECLARE(apr_status_t) apr_thread_mutex_lock(apr_thread_mutex_t *mutex)",
            "is_external": true,
            "definition": null
          },
          "ap_run_quick_handler": {
            "declaration": "AP_DECLARE_HOOK(int,quick_handler,(request_rec *r, int lookup_uri))",
            "is_external": true,
            "definition": null
          },
          "ap_process_request_internal": {
            "declaration": "AP_DECLARE(int) ap_process_request_internal(request_rec *r)",
            "is_external": true,
            "definition": null
          },
          "ap_invoke_handler": {
            "declaration": "AP_CORE_DECLARE(int) ap_invoke_handler(request_rec *r)",
            "is_external": true,
            "definition": null
          },
          "apr_thread_mutex_unlock": {
            "declaration": "APR_DECLARE(apr_status_t) apr_thread_mutex_unlock(apr_thread_mutex_t *mutex)",
            "is_external": true,
            "definition": null
          },
          "ap_die_r": {
            "declaration": "static void ap_die_r(int type, request_rec *r, int recursive_error)\n{\n    char *custom_response;\n    request_rec *r_1st_err = r;\n\n    if (type == OK || type == DONE) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    /*\n     * if we have already passed the final response down the\n     * output filter chain, we cannot generate a second final\n     * response here.\n     */\n    if (r->final_resp_passed) {\n        return;\n    }\n\n    if (!ap_is_HTTP_VALID_RESPONSE(type)) {\n        if (type != AP_FILTER_ERROR) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01579)\n                          \"Invalid response status %i\", type);\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02831)\n                          \"Response from AP_FILTER_ERROR\");\n        }\n        type = HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /*\n     * The following takes care of Apache redirects to custom response URLs\n     * Note that if we are already dealing with the response to some other\n     * error condition, we just report on the original error, and give up on\n     * any attempt to handle the other thing \"intelligently\"...\n     */\n    if (recursive_error != HTTP_OK) {\n        while (r_1st_err->prev && (r_1st_err->prev->status != HTTP_OK))\n            r_1st_err = r_1st_err->prev;  /* Get back to original error */\n\n        if (r_1st_err != r) {\n            /* The recursive error was caused by an ErrorDocument specifying\n             * an internal redirect to a bad URI.  ap_internal_redirect has\n             * changed the filter chains to point to the ErrorDocument's\n             * request_rec.  Back out those changes so we can safely use the\n             * original failing request_rec to send the canned error message.\n             *\n             * ap_send_error_response gets rid of existing resource filters\n             * on the output side, so we can skip those.\n             */\n            update_r_in_filters(r_1st_err->proto_output_filters, r, r_1st_err);\n            update_r_in_filters(r_1st_err->input_filters, r, r_1st_err);\n        }\n\n        custom_response = NULL; /* Do NOT retry the custom thing! */\n    }\n    else {\n        int error_index = ap_index_of_response(type);\n        custom_response = ap_response_code_string(r, error_index);\n        recursive_error = 0;\n    }\n\n    r->status = type;\n\n    /*\n     * This test is done here so that none of the auth modules needs to know\n     * about proxy authentication.  They treat it like normal auth, and then\n     * we tweak the status.\n     */\n    if (HTTP_UNAUTHORIZED == r->status && PROXYREQ_PROXY == r->proxyreq) {\n        r->status = HTTP_PROXY_AUTHENTICATION_REQUIRED;\n    }\n\n    /* If we don't want to keep the connection, make sure we mark that the\n     * connection is not eligible for keepalive.  If we want to keep the\n     * connection, be sure that the request body (if any) has been read.\n     */\n    if (ap_status_drops_connection(r->status)) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n    }\n\n    /*\n     * Two types of custom redirects --- plain text, and URLs. Plain text has\n     * a leading '\"', so the URL code, here, is triggered on its absence\n     */\n\n    if (custom_response && custom_response[0] != '\"') {\n\n        if (ap_is_url(custom_response)) {\n            /*\n             * The URL isn't local, so lets drop through the rest of this\n             * apache code, and continue with the usual REDIRECT handler.\n             * But note that the client will ultimately see the wrong\n             * status...\n             */\n            r->status = HTTP_MOVED_TEMPORARILY;\n            apr_table_setn(r->headers_out, \"Location\", custom_response);\n        }\n        else if (custom_response[0] == '/') {\n            const char *error_notes, *original_method;\n            int original_method_number;\n            r->no_local_copy = 1;       /* Do NOT send HTTP_NOT_MODIFIED for\n                                         * error documents! */\n            /*\n             * This redirect needs to be a GET no matter what the original\n             * method was.\n             */\n            apr_table_setn(r->subprocess_env, \"REQUEST_METHOD\", r->method);\n\n            /*\n             * Provide a special method for modules to communicate\n             * more informative (than the plain canned) messages to us.\n             * Propagate them to ErrorDocuments via the ERROR_NOTES variable:\n             */\n            if ((error_notes = apr_table_get(r->notes,\n                                             \"error-notes\")) != NULL) {\n                apr_table_setn(r->subprocess_env, \"ERROR_NOTES\", error_notes);\n            }\n            original_method = r->method;\n            original_method_number = r->method_number;\n            r->method = \"GET\";\n            r->method_number = M_GET;\n            ap_internal_redirect(custom_response, r);\n            /* preserve ability to see %<m in the access log */\n            r->method = original_method;\n            r->method_number = original_method_number;\n            return;\n        }\n        else {\n            /*\n             * Dumb user has given us a bad url to redirect to --- fake up\n             * dying with a recursive server error...\n             */\n            recursive_error = HTTP_INTERNAL_SERVER_ERROR;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01580)\n                        \"Invalid error redirection directive: %s\",\n                        custom_response);\n        }\n    }\n    ap_send_error_response(r_1st_err, recursive_error);\n}",
            "is_external": false,
            "definition": "static void ap_die_r(int type, request_rec *r, int recursive_error)\n{\n    char *custom_response;\n    request_rec *r_1st_err = r;\n\n    if (type == OK || type == DONE) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    /*\n     * if we have already passed the final response down the\n     * output filter chain, we cannot generate a second final\n     * response here.\n     */\n    if (r->final_resp_passed) {\n        return;\n    }\n\n    if (!ap_is_HTTP_VALID_RESPONSE(type)) {\n        if (type != AP_FILTER_ERROR) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01579)\n                          \"Invalid response status %i\", type);\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02831)\n                          \"Response from AP_FILTER_ERROR\");\n        }\n        type = HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /*\n     * The following takes care of Apache redirects to custom response URLs\n     * Note that if we are already dealing with the response to some other\n     * error condition, we just report on the original error, and give up on\n     * any attempt to handle the other thing \"intelligently\"...\n     */\n    if (recursive_error != HTTP_OK) {\n        while (r_1st_err->prev && (r_1st_err->prev->status != HTTP_OK))\n            r_1st_err = r_1st_err->prev;  /* Get back to original error */\n\n        if (r_1st_err != r) {\n            /* The recursive error was caused by an ErrorDocument specifying\n             * an internal redirect to a bad URI.  ap_internal_redirect has\n             * changed the filter chains to point to the ErrorDocument's\n             * request_rec.  Back out those changes so we can safely use the\n             * original failing request_rec to send the canned error message.\n             *\n             * ap_send_error_response gets rid of existing resource filters\n             * on the output side, so we can skip those.\n             */\n            update_r_in_filters(r_1st_err->proto_output_filters, r, r_1st_err);\n            update_r_in_filters(r_1st_err->input_filters, r, r_1st_err);\n        }\n\n        custom_response = NULL; /* Do NOT retry the custom thing! */\n    }\n    else {\n        int error_index = ap_index_of_response(type);\n        custom_response = ap_response_code_string(r, error_index);\n        recursive_error = 0;\n    }\n\n    r->status = type;\n\n    /*\n     * This test is done here so that none of the auth modules needs to know\n     * about proxy authentication.  They treat it like normal auth, and then\n     * we tweak the status.\n     */\n    if (HTTP_UNAUTHORIZED == r->status && PROXYREQ_PROXY == r->proxyreq) {\n        r->status = HTTP_PROXY_AUTHENTICATION_REQUIRED;\n    }\n\n    /* If we don't want to keep the connection, make sure we mark that the\n     * connection is not eligible for keepalive.  If we want to keep the\n     * connection, be sure that the request body (if any) has been read.\n     */\n    if (ap_status_drops_connection(r->status)) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n    }\n\n    /*\n     * Two types of custom redirects --- plain text, and URLs. Plain text has\n     * a leading '\"', so the URL code, here, is triggered on its absence\n     */\n\n    if (custom_response && custom_response[0] != '\"') {\n\n        if (ap_is_url(custom_response)) {\n            /*\n             * The URL isn't local, so lets drop through the rest of this\n             * apache code, and continue with the usual REDIRECT handler.\n             * But note that the client will ultimately see the wrong\n             * status...\n             */\n            r->status = HTTP_MOVED_TEMPORARILY;\n            apr_table_setn(r->headers_out, \"Location\", custom_response);\n        }\n        else if (custom_response[0] == '/') {\n            const char *error_notes, *original_method;\n            int original_method_number;\n            r->no_local_copy = 1;       /* Do NOT send HTTP_NOT_MODIFIED for\n                                         * error documents! */\n            /*\n             * This redirect needs to be a GET no matter what the original\n             * method was.\n             */\n            apr_table_setn(r->subprocess_env, \"REQUEST_METHOD\", r->method);\n\n            /*\n             * Provide a special method for modules to communicate\n             * more informative (than the plain canned) messages to us.\n             * Propagate them to ErrorDocuments via the ERROR_NOTES variable:\n             */\n            if ((error_notes = apr_table_get(r->notes,\n                                             \"error-notes\")) != NULL) {\n                apr_table_setn(r->subprocess_env, \"ERROR_NOTES\", error_notes);\n            }\n            original_method = r->method;\n            original_method_number = r->method_number;\n            r->method = \"GET\";\n            r->method_number = M_GET;\n            ap_internal_redirect(custom_response, r);\n            /* preserve ability to see %<m in the access log */\n            r->method = original_method;\n            r->method_number = original_method_number;\n            return;\n        }\n        else {\n            /*\n             * Dumb user has given us a bad url to redirect to --- fake up\n             * dying with a recursive server error...\n             */\n            recursive_error = HTTP_INTERNAL_SERVER_ERROR;\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01580)\n                        \"Invalid error redirection directive: %s\",\n                        custom_response);\n        }\n    }\n    ap_send_error_response(r_1st_err, recursive_error);\n}"
          },
          "ap_process_request_after_handler": {
            "declaration": "AP_DECLARE(void) ap_process_request_after_handler(request_rec *r)\n{\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n    conn_rec *c = r->connection;\n\n    bb = ap_acquire_brigade(c);\n\n    /* Send an EOR bucket through the output filter chain.  When\n     * this bucket is destroyed, the request will be logged and\n     * its pool will be freed\n     */\n    b = ap_bucket_eor_create(c->bucket_alloc, r);\n    APR_BRIGADE_INSERT_HEAD(bb, b);\n\n    /* Find the last request, taking into account internal\n     * redirects. We want to send the EOR bucket at the end of\n     * all the buckets so it does not jump the queue.\n     */\n    while (r->next) {\n        r = r->next;\n    }\n\n    /* All the request filters should have bailed out on EOS, and in any\n     * case they shouldn't have to handle this EOR which will destroy the\n     * request underneath them. So go straight to the connection filters.\n     */\n    ap_pass_brigade(c->output_filters, bb);\n\n    /* The EOR bucket has either been handled by an output filter (eg.\n     * deleted or moved to a buffered_bb => no more in bb), or an error\n     * occurred before that (eg. c->aborted => still in bb) and we ought\n     * to destroy it now. So cleanup any remaining bucket along with\n     * the orphan request (if any).\n     */\n    apr_brigade_cleanup(bb);\n\n    /* From here onward, it is no longer safe to reference r\n     * or r->pool, because r->pool may have been destroyed\n     * already by the EOR bucket's cleanup function.\n     */\n\n    /* Check pipeline consuming blank lines, they must not be interpreted as\n     * the next pipelined request, otherwise we would block on the next read\n     * without flushing data, and hence possibly delay pending response(s)\n     * until the next/real request comes in or the keepalive timeout expires.\n     */\n    (void)ap_check_pipeline(c, bb, DEFAULT_LIMIT_BLANK_LINES);\n\n    ap_release_brigade(c, bb);\n\n    if (c->cs) {\n        if (c->aborted) {\n            c->cs->state = CONN_STATE_LINGER;\n        }\n        else {\n            /* If we have still data in the output filters here it means that\n             * the last (recent) nonblocking write was EAGAIN, so tell the MPM\n             * to not try another useless/stressful one but to go straight to\n             * POLLOUT.\n            */\n            c->cs->state = CONN_STATE_WRITE_COMPLETION;\n        }\n    }\n    AP_PROCESS_REQUEST_RETURN((uintptr_t)r, r->uri, r->status);\n    if (ap_extended_status) {\n        ap_time_process_request(c->sbh, STOP_PREQUEST);\n    }\n}",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_process_request_after_handler(request_rec *r)\n{\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n    conn_rec *c = r->connection;\n\n    bb = ap_acquire_brigade(c);\n\n    /* Send an EOR bucket through the output filter chain.  When\n     * this bucket is destroyed, the request will be logged and\n     * its pool will be freed\n     */\n    b = ap_bucket_eor_create(c->bucket_alloc, r);\n    APR_BRIGADE_INSERT_HEAD(bb, b);\n\n    /* Find the last request, taking into account internal\n     * redirects. We want to send the EOR bucket at the end of\n     * all the buckets so it does not jump the queue.\n     */\n    while (r->next) {\n        r = r->next;\n    }\n\n    /* All the request filters should have bailed out on EOS, and in any\n     * case they shouldn't have to handle this EOR which will destroy the\n     * request underneath them. So go straight to the connection filters.\n     */\n    ap_pass_brigade(c->output_filters, bb);\n\n    /* The EOR bucket has either been handled by an output filter (eg.\n     * deleted or moved to a buffered_bb => no more in bb), or an error\n     * occurred before that (eg. c->aborted => still in bb) and we ought\n     * to destroy it now. So cleanup any remaining bucket along with\n     * the orphan request (if any).\n     */\n    apr_brigade_cleanup(bb);\n\n    /* From here onward, it is no longer safe to reference r\n     * or r->pool, because r->pool may have been destroyed\n     * already by the EOR bucket's cleanup function.\n     */\n\n    /* Check pipeline consuming blank lines, they must not be interpreted as\n     * the next pipelined request, otherwise we would block on the next read\n     * without flushing data, and hence possibly delay pending response(s)\n     * until the next/real request comes in or the keepalive timeout expires.\n     */\n    (void)ap_check_pipeline(c, bb, DEFAULT_LIMIT_BLANK_LINES);\n\n    ap_release_brigade(c, bb);\n\n    if (c->cs) {\n        if (c->aborted) {\n            c->cs->state = CONN_STATE_LINGER;\n        }\n        else {\n            /* If we have still data in the output filters here it means that\n             * the last (recent) nonblocking write was EAGAIN, so tell the MPM\n             * to not try another useless/stressful one but to go straight to\n             * POLLOUT.\n            */\n            c->cs->state = CONN_STATE_WRITE_COMPLETION;\n        }\n    }\n    AP_PROCESS_REQUEST_RETURN((uintptr_t)r, r->uri, r->status);\n    if (ap_extended_status) {\n        ap_time_process_request(c->sbh, STOP_PREQUEST);\n    }\n}"
          }
        },
        "callers": {
          "ap_process_request@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 478, column 18>": {
            "source_code": "AP_DECLARE(void) ap_process_request(request_rec *r)\n{\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n    conn_rec *c = r->connection;\n    apr_status_t rv;\n\n    ap_process_async_request(r);\n\n    if (ap_run_input_pending(c) != OK) {\n        bb = ap_acquire_brigade(c);\n        b = apr_bucket_flush_create(c->bucket_alloc);\n        APR_BRIGADE_INSERT_HEAD(bb, b);\n        rv = ap_pass_brigade(c->output_filters, bb);\n        if (APR_STATUS_IS_TIMEUP(rv)) {\n            /*\n             * Notice a timeout as an error message. This might be\n             * valuable for detecting clients with broken network\n             * connections or possible DoS attacks.\n             */\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, rv, c, APLOGNO(01581)\n                          \"flushing data to the client\");\n        }\n        ap_release_brigade(c, bb);\n    }\n    if (ap_extended_status) {\n        ap_time_process_request(c->sbh, STOP_PREQUEST);\n    }\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 478, column 18>"
          }
        },
        "used_macros": {
          "CONN_STATE_SUSPENDED": {
            "name": "CONN_STATE_SUSPENDED",
            "value": "4",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum conn_state_e CONN_STATE_SUSPENDED = 4",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1263, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "conn_rec": {
            "name": "conn_rec",
            "definition": "struct conn_rec {\n    /** Pool associated with this connection */\n    apr_pool_t *pool;\n    /** Physical vhost this conn came in on */\n    server_rec *base_server;\n    /** used by http_vhost.c */\n    void *vhost_lookup_data;\n\n    /* Information about the connection itself */\n    /** local address */\n    apr_sockaddr_t *local_addr;\n    /** remote address; this is the end-point of the next hop, for the address\n     *  of the request creator, see useragent_addr in request_rec\n     */\n    apr_sockaddr_t *client_addr;\n\n    /** Client's IP address; this is the end-point of the next hop, for the\n     *  IP of the request creator, see useragent_ip in request_rec\n     */\n    char *client_ip;\n    /** Client's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     * get_remote_host() */\n    char *remote_host;\n    /** Only ever set if doing rfc1413 lookups.  N.B. Only access this through\n     *  get_remote_logname() */\n    char *remote_logname;\n\n    /** server IP address */\n    char *local_ip;\n    /** used for ap_get_server_name when UseCanonicalName is set to DNS\n     *  (ignores setting of HostnameLookups) */\n    char *local_host;\n\n    /** ID of this connection; unique at any point in time */\n    long id;\n    /** Config vector containing pointers to connections per-server\n     *  config structures. */\n    struct ap_conf_vector_t *conn_config;\n    /** Notes on *this* connection: send note from one module to\n     *  another. must remain valid for all requests on this conn */\n    apr_table_t *notes;\n    /** A list of input filters to be used for this connection */\n    struct ap_filter_t *input_filters;\n    /** A list of output filters to be used for this connection */\n    struct ap_filter_t *output_filters;\n    /** handle to scoreboard information for this connection */\n    void *sbh;\n    /** The bucket allocator to use for all bucket/brigade creations */\n    struct apr_bucket_alloc_t *bucket_alloc;\n    /** The current state of this connection; may be NULL if not used by MPM */\n    conn_state_t *cs;\n    /** Is there data pending in the input filters? */\n    int data_in_input_filters;\n    /** Is there data pending in the output filters? */\n    int data_in_output_filters;\n\n    /** Are there any filters that clogg/buffer the input stream, breaking\n     *  the event mpm.\n     */\n    unsigned int clogging_input_filters:1;\n\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success */\n    signed int double_reverse:2;\n\n    /** Are we still talking? */\n    unsigned aborted;\n\n    /** Are we going to keep the connection alive for another request?\n     * @see ap_conn_keepalive_e */\n    ap_conn_keepalive_e keepalive;\n\n    /** How many times have we used it? */\n    int keepalives;\n\n    /** Optional connection log level configuration. May point to a server or\n     *  per_dir config, i.e. must be copied before modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify this connection in error log. Set when the first\n     *  error log entry for this connection is generated.\n     */\n    const char *log_id;\n\n\n    /** This points to the current thread being used to process this request,\n     * over the lifetime of a request, the value may change. Users of the connection\n     * record should not rely upon it staying the same between calls that involve\n     * the MPM.\n     */\n#if APR_HAS_THREADS\n    apr_thread_t *current_thread;\n#endif\n\n    /** The \"real\" master connection. NULL if I am the master. */\n    conn_rec *master;\n\n    int outgoing;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "base_server": "server_rec *",
              "vhost_lookup_data": "void *",
              "local_addr": "apr_sockaddr_t *",
              "client_addr": "apr_sockaddr_t *",
              "client_ip": "char *",
              "remote_host": "char *",
              "remote_logname": "char *",
              "local_ip": "char *",
              "local_host": "char *",
              "id": "long",
              "conn_config": "struct ap_conf_vector_t *",
              "notes": "apr_table_t *",
              "input_filters": "struct ap_filter_t *",
              "output_filters": "struct ap_filter_t *",
              "sbh": "void *",
              "bucket_alloc": "struct apr_bucket_alloc_t *",
              "cs": "conn_state_t *",
              "data_in_input_filters": "int",
              "data_in_output_filters": "int",
              "clogging_input_filters": "unsigned int",
              "double_reverse": "int",
              "aborted": "unsigned int",
              "keepalive": "ap_conn_keepalive_e",
              "keepalives": "int",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "current_thread": "apr_thread_t *",
              "master": "conn_rec *",
              "outgoing": "int"
            },
            "condition": ""
          },
          "apr_array_header_t": {
            "name": "apr_array_header_t",
            "definition": "struct apr_array_header_t {\n    /** The pool the array is allocated out of */\n    apr_pool_t *pool;\n    /** The amount of memory allocated for each element of the array */\n    int elt_size;\n    /** The number of active elements in the array */\n    int nelts;\n    /** The number of elements allocated in the array */\n    int nalloc;\n    /** The elements in the array */\n    char *elts;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "elt_size": "int",
              "nelts": "int",
              "nalloc": "int",
              "elts": "char *"
            },
            "condition": ""
          },
          "apr_table_entry_t": {
            "name": "apr_table_entry_t",
            "definition": "struct apr_table_entry_t {\n    /** The key for the current table entry */\n    char *key;          /* maybe NULL in future;\n                         * check when iterating thru table_elts\n                         */\n    /** The value for the current table entry */\n    char *val;\n\n    /** A checksum for the key, for use by the apr_table internals */\n    apr_uint32_t key_checksum;\n}",
            "typedef_name": null,
            "fields": {
              "key": "char *",
              "val": "char *",
              "key_checksum": "apr_uint32_t"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "ap_extended_status": {
            "name": "ap_extended_status",
            "type": "int",
            "is_extern": true,
            "is_static": false,
            "definition": "extern int ap_extended_status",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "void ap_process_async_request(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    int access_status;\n\n    /* Give quick handlers a shot at serving the request on the fast\n     * path, bypassing all of the other Apache hooks.\n     *\n     * This hook was added to enable serving files out of a URI keyed\n     * content cache ( e.g., Mike Abbott's Quick Shortcut Cache,\n     * described here: http://oss.sgi.com/projects/apache/mod_qsc.html )\n     *\n     * It may have other uses as well, such as routing requests directly to\n     * content handlers that have the ability to grok HTTP and do their\n     * own access checking, etc (e.g. servlet engines).\n     *\n     * Use this hook with extreme care and only if you know what you are\n     * doing.\n     */\n    AP_PROCESS_REQUEST_ENTRY((uintptr_t)r, r->uri);\n    if (ap_extended_status) {\n        ap_time_process_request(r->connection->sbh, START_PREQUEST);\n    }\n\n    if (APLOGrtrace4(r)) {\n        int i;\n        const apr_array_header_t *t_h = apr_table_elts(r->headers_in);\n        const apr_table_entry_t *t_elt = (apr_table_entry_t *)t_h->elts;\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                      \"Headers received from client:\");\n        for (i = 0; i < t_h->nelts; i++, t_elt++) {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r, \"  %s: %s\",\n                          ap_escape_logitem(r->pool, t_elt->key),\n                          ap_escape_logitem(r->pool, t_elt->val));\n        }\n    }\n\n#if APR_HAS_THREADS\n    apr_thread_mutex_create(&r->invoke_mtx, APR_THREAD_MUTEX_DEFAULT, r->pool);\n    apr_thread_mutex_lock(r->invoke_mtx);\n#endif\n    access_status = ap_run_quick_handler(r, 0);  /* Not a look-up request */\n    if (access_status == DECLINED) {\n        access_status = ap_process_request_internal(r);\n        if (access_status == OK) {\n            access_status = ap_invoke_handler(r);\n        }\n    }\n\n    if (access_status == SUSPENDED) {\n        /* TODO: Should move these steps into a generic function, so modules\n         * working on a suspended request can also call _ENTRY again.\n         */\n        AP_PROCESS_REQUEST_RETURN((uintptr_t)r, r->uri, access_status);\n        if (ap_extended_status) {\n            ap_time_process_request(c->sbh, STOP_PREQUEST);\n        }\n        if (c->cs)\n            c->cs->state = CONN_STATE_SUSPENDED;\n#if APR_HAS_THREADS\n        apr_thread_mutex_unlock(r->invoke_mtx);\n#endif\n        return;\n    }\n#if APR_HAS_THREADS\n    apr_thread_mutex_unlock(r->invoke_mtx);\n#endif\n\n    ap_die_r(access_status, r, HTTP_OK);\n\n    ap_process_request_after_handler(r);\n}"
    },
    "ap_process_request@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 478, column 18>": {
      "basic_info": {
        "function_id": 1611,
        "name": "ap_process_request",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 478, column 18>",
        "is_definition": true,
        "start_line": 478,
        "end_line": 506,
        "return_type": "void",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_process_async_request": {
            "declaration": "void ap_process_async_request(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    int access_status;\n\n    /* Give quick handlers a shot at serving the request on the fast\n     * path, bypassing all of the other Apache hooks.\n     *\n     * This hook was added to enable serving files out of a URI keyed\n     * content cache ( e.g., Mike Abbott's Quick Shortcut Cache,\n     * described here: http://oss.sgi.com/projects/apache/mod_qsc.html )\n     *\n     * It may have other uses as well, such as routing requests directly to\n     * content handlers that have the ability to grok HTTP and do their\n     * own access checking, etc (e.g. servlet engines).\n     *\n     * Use this hook with extreme care and only if you know what you are\n     * doing.\n     */\n    AP_PROCESS_REQUEST_ENTRY((uintptr_t)r, r->uri);\n    if (ap_extended_status) {\n        ap_time_process_request(r->connection->sbh, START_PREQUEST);\n    }\n\n    if (APLOGrtrace4(r)) {\n        int i;\n        const apr_array_header_t *t_h = apr_table_elts(r->headers_in);\n        const apr_table_entry_t *t_elt = (apr_table_entry_t *)t_h->elts;\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                      \"Headers received from client:\");\n        for (i = 0; i < t_h->nelts; i++, t_elt++) {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r, \"  %s: %s\",\n                          ap_escape_logitem(r->pool, t_elt->key),\n                          ap_escape_logitem(r->pool, t_elt->val));\n        }\n    }\n\n#if APR_HAS_THREADS\n    apr_thread_mutex_create(&r->invoke_mtx, APR_THREAD_MUTEX_DEFAULT, r->pool);\n    apr_thread_mutex_lock(r->invoke_mtx);\n#endif\n    access_status = ap_run_quick_handler(r, 0);  /* Not a look-up request */\n    if (access_status == DECLINED) {\n        access_status = ap_process_request_internal(r);\n        if (access_status == OK) {\n            access_status = ap_invoke_handler(r);\n        }\n    }\n\n    if (access_status == SUSPENDED) {\n        /* TODO: Should move these steps into a generic function, so modules\n         * working on a suspended request can also call _ENTRY again.\n         */\n        AP_PROCESS_REQUEST_RETURN((uintptr_t)r, r->uri, access_status);\n        if (ap_extended_status) {\n            ap_time_process_request(c->sbh, STOP_PREQUEST);\n        }\n        if (c->cs)\n            c->cs->state = CONN_STATE_SUSPENDED;\n#if APR_HAS_THREADS\n        apr_thread_mutex_unlock(r->invoke_mtx);\n#endif\n        return;\n    }\n#if APR_HAS_THREADS\n    apr_thread_mutex_unlock(r->invoke_mtx);\n#endif\n\n    ap_die_r(access_status, r, HTTP_OK);\n\n    ap_process_request_after_handler(r);\n}",
            "is_external": false,
            "definition": "void ap_process_async_request(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    int access_status;\n\n    /* Give quick handlers a shot at serving the request on the fast\n     * path, bypassing all of the other Apache hooks.\n     *\n     * This hook was added to enable serving files out of a URI keyed\n     * content cache ( e.g., Mike Abbott's Quick Shortcut Cache,\n     * described here: http://oss.sgi.com/projects/apache/mod_qsc.html )\n     *\n     * It may have other uses as well, such as routing requests directly to\n     * content handlers that have the ability to grok HTTP and do their\n     * own access checking, etc (e.g. servlet engines).\n     *\n     * Use this hook with extreme care and only if you know what you are\n     * doing.\n     */\n    AP_PROCESS_REQUEST_ENTRY((uintptr_t)r, r->uri);\n    if (ap_extended_status) {\n        ap_time_process_request(r->connection->sbh, START_PREQUEST);\n    }\n\n    if (APLOGrtrace4(r)) {\n        int i;\n        const apr_array_header_t *t_h = apr_table_elts(r->headers_in);\n        const apr_table_entry_t *t_elt = (apr_table_entry_t *)t_h->elts;\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                      \"Headers received from client:\");\n        for (i = 0; i < t_h->nelts; i++, t_elt++) {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r, \"  %s: %s\",\n                          ap_escape_logitem(r->pool, t_elt->key),\n                          ap_escape_logitem(r->pool, t_elt->val));\n        }\n    }\n\n#if APR_HAS_THREADS\n    apr_thread_mutex_create(&r->invoke_mtx, APR_THREAD_MUTEX_DEFAULT, r->pool);\n    apr_thread_mutex_lock(r->invoke_mtx);\n#endif\n    access_status = ap_run_quick_handler(r, 0);  /* Not a look-up request */\n    if (access_status == DECLINED) {\n        access_status = ap_process_request_internal(r);\n        if (access_status == OK) {\n            access_status = ap_invoke_handler(r);\n        }\n    }\n\n    if (access_status == SUSPENDED) {\n        /* TODO: Should move these steps into a generic function, so modules\n         * working on a suspended request can also call _ENTRY again.\n         */\n        AP_PROCESS_REQUEST_RETURN((uintptr_t)r, r->uri, access_status);\n        if (ap_extended_status) {\n            ap_time_process_request(c->sbh, STOP_PREQUEST);\n        }\n        if (c->cs)\n            c->cs->state = CONN_STATE_SUSPENDED;\n#if APR_HAS_THREADS\n        apr_thread_mutex_unlock(r->invoke_mtx);\n#endif\n        return;\n    }\n#if APR_HAS_THREADS\n    apr_thread_mutex_unlock(r->invoke_mtx);\n#endif\n\n    ap_die_r(access_status, r, HTTP_OK);\n\n    ap_process_request_after_handler(r);\n}"
          },
          "ap_run_input_pending": {
            "declaration": "ap_run_input_pending(c)",
            "is_external": true,
            "definition": null
          },
          "ap_acquire_brigade": {
            "declaration": "ap_acquire_brigade(c)",
            "is_external": true,
            "definition": null
          },
          "apr_bucket_flush_create": {
            "declaration": "APU_DECLARE(apr_bucket *) apr_bucket_flush_create(apr_bucket_alloc_t *list)",
            "is_external": true,
            "definition": null
          },
          "ap_pass_brigade": {
            "declaration": "AP_DECLARE(apr_status_t) ap_pass_brigade(ap_filter_t *filter,\n                                         apr_bucket_brigade *bucket)",
            "is_external": true,
            "definition": null
          },
          "ap_log_cerror_": {
            "declaration": "AP_DECLARE(void) ap_log_cerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const conn_rec *c, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "ap_release_brigade": {
            "declaration": "ap_release_brigade(c, bb)",
            "is_external": true,
            "definition": null
          },
          "ap_time_process_request": {
            "declaration": "AP_DECLARE(void) ap_time_process_request(ap_sb_handle_t *sbh, int status)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "conn_rec": {
            "name": "conn_rec",
            "definition": "struct conn_rec {\n    /** Pool associated with this connection */\n    apr_pool_t *pool;\n    /** Physical vhost this conn came in on */\n    server_rec *base_server;\n    /** used by http_vhost.c */\n    void *vhost_lookup_data;\n\n    /* Information about the connection itself */\n    /** local address */\n    apr_sockaddr_t *local_addr;\n    /** remote address; this is the end-point of the next hop, for the address\n     *  of the request creator, see useragent_addr in request_rec\n     */\n    apr_sockaddr_t *client_addr;\n\n    /** Client's IP address; this is the end-point of the next hop, for the\n     *  IP of the request creator, see useragent_ip in request_rec\n     */\n    char *client_ip;\n    /** Client's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     * get_remote_host() */\n    char *remote_host;\n    /** Only ever set if doing rfc1413 lookups.  N.B. Only access this through\n     *  get_remote_logname() */\n    char *remote_logname;\n\n    /** server IP address */\n    char *local_ip;\n    /** used for ap_get_server_name when UseCanonicalName is set to DNS\n     *  (ignores setting of HostnameLookups) */\n    char *local_host;\n\n    /** ID of this connection; unique at any point in time */\n    long id;\n    /** Config vector containing pointers to connections per-server\n     *  config structures. */\n    struct ap_conf_vector_t *conn_config;\n    /** Notes on *this* connection: send note from one module to\n     *  another. must remain valid for all requests on this conn */\n    apr_table_t *notes;\n    /** A list of input filters to be used for this connection */\n    struct ap_filter_t *input_filters;\n    /** A list of output filters to be used for this connection */\n    struct ap_filter_t *output_filters;\n    /** handle to scoreboard information for this connection */\n    void *sbh;\n    /** The bucket allocator to use for all bucket/brigade creations */\n    struct apr_bucket_alloc_t *bucket_alloc;\n    /** The current state of this connection; may be NULL if not used by MPM */\n    conn_state_t *cs;\n    /** Is there data pending in the input filters? */\n    int data_in_input_filters;\n    /** Is there data pending in the output filters? */\n    int data_in_output_filters;\n\n    /** Are there any filters that clogg/buffer the input stream, breaking\n     *  the event mpm.\n     */\n    unsigned int clogging_input_filters:1;\n\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success */\n    signed int double_reverse:2;\n\n    /** Are we still talking? */\n    unsigned aborted;\n\n    /** Are we going to keep the connection alive for another request?\n     * @see ap_conn_keepalive_e */\n    ap_conn_keepalive_e keepalive;\n\n    /** How many times have we used it? */\n    int keepalives;\n\n    /** Optional connection log level configuration. May point to a server or\n     *  per_dir config, i.e. must be copied before modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify this connection in error log. Set when the first\n     *  error log entry for this connection is generated.\n     */\n    const char *log_id;\n\n\n    /** This points to the current thread being used to process this request,\n     * over the lifetime of a request, the value may change. Users of the connection\n     * record should not rely upon it staying the same between calls that involve\n     * the MPM.\n     */\n#if APR_HAS_THREADS\n    apr_thread_t *current_thread;\n#endif\n\n    /** The \"real\" master connection. NULL if I am the master. */\n    conn_rec *master;\n\n    int outgoing;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "base_server": "server_rec *",
              "vhost_lookup_data": "void *",
              "local_addr": "apr_sockaddr_t *",
              "client_addr": "apr_sockaddr_t *",
              "client_ip": "char *",
              "remote_host": "char *",
              "remote_logname": "char *",
              "local_ip": "char *",
              "local_host": "char *",
              "id": "long",
              "conn_config": "struct ap_conf_vector_t *",
              "notes": "apr_table_t *",
              "input_filters": "struct ap_filter_t *",
              "output_filters": "struct ap_filter_t *",
              "sbh": "void *",
              "bucket_alloc": "struct apr_bucket_alloc_t *",
              "cs": "conn_state_t *",
              "data_in_input_filters": "int",
              "data_in_output_filters": "int",
              "clogging_input_filters": "unsigned int",
              "double_reverse": "int",
              "aborted": "unsigned int",
              "keepalive": "ap_conn_keepalive_e",
              "keepalives": "int",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "current_thread": "apr_thread_t *",
              "master": "conn_rec *",
              "outgoing": "int"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          },
          "ap_extended_status": {
            "name": "ap_extended_status",
            "type": "int",
            "is_extern": true,
            "is_static": false,
            "definition": "extern int ap_extended_status",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "apr_status_t"
        ]
      },
      "source_code": "AP_DECLARE(void) ap_process_request(request_rec *r)\n{\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n    conn_rec *c = r->connection;\n    apr_status_t rv;\n\n    ap_process_async_request(r);\n\n    if (ap_run_input_pending(c) != OK) {\n        bb = ap_acquire_brigade(c);\n        b = apr_bucket_flush_create(c->bucket_alloc);\n        APR_BRIGADE_INSERT_HEAD(bb, b);\n        rv = ap_pass_brigade(c->output_filters, bb);\n        if (APR_STATUS_IS_TIMEUP(rv)) {\n            /*\n             * Notice a timeout as an error message. This might be\n             * valuable for detecting clients with broken network\n             * connections or possible DoS attacks.\n             */\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, rv, c, APLOGNO(01581)\n                          \"flushing data to the client\");\n        }\n        ap_release_brigade(c, bb);\n    }\n    if (ap_extended_status) {\n        ap_time_process_request(c->sbh, STOP_PREQUEST);\n    }\n}"
    },
    "rename_original_env@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 508, column 21>": {
      "basic_info": {
        "function_id": 1612,
        "name": "rename_original_env",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 508, column 21>",
        "is_definition": true,
        "start_line": 508,
        "end_line": 523,
        "return_type": "apr_table_t *",
        "parameters": [
          {
            "name": "p",
            "type": "apr_pool_t *"
          },
          {
            "name": "t",
            "type": "apr_table_t *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_table_elts": {
            "declaration": "APR_DECLARE(const apr_array_header_t *) apr_table_elts(const apr_table_t *t)",
            "is_external": true,
            "definition": null
          },
          "apr_table_make": {
            "declaration": "APR_DECLARE(apr_table_t *) apr_table_make(apr_pool_t *p, int nelts)",
            "is_external": true,
            "definition": null
          },
          "apr_table_setn": {
            "declaration": "APR_DECLARE(void) apr_table_setn(apr_table_t *t, const char *key,\n                                 const char *val)",
            "is_external": true,
            "definition": null
          },
          "apr_pstrcat": {
            "declaration": "APR_DECLARE_NONSTD(char *) apr_pstrcat(apr_pool_t *p, ...)\n#if defined(__GNUC__) && __GNUC__ >= 4\n    __attribute__((sentinel))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "internal_internal_redirect@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 525, column 21>": {
            "source_code": "static request_rec *internal_internal_redirect(const char *new_uri,\n                                               request_rec *r) {\n    int access_status;\n    request_rec *new;\n    const char *vary_header;\n\n    if (ap_is_recursion_limit_exceeded(r)) {\n        ap_die(HTTP_INTERNAL_SERVER_ERROR, r);\n        return NULL;\n    }\n\n    new = (request_rec *) apr_pcalloc(r->pool, sizeof(request_rec));\n\n    new->connection = r->connection;\n    new->server     = r->server;\n    new->pool       = r->pool;\n\n    /*\n     * A whole lot of this really ought to be shared with http_protocol.c...\n     * another missing cleanup.  It's particularly inappropriate to be\n     * setting header_only, etc., here.\n     */\n\n    new->method          = r->method;\n    new->method_number   = r->method_number;\n    new->allowed_methods = ap_make_method_list(new->pool, 2);\n    ap_parse_uri(new, new_uri);\n    new->parsed_uri.port_str = r->parsed_uri.port_str;\n    new->parsed_uri.port = r->parsed_uri.port;\n\n    new->request_config = ap_create_request_config(r->pool);\n\n    new->per_dir_config = r->server->lookup_defaults;\n\n    new->prev = r;\n    r->next   = new;\n\n    new->useragent_addr = r->useragent_addr;\n    new->useragent_ip = r->useragent_ip;\n\n    /* Must have prev and next pointers set before calling create_request\n     * hook.\n     */\n    ap_run_create_request(new);\n\n    /* Inherit the rest of the protocol info... */\n\n    new->the_request = r->the_request;\n\n    new->allowed         = r->allowed;\n\n    new->status          = r->status;\n    new->assbackwards    = r->assbackwards;\n    new->header_only     = r->header_only;\n    new->protocol        = r->protocol;\n    new->proto_num       = r->proto_num;\n    new->hostname        = r->hostname;\n    new->request_time    = r->request_time;\n    new->main            = r->main;\n\n    new->headers_in      = r->headers_in;\n    new->trailers_in     = r->trailers_in;\n    new->headers_out     = apr_table_make(r->pool, 12);\n    if (ap_is_HTTP_REDIRECT(new->status)) {\n        const char *location = apr_table_get(r->headers_out, \"Location\");\n        if (location)\n            apr_table_setn(new->headers_out, \"Location\", location);\n    }\n\n    /* A module (like mod_rewrite) can force an internal redirect\n     * to carry over the Vary header (if present).\n     */\n    if (apr_table_get(r->notes, \"redirect-keeps-vary\")) {\n        if((vary_header = apr_table_get(r->headers_out, \"Vary\"))) {\n            apr_table_setn(new->headers_out, \"Vary\", vary_header);\n        }\n    }\n\n    new->err_headers_out = r->err_headers_out;\n    new->trailers_out    = apr_table_make(r->pool, 5);\n    new->subprocess_env  = rename_original_env(r->pool, r->subprocess_env);\n    new->notes           = apr_table_make(r->pool, 5);\n\n    new->htaccess        = r->htaccess;\n    new->no_cache        = r->no_cache;\n    new->expecting_100   = r->expecting_100;\n    new->no_local_copy   = r->no_local_copy;\n    new->read_length     = r->read_length;     /* We can only read it once */\n    new->vlist_validator = r->vlist_validator;\n\n    new->proto_output_filters  = r->proto_output_filters;\n    new->proto_input_filters   = r->proto_input_filters;\n\n    new->input_filters   = new->proto_input_filters;\n\n    if (new->main) {\n        ap_filter_t *f, *nextf;\n\n        /* If this is a subrequest, the filter chain may contain a\n         * mixture of filters specific to the old request (r), and\n         * some inherited from r->main.  Here, inherit that filter\n         * chain, and remove all those which are specific to the old\n         * request; ensuring the subreq filter is left in place. */\n        new->output_filters = r->output_filters;\n\n        f = new->output_filters;\n        do {\n            nextf = f->next;\n\n            if (f->r == r && f->frec != ap_subreq_core_filter_handle) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01582)\n                              \"dropping filter '%s' in internal redirect from %s to %s\",\n                              f->frec->name, r->unparsed_uri, new_uri);\n\n                /* To remove the filter, first set f->r to the *new*\n                 * request_rec, so that ->output_filters on 'new' is\n                 * changed (if necessary) when removing the filter. */\n                f->r = new;\n                ap_remove_output_filter(f);\n            }\n\n            f = nextf;\n\n            /* Stop at the protocol filters.  If a protocol filter has\n             * been newly installed for this resource, better leave it\n             * in place, though it's probably a misconfiguration or\n             * filter bug to get into this state. */\n        } while (f && f != new->proto_output_filters);\n    }\n    else {\n        /* If this is not a subrequest, clear out all\n         * resource-specific filters. */\n        new->output_filters  = new->proto_output_filters;\n    }\n\n    update_r_in_filters(new->input_filters, r, new);\n    update_r_in_filters(new->output_filters, r, new);\n\n    apr_table_setn(new->subprocess_env, \"REDIRECT_STATUS\",\n                   apr_itoa(r->pool, r->status));\n\n    /* Begin by presuming any module can make its own path_info assumptions,\n     * until some module interjects and changes the value.\n     */\n    new->used_path_info = AP_REQ_DEFAULT_PATH_INFO;\n\n#if APR_HAS_THREADS\n    new->invoke_mtx = r->invoke_mtx;\n#endif\n\n    /*\n     * XXX: hmm.  This is because mod_setenvif and mod_unique_id really need\n     * to do their thing on internal redirects as well.  Perhaps this is a\n     * misnamed function.\n     */\n    if ((access_status = ap_post_read_request(new))) {\n        ap_die(access_status, new);\n        return NULL;\n    }\n\n    return new;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 525, column 21>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "apr_table_t": {
            "name": "apr_table_t",
            "definition": "struct apr_table_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          },
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          },
          "apr_array_header_t": {
            "name": "apr_array_header_t",
            "definition": "struct apr_array_header_t {\n    /** The pool the array is allocated out of */\n    apr_pool_t *pool;\n    /** The amount of memory allocated for each element of the array */\n    int elt_size;\n    /** The number of active elements in the array */\n    int nelts;\n    /** The number of elements allocated in the array */\n    int nalloc;\n    /** The elements in the array */\n    char *elts;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "elt_size": "int",
              "nelts": "int",
              "nalloc": "int",
              "elts": "char *"
            },
            "condition": ""
          },
          "apr_table_entry_t": {
            "name": "apr_table_entry_t",
            "definition": "struct apr_table_entry_t {\n    /** The key for the current table entry */\n    char *key;          /* maybe NULL in future;\n                         * check when iterating thru table_elts\n                         */\n    /** The value for the current table entry */\n    char *val;\n\n    /** A checksum for the key, for use by the apr_table internals */\n    apr_uint32_t key_checksum;\n}",
            "typedef_name": null,
            "fields": {
              "key": "char *",
              "val": "char *",
              "key_checksum": "apr_uint32_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static apr_table_t *rename_original_env(apr_pool_t *p, apr_table_t *t)\n{\n    const apr_array_header_t *env_arr = apr_table_elts(t);\n    const apr_table_entry_t *elts = (const apr_table_entry_t *) env_arr->elts;\n    apr_table_t *new = apr_table_make(p, env_arr->nalloc);\n    int i;\n\n    for (i = 0; i < env_arr->nelts; ++i) {\n        if (!elts[i].key)\n            continue;\n        apr_table_setn(new, apr_pstrcat(p, \"REDIRECT_\", elts[i].key, NULL),\n                  elts[i].val);\n    }\n\n    return new;\n}"
    },
    "internal_internal_redirect@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 525, column 21>": {
      "basic_info": {
        "function_id": 1613,
        "name": "internal_internal_redirect",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 525, column 21>",
        "is_definition": true,
        "start_line": 525,
        "end_line": 686,
        "return_type": "request_rec *",
        "parameters": [
          {
            "name": "new_uri",
            "type": "const char *"
          },
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_is_recursion_limit_exceeded": {
            "declaration": "AP_DECLARE(int) ap_is_recursion_limit_exceeded(const request_rec *r)",
            "is_external": true,
            "definition": null
          },
          "ap_die": {
            "declaration": "AP_DECLARE(void) ap_die(int type, request_rec *r)\n{\n    ap_die_r(type, r, r->status);\n}",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_die(int type, request_rec *r)\n{\n    ap_die_r(type, r, r->status);\n}"
          },
          "memset": {
            "declaration": "extern void *memset (void *__s, int __c, size_t __n) __THROW __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "ap_make_method_list": {
            "declaration": "AP_DECLARE(ap_method_list_t *) ap_make_method_list(apr_pool_t *p, int nelts)",
            "is_external": false,
            "definition": "AP_DECLARE(ap_method_list_t *) ap_make_method_list(apr_pool_t *p, int nelts)\n{\n    ap_method_list_t *ml;\n\n    ml = (ap_method_list_t *) apr_palloc(p, sizeof(ap_method_list_t));\n    ml->method_mask = 0;\n    ml->method_list = apr_array_make(p, nelts, sizeof(char *));\n    return ml;\n}"
          },
          "ap_parse_uri": {
            "declaration": "AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char *uri)",
            "is_external": true,
            "definition": null
          },
          "ap_create_request_config": {
            "declaration": "AP_DECLARE(ap_conf_vector_t*) ap_create_request_config(apr_pool_t *p)",
            "is_external": true,
            "definition": null
          },
          "ap_run_create_request": {
            "declaration": "AP_DECLARE_HOOK(int,create_request,(request_rec *r))",
            "is_external": true,
            "definition": null
          },
          "apr_table_make": {
            "declaration": "APR_DECLARE(apr_table_t *) apr_table_make(apr_pool_t *p, int nelts)",
            "is_external": true,
            "definition": null
          },
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "apr_table_setn": {
            "declaration": "APR_DECLARE(void) apr_table_setn(apr_table_t *t, const char *key,\n                                 const char *val)",
            "is_external": true,
            "definition": null
          },
          "rename_original_env": {
            "declaration": "static apr_table_t *rename_original_env(apr_pool_t *p, apr_table_t *t)\n{\n    const apr_array_header_t *env_arr = apr_table_elts(t);\n    const apr_table_entry_t *elts = (const apr_table_entry_t *) env_arr->elts;\n    apr_table_t *new = apr_table_make(p, env_arr->nalloc);\n    int i;\n\n    for (i = 0; i < env_arr->nelts; ++i) {\n        if (!elts[i].key)\n            continue;\n        apr_table_setn(new, apr_pstrcat(p, \"REDIRECT_\", elts[i].key, NULL),\n                  elts[i].val);\n    }\n\n    return new;\n}",
            "is_external": false,
            "definition": "static apr_table_t *rename_original_env(apr_pool_t *p, apr_table_t *t)\n{\n    const apr_array_header_t *env_arr = apr_table_elts(t);\n    const apr_table_entry_t *elts = (const apr_table_entry_t *) env_arr->elts;\n    apr_table_t *new = apr_table_make(p, env_arr->nalloc);\n    int i;\n\n    for (i = 0; i < env_arr->nelts; ++i) {\n        if (!elts[i].key)\n            continue;\n        apr_table_setn(new, apr_pstrcat(p, \"REDIRECT_\", elts[i].key, NULL),\n                  elts[i].val);\n    }\n\n    return new;\n}"
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "ap_remove_output_filter": {
            "declaration": "AP_DECLARE(void) ap_remove_output_filter(ap_filter_t *f)",
            "is_external": true,
            "definition": null
          },
          "update_r_in_filters": {
            "declaration": "static void update_r_in_filters(ap_filter_t *f,\n                                request_rec *from,\n                                request_rec *to)\n{\n    while (f) {\n        if (f->r == from) {\n            f->r = to;\n        }\n        f = f->next;\n    }\n}",
            "is_external": false,
            "definition": "static void update_r_in_filters(ap_filter_t *f,\n                                request_rec *from,\n                                request_rec *to)\n{\n    while (f) {\n        if (f->r == from) {\n            f->r = to;\n        }\n        f = f->next;\n    }\n}"
          },
          "apr_itoa": {
            "declaration": "APR_DECLARE(char *) apr_itoa(apr_pool_t *p, int n)",
            "is_external": true,
            "definition": null
          },
          "ap_post_read_request": {
            "declaration": "AP_DECLARE(int) ap_post_read_request(request_rec *r)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_internal_redirect@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 771, column 18>": {
            "source_code": "AP_DECLARE(void) ap_internal_redirect(const char *new_uri, request_rec *r)\n{\n    int access_status;\n    request_rec *new = internal_internal_redirect(new_uri, r);\n\n    AP_INTERNAL_REDIRECT(r->uri, new_uri);\n\n    /* ap_die was already called, if an error occurred */\n    if (!new) {\n        return;\n    }\n\n    access_status = ap_run_quick_handler(new, 0);  /* Not a look-up request */\n    if (access_status == DECLINED) {\n        access_status = ap_process_request_internal(new);\n        if (access_status == OK) {\n            access_status = ap_invoke_handler(new);\n        }\n    }\n    ap_die(access_status, new);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 771, column 18>"
          },
          "ap_internal_redirect_handler@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 797, column 18>": {
            "source_code": "AP_DECLARE(void) ap_internal_redirect_handler(const char *new_uri, request_rec *r)\n{\n    int access_status;\n    request_rec *new = internal_internal_redirect(new_uri, r);\n\n    /* ap_die was already called, if an error occurred */\n    if (!new) {\n        return;\n    }\n\n    if (r->handler)\n        ap_set_content_type_ex(new, r->content_type, AP_REQUEST_IS_TRUSTED_CT(r));\n    access_status = ap_process_request_internal(new);\n    if (access_status == OK) {\n        access_status = ap_invoke_handler(new);\n    }\n    ap_die(access_status, new);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 797, column 18>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "ap_filter_t": {
            "name": "ap_filter_t",
            "definition": "struct ap_filter_t {\n    /** The internal representation of this filter.  This includes\n     *  the filter's name, type, and the actual function pointer.\n     */\n    ap_filter_rec_t *frec;\n\n    /** A place to store any data associated with the current filter */\n    void *ctx;\n\n    /** The next filter in the chain */\n    ap_filter_t *next;\n\n    /** The request_rec associated with the current filter.  If a sub-request\n     *  adds filters, then the sub-request is the request associated with the\n     *  filter.\n     */\n    request_rec *r;\n\n    /** The conn_rec associated with the current filter.  This is analogous\n     *  to the request_rec, except that it is used for connection filters.\n     */\n    conn_rec *c;\n}",
            "typedef_name": null,
            "fields": {
              "frec": "ap_filter_rec_t *",
              "ctx": "void *",
              "next": "ap_filter_t *",
              "r": "request_rec *",
              "c": "conn_rec *"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "ap_subreq_core_filter_handle": {
            "name": "ap_subreq_core_filter_handle",
            "type": "ap_filter_rec_t *",
            "is_extern": true,
            "is_static": false,
            "definition": "extern ap_filter_rec_t *ap_subreq_core_filter_handle",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "static request_rec *internal_internal_redirect(const char *new_uri,\n                                               request_rec *r) {\n    int access_status;\n    request_rec *new;\n    const char *vary_header;\n\n    if (ap_is_recursion_limit_exceeded(r)) {\n        ap_die(HTTP_INTERNAL_SERVER_ERROR, r);\n        return NULL;\n    }\n\n    new = (request_rec *) apr_pcalloc(r->pool, sizeof(request_rec));\n\n    new->connection = r->connection;\n    new->server     = r->server;\n    new->pool       = r->pool;\n\n    /*\n     * A whole lot of this really ought to be shared with http_protocol.c...\n     * another missing cleanup.  It's particularly inappropriate to be\n     * setting header_only, etc., here.\n     */\n\n    new->method          = r->method;\n    new->method_number   = r->method_number;\n    new->allowed_methods = ap_make_method_list(new->pool, 2);\n    ap_parse_uri(new, new_uri);\n    new->parsed_uri.port_str = r->parsed_uri.port_str;\n    new->parsed_uri.port = r->parsed_uri.port;\n\n    new->request_config = ap_create_request_config(r->pool);\n\n    new->per_dir_config = r->server->lookup_defaults;\n\n    new->prev = r;\n    r->next   = new;\n\n    new->useragent_addr = r->useragent_addr;\n    new->useragent_ip = r->useragent_ip;\n\n    /* Must have prev and next pointers set before calling create_request\n     * hook.\n     */\n    ap_run_create_request(new);\n\n    /* Inherit the rest of the protocol info... */\n\n    new->the_request = r->the_request;\n\n    new->allowed         = r->allowed;\n\n    new->status          = r->status;\n    new->assbackwards    = r->assbackwards;\n    new->header_only     = r->header_only;\n    new->protocol        = r->protocol;\n    new->proto_num       = r->proto_num;\n    new->hostname        = r->hostname;\n    new->request_time    = r->request_time;\n    new->main            = r->main;\n\n    new->headers_in      = r->headers_in;\n    new->trailers_in     = r->trailers_in;\n    new->headers_out     = apr_table_make(r->pool, 12);\n    if (ap_is_HTTP_REDIRECT(new->status)) {\n        const char *location = apr_table_get(r->headers_out, \"Location\");\n        if (location)\n            apr_table_setn(new->headers_out, \"Location\", location);\n    }\n\n    /* A module (like mod_rewrite) can force an internal redirect\n     * to carry over the Vary header (if present).\n     */\n    if (apr_table_get(r->notes, \"redirect-keeps-vary\")) {\n        if((vary_header = apr_table_get(r->headers_out, \"Vary\"))) {\n            apr_table_setn(new->headers_out, \"Vary\", vary_header);\n        }\n    }\n\n    new->err_headers_out = r->err_headers_out;\n    new->trailers_out    = apr_table_make(r->pool, 5);\n    new->subprocess_env  = rename_original_env(r->pool, r->subprocess_env);\n    new->notes           = apr_table_make(r->pool, 5);\n\n    new->htaccess        = r->htaccess;\n    new->no_cache        = r->no_cache;\n    new->expecting_100   = r->expecting_100;\n    new->no_local_copy   = r->no_local_copy;\n    new->read_length     = r->read_length;     /* We can only read it once */\n    new->vlist_validator = r->vlist_validator;\n\n    new->proto_output_filters  = r->proto_output_filters;\n    new->proto_input_filters   = r->proto_input_filters;\n\n    new->input_filters   = new->proto_input_filters;\n\n    if (new->main) {\n        ap_filter_t *f, *nextf;\n\n        /* If this is a subrequest, the filter chain may contain a\n         * mixture of filters specific to the old request (r), and\n         * some inherited from r->main.  Here, inherit that filter\n         * chain, and remove all those which are specific to the old\n         * request; ensuring the subreq filter is left in place. */\n        new->output_filters = r->output_filters;\n\n        f = new->output_filters;\n        do {\n            nextf = f->next;\n\n            if (f->r == r && f->frec != ap_subreq_core_filter_handle) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01582)\n                              \"dropping filter '%s' in internal redirect from %s to %s\",\n                              f->frec->name, r->unparsed_uri, new_uri);\n\n                /* To remove the filter, first set f->r to the *new*\n                 * request_rec, so that ->output_filters on 'new' is\n                 * changed (if necessary) when removing the filter. */\n                f->r = new;\n                ap_remove_output_filter(f);\n            }\n\n            f = nextf;\n\n            /* Stop at the protocol filters.  If a protocol filter has\n             * been newly installed for this resource, better leave it\n             * in place, though it's probably a misconfiguration or\n             * filter bug to get into this state. */\n        } while (f && f != new->proto_output_filters);\n    }\n    else {\n        /* If this is not a subrequest, clear out all\n         * resource-specific filters. */\n        new->output_filters  = new->proto_output_filters;\n    }\n\n    update_r_in_filters(new->input_filters, r, new);\n    update_r_in_filters(new->output_filters, r, new);\n\n    apr_table_setn(new->subprocess_env, \"REDIRECT_STATUS\",\n                   apr_itoa(r->pool, r->status));\n\n    /* Begin by presuming any module can make its own path_info assumptions,\n     * until some module interjects and changes the value.\n     */\n    new->used_path_info = AP_REQ_DEFAULT_PATH_INFO;\n\n#if APR_HAS_THREADS\n    new->invoke_mtx = r->invoke_mtx;\n#endif\n\n    /*\n     * XXX: hmm.  This is because mod_setenvif and mod_unique_id really need\n     * to do their thing on internal redirects as well.  Perhaps this is a\n     * misnamed function.\n     */\n    if ((access_status = ap_post_read_request(new))) {\n        ap_die(access_status, new);\n        return NULL;\n    }\n\n    return new;\n}"
    },
    "ap_internal_fast_redirect@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 689, column 18>": {
      "basic_info": {
        "function_id": 1614,
        "name": "ap_internal_fast_redirect",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 689, column 18>",
        "is_definition": true,
        "start_line": 689,
        "end_line": 769,
        "return_type": "void",
        "parameters": [
          {
            "name": "rr",
            "type": "request_rec *"
          },
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_set_content_type_ex": {
            "declaration": "AP_DECLARE(void) ap_set_content_type_ex(request_rec *r, const char *ct, int trusted)",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_set_content_type_ex(request_rec *r, const char *ct, int trusted)\n{\n    ap_set_content_type(r, ct);\n    AP_REQUEST_SET_BNOTE(r, AP_REQUEST_TRUSTED_CT, trusted ? AP_REQUEST_TRUSTED_CT : 0);\n}"
          },
          "apr_table_overlay": {
            "declaration": "APR_DECLARE(apr_table_t *) apr_table_overlay(apr_pool_t *p,\n                                             const apr_table_t *overlay,\n                                             const apr_table_t *base)",
            "is_external": true,
            "definition": null
          },
          "update_r_in_filters": {
            "declaration": "static void update_r_in_filters(ap_filter_t *f,\n                                request_rec *from,\n                                request_rec *to)\n{\n    while (f) {\n        if (f->r == from) {\n            f->r = to;\n        }\n        f = f->next;\n    }\n}",
            "is_external": false,
            "definition": "static void update_r_in_filters(ap_filter_t *f,\n                                request_rec *from,\n                                request_rec *to)\n{\n    while (f) {\n        if (f->r == from) {\n            f->r = to;\n        }\n        f = f->next;\n    }\n}"
          },
          "ap_add_output_filter_handle": {
            "declaration": "AP_DECLARE(ap_filter_t *) ap_add_output_filter_handle(ap_filter_rec_t *f,\n                                                      void *ctx,\n                                                      request_rec *r,\n                                                      conn_rec *c)",
            "is_external": true,
            "definition": null
          },
          "ap_remove_output_filter": {
            "declaration": "AP_DECLARE(void) ap_remove_output_filter(ap_filter_t *f)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "ap_filter_t": {
            "name": "ap_filter_t",
            "definition": "struct ap_filter_t {\n    /** The internal representation of this filter.  This includes\n     *  the filter's name, type, and the actual function pointer.\n     */\n    ap_filter_rec_t *frec;\n\n    /** A place to store any data associated with the current filter */\n    void *ctx;\n\n    /** The next filter in the chain */\n    ap_filter_t *next;\n\n    /** The request_rec associated with the current filter.  If a sub-request\n     *  adds filters, then the sub-request is the request associated with the\n     *  filter.\n     */\n    request_rec *r;\n\n    /** The conn_rec associated with the current filter.  This is analogous\n     *  to the request_rec, except that it is used for connection filters.\n     */\n    conn_rec *c;\n}",
            "typedef_name": null,
            "fields": {
              "frec": "ap_filter_rec_t *",
              "ctx": "void *",
              "next": "ap_filter_t *",
              "r": "request_rec *",
              "c": "conn_rec *"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "ap_subreq_core_filter_handle": {
            "name": "ap_subreq_core_filter_handle",
            "type": "ap_filter_rec_t *",
            "is_extern": true,
            "is_static": false,
            "definition": "extern ap_filter_rec_t *ap_subreq_core_filter_handle",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(void) ap_internal_fast_redirect(request_rec *rr, request_rec *r)\n{\n    /* We need to tell POOL_DEBUG that we're guaranteeing that rr->pool\n     * will exist as long as r->pool.  Otherwise we run into troubles because\n     * some values in this request will be allocated in r->pool, and others in\n     * rr->pool.\n     */\n    apr_pool_join(r->pool, rr->pool);\n    r->proxyreq = rr->proxyreq;\n    r->no_cache = (r->no_cache && rr->no_cache);\n    r->no_local_copy = (r->no_local_copy && rr->no_local_copy);\n    r->mtime = rr->mtime;\n    r->uri = rr->uri;\n    r->filename = rr->filename;\n    r->canonical_filename = rr->canonical_filename;\n    r->path_info = rr->path_info;\n    r->args = rr->args;\n    r->finfo = rr->finfo;\n    r->handler = rr->handler;\n    ap_set_content_type_ex(r, rr->content_type, AP_REQUEST_IS_TRUSTED_CT(rr));\n    r->content_encoding = rr->content_encoding;\n    r->content_languages = rr->content_languages;\n    r->per_dir_config = rr->per_dir_config;\n    /* copy output headers from subrequest, but leave negotiation headers */\n    r->notes = apr_table_overlay(r->pool, rr->notes, r->notes);\n    r->headers_out = apr_table_overlay(r->pool, rr->headers_out,\n                                       r->headers_out);\n    r->err_headers_out = apr_table_overlay(r->pool, rr->err_headers_out,\n                                           r->err_headers_out);\n    r->trailers_out = apr_table_overlay(r->pool, rr->trailers_out,\n                                           r->trailers_out);\n    r->subprocess_env = apr_table_overlay(r->pool, rr->subprocess_env,\n                                          r->subprocess_env);\n\n    r->output_filters = rr->output_filters;\n    r->input_filters = rr->input_filters;\n\n    /* If any filters pointed at the now-defunct rr, we must point them\n     * at our \"new\" instance of r.  In particular, some of rr's structures\n     * will now be bogus (say rr->headers_out).  If a filter tried to modify\n     * their f->r structure when it is pointing to rr, the real request_rec\n     * will not get updated.  Fix that here.\n     */\n    update_r_in_filters(r->input_filters, rr, r);\n    update_r_in_filters(r->output_filters, rr, r);\n\n    if (r->main) {\n        ap_filter_t *next = r->output_filters;\n        while (next && (next != r->proto_output_filters)) {\n            if (next->frec == ap_subreq_core_filter_handle) {\n                break;\n            }\n            next = next->next;\n        }\n        if (!next || next == r->proto_output_filters) {\n            ap_add_output_filter_handle(ap_subreq_core_filter_handle,\n                                        NULL, r, r->connection);\n        }\n    }\n    else {\n        /*\n         * We need to check if we now have the SUBREQ_CORE filter in our filter\n         * chain. If this is the case we need to remove it since we are NO\n         * subrequest. But we need to keep in mind that the SUBREQ_CORE filter\n         * does not necessarily need to be the first filter in our chain. So we\n         * need to go through the chain. But we only need to walk up the chain\n         * until the proto_output_filters as the SUBREQ_CORE filter is below the\n         * protocol filters.\n         */\n        ap_filter_t *next;\n\n        next = r->output_filters;\n        while (next && (next->frec != ap_subreq_core_filter_handle)\n               && (next != r->proto_output_filters)) {\n                next = next->next;\n        }\n        if (next && (next->frec == ap_subreq_core_filter_handle)) {\n            ap_remove_output_filter(next);\n        }\n    }\n}"
    },
    "ap_internal_redirect@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 771, column 18>": {
      "basic_info": {
        "function_id": 1615,
        "name": "ap_internal_redirect",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 771, column 18>",
        "is_definition": true,
        "start_line": 771,
        "end_line": 791,
        "return_type": "void",
        "parameters": [
          {
            "name": "new_uri",
            "type": "const char *"
          },
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "internal_internal_redirect": {
            "declaration": "static request_rec *internal_internal_redirect(const char *new_uri,\n                                               request_rec *r) {\n    int access_status;\n    request_rec *new;\n    const char *vary_header;\n\n    if (ap_is_recursion_limit_exceeded(r)) {\n        ap_die(HTTP_INTERNAL_SERVER_ERROR, r);\n        return NULL;\n    }\n\n    new = (request_rec *) apr_pcalloc(r->pool, sizeof(request_rec));\n\n    new->connection = r->connection;\n    new->server     = r->server;\n    new->pool       = r->pool;\n\n    /*\n     * A whole lot of this really ought to be shared with http_protocol.c...\n     * another missing cleanup.  It's particularly inappropriate to be\n     * setting header_only, etc., here.\n     */\n\n    new->method          = r->method;\n    new->method_number   = r->method_number;\n    new->allowed_methods = ap_make_method_list(new->pool, 2);\n    ap_parse_uri(new, new_uri);\n    new->parsed_uri.port_str = r->parsed_uri.port_str;\n    new->parsed_uri.port = r->parsed_uri.port;\n\n    new->request_config = ap_create_request_config(r->pool);\n\n    new->per_dir_config = r->server->lookup_defaults;\n\n    new->prev = r;\n    r->next   = new;\n\n    new->useragent_addr = r->useragent_addr;\n    new->useragent_ip = r->useragent_ip;\n\n    /* Must have prev and next pointers set before calling create_request\n     * hook.\n     */\n    ap_run_create_request(new);\n\n    /* Inherit the rest of the protocol info... */\n\n    new->the_request = r->the_request;\n\n    new->allowed         = r->allowed;\n\n    new->status          = r->status;\n    new->assbackwards    = r->assbackwards;\n    new->header_only     = r->header_only;\n    new->protocol        = r->protocol;\n    new->proto_num       = r->proto_num;\n    new->hostname        = r->hostname;\n    new->request_time    = r->request_time;\n    new->main            = r->main;\n\n    new->headers_in      = r->headers_in;\n    new->trailers_in     = r->trailers_in;\n    new->headers_out     = apr_table_make(r->pool, 12);\n    if (ap_is_HTTP_REDIRECT(new->status)) {\n        const char *location = apr_table_get(r->headers_out, \"Location\");\n        if (location)\n            apr_table_setn(new->headers_out, \"Location\", location);\n    }\n\n    /* A module (like mod_rewrite) can force an internal redirect\n     * to carry over the Vary header (if present).\n     */\n    if (apr_table_get(r->notes, \"redirect-keeps-vary\")) {\n        if((vary_header = apr_table_get(r->headers_out, \"Vary\"))) {\n            apr_table_setn(new->headers_out, \"Vary\", vary_header);\n        }\n    }\n\n    new->err_headers_out = r->err_headers_out;\n    new->trailers_out    = apr_table_make(r->pool, 5);\n    new->subprocess_env  = rename_original_env(r->pool, r->subprocess_env);\n    new->notes           = apr_table_make(r->pool, 5);\n\n    new->htaccess        = r->htaccess;\n    new->no_cache        = r->no_cache;\n    new->expecting_100   = r->expecting_100;\n    new->no_local_copy   = r->no_local_copy;\n    new->read_length     = r->read_length;     /* We can only read it once */\n    new->vlist_validator = r->vlist_validator;\n\n    new->proto_output_filters  = r->proto_output_filters;\n    new->proto_input_filters   = r->proto_input_filters;\n\n    new->input_filters   = new->proto_input_filters;\n\n    if (new->main) {\n        ap_filter_t *f, *nextf;\n\n        /* If this is a subrequest, the filter chain may contain a\n         * mixture of filters specific to the old request (r), and\n         * some inherited from r->main.  Here, inherit that filter\n         * chain, and remove all those which are specific to the old\n         * request; ensuring the subreq filter is left in place. */\n        new->output_filters = r->output_filters;\n\n        f = new->output_filters;\n        do {\n            nextf = f->next;\n\n            if (f->r == r && f->frec != ap_subreq_core_filter_handle) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01582)\n                              \"dropping filter '%s' in internal redirect from %s to %s\",\n                              f->frec->name, r->unparsed_uri, new_uri);\n\n                /* To remove the filter, first set f->r to the *new*\n                 * request_rec, so that ->output_filters on 'new' is\n                 * changed (if necessary) when removing the filter. */\n                f->r = new;\n                ap_remove_output_filter(f);\n            }\n\n            f = nextf;\n\n            /* Stop at the protocol filters.  If a protocol filter has\n             * been newly installed for this resource, better leave it\n             * in place, though it's probably a misconfiguration or\n             * filter bug to get into this state. */\n        } while (f && f != new->proto_output_filters);\n    }\n    else {\n        /* If this is not a subrequest, clear out all\n         * resource-specific filters. */\n        new->output_filters  = new->proto_output_filters;\n    }\n\n    update_r_in_filters(new->input_filters, r, new);\n    update_r_in_filters(new->output_filters, r, new);\n\n    apr_table_setn(new->subprocess_env, \"REDIRECT_STATUS\",\n                   apr_itoa(r->pool, r->status));\n\n    /* Begin by presuming any module can make its own path_info assumptions,\n     * until some module interjects and changes the value.\n     */\n    new->used_path_info = AP_REQ_DEFAULT_PATH_INFO;\n\n#if APR_HAS_THREADS\n    new->invoke_mtx = r->invoke_mtx;\n#endif\n\n    /*\n     * XXX: hmm.  This is because mod_setenvif and mod_unique_id really need\n     * to do their thing on internal redirects as well.  Perhaps this is a\n     * misnamed function.\n     */\n    if ((access_status = ap_post_read_request(new))) {\n        ap_die(access_status, new);\n        return NULL;\n    }\n\n    return new;\n}",
            "is_external": false,
            "definition": "static request_rec *internal_internal_redirect(const char *new_uri,\n                                               request_rec *r) {\n    int access_status;\n    request_rec *new;\n    const char *vary_header;\n\n    if (ap_is_recursion_limit_exceeded(r)) {\n        ap_die(HTTP_INTERNAL_SERVER_ERROR, r);\n        return NULL;\n    }\n\n    new = (request_rec *) apr_pcalloc(r->pool, sizeof(request_rec));\n\n    new->connection = r->connection;\n    new->server     = r->server;\n    new->pool       = r->pool;\n\n    /*\n     * A whole lot of this really ought to be shared with http_protocol.c...\n     * another missing cleanup.  It's particularly inappropriate to be\n     * setting header_only, etc., here.\n     */\n\n    new->method          = r->method;\n    new->method_number   = r->method_number;\n    new->allowed_methods = ap_make_method_list(new->pool, 2);\n    ap_parse_uri(new, new_uri);\n    new->parsed_uri.port_str = r->parsed_uri.port_str;\n    new->parsed_uri.port = r->parsed_uri.port;\n\n    new->request_config = ap_create_request_config(r->pool);\n\n    new->per_dir_config = r->server->lookup_defaults;\n\n    new->prev = r;\n    r->next   = new;\n\n    new->useragent_addr = r->useragent_addr;\n    new->useragent_ip = r->useragent_ip;\n\n    /* Must have prev and next pointers set before calling create_request\n     * hook.\n     */\n    ap_run_create_request(new);\n\n    /* Inherit the rest of the protocol info... */\n\n    new->the_request = r->the_request;\n\n    new->allowed         = r->allowed;\n\n    new->status          = r->status;\n    new->assbackwards    = r->assbackwards;\n    new->header_only     = r->header_only;\n    new->protocol        = r->protocol;\n    new->proto_num       = r->proto_num;\n    new->hostname        = r->hostname;\n    new->request_time    = r->request_time;\n    new->main            = r->main;\n\n    new->headers_in      = r->headers_in;\n    new->trailers_in     = r->trailers_in;\n    new->headers_out     = apr_table_make(r->pool, 12);\n    if (ap_is_HTTP_REDIRECT(new->status)) {\n        const char *location = apr_table_get(r->headers_out, \"Location\");\n        if (location)\n            apr_table_setn(new->headers_out, \"Location\", location);\n    }\n\n    /* A module (like mod_rewrite) can force an internal redirect\n     * to carry over the Vary header (if present).\n     */\n    if (apr_table_get(r->notes, \"redirect-keeps-vary\")) {\n        if((vary_header = apr_table_get(r->headers_out, \"Vary\"))) {\n            apr_table_setn(new->headers_out, \"Vary\", vary_header);\n        }\n    }\n\n    new->err_headers_out = r->err_headers_out;\n    new->trailers_out    = apr_table_make(r->pool, 5);\n    new->subprocess_env  = rename_original_env(r->pool, r->subprocess_env);\n    new->notes           = apr_table_make(r->pool, 5);\n\n    new->htaccess        = r->htaccess;\n    new->no_cache        = r->no_cache;\n    new->expecting_100   = r->expecting_100;\n    new->no_local_copy   = r->no_local_copy;\n    new->read_length     = r->read_length;     /* We can only read it once */\n    new->vlist_validator = r->vlist_validator;\n\n    new->proto_output_filters  = r->proto_output_filters;\n    new->proto_input_filters   = r->proto_input_filters;\n\n    new->input_filters   = new->proto_input_filters;\n\n    if (new->main) {\n        ap_filter_t *f, *nextf;\n\n        /* If this is a subrequest, the filter chain may contain a\n         * mixture of filters specific to the old request (r), and\n         * some inherited from r->main.  Here, inherit that filter\n         * chain, and remove all those which are specific to the old\n         * request; ensuring the subreq filter is left in place. */\n        new->output_filters = r->output_filters;\n\n        f = new->output_filters;\n        do {\n            nextf = f->next;\n\n            if (f->r == r && f->frec != ap_subreq_core_filter_handle) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01582)\n                              \"dropping filter '%s' in internal redirect from %s to %s\",\n                              f->frec->name, r->unparsed_uri, new_uri);\n\n                /* To remove the filter, first set f->r to the *new*\n                 * request_rec, so that ->output_filters on 'new' is\n                 * changed (if necessary) when removing the filter. */\n                f->r = new;\n                ap_remove_output_filter(f);\n            }\n\n            f = nextf;\n\n            /* Stop at the protocol filters.  If a protocol filter has\n             * been newly installed for this resource, better leave it\n             * in place, though it's probably a misconfiguration or\n             * filter bug to get into this state. */\n        } while (f && f != new->proto_output_filters);\n    }\n    else {\n        /* If this is not a subrequest, clear out all\n         * resource-specific filters. */\n        new->output_filters  = new->proto_output_filters;\n    }\n\n    update_r_in_filters(new->input_filters, r, new);\n    update_r_in_filters(new->output_filters, r, new);\n\n    apr_table_setn(new->subprocess_env, \"REDIRECT_STATUS\",\n                   apr_itoa(r->pool, r->status));\n\n    /* Begin by presuming any module can make its own path_info assumptions,\n     * until some module interjects and changes the value.\n     */\n    new->used_path_info = AP_REQ_DEFAULT_PATH_INFO;\n\n#if APR_HAS_THREADS\n    new->invoke_mtx = r->invoke_mtx;\n#endif\n\n    /*\n     * XXX: hmm.  This is because mod_setenvif and mod_unique_id really need\n     * to do their thing on internal redirects as well.  Perhaps this is a\n     * misnamed function.\n     */\n    if ((access_status = ap_post_read_request(new))) {\n        ap_die(access_status, new);\n        return NULL;\n    }\n\n    return new;\n}"
          },
          "ap_run_quick_handler": {
            "declaration": "AP_DECLARE_HOOK(int,quick_handler,(request_rec *r, int lookup_uri))",
            "is_external": true,
            "definition": null
          },
          "ap_process_request_internal": {
            "declaration": "AP_DECLARE(int) ap_process_request_internal(request_rec *r)",
            "is_external": true,
            "definition": null
          },
          "ap_invoke_handler": {
            "declaration": "AP_CORE_DECLARE(int) ap_invoke_handler(request_rec *r)",
            "is_external": true,
            "definition": null
          },
          "ap_die": {
            "declaration": "AP_DECLARE(void) ap_die(int type, request_rec *r)\n{\n    ap_die_r(type, r, r->status);\n}",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_die(int type, request_rec *r)\n{\n    ap_die_r(type, r, r->status);\n}"
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(void) ap_internal_redirect(const char *new_uri, request_rec *r)\n{\n    int access_status;\n    request_rec *new = internal_internal_redirect(new_uri, r);\n\n    AP_INTERNAL_REDIRECT(r->uri, new_uri);\n\n    /* ap_die was already called, if an error occurred */\n    if (!new) {\n        return;\n    }\n\n    access_status = ap_run_quick_handler(new, 0);  /* Not a look-up request */\n    if (access_status == DECLINED) {\n        access_status = ap_process_request_internal(new);\n        if (access_status == OK) {\n            access_status = ap_invoke_handler(new);\n        }\n    }\n    ap_die(access_status, new);\n}"
    },
    "ap_internal_redirect_handler@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 797, column 18>": {
      "basic_info": {
        "function_id": 1616,
        "name": "ap_internal_redirect_handler",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 797, column 18>",
        "is_definition": true,
        "start_line": 797,
        "end_line": 814,
        "return_type": "void",
        "parameters": [
          {
            "name": "new_uri",
            "type": "const char *"
          },
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "internal_internal_redirect": {
            "declaration": "static request_rec *internal_internal_redirect(const char *new_uri,\n                                               request_rec *r) {\n    int access_status;\n    request_rec *new;\n    const char *vary_header;\n\n    if (ap_is_recursion_limit_exceeded(r)) {\n        ap_die(HTTP_INTERNAL_SERVER_ERROR, r);\n        return NULL;\n    }\n\n    new = (request_rec *) apr_pcalloc(r->pool, sizeof(request_rec));\n\n    new->connection = r->connection;\n    new->server     = r->server;\n    new->pool       = r->pool;\n\n    /*\n     * A whole lot of this really ought to be shared with http_protocol.c...\n     * another missing cleanup.  It's particularly inappropriate to be\n     * setting header_only, etc., here.\n     */\n\n    new->method          = r->method;\n    new->method_number   = r->method_number;\n    new->allowed_methods = ap_make_method_list(new->pool, 2);\n    ap_parse_uri(new, new_uri);\n    new->parsed_uri.port_str = r->parsed_uri.port_str;\n    new->parsed_uri.port = r->parsed_uri.port;\n\n    new->request_config = ap_create_request_config(r->pool);\n\n    new->per_dir_config = r->server->lookup_defaults;\n\n    new->prev = r;\n    r->next   = new;\n\n    new->useragent_addr = r->useragent_addr;\n    new->useragent_ip = r->useragent_ip;\n\n    /* Must have prev and next pointers set before calling create_request\n     * hook.\n     */\n    ap_run_create_request(new);\n\n    /* Inherit the rest of the protocol info... */\n\n    new->the_request = r->the_request;\n\n    new->allowed         = r->allowed;\n\n    new->status          = r->status;\n    new->assbackwards    = r->assbackwards;\n    new->header_only     = r->header_only;\n    new->protocol        = r->protocol;\n    new->proto_num       = r->proto_num;\n    new->hostname        = r->hostname;\n    new->request_time    = r->request_time;\n    new->main            = r->main;\n\n    new->headers_in      = r->headers_in;\n    new->trailers_in     = r->trailers_in;\n    new->headers_out     = apr_table_make(r->pool, 12);\n    if (ap_is_HTTP_REDIRECT(new->status)) {\n        const char *location = apr_table_get(r->headers_out, \"Location\");\n        if (location)\n            apr_table_setn(new->headers_out, \"Location\", location);\n    }\n\n    /* A module (like mod_rewrite) can force an internal redirect\n     * to carry over the Vary header (if present).\n     */\n    if (apr_table_get(r->notes, \"redirect-keeps-vary\")) {\n        if((vary_header = apr_table_get(r->headers_out, \"Vary\"))) {\n            apr_table_setn(new->headers_out, \"Vary\", vary_header);\n        }\n    }\n\n    new->err_headers_out = r->err_headers_out;\n    new->trailers_out    = apr_table_make(r->pool, 5);\n    new->subprocess_env  = rename_original_env(r->pool, r->subprocess_env);\n    new->notes           = apr_table_make(r->pool, 5);\n\n    new->htaccess        = r->htaccess;\n    new->no_cache        = r->no_cache;\n    new->expecting_100   = r->expecting_100;\n    new->no_local_copy   = r->no_local_copy;\n    new->read_length     = r->read_length;     /* We can only read it once */\n    new->vlist_validator = r->vlist_validator;\n\n    new->proto_output_filters  = r->proto_output_filters;\n    new->proto_input_filters   = r->proto_input_filters;\n\n    new->input_filters   = new->proto_input_filters;\n\n    if (new->main) {\n        ap_filter_t *f, *nextf;\n\n        /* If this is a subrequest, the filter chain may contain a\n         * mixture of filters specific to the old request (r), and\n         * some inherited from r->main.  Here, inherit that filter\n         * chain, and remove all those which are specific to the old\n         * request; ensuring the subreq filter is left in place. */\n        new->output_filters = r->output_filters;\n\n        f = new->output_filters;\n        do {\n            nextf = f->next;\n\n            if (f->r == r && f->frec != ap_subreq_core_filter_handle) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01582)\n                              \"dropping filter '%s' in internal redirect from %s to %s\",\n                              f->frec->name, r->unparsed_uri, new_uri);\n\n                /* To remove the filter, first set f->r to the *new*\n                 * request_rec, so that ->output_filters on 'new' is\n                 * changed (if necessary) when removing the filter. */\n                f->r = new;\n                ap_remove_output_filter(f);\n            }\n\n            f = nextf;\n\n            /* Stop at the protocol filters.  If a protocol filter has\n             * been newly installed for this resource, better leave it\n             * in place, though it's probably a misconfiguration or\n             * filter bug to get into this state. */\n        } while (f && f != new->proto_output_filters);\n    }\n    else {\n        /* If this is not a subrequest, clear out all\n         * resource-specific filters. */\n        new->output_filters  = new->proto_output_filters;\n    }\n\n    update_r_in_filters(new->input_filters, r, new);\n    update_r_in_filters(new->output_filters, r, new);\n\n    apr_table_setn(new->subprocess_env, \"REDIRECT_STATUS\",\n                   apr_itoa(r->pool, r->status));\n\n    /* Begin by presuming any module can make its own path_info assumptions,\n     * until some module interjects and changes the value.\n     */\n    new->used_path_info = AP_REQ_DEFAULT_PATH_INFO;\n\n#if APR_HAS_THREADS\n    new->invoke_mtx = r->invoke_mtx;\n#endif\n\n    /*\n     * XXX: hmm.  This is because mod_setenvif and mod_unique_id really need\n     * to do their thing on internal redirects as well.  Perhaps this is a\n     * misnamed function.\n     */\n    if ((access_status = ap_post_read_request(new))) {\n        ap_die(access_status, new);\n        return NULL;\n    }\n\n    return new;\n}",
            "is_external": false,
            "definition": "static request_rec *internal_internal_redirect(const char *new_uri,\n                                               request_rec *r) {\n    int access_status;\n    request_rec *new;\n    const char *vary_header;\n\n    if (ap_is_recursion_limit_exceeded(r)) {\n        ap_die(HTTP_INTERNAL_SERVER_ERROR, r);\n        return NULL;\n    }\n\n    new = (request_rec *) apr_pcalloc(r->pool, sizeof(request_rec));\n\n    new->connection = r->connection;\n    new->server     = r->server;\n    new->pool       = r->pool;\n\n    /*\n     * A whole lot of this really ought to be shared with http_protocol.c...\n     * another missing cleanup.  It's particularly inappropriate to be\n     * setting header_only, etc., here.\n     */\n\n    new->method          = r->method;\n    new->method_number   = r->method_number;\n    new->allowed_methods = ap_make_method_list(new->pool, 2);\n    ap_parse_uri(new, new_uri);\n    new->parsed_uri.port_str = r->parsed_uri.port_str;\n    new->parsed_uri.port = r->parsed_uri.port;\n\n    new->request_config = ap_create_request_config(r->pool);\n\n    new->per_dir_config = r->server->lookup_defaults;\n\n    new->prev = r;\n    r->next   = new;\n\n    new->useragent_addr = r->useragent_addr;\n    new->useragent_ip = r->useragent_ip;\n\n    /* Must have prev and next pointers set before calling create_request\n     * hook.\n     */\n    ap_run_create_request(new);\n\n    /* Inherit the rest of the protocol info... */\n\n    new->the_request = r->the_request;\n\n    new->allowed         = r->allowed;\n\n    new->status          = r->status;\n    new->assbackwards    = r->assbackwards;\n    new->header_only     = r->header_only;\n    new->protocol        = r->protocol;\n    new->proto_num       = r->proto_num;\n    new->hostname        = r->hostname;\n    new->request_time    = r->request_time;\n    new->main            = r->main;\n\n    new->headers_in      = r->headers_in;\n    new->trailers_in     = r->trailers_in;\n    new->headers_out     = apr_table_make(r->pool, 12);\n    if (ap_is_HTTP_REDIRECT(new->status)) {\n        const char *location = apr_table_get(r->headers_out, \"Location\");\n        if (location)\n            apr_table_setn(new->headers_out, \"Location\", location);\n    }\n\n    /* A module (like mod_rewrite) can force an internal redirect\n     * to carry over the Vary header (if present).\n     */\n    if (apr_table_get(r->notes, \"redirect-keeps-vary\")) {\n        if((vary_header = apr_table_get(r->headers_out, \"Vary\"))) {\n            apr_table_setn(new->headers_out, \"Vary\", vary_header);\n        }\n    }\n\n    new->err_headers_out = r->err_headers_out;\n    new->trailers_out    = apr_table_make(r->pool, 5);\n    new->subprocess_env  = rename_original_env(r->pool, r->subprocess_env);\n    new->notes           = apr_table_make(r->pool, 5);\n\n    new->htaccess        = r->htaccess;\n    new->no_cache        = r->no_cache;\n    new->expecting_100   = r->expecting_100;\n    new->no_local_copy   = r->no_local_copy;\n    new->read_length     = r->read_length;     /* We can only read it once */\n    new->vlist_validator = r->vlist_validator;\n\n    new->proto_output_filters  = r->proto_output_filters;\n    new->proto_input_filters   = r->proto_input_filters;\n\n    new->input_filters   = new->proto_input_filters;\n\n    if (new->main) {\n        ap_filter_t *f, *nextf;\n\n        /* If this is a subrequest, the filter chain may contain a\n         * mixture of filters specific to the old request (r), and\n         * some inherited from r->main.  Here, inherit that filter\n         * chain, and remove all those which are specific to the old\n         * request; ensuring the subreq filter is left in place. */\n        new->output_filters = r->output_filters;\n\n        f = new->output_filters;\n        do {\n            nextf = f->next;\n\n            if (f->r == r && f->frec != ap_subreq_core_filter_handle) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01582)\n                              \"dropping filter '%s' in internal redirect from %s to %s\",\n                              f->frec->name, r->unparsed_uri, new_uri);\n\n                /* To remove the filter, first set f->r to the *new*\n                 * request_rec, so that ->output_filters on 'new' is\n                 * changed (if necessary) when removing the filter. */\n                f->r = new;\n                ap_remove_output_filter(f);\n            }\n\n            f = nextf;\n\n            /* Stop at the protocol filters.  If a protocol filter has\n             * been newly installed for this resource, better leave it\n             * in place, though it's probably a misconfiguration or\n             * filter bug to get into this state. */\n        } while (f && f != new->proto_output_filters);\n    }\n    else {\n        /* If this is not a subrequest, clear out all\n         * resource-specific filters. */\n        new->output_filters  = new->proto_output_filters;\n    }\n\n    update_r_in_filters(new->input_filters, r, new);\n    update_r_in_filters(new->output_filters, r, new);\n\n    apr_table_setn(new->subprocess_env, \"REDIRECT_STATUS\",\n                   apr_itoa(r->pool, r->status));\n\n    /* Begin by presuming any module can make its own path_info assumptions,\n     * until some module interjects and changes the value.\n     */\n    new->used_path_info = AP_REQ_DEFAULT_PATH_INFO;\n\n#if APR_HAS_THREADS\n    new->invoke_mtx = r->invoke_mtx;\n#endif\n\n    /*\n     * XXX: hmm.  This is because mod_setenvif and mod_unique_id really need\n     * to do their thing on internal redirects as well.  Perhaps this is a\n     * misnamed function.\n     */\n    if ((access_status = ap_post_read_request(new))) {\n        ap_die(access_status, new);\n        return NULL;\n    }\n\n    return new;\n}"
          },
          "ap_set_content_type_ex": {
            "declaration": "AP_DECLARE(void) ap_set_content_type_ex(request_rec *r, const char *ct, int trusted)",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_set_content_type_ex(request_rec *r, const char *ct, int trusted)\n{\n    ap_set_content_type(r, ct);\n    AP_REQUEST_SET_BNOTE(r, AP_REQUEST_TRUSTED_CT, trusted ? AP_REQUEST_TRUSTED_CT : 0);\n}"
          },
          "ap_process_request_internal": {
            "declaration": "AP_DECLARE(int) ap_process_request_internal(request_rec *r)",
            "is_external": true,
            "definition": null
          },
          "ap_invoke_handler": {
            "declaration": "AP_CORE_DECLARE(int) ap_invoke_handler(request_rec *r)",
            "is_external": true,
            "definition": null
          },
          "ap_die": {
            "declaration": "AP_DECLARE(void) ap_die(int type, request_rec *r)\n{\n    ap_die_r(type, r, r->status);\n}",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_die(int type, request_rec *r)\n{\n    ap_die_r(type, r, r->status);\n}"
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(void) ap_internal_redirect_handler(const char *new_uri, request_rec *r)\n{\n    int access_status;\n    request_rec *new = internal_internal_redirect(new_uri, r);\n\n    /* ap_die was already called, if an error occurred */\n    if (!new) {\n        return;\n    }\n\n    if (r->handler)\n        ap_set_content_type_ex(new, r->content_type, AP_REQUEST_IS_TRUSTED_CT(r));\n    access_status = ap_process_request_internal(new);\n    if (access_status == OK) {\n        access_status = ap_invoke_handler(new);\n    }\n    ap_die(access_status, new);\n}"
    },
    "ap_allow_methods@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 816, column 18>": {
      "basic_info": {
        "function_id": 1617,
        "name": "ap_allow_methods",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 816, column 18>",
        "is_definition": true,
        "start_line": 816,
        "end_line": 834,
        "return_type": "void",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "reset",
            "type": "int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_clear_method_list": {
            "declaration": "AP_DECLARE(void) ap_clear_method_list(ap_method_list_t *l)",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_clear_method_list(ap_method_list_t *l)\n{\n    l->method_mask = 0;\n    l->method_list->nelts = 0;\n}"
          },
          "__builtin_va_start": {
            "declaration": "va_start(methods, reset)",
            "is_external": true,
            "definition": null
          },
          "ap_method_list_add": {
            "declaration": "AP_DECLARE(void) ap_method_list_add(ap_method_list_t *l, const char *method)",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_method_list_add(ap_method_list_t *l, const char *method)\n{\n    int methnum;\n    const char **xmethod;\n\n    /*\n     * If it's one of our known methods, use the shortcut and use the\n     * bitmask.\n     */\n    methnum = ap_method_number_of(method);\n    if (methnum != M_INVALID) {\n        l->method_mask |= (AP_METHOD_BIT << methnum);\n        return;\n    }\n    /*\n     * Otherwise, see if the method name is in the array of string names.\n     */\n    if (ap_array_str_contains(l->method_list, method)) {\n        return;\n    }\n\n    xmethod = (const char **) apr_array_push(l->method_list);\n    *xmethod = method;\n}"
          },
          "__builtin_va_end": {
            "declaration": "va_end(methods)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "va_list"
        ]
      },
      "source_code": "AP_DECLARE(void) ap_allow_methods(request_rec *r, int reset, ...)\n{\n    const char *method;\n    va_list methods;\n\n    /*\n     * Get rid of any current settings if requested; not just the\n     * well-known methods but any extensions as well.\n     */\n    if (reset) {\n        ap_clear_method_list(r->allowed_methods);\n    }\n\n    va_start(methods, reset);\n    while ((method = va_arg(methods, const char *)) != NULL) {\n        ap_method_list_add(r->allowed_methods, method);\n    }\n    va_end(methods);\n}"
    },
    "ap_allow_standard_methods@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 836, column 18>": {
      "basic_info": {
        "function_id": 1618,
        "name": "ap_allow_standard_methods",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_request.c', line 836, column 18>",
        "is_definition": true,
        "start_line": 836,
        "end_line": 858,
        "return_type": "void",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "reset",
            "type": "int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_clear_method_list": {
            "declaration": "AP_DECLARE(void) ap_clear_method_list(ap_method_list_t *l)",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_clear_method_list(ap_method_list_t *l)\n{\n    l->method_mask = 0;\n    l->method_list->nelts = 0;\n}"
          },
          "__builtin_va_start": {
            "declaration": "va_start(methods, reset)",
            "is_external": true,
            "definition": null
          },
          "__builtin_va_end": {
            "declaration": "va_end(methods)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "va_list"
        ]
      },
      "source_code": "AP_DECLARE(void) ap_allow_standard_methods(request_rec *r, int reset, ...)\n{\n    int method;\n    va_list methods;\n    ap_method_mask_t mask;\n\n    /*\n     * Get rid of any current settings if requested; not just the\n     * well-known methods but any extensions as well.\n     */\n    if (reset) {\n        ap_clear_method_list(r->allowed_methods);\n    }\n\n    mask = 0;\n    va_start(methods, reset);\n    while ((method = va_arg(methods, int)) != -1) {\n        mask |= (AP_METHOD_BIT << method);\n    }\n    va_end(methods);\n\n    r->allowed_methods->method_mask |= mask;\n}"
    },
    "set_keep_alive_timeout@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 55, column 20>": {
      "basic_info": {
        "function_id": 1619,
        "name": "set_keep_alive_timeout",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 55, column 20>",
        "is_definition": true,
        "start_line": 55,
        "end_line": 80,
        "return_type": "const char *",
        "parameters": [
          {
            "name": "cmd",
            "type": "cmd_parms *"
          },
          {
            "name": "dummy",
            "type": "void *"
          },
          {
            "name": "arg",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_check_cmd_context": {
            "declaration": "AP_DECLARE(const char *) ap_check_cmd_context(cmd_parms *cmd,\n                                              unsigned forbidden)",
            "is_external": true,
            "definition": null
          },
          "ap_timeout_parameter_parse": {
            "declaration": "AP_DECLARE(apr_status_t) ap_timeout_parameter_parse(\n                                               const char *timeout_parameter,\n                                               apr_interval_time_t *timeout,\n                                               const char *default_time_unit)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {},
        "used_globals": {},
        "used_typedefs": [
          "apr_interval_time_t",
          "cmd_parms"
        ]
      },
      "source_code": "static const char *set_keep_alive_timeout(cmd_parms *cmd, void *dummy,\n                                          const char *arg)\n{\n    apr_interval_time_t timeout;\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_CONTEXT);\n    if (err != NULL) {\n        return err;\n    }\n\n    /* Stolen from mod_proxy.c */\n    if (ap_timeout_parameter_parse(arg, &timeout, \"s\") != APR_SUCCESS)\n        return \"KeepAliveTimeout has wrong format\";\n    cmd->server->keep_alive_timeout = timeout;\n\n    /* We don't want to take into account whether or not KeepAliveTimeout is\n     * set for the main server, because if no http_module directive is used\n     * for a vhost, it will inherit the http_srv_cfg from the main server.\n     * However keep_alive_timeout_set helps determine whether the vhost should\n     * use its own configured timeout or the one from the vhost declared first\n     * on the same IP:port (ie. c->base_server, and the legacy behaviour).\n     */\n    if (cmd->server->is_virtual) {\n        cmd->server->keep_alive_timeout_set = 1;\n    }\n    return NULL;\n}"
    },
    "set_keep_alive@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 82, column 20>": {
      "basic_info": {
        "function_id": 1620,
        "name": "set_keep_alive",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 82, column 20>",
        "is_definition": true,
        "start_line": 82,
        "end_line": 92,
        "return_type": "const char *",
        "parameters": [
          {
            "name": "cmd",
            "type": "cmd_parms *"
          },
          {
            "name": "dummy",
            "type": "void *"
          },
          {
            "name": "arg",
            "type": "int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_check_cmd_context": {
            "declaration": "AP_DECLARE(const char *) ap_check_cmd_context(cmd_parms *cmd,\n                                              unsigned forbidden)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {},
        "used_globals": {},
        "used_typedefs": [
          "cmd_parms"
        ]
      },
      "source_code": "static const char *set_keep_alive(cmd_parms *cmd, void *dummy,\n                                  int arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_CONTEXT);\n    if (err != NULL) {\n        return err;\n    }\n\n    cmd->server->keep_alive = arg;\n    return NULL;\n}"
    },
    "set_keep_alive_max@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 94, column 20>": {
      "basic_info": {
        "function_id": 1621,
        "name": "set_keep_alive_max",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 94, column 20>",
        "is_definition": true,
        "start_line": 94,
        "end_line": 104,
        "return_type": "const char *",
        "parameters": [
          {
            "name": "cmd",
            "type": "cmd_parms *"
          },
          {
            "name": "dummy",
            "type": "void *"
          },
          {
            "name": "arg",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_check_cmd_context": {
            "declaration": "AP_DECLARE(const char *) ap_check_cmd_context(cmd_parms *cmd,\n                                              unsigned forbidden)",
            "is_external": true,
            "definition": null
          },
          "atoi": {
            "declaration": "extern int atoi (const char *__nptr)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {},
        "used_globals": {},
        "used_typedefs": [
          "cmd_parms"
        ]
      },
      "source_code": "static const char *set_keep_alive_max(cmd_parms *cmd, void *dummy,\n                                      const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_CONTEXT);\n    if (err != NULL) {\n        return err;\n    }\n\n    cmd->server->keep_alive_max = atoi(arg);\n    return NULL;\n}"
    },
    "http_scheme@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 117, column 20>": {
      "basic_info": {
        "function_id": 1622,
        "name": "http_scheme",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 117, column 20>",
        "is_definition": true,
        "start_line": 117,
        "end_line": 128,
        "return_type": "const char *",
        "parameters": [
          {
            "name": "r",
            "type": "const request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "strcmp": {
            "declaration": "extern int strcmp (const char *__s1, const char *__s2)\n     __THROW __attribute_pure__ __nonnull ((1, 2))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static const char *http_scheme(const request_rec *r)\n{\n    /*\n     * The http module shouldn't return anything other than\n     * \"http\" (the default) or \"https\".\n     */\n    if (r->server->server_scheme &&\n        (strcmp(r->server->server_scheme, \"https\") == 0))\n        return \"https\";\n\n    return \"http\";\n}"
    },
    "http_port@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 130, column 19>": {
      "basic_info": {
        "function_id": 1623,
        "name": "http_port",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 130, column 19>",
        "is_definition": true,
        "start_line": 130,
        "end_line": 137,
        "return_type": "apr_port_t",
        "parameters": [
          {
            "name": "r",
            "type": "const request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "strcmp": {
            "declaration": "extern int strcmp (const char *__s1, const char *__s2)\n     __THROW __attribute_pure__ __nonnull ((1, 2))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "apr_port_t"
        ]
      },
      "source_code": "static apr_port_t http_port(const request_rec *r)\n{\n    if (r->server->server_scheme &&\n        (strcmp(r->server->server_scheme, \"https\") == 0))\n        return DEFAULT_HTTPS_PORT;\n\n    return DEFAULT_HTTP_PORT;\n}"
    },
    "ap_process_http_async_connection@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 139, column 12>": {
      "basic_info": {
        "function_id": 1624,
        "name": "ap_process_http_async_connection",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 139, column 12>",
        "is_definition": true,
        "start_line": 139,
        "end_line": 182,
        "return_type": "int",
        "parameters": [
          {
            "name": "c",
            "type": "conn_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_update_child_status_from_conn": {
            "declaration": "AP_DECLARE(int) ap_update_child_status_from_conn(ap_sb_handle_t *sbh, int status, conn_rec *c)",
            "is_external": true,
            "definition": null
          },
          "ap_set_conn_count": {
            "declaration": "AP_DECLARE(void) ap_set_conn_count(ap_sb_handle_t *sb, request_rec *r, unsigned short conn_count)",
            "is_external": true,
            "definition": null
          },
          "ap_read_request": {
            "declaration": "request_rec *ap_read_request(conn_rec *c)",
            "is_external": true,
            "definition": null
          },
          "ap_update_child_status": {
            "declaration": "AP_DECLARE(int) ap_update_child_status(ap_sb_handle_t *sbh, int status, request_rec *r)",
            "is_external": true,
            "definition": null
          },
          "ap_process_async_request": {
            "declaration": "void ap_process_async_request(request_rec *r)",
            "is_external": false,
            "definition": "void ap_process_async_request(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    int access_status;\n\n    /* Give quick handlers a shot at serving the request on the fast\n     * path, bypassing all of the other Apache hooks.\n     *\n     * This hook was added to enable serving files out of a URI keyed\n     * content cache ( e.g., Mike Abbott's Quick Shortcut Cache,\n     * described here: http://oss.sgi.com/projects/apache/mod_qsc.html )\n     *\n     * It may have other uses as well, such as routing requests directly to\n     * content handlers that have the ability to grok HTTP and do their\n     * own access checking, etc (e.g. servlet engines).\n     *\n     * Use this hook with extreme care and only if you know what you are\n     * doing.\n     */\n    AP_PROCESS_REQUEST_ENTRY((uintptr_t)r, r->uri);\n    if (ap_extended_status) {\n        ap_time_process_request(r->connection->sbh, START_PREQUEST);\n    }\n\n    if (APLOGrtrace4(r)) {\n        int i;\n        const apr_array_header_t *t_h = apr_table_elts(r->headers_in);\n        const apr_table_entry_t *t_elt = (apr_table_entry_t *)t_h->elts;\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                      \"Headers received from client:\");\n        for (i = 0; i < t_h->nelts; i++, t_elt++) {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r, \"  %s: %s\",\n                          ap_escape_logitem(r->pool, t_elt->key),\n                          ap_escape_logitem(r->pool, t_elt->val));\n        }\n    }\n\n#if APR_HAS_THREADS\n    apr_thread_mutex_create(&r->invoke_mtx, APR_THREAD_MUTEX_DEFAULT, r->pool);\n    apr_thread_mutex_lock(r->invoke_mtx);\n#endif\n    access_status = ap_run_quick_handler(r, 0);  /* Not a look-up request */\n    if (access_status == DECLINED) {\n        access_status = ap_process_request_internal(r);\n        if (access_status == OK) {\n            access_status = ap_invoke_handler(r);\n        }\n    }\n\n    if (access_status == SUSPENDED) {\n        /* TODO: Should move these steps into a generic function, so modules\n         * working on a suspended request can also call _ENTRY again.\n         */\n        AP_PROCESS_REQUEST_RETURN((uintptr_t)r, r->uri, access_status);\n        if (ap_extended_status) {\n            ap_time_process_request(c->sbh, STOP_PREQUEST);\n        }\n        if (c->cs)\n            c->cs->state = CONN_STATE_SUSPENDED;\n#if APR_HAS_THREADS\n        apr_thread_mutex_unlock(r->invoke_mtx);\n#endif\n        return;\n    }\n#if APR_HAS_THREADS\n    apr_thread_mutex_unlock(r->invoke_mtx);\n#endif\n\n    ap_die_r(access_status, r, HTTP_OK);\n\n    ap_process_request_after_handler(r);\n}"
          }
        },
        "callers": {
          "ap_process_http_connection@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 247, column 12>": {
            "source_code": "static int ap_process_http_connection(conn_rec *c)\n{\n    if (async_mpm && !c->clogging_input_filters) {\n        return ap_process_http_async_connection(c);\n    }\n    else {\n        return ap_process_http_sync_connection(c);\n    }\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 247, column 12>"
          }
        },
        "used_macros": {
          "CONN_STATE_HANDLER": {
            "name": "CONN_STATE_HANDLER",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum conn_state_e CONN_STATE_HANDLER = 2",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1261, column 5>",
            "condition": ""
          },
          "CONN_STATE_WRITE_COMPLETION": {
            "name": "CONN_STATE_WRITE_COMPLETION",
            "value": "3",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum conn_state_e CONN_STATE_WRITE_COMPLETION = 3",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1262, column 5>",
            "condition": ""
          },
          "CONN_STATE_SUSPENDED": {
            "name": "CONN_STATE_SUSPENDED",
            "value": "4",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum conn_state_e CONN_STATE_SUSPENDED = 4",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1263, column 5>",
            "condition": ""
          },
          "CONN_STATE_LINGER": {
            "name": "CONN_STATE_LINGER",
            "value": "5",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum conn_state_e CONN_STATE_LINGER = 5",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1264, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "conn_rec": {
            "name": "conn_rec",
            "definition": "struct conn_rec {\n    /** Pool associated with this connection */\n    apr_pool_t *pool;\n    /** Physical vhost this conn came in on */\n    server_rec *base_server;\n    /** used by http_vhost.c */\n    void *vhost_lookup_data;\n\n    /* Information about the connection itself */\n    /** local address */\n    apr_sockaddr_t *local_addr;\n    /** remote address; this is the end-point of the next hop, for the address\n     *  of the request creator, see useragent_addr in request_rec\n     */\n    apr_sockaddr_t *client_addr;\n\n    /** Client's IP address; this is the end-point of the next hop, for the\n     *  IP of the request creator, see useragent_ip in request_rec\n     */\n    char *client_ip;\n    /** Client's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     * get_remote_host() */\n    char *remote_host;\n    /** Only ever set if doing rfc1413 lookups.  N.B. Only access this through\n     *  get_remote_logname() */\n    char *remote_logname;\n\n    /** server IP address */\n    char *local_ip;\n    /** used for ap_get_server_name when UseCanonicalName is set to DNS\n     *  (ignores setting of HostnameLookups) */\n    char *local_host;\n\n    /** ID of this connection; unique at any point in time */\n    long id;\n    /** Config vector containing pointers to connections per-server\n     *  config structures. */\n    struct ap_conf_vector_t *conn_config;\n    /** Notes on *this* connection: send note from one module to\n     *  another. must remain valid for all requests on this conn */\n    apr_table_t *notes;\n    /** A list of input filters to be used for this connection */\n    struct ap_filter_t *input_filters;\n    /** A list of output filters to be used for this connection */\n    struct ap_filter_t *output_filters;\n    /** handle to scoreboard information for this connection */\n    void *sbh;\n    /** The bucket allocator to use for all bucket/brigade creations */\n    struct apr_bucket_alloc_t *bucket_alloc;\n    /** The current state of this connection; may be NULL if not used by MPM */\n    conn_state_t *cs;\n    /** Is there data pending in the input filters? */\n    int data_in_input_filters;\n    /** Is there data pending in the output filters? */\n    int data_in_output_filters;\n\n    /** Are there any filters that clogg/buffer the input stream, breaking\n     *  the event mpm.\n     */\n    unsigned int clogging_input_filters:1;\n\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success */\n    signed int double_reverse:2;\n\n    /** Are we still talking? */\n    unsigned aborted;\n\n    /** Are we going to keep the connection alive for another request?\n     * @see ap_conn_keepalive_e */\n    ap_conn_keepalive_e keepalive;\n\n    /** How many times have we used it? */\n    int keepalives;\n\n    /** Optional connection log level configuration. May point to a server or\n     *  per_dir config, i.e. must be copied before modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify this connection in error log. Set when the first\n     *  error log entry for this connection is generated.\n     */\n    const char *log_id;\n\n\n    /** This points to the current thread being used to process this request,\n     * over the lifetime of a request, the value may change. Users of the connection\n     * record should not rely upon it staying the same between calls that involve\n     * the MPM.\n     */\n#if APR_HAS_THREADS\n    apr_thread_t *current_thread;\n#endif\n\n    /** The \"real\" master connection. NULL if I am the master. */\n    conn_rec *master;\n\n    int outgoing;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "base_server": "server_rec *",
              "vhost_lookup_data": "void *",
              "local_addr": "apr_sockaddr_t *",
              "client_addr": "apr_sockaddr_t *",
              "client_ip": "char *",
              "remote_host": "char *",
              "remote_logname": "char *",
              "local_ip": "char *",
              "local_host": "char *",
              "id": "long",
              "conn_config": "struct ap_conf_vector_t *",
              "notes": "apr_table_t *",
              "input_filters": "struct ap_filter_t *",
              "output_filters": "struct ap_filter_t *",
              "sbh": "void *",
              "bucket_alloc": "struct apr_bucket_alloc_t *",
              "cs": "conn_state_t *",
              "data_in_input_filters": "int",
              "data_in_output_filters": "int",
              "clogging_input_filters": "unsigned int",
              "double_reverse": "int",
              "aborted": "unsigned int",
              "keepalive": "ap_conn_keepalive_e",
              "keepalives": "int",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "current_thread": "apr_thread_t *",
              "master": "conn_rec *",
              "outgoing": "int"
            },
            "condition": ""
          },
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "conn_state_t": {
            "name": "conn_state_t",
            "definition": "struct conn_state_t {\n    /** Current state of the connection */\n    conn_state_e state;\n    /** Whether to read instead of write, or write instead of read */\n    conn_sense_e sense;\n}",
            "typedef_name": null,
            "fields": {
              "state": "conn_state_e",
              "sense": "conn_sense_e"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "ap_extended_status": {
            "name": "ap_extended_status",
            "type": "int",
            "is_extern": true,
            "is_static": false,
            "definition": "extern int ap_extended_status",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "static int ap_process_http_async_connection(conn_rec *c)\n{\n    request_rec *r = NULL;\n    conn_state_t *cs = c->cs;\n\n    AP_DEBUG_ASSERT(cs != NULL);\n    AP_DEBUG_ASSERT(cs->state == CONN_STATE_PROCESSING);\n\n    if (cs->state == CONN_STATE_PROCESSING) {\n        ap_update_child_status_from_conn(c->sbh, SERVER_BUSY_READ, c);\n        if (ap_extended_status) {\n            ap_set_conn_count(c->sbh, r, c->keepalives);\n        }\n        if ((r = ap_read_request(c))) {\n            if (r->status == HTTP_OK) {\n                cs->state = CONN_STATE_HANDLER;\n                if (ap_extended_status) {\n                    ap_set_conn_count(c->sbh, r, c->keepalives + 1);\n                }\n                ap_update_child_status(c->sbh, SERVER_BUSY_WRITE, r);\n                ap_process_async_request(r);\n                /* After the call to ap_process_request, the\n                 * request pool may have been deleted.  We set\n                 * r=NULL here to ensure that any dereference\n                 * of r that might be added later in this function\n                 * will result in a segfault immediately instead\n                 * of nondeterministic failures later.\n                 */\n                r = NULL;\n            }\n\n            if (cs->state != CONN_STATE_WRITE_COMPLETION &&\n                cs->state != CONN_STATE_SUSPENDED) {\n                /* Something went wrong; close the connection */\n                cs->state = CONN_STATE_LINGER;\n            }\n        }\n        else {   /* ap_read_request failed - client may have closed */\n            cs->state = CONN_STATE_LINGER;\n        }\n    }\n\n    return OK;\n}"
    },
    "ap_process_http_sync_connection@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 184, column 12>": {
      "basic_info": {
        "function_id": 1625,
        "name": "ap_process_http_sync_connection",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 184, column 12>",
        "is_definition": true,
        "start_line": 184,
        "end_line": 245,
        "return_type": "int",
        "parameters": [
          {
            "name": "c",
            "type": "conn_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_update_child_status_from_conn": {
            "declaration": "AP_DECLARE(int) ap_update_child_status_from_conn(ap_sb_handle_t *sbh, int status, conn_rec *c)",
            "is_external": true,
            "definition": null
          },
          "ap_read_request": {
            "declaration": "request_rec *ap_read_request(conn_rec *c)",
            "is_external": true,
            "definition": null
          },
          "ap_update_child_status": {
            "declaration": "AP_DECLARE(int) ap_update_child_status(ap_sb_handle_t *sbh, int status, request_rec *r)",
            "is_external": true,
            "definition": null
          },
          "ap_process_request": {
            "declaration": "AP_DECLARE(void) ap_process_request(request_rec *r)",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_process_request(request_rec *r)\n{\n    apr_bucket_brigade *bb;\n    apr_bucket *b;\n    conn_rec *c = r->connection;\n    apr_status_t rv;\n\n    ap_process_async_request(r);\n\n    if (ap_run_input_pending(c) != OK) {\n        bb = ap_acquire_brigade(c);\n        b = apr_bucket_flush_create(c->bucket_alloc);\n        APR_BRIGADE_INSERT_HEAD(bb, b);\n        rv = ap_pass_brigade(c->output_filters, bb);\n        if (APR_STATUS_IS_TIMEUP(rv)) {\n            /*\n             * Notice a timeout as an error message. This might be\n             * valuable for detecting clients with broken network\n             * connections or possible DoS attacks.\n             */\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, rv, c, APLOGNO(01581)\n                          \"flushing data to the client\");\n        }\n        ap_release_brigade(c, bb);\n    }\n    if (ap_extended_status) {\n        ap_time_process_request(c->sbh, STOP_PREQUEST);\n    }\n}"
          },
          "ap_mpm_query": {
            "declaration": "AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)",
            "is_external": true,
            "definition": null
          },
          "ap_get_conn_socket": {
            "declaration": "AP_DECLARE(apr_socket_t *) ap_get_conn_socket(conn_rec *c)",
            "is_external": true,
            "definition": null
          },
          "apr_socket_opt_set": {
            "declaration": "APR_DECLARE(apr_status_t) apr_socket_opt_set(apr_socket_t *sock,\n                                             apr_int32_t opt, apr_int32_t on)",
            "is_external": true,
            "definition": null
          },
          "apr_socket_timeout_set": {
            "declaration": "APR_DECLARE(apr_status_t) apr_socket_timeout_set(apr_socket_t *sock,\n                                                 apr_interval_time_t t)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_process_http_connection@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 247, column 12>": {
            "source_code": "static int ap_process_http_connection(conn_rec *c)\n{\n    if (async_mpm && !c->clogging_input_filters) {\n        return ap_process_http_async_connection(c);\n    }\n    else {\n        return ap_process_http_sync_connection(c);\n    }\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 247, column 12>"
          }
        },
        "used_macros": {
          "CONN_STATE_HANDLER": {
            "name": "CONN_STATE_HANDLER",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum conn_state_e CONN_STATE_HANDLER = 2",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1261, column 5>",
            "condition": ""
          },
          "AP_CONN_KEEPALIVE": {
            "name": "AP_CONN_KEEPALIVE",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_conn_keepalive_e AP_CONN_KEEPALIVE = 2",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1146, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "conn_rec": {
            "name": "conn_rec",
            "definition": "struct conn_rec {\n    /** Pool associated with this connection */\n    apr_pool_t *pool;\n    /** Physical vhost this conn came in on */\n    server_rec *base_server;\n    /** used by http_vhost.c */\n    void *vhost_lookup_data;\n\n    /* Information about the connection itself */\n    /** local address */\n    apr_sockaddr_t *local_addr;\n    /** remote address; this is the end-point of the next hop, for the address\n     *  of the request creator, see useragent_addr in request_rec\n     */\n    apr_sockaddr_t *client_addr;\n\n    /** Client's IP address; this is the end-point of the next hop, for the\n     *  IP of the request creator, see useragent_ip in request_rec\n     */\n    char *client_ip;\n    /** Client's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     * get_remote_host() */\n    char *remote_host;\n    /** Only ever set if doing rfc1413 lookups.  N.B. Only access this through\n     *  get_remote_logname() */\n    char *remote_logname;\n\n    /** server IP address */\n    char *local_ip;\n    /** used for ap_get_server_name when UseCanonicalName is set to DNS\n     *  (ignores setting of HostnameLookups) */\n    char *local_host;\n\n    /** ID of this connection; unique at any point in time */\n    long id;\n    /** Config vector containing pointers to connections per-server\n     *  config structures. */\n    struct ap_conf_vector_t *conn_config;\n    /** Notes on *this* connection: send note from one module to\n     *  another. must remain valid for all requests on this conn */\n    apr_table_t *notes;\n    /** A list of input filters to be used for this connection */\n    struct ap_filter_t *input_filters;\n    /** A list of output filters to be used for this connection */\n    struct ap_filter_t *output_filters;\n    /** handle to scoreboard information for this connection */\n    void *sbh;\n    /** The bucket allocator to use for all bucket/brigade creations */\n    struct apr_bucket_alloc_t *bucket_alloc;\n    /** The current state of this connection; may be NULL if not used by MPM */\n    conn_state_t *cs;\n    /** Is there data pending in the input filters? */\n    int data_in_input_filters;\n    /** Is there data pending in the output filters? */\n    int data_in_output_filters;\n\n    /** Are there any filters that clogg/buffer the input stream, breaking\n     *  the event mpm.\n     */\n    unsigned int clogging_input_filters:1;\n\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success */\n    signed int double_reverse:2;\n\n    /** Are we still talking? */\n    unsigned aborted;\n\n    /** Are we going to keep the connection alive for another request?\n     * @see ap_conn_keepalive_e */\n    ap_conn_keepalive_e keepalive;\n\n    /** How many times have we used it? */\n    int keepalives;\n\n    /** Optional connection log level configuration. May point to a server or\n     *  per_dir config, i.e. must be copied before modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify this connection in error log. Set when the first\n     *  error log entry for this connection is generated.\n     */\n    const char *log_id;\n\n\n    /** This points to the current thread being used to process this request,\n     * over the lifetime of a request, the value may change. Users of the connection\n     * record should not rely upon it staying the same between calls that involve\n     * the MPM.\n     */\n#if APR_HAS_THREADS\n    apr_thread_t *current_thread;\n#endif\n\n    /** The \"real\" master connection. NULL if I am the master. */\n    conn_rec *master;\n\n    int outgoing;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "base_server": "server_rec *",
              "vhost_lookup_data": "void *",
              "local_addr": "apr_sockaddr_t *",
              "client_addr": "apr_sockaddr_t *",
              "client_ip": "char *",
              "remote_host": "char *",
              "remote_logname": "char *",
              "local_ip": "char *",
              "local_host": "char *",
              "id": "long",
              "conn_config": "struct ap_conf_vector_t *",
              "notes": "apr_table_t *",
              "input_filters": "struct ap_filter_t *",
              "output_filters": "struct ap_filter_t *",
              "sbh": "void *",
              "bucket_alloc": "struct apr_bucket_alloc_t *",
              "cs": "conn_state_t *",
              "data_in_input_filters": "int",
              "data_in_output_filters": "int",
              "clogging_input_filters": "unsigned int",
              "double_reverse": "int",
              "aborted": "unsigned int",
              "keepalive": "ap_conn_keepalive_e",
              "keepalives": "int",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "current_thread": "apr_thread_t *",
              "master": "conn_rec *",
              "outgoing": "int"
            },
            "condition": ""
          },
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "conn_state_t": {
            "name": "conn_state_t",
            "definition": "struct conn_state_t {\n    /** Current state of the connection */\n    conn_state_e state;\n    /** Whether to read instead of write, or write instead of read */\n    conn_sense_e sense;\n}",
            "typedef_name": null,
            "fields": {
              "state": "conn_state_e",
              "sense": "conn_sense_e"
            },
            "condition": ""
          },
          "apr_socket_t": {
            "name": "apr_socket_t",
            "definition": "struct apr_socket_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "apr_interval_time_t"
        ]
      },
      "source_code": "static int ap_process_http_sync_connection(conn_rec *c)\n{\n    request_rec *r;\n    conn_state_t *cs = c->cs;\n    apr_socket_t *csd = NULL;\n    int mpm_state = 0;\n\n    /*\n     * Read and process each request found on our connection\n     * until no requests are left or we decide to close.\n     */\n\n    ap_update_child_status_from_conn(c->sbh, SERVER_BUSY_READ, c);\n    while ((r = ap_read_request(c)) != NULL) {\n        apr_interval_time_t keep_alive_timeout = r->server->keep_alive_timeout;\n\n        /* To preserve legacy behaviour, use the keepalive timeout from the\n         * base server (first on this IP:port) when none is explicitly\n         * configured on this server.\n         */\n        if (!r->server->keep_alive_timeout_set) {\n            keep_alive_timeout = c->base_server->keep_alive_timeout;\n        }\n\n        if (r->status == HTTP_OK) {\n            if (cs)\n                cs->state = CONN_STATE_HANDLER;\n            ap_update_child_status(c->sbh, SERVER_BUSY_WRITE, r);\n            ap_process_request(r);\n            /* After the call to ap_process_request, the\n             * request pool will have been deleted.  We set\n             * r=NULL here to ensure that any dereference\n             * of r that might be added later in this function\n             * will result in a segfault immediately instead\n             * of nondeterministic failures later.\n             */\n            r = NULL;\n        }\n\n        if (c->keepalive != AP_CONN_KEEPALIVE || c->aborted)\n            break;\n\n        ap_update_child_status(c->sbh, SERVER_BUSY_KEEPALIVE, NULL);\n\n        if (ap_mpm_query(AP_MPMQ_MPM_STATE, &mpm_state)) {\n            break;\n        }\n\n        if (mpm_state == AP_MPMQ_STOPPING) {\n          break;\n        }\n\n        if (!csd) {\n            csd = ap_get_conn_socket(c);\n        }\n        apr_socket_opt_set(csd, APR_INCOMPLETE_READ, 1);\n        apr_socket_timeout_set(csd, keep_alive_timeout);\n        /* Go straight to select() to wait for the next request */\n    }\n\n    return OK;\n}"
    },
    "ap_process_http_connection@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 247, column 12>": {
      "basic_info": {
        "function_id": 1626,
        "name": "ap_process_http_connection",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 247, column 12>",
        "is_definition": true,
        "start_line": 247,
        "end_line": 255,
        "return_type": "int",
        "parameters": [
          {
            "name": "c",
            "type": "conn_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_process_http_async_connection": {
            "declaration": "static int ap_process_http_async_connection(conn_rec *c)\n{\n    request_rec *r = NULL;\n    conn_state_t *cs = c->cs;\n\n    AP_DEBUG_ASSERT(cs != NULL);\n    AP_DEBUG_ASSERT(cs->state == CONN_STATE_PROCESSING);\n\n    if (cs->state == CONN_STATE_PROCESSING) {\n        ap_update_child_status_from_conn(c->sbh, SERVER_BUSY_READ, c);\n        if (ap_extended_status) {\n            ap_set_conn_count(c->sbh, r, c->keepalives);\n        }\n        if ((r = ap_read_request(c))) {\n            if (r->status == HTTP_OK) {\n                cs->state = CONN_STATE_HANDLER;\n                if (ap_extended_status) {\n                    ap_set_conn_count(c->sbh, r, c->keepalives + 1);\n                }\n                ap_update_child_status(c->sbh, SERVER_BUSY_WRITE, r);\n                ap_process_async_request(r);\n                /* After the call to ap_process_request, the\n                 * request pool may have been deleted.  We set\n                 * r=NULL here to ensure that any dereference\n                 * of r that might be added later in this function\n                 * will result in a segfault immediately instead\n                 * of nondeterministic failures later.\n                 */\n                r = NULL;\n            }\n\n            if (cs->state != CONN_STATE_WRITE_COMPLETION &&\n                cs->state != CONN_STATE_SUSPENDED) {\n                /* Something went wrong; close the connection */\n                cs->state = CONN_STATE_LINGER;\n            }\n        }\n        else {   /* ap_read_request failed - client may have closed */\n            cs->state = CONN_STATE_LINGER;\n        }\n    }\n\n    return OK;\n}",
            "is_external": false,
            "definition": "static int ap_process_http_async_connection(conn_rec *c)\n{\n    request_rec *r = NULL;\n    conn_state_t *cs = c->cs;\n\n    AP_DEBUG_ASSERT(cs != NULL);\n    AP_DEBUG_ASSERT(cs->state == CONN_STATE_PROCESSING);\n\n    if (cs->state == CONN_STATE_PROCESSING) {\n        ap_update_child_status_from_conn(c->sbh, SERVER_BUSY_READ, c);\n        if (ap_extended_status) {\n            ap_set_conn_count(c->sbh, r, c->keepalives);\n        }\n        if ((r = ap_read_request(c))) {\n            if (r->status == HTTP_OK) {\n                cs->state = CONN_STATE_HANDLER;\n                if (ap_extended_status) {\n                    ap_set_conn_count(c->sbh, r, c->keepalives + 1);\n                }\n                ap_update_child_status(c->sbh, SERVER_BUSY_WRITE, r);\n                ap_process_async_request(r);\n                /* After the call to ap_process_request, the\n                 * request pool may have been deleted.  We set\n                 * r=NULL here to ensure that any dereference\n                 * of r that might be added later in this function\n                 * will result in a segfault immediately instead\n                 * of nondeterministic failures later.\n                 */\n                r = NULL;\n            }\n\n            if (cs->state != CONN_STATE_WRITE_COMPLETION &&\n                cs->state != CONN_STATE_SUSPENDED) {\n                /* Something went wrong; close the connection */\n                cs->state = CONN_STATE_LINGER;\n            }\n        }\n        else {   /* ap_read_request failed - client may have closed */\n            cs->state = CONN_STATE_LINGER;\n        }\n    }\n\n    return OK;\n}"
          },
          "ap_process_http_sync_connection": {
            "declaration": "static int ap_process_http_sync_connection(conn_rec *c)\n{\n    request_rec *r;\n    conn_state_t *cs = c->cs;\n    apr_socket_t *csd = NULL;\n    int mpm_state = 0;\n\n    /*\n     * Read and process each request found on our connection\n     * until no requests are left or we decide to close.\n     */\n\n    ap_update_child_status_from_conn(c->sbh, SERVER_BUSY_READ, c);\n    while ((r = ap_read_request(c)) != NULL) {\n        apr_interval_time_t keep_alive_timeout = r->server->keep_alive_timeout;\n\n        /* To preserve legacy behaviour, use the keepalive timeout from the\n         * base server (first on this IP:port) when none is explicitly\n         * configured on this server.\n         */\n        if (!r->server->keep_alive_timeout_set) {\n            keep_alive_timeout = c->base_server->keep_alive_timeout;\n        }\n\n        if (r->status == HTTP_OK) {\n            if (cs)\n                cs->state = CONN_STATE_HANDLER;\n            ap_update_child_status(c->sbh, SERVER_BUSY_WRITE, r);\n            ap_process_request(r);\n            /* After the call to ap_process_request, the\n             * request pool will have been deleted.  We set\n             * r=NULL here to ensure that any dereference\n             * of r that might be added later in this function\n             * will result in a segfault immediately instead\n             * of nondeterministic failures later.\n             */\n            r = NULL;\n        }\n\n        if (c->keepalive != AP_CONN_KEEPALIVE || c->aborted)\n            break;\n\n        ap_update_child_status(c->sbh, SERVER_BUSY_KEEPALIVE, NULL);\n\n        if (ap_mpm_query(AP_MPMQ_MPM_STATE, &mpm_state)) {\n            break;\n        }\n\n        if (mpm_state == AP_MPMQ_STOPPING) {\n          break;\n        }\n\n        if (!csd) {\n            csd = ap_get_conn_socket(c);\n        }\n        apr_socket_opt_set(csd, APR_INCOMPLETE_READ, 1);\n        apr_socket_timeout_set(csd, keep_alive_timeout);\n        /* Go straight to select() to wait for the next request */\n    }\n\n    return OK;\n}",
            "is_external": false,
            "definition": "static int ap_process_http_sync_connection(conn_rec *c)\n{\n    request_rec *r;\n    conn_state_t *cs = c->cs;\n    apr_socket_t *csd = NULL;\n    int mpm_state = 0;\n\n    /*\n     * Read and process each request found on our connection\n     * until no requests are left or we decide to close.\n     */\n\n    ap_update_child_status_from_conn(c->sbh, SERVER_BUSY_READ, c);\n    while ((r = ap_read_request(c)) != NULL) {\n        apr_interval_time_t keep_alive_timeout = r->server->keep_alive_timeout;\n\n        /* To preserve legacy behaviour, use the keepalive timeout from the\n         * base server (first on this IP:port) when none is explicitly\n         * configured on this server.\n         */\n        if (!r->server->keep_alive_timeout_set) {\n            keep_alive_timeout = c->base_server->keep_alive_timeout;\n        }\n\n        if (r->status == HTTP_OK) {\n            if (cs)\n                cs->state = CONN_STATE_HANDLER;\n            ap_update_child_status(c->sbh, SERVER_BUSY_WRITE, r);\n            ap_process_request(r);\n            /* After the call to ap_process_request, the\n             * request pool will have been deleted.  We set\n             * r=NULL here to ensure that any dereference\n             * of r that might be added later in this function\n             * will result in a segfault immediately instead\n             * of nondeterministic failures later.\n             */\n            r = NULL;\n        }\n\n        if (c->keepalive != AP_CONN_KEEPALIVE || c->aborted)\n            break;\n\n        ap_update_child_status(c->sbh, SERVER_BUSY_KEEPALIVE, NULL);\n\n        if (ap_mpm_query(AP_MPMQ_MPM_STATE, &mpm_state)) {\n            break;\n        }\n\n        if (mpm_state == AP_MPMQ_STOPPING) {\n          break;\n        }\n\n        if (!csd) {\n            csd = ap_get_conn_socket(c);\n        }\n        apr_socket_opt_set(csd, APR_INCOMPLETE_READ, 1);\n        apr_socket_timeout_set(csd, keep_alive_timeout);\n        /* Go straight to select() to wait for the next request */\n    }\n\n    return OK;\n}"
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "conn_rec": {
            "name": "conn_rec",
            "definition": "struct conn_rec {\n    /** Pool associated with this connection */\n    apr_pool_t *pool;\n    /** Physical vhost this conn came in on */\n    server_rec *base_server;\n    /** used by http_vhost.c */\n    void *vhost_lookup_data;\n\n    /* Information about the connection itself */\n    /** local address */\n    apr_sockaddr_t *local_addr;\n    /** remote address; this is the end-point of the next hop, for the address\n     *  of the request creator, see useragent_addr in request_rec\n     */\n    apr_sockaddr_t *client_addr;\n\n    /** Client's IP address; this is the end-point of the next hop, for the\n     *  IP of the request creator, see useragent_ip in request_rec\n     */\n    char *client_ip;\n    /** Client's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     * get_remote_host() */\n    char *remote_host;\n    /** Only ever set if doing rfc1413 lookups.  N.B. Only access this through\n     *  get_remote_logname() */\n    char *remote_logname;\n\n    /** server IP address */\n    char *local_ip;\n    /** used for ap_get_server_name when UseCanonicalName is set to DNS\n     *  (ignores setting of HostnameLookups) */\n    char *local_host;\n\n    /** ID of this connection; unique at any point in time */\n    long id;\n    /** Config vector containing pointers to connections per-server\n     *  config structures. */\n    struct ap_conf_vector_t *conn_config;\n    /** Notes on *this* connection: send note from one module to\n     *  another. must remain valid for all requests on this conn */\n    apr_table_t *notes;\n    /** A list of input filters to be used for this connection */\n    struct ap_filter_t *input_filters;\n    /** A list of output filters to be used for this connection */\n    struct ap_filter_t *output_filters;\n    /** handle to scoreboard information for this connection */\n    void *sbh;\n    /** The bucket allocator to use for all bucket/brigade creations */\n    struct apr_bucket_alloc_t *bucket_alloc;\n    /** The current state of this connection; may be NULL if not used by MPM */\n    conn_state_t *cs;\n    /** Is there data pending in the input filters? */\n    int data_in_input_filters;\n    /** Is there data pending in the output filters? */\n    int data_in_output_filters;\n\n    /** Are there any filters that clogg/buffer the input stream, breaking\n     *  the event mpm.\n     */\n    unsigned int clogging_input_filters:1;\n\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success */\n    signed int double_reverse:2;\n\n    /** Are we still talking? */\n    unsigned aborted;\n\n    /** Are we going to keep the connection alive for another request?\n     * @see ap_conn_keepalive_e */\n    ap_conn_keepalive_e keepalive;\n\n    /** How many times have we used it? */\n    int keepalives;\n\n    /** Optional connection log level configuration. May point to a server or\n     *  per_dir config, i.e. must be copied before modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify this connection in error log. Set when the first\n     *  error log entry for this connection is generated.\n     */\n    const char *log_id;\n\n\n    /** This points to the current thread being used to process this request,\n     * over the lifetime of a request, the value may change. Users of the connection\n     * record should not rely upon it staying the same between calls that involve\n     * the MPM.\n     */\n#if APR_HAS_THREADS\n    apr_thread_t *current_thread;\n#endif\n\n    /** The \"real\" master connection. NULL if I am the master. */\n    conn_rec *master;\n\n    int outgoing;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "base_server": "server_rec *",
              "vhost_lookup_data": "void *",
              "local_addr": "apr_sockaddr_t *",
              "client_addr": "apr_sockaddr_t *",
              "client_ip": "char *",
              "remote_host": "char *",
              "remote_logname": "char *",
              "local_ip": "char *",
              "local_host": "char *",
              "id": "long",
              "conn_config": "struct ap_conf_vector_t *",
              "notes": "apr_table_t *",
              "input_filters": "struct ap_filter_t *",
              "output_filters": "struct ap_filter_t *",
              "sbh": "void *",
              "bucket_alloc": "struct apr_bucket_alloc_t *",
              "cs": "conn_state_t *",
              "data_in_input_filters": "int",
              "data_in_output_filters": "int",
              "clogging_input_filters": "unsigned int",
              "double_reverse": "int",
              "aborted": "unsigned int",
              "keepalive": "ap_conn_keepalive_e",
              "keepalives": "int",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "current_thread": "apr_thread_t *",
              "master": "conn_rec *",
              "outgoing": "int"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "async_mpm": {
            "name": "async_mpm",
            "type": "int",
            "is_extern": false,
            "is_static": true,
            "definition": "static int async_mpm = 0",
            "initializer": "0",
            "full_definition": "static int async_mpm = 0",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "static int ap_process_http_connection(conn_rec *c)\n{\n    if (async_mpm && !c->clogging_input_filters) {\n        return ap_process_http_async_connection(c);\n    }\n    else {\n        return ap_process_http_sync_connection(c);\n    }\n}"
    },
    "http_create_request@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 257, column 12>": {
      "basic_info": {
        "function_id": 1627,
        "name": "http_create_request",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 257, column 12>",
        "is_definition": true,
        "start_line": 257,
        "end_line": 272,
        "return_type": "int",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_add_output_filter_handle": {
            "declaration": "AP_DECLARE(ap_filter_t *) ap_add_output_filter_handle(ap_filter_rec_t *f,\n                                                      void *ctx,\n                                                      request_rec *r,\n                                                      conn_rec *c)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "ap_byterange_filter_handle": {
            "name": "ap_byterange_filter_handle",
            "type": "ap_filter_rec_t *",
            "is_extern": false,
            "is_static": false,
            "definition": "ap_filter_rec_t *ap_byterange_filter_handle",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "ap_content_length_filter_handle": {
            "name": "ap_content_length_filter_handle",
            "type": "ap_filter_rec_t *",
            "is_extern": true,
            "is_static": false,
            "definition": "extern ap_filter_rec_t *ap_content_length_filter_handle",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "ap_http_header_filter_handle": {
            "name": "ap_http_header_filter_handle",
            "type": "ap_filter_rec_t *",
            "is_extern": false,
            "is_static": false,
            "definition": "ap_filter_rec_t *ap_http_header_filter_handle",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "ap_http_outerror_filter_handle": {
            "name": "ap_http_outerror_filter_handle",
            "type": "ap_filter_rec_t *",
            "is_extern": false,
            "is_static": false,
            "definition": "ap_filter_rec_t *ap_http_outerror_filter_handle",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "static int http_create_request(request_rec *r)\n{\n    /* FIXME: we must only add these filters if we are an HTTP request */\n    if (!r->main && !r->prev) {\n        ap_add_output_filter_handle(ap_byterange_filter_handle,\n                                    NULL, r, r->connection);\n        ap_add_output_filter_handle(ap_content_length_filter_handle,\n                                    NULL, r, r->connection);\n        ap_add_output_filter_handle(ap_http_header_filter_handle,\n                                    NULL, r, r->connection);\n        ap_add_output_filter_handle(ap_http_outerror_filter_handle,\n                                    NULL, r, r->connection);\n    }\n\n    return OK;\n}"
    },
    "h1_pre_read_request@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 274, column 13>": {
      "basic_info": {
        "function_id": 1628,
        "name": "h1_pre_read_request",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 274, column 13>",
        "is_definition": true,
        "start_line": 274,
        "end_line": 285,
        "return_type": "void",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "c",
            "type": "conn_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "strcmp": {
            "declaration": "extern int strcmp (const char *__s1, const char *__s2)\n     __THROW __attribute_pure__ __nonnull ((1, 2))",
            "is_external": true,
            "definition": null
          },
          "ap_get_protocol": {
            "declaration": "AP_DECLARE(const char *) ap_get_protocol(conn_rec *c)",
            "is_external": true,
            "definition": null
          },
          "ap_add_input_filter_handle": {
            "declaration": "AP_DECLARE(ap_filter_t *) ap_add_input_filter_handle(ap_filter_rec_t *f,\n                                                     void *ctx,\n                                                     request_rec *r,\n                                                     conn_rec *c)",
            "is_external": true,
            "definition": null
          },
          "ap_add_output_filter_handle": {
            "declaration": "AP_DECLARE(ap_filter_t *) ap_add_output_filter_handle(ap_filter_rec_t *f,\n                                                      void *ctx,\n                                                      request_rec *r,\n                                                      conn_rec *c)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "conn_rec": {
            "name": "conn_rec",
            "definition": "struct conn_rec {\n    /** Pool associated with this connection */\n    apr_pool_t *pool;\n    /** Physical vhost this conn came in on */\n    server_rec *base_server;\n    /** used by http_vhost.c */\n    void *vhost_lookup_data;\n\n    /* Information about the connection itself */\n    /** local address */\n    apr_sockaddr_t *local_addr;\n    /** remote address; this is the end-point of the next hop, for the address\n     *  of the request creator, see useragent_addr in request_rec\n     */\n    apr_sockaddr_t *client_addr;\n\n    /** Client's IP address; this is the end-point of the next hop, for the\n     *  IP of the request creator, see useragent_ip in request_rec\n     */\n    char *client_ip;\n    /** Client's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     * get_remote_host() */\n    char *remote_host;\n    /** Only ever set if doing rfc1413 lookups.  N.B. Only access this through\n     *  get_remote_logname() */\n    char *remote_logname;\n\n    /** server IP address */\n    char *local_ip;\n    /** used for ap_get_server_name when UseCanonicalName is set to DNS\n     *  (ignores setting of HostnameLookups) */\n    char *local_host;\n\n    /** ID of this connection; unique at any point in time */\n    long id;\n    /** Config vector containing pointers to connections per-server\n     *  config structures. */\n    struct ap_conf_vector_t *conn_config;\n    /** Notes on *this* connection: send note from one module to\n     *  another. must remain valid for all requests on this conn */\n    apr_table_t *notes;\n    /** A list of input filters to be used for this connection */\n    struct ap_filter_t *input_filters;\n    /** A list of output filters to be used for this connection */\n    struct ap_filter_t *output_filters;\n    /** handle to scoreboard information for this connection */\n    void *sbh;\n    /** The bucket allocator to use for all bucket/brigade creations */\n    struct apr_bucket_alloc_t *bucket_alloc;\n    /** The current state of this connection; may be NULL if not used by MPM */\n    conn_state_t *cs;\n    /** Is there data pending in the input filters? */\n    int data_in_input_filters;\n    /** Is there data pending in the output filters? */\n    int data_in_output_filters;\n\n    /** Are there any filters that clogg/buffer the input stream, breaking\n     *  the event mpm.\n     */\n    unsigned int clogging_input_filters:1;\n\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success */\n    signed int double_reverse:2;\n\n    /** Are we still talking? */\n    unsigned aborted;\n\n    /** Are we going to keep the connection alive for another request?\n     * @see ap_conn_keepalive_e */\n    ap_conn_keepalive_e keepalive;\n\n    /** How many times have we used it? */\n    int keepalives;\n\n    /** Optional connection log level configuration. May point to a server or\n     *  per_dir config, i.e. must be copied before modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify this connection in error log. Set when the first\n     *  error log entry for this connection is generated.\n     */\n    const char *log_id;\n\n\n    /** This points to the current thread being used to process this request,\n     * over the lifetime of a request, the value may change. Users of the connection\n     * record should not rely upon it staying the same between calls that involve\n     * the MPM.\n     */\n#if APR_HAS_THREADS\n    apr_thread_t *current_thread;\n#endif\n\n    /** The \"real\" master connection. NULL if I am the master. */\n    conn_rec *master;\n\n    int outgoing;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "base_server": "server_rec *",
              "vhost_lookup_data": "void *",
              "local_addr": "apr_sockaddr_t *",
              "client_addr": "apr_sockaddr_t *",
              "client_ip": "char *",
              "remote_host": "char *",
              "remote_logname": "char *",
              "local_ip": "char *",
              "local_host": "char *",
              "id": "long",
              "conn_config": "struct ap_conf_vector_t *",
              "notes": "apr_table_t *",
              "input_filters": "struct ap_filter_t *",
              "output_filters": "struct ap_filter_t *",
              "sbh": "void *",
              "bucket_alloc": "struct apr_bucket_alloc_t *",
              "cs": "conn_state_t *",
              "data_in_input_filters": "int",
              "data_in_output_filters": "int",
              "clogging_input_filters": "unsigned int",
              "double_reverse": "int",
              "aborted": "unsigned int",
              "keepalive": "ap_conn_keepalive_e",
              "keepalives": "int",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "current_thread": "apr_thread_t *",
              "master": "conn_rec *",
              "outgoing": "int"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "ap_h1_request_in_filter_handle": {
            "name": "ap_h1_request_in_filter_handle",
            "type": "ap_filter_rec_t *",
            "is_extern": false,
            "is_static": false,
            "definition": "ap_filter_rec_t *ap_h1_request_in_filter_handle",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "ap_h1_response_out_filter_handle": {
            "name": "ap_h1_response_out_filter_handle",
            "type": "ap_filter_rec_t *",
            "is_extern": false,
            "is_static": false,
            "definition": "ap_filter_rec_t *ap_h1_response_out_filter_handle",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "static void h1_pre_read_request(request_rec *r, conn_rec *c)\n{\n    if (!r->main && !r->prev\n        && !strcmp(AP_PROTOCOL_HTTP1, ap_get_protocol(c))) {\n        if (r->proxyreq == PROXYREQ_NONE) {\n            ap_add_input_filter_handle(ap_h1_request_in_filter_handle,\n                                       NULL, r, r->connection);\n        }\n        ap_add_output_filter_handle(ap_h1_response_out_filter_handle,\n                                    NULL, r, r->connection);\n    }\n}"
    },
    "h1_post_read_request@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 287, column 12>": {
      "basic_info": {
        "function_id": 1629,
        "name": "h1_post_read_request",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 287, column 12>",
        "is_definition": true,
        "start_line": 287,
        "end_line": 332,
        "return_type": "int",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "ap_is_chunked": {
            "declaration": "AP_DECLARE(int) ap_is_chunked(apr_pool_t *p, const char *line)",
            "is_external": true,
            "definition": null
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "apr_table_unset": {
            "declaration": "APR_DECLARE(void) apr_table_unset(apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "ap_add_input_filter_handle": {
            "declaration": "AP_DECLARE(ap_filter_t *) ap_add_input_filter_handle(ap_filter_rec_t *f,\n                                                     void *ctx,\n                                                     request_rec *r,\n                                                     conn_rec *c)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {
          "AP_CONN_CLOSE": {
            "name": "AP_CONN_CLOSE",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_conn_keepalive_e AP_CONN_CLOSE = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1145, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "AP_DECLARE_MODULE(http)",
            "initializer": null,
            "full_definition": "AP_DECLARE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          },
          "ap_h1_body_in_filter_handle": {
            "name": "ap_h1_body_in_filter_handle",
            "type": "ap_filter_rec_t *",
            "is_extern": false,
            "is_static": false,
            "definition": "ap_filter_rec_t *ap_h1_body_in_filter_handle",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "static int h1_post_read_request(request_rec *r)\n{\n    const char *tenc;\n\n    if (!r->main && !r->prev && r->proto_num <= HTTP_VERSION(1,1)) {\n        if (r->proto_num >= HTTP_VERSION(1,0)) {\n            tenc = apr_table_get(r->headers_in, \"Transfer-Encoding\");\n            if (tenc) {\n                r->body_indeterminate = 1;\n\n                /* https://tools.ietf.org/html/rfc7230\n                 * Section 3.3.3.3: \"If a Transfer-Encoding header field is\n                 * present in a request and the chunked transfer coding is not\n                 * the final encoding ...; the server MUST respond with the 400\n                 * (Bad Request) status code and then close the connection\".\n                 */\n                if (!ap_is_chunked(r->pool, tenc)) {\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02539)\n                                  \"client sent unknown Transfer-Encoding \"\n                                  \"(%s): %s\", tenc, r->uri);\n                    return HTTP_BAD_REQUEST;\n                }\n\n                /* https://tools.ietf.org/html/rfc7230\n                 * Section 3.3.3.3: \"If a message is received with both a\n                 * Transfer-Encoding and a Content-Length header field, the\n                 * Transfer-Encoding overrides the Content-Length. ... A sender\n                 * MUST remove the received Content-Length field\".\n                 */\n                if (apr_table_get(r->headers_in, \"Content-Length\")) {\n                    apr_table_unset(r->headers_in, \"Content-Length\");\n\n                    /* Don't reuse this connection anyway to avoid confusion with\n                     * intermediaries and request/reponse spltting.\n                     */\n                    r->connection->keepalive = AP_CONN_CLOSE;\n                }\n            }\n        }\n        /* HTTP1_BODY_IN takes care of chunked encoding and content-length.\n         */\n        ap_add_input_filter_handle(ap_h1_body_in_filter_handle,\n                                   NULL, r, r->connection);\n    }\n    return OK;\n}"
    },
    "http_send_options@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 334, column 12>": {
      "basic_info": {
        "function_id": 1630,
        "name": "http_send_options",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 334, column 12>",
        "is_definition": true,
        "start_line": 334,
        "end_line": 341,
        "return_type": "int",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {},
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static int http_send_options(request_rec *r)\n{\n    if ((r->method_number == M_OPTIONS) && r->uri && (r->uri[0] == '*') &&\n         (r->uri[1] == '\\0')) {\n        return DONE;           /* Send HTTP pong, without Allow header */\n    }\n    return DECLINED;\n}"
    },
    "http_post_config@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 343, column 12>": {
      "basic_info": {
        "function_id": 1631,
        "name": "http_post_config",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 343, column 12>",
        "is_definition": true,
        "start_line": 343,
        "end_line": 353,
        "return_type": "int",
        "parameters": [
          {
            "name": "p",
            "type": "apr_pool_t *"
          },
          {
            "name": "plog",
            "type": "apr_pool_t *"
          },
          {
            "name": "ptemp",
            "type": "apr_pool_t *"
          },
          {
            "name": "s",
            "type": "server_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_mpm_query": {
            "declaration": "AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)",
            "is_external": true,
            "definition": null
          },
          "ap_random_insecure_bytes": {
            "declaration": "AP_DECLARE(void) ap_random_insecure_bytes(void *buf, apr_size_t size)",
            "is_external": true,
            "definition": null
          },
          "apr_psprintf": {
            "declaration": "APR_DECLARE_NONSTD(char *) apr_psprintf(apr_pool_t *p, const char *fmt, ...)\n        __attribute__((format(printf,2,3)))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          },
          "server_rec": {
            "name": "server_rec",
            "definition": "struct server_rec {\n    /** The process this server is running in */\n    process_rec *process;\n    /** The next server in the list */\n    server_rec *next;\n\n    /* Log files --- note that transfer log is now in the modules... */\n\n    /** The name of the error log */\n    char *error_fname;\n    /** A file descriptor that references the error log */\n    apr_file_t *error_log;\n    /** The log level configuration */\n    struct ap_logconf log;\n\n    /* Module-specific configuration for server, and defaults... */\n\n    /** Config vector containing pointers to modules' per-server config\n     *  structures. */\n    struct ap_conf_vector_t *module_config;\n    /** MIME type info, etc., before we start checking per-directory info */\n    struct ap_conf_vector_t *lookup_defaults;\n\n    /** The path to the config file that the server was defined in */\n    const char *defn_name;\n    /** The line of the config file that the server was defined on */\n    unsigned defn_line_number;\n    /** true if this is the virtual server */\n    char is_virtual;\n\n\n    /* Information for redirects */\n\n    /** for redirects, etc. */\n    apr_port_t port;\n    /** The server request scheme for redirect responses */\n    const char *server_scheme;\n\n    /* Contact information */\n\n    /** The admin's contact information */\n    char *server_admin;\n    /** The server hostname */\n    char *server_hostname;\n\n    /* Transaction handling */\n\n    /** I haven't got a clue */\n    server_addr_rec *addrs;\n    /** Timeout, as an apr interval, before we give up */\n    apr_interval_time_t timeout;\n    /** The apr interval we will wait for another request */\n    apr_interval_time_t keep_alive_timeout;\n    /** Maximum requests per connection */\n    int keep_alive_max;\n    /** Use persistent connections? */\n    int keep_alive;\n\n    /** Normal names for ServerAlias servers */\n    apr_array_header_t *names;\n    /** Wildcarded names for ServerAlias servers */\n    apr_array_header_t *wild_names;\n\n    /** Pathname for ServerPath */\n    const char *path;\n    /** Length of path */\n    int pathlen;\n\n    /** limit on size of the HTTP request line    */\n    int limit_req_line;\n    /** limit on size of any request header field */\n    int limit_req_fieldsize;\n    /** limit on number of request header fields  */\n    int limit_req_fields;\n\n    /** Opaque storage location */\n    void *context;\n\n    /** Whether the keepalive timeout is explicit (1) or\n     *  inherited (0) from the base server (either first\n     *  server on the same IP:port or main server) */\n    unsigned int keep_alive_timeout_set:1;\n}",
            "typedef_name": null,
            "fields": {
              "process": "process_rec *",
              "next": "server_rec *",
              "error_fname": "char *",
              "error_log": "apr_file_t *",
              "log": "struct ap_logconf",
              "module_config": "struct ap_conf_vector_t *",
              "lookup_defaults": "struct ap_conf_vector_t *",
              "defn_name": "const char *",
              "defn_line_number": "unsigned int",
              "is_virtual": "char",
              "port": "apr_port_t",
              "server_scheme": "const char *",
              "server_admin": "char *",
              "server_hostname": "char *",
              "addrs": "server_addr_rec *",
              "timeout": "apr_interval_time_t",
              "keep_alive_timeout": "apr_interval_time_t",
              "keep_alive_max": "int",
              "keep_alive": "int",
              "names": "apr_array_header_t *",
              "wild_names": "apr_array_header_t *",
              "path": "const char *",
              "pathlen": "int",
              "limit_req_line": "int",
              "limit_req_fieldsize": "int",
              "limit_req_fields": "int",
              "context": "void *",
              "keep_alive_timeout_set": "unsigned int"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "async_mpm": {
            "name": "async_mpm",
            "type": "int",
            "is_extern": false,
            "is_static": true,
            "definition": "static int async_mpm = 0",
            "initializer": "0",
            "full_definition": "static int async_mpm = 0",
            "used_macros": {},
            "condition": ""
          },
          "ap_multipart_boundary": {
            "name": "ap_multipart_boundary",
            "type": "const char *",
            "is_extern": false,
            "is_static": false,
            "definition": "const char *ap_multipart_boundary",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "apr_uint64_t"
        ]
      },
      "source_code": "static int http_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)\n{\n    apr_uint64_t val;\n    if (ap_mpm_query(AP_MPMQ_IS_ASYNC, &async_mpm) != APR_SUCCESS) {\n        async_mpm = 0;\n    }\n    ap_random_insecure_bytes(&val, sizeof(val));\n    ap_multipart_boundary = apr_psprintf(p, \"%0\" APR_UINT64_T_HEX_FMT, val);\n\n    return OK;\n}"
    },
    "register_hooks@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 355, column 13>": {
      "basic_info": {
        "function_id": 1632,
        "name": "register_hooks",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_core.c', line 355, column 13>",
        "is_definition": true,
        "start_line": 355,
        "end_line": 394,
        "return_type": "void",
        "parameters": [
          {
            "name": "p",
            "type": "apr_pool_t *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_hook_post_config": {
            "declaration": "AP_DECLARE_HOOK(int,post_config,(apr_pool_t *pconf,apr_pool_t *plog,\n                                 apr_pool_t *ptemp,server_rec *s))",
            "is_external": true,
            "definition": null
          },
          "ap_hook_process_connection": {
            "declaration": "AP_DECLARE_HOOK(int,process_connection,(conn_rec *c))",
            "is_external": true,
            "definition": null
          },
          "ap_hook_map_to_storage": {
            "declaration": "AP_DECLARE_HOOK(int,map_to_storage,(request_rec *r))",
            "is_external": true,
            "definition": null
          },
          "ap_hook_http_scheme": {
            "declaration": "AP_DECLARE_HOOK(const char *,http_scheme,(const request_rec *r))",
            "is_external": true,
            "definition": null
          },
          "ap_hook_default_port": {
            "declaration": "AP_DECLARE_HOOK(apr_port_t,default_port,(const request_rec *r))",
            "is_external": true,
            "definition": null
          },
          "ap_hook_create_request": {
            "declaration": "AP_DECLARE_HOOK(int,create_request,(request_rec *r))",
            "is_external": true,
            "definition": null
          },
          "ap_hook_pre_read_request": {
            "declaration": "AP_DECLARE_HOOK(void,pre_read_request,(request_rec *r, conn_rec *c))",
            "is_external": true,
            "definition": null
          },
          "ap_hook_post_read_request": {
            "declaration": "AP_DECLARE_HOOK(int,post_read_request,(request_rec *r))",
            "is_external": true,
            "definition": null
          },
          "ap_register_input_filter": {
            "declaration": "AP_DECLARE(ap_filter_rec_t *) ap_register_input_filter(const char *name,\n                                          ap_in_filter_func filter_func,\n                                          ap_init_filter_func filter_init,\n                                          ap_filter_type ftype)",
            "is_external": true,
            "definition": null
          },
          "ap_register_output_filter": {
            "declaration": "AP_DECLARE(ap_filter_rec_t *) ap_register_output_filter(const char *name,\n                                            ap_out_filter_func filter_func,\n                                            ap_init_filter_func filter_init,\n                                            ap_filter_type ftype)",
            "is_external": true,
            "definition": null
          },
          "ap_method_registry_init": {
            "declaration": "AP_DECLARE(void) ap_method_registry_init(apr_pool_t *p)",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_method_registry_init(apr_pool_t *p)\n{\n    methods_registry = apr_hash_make(p);\n    apr_pool_cleanup_register(p, NULL,\n                              ap_method_registry_destroy,\n                              apr_pool_cleanup_null);\n\n    /* put all the standard methods into the registry hash to ease the\n     * mapping operations between name and number\n     * HEAD is a special-instance of the GET method and shares the same ID\n     */\n    register_one_method(p, \"GET\", M_GET);\n    register_one_method(p, \"HEAD\", M_GET);\n    register_one_method(p, \"PUT\", M_PUT);\n    register_one_method(p, \"POST\", M_POST);\n    register_one_method(p, \"DELETE\", M_DELETE);\n    register_one_method(p, \"CONNECT\", M_CONNECT);\n    register_one_method(p, \"OPTIONS\", M_OPTIONS);\n    register_one_method(p, \"TRACE\", M_TRACE);\n    register_one_method(p, \"PATCH\", M_PATCH);\n    register_one_method(p, \"PROPFIND\", M_PROPFIND);\n    register_one_method(p, \"PROPPATCH\", M_PROPPATCH);\n    register_one_method(p, \"MKCOL\", M_MKCOL);\n    register_one_method(p, \"COPY\", M_COPY);\n    register_one_method(p, \"MOVE\", M_MOVE);\n    register_one_method(p, \"LOCK\", M_LOCK);\n    register_one_method(p, \"UNLOCK\", M_UNLOCK);\n    register_one_method(p, \"VERSION-CONTROL\", M_VERSION_CONTROL);\n    register_one_method(p, \"CHECKOUT\", M_CHECKOUT);\n    register_one_method(p, \"UNCHECKOUT\", M_UNCHECKOUT);\n    register_one_method(p, \"CHECKIN\", M_CHECKIN);\n    register_one_method(p, \"UPDATE\", M_UPDATE);\n    register_one_method(p, \"LABEL\", M_LABEL);\n    register_one_method(p, \"REPORT\", M_REPORT);\n    register_one_method(p, \"MKWORKSPACE\", M_MKWORKSPACE);\n    register_one_method(p, \"MKACTIVITY\", M_MKACTIVITY);\n    register_one_method(p, \"BASELINE-CONTROL\", M_BASELINE_CONTROL);\n    register_one_method(p, \"MERGE\", M_MERGE);\n}"
          }
        },
        "callers": {},
        "used_macros": {
          "AP_FTYPE_PROTOCOL": {
            "name": "AP_FTYPE_PROTOCOL",
            "value": "30",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_filter_type AP_FTYPE_PROTOCOL = 30",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/util_filter.h', line 168, column 5>",
            "condition": ""
          },
          "AP_FTYPE_TRANSCODE": {
            "name": "AP_FTYPE_TRANSCODE",
            "value": "40",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_filter_type AP_FTYPE_TRANSCODE = 40",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/util_filter.h', line 170, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {
          "ap_http_input_filter_handle": {
            "name": "ap_http_input_filter_handle",
            "type": "ap_filter_rec_t *",
            "is_extern": false,
            "is_static": false,
            "definition": "ap_filter_rec_t *ap_http_input_filter_handle",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "ap_http_header_filter_handle": {
            "name": "ap_http_header_filter_handle",
            "type": "ap_filter_rec_t *",
            "is_extern": false,
            "is_static": false,
            "definition": "ap_filter_rec_t *ap_http_header_filter_handle",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "ap_chunk_filter_handle": {
            "name": "ap_chunk_filter_handle",
            "type": "ap_filter_rec_t *",
            "is_extern": false,
            "is_static": false,
            "definition": "ap_filter_rec_t *ap_chunk_filter_handle",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "ap_http_outerror_filter_handle": {
            "name": "ap_http_outerror_filter_handle",
            "type": "ap_filter_rec_t *",
            "is_extern": false,
            "is_static": false,
            "definition": "ap_filter_rec_t *ap_http_outerror_filter_handle",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "ap_byterange_filter_handle": {
            "name": "ap_byterange_filter_handle",
            "type": "ap_filter_rec_t *",
            "is_extern": false,
            "is_static": false,
            "definition": "ap_filter_rec_t *ap_byterange_filter_handle",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "static void register_hooks(apr_pool_t *p)\n{\n    ap_hook_post_config(http_post_config, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_process_connection(ap_process_http_connection, NULL, NULL,\n                               APR_HOOK_REALLY_LAST);\n    ap_hook_map_to_storage(ap_send_http_trace,NULL,NULL,APR_HOOK_MIDDLE);\n    ap_hook_map_to_storage(http_send_options,NULL,NULL,APR_HOOK_MIDDLE);\n    ap_hook_http_scheme(http_scheme,NULL,NULL,APR_HOOK_REALLY_LAST);\n    ap_hook_default_port(http_port,NULL,NULL,APR_HOOK_REALLY_LAST);\n\n    ap_hook_create_request(http_create_request, NULL, NULL, APR_HOOK_REALLY_LAST);\n    ap_hook_pre_read_request(h1_pre_read_request, NULL, NULL, APR_HOOK_REALLY_LAST);\n    ap_hook_post_read_request(h1_post_read_request, NULL, NULL, APR_HOOK_REALLY_FIRST);\n\n    ap_http_input_filter_handle =\n        ap_register_input_filter(\"HTTP_IN\", ap_http_filter,\n                                 NULL, AP_FTYPE_PROTOCOL);\n    ap_h1_request_in_filter_handle =\n        ap_register_input_filter(\"HTTP1_REQUEST_IN\", ap_h1_request_in_filter,\n                                 NULL, AP_FTYPE_PROTOCOL);\n    ap_h1_body_in_filter_handle =\n        ap_register_input_filter(\"HTTP1_BODY_IN\", ap_h1_body_in_filter,\n                                 NULL, AP_FTYPE_TRANSCODE);\n    ap_http_header_filter_handle =\n        ap_register_output_filter(\"HTTP_HEADER\", ap_http_header_filter,\n                                  NULL, AP_FTYPE_PROTOCOL);\n    ap_h1_response_out_filter_handle =\n        ap_register_output_filter(\"HTTP1_RESPONSE_OUT\", ap_h1_response_out_filter,\n                                  NULL, AP_FTYPE_TRANSCODE);\n    ap_chunk_filter_handle =\n        ap_register_output_filter(\"CHUNK\", ap_http_chunk_filter,\n                                  NULL, AP_FTYPE_TRANSCODE);\n    ap_http_outerror_filter_handle =\n        ap_register_output_filter(\"HTTP_OUTERROR\", ap_http_outerror_filter,\n                                  NULL, AP_FTYPE_PROTOCOL);\n    ap_byterange_filter_handle =\n        ap_register_output_filter(\"BYTERANGE\", ap_byterange_filter,\n                                  NULL, AP_FTYPE_PROTOCOL);\n    ap_method_registry_init(p);\n}"
    },
    "ap_hook_insert_error_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 188, column 1>": {
      "basic_info": {
        "function_id": 1633,
        "name": "ap_hook_insert_error_filter",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 188, column 1>",
        "is_definition": true,
        "start_line": 188,
        "end_line": 188,
        "return_type": "void",
        "parameters": [
          {
            "name": "pf",
            "type": "ap_HOOK_insert_error_filter_t *"
          },
          {
            "name": "aszPre",
            "type": "const char *const *"
          },
          {
            "name": "aszSucc",
            "type": "const char *const *"
          },
          {
            "name": "nOrder",
            "type": "int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_array_make": {
            "declaration": "APR_DECLARE(apr_array_header_t *) apr_array_make(apr_pool_t *p,\n                                                 int nelts, int elt_size)",
            "is_external": true,
            "definition": null
          },
          "apr_hook_sort_register": {
            "declaration": "APU_DECLARE(void) apr_hook_sort_register(const char *szHookName, \n                                        apr_array_header_t **aHooks)",
            "is_external": true,
            "definition": null
          },
          "apr_array_push": {
            "declaration": "APR_DECLARE(void *) apr_array_push(apr_array_header_t *arr)",
            "is_external": true,
            "definition": null
          },
          "apr_hook_debug_show": {
            "declaration": "APU_DECLARE(void) apr_hook_debug_show(const char *szName,\n                                      const char * const *aszPre,\n                                      const char * const *aszSucc)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "ap_LINK_insert_error_filter_t": {
            "name": "ap_LINK_insert_error_filter_t",
            "definition": "AP_DECLARE_HOOK(void,insert_error_filter,(request_rec *r))",
            "typedef_name": null,
            "fields": {
              "pFunc": "ap_HOOK_insert_error_filter_t *",
              "szName": "const char *",
              "aszPredecessors": "const char *const *",
              "aszSuccessors": "const char *const *",
              "nOrder": "int"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "_hooks": {
            "name": "_hooks",
            "type": "struct (unnamed struct at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c:184:1)",
            "is_extern": false,
            "is_static": true,
            "definition": "APR_HOOK_STRUCT(\n    APR_HOOK_LINK(insert_error_filter)\n)",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "apr_hook_global_pool": {
            "name": "apr_hook_global_pool",
            "type": "apr_pool_t *",
            "is_extern": true,
            "is_static": false,
            "definition": "extern apr_pool_t *apr_hook_global_pool",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "apr_hook_debug_current": {
            "name": "apr_hook_debug_current",
            "type": "const char *",
            "is_extern": true,
            "is_static": false,
            "definition": "extern const char *apr_hook_debug_current",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          },
          "apr_hook_debug_enabled": {
            "name": "apr_hook_debug_enabled",
            "type": "int",
            "is_extern": true,
            "is_static": false,
            "definition": "extern int apr_hook_debug_enabled",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "ap_HOOK_insert_error_filter_t"
        ]
      },
      "source_code": "AP_IMPLEMENT_HOOK_VOID(insert_error_filter, (request_rec *r), (r))"
    },
    "ap_hook_get_insert_error_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 188, column 1>": {
      "basic_info": {
        "function_id": 1634,
        "name": "ap_hook_get_insert_error_filter",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 188, column 1>",
        "is_definition": true,
        "start_line": 188,
        "end_line": 188,
        "return_type": "apr_array_header_t *",
        "parameters": [],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {},
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "apr_array_header_t": {
            "name": "apr_array_header_t",
            "definition": "struct apr_array_header_t {\n    /** The pool the array is allocated out of */\n    apr_pool_t *pool;\n    /** The amount of memory allocated for each element of the array */\n    int elt_size;\n    /** The number of active elements in the array */\n    int nelts;\n    /** The number of elements allocated in the array */\n    int nalloc;\n    /** The elements in the array */\n    char *elts;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "elt_size": "int",
              "nelts": "int",
              "nalloc": "int",
              "elts": "char *"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "_hooks": {
            "name": "_hooks",
            "type": "struct (unnamed struct at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c:184:1)",
            "is_extern": false,
            "is_static": true,
            "definition": "APR_HOOK_STRUCT(\n    APR_HOOK_LINK(insert_error_filter)\n)",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "AP_IMPLEMENT_HOOK_VOID(insert_error_filter, (request_rec *r), (r))"
    },
    "ap_run_insert_error_filter@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 188, column 1>": {
      "basic_info": {
        "function_id": 1635,
        "name": "ap_run_insert_error_filter",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 188, column 1>",
        "is_definition": true,
        "start_line": 188,
        "end_line": 188,
        "return_type": "void",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "pFunc": {
            "declaration": "AP_IMPLEMENT_HOOK_VOID(insert_error_filter, (request_rec *r), (r))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_send_error_response@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1212, column 18>": {
            "source_code": "AP_DECLARE(void) ap_send_error_response(request_rec *r, int recursive_error)\n{\n    int status = r->status;\n    int idx = ap_index_of_response(status);\n    char *custom_response;\n    const char *location = apr_table_get(r->headers_out, \"Location\");\n\n    /* At this point, we are starting the response over, so we have to reset\n     * this value.\n     */\n    r->eos_sent = 0;\n\n    /* and we need to get rid of any RESOURCE filters that might be lurking\n     * around, thinking they are in the middle of the original request\n     */\n\n    r->output_filters = r->proto_output_filters;\n\n    ap_run_insert_error_filter(r);\n\n    /* We need to special-case the handling of 204 and 304 responses,\n     * since they have specific HTTP requirements and do not include a\n     * message body.  Note that being assbackwards here is not an option.\n     */\n    if (AP_STATUS_IS_HEADER_ONLY(status)) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    /*\n     * It's possible that the Location field might be in r->err_headers_out\n     * instead of r->headers_out; use the latter if possible, else the\n     * former.\n     */\n    if (location == NULL) {\n        location = apr_table_get(r->err_headers_out, \"Location\");\n    }\n\n    if (!r->assbackwards) {\n\n        /* For all HTTP/1.x responses for which we generate the message,\n         * we need to avoid inheriting the \"normal status\" header fields\n         * that may have been set by the request handler before the\n         * error or redirect, except for Location on external redirects.\n         */\n        apr_table_clear(r->headers_out);\n\n        if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {\n            if ((location != NULL) && *location) {\n                apr_table_setn(r->headers_out, \"Location\", location);\n            }\n            else {\n                location = \"\";   /* avoids coredump when printing, below */\n            }\n        }\n\n        r->content_languages = NULL;\n        r->content_encoding = NULL;\n        r->clength = 0;\n\n        if (apr_table_get(r->subprocess_env,\n                          \"suppress-error-charset\") != NULL) {\n            core_request_config *request_conf =\n                        ap_get_core_module_config(r->request_config);\n            request_conf->suppress_charset = 1; /* avoid adding default\n                                                 * charset later\n                                                 */\n            ap_set_content_type_ex(r, \"text/html\", 1);\n        }\n        else {\n            ap_set_content_type_ex(r, \"text/html; charset=iso-8859-1\", 1);\n        }\n\n        if ((status == HTTP_METHOD_NOT_ALLOWED)\n            || (status == HTTP_NOT_IMPLEMENTED)) {\n            apr_table_setn(r->headers_out, \"Allow\", make_allow(r));\n        }\n\n        if (r->header_only) {\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n\n    if ((custom_response = ap_response_code_string(r, idx))) {\n        /*\n         * We have a custom response output. This should only be\n         * a text-string to write back. But if the ErrorDocument\n         * was a local redirect and the requested resource failed\n         * for any reason, the custom_response will still hold the\n         * redirect URL. We don't really want to output this URL\n         * as a text message, so first check the custom response\n         * string to ensure that it is a text-string (using the\n         * same test used in ap_die(), i.e. does it start with a \").\n         *\n         * If it's not a text string, we've got a recursive error or\n         * an external redirect.  If it's a recursive error, ap_die passes\n         * us the second error code so we can write both, and has already\n         * backed up to the original error.  If it's an external redirect,\n         * it hasn't happened yet; we may never know if it fails.\n         */\n        if (custom_response[0] == '\\\"') {\n            ap_rvputs_proto_in_ascii(r, custom_response + 1, NULL);\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n    {\n        const char *title = status_lines[idx];\n        const char *h1;\n\n        /* Accept a status_line set by a module, but only if it begins\n         * with the correct 3 digit status code\n         */\n        if (r->status_line) {\n            char *end;\n            int len = strlen(r->status_line);\n            if (len >= 3\n                && apr_strtoi64(r->status_line, &end, 10) == r->status\n                && (end - 3) == r->status_line\n                && (len < 4 || apr_isspace(r->status_line[3]))\n                && (len < 5 || apr_isalnum(r->status_line[4]))) {\n                /* Since we passed the above check, we know that length three\n                 * is equivalent to only a 3 digit numeric http status.\n                 * RFC2616 mandates a trailing space, let's add it.\n                 * If we have an empty reason phrase, we also add \"Unknown Reason\".\n                 */\n                if (len == 3) {\n                    r->status_line = apr_pstrcat(r->pool, r->status_line, \" Unknown Reason\", NULL);\n                } else if (len == 4) {\n                    r->status_line = apr_pstrcat(r->pool, r->status_line, \"Unknown Reason\", NULL);\n                }\n                title = r->status_line;\n            }\n        }\n\n        /* folks decided they didn't want the error code in the H1 text */\n        h1 = &title[4];\n\n        /* can't count on a charset filter being in place here,\n         * so do ebcdic->ascii translation explicitly (if needed)\n         */\n\n        ap_rvputs_proto_in_ascii(r,\n                  DOCTYPE_HTML_4_01\n                  \"<html><head>\\n<title>\", title,\n                  \"</title>\\n</head><body>\\n<h1>\", h1, \"</h1>\\n\",\n                  NULL);\n\n        ap_rvputs_proto_in_ascii(r,\n                                 get_canned_error_string(status, r, location),\n                                 NULL);\n\n        if (recursive_error) {\n            ap_rvputs_proto_in_ascii(r, \"<p>Additionally, a \",\n                      status_lines[ap_index_of_response(recursive_error)],\n                      \"\\nerror was encountered while trying to use an \"\n                      \"ErrorDocument to handle the request.</p>\\n\", NULL);\n        }\n        ap_rvputs_proto_in_ascii(r, ap_psignature(\"<hr>\\n\", r), NULL);\n        ap_rvputs_proto_in_ascii(r, \"</body></html>\\n\", NULL);\n    }\n    ap_finalize_request_protocol(r);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1212, column 18>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "ap_LINK_insert_error_filter_t": {
            "name": "ap_LINK_insert_error_filter_t",
            "definition": "AP_DECLARE_HOOK(void,insert_error_filter,(request_rec *r))",
            "typedef_name": null,
            "fields": {
              "pFunc": "ap_HOOK_insert_error_filter_t *",
              "szName": "const char *",
              "aszPredecessors": "const char *const *",
              "aszSuccessors": "const char *const *",
              "nOrder": "int"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "_hooks": {
            "name": "_hooks",
            "type": "struct (unnamed struct at /data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c:184:1)",
            "is_extern": false,
            "is_static": true,
            "definition": "APR_HOOK_STRUCT(\n    APR_HOOK_LINK(insert_error_filter)\n)",
            "initializer": null,
            "full_definition": null,
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "AP_IMPLEMENT_HOOK_VOID(insert_error_filter, (request_rec *r), (r))"
    },
    "is_mpm_running@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 201, column 12>": {
      "basic_info": {
        "function_id": 1636,
        "name": "is_mpm_running",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 201, column 12>",
        "is_definition": true,
        "start_line": 201,
        "end_line": 214,
        "return_type": "int",
        "parameters": [],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_mpm_query": {
            "declaration": "AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_h1_set_keepalive@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 216, column 5>": {
            "source_code": "int ap_h1_set_keepalive(request_rec *r, ap_bucket_response *resp)\n{\n    int ka_sent, left = 0, wimpy;\n    const char *conn;\n\n    if (r->proto_num >= HTTP_VERSION(2,0)) {\n        goto update_keepalives;\n    }\n\n    ka_sent = 0;\n    left = r->server->keep_alive_max - r->connection->keepalives;\n    wimpy = ap_find_token(r->pool,\n                          apr_table_get(resp->headers, \"Connection\"),\n                          \"close\");\n    conn = apr_table_get(r->headers_in, \"Connection\");\n\n    /* The following convoluted conditional determines whether or not\n     * the current connection should remain persistent after this response\n     * (a.k.a. HTTP Keep-Alive) and whether or not the output message\n     * body should use the HTTP/1.1 chunked transfer-coding.  In English,\n     *\n     *   IF  we have not marked this connection as errored;\n     *   and the client isn't expecting 100-continue (PR47087 - more\n     *       input here could be the client continuing when we're\n     *       closing the request).\n     *   and the response body has a defined length due to the status code\n     *       being 304 or 204, the request method being HEAD, already\n     *       having defined Content-Length or Transfer-Encoding: chunked, or\n     *       the request version being HTTP/1.1 and thus capable of being set\n     *       as chunked [we know the (r->chunked = 1) side-effect is ugly];\n     *   and the server configuration enables keep-alive;\n     *   and the server configuration has a reasonable inter-request timeout;\n     *   and there is no maximum # requests or the max hasn't been reached;\n     *   and the response status does not require a close;\n     *   and the response generator has not already indicated close;\n     *   and the client did not request non-persistence (Connection: close);\n     *   and    we haven't been configured to ignore the buggy twit\n     *       or they're a buggy twit coming through a HTTP/1.1 proxy\n     *   and    the client is requesting an HTTP/1.0-style keep-alive\n     *       or the client claims to be HTTP/1.1 compliant (perhaps a proxy);\n     *   and this MPM process is not already exiting\n     *   THEN we can be persistent, which requires more headers be output.\n     *\n     * Note that the condition evaluation order is extremely important.\n     */\n    if ((r->connection->keepalive != AP_CONN_CLOSE)\n        && !r->expecting_100\n        && (r->header_only\n            || AP_STATUS_IS_HEADER_ONLY(resp->status)\n            || apr_table_get(resp->headers, \"Content-Length\")\n            || ap_is_chunked(r->pool,\n                             apr_table_get(resp->headers, \"Transfer-Encoding\"))\n            || ((r->proto_num >= HTTP_VERSION(1,1))\n                && (r->chunked = 1))) /* THIS CODE IS CORRECT, see above. */\n        && r->server->keep_alive\n        && (r->server->keep_alive_timeout > 0)\n        && ((r->server->keep_alive_max == 0)\n            || (left > 0))\n        && !ap_status_drops_connection(resp->status)\n        && !wimpy\n        && !ap_find_token(r->pool, conn, \"close\")\n        && (!apr_table_get(r->subprocess_env, \"nokeepalive\")\n            || apr_table_get(r->headers_in, \"Via\"))\n        && ((ka_sent = ap_find_token(r->pool, conn, \"keep-alive\"))\n            || (r->proto_num >= HTTP_VERSION(1,1)))\n        && is_mpm_running()) {\n\n        r->connection->keepalive = AP_CONN_KEEPALIVE;\n        r->connection->keepalives++;\n\n        /* If they sent a Keep-Alive token, send one back */\n        if (ka_sent) {\n            if (r->server->keep_alive_max) {\n                apr_table_setn(resp->headers, \"Keep-Alive\",\n                       apr_psprintf(r->pool, \"timeout=%d, max=%d\",\n                            (int)apr_time_sec(r->server->keep_alive_timeout),\n                            left));\n            }\n            else {\n                apr_table_setn(resp->headers, \"Keep-Alive\",\n                      apr_psprintf(r->pool, \"timeout=%d\",\n                            (int)apr_time_sec(r->server->keep_alive_timeout)));\n            }\n            apr_table_mergen(resp->headers, \"Connection\", \"Keep-Alive\");\n        }\n\n        return 1;\n    }\n\n    /* Otherwise, we need to indicate that we will be closing this\n     * connection immediately after the current response.\n     *\n     * We only really need to send \"close\" to HTTP/1.1 clients, but we\n     * always send it anyway, because a broken proxy may identify itself\n     * as HTTP/1.0, but pass our request along with our HTTP/1.1 tag\n     * to a HTTP/1.1 client. Better safe than sorry.\n     */\n    if (!wimpy) {\n        apr_table_mergen(resp->headers, \"Connection\", \"close\");\n    }\n\nupdate_keepalives:\n    /*\n     * If we had previously been a keepalive connection and this\n     * is the last one, then bump up the number of keepalives\n     * we've had\n     */\n    if ((r->connection->keepalive != AP_CONN_CLOSE)\n        && r->server->keep_alive_max\n        && !left) {\n        r->connection->keepalives++;\n    }\n    r->connection->keepalive = AP_CONN_CLOSE;\n\n    return 0;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 216, column 5>"
          }
        },
        "used_macros": {},
        "used_structs": {},
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static int is_mpm_running(void)\n{\n    int mpm_state = 0;\n\n    if (ap_mpm_query(AP_MPMQ_MPM_STATE, &mpm_state)) {\n      return 0;\n    }\n\n    if (mpm_state == AP_MPMQ_STOPPING) {\n      return 0;\n    }\n\n    return 1;\n}"
    },
    "ap_h1_set_keepalive@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 216, column 5>": {
      "basic_info": {
        "function_id": 1637,
        "name": "ap_h1_set_keepalive",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 216, column 5>",
        "is_definition": true,
        "start_line": 216,
        "end_line": 331,
        "return_type": "int",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "resp",
            "type": "int *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_find_token": {
            "declaration": "AP_DECLARE(int) ap_find_token(apr_pool_t *p, const char *line, const char *tok)",
            "is_external": true,
            "definition": null
          },
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "ap_is_chunked": {
            "declaration": "AP_DECLARE(int) ap_is_chunked(apr_pool_t *p, const char *line)",
            "is_external": true,
            "definition": null
          },
          "is_mpm_running": {
            "declaration": "static int is_mpm_running(void)\n{\n    int mpm_state = 0;\n\n    if (ap_mpm_query(AP_MPMQ_MPM_STATE, &mpm_state)) {\n      return 0;\n    }\n\n    if (mpm_state == AP_MPMQ_STOPPING) {\n      return 0;\n    }\n\n    return 1;\n}",
            "is_external": false,
            "definition": "static int is_mpm_running(void)\n{\n    int mpm_state = 0;\n\n    if (ap_mpm_query(AP_MPMQ_MPM_STATE, &mpm_state)) {\n      return 0;\n    }\n\n    if (mpm_state == AP_MPMQ_STOPPING) {\n      return 0;\n    }\n\n    return 1;\n}"
          },
          "apr_table_setn": {
            "declaration": "APR_DECLARE(void) apr_table_setn(apr_table_t *t, const char *key,\n                                 const char *val)",
            "is_external": true,
            "definition": null
          },
          "apr_psprintf": {
            "declaration": "APR_DECLARE_NONSTD(char *) apr_psprintf(apr_pool_t *p, const char *fmt, ...)\n        __attribute__((format(printf,2,3)))",
            "is_external": true,
            "definition": null
          },
          "apr_table_mergen": {
            "declaration": "APR_DECLARE(void) apr_table_mergen(apr_table_t *t, const char *key,\n                                   const char *val)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {
          "AP_CONN_CLOSE": {
            "name": "AP_CONN_CLOSE",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_conn_keepalive_e AP_CONN_CLOSE = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1145, column 5>",
            "condition": ""
          },
          "AP_CONN_KEEPALIVE": {
            "name": "AP_CONN_KEEPALIVE",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_conn_keepalive_e AP_CONN_KEEPALIVE = 2",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/httpd.h', line 1146, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "int ap_h1_set_keepalive(request_rec *r, ap_bucket_response *resp)\n{\n    int ka_sent, left = 0, wimpy;\n    const char *conn;\n\n    if (r->proto_num >= HTTP_VERSION(2,0)) {\n        goto update_keepalives;\n    }\n\n    ka_sent = 0;\n    left = r->server->keep_alive_max - r->connection->keepalives;\n    wimpy = ap_find_token(r->pool,\n                          apr_table_get(resp->headers, \"Connection\"),\n                          \"close\");\n    conn = apr_table_get(r->headers_in, \"Connection\");\n\n    /* The following convoluted conditional determines whether or not\n     * the current connection should remain persistent after this response\n     * (a.k.a. HTTP Keep-Alive) and whether or not the output message\n     * body should use the HTTP/1.1 chunked transfer-coding.  In English,\n     *\n     *   IF  we have not marked this connection as errored;\n     *   and the client isn't expecting 100-continue (PR47087 - more\n     *       input here could be the client continuing when we're\n     *       closing the request).\n     *   and the response body has a defined length due to the status code\n     *       being 304 or 204, the request method being HEAD, already\n     *       having defined Content-Length or Transfer-Encoding: chunked, or\n     *       the request version being HTTP/1.1 and thus capable of being set\n     *       as chunked [we know the (r->chunked = 1) side-effect is ugly];\n     *   and the server configuration enables keep-alive;\n     *   and the server configuration has a reasonable inter-request timeout;\n     *   and there is no maximum # requests or the max hasn't been reached;\n     *   and the response status does not require a close;\n     *   and the response generator has not already indicated close;\n     *   and the client did not request non-persistence (Connection: close);\n     *   and    we haven't been configured to ignore the buggy twit\n     *       or they're a buggy twit coming through a HTTP/1.1 proxy\n     *   and    the client is requesting an HTTP/1.0-style keep-alive\n     *       or the client claims to be HTTP/1.1 compliant (perhaps a proxy);\n     *   and this MPM process is not already exiting\n     *   THEN we can be persistent, which requires more headers be output.\n     *\n     * Note that the condition evaluation order is extremely important.\n     */\n    if ((r->connection->keepalive != AP_CONN_CLOSE)\n        && !r->expecting_100\n        && (r->header_only\n            || AP_STATUS_IS_HEADER_ONLY(resp->status)\n            || apr_table_get(resp->headers, \"Content-Length\")\n            || ap_is_chunked(r->pool,\n                             apr_table_get(resp->headers, \"Transfer-Encoding\"))\n            || ((r->proto_num >= HTTP_VERSION(1,1))\n                && (r->chunked = 1))) /* THIS CODE IS CORRECT, see above. */\n        && r->server->keep_alive\n        && (r->server->keep_alive_timeout > 0)\n        && ((r->server->keep_alive_max == 0)\n            || (left > 0))\n        && !ap_status_drops_connection(resp->status)\n        && !wimpy\n        && !ap_find_token(r->pool, conn, \"close\")\n        && (!apr_table_get(r->subprocess_env, \"nokeepalive\")\n            || apr_table_get(r->headers_in, \"Via\"))\n        && ((ka_sent = ap_find_token(r->pool, conn, \"keep-alive\"))\n            || (r->proto_num >= HTTP_VERSION(1,1)))\n        && is_mpm_running()) {\n\n        r->connection->keepalive = AP_CONN_KEEPALIVE;\n        r->connection->keepalives++;\n\n        /* If they sent a Keep-Alive token, send one back */\n        if (ka_sent) {\n            if (r->server->keep_alive_max) {\n                apr_table_setn(resp->headers, \"Keep-Alive\",\n                       apr_psprintf(r->pool, \"timeout=%d, max=%d\",\n                            (int)apr_time_sec(r->server->keep_alive_timeout),\n                            left));\n            }\n            else {\n                apr_table_setn(resp->headers, \"Keep-Alive\",\n                      apr_psprintf(r->pool, \"timeout=%d\",\n                            (int)apr_time_sec(r->server->keep_alive_timeout)));\n            }\n            apr_table_mergen(resp->headers, \"Connection\", \"Keep-Alive\");\n        }\n\n        return 1;\n    }\n\n    /* Otherwise, we need to indicate that we will be closing this\n     * connection immediately after the current response.\n     *\n     * We only really need to send \"close\" to HTTP/1.1 clients, but we\n     * always send it anyway, because a broken proxy may identify itself\n     * as HTTP/1.0, but pass our request along with our HTTP/1.1 tag\n     * to a HTTP/1.1 client. Better safe than sorry.\n     */\n    if (!wimpy) {\n        apr_table_mergen(resp->headers, \"Connection\", \"close\");\n    }\n\nupdate_keepalives:\n    /*\n     * If we had previously been a keepalive connection and this\n     * is the last one, then bump up the number of keepalives\n     * we've had\n     */\n    if ((r->connection->keepalive != AP_CONN_CLOSE)\n        && r->server->keep_alive_max\n        && !left) {\n        r->connection->keepalives++;\n    }\n    r->connection->keepalive = AP_CONN_CLOSE;\n\n    return 0;\n}"
    },
    "ap_set_keepalive@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 333, column 17>": {
      "basic_info": {
        "function_id": 1638,
        "name": "ap_set_keepalive",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 333, column 17>",
        "is_definition": true,
        "start_line": 333,
        "end_line": 342,
        "return_type": "int",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {},
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(int) ap_set_keepalive(request_rec *r)\n{\n    ap_bucket_response resp;\n\n    memset(&resp, 0, sizeof(resp));\n    resp.status = r->status;\n    resp.headers = r->headers_out;\n    resp.notes = r->notes;\n    return ap_h1_set_keepalive(r, &resp);\n}"
    },
    "ap_condition_if_match@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 344, column 28>": {
      "basic_info": {
        "function_id": 1639,
        "name": "ap_condition_if_match",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 344, column 28>",
        "is_definition": true,
        "start_line": 344,
        "end_line": 364,
        "return_type": "ap_condition_e",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "headers",
            "type": "apr_table_t *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "ap_find_etag_strong": {
            "declaration": "AP_DECLARE(int) ap_find_etag_strong(apr_pool_t *p, const char *line, const char *tok)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_meets_conditions@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 563, column 17>": {
            "source_code": "AP_DECLARE(int) ap_meets_conditions(request_rec *r)\n{\n    int not_modified = -1; /* unset by default */\n    ap_condition_e cond;\n\n    /* Check for conditional requests --- note that we only want to do\n     * this if we are successful so far and we are not processing a\n     * subrequest or an ErrorDocument.\n     *\n     * The order of the checks is important, since ETag checks are supposed\n     * to be more accurate than checks relative to the modification time.\n     * However, not all documents are guaranteed to *have* ETags, and some\n     * might have Last-Modified values w/o ETags, so this gets a little\n     * complicated.\n     */\n\n    if (!ap_is_HTTP_SUCCESS(r->status) || r->no_local_copy) {\n        return OK;\n    }\n\n    /* If an If-Match request-header field was given\n     * AND the field value is not \"*\" (meaning match anything)\n     * AND if our strong ETag does not match any entity tag in that field,\n     *     respond with a status of 412 (Precondition Failed).\n     */\n    cond = ap_condition_if_match(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        return HTTP_PRECONDITION_FAILED;\n    }\n\n    /* Else if a valid If-Unmodified-Since request-header field was given\n     * AND the requested resource has been modified since the time\n     * specified in this field, then the server MUST\n     *     respond with a status of 412 (Precondition Failed).\n     */\n    cond = ap_condition_if_unmodified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        return HTTP_PRECONDITION_FAILED;\n    }\n\n    /* If an If-None-Match request-header field was given\n     * AND the field value is \"*\" (meaning match anything)\n     *     OR our ETag matches any of the entity tags in that field, fail.\n     *\n     * If the request method was GET or HEAD, failure means the server\n     *    SHOULD respond with a 304 (Not Modified) response.\n     * For all other request methods, failure means the server MUST\n     *    respond with a status of 412 (Precondition Failed).\n     *\n     * GET or HEAD allow weak etag comparison, all other methods require\n     * strong comparison.  We can only use weak if it's not a range request.\n     */\n    cond = ap_condition_if_none_match(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        if (r->method_number == M_GET) {\n            if (not_modified) {\n                not_modified = 1;\n            }\n        }\n        else {\n            return HTTP_PRECONDITION_FAILED;\n        }\n    }\n\n    /* If a valid If-Modified-Since request-header field was given\n     * AND it is a GET or HEAD request\n     * AND the requested resource has not been modified since the time\n     * specified in this field, then the server MUST\n     *    respond with a status of 304 (Not Modified).\n     * A date later than the server's current request time is invalid.\n     */\n    cond = ap_condition_if_modified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        if (r->method_number == M_GET) {\n            if (not_modified) {\n                not_modified = 1;\n            }\n        }\n    }\n\n    /* If an If-Range and an Range header is present, we must return\n     * 200 OK. The byterange filter will convert it to a range response.\n     */\n    cond = ap_condition_if_range(r, r->headers_out);\n    if (cond > AP_CONDITION_NONE) {\n        return OK;\n    }\n\n    if (not_modified == 1) {\n        return HTTP_NOT_MODIFIED;\n    }\n\n    return OK;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 563, column 17>"
          }
        },
        "used_macros": {
          "AP_CONDITION_STRONG": {
            "name": "AP_CONDITION_STRONG",
            "value": "3",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_STRONG = 3",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 238, column 5>",
            "condition": ""
          },
          "AP_CONDITION_NOMATCH": {
            "name": "AP_CONDITION_NOMATCH",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_NOMATCH = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 236, column 5>",
            "condition": ""
          },
          "AP_CONDITION_NONE": {
            "name": "AP_CONDITION_NONE",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_NONE = 0",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 235, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_table_t": {
            "name": "apr_table_t",
            "definition": "struct apr_table_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "ap_condition_e"
        ]
      },
      "source_code": "AP_DECLARE(ap_condition_e) ap_condition_if_match(request_rec *r,\n        apr_table_t *headers)\n{\n    const char *if_match, *etag;\n\n    /* A server MUST use the strong comparison function (see section 13.3.3)\n     * to compare the entity tags in If-Match.\n     */\n    if ((if_match = apr_table_get(r->headers_in, \"If-Match\")) != NULL) {\n        if (if_match[0] == '*'\n                || ((etag = apr_table_get(headers, \"ETag\")) != NULL\n                        && ap_find_etag_strong(r->pool, if_match, etag))) {\n            return AP_CONDITION_STRONG;\n        }\n        else {\n            return AP_CONDITION_NOMATCH;\n        }\n    }\n\n    return AP_CONDITION_NONE;\n}"
    },
    "ap_condition_if_unmodified_since@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 366, column 28>": {
      "basic_info": {
        "function_id": 1640,
        "name": "ap_condition_if_unmodified_since",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 366, column 28>",
        "is_definition": true,
        "start_line": 366,
        "end_line": 412,
        "return_type": "ap_condition_e",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "headers",
            "type": "apr_table_t *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "apr_date_parse_http": {
            "declaration": "APU_DECLARE(apr_time_t) apr_date_parse_http(const char *date)",
            "is_external": true,
            "definition": null
          },
          "apr_time_now": {
            "declaration": "APR_DECLARE(apr_time_t) apr_time_now(void)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_meets_conditions@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 563, column 17>": {
            "source_code": "AP_DECLARE(int) ap_meets_conditions(request_rec *r)\n{\n    int not_modified = -1; /* unset by default */\n    ap_condition_e cond;\n\n    /* Check for conditional requests --- note that we only want to do\n     * this if we are successful so far and we are not processing a\n     * subrequest or an ErrorDocument.\n     *\n     * The order of the checks is important, since ETag checks are supposed\n     * to be more accurate than checks relative to the modification time.\n     * However, not all documents are guaranteed to *have* ETags, and some\n     * might have Last-Modified values w/o ETags, so this gets a little\n     * complicated.\n     */\n\n    if (!ap_is_HTTP_SUCCESS(r->status) || r->no_local_copy) {\n        return OK;\n    }\n\n    /* If an If-Match request-header field was given\n     * AND the field value is not \"*\" (meaning match anything)\n     * AND if our strong ETag does not match any entity tag in that field,\n     *     respond with a status of 412 (Precondition Failed).\n     */\n    cond = ap_condition_if_match(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        return HTTP_PRECONDITION_FAILED;\n    }\n\n    /* Else if a valid If-Unmodified-Since request-header field was given\n     * AND the requested resource has been modified since the time\n     * specified in this field, then the server MUST\n     *     respond with a status of 412 (Precondition Failed).\n     */\n    cond = ap_condition_if_unmodified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        return HTTP_PRECONDITION_FAILED;\n    }\n\n    /* If an If-None-Match request-header field was given\n     * AND the field value is \"*\" (meaning match anything)\n     *     OR our ETag matches any of the entity tags in that field, fail.\n     *\n     * If the request method was GET or HEAD, failure means the server\n     *    SHOULD respond with a 304 (Not Modified) response.\n     * For all other request methods, failure means the server MUST\n     *    respond with a status of 412 (Precondition Failed).\n     *\n     * GET or HEAD allow weak etag comparison, all other methods require\n     * strong comparison.  We can only use weak if it's not a range request.\n     */\n    cond = ap_condition_if_none_match(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        if (r->method_number == M_GET) {\n            if (not_modified) {\n                not_modified = 1;\n            }\n        }\n        else {\n            return HTTP_PRECONDITION_FAILED;\n        }\n    }\n\n    /* If a valid If-Modified-Since request-header field was given\n     * AND it is a GET or HEAD request\n     * AND the requested resource has not been modified since the time\n     * specified in this field, then the server MUST\n     *    respond with a status of 304 (Not Modified).\n     * A date later than the server's current request time is invalid.\n     */\n    cond = ap_condition_if_modified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        if (r->method_number == M_GET) {\n            if (not_modified) {\n                not_modified = 1;\n            }\n        }\n    }\n\n    /* If an If-Range and an Range header is present, we must return\n     * 200 OK. The byterange filter will convert it to a range response.\n     */\n    cond = ap_condition_if_range(r, r->headers_out);\n    if (cond > AP_CONDITION_NONE) {\n        return OK;\n    }\n\n    if (not_modified == 1) {\n        return HTTP_NOT_MODIFIED;\n    }\n\n    return OK;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 563, column 17>"
          }
        },
        "used_macros": {
          "AP_CONDITION_NOMATCH": {
            "name": "AP_CONDITION_NOMATCH",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_NOMATCH = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 236, column 5>",
            "condition": ""
          },
          "AP_CONDITION_WEAK": {
            "name": "AP_CONDITION_WEAK",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_WEAK = 2",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 237, column 5>",
            "condition": ""
          },
          "AP_CONDITION_STRONG": {
            "name": "AP_CONDITION_STRONG",
            "value": "3",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_STRONG = 3",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 238, column 5>",
            "condition": ""
          },
          "AP_CONDITION_NONE": {
            "name": "AP_CONDITION_NONE",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_NONE = 0",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 235, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_table_t": {
            "name": "apr_table_t",
            "definition": "struct apr_table_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "ap_condition_e",
          "apr_int64_t",
          "apr_time_t"
        ]
      },
      "source_code": "AP_DECLARE(ap_condition_e) ap_condition_if_unmodified_since(request_rec *r,\n        apr_table_t *headers)\n{\n    const char *if_unmodified;\n\n    if_unmodified = apr_table_get(r->headers_in, \"If-Unmodified-Since\");\n    if (if_unmodified) {\n        apr_int64_t mtime, reqtime;\n\n        apr_time_t ius = apr_time_sec(apr_date_parse_http(if_unmodified));\n\n        /* All of our comparisons must be in seconds, because that's the\n         * highest time resolution the HTTP specification allows.\n         */\n        mtime = apr_time_sec(apr_date_parse_http(\n                        apr_table_get(headers, \"Last-Modified\")));\n        if (mtime == APR_DATE_BAD) {\n            mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n        }\n\n        reqtime = apr_time_sec(apr_date_parse_http(\n                        apr_table_get(headers, \"Date\")));\n        if (!reqtime) {\n            reqtime = apr_time_sec(r->request_time);\n        }\n\n        if ((ius != APR_DATE_BAD) && (mtime > ius)) {\n            if (reqtime < mtime + 60) {\n                if (apr_table_get(r->headers_in, \"Range\")) {\n                    /* weak matches not allowed with Range requests */\n                    return AP_CONDITION_NOMATCH;\n                }\n                else {\n                    return AP_CONDITION_WEAK;\n                }\n            }\n            else {\n                return AP_CONDITION_STRONG;\n            }\n        }\n        else {\n            return AP_CONDITION_NOMATCH;\n        }\n    }\n\n    return AP_CONDITION_NONE;\n}"
    },
    "ap_condition_if_none_match@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 414, column 28>": {
      "basic_info": {
        "function_id": 1641,
        "name": "ap_condition_if_none_match",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 414, column 28>",
        "is_definition": true,
        "start_line": 414,
        "end_line": 453,
        "return_type": "ap_condition_e",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "headers",
            "type": "apr_table_t *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "ap_find_etag_strong": {
            "declaration": "AP_DECLARE(int) ap_find_etag_strong(apr_pool_t *p, const char *line, const char *tok)",
            "is_external": true,
            "definition": null
          },
          "ap_find_etag_weak": {
            "declaration": "AP_DECLARE(int) ap_find_etag_weak(apr_pool_t *p, const char *line, const char *tok)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_meets_conditions@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 563, column 17>": {
            "source_code": "AP_DECLARE(int) ap_meets_conditions(request_rec *r)\n{\n    int not_modified = -1; /* unset by default */\n    ap_condition_e cond;\n\n    /* Check for conditional requests --- note that we only want to do\n     * this if we are successful so far and we are not processing a\n     * subrequest or an ErrorDocument.\n     *\n     * The order of the checks is important, since ETag checks are supposed\n     * to be more accurate than checks relative to the modification time.\n     * However, not all documents are guaranteed to *have* ETags, and some\n     * might have Last-Modified values w/o ETags, so this gets a little\n     * complicated.\n     */\n\n    if (!ap_is_HTTP_SUCCESS(r->status) || r->no_local_copy) {\n        return OK;\n    }\n\n    /* If an If-Match request-header field was given\n     * AND the field value is not \"*\" (meaning match anything)\n     * AND if our strong ETag does not match any entity tag in that field,\n     *     respond with a status of 412 (Precondition Failed).\n     */\n    cond = ap_condition_if_match(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        return HTTP_PRECONDITION_FAILED;\n    }\n\n    /* Else if a valid If-Unmodified-Since request-header field was given\n     * AND the requested resource has been modified since the time\n     * specified in this field, then the server MUST\n     *     respond with a status of 412 (Precondition Failed).\n     */\n    cond = ap_condition_if_unmodified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        return HTTP_PRECONDITION_FAILED;\n    }\n\n    /* If an If-None-Match request-header field was given\n     * AND the field value is \"*\" (meaning match anything)\n     *     OR our ETag matches any of the entity tags in that field, fail.\n     *\n     * If the request method was GET or HEAD, failure means the server\n     *    SHOULD respond with a 304 (Not Modified) response.\n     * For all other request methods, failure means the server MUST\n     *    respond with a status of 412 (Precondition Failed).\n     *\n     * GET or HEAD allow weak etag comparison, all other methods require\n     * strong comparison.  We can only use weak if it's not a range request.\n     */\n    cond = ap_condition_if_none_match(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        if (r->method_number == M_GET) {\n            if (not_modified) {\n                not_modified = 1;\n            }\n        }\n        else {\n            return HTTP_PRECONDITION_FAILED;\n        }\n    }\n\n    /* If a valid If-Modified-Since request-header field was given\n     * AND it is a GET or HEAD request\n     * AND the requested resource has not been modified since the time\n     * specified in this field, then the server MUST\n     *    respond with a status of 304 (Not Modified).\n     * A date later than the server's current request time is invalid.\n     */\n    cond = ap_condition_if_modified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        if (r->method_number == M_GET) {\n            if (not_modified) {\n                not_modified = 1;\n            }\n        }\n    }\n\n    /* If an If-Range and an Range header is present, we must return\n     * 200 OK. The byterange filter will convert it to a range response.\n     */\n    cond = ap_condition_if_range(r, r->headers_out);\n    if (cond > AP_CONDITION_NONE) {\n        return OK;\n    }\n\n    if (not_modified == 1) {\n        return HTTP_NOT_MODIFIED;\n    }\n\n    return OK;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 563, column 17>"
          }
        },
        "used_macros": {
          "AP_CONDITION_STRONG": {
            "name": "AP_CONDITION_STRONG",
            "value": "3",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_STRONG = 3",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 238, column 5>",
            "condition": ""
          },
          "AP_CONDITION_WEAK": {
            "name": "AP_CONDITION_WEAK",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_WEAK = 2",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 237, column 5>",
            "condition": ""
          },
          "AP_CONDITION_NOMATCH": {
            "name": "AP_CONDITION_NOMATCH",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_NOMATCH = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 236, column 5>",
            "condition": ""
          },
          "AP_CONDITION_NONE": {
            "name": "AP_CONDITION_NONE",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_NONE = 0",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 235, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_table_t": {
            "name": "apr_table_t",
            "definition": "struct apr_table_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "ap_condition_e"
        ]
      },
      "source_code": "AP_DECLARE(ap_condition_e) ap_condition_if_none_match(request_rec *r,\n        apr_table_t *headers)\n{\n    const char *if_nonematch, *etag;\n\n    if_nonematch = apr_table_get(r->headers_in, \"If-None-Match\");\n    if (if_nonematch != NULL) {\n\n        if (if_nonematch[0] == '*') {\n            return AP_CONDITION_STRONG;\n        }\n\n        /* See section 13.3.3 for rules on how to determine if two entities tags\n         * match. The weak comparison function can only be used with GET or HEAD\n         * requests.\n         */\n        if (r->method_number == M_GET) {\n            if ((etag = apr_table_get(headers, \"ETag\")) != NULL) {\n                if (apr_table_get(r->headers_in, \"Range\")) {\n                    if (ap_find_etag_strong(r->pool, if_nonematch, etag)) {\n                        return AP_CONDITION_STRONG;\n                    }\n                }\n                else {\n                    if (ap_find_etag_weak(r->pool, if_nonematch, etag)) {\n                        return AP_CONDITION_WEAK;\n                    }\n                }\n            }\n        }\n\n        else if ((etag = apr_table_get(headers, \"ETag\")) != NULL\n                && ap_find_etag_strong(r->pool, if_nonematch, etag)) {\n            return AP_CONDITION_STRONG;\n        }\n        return AP_CONDITION_NOMATCH;\n    }\n\n    return AP_CONDITION_NONE;\n}"
    },
    "ap_condition_if_modified_since@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 455, column 28>": {
      "basic_info": {
        "function_id": 1642,
        "name": "ap_condition_if_modified_since",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 455, column 28>",
        "is_definition": true,
        "start_line": 455,
        "end_line": 503,
        "return_type": "ap_condition_e",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "headers",
            "type": "apr_table_t *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "apr_date_parse_http": {
            "declaration": "APU_DECLARE(apr_time_t) apr_date_parse_http(const char *date)",
            "is_external": true,
            "definition": null
          },
          "apr_time_now": {
            "declaration": "APR_DECLARE(apr_time_t) apr_time_now(void)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_meets_conditions@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 563, column 17>": {
            "source_code": "AP_DECLARE(int) ap_meets_conditions(request_rec *r)\n{\n    int not_modified = -1; /* unset by default */\n    ap_condition_e cond;\n\n    /* Check for conditional requests --- note that we only want to do\n     * this if we are successful so far and we are not processing a\n     * subrequest or an ErrorDocument.\n     *\n     * The order of the checks is important, since ETag checks are supposed\n     * to be more accurate than checks relative to the modification time.\n     * However, not all documents are guaranteed to *have* ETags, and some\n     * might have Last-Modified values w/o ETags, so this gets a little\n     * complicated.\n     */\n\n    if (!ap_is_HTTP_SUCCESS(r->status) || r->no_local_copy) {\n        return OK;\n    }\n\n    /* If an If-Match request-header field was given\n     * AND the field value is not \"*\" (meaning match anything)\n     * AND if our strong ETag does not match any entity tag in that field,\n     *     respond with a status of 412 (Precondition Failed).\n     */\n    cond = ap_condition_if_match(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        return HTTP_PRECONDITION_FAILED;\n    }\n\n    /* Else if a valid If-Unmodified-Since request-header field was given\n     * AND the requested resource has been modified since the time\n     * specified in this field, then the server MUST\n     *     respond with a status of 412 (Precondition Failed).\n     */\n    cond = ap_condition_if_unmodified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        return HTTP_PRECONDITION_FAILED;\n    }\n\n    /* If an If-None-Match request-header field was given\n     * AND the field value is \"*\" (meaning match anything)\n     *     OR our ETag matches any of the entity tags in that field, fail.\n     *\n     * If the request method was GET or HEAD, failure means the server\n     *    SHOULD respond with a 304 (Not Modified) response.\n     * For all other request methods, failure means the server MUST\n     *    respond with a status of 412 (Precondition Failed).\n     *\n     * GET or HEAD allow weak etag comparison, all other methods require\n     * strong comparison.  We can only use weak if it's not a range request.\n     */\n    cond = ap_condition_if_none_match(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        if (r->method_number == M_GET) {\n            if (not_modified) {\n                not_modified = 1;\n            }\n        }\n        else {\n            return HTTP_PRECONDITION_FAILED;\n        }\n    }\n\n    /* If a valid If-Modified-Since request-header field was given\n     * AND it is a GET or HEAD request\n     * AND the requested resource has not been modified since the time\n     * specified in this field, then the server MUST\n     *    respond with a status of 304 (Not Modified).\n     * A date later than the server's current request time is invalid.\n     */\n    cond = ap_condition_if_modified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        if (r->method_number == M_GET) {\n            if (not_modified) {\n                not_modified = 1;\n            }\n        }\n    }\n\n    /* If an If-Range and an Range header is present, we must return\n     * 200 OK. The byterange filter will convert it to a range response.\n     */\n    cond = ap_condition_if_range(r, r->headers_out);\n    if (cond > AP_CONDITION_NONE) {\n        return OK;\n    }\n\n    if (not_modified == 1) {\n        return HTTP_NOT_MODIFIED;\n    }\n\n    return OK;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 563, column 17>"
          }
        },
        "used_macros": {
          "AP_CONDITION_NOMATCH": {
            "name": "AP_CONDITION_NOMATCH",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_NOMATCH = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 236, column 5>",
            "condition": ""
          },
          "AP_CONDITION_WEAK": {
            "name": "AP_CONDITION_WEAK",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_WEAK = 2",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 237, column 5>",
            "condition": ""
          },
          "AP_CONDITION_STRONG": {
            "name": "AP_CONDITION_STRONG",
            "value": "3",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_STRONG = 3",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 238, column 5>",
            "condition": ""
          },
          "AP_CONDITION_NONE": {
            "name": "AP_CONDITION_NONE",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_NONE = 0",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 235, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_table_t": {
            "name": "apr_table_t",
            "definition": "struct apr_table_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "ap_condition_e",
          "apr_int64_t",
          "apr_time_t"
        ]
      },
      "source_code": "AP_DECLARE(ap_condition_e) ap_condition_if_modified_since(request_rec *r,\n        apr_table_t *headers)\n{\n    const char *if_modified_since;\n\n    if ((if_modified_since = apr_table_get(r->headers_in, \"If-Modified-Since\"))\n            != NULL) {\n        apr_int64_t mtime;\n        apr_int64_t ims, reqtime;\n\n        /* All of our comparisons must be in seconds, because that's the\n         * highest time resolution the HTTP specification allows.\n         */\n\n        mtime = apr_time_sec(apr_date_parse_http(\n                        apr_table_get(headers, \"Last-Modified\")));\n        if (mtime == APR_DATE_BAD) {\n            mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n        }\n\n        reqtime = apr_time_sec(apr_date_parse_http(\n                        apr_table_get(headers, \"Date\")));\n        if (!reqtime) {\n            reqtime = apr_time_sec(r->request_time);\n        }\n\n        ims = apr_time_sec(apr_date_parse_http(if_modified_since));\n\n        if (ims >= mtime && ims <= reqtime) {\n            if (reqtime < mtime + 60) {\n                if (apr_table_get(r->headers_in, \"Range\")) {\n                    /* weak matches not allowed with Range requests */\n                    return AP_CONDITION_NOMATCH;\n                }\n                else {\n                    return AP_CONDITION_WEAK;\n                }\n            }\n            else {\n                return AP_CONDITION_STRONG;\n            }\n        }\n        else {\n            return AP_CONDITION_NOMATCH;\n        }\n    }\n\n    return AP_CONDITION_NONE;\n}"
    },
    "ap_condition_if_range@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 505, column 28>": {
      "basic_info": {
        "function_id": 1643,
        "name": "ap_condition_if_range",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 505, column 28>",
        "is_definition": true,
        "start_line": 505,
        "end_line": 561,
        "return_type": "ap_condition_e",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "headers",
            "type": "apr_table_t *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "strcmp": {
            "declaration": "extern int strcmp (const char *__s1, const char *__s2)\n     __THROW __attribute_pure__ __nonnull ((1, 2))",
            "is_external": true,
            "definition": null
          },
          "apr_date_parse_http": {
            "declaration": "APU_DECLARE(apr_time_t) apr_date_parse_http(const char *date)",
            "is_external": true,
            "definition": null
          },
          "apr_time_now": {
            "declaration": "APR_DECLARE(apr_time_t) apr_time_now(void)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_meets_conditions@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 563, column 17>": {
            "source_code": "AP_DECLARE(int) ap_meets_conditions(request_rec *r)\n{\n    int not_modified = -1; /* unset by default */\n    ap_condition_e cond;\n\n    /* Check for conditional requests --- note that we only want to do\n     * this if we are successful so far and we are not processing a\n     * subrequest or an ErrorDocument.\n     *\n     * The order of the checks is important, since ETag checks are supposed\n     * to be more accurate than checks relative to the modification time.\n     * However, not all documents are guaranteed to *have* ETags, and some\n     * might have Last-Modified values w/o ETags, so this gets a little\n     * complicated.\n     */\n\n    if (!ap_is_HTTP_SUCCESS(r->status) || r->no_local_copy) {\n        return OK;\n    }\n\n    /* If an If-Match request-header field was given\n     * AND the field value is not \"*\" (meaning match anything)\n     * AND if our strong ETag does not match any entity tag in that field,\n     *     respond with a status of 412 (Precondition Failed).\n     */\n    cond = ap_condition_if_match(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        return HTTP_PRECONDITION_FAILED;\n    }\n\n    /* Else if a valid If-Unmodified-Since request-header field was given\n     * AND the requested resource has been modified since the time\n     * specified in this field, then the server MUST\n     *     respond with a status of 412 (Precondition Failed).\n     */\n    cond = ap_condition_if_unmodified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        return HTTP_PRECONDITION_FAILED;\n    }\n\n    /* If an If-None-Match request-header field was given\n     * AND the field value is \"*\" (meaning match anything)\n     *     OR our ETag matches any of the entity tags in that field, fail.\n     *\n     * If the request method was GET or HEAD, failure means the server\n     *    SHOULD respond with a 304 (Not Modified) response.\n     * For all other request methods, failure means the server MUST\n     *    respond with a status of 412 (Precondition Failed).\n     *\n     * GET or HEAD allow weak etag comparison, all other methods require\n     * strong comparison.  We can only use weak if it's not a range request.\n     */\n    cond = ap_condition_if_none_match(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        if (r->method_number == M_GET) {\n            if (not_modified) {\n                not_modified = 1;\n            }\n        }\n        else {\n            return HTTP_PRECONDITION_FAILED;\n        }\n    }\n\n    /* If a valid If-Modified-Since request-header field was given\n     * AND it is a GET or HEAD request\n     * AND the requested resource has not been modified since the time\n     * specified in this field, then the server MUST\n     *    respond with a status of 304 (Not Modified).\n     * A date later than the server's current request time is invalid.\n     */\n    cond = ap_condition_if_modified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        if (r->method_number == M_GET) {\n            if (not_modified) {\n                not_modified = 1;\n            }\n        }\n    }\n\n    /* If an If-Range and an Range header is present, we must return\n     * 200 OK. The byterange filter will convert it to a range response.\n     */\n    cond = ap_condition_if_range(r, r->headers_out);\n    if (cond > AP_CONDITION_NONE) {\n        return OK;\n    }\n\n    if (not_modified == 1) {\n        return HTTP_NOT_MODIFIED;\n    }\n\n    return OK;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 563, column 17>"
          }
        },
        "used_macros": {
          "AP_CONDITION_STRONG": {
            "name": "AP_CONDITION_STRONG",
            "value": "3",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_STRONG = 3",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 238, column 5>",
            "condition": ""
          },
          "AP_CONDITION_NOMATCH": {
            "name": "AP_CONDITION_NOMATCH",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_NOMATCH = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 236, column 5>",
            "condition": ""
          },
          "AP_CONDITION_NONE": {
            "name": "AP_CONDITION_NONE",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_NONE = 0",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 235, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_table_t": {
            "name": "apr_table_t",
            "definition": "struct apr_table_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "ap_condition_e",
          "apr_int64_t",
          "apr_time_t"
        ]
      },
      "source_code": "AP_DECLARE(ap_condition_e) ap_condition_if_range(request_rec *r,\n        apr_table_t *headers)\n{\n    const char *if_range, *etag;\n\n    if ((if_range = apr_table_get(r->headers_in, \"If-Range\"))\n            && apr_table_get(r->headers_in, \"Range\")) {\n        if (if_range[0] == '\"') {\n\n            if ((etag = apr_table_get(headers, \"ETag\"))\n                    && !strcmp(if_range, etag)) {\n                return AP_CONDITION_STRONG;\n            }\n            else {\n                return AP_CONDITION_NOMATCH;\n            }\n\n        }\n        else {\n            apr_int64_t mtime;\n            apr_int64_t rtime, reqtime;\n\n            /* All of our comparisons must be in seconds, because that's the\n             * highest time resolution the HTTP specification allows.\n             */\n\n            mtime = apr_time_sec(apr_date_parse_http(\n                            apr_table_get(headers, \"Last-Modified\")));\n            if (mtime == APR_DATE_BAD) {\n                mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n            }\n\n            reqtime = apr_time_sec(apr_date_parse_http(\n                            apr_table_get(headers, \"Date\")));\n            if (!reqtime) {\n                reqtime = apr_time_sec(r->request_time);\n            }\n\n            rtime = apr_time_sec(apr_date_parse_http(if_range));\n\n            if (rtime == mtime) {\n                if (reqtime < mtime + 60) {\n                    /* weak matches not allowed with Range requests */\n                    return AP_CONDITION_NOMATCH;\n                }\n                else {\n                    return AP_CONDITION_STRONG;\n                }\n            }\n            else {\n                return AP_CONDITION_NOMATCH;\n            }\n        }\n    }\n\n    return AP_CONDITION_NONE;\n}"
    },
    "ap_meets_conditions@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 563, column 17>": {
      "basic_info": {
        "function_id": 1644,
        "name": "ap_meets_conditions",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 563, column 17>",
        "is_definition": true,
        "start_line": 563,
        "end_line": 665,
        "return_type": "int",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_condition_if_match": {
            "declaration": "AP_DECLARE(ap_condition_e) ap_condition_if_match(request_rec *r,\n        apr_table_t *headers)\n{\n    const char *if_match, *etag;\n\n    /* A server MUST use the strong comparison function (see section 13.3.3)\n     * to compare the entity tags in If-Match.\n     */\n    if ((if_match = apr_table_get(r->headers_in, \"If-Match\")) != NULL) {\n        if (if_match[0] == '*'\n                || ((etag = apr_table_get(headers, \"ETag\")) != NULL\n                        && ap_find_etag_strong(r->pool, if_match, etag))) {\n            return AP_CONDITION_STRONG;\n        }\n        else {\n            return AP_CONDITION_NOMATCH;\n        }\n    }\n\n    return AP_CONDITION_NONE;\n}",
            "is_external": false,
            "definition": "AP_DECLARE(ap_condition_e) ap_condition_if_match(request_rec *r,\n        apr_table_t *headers)\n{\n    const char *if_match, *etag;\n\n    /* A server MUST use the strong comparison function (see section 13.3.3)\n     * to compare the entity tags in If-Match.\n     */\n    if ((if_match = apr_table_get(r->headers_in, \"If-Match\")) != NULL) {\n        if (if_match[0] == '*'\n                || ((etag = apr_table_get(headers, \"ETag\")) != NULL\n                        && ap_find_etag_strong(r->pool, if_match, etag))) {\n            return AP_CONDITION_STRONG;\n        }\n        else {\n            return AP_CONDITION_NOMATCH;\n        }\n    }\n\n    return AP_CONDITION_NONE;\n}"
          },
          "ap_condition_if_unmodified_since": {
            "declaration": "AP_DECLARE(ap_condition_e) ap_condition_if_unmodified_since(request_rec *r,\n        apr_table_t *headers)\n{\n    const char *if_unmodified;\n\n    if_unmodified = apr_table_get(r->headers_in, \"If-Unmodified-Since\");\n    if (if_unmodified) {\n        apr_int64_t mtime, reqtime;\n\n        apr_time_t ius = apr_time_sec(apr_date_parse_http(if_unmodified));\n\n        /* All of our comparisons must be in seconds, because that's the\n         * highest time resolution the HTTP specification allows.\n         */\n        mtime = apr_time_sec(apr_date_parse_http(\n                        apr_table_get(headers, \"Last-Modified\")));\n        if (mtime == APR_DATE_BAD) {\n            mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n        }\n\n        reqtime = apr_time_sec(apr_date_parse_http(\n                        apr_table_get(headers, \"Date\")));\n        if (!reqtime) {\n            reqtime = apr_time_sec(r->request_time);\n        }\n\n        if ((ius != APR_DATE_BAD) && (mtime > ius)) {\n            if (reqtime < mtime + 60) {\n                if (apr_table_get(r->headers_in, \"Range\")) {\n                    /* weak matches not allowed with Range requests */\n                    return AP_CONDITION_NOMATCH;\n                }\n                else {\n                    return AP_CONDITION_WEAK;\n                }\n            }\n            else {\n                return AP_CONDITION_STRONG;\n            }\n        }\n        else {\n            return AP_CONDITION_NOMATCH;\n        }\n    }\n\n    return AP_CONDITION_NONE;\n}",
            "is_external": false,
            "definition": "AP_DECLARE(ap_condition_e) ap_condition_if_unmodified_since(request_rec *r,\n        apr_table_t *headers)\n{\n    const char *if_unmodified;\n\n    if_unmodified = apr_table_get(r->headers_in, \"If-Unmodified-Since\");\n    if (if_unmodified) {\n        apr_int64_t mtime, reqtime;\n\n        apr_time_t ius = apr_time_sec(apr_date_parse_http(if_unmodified));\n\n        /* All of our comparisons must be in seconds, because that's the\n         * highest time resolution the HTTP specification allows.\n         */\n        mtime = apr_time_sec(apr_date_parse_http(\n                        apr_table_get(headers, \"Last-Modified\")));\n        if (mtime == APR_DATE_BAD) {\n            mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n        }\n\n        reqtime = apr_time_sec(apr_date_parse_http(\n                        apr_table_get(headers, \"Date\")));\n        if (!reqtime) {\n            reqtime = apr_time_sec(r->request_time);\n        }\n\n        if ((ius != APR_DATE_BAD) && (mtime > ius)) {\n            if (reqtime < mtime + 60) {\n                if (apr_table_get(r->headers_in, \"Range\")) {\n                    /* weak matches not allowed with Range requests */\n                    return AP_CONDITION_NOMATCH;\n                }\n                else {\n                    return AP_CONDITION_WEAK;\n                }\n            }\n            else {\n                return AP_CONDITION_STRONG;\n            }\n        }\n        else {\n            return AP_CONDITION_NOMATCH;\n        }\n    }\n\n    return AP_CONDITION_NONE;\n}"
          },
          "ap_condition_if_none_match": {
            "declaration": "AP_DECLARE(ap_condition_e) ap_condition_if_none_match(request_rec *r,\n        apr_table_t *headers)\n{\n    const char *if_nonematch, *etag;\n\n    if_nonematch = apr_table_get(r->headers_in, \"If-None-Match\");\n    if (if_nonematch != NULL) {\n\n        if (if_nonematch[0] == '*') {\n            return AP_CONDITION_STRONG;\n        }\n\n        /* See section 13.3.3 for rules on how to determine if two entities tags\n         * match. The weak comparison function can only be used with GET or HEAD\n         * requests.\n         */\n        if (r->method_number == M_GET) {\n            if ((etag = apr_table_get(headers, \"ETag\")) != NULL) {\n                if (apr_table_get(r->headers_in, \"Range\")) {\n                    if (ap_find_etag_strong(r->pool, if_nonematch, etag)) {\n                        return AP_CONDITION_STRONG;\n                    }\n                }\n                else {\n                    if (ap_find_etag_weak(r->pool, if_nonematch, etag)) {\n                        return AP_CONDITION_WEAK;\n                    }\n                }\n            }\n        }\n\n        else if ((etag = apr_table_get(headers, \"ETag\")) != NULL\n                && ap_find_etag_strong(r->pool, if_nonematch, etag)) {\n            return AP_CONDITION_STRONG;\n        }\n        return AP_CONDITION_NOMATCH;\n    }\n\n    return AP_CONDITION_NONE;\n}",
            "is_external": false,
            "definition": "AP_DECLARE(ap_condition_e) ap_condition_if_none_match(request_rec *r,\n        apr_table_t *headers)\n{\n    const char *if_nonematch, *etag;\n\n    if_nonematch = apr_table_get(r->headers_in, \"If-None-Match\");\n    if (if_nonematch != NULL) {\n\n        if (if_nonematch[0] == '*') {\n            return AP_CONDITION_STRONG;\n        }\n\n        /* See section 13.3.3 for rules on how to determine if two entities tags\n         * match. The weak comparison function can only be used with GET or HEAD\n         * requests.\n         */\n        if (r->method_number == M_GET) {\n            if ((etag = apr_table_get(headers, \"ETag\")) != NULL) {\n                if (apr_table_get(r->headers_in, \"Range\")) {\n                    if (ap_find_etag_strong(r->pool, if_nonematch, etag)) {\n                        return AP_CONDITION_STRONG;\n                    }\n                }\n                else {\n                    if (ap_find_etag_weak(r->pool, if_nonematch, etag)) {\n                        return AP_CONDITION_WEAK;\n                    }\n                }\n            }\n        }\n\n        else if ((etag = apr_table_get(headers, \"ETag\")) != NULL\n                && ap_find_etag_strong(r->pool, if_nonematch, etag)) {\n            return AP_CONDITION_STRONG;\n        }\n        return AP_CONDITION_NOMATCH;\n    }\n\n    return AP_CONDITION_NONE;\n}"
          },
          "ap_condition_if_modified_since": {
            "declaration": "AP_DECLARE(ap_condition_e) ap_condition_if_modified_since(request_rec *r,\n        apr_table_t *headers)\n{\n    const char *if_modified_since;\n\n    if ((if_modified_since = apr_table_get(r->headers_in, \"If-Modified-Since\"))\n            != NULL) {\n        apr_int64_t mtime;\n        apr_int64_t ims, reqtime;\n\n        /* All of our comparisons must be in seconds, because that's the\n         * highest time resolution the HTTP specification allows.\n         */\n\n        mtime = apr_time_sec(apr_date_parse_http(\n                        apr_table_get(headers, \"Last-Modified\")));\n        if (mtime == APR_DATE_BAD) {\n            mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n        }\n\n        reqtime = apr_time_sec(apr_date_parse_http(\n                        apr_table_get(headers, \"Date\")));\n        if (!reqtime) {\n            reqtime = apr_time_sec(r->request_time);\n        }\n\n        ims = apr_time_sec(apr_date_parse_http(if_modified_since));\n\n        if (ims >= mtime && ims <= reqtime) {\n            if (reqtime < mtime + 60) {\n                if (apr_table_get(r->headers_in, \"Range\")) {\n                    /* weak matches not allowed with Range requests */\n                    return AP_CONDITION_NOMATCH;\n                }\n                else {\n                    return AP_CONDITION_WEAK;\n                }\n            }\n            else {\n                return AP_CONDITION_STRONG;\n            }\n        }\n        else {\n            return AP_CONDITION_NOMATCH;\n        }\n    }\n\n    return AP_CONDITION_NONE;\n}",
            "is_external": false,
            "definition": "AP_DECLARE(ap_condition_e) ap_condition_if_modified_since(request_rec *r,\n        apr_table_t *headers)\n{\n    const char *if_modified_since;\n\n    if ((if_modified_since = apr_table_get(r->headers_in, \"If-Modified-Since\"))\n            != NULL) {\n        apr_int64_t mtime;\n        apr_int64_t ims, reqtime;\n\n        /* All of our comparisons must be in seconds, because that's the\n         * highest time resolution the HTTP specification allows.\n         */\n\n        mtime = apr_time_sec(apr_date_parse_http(\n                        apr_table_get(headers, \"Last-Modified\")));\n        if (mtime == APR_DATE_BAD) {\n            mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n        }\n\n        reqtime = apr_time_sec(apr_date_parse_http(\n                        apr_table_get(headers, \"Date\")));\n        if (!reqtime) {\n            reqtime = apr_time_sec(r->request_time);\n        }\n\n        ims = apr_time_sec(apr_date_parse_http(if_modified_since));\n\n        if (ims >= mtime && ims <= reqtime) {\n            if (reqtime < mtime + 60) {\n                if (apr_table_get(r->headers_in, \"Range\")) {\n                    /* weak matches not allowed with Range requests */\n                    return AP_CONDITION_NOMATCH;\n                }\n                else {\n                    return AP_CONDITION_WEAK;\n                }\n            }\n            else {\n                return AP_CONDITION_STRONG;\n            }\n        }\n        else {\n            return AP_CONDITION_NOMATCH;\n        }\n    }\n\n    return AP_CONDITION_NONE;\n}"
          },
          "ap_condition_if_range": {
            "declaration": "AP_DECLARE(ap_condition_e) ap_condition_if_range(request_rec *r,\n        apr_table_t *headers)\n{\n    const char *if_range, *etag;\n\n    if ((if_range = apr_table_get(r->headers_in, \"If-Range\"))\n            && apr_table_get(r->headers_in, \"Range\")) {\n        if (if_range[0] == '\"') {\n\n            if ((etag = apr_table_get(headers, \"ETag\"))\n                    && !strcmp(if_range, etag)) {\n                return AP_CONDITION_STRONG;\n            }\n            else {\n                return AP_CONDITION_NOMATCH;\n            }\n\n        }\n        else {\n            apr_int64_t mtime;\n            apr_int64_t rtime, reqtime;\n\n            /* All of our comparisons must be in seconds, because that's the\n             * highest time resolution the HTTP specification allows.\n             */\n\n            mtime = apr_time_sec(apr_date_parse_http(\n                            apr_table_get(headers, \"Last-Modified\")));\n            if (mtime == APR_DATE_BAD) {\n                mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n            }\n\n            reqtime = apr_time_sec(apr_date_parse_http(\n                            apr_table_get(headers, \"Date\")));\n            if (!reqtime) {\n                reqtime = apr_time_sec(r->request_time);\n            }\n\n            rtime = apr_time_sec(apr_date_parse_http(if_range));\n\n            if (rtime == mtime) {\n                if (reqtime < mtime + 60) {\n                    /* weak matches not allowed with Range requests */\n                    return AP_CONDITION_NOMATCH;\n                }\n                else {\n                    return AP_CONDITION_STRONG;\n                }\n            }\n            else {\n                return AP_CONDITION_NOMATCH;\n            }\n        }\n    }\n\n    return AP_CONDITION_NONE;\n}",
            "is_external": false,
            "definition": "AP_DECLARE(ap_condition_e) ap_condition_if_range(request_rec *r,\n        apr_table_t *headers)\n{\n    const char *if_range, *etag;\n\n    if ((if_range = apr_table_get(r->headers_in, \"If-Range\"))\n            && apr_table_get(r->headers_in, \"Range\")) {\n        if (if_range[0] == '\"') {\n\n            if ((etag = apr_table_get(headers, \"ETag\"))\n                    && !strcmp(if_range, etag)) {\n                return AP_CONDITION_STRONG;\n            }\n            else {\n                return AP_CONDITION_NOMATCH;\n            }\n\n        }\n        else {\n            apr_int64_t mtime;\n            apr_int64_t rtime, reqtime;\n\n            /* All of our comparisons must be in seconds, because that's the\n             * highest time resolution the HTTP specification allows.\n             */\n\n            mtime = apr_time_sec(apr_date_parse_http(\n                            apr_table_get(headers, \"Last-Modified\")));\n            if (mtime == APR_DATE_BAD) {\n                mtime = apr_time_sec(r->mtime ? r->mtime : apr_time_now());\n            }\n\n            reqtime = apr_time_sec(apr_date_parse_http(\n                            apr_table_get(headers, \"Date\")));\n            if (!reqtime) {\n                reqtime = apr_time_sec(r->request_time);\n            }\n\n            rtime = apr_time_sec(apr_date_parse_http(if_range));\n\n            if (rtime == mtime) {\n                if (reqtime < mtime + 60) {\n                    /* weak matches not allowed with Range requests */\n                    return AP_CONDITION_NOMATCH;\n                }\n                else {\n                    return AP_CONDITION_STRONG;\n                }\n            }\n            else {\n                return AP_CONDITION_NOMATCH;\n            }\n        }\n    }\n\n    return AP_CONDITION_NONE;\n}"
          }
        },
        "callers": {},
        "used_macros": {
          "AP_CONDITION_NOMATCH": {
            "name": "AP_CONDITION_NOMATCH",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_NOMATCH = 1",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 236, column 5>",
            "condition": ""
          },
          "AP_CONDITION_WEAK": {
            "name": "AP_CONDITION_WEAK",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_WEAK = 2",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 237, column 5>",
            "condition": ""
          },
          "AP_CONDITION_NONE": {
            "name": "AP_CONDITION_NONE",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum ap_condition_e AP_CONDITION_NONE = 0",
            "location": "<SourceLocation file '/data/a/ykw/httpd/include/http_protocol.h', line 235, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "ap_condition_e"
        ]
      },
      "source_code": "AP_DECLARE(int) ap_meets_conditions(request_rec *r)\n{\n    int not_modified = -1; /* unset by default */\n    ap_condition_e cond;\n\n    /* Check for conditional requests --- note that we only want to do\n     * this if we are successful so far and we are not processing a\n     * subrequest or an ErrorDocument.\n     *\n     * The order of the checks is important, since ETag checks are supposed\n     * to be more accurate than checks relative to the modification time.\n     * However, not all documents are guaranteed to *have* ETags, and some\n     * might have Last-Modified values w/o ETags, so this gets a little\n     * complicated.\n     */\n\n    if (!ap_is_HTTP_SUCCESS(r->status) || r->no_local_copy) {\n        return OK;\n    }\n\n    /* If an If-Match request-header field was given\n     * AND the field value is not \"*\" (meaning match anything)\n     * AND if our strong ETag does not match any entity tag in that field,\n     *     respond with a status of 412 (Precondition Failed).\n     */\n    cond = ap_condition_if_match(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        return HTTP_PRECONDITION_FAILED;\n    }\n\n    /* Else if a valid If-Unmodified-Since request-header field was given\n     * AND the requested resource has been modified since the time\n     * specified in this field, then the server MUST\n     *     respond with a status of 412 (Precondition Failed).\n     */\n    cond = ap_condition_if_unmodified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        return HTTP_PRECONDITION_FAILED;\n    }\n\n    /* If an If-None-Match request-header field was given\n     * AND the field value is \"*\" (meaning match anything)\n     *     OR our ETag matches any of the entity tags in that field, fail.\n     *\n     * If the request method was GET or HEAD, failure means the server\n     *    SHOULD respond with a 304 (Not Modified) response.\n     * For all other request methods, failure means the server MUST\n     *    respond with a status of 412 (Precondition Failed).\n     *\n     * GET or HEAD allow weak etag comparison, all other methods require\n     * strong comparison.  We can only use weak if it's not a range request.\n     */\n    cond = ap_condition_if_none_match(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        if (r->method_number == M_GET) {\n            if (not_modified) {\n                not_modified = 1;\n            }\n        }\n        else {\n            return HTTP_PRECONDITION_FAILED;\n        }\n    }\n\n    /* If a valid If-Modified-Since request-header field was given\n     * AND it is a GET or HEAD request\n     * AND the requested resource has not been modified since the time\n     * specified in this field, then the server MUST\n     *    respond with a status of 304 (Not Modified).\n     * A date later than the server's current request time is invalid.\n     */\n    cond = ap_condition_if_modified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        if (r->method_number == M_GET) {\n            if (not_modified) {\n                not_modified = 1;\n            }\n        }\n    }\n\n    /* If an If-Range and an Range header is present, we must return\n     * 200 OK. The byterange filter will convert it to a range response.\n     */\n    cond = ap_condition_if_range(r, r->headers_out);\n    if (cond > AP_CONDITION_NONE) {\n        return OK;\n    }\n\n    if (not_modified == 1) {\n        return HTTP_NOT_MODIFIED;\n    }\n\n    return OK;\n}"
    },
    "register_one_method@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 679, column 13>": {
      "basic_info": {
        "function_id": 1645,
        "name": "register_one_method",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 679, column 13>",
        "is_definition": true,
        "start_line": 679,
        "end_line": 686,
        "return_type": "void",
        "parameters": [
          {
            "name": "p",
            "type": "apr_pool_t *"
          },
          {
            "name": "methname",
            "type": "const char *"
          },
          {
            "name": "methnum",
            "type": "int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "apr_hash_set": {
            "declaration": "APR_DECLARE(void) apr_hash_set(apr_hash_t *ht, const void *key,\n                               apr_ssize_t klen, const void *val)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_method_register@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 738, column 17>": {
            "source_code": "AP_DECLARE(int) ap_method_register(apr_pool_t *p, const char *methname)\n{\n    int *methnum;\n\n    if (methname == NULL) {\n        return M_INVALID;\n    }\n\n    /* Check if the method was previously registered.  If it was\n     * return the associated method number.\n     */\n    methnum = (int *)apr_hash_get(methods_registry, methname,\n                                  APR_HASH_KEY_STRING);\n    if (methnum != NULL)\n        return *methnum;\n\n    if (cur_method_number > METHOD_NUMBER_LAST) {\n        /* The method registry  has run out of dynamically\n         * assignable method numbers. Log this and return M_INVALID.\n         */\n        ap_log_perror(APLOG_MARK, APLOG_ERR, 0, p, APLOGNO(01610)\n                      \"Maximum new request methods %d reached while \"\n                      \"registering method %s.\",\n                      METHOD_NUMBER_LAST, methname);\n        return M_INVALID;\n    }\n\n    register_one_method(p, methname, cur_method_number);\n    return cur_method_number++;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 738, column 17>"
          },
          "ap_method_registry_init@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 698, column 18>": {
            "source_code": "AP_DECLARE(void) ap_method_registry_init(apr_pool_t *p)\n{\n    methods_registry = apr_hash_make(p);\n    apr_pool_cleanup_register(p, NULL,\n                              ap_method_registry_destroy,\n                              apr_pool_cleanup_null);\n\n    /* put all the standard methods into the registry hash to ease the\n     * mapping operations between name and number\n     * HEAD is a special-instance of the GET method and shares the same ID\n     */\n    register_one_method(p, \"GET\", M_GET);\n    register_one_method(p, \"HEAD\", M_GET);\n    register_one_method(p, \"PUT\", M_PUT);\n    register_one_method(p, \"POST\", M_POST);\n    register_one_method(p, \"DELETE\", M_DELETE);\n    register_one_method(p, \"CONNECT\", M_CONNECT);\n    register_one_method(p, \"OPTIONS\", M_OPTIONS);\n    register_one_method(p, \"TRACE\", M_TRACE);\n    register_one_method(p, \"PATCH\", M_PATCH);\n    register_one_method(p, \"PROPFIND\", M_PROPFIND);\n    register_one_method(p, \"PROPPATCH\", M_PROPPATCH);\n    register_one_method(p, \"MKCOL\", M_MKCOL);\n    register_one_method(p, \"COPY\", M_COPY);\n    register_one_method(p, \"MOVE\", M_MOVE);\n    register_one_method(p, \"LOCK\", M_LOCK);\n    register_one_method(p, \"UNLOCK\", M_UNLOCK);\n    register_one_method(p, \"VERSION-CONTROL\", M_VERSION_CONTROL);\n    register_one_method(p, \"CHECKOUT\", M_CHECKOUT);\n    register_one_method(p, \"UNCHECKOUT\", M_UNCHECKOUT);\n    register_one_method(p, \"CHECKIN\", M_CHECKIN);\n    register_one_method(p, \"UPDATE\", M_UPDATE);\n    register_one_method(p, \"LABEL\", M_LABEL);\n    register_one_method(p, \"REPORT\", M_REPORT);\n    register_one_method(p, \"MKWORKSPACE\", M_MKWORKSPACE);\n    register_one_method(p, \"MKACTIVITY\", M_MKACTIVITY);\n    register_one_method(p, \"BASELINE-CONTROL\", M_BASELINE_CONTROL);\n    register_one_method(p, \"MERGE\", M_MERGE);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 698, column 18>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {
          "methods_registry": {
            "name": "methods_registry",
            "type": "apr_hash_t *",
            "is_extern": false,
            "is_static": true,
            "definition": "static apr_hash_t *methods_registry = NULL",
            "initializer": "NULL",
            "full_definition": "static apr_hash_t *methods_registry = NULL",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "static void register_one_method(apr_pool_t *p, const char *methname,\n                                int methnum)\n{\n    int *pnum = apr_palloc(p, sizeof(*pnum));\n\n    *pnum = methnum;\n    apr_hash_set(methods_registry, methname, APR_HASH_KEY_STRING, pnum);\n}"
    },
    "ap_method_registry_destroy@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 691, column 21>": {
      "basic_info": {
        "function_id": 1646,
        "name": "ap_method_registry_destroy",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 691, column 21>",
        "is_definition": true,
        "start_line": 691,
        "end_line": 696,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "notused",
            "type": "void *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {},
        "callers": {},
        "used_macros": {},
        "used_structs": {},
        "used_globals": {
          "methods_registry": {
            "name": "methods_registry",
            "type": "apr_hash_t *",
            "is_extern": false,
            "is_static": true,
            "definition": "static apr_hash_t *methods_registry = NULL",
            "initializer": "NULL",
            "full_definition": "static apr_hash_t *methods_registry = NULL",
            "used_macros": {},
            "condition": ""
          },
          "cur_method_number": {
            "name": "cur_method_number",
            "type": "int",
            "is_extern": false,
            "is_static": true,
            "definition": "static int cur_method_number = METHOD_NUMBER_FIRST",
            "initializer": "METHOD_NUMBER_FIRST",
            "full_definition": "static int cur_method_number = METHOD_NUMBER_FIRST",
            "used_macros": {
              "METHOD_NUMBER_FIRST": {
                "name": "METHOD_NUMBER_FIRST",
                "value": "(M_INVALID + 1)",
                "definition": "#define METHOD_NUMBER_FIRST (M_INVALID + 1)"
              }
            },
            "condition": ""
          }
        },
        "used_typedefs": [
          "apr_status_t"
        ]
      },
      "source_code": "static apr_status_t ap_method_registry_destroy(void *notused)\n{\n    methods_registry = NULL;\n    cur_method_number = METHOD_NUMBER_FIRST;\n    return APR_SUCCESS;\n}"
    },
    "ap_method_registry_init@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 698, column 18>": {
      "basic_info": {
        "function_id": 1647,
        "name": "ap_method_registry_init",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 698, column 18>",
        "is_definition": true,
        "start_line": 698,
        "end_line": 736,
        "return_type": "void",
        "parameters": [
          {
            "name": "p",
            "type": "apr_pool_t *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_hash_make": {
            "declaration": "APR_DECLARE(apr_hash_t *) apr_hash_make(apr_pool_t *pool)",
            "is_external": true,
            "definition": null
          },
          "apr_pool_cleanup_register": {
            "declaration": "APR_DECLARE(void) apr_pool_cleanup_register(\n                            apr_pool_t *p, const void *data,\n                            apr_status_t (*plain_cleanup)(void *),\n                            apr_status_t (*child_cleanup)(void *))\n                  __attribute__((nonnull(3,4)))",
            "is_external": true,
            "definition": null
          },
          "register_one_method": {
            "declaration": "static void register_one_method(apr_pool_t *p, const char *methname,\n                                int methnum)\n{\n    int *pnum = apr_palloc(p, sizeof(*pnum));\n\n    *pnum = methnum;\n    apr_hash_set(methods_registry, methname, APR_HASH_KEY_STRING, pnum);\n}",
            "is_external": false,
            "definition": "static void register_one_method(apr_pool_t *p, const char *methname,\n                                int methnum)\n{\n    int *pnum = apr_palloc(p, sizeof(*pnum));\n\n    *pnum = methnum;\n    apr_hash_set(methods_registry, methname, APR_HASH_KEY_STRING, pnum);\n}"
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {
          "methods_registry": {
            "name": "methods_registry",
            "type": "apr_hash_t *",
            "is_extern": false,
            "is_static": true,
            "definition": "static apr_hash_t *methods_registry = NULL",
            "initializer": "NULL",
            "full_definition": "static apr_hash_t *methods_registry = NULL",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(void) ap_method_registry_init(apr_pool_t *p)\n{\n    methods_registry = apr_hash_make(p);\n    apr_pool_cleanup_register(p, NULL,\n                              ap_method_registry_destroy,\n                              apr_pool_cleanup_null);\n\n    /* put all the standard methods into the registry hash to ease the\n     * mapping operations between name and number\n     * HEAD is a special-instance of the GET method and shares the same ID\n     */\n    register_one_method(p, \"GET\", M_GET);\n    register_one_method(p, \"HEAD\", M_GET);\n    register_one_method(p, \"PUT\", M_PUT);\n    register_one_method(p, \"POST\", M_POST);\n    register_one_method(p, \"DELETE\", M_DELETE);\n    register_one_method(p, \"CONNECT\", M_CONNECT);\n    register_one_method(p, \"OPTIONS\", M_OPTIONS);\n    register_one_method(p, \"TRACE\", M_TRACE);\n    register_one_method(p, \"PATCH\", M_PATCH);\n    register_one_method(p, \"PROPFIND\", M_PROPFIND);\n    register_one_method(p, \"PROPPATCH\", M_PROPPATCH);\n    register_one_method(p, \"MKCOL\", M_MKCOL);\n    register_one_method(p, \"COPY\", M_COPY);\n    register_one_method(p, \"MOVE\", M_MOVE);\n    register_one_method(p, \"LOCK\", M_LOCK);\n    register_one_method(p, \"UNLOCK\", M_UNLOCK);\n    register_one_method(p, \"VERSION-CONTROL\", M_VERSION_CONTROL);\n    register_one_method(p, \"CHECKOUT\", M_CHECKOUT);\n    register_one_method(p, \"UNCHECKOUT\", M_UNCHECKOUT);\n    register_one_method(p, \"CHECKIN\", M_CHECKIN);\n    register_one_method(p, \"UPDATE\", M_UPDATE);\n    register_one_method(p, \"LABEL\", M_LABEL);\n    register_one_method(p, \"REPORT\", M_REPORT);\n    register_one_method(p, \"MKWORKSPACE\", M_MKWORKSPACE);\n    register_one_method(p, \"MKACTIVITY\", M_MKACTIVITY);\n    register_one_method(p, \"BASELINE-CONTROL\", M_BASELINE_CONTROL);\n    register_one_method(p, \"MERGE\", M_MERGE);\n}"
    },
    "ap_method_register@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 738, column 17>": {
      "basic_info": {
        "function_id": 1648,
        "name": "ap_method_register",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 738, column 17>",
        "is_definition": true,
        "start_line": 738,
        "end_line": 767,
        "return_type": "int",
        "parameters": [
          {
            "name": "p",
            "type": "apr_pool_t *"
          },
          {
            "name": "methname",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_hash_get": {
            "declaration": "APR_DECLARE(void *) apr_hash_get(apr_hash_t *ht, const void *key,\n                                 apr_ssize_t klen)",
            "is_external": true,
            "definition": null
          },
          "ap_log_perror_": {
            "declaration": "AP_DECLARE(void) ap_log_perror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status, apr_pool_t *p,\n                                const char *fmt, ...)\n                               __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "register_one_method": {
            "declaration": "static void register_one_method(apr_pool_t *p, const char *methname,\n                                int methnum)\n{\n    int *pnum = apr_palloc(p, sizeof(*pnum));\n\n    *pnum = methnum;\n    apr_hash_set(methods_registry, methname, APR_HASH_KEY_STRING, pnum);\n}",
            "is_external": false,
            "definition": "static void register_one_method(apr_pool_t *p, const char *methname,\n                                int methnum)\n{\n    int *pnum = apr_palloc(p, sizeof(*pnum));\n\n    *pnum = methnum;\n    apr_hash_set(methods_registry, methname, APR_HASH_KEY_STRING, pnum);\n}"
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {
          "methods_registry": {
            "name": "methods_registry",
            "type": "apr_hash_t *",
            "is_extern": false,
            "is_static": true,
            "definition": "static apr_hash_t *methods_registry = NULL",
            "initializer": "NULL",
            "full_definition": "static apr_hash_t *methods_registry = NULL",
            "used_macros": {},
            "condition": ""
          },
          "cur_method_number": {
            "name": "cur_method_number",
            "type": "int",
            "is_extern": false,
            "is_static": true,
            "definition": "static int cur_method_number = METHOD_NUMBER_FIRST",
            "initializer": "METHOD_NUMBER_FIRST",
            "full_definition": "static int cur_method_number = METHOD_NUMBER_FIRST",
            "used_macros": {
              "METHOD_NUMBER_FIRST": {
                "name": "METHOD_NUMBER_FIRST",
                "value": "(M_INVALID + 1)",
                "definition": "#define METHOD_NUMBER_FIRST (M_INVALID + 1)"
              }
            },
            "condition": ""
          },
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(int) ap_method_register(apr_pool_t *p, const char *methname)\n{\n    int *methnum;\n\n    if (methname == NULL) {\n        return M_INVALID;\n    }\n\n    /* Check if the method was previously registered.  If it was\n     * return the associated method number.\n     */\n    methnum = (int *)apr_hash_get(methods_registry, methname,\n                                  APR_HASH_KEY_STRING);\n    if (methnum != NULL)\n        return *methnum;\n\n    if (cur_method_number > METHOD_NUMBER_LAST) {\n        /* The method registry  has run out of dynamically\n         * assignable method numbers. Log this and return M_INVALID.\n         */\n        ap_log_perror(APLOG_MARK, APLOG_ERR, 0, p, APLOGNO(01610)\n                      \"Maximum new request methods %d reached while \"\n                      \"registering method %s.\",\n                      METHOD_NUMBER_LAST, methname);\n        return M_INVALID;\n    }\n\n    register_one_method(p, methname, cur_method_number);\n    return cur_method_number++;\n}"
    },
    "ap_method_number_of@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 776, column 17>": {
      "basic_info": {
        "function_id": 1649,
        "name": "ap_method_number_of",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 776, column 17>",
        "is_definition": true,
        "start_line": 776,
        "end_line": 788,
        "return_type": "int",
        "parameters": [
          {
            "name": "method",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "strlen": {
            "declaration": "extern size_t strlen (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_hash_get": {
            "declaration": "APR_DECLARE(void *) apr_hash_get(apr_hash_t *ht, const void *key,\n                                 apr_ssize_t klen)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_method_in_list@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1414, column 17>": {
            "source_code": "AP_DECLARE(int) ap_method_in_list(ap_method_list_t *l, const char *method)\n{\n    int methnum;\n\n    /*\n     * If it's one of our known methods, use the shortcut and check the\n     * bitmask.\n     */\n    methnum = ap_method_number_of(method);\n    if (methnum != M_INVALID) {\n        return !!(l->method_mask & (AP_METHOD_BIT << methnum));\n    }\n    /*\n     * Otherwise, see if the method name is in the array of string names.\n     */\n    if ((l->method_list == NULL) || (l->method_list->nelts == 0)) {\n        return 0;\n    }\n\n    return ap_array_str_contains(l->method_list, method);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1414, column 17>"
          },
          "ap_method_list_add@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1439, column 18>": {
            "source_code": "AP_DECLARE(void) ap_method_list_add(ap_method_list_t *l, const char *method)\n{\n    int methnum;\n    const char **xmethod;\n\n    /*\n     * If it's one of our known methods, use the shortcut and use the\n     * bitmask.\n     */\n    methnum = ap_method_number_of(method);\n    if (methnum != M_INVALID) {\n        l->method_mask |= (AP_METHOD_BIT << methnum);\n        return;\n    }\n    /*\n     * Otherwise, see if the method name is in the array of string names.\n     */\n    if (ap_array_str_contains(l->method_list, method)) {\n        return;\n    }\n\n    xmethod = (const char **) apr_array_push(l->method_list);\n    *xmethod = method;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1439, column 18>"
          },
          "ap_method_list_remove@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1467, column 18>": {
            "source_code": "AP_DECLARE(void) ap_method_list_remove(ap_method_list_t *l,\n                                       const char *method)\n{\n    int methnum;\n    char **methods;\n\n    /*\n     * If it's a known methods, either builtin or registered\n     * by a module, use the bitmask.\n     */\n    methnum = ap_method_number_of(method);\n    if (methnum != M_INVALID) {\n        l->method_mask &= ~(AP_METHOD_BIT << methnum);\n        return;\n    }\n    /*\n     * Otherwise, see if the method name is in the array of string names.\n     */\n    if (l->method_list->nelts != 0) {\n        int i, j, k;\n        methods = (char **)l->method_list->elts;\n        for (i = 0; i < l->method_list->nelts; ) {\n            if (strcmp(method, methods[i]) == 0) {\n                for (j = i, k = i + 1; k < l->method_list->nelts; ++j, ++k) {\n                    methods[j] = methods[k];\n                }\n                --l->method_list->nelts;\n            }\n            else {\n                ++i;\n            }\n        }\n    }\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1467, column 18>"
          }
        },
        "used_macros": {},
        "used_structs": {},
        "used_globals": {
          "methods_registry": {
            "name": "methods_registry",
            "type": "apr_hash_t *",
            "is_extern": false,
            "is_static": true,
            "definition": "static apr_hash_t *methods_registry = NULL",
            "initializer": "NULL",
            "full_definition": "static apr_hash_t *methods_registry = NULL",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(int) ap_method_number_of(const char *method)\n{\n    int len = strlen(method);\n\n    /* check if the method has been dynamically registered */\n    int *methnum = apr_hash_get(methods_registry, method, len);\n\n    if (methnum != NULL) {\n        return *methnum;\n    }\n\n    return M_INVALID;\n}"
    },
    "ap_method_name_of@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 793, column 26>": {
      "basic_info": {
        "function_id": 1650,
        "name": "ap_method_name_of",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 793, column 26>",
        "is_definition": true,
        "start_line": 793,
        "end_line": 810,
        "return_type": "const char *",
        "parameters": [
          {
            "name": "p",
            "type": "apr_pool_t *"
          },
          {
            "name": "methnum",
            "type": "int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_hash_first": {
            "declaration": "APR_DECLARE(apr_hash_index_t *) apr_hash_first(apr_pool_t *p, apr_hash_t *ht)",
            "is_external": true,
            "definition": null
          },
          "apr_hash_next": {
            "declaration": "APR_DECLARE(apr_hash_index_t *) apr_hash_next(apr_hash_index_t *hi)",
            "is_external": true,
            "definition": null
          },
          "apr_hash_this": {
            "declaration": "APR_DECLARE(void) apr_hash_this(apr_hash_index_t *hi, const void **key, \n                                apr_ssize_t *klen, void **val)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          },
          "apr_hash_index_t": {
            "name": "apr_hash_index_t",
            "definition": "struct apr_hash_index_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {
          "methods_registry": {
            "name": "methods_registry",
            "type": "apr_hash_t *",
            "is_extern": false,
            "is_static": true,
            "definition": "static apr_hash_t *methods_registry = NULL",
            "initializer": "NULL",
            "full_definition": "static apr_hash_t *methods_registry = NULL",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(const char *) ap_method_name_of(apr_pool_t *p, int methnum)\n{\n    apr_hash_index_t *hi = apr_hash_first(p, methods_registry);\n\n    /* scan through the hash table, looking for a value that matches\n       the provided method number. */\n    for (; hi; hi = apr_hash_next(hi)) {\n        const void *key;\n        void *val;\n\n        apr_hash_this(hi, &key, NULL, &val);\n        if (*(int *)val == methnum)\n            return key;\n    }\n\n    /* it wasn't found in the hash */\n    return NULL;\n}"
    },
    "index_of_response@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 819, column 12>": {
      "basic_info": {
        "function_id": 1651,
        "name": "index_of_response",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 819, column 12>",
        "is_definition": true,
        "start_line": 819,
        "end_line": 845,
        "return_type": "int",
        "parameters": [
          {
            "name": "status",
            "type": "int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {},
        "callers": {
          "ap_get_status_line_ex@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 853, column 26>": {
            "source_code": "AP_DECLARE(const char *) ap_get_status_line_ex(apr_pool_t *p, int status)\n{\n    int index = index_of_response(status);\n    if (index >= 0) {\n        return status_lines[index];\n    }\n    else if (index == -2) {\n        return apr_psprintf(p, \"%i Status %i\", status, status);\n    }\n    return status_lines[LEVEL_500];\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 853, column 26>"
          },
          "ap_index_of_response@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 847, column 17>": {
            "source_code": "AP_DECLARE(int) ap_index_of_response(int status)\n{\n    int index = index_of_response(status);\n    return (index < 0) ? LEVEL_500 : index;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 847, column 17>"
          }
        },
        "used_macros": {},
        "used_structs": {},
        "used_globals": {
          "status_lines": {
            "name": "status_lines",
            "type": "const char *const[103]",
            "is_extern": false,
            "is_static": true,
            "definition": "static const char * const status_lines[RESPONSE_CODES] =\n{\n    \"100 Continue\",\n    \"101 Switching Protocols\",\n    \"102 Processing\",\n#define LEVEL_200  3\n    \"200 OK\",\n    \"201 Created\",\n    \"202 Accepted\",\n    \"203 Non-Authoritative Information\",\n    \"204 No Content\",\n    \"205 Reset Content\",\n    \"206 Partial Content\",\n    \"207 Multi-Status\",\n    \"208 Already Reported\",\n    NULL, /* 209 */\n    NULL, /* 210 */\n    NULL, /* 211 */\n    NULL, /* 212 */\n    NULL, /* 213 */\n    NULL, /* 214 */\n    NULL, /* 215 */\n    NULL, /* 216 */\n    NULL, /* 217 */\n    NULL, /* 218 */\n    NULL, /* 219 */\n    NULL, /* 220 */\n    NULL, /* 221 */\n    NULL, /* 222 */\n    NULL, /* 223 */\n    NULL, /* 224 */\n    NULL, /* 225 */\n    \"226 IM Used\",\n#define LEVEL_300 30\n    \"300 Multiple Choices\",\n    \"301 Moved Permanently\",\n    \"302 Found\",\n    \"303 See Other\",\n    \"304 Not Modified\",\n    \"305 Use Proxy\",\n    NULL, /* 306 */\n    \"307 Temporary Redirect\",\n    \"308 Permanent Redirect\",\n#define LEVEL_400 39\n    \"400 Bad Request\",\n    \"401 Unauthorized\",\n    \"402 Payment Required\",\n    \"403 Forbidden\",\n    \"404 Not Found\",\n    \"405 Method Not Allowed\",\n    \"406 Not Acceptable\",\n    \"407 Proxy Authentication Required\",\n    \"408 Request Timeout\",\n    \"409 Conflict\",\n    \"410 Gone\",\n    \"411 Length Required\",\n    \"412 Precondition Failed\",\n    \"413 Request Entity Too Large\",\n    \"414 Request-URI Too Long\",\n    \"415 Unsupported Media Type\",\n    \"416 Requested Range Not Satisfiable\",\n    \"417 Expectation Failed\",\n    \"418 I'm A Teapot\",\n    NULL, /* 419 */\n    NULL, /* 420 */\n    \"421 Misdirected Request\",\n    \"422 Unprocessable Entity\",\n    \"423 Locked\",\n    \"424 Failed Dependency\",\n    \"425 Too Early\",\n    \"426 Upgrade Required\",\n    NULL, /* 427 */\n    \"428 Precondition Required\",\n    \"429 Too Many Requests\",\n    NULL, /* 430 */\n    \"431 Request Header Fields Too Large\",\n    NULL, /* 432 */\n    NULL, /* 433 */\n    NULL, /* 434 */\n    NULL, /* 435 */\n    NULL, /* 436 */\n    NULL, /* 437 */\n    NULL, /* 438 */\n    NULL, /* 439 */\n    NULL, /* 440 */\n    NULL, /* 441 */\n    NULL, /* 442 */\n    NULL, /* 443 */\n    NULL, /* 444 */\n    NULL, /* 445 */\n    NULL, /* 446 */\n    NULL, /* 447 */\n    NULL, /* 448 */\n    NULL, /* 449 */\n    NULL, /* 450 */\n    \"451 Unavailable For Legal Reasons\",\n#define LEVEL_500 91\n    \"500 Internal Server Error\",\n    \"501 Not Implemented\",\n    \"502 Bad Gateway\",\n    \"503 Service Unavailable\",\n    \"504 Gateway Timeout\",\n    \"505 HTTP Version Not Supported\",\n    \"506 Variant Also Negotiates\",\n    \"507 Insufficient Storage\",\n    \"508 Loop Detected\",\n    NULL, /* 509 */\n    \"510 Not Extended\",\n    \"511 Network Authentication Required\"\n}",
            "initializer": "{\n    \"100 Continue\",\n    \"101 Switching Protocols\",\n    \"102 Processing\",\n#define LEVEL_200  3\n    \"200 OK\",\n    \"201 Created\",\n    \"202 Accepted\",\n    \"203 Non-Authoritative Information\",\n    \"204 No Content\",\n    \"205 Reset Content\",\n    \"206 Partial Content\",\n    \"207 Multi-Status\",\n    \"208 Already Reported\",\n    NULL, /* 209 */\n    NULL, /* 210 */\n    NULL, /* 211 */\n    NULL, /* 212 */\n    NULL, /* 213 */\n    NULL, /* 214 */\n    NULL, /* 215 */\n    NULL, /* 216 */\n    NULL, /* 217 */\n    NULL, /* 218 */\n    NULL, /* 219 */\n    NULL, /* 220 */\n    NULL, /* 221 */\n    NULL, /* 222 */\n    NULL, /* 223 */\n    NULL, /* 224 */\n    NULL, /* 225 */\n    \"226 IM Used\",\n#define LEVEL_300 30\n    \"300 Multiple Choices\",\n    \"301 Moved Permanently\",\n    \"302 Found\",\n    \"303 See Other\",\n    \"304 Not Modified\",\n    \"305 Use Proxy\",\n    NULL, /* 306 */\n    \"307 Temporary Redirect\",\n    \"308 Permanent Redirect\",\n#define LEVEL_400 39\n    \"400 Bad Request\",\n    \"401 Unauthorized\",\n    \"402 Payment Required\",\n    \"403 Forbidden\",\n    \"404 Not Found\",\n    \"405 Method Not Allowed\",\n    \"406 Not Acceptable\",\n    \"407 Proxy Authentication Required\",\n    \"408 Request Timeout\",\n    \"409 Conflict\",\n    \"410 Gone\",\n    \"411 Length Required\",\n    \"412 Precondition Failed\",\n    \"413 Request Entity Too Large\",\n    \"414 Request-URI Too Long\",\n    \"415 Unsupported Media Type\",\n    \"416 Requested Range Not Satisfiable\",\n    \"417 Expectation Failed\",\n    \"418 I'm A Teapot\",\n    NULL, /* 419 */\n    NULL, /* 420 */\n    \"421 Misdirected Request\",\n    \"422 Unprocessable Entity\",\n    \"423 Locked\",\n    \"424 Failed Dependency\",\n    \"425 Too Early\",\n    \"426 Upgrade Required\",\n    NULL, /* 427 */\n    \"428 Precondition Required\",\n    \"429 Too Many Requests\",\n    NULL, /* 430 */\n    \"431 Request Header Fields Too Large\",\n    NULL, /* 432 */\n    NULL, /* 433 */\n    NULL, /* 434 */\n    NULL, /* 435 */\n    NULL, /* 436 */\n    NULL, /* 437 */\n    NULL, /* 438 */\n    NULL, /* 439 */\n    NULL, /* 440 */\n    NULL, /* 441 */\n    NULL, /* 442 */\n    NULL, /* 443 */\n    NULL, /* 444 */\n    NULL, /* 445 */\n    NULL, /* 446 */\n    NULL, /* 447 */\n    NULL, /* 448 */\n    NULL, /* 449 */\n    NULL, /* 450 */\n    \"451 Unavailable For Legal Reasons\",\n#define LEVEL_500 91\n    \"500 Internal Server Error\",\n    \"501 Not Implemented\",\n    \"502 Bad Gateway\",\n    \"503 Service Unavailable\",\n    \"504 Gateway Timeout\",\n    \"505 HTTP Version Not Supported\",\n    \"506 Variant Also Negotiates\",\n    \"507 Insufficient Storage\",\n    \"508 Loop Detected\",\n    NULL, /* 509 */\n    \"510 Not Extended\",\n    \"511 Network Authentication Required\"\n}",
            "full_definition": "static const char * const status_lines[RESPONSE_CODES] =\n{\n    \"100 Continue\",\n    \"101 Switching Protocols\",\n    \"102 Processing\",\n#define LEVEL_200  3\n    \"200 OK\",\n    \"201 Created\",\n    \"202 Accepted\",\n    \"203 Non-Authoritative Information\",\n    \"204 No Content\",\n    \"205 Reset Content\",\n    \"206 Partial Content\",\n    \"207 Multi-Status\",\n    \"208 Already Reported\",\n    NULL, /* 209 */\n    NULL, /* 210 */\n    NULL, /* 211 */\n    NULL, /* 212 */\n    NULL, /* 213 */\n    NULL, /* 214 */\n    NULL, /* 215 */\n    NULL, /* 216 */\n    NULL, /* 217 */\n    NULL, /* 218 */\n    NULL, /* 219 */\n    NULL, /* 220 */\n    NULL, /* 221 */\n    NULL, /* 222 */\n    NULL, /* 223 */\n    NULL, /* 224 */\n    NULL, /* 225 */\n    \"226 IM Used\",\n#define LEVEL_300 30\n    \"300 Multiple Choices\",\n    \"301 Moved Permanently\",\n    \"302 Found\",\n    \"303 See Other\",\n    \"304 Not Modified\",\n    \"305 Use Proxy\",\n    NULL, /* 306 */\n    \"307 Temporary Redirect\",\n    \"308 Permanent Redirect\",\n#define LEVEL_400 39\n    \"400 Bad Request\",\n    \"401 Unauthorized\",\n    \"402 Payment Required\",\n    \"403 Forbidden\",\n    \"404 Not Found\",\n    \"405 Method Not Allowed\",\n    \"406 Not Acceptable\",\n    \"407 Proxy Authentication Required\",\n    \"408 Request Timeout\",\n    \"409 Conflict\",\n    \"410 Gone\",\n    \"411 Length Required\",\n    \"412 Precondition Failed\",\n    \"413 Request Entity Too Large\",\n    \"414 Request-URI Too Long\",\n    \"415 Unsupported Media Type\",\n    \"416 Requested Range Not Satisfiable\",\n    \"417 Expectation Failed\",\n    \"418 I'm A Teapot\",\n    NULL, /* 419 */\n    NULL, /* 420 */\n    \"421 Misdirected Request\",\n    \"422 Unprocessable Entity\",\n    \"423 Locked\",\n    \"424 Failed Dependency\",\n    \"425 Too Early\",\n    \"426 Upgrade Required\",\n    NULL, /* 427 */\n    \"428 Precondition Required\",\n    \"429 Too Many Requests\",\n    NULL, /* 430 */\n    \"431 Request Header Fields Too Large\",\n    NULL, /* 432 */\n    NULL, /* 433 */\n    NULL, /* 434 */\n    NULL, /* 435 */\n    NULL, /* 436 */\n    NULL, /* 437 */\n    NULL, /* 438 */\n    NULL, /* 439 */\n    NULL, /* 440 */\n    NULL, /* 441 */\n    NULL, /* 442 */\n    NULL, /* 443 */\n    NULL, /* 444 */\n    NULL, /* 445 */\n    NULL, /* 446 */\n    NULL, /* 447 */\n    NULL, /* 448 */\n    NULL, /* 449 */\n    NULL, /* 450 */\n    \"451 Unavailable For Legal Reasons\",\n#define LEVEL_500 91\n    \"500 Internal Server Error\",\n    \"501 Not Implemented\",\n    \"502 Bad Gateway\",\n    \"503 Service Unavailable\",\n    \"504 Gateway Timeout\",\n    \"505 HTTP Version Not Supported\",\n    \"506 Variant Also Negotiates\",\n    \"507 Insufficient Storage\",\n    \"508 Loop Detected\",\n    NULL, /* 509 */\n    \"510 Not Extended\",\n    \"511 Network Authentication Required\"\n}",
            "used_macros": {
              "LEVEL_200": {
                "name": "LEVEL_200",
                "value": "3",
                "definition": "#define LEVEL_200  3"
              },
              "LEVEL_300": {
                "name": "LEVEL_300",
                "value": "30",
                "definition": "#define LEVEL_300 30"
              },
              "LEVEL_400": {
                "name": "LEVEL_400",
                "value": "39",
                "definition": "#define LEVEL_400 39"
              },
              "LEVEL_500": {
                "name": "LEVEL_500",
                "value": "91",
                "definition": "#define LEVEL_500 91"
              }
            },
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "static int index_of_response(int status)\n{\n    static int shortcut[6] = {0, LEVEL_200, LEVEL_300, LEVEL_400, LEVEL_500,\n                                 RESPONSE_CODES};\n    int i, pos;\n\n    if (status < 100) {     /* Below 100 is illegal for HTTP status */\n        return -1;\n    }\n    if (status > 999) {     /* Above 999 is also illegal for HTTP status */\n        return -1;\n    }\n\n    for (i = 0; i < 5; i++) {\n        status -= 100;\n        if (status < 100) {\n            pos = (status + shortcut[i]);\n            if (pos < shortcut[i + 1] && status_lines[pos] != NULL) {\n                return pos;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    return -2;              /* Status unknown (falls in gap) or above 600 */\n}"
    },
    "ap_index_of_response@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 847, column 17>": {
      "basic_info": {
        "function_id": 1652,
        "name": "ap_index_of_response",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 847, column 17>",
        "is_definition": true,
        "start_line": 847,
        "end_line": 851,
        "return_type": "int",
        "parameters": [
          {
            "name": "status",
            "type": "int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "index_of_response": {
            "declaration": "static int index_of_response(int status)\n{\n    static int shortcut[6] = {0, LEVEL_200, LEVEL_300, LEVEL_400, LEVEL_500,\n                                 RESPONSE_CODES};\n    int i, pos;\n\n    if (status < 100) {     /* Below 100 is illegal for HTTP status */\n        return -1;\n    }\n    if (status > 999) {     /* Above 999 is also illegal for HTTP status */\n        return -1;\n    }\n\n    for (i = 0; i < 5; i++) {\n        status -= 100;\n        if (status < 100) {\n            pos = (status + shortcut[i]);\n            if (pos < shortcut[i + 1] && status_lines[pos] != NULL) {\n                return pos;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    return -2;              /* Status unknown (falls in gap) or above 600 */\n}",
            "is_external": false,
            "definition": "static int index_of_response(int status)\n{\n    static int shortcut[6] = {0, LEVEL_200, LEVEL_300, LEVEL_400, LEVEL_500,\n                                 RESPONSE_CODES};\n    int i, pos;\n\n    if (status < 100) {     /* Below 100 is illegal for HTTP status */\n        return -1;\n    }\n    if (status > 999) {     /* Above 999 is also illegal for HTTP status */\n        return -1;\n    }\n\n    for (i = 0; i < 5; i++) {\n        status -= 100;\n        if (status < 100) {\n            pos = (status + shortcut[i]);\n            if (pos < shortcut[i + 1] && status_lines[pos] != NULL) {\n                return pos;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    return -2;              /* Status unknown (falls in gap) or above 600 */\n}"
          }
        },
        "callers": {
          "ap_get_status_line@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 865, column 26>": {
            "source_code": "AP_DECLARE(const char *) ap_get_status_line(int status)\n{\n    return status_lines[ap_index_of_response(status)];\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 865, column 26>"
          },
          "ap_send_error_response@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1212, column 18>": {
            "source_code": "AP_DECLARE(void) ap_send_error_response(request_rec *r, int recursive_error)\n{\n    int status = r->status;\n    int idx = ap_index_of_response(status);\n    char *custom_response;\n    const char *location = apr_table_get(r->headers_out, \"Location\");\n\n    /* At this point, we are starting the response over, so we have to reset\n     * this value.\n     */\n    r->eos_sent = 0;\n\n    /* and we need to get rid of any RESOURCE filters that might be lurking\n     * around, thinking they are in the middle of the original request\n     */\n\n    r->output_filters = r->proto_output_filters;\n\n    ap_run_insert_error_filter(r);\n\n    /* We need to special-case the handling of 204 and 304 responses,\n     * since they have specific HTTP requirements and do not include a\n     * message body.  Note that being assbackwards here is not an option.\n     */\n    if (AP_STATUS_IS_HEADER_ONLY(status)) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    /*\n     * It's possible that the Location field might be in r->err_headers_out\n     * instead of r->headers_out; use the latter if possible, else the\n     * former.\n     */\n    if (location == NULL) {\n        location = apr_table_get(r->err_headers_out, \"Location\");\n    }\n\n    if (!r->assbackwards) {\n\n        /* For all HTTP/1.x responses for which we generate the message,\n         * we need to avoid inheriting the \"normal status\" header fields\n         * that may have been set by the request handler before the\n         * error or redirect, except for Location on external redirects.\n         */\n        apr_table_clear(r->headers_out);\n\n        if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {\n            if ((location != NULL) && *location) {\n                apr_table_setn(r->headers_out, \"Location\", location);\n            }\n            else {\n                location = \"\";   /* avoids coredump when printing, below */\n            }\n        }\n\n        r->content_languages = NULL;\n        r->content_encoding = NULL;\n        r->clength = 0;\n\n        if (apr_table_get(r->subprocess_env,\n                          \"suppress-error-charset\") != NULL) {\n            core_request_config *request_conf =\n                        ap_get_core_module_config(r->request_config);\n            request_conf->suppress_charset = 1; /* avoid adding default\n                                                 * charset later\n                                                 */\n            ap_set_content_type_ex(r, \"text/html\", 1);\n        }\n        else {\n            ap_set_content_type_ex(r, \"text/html; charset=iso-8859-1\", 1);\n        }\n\n        if ((status == HTTP_METHOD_NOT_ALLOWED)\n            || (status == HTTP_NOT_IMPLEMENTED)) {\n            apr_table_setn(r->headers_out, \"Allow\", make_allow(r));\n        }\n\n        if (r->header_only) {\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n\n    if ((custom_response = ap_response_code_string(r, idx))) {\n        /*\n         * We have a custom response output. This should only be\n         * a text-string to write back. But if the ErrorDocument\n         * was a local redirect and the requested resource failed\n         * for any reason, the custom_response will still hold the\n         * redirect URL. We don't really want to output this URL\n         * as a text message, so first check the custom response\n         * string to ensure that it is a text-string (using the\n         * same test used in ap_die(), i.e. does it start with a \").\n         *\n         * If it's not a text string, we've got a recursive error or\n         * an external redirect.  If it's a recursive error, ap_die passes\n         * us the second error code so we can write both, and has already\n         * backed up to the original error.  If it's an external redirect,\n         * it hasn't happened yet; we may never know if it fails.\n         */\n        if (custom_response[0] == '\\\"') {\n            ap_rvputs_proto_in_ascii(r, custom_response + 1, NULL);\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n    {\n        const char *title = status_lines[idx];\n        const char *h1;\n\n        /* Accept a status_line set by a module, but only if it begins\n         * with the correct 3 digit status code\n         */\n        if (r->status_line) {\n            char *end;\n            int len = strlen(r->status_line);\n            if (len >= 3\n                && apr_strtoi64(r->status_line, &end, 10) == r->status\n                && (end - 3) == r->status_line\n                && (len < 4 || apr_isspace(r->status_line[3]))\n                && (len < 5 || apr_isalnum(r->status_line[4]))) {\n                /* Since we passed the above check, we know that length three\n                 * is equivalent to only a 3 digit numeric http status.\n                 * RFC2616 mandates a trailing space, let's add it.\n                 * If we have an empty reason phrase, we also add \"Unknown Reason\".\n                 */\n                if (len == 3) {\n                    r->status_line = apr_pstrcat(r->pool, r->status_line, \" Unknown Reason\", NULL);\n                } else if (len == 4) {\n                    r->status_line = apr_pstrcat(r->pool, r->status_line, \"Unknown Reason\", NULL);\n                }\n                title = r->status_line;\n            }\n        }\n\n        /* folks decided they didn't want the error code in the H1 text */\n        h1 = &title[4];\n\n        /* can't count on a charset filter being in place here,\n         * so do ebcdic->ascii translation explicitly (if needed)\n         */\n\n        ap_rvputs_proto_in_ascii(r,\n                  DOCTYPE_HTML_4_01\n                  \"<html><head>\\n<title>\", title,\n                  \"</title>\\n</head><body>\\n<h1>\", h1, \"</h1>\\n\",\n                  NULL);\n\n        ap_rvputs_proto_in_ascii(r,\n                                 get_canned_error_string(status, r, location),\n                                 NULL);\n\n        if (recursive_error) {\n            ap_rvputs_proto_in_ascii(r, \"<p>Additionally, a \",\n                      status_lines[ap_index_of_response(recursive_error)],\n                      \"\\nerror was encountered while trying to use an \"\n                      \"ErrorDocument to handle the request.</p>\\n\", NULL);\n        }\n        ap_rvputs_proto_in_ascii(r, ap_psignature(\"<hr>\\n\", r), NULL);\n        ap_rvputs_proto_in_ascii(r, \"</body></html>\\n\", NULL);\n    }\n    ap_finalize_request_protocol(r);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1212, column 18>"
          }
        },
        "used_macros": {},
        "used_structs": {},
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(int) ap_index_of_response(int status)\n{\n    int index = index_of_response(status);\n    return (index < 0) ? LEVEL_500 : index;\n}"
    },
    "ap_get_status_line_ex@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 853, column 26>": {
      "basic_info": {
        "function_id": 1653,
        "name": "ap_get_status_line_ex",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 853, column 26>",
        "is_definition": true,
        "start_line": 853,
        "end_line": 863,
        "return_type": "const char *",
        "parameters": [
          {
            "name": "p",
            "type": "apr_pool_t *"
          },
          {
            "name": "status",
            "type": "int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "index_of_response": {
            "declaration": "static int index_of_response(int status)\n{\n    static int shortcut[6] = {0, LEVEL_200, LEVEL_300, LEVEL_400, LEVEL_500,\n                                 RESPONSE_CODES};\n    int i, pos;\n\n    if (status < 100) {     /* Below 100 is illegal for HTTP status */\n        return -1;\n    }\n    if (status > 999) {     /* Above 999 is also illegal for HTTP status */\n        return -1;\n    }\n\n    for (i = 0; i < 5; i++) {\n        status -= 100;\n        if (status < 100) {\n            pos = (status + shortcut[i]);\n            if (pos < shortcut[i + 1] && status_lines[pos] != NULL) {\n                return pos;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    return -2;              /* Status unknown (falls in gap) or above 600 */\n}",
            "is_external": false,
            "definition": "static int index_of_response(int status)\n{\n    static int shortcut[6] = {0, LEVEL_200, LEVEL_300, LEVEL_400, LEVEL_500,\n                                 RESPONSE_CODES};\n    int i, pos;\n\n    if (status < 100) {     /* Below 100 is illegal for HTTP status */\n        return -1;\n    }\n    if (status > 999) {     /* Above 999 is also illegal for HTTP status */\n        return -1;\n    }\n\n    for (i = 0; i < 5; i++) {\n        status -= 100;\n        if (status < 100) {\n            pos = (status + shortcut[i]);\n            if (pos < shortcut[i + 1] && status_lines[pos] != NULL) {\n                return pos;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    return -2;              /* Status unknown (falls in gap) or above 600 */\n}"
          },
          "apr_psprintf": {
            "declaration": "APR_DECLARE_NONSTD(char *) apr_psprintf(apr_pool_t *p, const char *fmt, ...)\n        __attribute__((format(printf,2,3)))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {
          "LEVEL_500": {
            "name": "LEVEL_500",
            "value": "91",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "#define LEVEL_500 91",
            "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c:169",
            "condition": ""
          }
        },
        "used_structs": {
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {
          "status_lines": {
            "name": "status_lines",
            "type": "const char *const[103]",
            "is_extern": false,
            "is_static": true,
            "definition": "static const char * const status_lines[RESPONSE_CODES] =\n{\n    \"100 Continue\",\n    \"101 Switching Protocols\",\n    \"102 Processing\",\n#define LEVEL_200  3\n    \"200 OK\",\n    \"201 Created\",\n    \"202 Accepted\",\n    \"203 Non-Authoritative Information\",\n    \"204 No Content\",\n    \"205 Reset Content\",\n    \"206 Partial Content\",\n    \"207 Multi-Status\",\n    \"208 Already Reported\",\n    NULL, /* 209 */\n    NULL, /* 210 */\n    NULL, /* 211 */\n    NULL, /* 212 */\n    NULL, /* 213 */\n    NULL, /* 214 */\n    NULL, /* 215 */\n    NULL, /* 216 */\n    NULL, /* 217 */\n    NULL, /* 218 */\n    NULL, /* 219 */\n    NULL, /* 220 */\n    NULL, /* 221 */\n    NULL, /* 222 */\n    NULL, /* 223 */\n    NULL, /* 224 */\n    NULL, /* 225 */\n    \"226 IM Used\",\n#define LEVEL_300 30\n    \"300 Multiple Choices\",\n    \"301 Moved Permanently\",\n    \"302 Found\",\n    \"303 See Other\",\n    \"304 Not Modified\",\n    \"305 Use Proxy\",\n    NULL, /* 306 */\n    \"307 Temporary Redirect\",\n    \"308 Permanent Redirect\",\n#define LEVEL_400 39\n    \"400 Bad Request\",\n    \"401 Unauthorized\",\n    \"402 Payment Required\",\n    \"403 Forbidden\",\n    \"404 Not Found\",\n    \"405 Method Not Allowed\",\n    \"406 Not Acceptable\",\n    \"407 Proxy Authentication Required\",\n    \"408 Request Timeout\",\n    \"409 Conflict\",\n    \"410 Gone\",\n    \"411 Length Required\",\n    \"412 Precondition Failed\",\n    \"413 Request Entity Too Large\",\n    \"414 Request-URI Too Long\",\n    \"415 Unsupported Media Type\",\n    \"416 Requested Range Not Satisfiable\",\n    \"417 Expectation Failed\",\n    \"418 I'm A Teapot\",\n    NULL, /* 419 */\n    NULL, /* 420 */\n    \"421 Misdirected Request\",\n    \"422 Unprocessable Entity\",\n    \"423 Locked\",\n    \"424 Failed Dependency\",\n    \"425 Too Early\",\n    \"426 Upgrade Required\",\n    NULL, /* 427 */\n    \"428 Precondition Required\",\n    \"429 Too Many Requests\",\n    NULL, /* 430 */\n    \"431 Request Header Fields Too Large\",\n    NULL, /* 432 */\n    NULL, /* 433 */\n    NULL, /* 434 */\n    NULL, /* 435 */\n    NULL, /* 436 */\n    NULL, /* 437 */\n    NULL, /* 438 */\n    NULL, /* 439 */\n    NULL, /* 440 */\n    NULL, /* 441 */\n    NULL, /* 442 */\n    NULL, /* 443 */\n    NULL, /* 444 */\n    NULL, /* 445 */\n    NULL, /* 446 */\n    NULL, /* 447 */\n    NULL, /* 448 */\n    NULL, /* 449 */\n    NULL, /* 450 */\n    \"451 Unavailable For Legal Reasons\",\n#define LEVEL_500 91\n    \"500 Internal Server Error\",\n    \"501 Not Implemented\",\n    \"502 Bad Gateway\",\n    \"503 Service Unavailable\",\n    \"504 Gateway Timeout\",\n    \"505 HTTP Version Not Supported\",\n    \"506 Variant Also Negotiates\",\n    \"507 Insufficient Storage\",\n    \"508 Loop Detected\",\n    NULL, /* 509 */\n    \"510 Not Extended\",\n    \"511 Network Authentication Required\"\n}",
            "initializer": "{\n    \"100 Continue\",\n    \"101 Switching Protocols\",\n    \"102 Processing\",\n#define LEVEL_200  3\n    \"200 OK\",\n    \"201 Created\",\n    \"202 Accepted\",\n    \"203 Non-Authoritative Information\",\n    \"204 No Content\",\n    \"205 Reset Content\",\n    \"206 Partial Content\",\n    \"207 Multi-Status\",\n    \"208 Already Reported\",\n    NULL, /* 209 */\n    NULL, /* 210 */\n    NULL, /* 211 */\n    NULL, /* 212 */\n    NULL, /* 213 */\n    NULL, /* 214 */\n    NULL, /* 215 */\n    NULL, /* 216 */\n    NULL, /* 217 */\n    NULL, /* 218 */\n    NULL, /* 219 */\n    NULL, /* 220 */\n    NULL, /* 221 */\n    NULL, /* 222 */\n    NULL, /* 223 */\n    NULL, /* 224 */\n    NULL, /* 225 */\n    \"226 IM Used\",\n#define LEVEL_300 30\n    \"300 Multiple Choices\",\n    \"301 Moved Permanently\",\n    \"302 Found\",\n    \"303 See Other\",\n    \"304 Not Modified\",\n    \"305 Use Proxy\",\n    NULL, /* 306 */\n    \"307 Temporary Redirect\",\n    \"308 Permanent Redirect\",\n#define LEVEL_400 39\n    \"400 Bad Request\",\n    \"401 Unauthorized\",\n    \"402 Payment Required\",\n    \"403 Forbidden\",\n    \"404 Not Found\",\n    \"405 Method Not Allowed\",\n    \"406 Not Acceptable\",\n    \"407 Proxy Authentication Required\",\n    \"408 Request Timeout\",\n    \"409 Conflict\",\n    \"410 Gone\",\n    \"411 Length Required\",\n    \"412 Precondition Failed\",\n    \"413 Request Entity Too Large\",\n    \"414 Request-URI Too Long\",\n    \"415 Unsupported Media Type\",\n    \"416 Requested Range Not Satisfiable\",\n    \"417 Expectation Failed\",\n    \"418 I'm A Teapot\",\n    NULL, /* 419 */\n    NULL, /* 420 */\n    \"421 Misdirected Request\",\n    \"422 Unprocessable Entity\",\n    \"423 Locked\",\n    \"424 Failed Dependency\",\n    \"425 Too Early\",\n    \"426 Upgrade Required\",\n    NULL, /* 427 */\n    \"428 Precondition Required\",\n    \"429 Too Many Requests\",\n    NULL, /* 430 */\n    \"431 Request Header Fields Too Large\",\n    NULL, /* 432 */\n    NULL, /* 433 */\n    NULL, /* 434 */\n    NULL, /* 435 */\n    NULL, /* 436 */\n    NULL, /* 437 */\n    NULL, /* 438 */\n    NULL, /* 439 */\n    NULL, /* 440 */\n    NULL, /* 441 */\n    NULL, /* 442 */\n    NULL, /* 443 */\n    NULL, /* 444 */\n    NULL, /* 445 */\n    NULL, /* 446 */\n    NULL, /* 447 */\n    NULL, /* 448 */\n    NULL, /* 449 */\n    NULL, /* 450 */\n    \"451 Unavailable For Legal Reasons\",\n#define LEVEL_500 91\n    \"500 Internal Server Error\",\n    \"501 Not Implemented\",\n    \"502 Bad Gateway\",\n    \"503 Service Unavailable\",\n    \"504 Gateway Timeout\",\n    \"505 HTTP Version Not Supported\",\n    \"506 Variant Also Negotiates\",\n    \"507 Insufficient Storage\",\n    \"508 Loop Detected\",\n    NULL, /* 509 */\n    \"510 Not Extended\",\n    \"511 Network Authentication Required\"\n}",
            "full_definition": "static const char * const status_lines[RESPONSE_CODES] =\n{\n    \"100 Continue\",\n    \"101 Switching Protocols\",\n    \"102 Processing\",\n#define LEVEL_200  3\n    \"200 OK\",\n    \"201 Created\",\n    \"202 Accepted\",\n    \"203 Non-Authoritative Information\",\n    \"204 No Content\",\n    \"205 Reset Content\",\n    \"206 Partial Content\",\n    \"207 Multi-Status\",\n    \"208 Already Reported\",\n    NULL, /* 209 */\n    NULL, /* 210 */\n    NULL, /* 211 */\n    NULL, /* 212 */\n    NULL, /* 213 */\n    NULL, /* 214 */\n    NULL, /* 215 */\n    NULL, /* 216 */\n    NULL, /* 217 */\n    NULL, /* 218 */\n    NULL, /* 219 */\n    NULL, /* 220 */\n    NULL, /* 221 */\n    NULL, /* 222 */\n    NULL, /* 223 */\n    NULL, /* 224 */\n    NULL, /* 225 */\n    \"226 IM Used\",\n#define LEVEL_300 30\n    \"300 Multiple Choices\",\n    \"301 Moved Permanently\",\n    \"302 Found\",\n    \"303 See Other\",\n    \"304 Not Modified\",\n    \"305 Use Proxy\",\n    NULL, /* 306 */\n    \"307 Temporary Redirect\",\n    \"308 Permanent Redirect\",\n#define LEVEL_400 39\n    \"400 Bad Request\",\n    \"401 Unauthorized\",\n    \"402 Payment Required\",\n    \"403 Forbidden\",\n    \"404 Not Found\",\n    \"405 Method Not Allowed\",\n    \"406 Not Acceptable\",\n    \"407 Proxy Authentication Required\",\n    \"408 Request Timeout\",\n    \"409 Conflict\",\n    \"410 Gone\",\n    \"411 Length Required\",\n    \"412 Precondition Failed\",\n    \"413 Request Entity Too Large\",\n    \"414 Request-URI Too Long\",\n    \"415 Unsupported Media Type\",\n    \"416 Requested Range Not Satisfiable\",\n    \"417 Expectation Failed\",\n    \"418 I'm A Teapot\",\n    NULL, /* 419 */\n    NULL, /* 420 */\n    \"421 Misdirected Request\",\n    \"422 Unprocessable Entity\",\n    \"423 Locked\",\n    \"424 Failed Dependency\",\n    \"425 Too Early\",\n    \"426 Upgrade Required\",\n    NULL, /* 427 */\n    \"428 Precondition Required\",\n    \"429 Too Many Requests\",\n    NULL, /* 430 */\n    \"431 Request Header Fields Too Large\",\n    NULL, /* 432 */\n    NULL, /* 433 */\n    NULL, /* 434 */\n    NULL, /* 435 */\n    NULL, /* 436 */\n    NULL, /* 437 */\n    NULL, /* 438 */\n    NULL, /* 439 */\n    NULL, /* 440 */\n    NULL, /* 441 */\n    NULL, /* 442 */\n    NULL, /* 443 */\n    NULL, /* 444 */\n    NULL, /* 445 */\n    NULL, /* 446 */\n    NULL, /* 447 */\n    NULL, /* 448 */\n    NULL, /* 449 */\n    NULL, /* 450 */\n    \"451 Unavailable For Legal Reasons\",\n#define LEVEL_500 91\n    \"500 Internal Server Error\",\n    \"501 Not Implemented\",\n    \"502 Bad Gateway\",\n    \"503 Service Unavailable\",\n    \"504 Gateway Timeout\",\n    \"505 HTTP Version Not Supported\",\n    \"506 Variant Also Negotiates\",\n    \"507 Insufficient Storage\",\n    \"508 Loop Detected\",\n    NULL, /* 509 */\n    \"510 Not Extended\",\n    \"511 Network Authentication Required\"\n}",
            "used_macros": {
              "LEVEL_200": {
                "name": "LEVEL_200",
                "value": "3",
                "definition": "#define LEVEL_200  3"
              },
              "LEVEL_300": {
                "name": "LEVEL_300",
                "value": "30",
                "definition": "#define LEVEL_300 30"
              },
              "LEVEL_400": {
                "name": "LEVEL_400",
                "value": "39",
                "definition": "#define LEVEL_400 39"
              },
              "LEVEL_500": {
                "name": "LEVEL_500",
                "value": "91",
                "definition": "#define LEVEL_500 91"
              }
            },
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(const char *) ap_get_status_line_ex(apr_pool_t *p, int status)\n{\n    int index = index_of_response(status);\n    if (index >= 0) {\n        return status_lines[index];\n    }\n    else if (index == -2) {\n        return apr_psprintf(p, \"%i Status %i\", status, status);\n    }\n    return status_lines[LEVEL_500];\n}"
    },
    "ap_get_status_line@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 865, column 26>": {
      "basic_info": {
        "function_id": 1654,
        "name": "ap_get_status_line",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 865, column 26>",
        "is_definition": true,
        "start_line": 865,
        "end_line": 868,
        "return_type": "const char *",
        "parameters": [
          {
            "name": "status",
            "type": "int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_index_of_response": {
            "declaration": "AP_DECLARE(int) ap_index_of_response(int status)\n{\n    int index = index_of_response(status);\n    return (index < 0) ? LEVEL_500 : index;\n}",
            "is_external": false,
            "definition": "AP_DECLARE(int) ap_index_of_response(int status)\n{\n    int index = index_of_response(status);\n    return (index < 0) ? LEVEL_500 : index;\n}"
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {},
        "used_globals": {
          "status_lines": {
            "name": "status_lines",
            "type": "const char *const[103]",
            "is_extern": false,
            "is_static": true,
            "definition": "static const char * const status_lines[RESPONSE_CODES] =\n{\n    \"100 Continue\",\n    \"101 Switching Protocols\",\n    \"102 Processing\",\n#define LEVEL_200  3\n    \"200 OK\",\n    \"201 Created\",\n    \"202 Accepted\",\n    \"203 Non-Authoritative Information\",\n    \"204 No Content\",\n    \"205 Reset Content\",\n    \"206 Partial Content\",\n    \"207 Multi-Status\",\n    \"208 Already Reported\",\n    NULL, /* 209 */\n    NULL, /* 210 */\n    NULL, /* 211 */\n    NULL, /* 212 */\n    NULL, /* 213 */\n    NULL, /* 214 */\n    NULL, /* 215 */\n    NULL, /* 216 */\n    NULL, /* 217 */\n    NULL, /* 218 */\n    NULL, /* 219 */\n    NULL, /* 220 */\n    NULL, /* 221 */\n    NULL, /* 222 */\n    NULL, /* 223 */\n    NULL, /* 224 */\n    NULL, /* 225 */\n    \"226 IM Used\",\n#define LEVEL_300 30\n    \"300 Multiple Choices\",\n    \"301 Moved Permanently\",\n    \"302 Found\",\n    \"303 See Other\",\n    \"304 Not Modified\",\n    \"305 Use Proxy\",\n    NULL, /* 306 */\n    \"307 Temporary Redirect\",\n    \"308 Permanent Redirect\",\n#define LEVEL_400 39\n    \"400 Bad Request\",\n    \"401 Unauthorized\",\n    \"402 Payment Required\",\n    \"403 Forbidden\",\n    \"404 Not Found\",\n    \"405 Method Not Allowed\",\n    \"406 Not Acceptable\",\n    \"407 Proxy Authentication Required\",\n    \"408 Request Timeout\",\n    \"409 Conflict\",\n    \"410 Gone\",\n    \"411 Length Required\",\n    \"412 Precondition Failed\",\n    \"413 Request Entity Too Large\",\n    \"414 Request-URI Too Long\",\n    \"415 Unsupported Media Type\",\n    \"416 Requested Range Not Satisfiable\",\n    \"417 Expectation Failed\",\n    \"418 I'm A Teapot\",\n    NULL, /* 419 */\n    NULL, /* 420 */\n    \"421 Misdirected Request\",\n    \"422 Unprocessable Entity\",\n    \"423 Locked\",\n    \"424 Failed Dependency\",\n    \"425 Too Early\",\n    \"426 Upgrade Required\",\n    NULL, /* 427 */\n    \"428 Precondition Required\",\n    \"429 Too Many Requests\",\n    NULL, /* 430 */\n    \"431 Request Header Fields Too Large\",\n    NULL, /* 432 */\n    NULL, /* 433 */\n    NULL, /* 434 */\n    NULL, /* 435 */\n    NULL, /* 436 */\n    NULL, /* 437 */\n    NULL, /* 438 */\n    NULL, /* 439 */\n    NULL, /* 440 */\n    NULL, /* 441 */\n    NULL, /* 442 */\n    NULL, /* 443 */\n    NULL, /* 444 */\n    NULL, /* 445 */\n    NULL, /* 446 */\n    NULL, /* 447 */\n    NULL, /* 448 */\n    NULL, /* 449 */\n    NULL, /* 450 */\n    \"451 Unavailable For Legal Reasons\",\n#define LEVEL_500 91\n    \"500 Internal Server Error\",\n    \"501 Not Implemented\",\n    \"502 Bad Gateway\",\n    \"503 Service Unavailable\",\n    \"504 Gateway Timeout\",\n    \"505 HTTP Version Not Supported\",\n    \"506 Variant Also Negotiates\",\n    \"507 Insufficient Storage\",\n    \"508 Loop Detected\",\n    NULL, /* 509 */\n    \"510 Not Extended\",\n    \"511 Network Authentication Required\"\n}",
            "initializer": "{\n    \"100 Continue\",\n    \"101 Switching Protocols\",\n    \"102 Processing\",\n#define LEVEL_200  3\n    \"200 OK\",\n    \"201 Created\",\n    \"202 Accepted\",\n    \"203 Non-Authoritative Information\",\n    \"204 No Content\",\n    \"205 Reset Content\",\n    \"206 Partial Content\",\n    \"207 Multi-Status\",\n    \"208 Already Reported\",\n    NULL, /* 209 */\n    NULL, /* 210 */\n    NULL, /* 211 */\n    NULL, /* 212 */\n    NULL, /* 213 */\n    NULL, /* 214 */\n    NULL, /* 215 */\n    NULL, /* 216 */\n    NULL, /* 217 */\n    NULL, /* 218 */\n    NULL, /* 219 */\n    NULL, /* 220 */\n    NULL, /* 221 */\n    NULL, /* 222 */\n    NULL, /* 223 */\n    NULL, /* 224 */\n    NULL, /* 225 */\n    \"226 IM Used\",\n#define LEVEL_300 30\n    \"300 Multiple Choices\",\n    \"301 Moved Permanently\",\n    \"302 Found\",\n    \"303 See Other\",\n    \"304 Not Modified\",\n    \"305 Use Proxy\",\n    NULL, /* 306 */\n    \"307 Temporary Redirect\",\n    \"308 Permanent Redirect\",\n#define LEVEL_400 39\n    \"400 Bad Request\",\n    \"401 Unauthorized\",\n    \"402 Payment Required\",\n    \"403 Forbidden\",\n    \"404 Not Found\",\n    \"405 Method Not Allowed\",\n    \"406 Not Acceptable\",\n    \"407 Proxy Authentication Required\",\n    \"408 Request Timeout\",\n    \"409 Conflict\",\n    \"410 Gone\",\n    \"411 Length Required\",\n    \"412 Precondition Failed\",\n    \"413 Request Entity Too Large\",\n    \"414 Request-URI Too Long\",\n    \"415 Unsupported Media Type\",\n    \"416 Requested Range Not Satisfiable\",\n    \"417 Expectation Failed\",\n    \"418 I'm A Teapot\",\n    NULL, /* 419 */\n    NULL, /* 420 */\n    \"421 Misdirected Request\",\n    \"422 Unprocessable Entity\",\n    \"423 Locked\",\n    \"424 Failed Dependency\",\n    \"425 Too Early\",\n    \"426 Upgrade Required\",\n    NULL, /* 427 */\n    \"428 Precondition Required\",\n    \"429 Too Many Requests\",\n    NULL, /* 430 */\n    \"431 Request Header Fields Too Large\",\n    NULL, /* 432 */\n    NULL, /* 433 */\n    NULL, /* 434 */\n    NULL, /* 435 */\n    NULL, /* 436 */\n    NULL, /* 437 */\n    NULL, /* 438 */\n    NULL, /* 439 */\n    NULL, /* 440 */\n    NULL, /* 441 */\n    NULL, /* 442 */\n    NULL, /* 443 */\n    NULL, /* 444 */\n    NULL, /* 445 */\n    NULL, /* 446 */\n    NULL, /* 447 */\n    NULL, /* 448 */\n    NULL, /* 449 */\n    NULL, /* 450 */\n    \"451 Unavailable For Legal Reasons\",\n#define LEVEL_500 91\n    \"500 Internal Server Error\",\n    \"501 Not Implemented\",\n    \"502 Bad Gateway\",\n    \"503 Service Unavailable\",\n    \"504 Gateway Timeout\",\n    \"505 HTTP Version Not Supported\",\n    \"506 Variant Also Negotiates\",\n    \"507 Insufficient Storage\",\n    \"508 Loop Detected\",\n    NULL, /* 509 */\n    \"510 Not Extended\",\n    \"511 Network Authentication Required\"\n}",
            "full_definition": "static const char * const status_lines[RESPONSE_CODES] =\n{\n    \"100 Continue\",\n    \"101 Switching Protocols\",\n    \"102 Processing\",\n#define LEVEL_200  3\n    \"200 OK\",\n    \"201 Created\",\n    \"202 Accepted\",\n    \"203 Non-Authoritative Information\",\n    \"204 No Content\",\n    \"205 Reset Content\",\n    \"206 Partial Content\",\n    \"207 Multi-Status\",\n    \"208 Already Reported\",\n    NULL, /* 209 */\n    NULL, /* 210 */\n    NULL, /* 211 */\n    NULL, /* 212 */\n    NULL, /* 213 */\n    NULL, /* 214 */\n    NULL, /* 215 */\n    NULL, /* 216 */\n    NULL, /* 217 */\n    NULL, /* 218 */\n    NULL, /* 219 */\n    NULL, /* 220 */\n    NULL, /* 221 */\n    NULL, /* 222 */\n    NULL, /* 223 */\n    NULL, /* 224 */\n    NULL, /* 225 */\n    \"226 IM Used\",\n#define LEVEL_300 30\n    \"300 Multiple Choices\",\n    \"301 Moved Permanently\",\n    \"302 Found\",\n    \"303 See Other\",\n    \"304 Not Modified\",\n    \"305 Use Proxy\",\n    NULL, /* 306 */\n    \"307 Temporary Redirect\",\n    \"308 Permanent Redirect\",\n#define LEVEL_400 39\n    \"400 Bad Request\",\n    \"401 Unauthorized\",\n    \"402 Payment Required\",\n    \"403 Forbidden\",\n    \"404 Not Found\",\n    \"405 Method Not Allowed\",\n    \"406 Not Acceptable\",\n    \"407 Proxy Authentication Required\",\n    \"408 Request Timeout\",\n    \"409 Conflict\",\n    \"410 Gone\",\n    \"411 Length Required\",\n    \"412 Precondition Failed\",\n    \"413 Request Entity Too Large\",\n    \"414 Request-URI Too Long\",\n    \"415 Unsupported Media Type\",\n    \"416 Requested Range Not Satisfiable\",\n    \"417 Expectation Failed\",\n    \"418 I'm A Teapot\",\n    NULL, /* 419 */\n    NULL, /* 420 */\n    \"421 Misdirected Request\",\n    \"422 Unprocessable Entity\",\n    \"423 Locked\",\n    \"424 Failed Dependency\",\n    \"425 Too Early\",\n    \"426 Upgrade Required\",\n    NULL, /* 427 */\n    \"428 Precondition Required\",\n    \"429 Too Many Requests\",\n    NULL, /* 430 */\n    \"431 Request Header Fields Too Large\",\n    NULL, /* 432 */\n    NULL, /* 433 */\n    NULL, /* 434 */\n    NULL, /* 435 */\n    NULL, /* 436 */\n    NULL, /* 437 */\n    NULL, /* 438 */\n    NULL, /* 439 */\n    NULL, /* 440 */\n    NULL, /* 441 */\n    NULL, /* 442 */\n    NULL, /* 443 */\n    NULL, /* 444 */\n    NULL, /* 445 */\n    NULL, /* 446 */\n    NULL, /* 447 */\n    NULL, /* 448 */\n    NULL, /* 449 */\n    NULL, /* 450 */\n    \"451 Unavailable For Legal Reasons\",\n#define LEVEL_500 91\n    \"500 Internal Server Error\",\n    \"501 Not Implemented\",\n    \"502 Bad Gateway\",\n    \"503 Service Unavailable\",\n    \"504 Gateway Timeout\",\n    \"505 HTTP Version Not Supported\",\n    \"506 Variant Also Negotiates\",\n    \"507 Insufficient Storage\",\n    \"508 Loop Detected\",\n    NULL, /* 509 */\n    \"510 Not Extended\",\n    \"511 Network Authentication Required\"\n}",
            "used_macros": {
              "LEVEL_200": {
                "name": "LEVEL_200",
                "value": "3",
                "definition": "#define LEVEL_200  3"
              },
              "LEVEL_300": {
                "name": "LEVEL_300",
                "value": "30",
                "definition": "#define LEVEL_300 30"
              },
              "LEVEL_400": {
                "name": "LEVEL_400",
                "value": "39",
                "definition": "#define LEVEL_400 39"
              },
              "LEVEL_500": {
                "name": "LEVEL_500",
                "value": "91",
                "definition": "#define LEVEL_500 91"
              }
            },
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(const char *) ap_get_status_line(int status)\n{\n    return status_lines[ap_index_of_response(status)];\n}"
    },
    "make_allow@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 872, column 14>": {
      "basic_info": {
        "function_id": 1655,
        "name": "make_allow",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 872, column 14>",
        "is_definition": true,
        "start_line": 872,
        "end_line": 906,
        "return_type": "char *",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_array_make": {
            "declaration": "APR_DECLARE(apr_array_header_t *) apr_array_make(apr_pool_t *p,\n                                                 int nelts, int elt_size)",
            "is_external": true,
            "definition": null
          },
          "apr_hash_first": {
            "declaration": "APR_DECLARE(apr_hash_index_t *) apr_hash_first(apr_pool_t *p, apr_hash_t *ht)",
            "is_external": true,
            "definition": null
          },
          "apr_hash_next": {
            "declaration": "APR_DECLARE(apr_hash_index_t *) apr_hash_next(apr_hash_index_t *hi)",
            "is_external": true,
            "definition": null
          },
          "apr_hash_this": {
            "declaration": "APR_DECLARE(void) apr_hash_this(apr_hash_index_t *hi, const void **key, \n                                apr_ssize_t *klen, void **val)",
            "is_external": true,
            "definition": null
          },
          "apr_array_push": {
            "declaration": "APR_DECLARE(void *) apr_array_push(apr_array_header_t *arr)",
            "is_external": true,
            "definition": null
          },
          "apr_array_cat": {
            "declaration": "APR_DECLARE(void) apr_array_cat(apr_array_header_t *dst,\n\t\t\t        const apr_array_header_t *src)",
            "is_external": true,
            "definition": null
          },
          "apr_array_pstrcat": {
            "declaration": "APR_DECLARE(char *) apr_array_pstrcat(apr_pool_t *p,\n\t\t\t\t      const apr_array_header_t *arr,\n\t\t\t\t      const char sep)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_send_error_response@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1212, column 18>": {
            "source_code": "AP_DECLARE(void) ap_send_error_response(request_rec *r, int recursive_error)\n{\n    int status = r->status;\n    int idx = ap_index_of_response(status);\n    char *custom_response;\n    const char *location = apr_table_get(r->headers_out, \"Location\");\n\n    /* At this point, we are starting the response over, so we have to reset\n     * this value.\n     */\n    r->eos_sent = 0;\n\n    /* and we need to get rid of any RESOURCE filters that might be lurking\n     * around, thinking they are in the middle of the original request\n     */\n\n    r->output_filters = r->proto_output_filters;\n\n    ap_run_insert_error_filter(r);\n\n    /* We need to special-case the handling of 204 and 304 responses,\n     * since they have specific HTTP requirements and do not include a\n     * message body.  Note that being assbackwards here is not an option.\n     */\n    if (AP_STATUS_IS_HEADER_ONLY(status)) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    /*\n     * It's possible that the Location field might be in r->err_headers_out\n     * instead of r->headers_out; use the latter if possible, else the\n     * former.\n     */\n    if (location == NULL) {\n        location = apr_table_get(r->err_headers_out, \"Location\");\n    }\n\n    if (!r->assbackwards) {\n\n        /* For all HTTP/1.x responses for which we generate the message,\n         * we need to avoid inheriting the \"normal status\" header fields\n         * that may have been set by the request handler before the\n         * error or redirect, except for Location on external redirects.\n         */\n        apr_table_clear(r->headers_out);\n\n        if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {\n            if ((location != NULL) && *location) {\n                apr_table_setn(r->headers_out, \"Location\", location);\n            }\n            else {\n                location = \"\";   /* avoids coredump when printing, below */\n            }\n        }\n\n        r->content_languages = NULL;\n        r->content_encoding = NULL;\n        r->clength = 0;\n\n        if (apr_table_get(r->subprocess_env,\n                          \"suppress-error-charset\") != NULL) {\n            core_request_config *request_conf =\n                        ap_get_core_module_config(r->request_config);\n            request_conf->suppress_charset = 1; /* avoid adding default\n                                                 * charset later\n                                                 */\n            ap_set_content_type_ex(r, \"text/html\", 1);\n        }\n        else {\n            ap_set_content_type_ex(r, \"text/html; charset=iso-8859-1\", 1);\n        }\n\n        if ((status == HTTP_METHOD_NOT_ALLOWED)\n            || (status == HTTP_NOT_IMPLEMENTED)) {\n            apr_table_setn(r->headers_out, \"Allow\", make_allow(r));\n        }\n\n        if (r->header_only) {\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n\n    if ((custom_response = ap_response_code_string(r, idx))) {\n        /*\n         * We have a custom response output. This should only be\n         * a text-string to write back. But if the ErrorDocument\n         * was a local redirect and the requested resource failed\n         * for any reason, the custom_response will still hold the\n         * redirect URL. We don't really want to output this URL\n         * as a text message, so first check the custom response\n         * string to ensure that it is a text-string (using the\n         * same test used in ap_die(), i.e. does it start with a \").\n         *\n         * If it's not a text string, we've got a recursive error or\n         * an external redirect.  If it's a recursive error, ap_die passes\n         * us the second error code so we can write both, and has already\n         * backed up to the original error.  If it's an external redirect,\n         * it hasn't happened yet; we may never know if it fails.\n         */\n        if (custom_response[0] == '\\\"') {\n            ap_rvputs_proto_in_ascii(r, custom_response + 1, NULL);\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n    {\n        const char *title = status_lines[idx];\n        const char *h1;\n\n        /* Accept a status_line set by a module, but only if it begins\n         * with the correct 3 digit status code\n         */\n        if (r->status_line) {\n            char *end;\n            int len = strlen(r->status_line);\n            if (len >= 3\n                && apr_strtoi64(r->status_line, &end, 10) == r->status\n                && (end - 3) == r->status_line\n                && (len < 4 || apr_isspace(r->status_line[3]))\n                && (len < 5 || apr_isalnum(r->status_line[4]))) {\n                /* Since we passed the above check, we know that length three\n                 * is equivalent to only a 3 digit numeric http status.\n                 * RFC2616 mandates a trailing space, let's add it.\n                 * If we have an empty reason phrase, we also add \"Unknown Reason\".\n                 */\n                if (len == 3) {\n                    r->status_line = apr_pstrcat(r->pool, r->status_line, \" Unknown Reason\", NULL);\n                } else if (len == 4) {\n                    r->status_line = apr_pstrcat(r->pool, r->status_line, \"Unknown Reason\", NULL);\n                }\n                title = r->status_line;\n            }\n        }\n\n        /* folks decided they didn't want the error code in the H1 text */\n        h1 = &title[4];\n\n        /* can't count on a charset filter being in place here,\n         * so do ebcdic->ascii translation explicitly (if needed)\n         */\n\n        ap_rvputs_proto_in_ascii(r,\n                  DOCTYPE_HTML_4_01\n                  \"<html><head>\\n<title>\", title,\n                  \"</title>\\n</head><body>\\n<h1>\", h1, \"</h1>\\n\",\n                  NULL);\n\n        ap_rvputs_proto_in_ascii(r,\n                                 get_canned_error_string(status, r, location),\n                                 NULL);\n\n        if (recursive_error) {\n            ap_rvputs_proto_in_ascii(r, \"<p>Additionally, a \",\n                      status_lines[ap_index_of_response(recursive_error)],\n                      \"\\nerror was encountered while trying to use an \"\n                      \"ErrorDocument to handle the request.</p>\\n\", NULL);\n        }\n        ap_rvputs_proto_in_ascii(r, ap_psignature(\"<hr>\\n\", r), NULL);\n        ap_rvputs_proto_in_ascii(r, \"</body></html>\\n\", NULL);\n    }\n    ap_finalize_request_protocol(r);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1212, column 18>"
          },
          "ap_send_http_options@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 908, column 17>": {
            "source_code": "AP_DECLARE(int) ap_send_http_options(request_rec *r)\n{\n    if (r->assbackwards) {\n        return DECLINED;\n    }\n\n    apr_table_setn(r->headers_out, \"Allow\", make_allow(r));\n\n    /* the request finalization will send an EOS, which will flush all\n     * the headers out (including the Allow header)\n     */\n\n    return OK;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 908, column 17>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_array_header_t": {
            "name": "apr_array_header_t",
            "definition": "struct apr_array_header_t {\n    /** The pool the array is allocated out of */\n    apr_pool_t *pool;\n    /** The amount of memory allocated for each element of the array */\n    int elt_size;\n    /** The number of active elements in the array */\n    int nelts;\n    /** The number of elements allocated in the array */\n    int nalloc;\n    /** The elements in the array */\n    char *elts;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "elt_size": "int",
              "nelts": "int",
              "nalloc": "int",
              "elts": "char *"
            },
            "condition": ""
          },
          "apr_hash_index_t": {
            "name": "apr_hash_index_t",
            "definition": "struct apr_hash_index_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          },
          "core_server_config": {
            "name": "core_server_config",
            "definition": "struct {\n\n    char *gprof_dir;\n\n    /* Name translations --- we want the core to be able to do *something*\n     * so it's at least a minimally functional web server on its own (and\n     * can be tested that way).  But let's keep it to the bare minimum:\n     */\n    const char *ap_document_root;\n\n    /* Access control */\n\n    char *access_name;\n    apr_array_header_t *sec_dir;\n    apr_array_header_t *sec_url;\n\n    /* recursion backstopper */\n    int redirect_limit; /* maximum number of internal redirects */\n    int subreq_limit;   /* maximum nesting level of subrequests */\n\n    const char *protocol;\n    apr_table_t *accf_map;\n\n    /* array of ap_errorlog_format_item for error log format string */\n    apr_array_header_t *error_log_format;\n    /*\n     * two arrays of arrays of ap_errorlog_format_item for additional information\n     * logged to the error log once per connection/request\n     */\n    apr_array_header_t *error_log_conn;\n    apr_array_header_t *error_log_req;\n\n    /* TRACE control */\n#define AP_TRACE_UNSET    -1\n#define AP_TRACE_DISABLE   0\n#define AP_TRACE_ENABLE    1\n#define AP_TRACE_EXTENDED  2\n    int trace_enable;\n#define AP_MERGE_TRAILERS_UNSET    0\n#define AP_MERGE_TRAILERS_ENABLE   1\n#define AP_MERGE_TRAILERS_DISABLE  2\n    int merge_trailers;\n\n    apr_array_header_t *protocols;\n    int protocols_honor_order;\n\n#define AP_HTTP09_UNSET   0\n#define AP_HTTP09_ENABLE  1\n#define AP_HTTP09_DISABLE 2\n    char http09_enable;\n\n#define AP_HTTP_CONFORMANCE_UNSET     0\n#define AP_HTTP_CONFORMANCE_UNSAFE    1\n#define AP_HTTP_CONFORMANCE_STRICT    2\n    char http_conformance;\n\n#define AP_HTTP_METHODS_UNSET         0\n#define AP_HTTP_METHODS_LENIENT       1\n#define AP_HTTP_METHODS_REGISTERED    2\n    char http_methods;\n    unsigned int merge_slashes;\n \n    apr_size_t   flush_max_threshold;\n    apr_int32_t  flush_max_pipelined;\n    unsigned int strict_host_check;\n#ifdef WIN32\n    apr_array_header_t *unc_list;\n#endif\n}",
            "typedef_name": null,
            "fields": {
              "gprof_dir": "char *",
              "ap_document_root": "const char *",
              "access_name": "char *",
              "sec_dir": "apr_array_header_t *",
              "sec_url": "apr_array_header_t *",
              "redirect_limit": "int",
              "subreq_limit": "int",
              "protocol": "const char *",
              "accf_map": "apr_table_t *",
              "error_log_format": "apr_array_header_t *",
              "error_log_conn": "apr_array_header_t *",
              "error_log_req": "apr_array_header_t *",
              "trace_enable": "int",
              "merge_trailers": "int",
              "protocols": "apr_array_header_t *",
              "protocols_honor_order": "int",
              "http09_enable": "char",
              "http_conformance": "char",
              "http_methods": "char",
              "merge_slashes": "unsigned int",
              "flush_max_threshold": "apr_size_t",
              "flush_max_pipelined": "apr_int32_t",
              "strict_host_check": "unsigned int"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "methods_registry": {
            "name": "methods_registry",
            "type": "apr_hash_t *",
            "is_extern": false,
            "is_static": true,
            "definition": "static apr_hash_t *methods_registry = NULL",
            "initializer": "NULL",
            "full_definition": "static apr_hash_t *methods_registry = NULL",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "static char *make_allow(request_rec *r)\n{\n    ap_method_mask_t mask;\n    apr_array_header_t *allow = apr_array_make(r->pool, 10, sizeof(char *));\n    apr_hash_index_t *hi = apr_hash_first(r->pool, methods_registry);\n    /* For TRACE below */\n    core_server_config *conf =\n        ap_get_core_module_config(r->server->module_config);\n\n    mask = r->allowed_methods->method_mask;\n\n    for (; hi; hi = apr_hash_next(hi)) {\n        const void *key;\n        void *val;\n\n        apr_hash_this(hi, &key, NULL, &val);\n        if ((mask & (AP_METHOD_BIT << *(int *)val)) != 0) {\n            APR_ARRAY_PUSH(allow, const char *) = key;\n        }\n    }\n\n    /* TRACE is tested on a per-server basis */\n    if (conf->trace_enable != AP_TRACE_DISABLE)\n        *(const char **)apr_array_push(allow) = \"TRACE\";\n\n    /* ### this is rather annoying. we should enforce registration of\n       ### these methods */\n    if ((mask & (AP_METHOD_BIT << M_INVALID))\n        && (r->allowed_methods->method_list != NULL)\n        && (r->allowed_methods->method_list->nelts != 0)) {\n        apr_array_cat(allow, r->allowed_methods->method_list);\n    }\n\n    return apr_array_pstrcat(r->pool, allow, ',');\n}"
    },
    "ap_send_http_options@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 908, column 17>": {
      "basic_info": {
        "function_id": 1656,
        "name": "ap_send_http_options",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 908, column 17>",
        "is_definition": true,
        "start_line": 908,
        "end_line": 921,
        "return_type": "int",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_table_setn": {
            "declaration": "APR_DECLARE(void) apr_table_setn(apr_table_t *t, const char *key,\n                                 const char *val)",
            "is_external": true,
            "definition": null
          },
          "make_allow": {
            "declaration": "static char *make_allow(request_rec *r)\n{\n    ap_method_mask_t mask;\n    apr_array_header_t *allow = apr_array_make(r->pool, 10, sizeof(char *));\n    apr_hash_index_t *hi = apr_hash_first(r->pool, methods_registry);\n    /* For TRACE below */\n    core_server_config *conf =\n        ap_get_core_module_config(r->server->module_config);\n\n    mask = r->allowed_methods->method_mask;\n\n    for (; hi; hi = apr_hash_next(hi)) {\n        const void *key;\n        void *val;\n\n        apr_hash_this(hi, &key, NULL, &val);\n        if ((mask & (AP_METHOD_BIT << *(int *)val)) != 0) {\n            APR_ARRAY_PUSH(allow, const char *) = key;\n        }\n    }\n\n    /* TRACE is tested on a per-server basis */\n    if (conf->trace_enable != AP_TRACE_DISABLE)\n        *(const char **)apr_array_push(allow) = \"TRACE\";\n\n    /* ### this is rather annoying. we should enforce registration of\n       ### these methods */\n    if ((mask & (AP_METHOD_BIT << M_INVALID))\n        && (r->allowed_methods->method_list != NULL)\n        && (r->allowed_methods->method_list->nelts != 0)) {\n        apr_array_cat(allow, r->allowed_methods->method_list);\n    }\n\n    return apr_array_pstrcat(r->pool, allow, ',');\n}",
            "is_external": false,
            "definition": "static char *make_allow(request_rec *r)\n{\n    ap_method_mask_t mask;\n    apr_array_header_t *allow = apr_array_make(r->pool, 10, sizeof(char *));\n    apr_hash_index_t *hi = apr_hash_first(r->pool, methods_registry);\n    /* For TRACE below */\n    core_server_config *conf =\n        ap_get_core_module_config(r->server->module_config);\n\n    mask = r->allowed_methods->method_mask;\n\n    for (; hi; hi = apr_hash_next(hi)) {\n        const void *key;\n        void *val;\n\n        apr_hash_this(hi, &key, NULL, &val);\n        if ((mask & (AP_METHOD_BIT << *(int *)val)) != 0) {\n            APR_ARRAY_PUSH(allow, const char *) = key;\n        }\n    }\n\n    /* TRACE is tested on a per-server basis */\n    if (conf->trace_enable != AP_TRACE_DISABLE)\n        *(const char **)apr_array_push(allow) = \"TRACE\";\n\n    /* ### this is rather annoying. we should enforce registration of\n       ### these methods */\n    if ((mask & (AP_METHOD_BIT << M_INVALID))\n        && (r->allowed_methods->method_list != NULL)\n        && (r->allowed_methods->method_list->nelts != 0)) {\n        apr_array_cat(allow, r->allowed_methods->method_list);\n    }\n\n    return apr_array_pstrcat(r->pool, allow, ',');\n}"
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(int) ap_send_http_options(request_rec *r)\n{\n    if (r->assbackwards) {\n        return DECLINED;\n    }\n\n    apr_table_setn(r->headers_out, \"Allow\", make_allow(r));\n\n    /* the request finalization will send an EOS, which will flush all\n     * the headers out (including the Allow header)\n     */\n\n    return OK;\n}"
    },
    "ap_set_content_type@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 923, column 18>": {
      "basic_info": {
        "function_id": 1657,
        "name": "ap_set_content_type",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 923, column 18>",
        "is_definition": true,
        "start_line": 923,
        "end_line": 932,
        "return_type": "void",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "ct",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "strcmp": {
            "declaration": "extern int strcmp (const char *__s1, const char *__s2)\n     __THROW __attribute_pure__ __nonnull ((1, 2))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_set_content_type_ex@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 933, column 18>": {
            "source_code": "AP_DECLARE(void) ap_set_content_type_ex(request_rec *r, const char *ct, int trusted)\n{\n    ap_set_content_type(r, ct);\n    AP_REQUEST_SET_BNOTE(r, AP_REQUEST_TRUSTED_CT, trusted ? AP_REQUEST_TRUSTED_CT : 0);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 933, column 18>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(void) ap_set_content_type(request_rec *r, const char *ct)\n{\n    if (!ct) {\n        r->content_type = NULL;\n    }\n    else if (!r->content_type || strcmp(r->content_type, ct)) {\n        r->content_type = ct;\n        AP_REQUEST_SET_BNOTE(r, AP_REQUEST_TRUSTED_CT, 0);\n    }\n}"
    },
    "ap_set_content_type_ex@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 933, column 18>": {
      "basic_info": {
        "function_id": 1658,
        "name": "ap_set_content_type_ex",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 933, column 18>",
        "is_definition": true,
        "start_line": 933,
        "end_line": 937,
        "return_type": "void",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "ct",
            "type": "const char *"
          },
          {
            "name": "trusted",
            "type": "int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_set_content_type": {
            "declaration": "AP_DECLARE(void) ap_set_content_type(request_rec *r, const char *ct)\n{\n    if (!ct) {\n        r->content_type = NULL;\n    }\n    else if (!r->content_type || strcmp(r->content_type, ct)) {\n        r->content_type = ct;\n        AP_REQUEST_SET_BNOTE(r, AP_REQUEST_TRUSTED_CT, 0);\n    }\n}",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_set_content_type(request_rec *r, const char *ct)\n{\n    if (!ct) {\n        r->content_type = NULL;\n    }\n    else if (!r->content_type || strcmp(r->content_type, ct)) {\n        r->content_type = ct;\n        AP_REQUEST_SET_BNOTE(r, AP_REQUEST_TRUSTED_CT, 0);\n    }\n}"
          }
        },
        "callers": {
          "ap_send_error_response@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1212, column 18>": {
            "source_code": "AP_DECLARE(void) ap_send_error_response(request_rec *r, int recursive_error)\n{\n    int status = r->status;\n    int idx = ap_index_of_response(status);\n    char *custom_response;\n    const char *location = apr_table_get(r->headers_out, \"Location\");\n\n    /* At this point, we are starting the response over, so we have to reset\n     * this value.\n     */\n    r->eos_sent = 0;\n\n    /* and we need to get rid of any RESOURCE filters that might be lurking\n     * around, thinking they are in the middle of the original request\n     */\n\n    r->output_filters = r->proto_output_filters;\n\n    ap_run_insert_error_filter(r);\n\n    /* We need to special-case the handling of 204 and 304 responses,\n     * since they have specific HTTP requirements and do not include a\n     * message body.  Note that being assbackwards here is not an option.\n     */\n    if (AP_STATUS_IS_HEADER_ONLY(status)) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    /*\n     * It's possible that the Location field might be in r->err_headers_out\n     * instead of r->headers_out; use the latter if possible, else the\n     * former.\n     */\n    if (location == NULL) {\n        location = apr_table_get(r->err_headers_out, \"Location\");\n    }\n\n    if (!r->assbackwards) {\n\n        /* For all HTTP/1.x responses for which we generate the message,\n         * we need to avoid inheriting the \"normal status\" header fields\n         * that may have been set by the request handler before the\n         * error or redirect, except for Location on external redirects.\n         */\n        apr_table_clear(r->headers_out);\n\n        if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {\n            if ((location != NULL) && *location) {\n                apr_table_setn(r->headers_out, \"Location\", location);\n            }\n            else {\n                location = \"\";   /* avoids coredump when printing, below */\n            }\n        }\n\n        r->content_languages = NULL;\n        r->content_encoding = NULL;\n        r->clength = 0;\n\n        if (apr_table_get(r->subprocess_env,\n                          \"suppress-error-charset\") != NULL) {\n            core_request_config *request_conf =\n                        ap_get_core_module_config(r->request_config);\n            request_conf->suppress_charset = 1; /* avoid adding default\n                                                 * charset later\n                                                 */\n            ap_set_content_type_ex(r, \"text/html\", 1);\n        }\n        else {\n            ap_set_content_type_ex(r, \"text/html; charset=iso-8859-1\", 1);\n        }\n\n        if ((status == HTTP_METHOD_NOT_ALLOWED)\n            || (status == HTTP_NOT_IMPLEMENTED)) {\n            apr_table_setn(r->headers_out, \"Allow\", make_allow(r));\n        }\n\n        if (r->header_only) {\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n\n    if ((custom_response = ap_response_code_string(r, idx))) {\n        /*\n         * We have a custom response output. This should only be\n         * a text-string to write back. But if the ErrorDocument\n         * was a local redirect and the requested resource failed\n         * for any reason, the custom_response will still hold the\n         * redirect URL. We don't really want to output this URL\n         * as a text message, so first check the custom response\n         * string to ensure that it is a text-string (using the\n         * same test used in ap_die(), i.e. does it start with a \").\n         *\n         * If it's not a text string, we've got a recursive error or\n         * an external redirect.  If it's a recursive error, ap_die passes\n         * us the second error code so we can write both, and has already\n         * backed up to the original error.  If it's an external redirect,\n         * it hasn't happened yet; we may never know if it fails.\n         */\n        if (custom_response[0] == '\\\"') {\n            ap_rvputs_proto_in_ascii(r, custom_response + 1, NULL);\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n    {\n        const char *title = status_lines[idx];\n        const char *h1;\n\n        /* Accept a status_line set by a module, but only if it begins\n         * with the correct 3 digit status code\n         */\n        if (r->status_line) {\n            char *end;\n            int len = strlen(r->status_line);\n            if (len >= 3\n                && apr_strtoi64(r->status_line, &end, 10) == r->status\n                && (end - 3) == r->status_line\n                && (len < 4 || apr_isspace(r->status_line[3]))\n                && (len < 5 || apr_isalnum(r->status_line[4]))) {\n                /* Since we passed the above check, we know that length three\n                 * is equivalent to only a 3 digit numeric http status.\n                 * RFC2616 mandates a trailing space, let's add it.\n                 * If we have an empty reason phrase, we also add \"Unknown Reason\".\n                 */\n                if (len == 3) {\n                    r->status_line = apr_pstrcat(r->pool, r->status_line, \" Unknown Reason\", NULL);\n                } else if (len == 4) {\n                    r->status_line = apr_pstrcat(r->pool, r->status_line, \"Unknown Reason\", NULL);\n                }\n                title = r->status_line;\n            }\n        }\n\n        /* folks decided they didn't want the error code in the H1 text */\n        h1 = &title[4];\n\n        /* can't count on a charset filter being in place here,\n         * so do ebcdic->ascii translation explicitly (if needed)\n         */\n\n        ap_rvputs_proto_in_ascii(r,\n                  DOCTYPE_HTML_4_01\n                  \"<html><head>\\n<title>\", title,\n                  \"</title>\\n</head><body>\\n<h1>\", h1, \"</h1>\\n\",\n                  NULL);\n\n        ap_rvputs_proto_in_ascii(r,\n                                 get_canned_error_string(status, r, location),\n                                 NULL);\n\n        if (recursive_error) {\n            ap_rvputs_proto_in_ascii(r, \"<p>Additionally, a \",\n                      status_lines[ap_index_of_response(recursive_error)],\n                      \"\\nerror was encountered while trying to use an \"\n                      \"ErrorDocument to handle the request.</p>\\n\", NULL);\n        }\n        ap_rvputs_proto_in_ascii(r, ap_psignature(\"<hr>\\n\", r), NULL);\n        ap_rvputs_proto_in_ascii(r, \"</body></html>\\n\", NULL);\n    }\n    ap_finalize_request_protocol(r);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1212, column 18>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(void) ap_set_content_type_ex(request_rec *r, const char *ct, int trusted)\n{\n    ap_set_content_type(r, ct);\n    AP_REQUEST_SET_BNOTE(r, AP_REQUEST_TRUSTED_CT, trusted ? AP_REQUEST_TRUSTED_CT : 0);\n}"
    },
    "ap_set_accept_ranges@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 939, column 18>": {
      "basic_info": {
        "function_id": 1659,
        "name": "ap_set_accept_ranges",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 939, column 18>",
        "is_definition": true,
        "start_line": 939,
        "end_line": 945,
        "return_type": "void",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_table_setn": {
            "declaration": "APR_DECLARE(void) apr_table_setn(apr_table_t *t, const char *key,\n                                 const char *val)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "core_dir_config": {
            "name": "core_dir_config",
            "definition": "struct {\n    /** path of the directory/regex/etc. see also d_is_fnmatch/absolute below */\n    char *d;\n    /** the number of slashes in d */\n    unsigned d_components;\n\n    /** If (opts & OPT_UNSET) then no absolute assignment to options has\n     * been made.\n     * invariant: (opts_add & opts_remove) == 0\n     * Which said another way means that the last relative (options + or -)\n     * assignment made to each bit is recorded in exactly one of opts_add\n     * or opts_remove.\n     */\n    allow_options_t opts;\n    allow_options_t opts_add;\n    allow_options_t opts_remove;\n    overrides_t override;\n    allow_options_t override_opts;\n\n    /* Used to be the custom response config. No longer used. */\n    char **response_code_strings; /* from ErrorDocument, not from\n                                   * ap_custom_response() */\n\n    /* Hostname resolution etc */\n#define HOSTNAME_LOOKUP_OFF     0\n#define HOSTNAME_LOOKUP_ON      1\n#define HOSTNAME_LOOKUP_DOUBLE  2\n#define HOSTNAME_LOOKUP_UNSET   3\n    unsigned int hostname_lookups : 4;\n\n    unsigned int content_md5 : 2;  /* calculate Content-MD5? */\n\n#define USE_CANONICAL_NAME_OFF   (0)\n#define USE_CANONICAL_NAME_ON    (1)\n#define USE_CANONICAL_NAME_DNS   (2)\n#define USE_CANONICAL_NAME_UNSET (3)\n    unsigned use_canonical_name : 2;\n\n    /* since is_fnmatch(conf->d) was being called so frequently in\n     * directory_walk() and its relatives, this field was created and\n     * is set to the result of that call.\n     */\n    unsigned d_is_fnmatch : 1;\n\n    /* should we force a charset on any outgoing parameterless content-type?\n     * if so, which charset?\n     */\n#define ADD_DEFAULT_CHARSET_OFF   (0)\n#define ADD_DEFAULT_CHARSET_ON    (1)\n#define ADD_DEFAULT_CHARSET_UNSET (2)\n    unsigned add_default_charset : 2;\n    const char *add_default_charset_name;\n\n    /* System Resource Control */\n#ifdef RLIMIT_CPU\n    struct rlimit *limit_cpu;\n#endif\n#if defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined(RLIMIT_AS)\n    struct rlimit *limit_mem;\n#endif\n#ifdef RLIMIT_NPROC\n    struct rlimit *limit_nproc;\n#endif\n    apr_off_t limit_req_body;      /* limit on bytes in request msg body */\n    long limit_xml_body;           /* limit on bytes in XML request msg body */\n\n    /* logging options */\n\n    server_signature_e server_signature;\n\n    /* Access control */\n    apr_array_header_t *sec_file;\n    apr_array_header_t *sec_if;\n    ap_regex_t *r;\n\n    const char *mime_type;       /* forced with ForceType  */\n    const char *handler;         /* forced by something other than SetHandler */\n    const char *output_filters;  /* forced with SetOutputFilters */\n    const char *input_filters;   /* forced with SetInputFilters */\n    int accept_path_info;        /* forced with AcceptPathInfo */\n\n    /*\n     * What attributes/data should be included in ETag generation?\n     */\n    etag_components_t etag_bits;\n    etag_components_t etag_add;\n    etag_components_t etag_remove;\n\n    /*\n     * Run-time performance tuning\n     */\n#define ENABLE_MMAP_OFF    (0)\n#define ENABLE_MMAP_ON     (1)\n#define ENABLE_MMAP_UNSET  (2)\n    unsigned int enable_mmap : 2;  /* whether files in this dir can be mmap'ed */\n\n#define ENABLE_SENDFILE_OFF    (0)\n#define ENABLE_SENDFILE_ON     (1)\n#define ENABLE_SENDFILE_UNSET  (2)\n    unsigned int enable_sendfile : 2;  /* files in this dir can be sendfile'ed */\n\n#define USE_CANONICAL_PHYS_PORT_OFF   (0)\n#define USE_CANONICAL_PHYS_PORT_ON    (1)\n#define USE_CANONICAL_PHYS_PORT_UNSET (2)\n    unsigned int use_canonical_phys_port : 2;\n\n    unsigned int allow_encoded_slashes : 1; /* URLs may contain %2f w/o being\n                                             * pitched indiscriminately */\n    unsigned int decode_encoded_slashes : 1; /* whether to decode encoded slashes in URLs */\n\n#define AP_CONDITION_IF        1\n#define AP_CONDITION_ELSE      2\n#define AP_CONDITION_ELSEIF    (AP_CONDITION_ELSE|AP_CONDITION_IF)\n    unsigned int condition_ifelse : 2; /* is this an <If>, <ElseIf>, or <Else> */\n\n    ap_expr_info_t *condition;   /* Conditionally merge <If> sections */\n\n    /** per-dir log config */\n    struct ap_logconf *log;\n\n    /** Table of directives allowed per AllowOverrideList */\n    apr_table_t *override_list;\n\n#define AP_MAXRANGES_UNSET     -1\n#define AP_MAXRANGES_DEFAULT   -2\n#define AP_MAXRANGES_UNLIMITED -3\n#define AP_MAXRANGES_NORANGES   0\n    /** Number of Ranges before returning HTTP_OK. **/\n    int max_ranges;\n    /** Max number of Range overlaps (merges) allowed **/\n    int max_overlaps;\n    /** Max number of Range reversals (eg: 200-300, 100-125) allowed **/\n    int max_reversals;\n\n    /** Named back references */\n    apr_array_header_t *refs;\n\n    /** Custom response config with expression support. The hash table\n     * contains compiled expressions keyed against the custom response\n     * code.\n     */\n    apr_hash_t *response_code_exprs;\n\n#define AP_CGI_PASS_AUTH_OFF     (0)\n#define AP_CGI_PASS_AUTH_ON      (1)\n#define AP_CGI_PASS_AUTH_UNSET   (2)\n    /** CGIPassAuth: Whether HTTP authorization headers will be passed to\n     * scripts as CGI variables; affects all modules calling\n     * ap_add_common_vars(), as well as any others using this field as \n     * advice\n     */\n    unsigned int cgi_pass_auth : 2;\n    unsigned int qualify_redirect_url :2;\n    ap_expr_info_t  *expr_handler;         /* forced with SetHandler */\n\n    /** Table of rules for building CGI variables, NULL if none configured */\n    apr_hash_t *cgi_var_rules;\n\n    apr_size_t read_buf_size;\n}",
            "typedef_name": null,
            "fields": {
              "d": "char *",
              "d_components": "unsigned int",
              "opts": "allow_options_t",
              "opts_add": "allow_options_t",
              "opts_remove": "allow_options_t",
              "override": "overrides_t",
              "override_opts": "allow_options_t",
              "response_code_strings": "char **",
              "hostname_lookups": "unsigned int",
              "content_md5": "unsigned int",
              "use_canonical_name": "unsigned int",
              "d_is_fnmatch": "unsigned int",
              "add_default_charset": "unsigned int",
              "add_default_charset_name": "const char *",
              "limit_cpu": "struct rlimit *",
              "limit_mem": "struct rlimit *",
              "limit_nproc": "struct rlimit *",
              "limit_req_body": "apr_off_t",
              "limit_xml_body": "long",
              "server_signature": "server_signature_e",
              "sec_file": "apr_array_header_t *",
              "sec_if": "apr_array_header_t *",
              "r": "ap_regex_t *",
              "mime_type": "const char *",
              "handler": "const char *",
              "output_filters": "const char *",
              "input_filters": "const char *",
              "accept_path_info": "int",
              "etag_bits": "etag_components_t",
              "etag_add": "etag_components_t",
              "etag_remove": "etag_components_t",
              "enable_mmap": "unsigned int",
              "enable_sendfile": "unsigned int",
              "use_canonical_phys_port": "unsigned int",
              "allow_encoded_slashes": "unsigned int",
              "decode_encoded_slashes": "unsigned int",
              "condition_ifelse": "unsigned int",
              "condition": "ap_expr_info_t *",
              "log": "struct ap_logconf *",
              "override_list": "apr_table_t *",
              "max_ranges": "int",
              "max_overlaps": "int",
              "max_reversals": "int",
              "refs": "apr_array_header_t *",
              "response_code_exprs": "apr_hash_t *",
              "cgi_pass_auth": "unsigned int",
              "qualify_redirect_url": "unsigned int",
              "expr_handler": "ap_expr_info_t *",
              "cgi_var_rules": "apr_hash_t *",
              "read_buf_size": "apr_size_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(void) ap_set_accept_ranges(request_rec *r)\n{\n    core_dir_config *d = ap_get_core_module_config(r->per_dir_config);\n    apr_table_setn(r->headers_out, \"Accept-Ranges\",\n                  (d->max_ranges == AP_MAXRANGES_NORANGES) ? \"none\"\n                                                           : \"bytes\");\n}"
    },
    "add_optional_notes@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 946, column 20>": {
      "basic_info": {
        "function_id": 1660,
        "name": "add_optional_notes",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 946, column 20>",
        "is_definition": true,
        "start_line": 946,
        "end_line": 961,
        "return_type": "const char *",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "prefix",
            "type": "const char *"
          },
          {
            "name": "key",
            "type": "const char *"
          },
          {
            "name": "suffix",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "apr_pstrcat": {
            "declaration": "APR_DECLARE_NONSTD(char *) apr_pstrcat(apr_pool_t *p, ...)\n#if defined(__GNUC__) && __GNUC__ >= 4\n    __attribute__((sentinel))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "get_canned_error_string@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 966, column 20>": {
            "source_code": "static const char *get_canned_error_string(int status,\n                                           request_rec *r,\n                                           const char *location)\n{\n    apr_pool_t *p = r->pool;\n    const char *error_notes, *h1, *s1;\n\n    switch (status) {\n    case HTTP_MOVED_PERMANENTLY:\n    case HTTP_MOVED_TEMPORARILY:\n    case HTTP_TEMPORARY_REDIRECT:\n    case HTTP_PERMANENT_REDIRECT:\n        return(apr_pstrcat(p,\n                           \"<p>The document has moved <a href=\\\"\",\n                           ap_escape_html(r->pool, location),\n                           \"\\\">here</a>.</p>\\n\",\n                           NULL));\n    case HTTP_SEE_OTHER:\n        return(apr_pstrcat(p,\n                           \"<p>The answer to your request is located \"\n                           \"<a href=\\\"\",\n                           ap_escape_html(r->pool, location),\n                           \"\\\">here</a>.</p>\\n\",\n                           NULL));\n    case HTTP_USE_PROXY:\n        return(\"<p>This resource is only accessible \"\n               \"through the proxy\\n\"\n               \"<br />\\nYou will need to configure \"\n               \"your client to use that proxy.</p>\\n\");\n    case HTTP_PROXY_AUTHENTICATION_REQUIRED:\n    case HTTP_UNAUTHORIZED:\n        return(\"<p>This server could not verify that you\\n\"\n               \"are authorized to access the document\\n\"\n               \"requested.  Either you supplied the wrong\\n\"\n               \"credentials (e.g., bad password), or your\\n\"\n               \"browser doesn't understand how to supply\\n\"\n               \"the credentials required.</p>\\n\");\n    case HTTP_BAD_REQUEST:\n        return(add_optional_notes(r,\n                                  \"<p>Your browser sent a request that \"\n                                  \"this server could not understand.<br />\\n\",\n                                  \"error-notes\",\n                                  \"</p>\\n\"));\n    case HTTP_FORBIDDEN:\n        return(add_optional_notes(r, \"<p>You don't have permission to access this resource.\", \"error-notes\", \"</p>\\n\"));\n    case HTTP_NOT_FOUND:\n        return(\"<p>The requested URL was not found on this server.</p>\\n\");\n    case HTTP_METHOD_NOT_ALLOWED:\n        return(apr_pstrcat(p,\n                           \"<p>The requested method \",\n                           ap_escape_html(r->pool, r->method),\n                           \" is not allowed for this URL.</p>\\n\",\n                           NULL));\n    case HTTP_NOT_ACCEPTABLE:\n        return(add_optional_notes(r, \n            \"<p>An appropriate representation of the requested resource \"\n            \"could not be found on this server.</p>\\n\",\n            \"variant-list\", \"\"));\n    case HTTP_MULTIPLE_CHOICES:\n        return(add_optional_notes(r, \"\", \"variant-list\", \"\"));\n    case HTTP_LENGTH_REQUIRED:\n        s1 = apr_pstrcat(p,\n                         \"<p>A request of the requested method \",\n                         ap_escape_html(r->pool, r->method),\n                         \" requires a valid Content-length.<br />\\n\",\n                         NULL);\n        return(add_optional_notes(r, s1, \"error-notes\", \"</p>\\n\"));\n    case HTTP_PRECONDITION_FAILED:\n        return(\"<p>The precondition on the request \"\n               \"for this URL evaluated to false.</p>\\n\");\n    case HTTP_NOT_IMPLEMENTED:\n        s1 = apr_pstrcat(p,\n                         \"<p>\",\n                         ap_escape_html(r->pool, r->method),\n                         \" not supported for current URL.<br />\\n\",\n                         NULL);\n        return(add_optional_notes(r, s1, \"error-notes\", \"</p>\\n\"));\n    case HTTP_BAD_GATEWAY:\n        s1 = \"<p>The proxy server received an invalid\" CRLF\n            \"response from an upstream server.<br />\" CRLF;\n        return(add_optional_notes(r, s1, \"error-notes\", \"</p>\\n\"));\n    case HTTP_VARIANT_ALSO_VARIES:\n        return(\"<p>A variant for the requested \"\n               \"resource\\n<pre>\\n\"\n               \"\\n</pre>\\nis itself a negotiable resource. \"\n               \"This indicates a configuration error.</p>\\n\");\n    case HTTP_REQUEST_TIME_OUT:\n        return(\"<p>Server timeout waiting for the HTTP request from the client.</p>\\n\");\n    case HTTP_GONE:\n        return(\"<p>The requested resource is no longer available on this server\"\n               \" and there is no forwarding address.\\n\"\n               \"Please remove all references to this resource.</p>\\n\");\n    case HTTP_REQUEST_ENTITY_TOO_LARGE:\n        return(apr_pstrcat(p,\n                           \"The requested resource does not allow request data with \",\n                           ap_escape_html(r->pool, r->method),\n                           \" requests, or the amount of data provided in\\n\"\n                           \"the request exceeds the capacity limit.\\n\",\n                           NULL));\n    case HTTP_REQUEST_URI_TOO_LARGE:\n        s1 = \"<p>The requested URL's length exceeds the capacity\\n\"\n             \"limit for this server.<br />\\n\";\n        return(add_optional_notes(r, s1, \"error-notes\", \"</p>\\n\"));\n    case HTTP_UNSUPPORTED_MEDIA_TYPE:\n        return(\"<p>The supplied request data is not in a format\\n\"\n               \"acceptable for processing by this resource.</p>\\n\");\n    case HTTP_RANGE_NOT_SATISFIABLE:\n        return(\"<p>None of the range-specifier values in the Range\\n\"\n               \"request-header field overlap the current extent\\n\"\n               \"of the selected resource.</p>\\n\");\n    case HTTP_EXPECTATION_FAILED:\n        s1 = apr_table_get(r->headers_in, \"Expect\");\n        if (s1)\n            s1 = apr_pstrcat(p,\n                     \"<p>The expectation given in the Expect request-header\\n\"\n                     \"field could not be met by this server.\\n\"\n                     \"The client sent<pre>\\n    Expect: \",\n                     ap_escape_html(r->pool, s1), \"\\n</pre>\\n\",\n                     NULL);\n        else\n            s1 = \"<p>No expectation was seen, the Expect request-header \\n\"\n                 \"field was not presented by the client.\\n\";\n        return add_optional_notes(r, s1, \"error-notes\", \"</p>\"\n                   \"<p>Only the 100-continue expectation is supported.</p>\\n\");\n    case HTTP_UNPROCESSABLE_ENTITY:\n        return(\"<p>The server understands the media type of the\\n\"\n               \"request entity, but was unable to process the\\n\"\n               \"contained instructions.</p>\\n\");\n    case HTTP_LOCKED:\n        return(\"<p>The requested resource is currently locked.\\n\"\n               \"The lock must be released or proper identification\\n\"\n               \"given before the method can be applied.</p>\\n\");\n    case HTTP_FAILED_DEPENDENCY:\n        return(\"<p>The method could not be performed on the resource\\n\"\n               \"because the requested action depended on another\\n\"\n               \"action and that other action failed.</p>\\n\");\n    case HTTP_TOO_EARLY:\n        return(\"<p>The request could not be processed as TLS\\n\"\n               \"early data and should be retried.</p>\\n\");\n    case HTTP_UPGRADE_REQUIRED:\n        return(\"<p>The requested resource can only be retrieved\\n\"\n               \"using SSL.  The server is willing to upgrade the current\\n\"\n               \"connection to SSL, but your client doesn't support it.\\n\"\n               \"Either upgrade your client, or try requesting the page\\n\"\n               \"using https://\\n\");\n    case HTTP_PRECONDITION_REQUIRED:\n        return(\"<p>The request is required to be conditional.</p>\\n\");\n    case HTTP_TOO_MANY_REQUESTS:\n        return(\"<p>The user has sent too many requests\\n\"\n               \"in a given amount of time.</p>\\n\");\n    case HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE:\n        return(\"<p>The server refused this request because\\n\"\n               \"the request header fields are too large.</p>\\n\");\n    case HTTP_INSUFFICIENT_STORAGE:\n        return(\"<p>The method could not be performed on the resource\\n\"\n               \"because the server is unable to store the\\n\"\n               \"representation needed to successfully complete the\\n\"\n               \"request.  There is insufficient free space left in\\n\"\n               \"your storage allocation.</p>\\n\");\n    case HTTP_SERVICE_UNAVAILABLE:\n        return(\"<p>The server is temporarily unable to service your\\n\"\n               \"request due to maintenance downtime or capacity\\n\"\n               \"problems. Please try again later.</p>\\n\");\n    case HTTP_GATEWAY_TIME_OUT:\n        return(\"<p>The gateway did not receive a timely response\\n\"\n               \"from the upstream server or application.</p>\\n\");\n    case HTTP_LOOP_DETECTED:\n        return(\"<p>The server terminated an operation because\\n\"\n               \"it encountered an infinite loop.</p>\\n\");\n    case HTTP_NOT_EXTENDED:\n        return(\"<p>A mandatory extension policy in the request is not\\n\"\n               \"accepted by the server for this resource.</p>\\n\");\n    case HTTP_NETWORK_AUTHENTICATION_REQUIRED:\n        return(\"<p>The client needs to authenticate to gain\\n\"\n               \"network access.</p>\\n\");\n    case HTTP_IM_A_TEAPOT:\n        return(\"<p>The resulting entity body MAY be short and\\n\"\n                \"stout.</p>\\n\");\n    case HTTP_MISDIRECTED_REQUEST:\n        return(\"<p>The client needs a new connection for this\\n\"\n               \"request as the requested host name does not match\\n\"\n               \"the Server Name Indication (SNI) in use for this\\n\"\n               \"connection.</p>\\n\");\n    case HTTP_UNAVAILABLE_FOR_LEGAL_REASONS:\n        return(add_optional_notes(r, \n               \"<p>Access to this URL has been denied for legal reasons.<br />\\n\",\n               \"error-notes\", \"</p>\\n\"));\n    default:                    /* HTTP_INTERNAL_SERVER_ERROR */\n        /*\n         * This comparison to expose error-notes could be modified to\n         * use a configuration directive and export based on that\n         * directive.  For now \"*\" is used to designate an error-notes\n         * that is totally safe for any user to see (ie lacks paths,\n         * database passwords, etc.)\n         */\n        if (((error_notes = apr_table_get(r->notes,\n                                          \"error-notes\")) != NULL)\n            && (h1 = apr_table_get(r->notes, \"verbose-error-to\")) != NULL\n            && (strcmp(h1, \"*\") == 0)) {\n            return(apr_pstrcat(p, error_notes, \"<p />\\n\", NULL));\n        }\n        else {\n            return(apr_pstrcat(p,\n                               \"<p>The server encountered an internal \"\n                               \"error or\\n\"\n                               \"misconfiguration and was unable to complete\\n\"\n                               \"your request.</p>\\n\"\n                               \"<p>Please contact the server \"\n                               \"administrator at \\n \",\n                               ap_escape_html(r->pool,\n                                              r->server->server_admin),\n                               \" to inform them of the time this \"\n                               \"error occurred,\\n\"\n                               \" and the actions you performed just before \"\n                               \"this error.</p>\\n\"\n                               \"<p>More information about this error \"\n                               \"may be available\\n\"\n                               \"in the server error log.</p>\\n\",\n                               NULL));\n        }\n        /*\n         * It would be nice to give the user the information they need to\n         * fix the problem directly since many users don't have access to\n         * the error_log (think University sites) even though they can easily\n         * get this error by misconfiguring an htaccess file.  However, the\n         * e error notes tend to include the real file pathname in this case,\n         * which some people consider to be a breach of privacy.  Until we\n         * can figure out a way to remove the pathname, leave this commented.\n         *\n         * if ((error_notes = apr_table_get(r->notes,\n         *                                  \"error-notes\")) != NULL) {\n         *     return(apr_pstrcat(p, error_notes, \"<p />\\n\", NULL);\n         * }\n         * else {\n         *     return \"\";\n         * }\n         */\n    }\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 966, column 20>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static const char *add_optional_notes(request_rec *r,\n                                      const char *prefix,\n                                      const char *key,\n                                      const char *suffix)\n{\n    const char *notes, *result;\n\n    if ((notes = apr_table_get(r->notes, key)) == NULL) {\n        result = apr_pstrcat(r->pool, prefix, suffix, NULL);\n    }\n    else {\n        result = apr_pstrcat(r->pool, prefix, notes, suffix, NULL);\n    }\n\n    return result;\n}"
    },
    "get_canned_error_string@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 966, column 20>": {
      "basic_info": {
        "function_id": 1661,
        "name": "get_canned_error_string",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 966, column 20>",
        "is_definition": true,
        "start_line": 966,
        "end_line": 1204,
        "return_type": "const char *",
        "parameters": [
          {
            "name": "status",
            "type": "int"
          },
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "location",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_pstrcat": {
            "declaration": "APR_DECLARE_NONSTD(char *) apr_pstrcat(apr_pool_t *p, ...)\n#if defined(__GNUC__) && __GNUC__ >= 4\n    __attribute__((sentinel))",
            "is_external": true,
            "definition": null
          },
          "ap_escape_html2": {
            "declaration": "AP_DECLARE(char *) ap_escape_html2(apr_pool_t *p, const char *s, int toasc)",
            "is_external": true,
            "definition": null
          },
          "add_optional_notes": {
            "declaration": "static const char *add_optional_notes(request_rec *r,\n                                      const char *prefix,\n                                      const char *key,\n                                      const char *suffix)\n{\n    const char *notes, *result;\n\n    if ((notes = apr_table_get(r->notes, key)) == NULL) {\n        result = apr_pstrcat(r->pool, prefix, suffix, NULL);\n    }\n    else {\n        result = apr_pstrcat(r->pool, prefix, notes, suffix, NULL);\n    }\n\n    return result;\n}",
            "is_external": false,
            "definition": "static const char *add_optional_notes(request_rec *r,\n                                      const char *prefix,\n                                      const char *key,\n                                      const char *suffix)\n{\n    const char *notes, *result;\n\n    if ((notes = apr_table_get(r->notes, key)) == NULL) {\n        result = apr_pstrcat(r->pool, prefix, suffix, NULL);\n    }\n    else {\n        result = apr_pstrcat(r->pool, prefix, notes, suffix, NULL);\n    }\n\n    return result;\n}"
          },
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "strcmp": {
            "declaration": "extern int strcmp (const char *__s1, const char *__s2)\n     __THROW __attribute_pure__ __nonnull ((1, 2))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_send_error_response@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1212, column 18>": {
            "source_code": "AP_DECLARE(void) ap_send_error_response(request_rec *r, int recursive_error)\n{\n    int status = r->status;\n    int idx = ap_index_of_response(status);\n    char *custom_response;\n    const char *location = apr_table_get(r->headers_out, \"Location\");\n\n    /* At this point, we are starting the response over, so we have to reset\n     * this value.\n     */\n    r->eos_sent = 0;\n\n    /* and we need to get rid of any RESOURCE filters that might be lurking\n     * around, thinking they are in the middle of the original request\n     */\n\n    r->output_filters = r->proto_output_filters;\n\n    ap_run_insert_error_filter(r);\n\n    /* We need to special-case the handling of 204 and 304 responses,\n     * since they have specific HTTP requirements and do not include a\n     * message body.  Note that being assbackwards here is not an option.\n     */\n    if (AP_STATUS_IS_HEADER_ONLY(status)) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    /*\n     * It's possible that the Location field might be in r->err_headers_out\n     * instead of r->headers_out; use the latter if possible, else the\n     * former.\n     */\n    if (location == NULL) {\n        location = apr_table_get(r->err_headers_out, \"Location\");\n    }\n\n    if (!r->assbackwards) {\n\n        /* For all HTTP/1.x responses for which we generate the message,\n         * we need to avoid inheriting the \"normal status\" header fields\n         * that may have been set by the request handler before the\n         * error or redirect, except for Location on external redirects.\n         */\n        apr_table_clear(r->headers_out);\n\n        if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {\n            if ((location != NULL) && *location) {\n                apr_table_setn(r->headers_out, \"Location\", location);\n            }\n            else {\n                location = \"\";   /* avoids coredump when printing, below */\n            }\n        }\n\n        r->content_languages = NULL;\n        r->content_encoding = NULL;\n        r->clength = 0;\n\n        if (apr_table_get(r->subprocess_env,\n                          \"suppress-error-charset\") != NULL) {\n            core_request_config *request_conf =\n                        ap_get_core_module_config(r->request_config);\n            request_conf->suppress_charset = 1; /* avoid adding default\n                                                 * charset later\n                                                 */\n            ap_set_content_type_ex(r, \"text/html\", 1);\n        }\n        else {\n            ap_set_content_type_ex(r, \"text/html; charset=iso-8859-1\", 1);\n        }\n\n        if ((status == HTTP_METHOD_NOT_ALLOWED)\n            || (status == HTTP_NOT_IMPLEMENTED)) {\n            apr_table_setn(r->headers_out, \"Allow\", make_allow(r));\n        }\n\n        if (r->header_only) {\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n\n    if ((custom_response = ap_response_code_string(r, idx))) {\n        /*\n         * We have a custom response output. This should only be\n         * a text-string to write back. But if the ErrorDocument\n         * was a local redirect and the requested resource failed\n         * for any reason, the custom_response will still hold the\n         * redirect URL. We don't really want to output this URL\n         * as a text message, so first check the custom response\n         * string to ensure that it is a text-string (using the\n         * same test used in ap_die(), i.e. does it start with a \").\n         *\n         * If it's not a text string, we've got a recursive error or\n         * an external redirect.  If it's a recursive error, ap_die passes\n         * us the second error code so we can write both, and has already\n         * backed up to the original error.  If it's an external redirect,\n         * it hasn't happened yet; we may never know if it fails.\n         */\n        if (custom_response[0] == '\\\"') {\n            ap_rvputs_proto_in_ascii(r, custom_response + 1, NULL);\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n    {\n        const char *title = status_lines[idx];\n        const char *h1;\n\n        /* Accept a status_line set by a module, but only if it begins\n         * with the correct 3 digit status code\n         */\n        if (r->status_line) {\n            char *end;\n            int len = strlen(r->status_line);\n            if (len >= 3\n                && apr_strtoi64(r->status_line, &end, 10) == r->status\n                && (end - 3) == r->status_line\n                && (len < 4 || apr_isspace(r->status_line[3]))\n                && (len < 5 || apr_isalnum(r->status_line[4]))) {\n                /* Since we passed the above check, we know that length three\n                 * is equivalent to only a 3 digit numeric http status.\n                 * RFC2616 mandates a trailing space, let's add it.\n                 * If we have an empty reason phrase, we also add \"Unknown Reason\".\n                 */\n                if (len == 3) {\n                    r->status_line = apr_pstrcat(r->pool, r->status_line, \" Unknown Reason\", NULL);\n                } else if (len == 4) {\n                    r->status_line = apr_pstrcat(r->pool, r->status_line, \"Unknown Reason\", NULL);\n                }\n                title = r->status_line;\n            }\n        }\n\n        /* folks decided they didn't want the error code in the H1 text */\n        h1 = &title[4];\n\n        /* can't count on a charset filter being in place here,\n         * so do ebcdic->ascii translation explicitly (if needed)\n         */\n\n        ap_rvputs_proto_in_ascii(r,\n                  DOCTYPE_HTML_4_01\n                  \"<html><head>\\n<title>\", title,\n                  \"</title>\\n</head><body>\\n<h1>\", h1, \"</h1>\\n\",\n                  NULL);\n\n        ap_rvputs_proto_in_ascii(r,\n                                 get_canned_error_string(status, r, location),\n                                 NULL);\n\n        if (recursive_error) {\n            ap_rvputs_proto_in_ascii(r, \"<p>Additionally, a \",\n                      status_lines[ap_index_of_response(recursive_error)],\n                      \"\\nerror was encountered while trying to use an \"\n                      \"ErrorDocument to handle the request.</p>\\n\", NULL);\n        }\n        ap_rvputs_proto_in_ascii(r, ap_psignature(\"<hr>\\n\", r), NULL);\n        ap_rvputs_proto_in_ascii(r, \"</body></html>\\n\", NULL);\n    }\n    ap_finalize_request_protocol(r);\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1212, column 18>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "static const char *get_canned_error_string(int status,\n                                           request_rec *r,\n                                           const char *location)\n{\n    apr_pool_t *p = r->pool;\n    const char *error_notes, *h1, *s1;\n\n    switch (status) {\n    case HTTP_MOVED_PERMANENTLY:\n    case HTTP_MOVED_TEMPORARILY:\n    case HTTP_TEMPORARY_REDIRECT:\n    case HTTP_PERMANENT_REDIRECT:\n        return(apr_pstrcat(p,\n                           \"<p>The document has moved <a href=\\\"\",\n                           ap_escape_html(r->pool, location),\n                           \"\\\">here</a>.</p>\\n\",\n                           NULL));\n    case HTTP_SEE_OTHER:\n        return(apr_pstrcat(p,\n                           \"<p>The answer to your request is located \"\n                           \"<a href=\\\"\",\n                           ap_escape_html(r->pool, location),\n                           \"\\\">here</a>.</p>\\n\",\n                           NULL));\n    case HTTP_USE_PROXY:\n        return(\"<p>This resource is only accessible \"\n               \"through the proxy\\n\"\n               \"<br />\\nYou will need to configure \"\n               \"your client to use that proxy.</p>\\n\");\n    case HTTP_PROXY_AUTHENTICATION_REQUIRED:\n    case HTTP_UNAUTHORIZED:\n        return(\"<p>This server could not verify that you\\n\"\n               \"are authorized to access the document\\n\"\n               \"requested.  Either you supplied the wrong\\n\"\n               \"credentials (e.g., bad password), or your\\n\"\n               \"browser doesn't understand how to supply\\n\"\n               \"the credentials required.</p>\\n\");\n    case HTTP_BAD_REQUEST:\n        return(add_optional_notes(r,\n                                  \"<p>Your browser sent a request that \"\n                                  \"this server could not understand.<br />\\n\",\n                                  \"error-notes\",\n                                  \"</p>\\n\"));\n    case HTTP_FORBIDDEN:\n        return(add_optional_notes(r, \"<p>You don't have permission to access this resource.\", \"error-notes\", \"</p>\\n\"));\n    case HTTP_NOT_FOUND:\n        return(\"<p>The requested URL was not found on this server.</p>\\n\");\n    case HTTP_METHOD_NOT_ALLOWED:\n        return(apr_pstrcat(p,\n                           \"<p>The requested method \",\n                           ap_escape_html(r->pool, r->method),\n                           \" is not allowed for this URL.</p>\\n\",\n                           NULL));\n    case HTTP_NOT_ACCEPTABLE:\n        return(add_optional_notes(r, \n            \"<p>An appropriate representation of the requested resource \"\n            \"could not be found on this server.</p>\\n\",\n            \"variant-list\", \"\"));\n    case HTTP_MULTIPLE_CHOICES:\n        return(add_optional_notes(r, \"\", \"variant-list\", \"\"));\n    case HTTP_LENGTH_REQUIRED:\n        s1 = apr_pstrcat(p,\n                         \"<p>A request of the requested method \",\n                         ap_escape_html(r->pool, r->method),\n                         \" requires a valid Content-length.<br />\\n\",\n                         NULL);\n        return(add_optional_notes(r, s1, \"error-notes\", \"</p>\\n\"));\n    case HTTP_PRECONDITION_FAILED:\n        return(\"<p>The precondition on the request \"\n               \"for this URL evaluated to false.</p>\\n\");\n    case HTTP_NOT_IMPLEMENTED:\n        s1 = apr_pstrcat(p,\n                         \"<p>\",\n                         ap_escape_html(r->pool, r->method),\n                         \" not supported for current URL.<br />\\n\",\n                         NULL);\n        return(add_optional_notes(r, s1, \"error-notes\", \"</p>\\n\"));\n    case HTTP_BAD_GATEWAY:\n        s1 = \"<p>The proxy server received an invalid\" CRLF\n            \"response from an upstream server.<br />\" CRLF;\n        return(add_optional_notes(r, s1, \"error-notes\", \"</p>\\n\"));\n    case HTTP_VARIANT_ALSO_VARIES:\n        return(\"<p>A variant for the requested \"\n               \"resource\\n<pre>\\n\"\n               \"\\n</pre>\\nis itself a negotiable resource. \"\n               \"This indicates a configuration error.</p>\\n\");\n    case HTTP_REQUEST_TIME_OUT:\n        return(\"<p>Server timeout waiting for the HTTP request from the client.</p>\\n\");\n    case HTTP_GONE:\n        return(\"<p>The requested resource is no longer available on this server\"\n               \" and there is no forwarding address.\\n\"\n               \"Please remove all references to this resource.</p>\\n\");\n    case HTTP_REQUEST_ENTITY_TOO_LARGE:\n        return(apr_pstrcat(p,\n                           \"The requested resource does not allow request data with \",\n                           ap_escape_html(r->pool, r->method),\n                           \" requests, or the amount of data provided in\\n\"\n                           \"the request exceeds the capacity limit.\\n\",\n                           NULL));\n    case HTTP_REQUEST_URI_TOO_LARGE:\n        s1 = \"<p>The requested URL's length exceeds the capacity\\n\"\n             \"limit for this server.<br />\\n\";\n        return(add_optional_notes(r, s1, \"error-notes\", \"</p>\\n\"));\n    case HTTP_UNSUPPORTED_MEDIA_TYPE:\n        return(\"<p>The supplied request data is not in a format\\n\"\n               \"acceptable for processing by this resource.</p>\\n\");\n    case HTTP_RANGE_NOT_SATISFIABLE:\n        return(\"<p>None of the range-specifier values in the Range\\n\"\n               \"request-header field overlap the current extent\\n\"\n               \"of the selected resource.</p>\\n\");\n    case HTTP_EXPECTATION_FAILED:\n        s1 = apr_table_get(r->headers_in, \"Expect\");\n        if (s1)\n            s1 = apr_pstrcat(p,\n                     \"<p>The expectation given in the Expect request-header\\n\"\n                     \"field could not be met by this server.\\n\"\n                     \"The client sent<pre>\\n    Expect: \",\n                     ap_escape_html(r->pool, s1), \"\\n</pre>\\n\",\n                     NULL);\n        else\n            s1 = \"<p>No expectation was seen, the Expect request-header \\n\"\n                 \"field was not presented by the client.\\n\";\n        return add_optional_notes(r, s1, \"error-notes\", \"</p>\"\n                   \"<p>Only the 100-continue expectation is supported.</p>\\n\");\n    case HTTP_UNPROCESSABLE_ENTITY:\n        return(\"<p>The server understands the media type of the\\n\"\n               \"request entity, but was unable to process the\\n\"\n               \"contained instructions.</p>\\n\");\n    case HTTP_LOCKED:\n        return(\"<p>The requested resource is currently locked.\\n\"\n               \"The lock must be released or proper identification\\n\"\n               \"given before the method can be applied.</p>\\n\");\n    case HTTP_FAILED_DEPENDENCY:\n        return(\"<p>The method could not be performed on the resource\\n\"\n               \"because the requested action depended on another\\n\"\n               \"action and that other action failed.</p>\\n\");\n    case HTTP_TOO_EARLY:\n        return(\"<p>The request could not be processed as TLS\\n\"\n               \"early data and should be retried.</p>\\n\");\n    case HTTP_UPGRADE_REQUIRED:\n        return(\"<p>The requested resource can only be retrieved\\n\"\n               \"using SSL.  The server is willing to upgrade the current\\n\"\n               \"connection to SSL, but your client doesn't support it.\\n\"\n               \"Either upgrade your client, or try requesting the page\\n\"\n               \"using https://\\n\");\n    case HTTP_PRECONDITION_REQUIRED:\n        return(\"<p>The request is required to be conditional.</p>\\n\");\n    case HTTP_TOO_MANY_REQUESTS:\n        return(\"<p>The user has sent too many requests\\n\"\n               \"in a given amount of time.</p>\\n\");\n    case HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE:\n        return(\"<p>The server refused this request because\\n\"\n               \"the request header fields are too large.</p>\\n\");\n    case HTTP_INSUFFICIENT_STORAGE:\n        return(\"<p>The method could not be performed on the resource\\n\"\n               \"because the server is unable to store the\\n\"\n               \"representation needed to successfully complete the\\n\"\n               \"request.  There is insufficient free space left in\\n\"\n               \"your storage allocation.</p>\\n\");\n    case HTTP_SERVICE_UNAVAILABLE:\n        return(\"<p>The server is temporarily unable to service your\\n\"\n               \"request due to maintenance downtime or capacity\\n\"\n               \"problems. Please try again later.</p>\\n\");\n    case HTTP_GATEWAY_TIME_OUT:\n        return(\"<p>The gateway did not receive a timely response\\n\"\n               \"from the upstream server or application.</p>\\n\");\n    case HTTP_LOOP_DETECTED:\n        return(\"<p>The server terminated an operation because\\n\"\n               \"it encountered an infinite loop.</p>\\n\");\n    case HTTP_NOT_EXTENDED:\n        return(\"<p>A mandatory extension policy in the request is not\\n\"\n               \"accepted by the server for this resource.</p>\\n\");\n    case HTTP_NETWORK_AUTHENTICATION_REQUIRED:\n        return(\"<p>The client needs to authenticate to gain\\n\"\n               \"network access.</p>\\n\");\n    case HTTP_IM_A_TEAPOT:\n        return(\"<p>The resulting entity body MAY be short and\\n\"\n                \"stout.</p>\\n\");\n    case HTTP_MISDIRECTED_REQUEST:\n        return(\"<p>The client needs a new connection for this\\n\"\n               \"request as the requested host name does not match\\n\"\n               \"the Server Name Indication (SNI) in use for this\\n\"\n               \"connection.</p>\\n\");\n    case HTTP_UNAVAILABLE_FOR_LEGAL_REASONS:\n        return(add_optional_notes(r, \n               \"<p>Access to this URL has been denied for legal reasons.<br />\\n\",\n               \"error-notes\", \"</p>\\n\"));\n    default:                    /* HTTP_INTERNAL_SERVER_ERROR */\n        /*\n         * This comparison to expose error-notes could be modified to\n         * use a configuration directive and export based on that\n         * directive.  For now \"*\" is used to designate an error-notes\n         * that is totally safe for any user to see (ie lacks paths,\n         * database passwords, etc.)\n         */\n        if (((error_notes = apr_table_get(r->notes,\n                                          \"error-notes\")) != NULL)\n            && (h1 = apr_table_get(r->notes, \"verbose-error-to\")) != NULL\n            && (strcmp(h1, \"*\") == 0)) {\n            return(apr_pstrcat(p, error_notes, \"<p />\\n\", NULL));\n        }\n        else {\n            return(apr_pstrcat(p,\n                               \"<p>The server encountered an internal \"\n                               \"error or\\n\"\n                               \"misconfiguration and was unable to complete\\n\"\n                               \"your request.</p>\\n\"\n                               \"<p>Please contact the server \"\n                               \"administrator at \\n \",\n                               ap_escape_html(r->pool,\n                                              r->server->server_admin),\n                               \" to inform them of the time this \"\n                               \"error occurred,\\n\"\n                               \" and the actions you performed just before \"\n                               \"this error.</p>\\n\"\n                               \"<p>More information about this error \"\n                               \"may be available\\n\"\n                               \"in the server error log.</p>\\n\",\n                               NULL));\n        }\n        /*\n         * It would be nice to give the user the information they need to\n         * fix the problem directly since many users don't have access to\n         * the error_log (think University sites) even though they can easily\n         * get this error by misconfiguring an htaccess file.  However, the\n         * e error notes tend to include the real file pathname in this case,\n         * which some people consider to be a breach of privacy.  Until we\n         * can figure out a way to remove the pathname, leave this commented.\n         *\n         * if ((error_notes = apr_table_get(r->notes,\n         *                                  \"error-notes\")) != NULL) {\n         *     return(apr_pstrcat(p, error_notes, \"<p />\\n\", NULL);\n         * }\n         * else {\n         *     return \"\";\n         * }\n         */\n    }\n}"
    },
    "ap_send_error_response@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1212, column 18>": {
      "basic_info": {
        "function_id": 1662,
        "name": "ap_send_error_response",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1212, column 18>",
        "is_definition": true,
        "start_line": 1212,
        "end_line": 1375,
        "return_type": "void",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "recursive_error",
            "type": "int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_index_of_response": {
            "declaration": "AP_DECLARE(int) ap_index_of_response(int status)\n{\n    int index = index_of_response(status);\n    return (index < 0) ? LEVEL_500 : index;\n}",
            "is_external": false,
            "definition": "AP_DECLARE(int) ap_index_of_response(int status)\n{\n    int index = index_of_response(status);\n    return (index < 0) ? LEVEL_500 : index;\n}"
          },
          "apr_table_get": {
            "declaration": "APR_DECLARE(const char *) apr_table_get(const apr_table_t *t, const char *key)",
            "is_external": true,
            "definition": null
          },
          "ap_run_insert_error_filter": {
            "declaration": "AP_IMPLEMENT_HOOK_VOID(insert_error_filter, (request_rec *r), (r))",
            "is_external": false,
            "definition": "AP_IMPLEMENT_HOOK_VOID(insert_error_filter, (request_rec *r), (r))"
          },
          "ap_finalize_request_protocol": {
            "declaration": "AP_DECLARE(void) ap_finalize_request_protocol(request_rec *r)",
            "is_external": true,
            "definition": null
          },
          "apr_table_clear": {
            "declaration": "APR_DECLARE(void) apr_table_clear(apr_table_t *t)",
            "is_external": true,
            "definition": null
          },
          "apr_table_setn": {
            "declaration": "APR_DECLARE(void) apr_table_setn(apr_table_t *t, const char *key,\n                                 const char *val)",
            "is_external": true,
            "definition": null
          },
          "ap_set_content_type_ex": {
            "declaration": "AP_DECLARE(void) ap_set_content_type_ex(request_rec *r, const char *ct, int trusted)\n{\n    ap_set_content_type(r, ct);\n    AP_REQUEST_SET_BNOTE(r, AP_REQUEST_TRUSTED_CT, trusted ? AP_REQUEST_TRUSTED_CT : 0);\n}",
            "is_external": false,
            "definition": "AP_DECLARE(void) ap_set_content_type_ex(request_rec *r, const char *ct, int trusted)\n{\n    ap_set_content_type(r, ct);\n    AP_REQUEST_SET_BNOTE(r, AP_REQUEST_TRUSTED_CT, trusted ? AP_REQUEST_TRUSTED_CT : 0);\n}"
          },
          "make_allow": {
            "declaration": "static char *make_allow(request_rec *r)\n{\n    ap_method_mask_t mask;\n    apr_array_header_t *allow = apr_array_make(r->pool, 10, sizeof(char *));\n    apr_hash_index_t *hi = apr_hash_first(r->pool, methods_registry);\n    /* For TRACE below */\n    core_server_config *conf =\n        ap_get_core_module_config(r->server->module_config);\n\n    mask = r->allowed_methods->method_mask;\n\n    for (; hi; hi = apr_hash_next(hi)) {\n        const void *key;\n        void *val;\n\n        apr_hash_this(hi, &key, NULL, &val);\n        if ((mask & (AP_METHOD_BIT << *(int *)val)) != 0) {\n            APR_ARRAY_PUSH(allow, const char *) = key;\n        }\n    }\n\n    /* TRACE is tested on a per-server basis */\n    if (conf->trace_enable != AP_TRACE_DISABLE)\n        *(const char **)apr_array_push(allow) = \"TRACE\";\n\n    /* ### this is rather annoying. we should enforce registration of\n       ### these methods */\n    if ((mask & (AP_METHOD_BIT << M_INVALID))\n        && (r->allowed_methods->method_list != NULL)\n        && (r->allowed_methods->method_list->nelts != 0)) {\n        apr_array_cat(allow, r->allowed_methods->method_list);\n    }\n\n    return apr_array_pstrcat(r->pool, allow, ',');\n}",
            "is_external": false,
            "definition": "static char *make_allow(request_rec *r)\n{\n    ap_method_mask_t mask;\n    apr_array_header_t *allow = apr_array_make(r->pool, 10, sizeof(char *));\n    apr_hash_index_t *hi = apr_hash_first(r->pool, methods_registry);\n    /* For TRACE below */\n    core_server_config *conf =\n        ap_get_core_module_config(r->server->module_config);\n\n    mask = r->allowed_methods->method_mask;\n\n    for (; hi; hi = apr_hash_next(hi)) {\n        const void *key;\n        void *val;\n\n        apr_hash_this(hi, &key, NULL, &val);\n        if ((mask & (AP_METHOD_BIT << *(int *)val)) != 0) {\n            APR_ARRAY_PUSH(allow, const char *) = key;\n        }\n    }\n\n    /* TRACE is tested on a per-server basis */\n    if (conf->trace_enable != AP_TRACE_DISABLE)\n        *(const char **)apr_array_push(allow) = \"TRACE\";\n\n    /* ### this is rather annoying. we should enforce registration of\n       ### these methods */\n    if ((mask & (AP_METHOD_BIT << M_INVALID))\n        && (r->allowed_methods->method_list != NULL)\n        && (r->allowed_methods->method_list->nelts != 0)) {\n        apr_array_cat(allow, r->allowed_methods->method_list);\n    }\n\n    return apr_array_pstrcat(r->pool, allow, ',');\n}"
          },
          "ap_response_code_string": {
            "declaration": "char *ap_response_code_string(request_rec *r, int error_index)",
            "is_external": true,
            "definition": null
          },
          "ap_rvputs": {
            "declaration": "AP_DECLARE_NONSTD(int) ap_rvputs(request_rec *r,...)\n                       AP_FN_ATTR_SENTINEL",
            "is_external": true,
            "definition": null
          },
          "strlen": {
            "declaration": "extern size_t strlen (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_strtoi64": {
            "declaration": "APR_DECLARE(apr_int64_t) apr_strtoi64(const char *buf, char **end, int base)",
            "is_external": true,
            "definition": null
          },
          "__ctype_b_loc": {
            "declaration": "extern const unsigned short int **__ctype_b_loc (void)\n     __THROW __attribute__ ((__const__))",
            "is_external": true,
            "definition": null
          },
          "apr_pstrcat": {
            "declaration": "APR_DECLARE_NONSTD(char *) apr_pstrcat(apr_pool_t *p, ...)\n#if defined(__GNUC__) && __GNUC__ >= 4\n    __attribute__((sentinel))",
            "is_external": true,
            "definition": null
          },
          "get_canned_error_string": {
            "declaration": "static const char *get_canned_error_string(int status,\n                                           request_rec *r,\n                                           const char *location)\n{\n    apr_pool_t *p = r->pool;\n    const char *error_notes, *h1, *s1;\n\n    switch (status) {\n    case HTTP_MOVED_PERMANENTLY:\n    case HTTP_MOVED_TEMPORARILY:\n    case HTTP_TEMPORARY_REDIRECT:\n    case HTTP_PERMANENT_REDIRECT:\n        return(apr_pstrcat(p,\n                           \"<p>The document has moved <a href=\\\"\",\n                           ap_escape_html(r->pool, location),\n                           \"\\\">here</a>.</p>\\n\",\n                           NULL));\n    case HTTP_SEE_OTHER:\n        return(apr_pstrcat(p,\n                           \"<p>The answer to your request is located \"\n                           \"<a href=\\\"\",\n                           ap_escape_html(r->pool, location),\n                           \"\\\">here</a>.</p>\\n\",\n                           NULL));\n    case HTTP_USE_PROXY:\n        return(\"<p>This resource is only accessible \"\n               \"through the proxy\\n\"\n               \"<br />\\nYou will need to configure \"\n               \"your client to use that proxy.</p>\\n\");\n    case HTTP_PROXY_AUTHENTICATION_REQUIRED:\n    case HTTP_UNAUTHORIZED:\n        return(\"<p>This server could not verify that you\\n\"\n               \"are authorized to access the document\\n\"\n               \"requested.  Either you supplied the wrong\\n\"\n               \"credentials (e.g., bad password), or your\\n\"\n               \"browser doesn't understand how to supply\\n\"\n               \"the credentials required.</p>\\n\");\n    case HTTP_BAD_REQUEST:\n        return(add_optional_notes(r,\n                                  \"<p>Your browser sent a request that \"\n                                  \"this server could not understand.<br />\\n\",\n                                  \"error-notes\",\n                                  \"</p>\\n\"));\n    case HTTP_FORBIDDEN:\n        return(add_optional_notes(r, \"<p>You don't have permission to access this resource.\", \"error-notes\", \"</p>\\n\"));\n    case HTTP_NOT_FOUND:\n        return(\"<p>The requested URL was not found on this server.</p>\\n\");\n    case HTTP_METHOD_NOT_ALLOWED:\n        return(apr_pstrcat(p,\n                           \"<p>The requested method \",\n                           ap_escape_html(r->pool, r->method),\n                           \" is not allowed for this URL.</p>\\n\",\n                           NULL));\n    case HTTP_NOT_ACCEPTABLE:\n        return(add_optional_notes(r, \n            \"<p>An appropriate representation of the requested resource \"\n            \"could not be found on this server.</p>\\n\",\n            \"variant-list\", \"\"));\n    case HTTP_MULTIPLE_CHOICES:\n        return(add_optional_notes(r, \"\", \"variant-list\", \"\"));\n    case HTTP_LENGTH_REQUIRED:\n        s1 = apr_pstrcat(p,\n                         \"<p>A request of the requested method \",\n                         ap_escape_html(r->pool, r->method),\n                         \" requires a valid Content-length.<br />\\n\",\n                         NULL);\n        return(add_optional_notes(r, s1, \"error-notes\", \"</p>\\n\"));\n    case HTTP_PRECONDITION_FAILED:\n        return(\"<p>The precondition on the request \"\n               \"for this URL evaluated to false.</p>\\n\");\n    case HTTP_NOT_IMPLEMENTED:\n        s1 = apr_pstrcat(p,\n                         \"<p>\",\n                         ap_escape_html(r->pool, r->method),\n                         \" not supported for current URL.<br />\\n\",\n                         NULL);\n        return(add_optional_notes(r, s1, \"error-notes\", \"</p>\\n\"));\n    case HTTP_BAD_GATEWAY:\n        s1 = \"<p>The proxy server received an invalid\" CRLF\n            \"response from an upstream server.<br />\" CRLF;\n        return(add_optional_notes(r, s1, \"error-notes\", \"</p>\\n\"));\n    case HTTP_VARIANT_ALSO_VARIES:\n        return(\"<p>A variant for the requested \"\n               \"resource\\n<pre>\\n\"\n               \"\\n</pre>\\nis itself a negotiable resource. \"\n               \"This indicates a configuration error.</p>\\n\");\n    case HTTP_REQUEST_TIME_OUT:\n        return(\"<p>Server timeout waiting for the HTTP request from the client.</p>\\n\");\n    case HTTP_GONE:\n        return(\"<p>The requested resource is no longer available on this server\"\n               \" and there is no forwarding address.\\n\"\n               \"Please remove all references to this resource.</p>\\n\");\n    case HTTP_REQUEST_ENTITY_TOO_LARGE:\n        return(apr_pstrcat(p,\n                           \"The requested resource does not allow request data with \",\n                           ap_escape_html(r->pool, r->method),\n                           \" requests, or the amount of data provided in\\n\"\n                           \"the request exceeds the capacity limit.\\n\",\n                           NULL));\n    case HTTP_REQUEST_URI_TOO_LARGE:\n        s1 = \"<p>The requested URL's length exceeds the capacity\\n\"\n             \"limit for this server.<br />\\n\";\n        return(add_optional_notes(r, s1, \"error-notes\", \"</p>\\n\"));\n    case HTTP_UNSUPPORTED_MEDIA_TYPE:\n        return(\"<p>The supplied request data is not in a format\\n\"\n               \"acceptable for processing by this resource.</p>\\n\");\n    case HTTP_RANGE_NOT_SATISFIABLE:\n        return(\"<p>None of the range-specifier values in the Range\\n\"\n               \"request-header field overlap the current extent\\n\"\n               \"of the selected resource.</p>\\n\");\n    case HTTP_EXPECTATION_FAILED:\n        s1 = apr_table_get(r->headers_in, \"Expect\");\n        if (s1)\n            s1 = apr_pstrcat(p,\n                     \"<p>The expectation given in the Expect request-header\\n\"\n                     \"field could not be met by this server.\\n\"\n                     \"The client sent<pre>\\n    Expect: \",\n                     ap_escape_html(r->pool, s1), \"\\n</pre>\\n\",\n                     NULL);\n        else\n            s1 = \"<p>No expectation was seen, the Expect request-header \\n\"\n                 \"field was not presented by the client.\\n\";\n        return add_optional_notes(r, s1, \"error-notes\", \"</p>\"\n                   \"<p>Only the 100-continue expectation is supported.</p>\\n\");\n    case HTTP_UNPROCESSABLE_ENTITY:\n        return(\"<p>The server understands the media type of the\\n\"\n               \"request entity, but was unable to process the\\n\"\n               \"contained instructions.</p>\\n\");\n    case HTTP_LOCKED:\n        return(\"<p>The requested resource is currently locked.\\n\"\n               \"The lock must be released or proper identification\\n\"\n               \"given before the method can be applied.</p>\\n\");\n    case HTTP_FAILED_DEPENDENCY:\n        return(\"<p>The method could not be performed on the resource\\n\"\n               \"because the requested action depended on another\\n\"\n               \"action and that other action failed.</p>\\n\");\n    case HTTP_TOO_EARLY:\n        return(\"<p>The request could not be processed as TLS\\n\"\n               \"early data and should be retried.</p>\\n\");\n    case HTTP_UPGRADE_REQUIRED:\n        return(\"<p>The requested resource can only be retrieved\\n\"\n               \"using SSL.  The server is willing to upgrade the current\\n\"\n               \"connection to SSL, but your client doesn't support it.\\n\"\n               \"Either upgrade your client, or try requesting the page\\n\"\n               \"using https://\\n\");\n    case HTTP_PRECONDITION_REQUIRED:\n        return(\"<p>The request is required to be conditional.</p>\\n\");\n    case HTTP_TOO_MANY_REQUESTS:\n        return(\"<p>The user has sent too many requests\\n\"\n               \"in a given amount of time.</p>\\n\");\n    case HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE:\n        return(\"<p>The server refused this request because\\n\"\n               \"the request header fields are too large.</p>\\n\");\n    case HTTP_INSUFFICIENT_STORAGE:\n        return(\"<p>The method could not be performed on the resource\\n\"\n               \"because the server is unable to store the\\n\"\n               \"representation needed to successfully complete the\\n\"\n               \"request.  There is insufficient free space left in\\n\"\n               \"your storage allocation.</p>\\n\");\n    case HTTP_SERVICE_UNAVAILABLE:\n        return(\"<p>The server is temporarily unable to service your\\n\"\n               \"request due to maintenance downtime or capacity\\n\"\n               \"problems. Please try again later.</p>\\n\");\n    case HTTP_GATEWAY_TIME_OUT:\n        return(\"<p>The gateway did not receive a timely response\\n\"\n               \"from the upstream server or application.</p>\\n\");\n    case HTTP_LOOP_DETECTED:\n        return(\"<p>The server terminated an operation because\\n\"\n               \"it encountered an infinite loop.</p>\\n\");\n    case HTTP_NOT_EXTENDED:\n        return(\"<p>A mandatory extension policy in the request is not\\n\"\n               \"accepted by the server for this resource.</p>\\n\");\n    case HTTP_NETWORK_AUTHENTICATION_REQUIRED:\n        return(\"<p>The client needs to authenticate to gain\\n\"\n               \"network access.</p>\\n\");\n    case HTTP_IM_A_TEAPOT:\n        return(\"<p>The resulting entity body MAY be short and\\n\"\n                \"stout.</p>\\n\");\n    case HTTP_MISDIRECTED_REQUEST:\n        return(\"<p>The client needs a new connection for this\\n\"\n               \"request as the requested host name does not match\\n\"\n               \"the Server Name Indication (SNI) in use for this\\n\"\n               \"connection.</p>\\n\");\n    case HTTP_UNAVAILABLE_FOR_LEGAL_REASONS:\n        return(add_optional_notes(r, \n               \"<p>Access to this URL has been denied for legal reasons.<br />\\n\",\n               \"error-notes\", \"</p>\\n\"));\n    default:                    /* HTTP_INTERNAL_SERVER_ERROR */\n        /*\n         * This comparison to expose error-notes could be modified to\n         * use a configuration directive and export based on that\n         * directive.  For now \"*\" is used to designate an error-notes\n         * that is totally safe for any user to see (ie lacks paths,\n         * database passwords, etc.)\n         */\n        if (((error_notes = apr_table_get(r->notes,\n                                          \"error-notes\")) != NULL)\n            && (h1 = apr_table_get(r->notes, \"verbose-error-to\")) != NULL\n            && (strcmp(h1, \"*\") == 0)) {\n            return(apr_pstrcat(p, error_notes, \"<p />\\n\", NULL));\n        }\n        else {\n            return(apr_pstrcat(p,\n                               \"<p>The server encountered an internal \"\n                               \"error or\\n\"\n                               \"misconfiguration and was unable to complete\\n\"\n                               \"your request.</p>\\n\"\n                               \"<p>Please contact the server \"\n                               \"administrator at \\n \",\n                               ap_escape_html(r->pool,\n                                              r->server->server_admin),\n                               \" to inform them of the time this \"\n                               \"error occurred,\\n\"\n                               \" and the actions you performed just before \"\n                               \"this error.</p>\\n\"\n                               \"<p>More information about this error \"\n                               \"may be available\\n\"\n                               \"in the server error log.</p>\\n\",\n                               NULL));\n        }\n        /*\n         * It would be nice to give the user the information they need to\n         * fix the problem directly since many users don't have access to\n         * the error_log (think University sites) even though they can easily\n         * get this error by misconfiguring an htaccess file.  However, the\n         * e error notes tend to include the real file pathname in this case,\n         * which some people consider to be a breach of privacy.  Until we\n         * can figure out a way to remove the pathname, leave this commented.\n         *\n         * if ((error_notes = apr_table_get(r->notes,\n         *                                  \"error-notes\")) != NULL) {\n         *     return(apr_pstrcat(p, error_notes, \"<p />\\n\", NULL);\n         * }\n         * else {\n         *     return \"\";\n         * }\n         */\n    }\n}",
            "is_external": false,
            "definition": "static const char *get_canned_error_string(int status,\n                                           request_rec *r,\n                                           const char *location)\n{\n    apr_pool_t *p = r->pool;\n    const char *error_notes, *h1, *s1;\n\n    switch (status) {\n    case HTTP_MOVED_PERMANENTLY:\n    case HTTP_MOVED_TEMPORARILY:\n    case HTTP_TEMPORARY_REDIRECT:\n    case HTTP_PERMANENT_REDIRECT:\n        return(apr_pstrcat(p,\n                           \"<p>The document has moved <a href=\\\"\",\n                           ap_escape_html(r->pool, location),\n                           \"\\\">here</a>.</p>\\n\",\n                           NULL));\n    case HTTP_SEE_OTHER:\n        return(apr_pstrcat(p,\n                           \"<p>The answer to your request is located \"\n                           \"<a href=\\\"\",\n                           ap_escape_html(r->pool, location),\n                           \"\\\">here</a>.</p>\\n\",\n                           NULL));\n    case HTTP_USE_PROXY:\n        return(\"<p>This resource is only accessible \"\n               \"through the proxy\\n\"\n               \"<br />\\nYou will need to configure \"\n               \"your client to use that proxy.</p>\\n\");\n    case HTTP_PROXY_AUTHENTICATION_REQUIRED:\n    case HTTP_UNAUTHORIZED:\n        return(\"<p>This server could not verify that you\\n\"\n               \"are authorized to access the document\\n\"\n               \"requested.  Either you supplied the wrong\\n\"\n               \"credentials (e.g., bad password), or your\\n\"\n               \"browser doesn't understand how to supply\\n\"\n               \"the credentials required.</p>\\n\");\n    case HTTP_BAD_REQUEST:\n        return(add_optional_notes(r,\n                                  \"<p>Your browser sent a request that \"\n                                  \"this server could not understand.<br />\\n\",\n                                  \"error-notes\",\n                                  \"</p>\\n\"));\n    case HTTP_FORBIDDEN:\n        return(add_optional_notes(r, \"<p>You don't have permission to access this resource.\", \"error-notes\", \"</p>\\n\"));\n    case HTTP_NOT_FOUND:\n        return(\"<p>The requested URL was not found on this server.</p>\\n\");\n    case HTTP_METHOD_NOT_ALLOWED:\n        return(apr_pstrcat(p,\n                           \"<p>The requested method \",\n                           ap_escape_html(r->pool, r->method),\n                           \" is not allowed for this URL.</p>\\n\",\n                           NULL));\n    case HTTP_NOT_ACCEPTABLE:\n        return(add_optional_notes(r, \n            \"<p>An appropriate representation of the requested resource \"\n            \"could not be found on this server.</p>\\n\",\n            \"variant-list\", \"\"));\n    case HTTP_MULTIPLE_CHOICES:\n        return(add_optional_notes(r, \"\", \"variant-list\", \"\"));\n    case HTTP_LENGTH_REQUIRED:\n        s1 = apr_pstrcat(p,\n                         \"<p>A request of the requested method \",\n                         ap_escape_html(r->pool, r->method),\n                         \" requires a valid Content-length.<br />\\n\",\n                         NULL);\n        return(add_optional_notes(r, s1, \"error-notes\", \"</p>\\n\"));\n    case HTTP_PRECONDITION_FAILED:\n        return(\"<p>The precondition on the request \"\n               \"for this URL evaluated to false.</p>\\n\");\n    case HTTP_NOT_IMPLEMENTED:\n        s1 = apr_pstrcat(p,\n                         \"<p>\",\n                         ap_escape_html(r->pool, r->method),\n                         \" not supported for current URL.<br />\\n\",\n                         NULL);\n        return(add_optional_notes(r, s1, \"error-notes\", \"</p>\\n\"));\n    case HTTP_BAD_GATEWAY:\n        s1 = \"<p>The proxy server received an invalid\" CRLF\n            \"response from an upstream server.<br />\" CRLF;\n        return(add_optional_notes(r, s1, \"error-notes\", \"</p>\\n\"));\n    case HTTP_VARIANT_ALSO_VARIES:\n        return(\"<p>A variant for the requested \"\n               \"resource\\n<pre>\\n\"\n               \"\\n</pre>\\nis itself a negotiable resource. \"\n               \"This indicates a configuration error.</p>\\n\");\n    case HTTP_REQUEST_TIME_OUT:\n        return(\"<p>Server timeout waiting for the HTTP request from the client.</p>\\n\");\n    case HTTP_GONE:\n        return(\"<p>The requested resource is no longer available on this server\"\n               \" and there is no forwarding address.\\n\"\n               \"Please remove all references to this resource.</p>\\n\");\n    case HTTP_REQUEST_ENTITY_TOO_LARGE:\n        return(apr_pstrcat(p,\n                           \"The requested resource does not allow request data with \",\n                           ap_escape_html(r->pool, r->method),\n                           \" requests, or the amount of data provided in\\n\"\n                           \"the request exceeds the capacity limit.\\n\",\n                           NULL));\n    case HTTP_REQUEST_URI_TOO_LARGE:\n        s1 = \"<p>The requested URL's length exceeds the capacity\\n\"\n             \"limit for this server.<br />\\n\";\n        return(add_optional_notes(r, s1, \"error-notes\", \"</p>\\n\"));\n    case HTTP_UNSUPPORTED_MEDIA_TYPE:\n        return(\"<p>The supplied request data is not in a format\\n\"\n               \"acceptable for processing by this resource.</p>\\n\");\n    case HTTP_RANGE_NOT_SATISFIABLE:\n        return(\"<p>None of the range-specifier values in the Range\\n\"\n               \"request-header field overlap the current extent\\n\"\n               \"of the selected resource.</p>\\n\");\n    case HTTP_EXPECTATION_FAILED:\n        s1 = apr_table_get(r->headers_in, \"Expect\");\n        if (s1)\n            s1 = apr_pstrcat(p,\n                     \"<p>The expectation given in the Expect request-header\\n\"\n                     \"field could not be met by this server.\\n\"\n                     \"The client sent<pre>\\n    Expect: \",\n                     ap_escape_html(r->pool, s1), \"\\n</pre>\\n\",\n                     NULL);\n        else\n            s1 = \"<p>No expectation was seen, the Expect request-header \\n\"\n                 \"field was not presented by the client.\\n\";\n        return add_optional_notes(r, s1, \"error-notes\", \"</p>\"\n                   \"<p>Only the 100-continue expectation is supported.</p>\\n\");\n    case HTTP_UNPROCESSABLE_ENTITY:\n        return(\"<p>The server understands the media type of the\\n\"\n               \"request entity, but was unable to process the\\n\"\n               \"contained instructions.</p>\\n\");\n    case HTTP_LOCKED:\n        return(\"<p>The requested resource is currently locked.\\n\"\n               \"The lock must be released or proper identification\\n\"\n               \"given before the method can be applied.</p>\\n\");\n    case HTTP_FAILED_DEPENDENCY:\n        return(\"<p>The method could not be performed on the resource\\n\"\n               \"because the requested action depended on another\\n\"\n               \"action and that other action failed.</p>\\n\");\n    case HTTP_TOO_EARLY:\n        return(\"<p>The request could not be processed as TLS\\n\"\n               \"early data and should be retried.</p>\\n\");\n    case HTTP_UPGRADE_REQUIRED:\n        return(\"<p>The requested resource can only be retrieved\\n\"\n               \"using SSL.  The server is willing to upgrade the current\\n\"\n               \"connection to SSL, but your client doesn't support it.\\n\"\n               \"Either upgrade your client, or try requesting the page\\n\"\n               \"using https://\\n\");\n    case HTTP_PRECONDITION_REQUIRED:\n        return(\"<p>The request is required to be conditional.</p>\\n\");\n    case HTTP_TOO_MANY_REQUESTS:\n        return(\"<p>The user has sent too many requests\\n\"\n               \"in a given amount of time.</p>\\n\");\n    case HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE:\n        return(\"<p>The server refused this request because\\n\"\n               \"the request header fields are too large.</p>\\n\");\n    case HTTP_INSUFFICIENT_STORAGE:\n        return(\"<p>The method could not be performed on the resource\\n\"\n               \"because the server is unable to store the\\n\"\n               \"representation needed to successfully complete the\\n\"\n               \"request.  There is insufficient free space left in\\n\"\n               \"your storage allocation.</p>\\n\");\n    case HTTP_SERVICE_UNAVAILABLE:\n        return(\"<p>The server is temporarily unable to service your\\n\"\n               \"request due to maintenance downtime or capacity\\n\"\n               \"problems. Please try again later.</p>\\n\");\n    case HTTP_GATEWAY_TIME_OUT:\n        return(\"<p>The gateway did not receive a timely response\\n\"\n               \"from the upstream server or application.</p>\\n\");\n    case HTTP_LOOP_DETECTED:\n        return(\"<p>The server terminated an operation because\\n\"\n               \"it encountered an infinite loop.</p>\\n\");\n    case HTTP_NOT_EXTENDED:\n        return(\"<p>A mandatory extension policy in the request is not\\n\"\n               \"accepted by the server for this resource.</p>\\n\");\n    case HTTP_NETWORK_AUTHENTICATION_REQUIRED:\n        return(\"<p>The client needs to authenticate to gain\\n\"\n               \"network access.</p>\\n\");\n    case HTTP_IM_A_TEAPOT:\n        return(\"<p>The resulting entity body MAY be short and\\n\"\n                \"stout.</p>\\n\");\n    case HTTP_MISDIRECTED_REQUEST:\n        return(\"<p>The client needs a new connection for this\\n\"\n               \"request as the requested host name does not match\\n\"\n               \"the Server Name Indication (SNI) in use for this\\n\"\n               \"connection.</p>\\n\");\n    case HTTP_UNAVAILABLE_FOR_LEGAL_REASONS:\n        return(add_optional_notes(r, \n               \"<p>Access to this URL has been denied for legal reasons.<br />\\n\",\n               \"error-notes\", \"</p>\\n\"));\n    default:                    /* HTTP_INTERNAL_SERVER_ERROR */\n        /*\n         * This comparison to expose error-notes could be modified to\n         * use a configuration directive and export based on that\n         * directive.  For now \"*\" is used to designate an error-notes\n         * that is totally safe for any user to see (ie lacks paths,\n         * database passwords, etc.)\n         */\n        if (((error_notes = apr_table_get(r->notes,\n                                          \"error-notes\")) != NULL)\n            && (h1 = apr_table_get(r->notes, \"verbose-error-to\")) != NULL\n            && (strcmp(h1, \"*\") == 0)) {\n            return(apr_pstrcat(p, error_notes, \"<p />\\n\", NULL));\n        }\n        else {\n            return(apr_pstrcat(p,\n                               \"<p>The server encountered an internal \"\n                               \"error or\\n\"\n                               \"misconfiguration and was unable to complete\\n\"\n                               \"your request.</p>\\n\"\n                               \"<p>Please contact the server \"\n                               \"administrator at \\n \",\n                               ap_escape_html(r->pool,\n                                              r->server->server_admin),\n                               \" to inform them of the time this \"\n                               \"error occurred,\\n\"\n                               \" and the actions you performed just before \"\n                               \"this error.</p>\\n\"\n                               \"<p>More information about this error \"\n                               \"may be available\\n\"\n                               \"in the server error log.</p>\\n\",\n                               NULL));\n        }\n        /*\n         * It would be nice to give the user the information they need to\n         * fix the problem directly since many users don't have access to\n         * the error_log (think University sites) even though they can easily\n         * get this error by misconfiguring an htaccess file.  However, the\n         * e error notes tend to include the real file pathname in this case,\n         * which some people consider to be a breach of privacy.  Until we\n         * can figure out a way to remove the pathname, leave this commented.\n         *\n         * if ((error_notes = apr_table_get(r->notes,\n         *                                  \"error-notes\")) != NULL) {\n         *     return(apr_pstrcat(p, error_notes, \"<p />\\n\", NULL);\n         * }\n         * else {\n         *     return \"\";\n         * }\n         */\n    }\n}"
          },
          "ap_psignature": {
            "declaration": "AP_DECLARE(const char *) ap_psignature(const char *prefix, request_rec *r)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {
          "_ISalnum": {
            "name": "_ISalnum",
            "value": "8",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISalnum = 8",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 59, column 3>",
            "condition": ""
          },
          "_ISalpha": {
            "name": "_ISalpha",
            "value": "1024",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISalpha = 1024",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 50, column 3>",
            "condition": ""
          },
          "_IScntrl": {
            "name": "_IScntrl",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _IScntrl = 2",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 57, column 3>",
            "condition": ""
          },
          "_ISdigit": {
            "name": "_ISdigit",
            "value": "2048",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISdigit = 2048",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 51, column 3>",
            "condition": ""
          },
          "_ISlower": {
            "name": "_ISlower",
            "value": "512",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISlower = 512",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 49, column 3>",
            "condition": ""
          },
          "_ISgraph": {
            "name": "_ISgraph",
            "value": "32768",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISgraph = 32768",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 55, column 3>",
            "condition": ""
          },
          "_ISprint": {
            "name": "_ISprint",
            "value": "16384",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISprint = 16384",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 54, column 3>",
            "condition": ""
          },
          "_ISpunct": {
            "name": "_ISpunct",
            "value": "4",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISpunct = 4",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 58, column 3>",
            "condition": ""
          },
          "_ISspace": {
            "name": "_ISspace",
            "value": "8192",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISspace = 8192",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 53, column 3>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "core_request_config": {
            "name": "core_request_config",
            "definition": "struct {\n    /** bucket brigade used by getline for look-ahead and\n     * ap_get_client_block for holding left-over request body */\n    struct apr_bucket_brigade *bb;\n\n    /** an array of per-request working data elements, accessed\n     * by ID using ap_get_request_note()\n     * (Use ap_register_request_note() during initialization\n     * to add elements)\n     */\n    void **notes;\n\n    /** Custom response strings registered via ap_custom_response(),\n     * or NULL; check per-dir config if nothing found here\n     */\n    char **response_code_strings; /* from ap_custom_response(), not from\n                                   * ErrorDocument\n                                   */\n\n    /** per-request document root of the server. This allows mass vhosting\n     * modules better compatibility with some scripts. Normally the\n     * context_* info should be used instead */\n    const char *document_root;\n\n    /*\n     * more fine-grained context information which is set by modules like\n     * mod_alias and mod_userdir\n     */\n    /** the context root directory on disk for the current resource,\n     *  without trailing slash\n     */\n    const char *context_document_root;\n    /** the URI prefix that corresponds to the context_document_root directory,\n     *  without trailing slash\n     */\n    const char *context_prefix;\n\n    /** There is a script processor installed on the output filter chain,\n     * so it needs the default_handler to deliver a (script) file into\n     * the chain so it can process it. Normally, default_handler only\n     * serves files on a GET request (assuming the file is actual content),\n     * since other methods are not content-retrieval. This flag overrides\n     * that behavior, stating that the \"content\" is actually a script and\n     * won't actually be delivered as the response for the non-GET method.\n     */\n    int deliver_script;\n\n    /** Should addition of charset= be suppressed for this request?\n     */\n    int suppress_charset;\n}",
            "typedef_name": null,
            "fields": {
              "bb": "struct apr_bucket_brigade *",
              "notes": "void **",
              "response_code_strings": "char **",
              "document_root": "const char *",
              "context_document_root": "const char *",
              "context_prefix": "const char *",
              "deliver_script": "int",
              "suppress_charset": "int"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "status_lines": {
            "name": "status_lines",
            "type": "const char *const[103]",
            "is_extern": false,
            "is_static": true,
            "definition": "static const char * const status_lines[RESPONSE_CODES] =\n{\n    \"100 Continue\",\n    \"101 Switching Protocols\",\n    \"102 Processing\",\n#define LEVEL_200  3\n    \"200 OK\",\n    \"201 Created\",\n    \"202 Accepted\",\n    \"203 Non-Authoritative Information\",\n    \"204 No Content\",\n    \"205 Reset Content\",\n    \"206 Partial Content\",\n    \"207 Multi-Status\",\n    \"208 Already Reported\",\n    NULL, /* 209 */\n    NULL, /* 210 */\n    NULL, /* 211 */\n    NULL, /* 212 */\n    NULL, /* 213 */\n    NULL, /* 214 */\n    NULL, /* 215 */\n    NULL, /* 216 */\n    NULL, /* 217 */\n    NULL, /* 218 */\n    NULL, /* 219 */\n    NULL, /* 220 */\n    NULL, /* 221 */\n    NULL, /* 222 */\n    NULL, /* 223 */\n    NULL, /* 224 */\n    NULL, /* 225 */\n    \"226 IM Used\",\n#define LEVEL_300 30\n    \"300 Multiple Choices\",\n    \"301 Moved Permanently\",\n    \"302 Found\",\n    \"303 See Other\",\n    \"304 Not Modified\",\n    \"305 Use Proxy\",\n    NULL, /* 306 */\n    \"307 Temporary Redirect\",\n    \"308 Permanent Redirect\",\n#define LEVEL_400 39\n    \"400 Bad Request\",\n    \"401 Unauthorized\",\n    \"402 Payment Required\",\n    \"403 Forbidden\",\n    \"404 Not Found\",\n    \"405 Method Not Allowed\",\n    \"406 Not Acceptable\",\n    \"407 Proxy Authentication Required\",\n    \"408 Request Timeout\",\n    \"409 Conflict\",\n    \"410 Gone\",\n    \"411 Length Required\",\n    \"412 Precondition Failed\",\n    \"413 Request Entity Too Large\",\n    \"414 Request-URI Too Long\",\n    \"415 Unsupported Media Type\",\n    \"416 Requested Range Not Satisfiable\",\n    \"417 Expectation Failed\",\n    \"418 I'm A Teapot\",\n    NULL, /* 419 */\n    NULL, /* 420 */\n    \"421 Misdirected Request\",\n    \"422 Unprocessable Entity\",\n    \"423 Locked\",\n    \"424 Failed Dependency\",\n    \"425 Too Early\",\n    \"426 Upgrade Required\",\n    NULL, /* 427 */\n    \"428 Precondition Required\",\n    \"429 Too Many Requests\",\n    NULL, /* 430 */\n    \"431 Request Header Fields Too Large\",\n    NULL, /* 432 */\n    NULL, /* 433 */\n    NULL, /* 434 */\n    NULL, /* 435 */\n    NULL, /* 436 */\n    NULL, /* 437 */\n    NULL, /* 438 */\n    NULL, /* 439 */\n    NULL, /* 440 */\n    NULL, /* 441 */\n    NULL, /* 442 */\n    NULL, /* 443 */\n    NULL, /* 444 */\n    NULL, /* 445 */\n    NULL, /* 446 */\n    NULL, /* 447 */\n    NULL, /* 448 */\n    NULL, /* 449 */\n    NULL, /* 450 */\n    \"451 Unavailable For Legal Reasons\",\n#define LEVEL_500 91\n    \"500 Internal Server Error\",\n    \"501 Not Implemented\",\n    \"502 Bad Gateway\",\n    \"503 Service Unavailable\",\n    \"504 Gateway Timeout\",\n    \"505 HTTP Version Not Supported\",\n    \"506 Variant Also Negotiates\",\n    \"507 Insufficient Storage\",\n    \"508 Loop Detected\",\n    NULL, /* 509 */\n    \"510 Not Extended\",\n    \"511 Network Authentication Required\"\n}",
            "initializer": "{\n    \"100 Continue\",\n    \"101 Switching Protocols\",\n    \"102 Processing\",\n#define LEVEL_200  3\n    \"200 OK\",\n    \"201 Created\",\n    \"202 Accepted\",\n    \"203 Non-Authoritative Information\",\n    \"204 No Content\",\n    \"205 Reset Content\",\n    \"206 Partial Content\",\n    \"207 Multi-Status\",\n    \"208 Already Reported\",\n    NULL, /* 209 */\n    NULL, /* 210 */\n    NULL, /* 211 */\n    NULL, /* 212 */\n    NULL, /* 213 */\n    NULL, /* 214 */\n    NULL, /* 215 */\n    NULL, /* 216 */\n    NULL, /* 217 */\n    NULL, /* 218 */\n    NULL, /* 219 */\n    NULL, /* 220 */\n    NULL, /* 221 */\n    NULL, /* 222 */\n    NULL, /* 223 */\n    NULL, /* 224 */\n    NULL, /* 225 */\n    \"226 IM Used\",\n#define LEVEL_300 30\n    \"300 Multiple Choices\",\n    \"301 Moved Permanently\",\n    \"302 Found\",\n    \"303 See Other\",\n    \"304 Not Modified\",\n    \"305 Use Proxy\",\n    NULL, /* 306 */\n    \"307 Temporary Redirect\",\n    \"308 Permanent Redirect\",\n#define LEVEL_400 39\n    \"400 Bad Request\",\n    \"401 Unauthorized\",\n    \"402 Payment Required\",\n    \"403 Forbidden\",\n    \"404 Not Found\",\n    \"405 Method Not Allowed\",\n    \"406 Not Acceptable\",\n    \"407 Proxy Authentication Required\",\n    \"408 Request Timeout\",\n    \"409 Conflict\",\n    \"410 Gone\",\n    \"411 Length Required\",\n    \"412 Precondition Failed\",\n    \"413 Request Entity Too Large\",\n    \"414 Request-URI Too Long\",\n    \"415 Unsupported Media Type\",\n    \"416 Requested Range Not Satisfiable\",\n    \"417 Expectation Failed\",\n    \"418 I'm A Teapot\",\n    NULL, /* 419 */\n    NULL, /* 420 */\n    \"421 Misdirected Request\",\n    \"422 Unprocessable Entity\",\n    \"423 Locked\",\n    \"424 Failed Dependency\",\n    \"425 Too Early\",\n    \"426 Upgrade Required\",\n    NULL, /* 427 */\n    \"428 Precondition Required\",\n    \"429 Too Many Requests\",\n    NULL, /* 430 */\n    \"431 Request Header Fields Too Large\",\n    NULL, /* 432 */\n    NULL, /* 433 */\n    NULL, /* 434 */\n    NULL, /* 435 */\n    NULL, /* 436 */\n    NULL, /* 437 */\n    NULL, /* 438 */\n    NULL, /* 439 */\n    NULL, /* 440 */\n    NULL, /* 441 */\n    NULL, /* 442 */\n    NULL, /* 443 */\n    NULL, /* 444 */\n    NULL, /* 445 */\n    NULL, /* 446 */\n    NULL, /* 447 */\n    NULL, /* 448 */\n    NULL, /* 449 */\n    NULL, /* 450 */\n    \"451 Unavailable For Legal Reasons\",\n#define LEVEL_500 91\n    \"500 Internal Server Error\",\n    \"501 Not Implemented\",\n    \"502 Bad Gateway\",\n    \"503 Service Unavailable\",\n    \"504 Gateway Timeout\",\n    \"505 HTTP Version Not Supported\",\n    \"506 Variant Also Negotiates\",\n    \"507 Insufficient Storage\",\n    \"508 Loop Detected\",\n    NULL, /* 509 */\n    \"510 Not Extended\",\n    \"511 Network Authentication Required\"\n}",
            "full_definition": "static const char * const status_lines[RESPONSE_CODES] =\n{\n    \"100 Continue\",\n    \"101 Switching Protocols\",\n    \"102 Processing\",\n#define LEVEL_200  3\n    \"200 OK\",\n    \"201 Created\",\n    \"202 Accepted\",\n    \"203 Non-Authoritative Information\",\n    \"204 No Content\",\n    \"205 Reset Content\",\n    \"206 Partial Content\",\n    \"207 Multi-Status\",\n    \"208 Already Reported\",\n    NULL, /* 209 */\n    NULL, /* 210 */\n    NULL, /* 211 */\n    NULL, /* 212 */\n    NULL, /* 213 */\n    NULL, /* 214 */\n    NULL, /* 215 */\n    NULL, /* 216 */\n    NULL, /* 217 */\n    NULL, /* 218 */\n    NULL, /* 219 */\n    NULL, /* 220 */\n    NULL, /* 221 */\n    NULL, /* 222 */\n    NULL, /* 223 */\n    NULL, /* 224 */\n    NULL, /* 225 */\n    \"226 IM Used\",\n#define LEVEL_300 30\n    \"300 Multiple Choices\",\n    \"301 Moved Permanently\",\n    \"302 Found\",\n    \"303 See Other\",\n    \"304 Not Modified\",\n    \"305 Use Proxy\",\n    NULL, /* 306 */\n    \"307 Temporary Redirect\",\n    \"308 Permanent Redirect\",\n#define LEVEL_400 39\n    \"400 Bad Request\",\n    \"401 Unauthorized\",\n    \"402 Payment Required\",\n    \"403 Forbidden\",\n    \"404 Not Found\",\n    \"405 Method Not Allowed\",\n    \"406 Not Acceptable\",\n    \"407 Proxy Authentication Required\",\n    \"408 Request Timeout\",\n    \"409 Conflict\",\n    \"410 Gone\",\n    \"411 Length Required\",\n    \"412 Precondition Failed\",\n    \"413 Request Entity Too Large\",\n    \"414 Request-URI Too Long\",\n    \"415 Unsupported Media Type\",\n    \"416 Requested Range Not Satisfiable\",\n    \"417 Expectation Failed\",\n    \"418 I'm A Teapot\",\n    NULL, /* 419 */\n    NULL, /* 420 */\n    \"421 Misdirected Request\",\n    \"422 Unprocessable Entity\",\n    \"423 Locked\",\n    \"424 Failed Dependency\",\n    \"425 Too Early\",\n    \"426 Upgrade Required\",\n    NULL, /* 427 */\n    \"428 Precondition Required\",\n    \"429 Too Many Requests\",\n    NULL, /* 430 */\n    \"431 Request Header Fields Too Large\",\n    NULL, /* 432 */\n    NULL, /* 433 */\n    NULL, /* 434 */\n    NULL, /* 435 */\n    NULL, /* 436 */\n    NULL, /* 437 */\n    NULL, /* 438 */\n    NULL, /* 439 */\n    NULL, /* 440 */\n    NULL, /* 441 */\n    NULL, /* 442 */\n    NULL, /* 443 */\n    NULL, /* 444 */\n    NULL, /* 445 */\n    NULL, /* 446 */\n    NULL, /* 447 */\n    NULL, /* 448 */\n    NULL, /* 449 */\n    NULL, /* 450 */\n    \"451 Unavailable For Legal Reasons\",\n#define LEVEL_500 91\n    \"500 Internal Server Error\",\n    \"501 Not Implemented\",\n    \"502 Bad Gateway\",\n    \"503 Service Unavailable\",\n    \"504 Gateway Timeout\",\n    \"505 HTTP Version Not Supported\",\n    \"506 Variant Also Negotiates\",\n    \"507 Insufficient Storage\",\n    \"508 Loop Detected\",\n    NULL, /* 509 */\n    \"510 Not Extended\",\n    \"511 Network Authentication Required\"\n}",
            "used_macros": {
              "LEVEL_200": {
                "name": "LEVEL_200",
                "value": "3",
                "definition": "#define LEVEL_200  3"
              },
              "LEVEL_300": {
                "name": "LEVEL_300",
                "value": "30",
                "definition": "#define LEVEL_300 30"
              },
              "LEVEL_400": {
                "name": "LEVEL_400",
                "value": "39",
                "definition": "#define LEVEL_400 39"
              },
              "LEVEL_500": {
                "name": "LEVEL_500",
                "value": "91",
                "definition": "#define LEVEL_500 91"
              }
            },
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(void) ap_send_error_response(request_rec *r, int recursive_error)\n{\n    int status = r->status;\n    int idx = ap_index_of_response(status);\n    char *custom_response;\n    const char *location = apr_table_get(r->headers_out, \"Location\");\n\n    /* At this point, we are starting the response over, so we have to reset\n     * this value.\n     */\n    r->eos_sent = 0;\n\n    /* and we need to get rid of any RESOURCE filters that might be lurking\n     * around, thinking they are in the middle of the original request\n     */\n\n    r->output_filters = r->proto_output_filters;\n\n    ap_run_insert_error_filter(r);\n\n    /* We need to special-case the handling of 204 and 304 responses,\n     * since they have specific HTTP requirements and do not include a\n     * message body.  Note that being assbackwards here is not an option.\n     */\n    if (AP_STATUS_IS_HEADER_ONLY(status)) {\n        ap_finalize_request_protocol(r);\n        return;\n    }\n\n    /*\n     * It's possible that the Location field might be in r->err_headers_out\n     * instead of r->headers_out; use the latter if possible, else the\n     * former.\n     */\n    if (location == NULL) {\n        location = apr_table_get(r->err_headers_out, \"Location\");\n    }\n\n    if (!r->assbackwards) {\n\n        /* For all HTTP/1.x responses for which we generate the message,\n         * we need to avoid inheriting the \"normal status\" header fields\n         * that may have been set by the request handler before the\n         * error or redirect, except for Location on external redirects.\n         */\n        apr_table_clear(r->headers_out);\n\n        if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {\n            if ((location != NULL) && *location) {\n                apr_table_setn(r->headers_out, \"Location\", location);\n            }\n            else {\n                location = \"\";   /* avoids coredump when printing, below */\n            }\n        }\n\n        r->content_languages = NULL;\n        r->content_encoding = NULL;\n        r->clength = 0;\n\n        if (apr_table_get(r->subprocess_env,\n                          \"suppress-error-charset\") != NULL) {\n            core_request_config *request_conf =\n                        ap_get_core_module_config(r->request_config);\n            request_conf->suppress_charset = 1; /* avoid adding default\n                                                 * charset later\n                                                 */\n            ap_set_content_type_ex(r, \"text/html\", 1);\n        }\n        else {\n            ap_set_content_type_ex(r, \"text/html; charset=iso-8859-1\", 1);\n        }\n\n        if ((status == HTTP_METHOD_NOT_ALLOWED)\n            || (status == HTTP_NOT_IMPLEMENTED)) {\n            apr_table_setn(r->headers_out, \"Allow\", make_allow(r));\n        }\n\n        if (r->header_only) {\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n\n    if ((custom_response = ap_response_code_string(r, idx))) {\n        /*\n         * We have a custom response output. This should only be\n         * a text-string to write back. But if the ErrorDocument\n         * was a local redirect and the requested resource failed\n         * for any reason, the custom_response will still hold the\n         * redirect URL. We don't really want to output this URL\n         * as a text message, so first check the custom response\n         * string to ensure that it is a text-string (using the\n         * same test used in ap_die(), i.e. does it start with a \").\n         *\n         * If it's not a text string, we've got a recursive error or\n         * an external redirect.  If it's a recursive error, ap_die passes\n         * us the second error code so we can write both, and has already\n         * backed up to the original error.  If it's an external redirect,\n         * it hasn't happened yet; we may never know if it fails.\n         */\n        if (custom_response[0] == '\\\"') {\n            ap_rvputs_proto_in_ascii(r, custom_response + 1, NULL);\n            ap_finalize_request_protocol(r);\n            return;\n        }\n    }\n    {\n        const char *title = status_lines[idx];\n        const char *h1;\n\n        /* Accept a status_line set by a module, but only if it begins\n         * with the correct 3 digit status code\n         */\n        if (r->status_line) {\n            char *end;\n            int len = strlen(r->status_line);\n            if (len >= 3\n                && apr_strtoi64(r->status_line, &end, 10) == r->status\n                && (end - 3) == r->status_line\n                && (len < 4 || apr_isspace(r->status_line[3]))\n                && (len < 5 || apr_isalnum(r->status_line[4]))) {\n                /* Since we passed the above check, we know that length three\n                 * is equivalent to only a 3 digit numeric http status.\n                 * RFC2616 mandates a trailing space, let's add it.\n                 * If we have an empty reason phrase, we also add \"Unknown Reason\".\n                 */\n                if (len == 3) {\n                    r->status_line = apr_pstrcat(r->pool, r->status_line, \" Unknown Reason\", NULL);\n                } else if (len == 4) {\n                    r->status_line = apr_pstrcat(r->pool, r->status_line, \"Unknown Reason\", NULL);\n                }\n                title = r->status_line;\n            }\n        }\n\n        /* folks decided they didn't want the error code in the H1 text */\n        h1 = &title[4];\n\n        /* can't count on a charset filter being in place here,\n         * so do ebcdic->ascii translation explicitly (if needed)\n         */\n\n        ap_rvputs_proto_in_ascii(r,\n                  DOCTYPE_HTML_4_01\n                  \"<html><head>\\n<title>\", title,\n                  \"</title>\\n</head><body>\\n<h1>\", h1, \"</h1>\\n\",\n                  NULL);\n\n        ap_rvputs_proto_in_ascii(r,\n                                 get_canned_error_string(status, r, location),\n                                 NULL);\n\n        if (recursive_error) {\n            ap_rvputs_proto_in_ascii(r, \"<p>Additionally, a \",\n                      status_lines[ap_index_of_response(recursive_error)],\n                      \"\\nerror was encountered while trying to use an \"\n                      \"ErrorDocument to handle the request.</p>\\n\", NULL);\n        }\n        ap_rvputs_proto_in_ascii(r, ap_psignature(\"<hr>\\n\", r), NULL);\n        ap_rvputs_proto_in_ascii(r, \"</body></html>\\n\", NULL);\n    }\n    ap_finalize_request_protocol(r);\n}"
    },
    "ap_make_method_list@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1381, column 32>": {
      "basic_info": {
        "function_id": 1663,
        "name": "ap_make_method_list",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1381, column 32>",
        "is_definition": true,
        "start_line": 1381,
        "end_line": 1389,
        "return_type": "ap_method_list_t *",
        "parameters": [
          {
            "name": "p",
            "type": "apr_pool_t *"
          },
          {
            "name": "nelts",
            "type": "int"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "apr_array_make": {
            "declaration": "APR_DECLARE(apr_array_header_t *) apr_array_make(apr_pool_t *p,\n                                                 int nelts, int elt_size)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "ap_method_list_t": {
            "name": "ap_method_list_t",
            "definition": "struct ap_method_list_t {\n    /** The bitmask used for known methods */\n    apr_int64_t method_mask;\n    /** the array used for extension methods */\n    apr_array_header_t *method_list;\n}",
            "typedef_name": null,
            "fields": {
              "method_mask": "apr_int64_t",
              "method_list": "apr_array_header_t *"
            },
            "condition": ""
          },
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(ap_method_list_t *) ap_make_method_list(apr_pool_t *p, int nelts)\n{\n    ap_method_list_t *ml;\n\n    ml = (ap_method_list_t *) apr_palloc(p, sizeof(ap_method_list_t));\n    ml->method_mask = 0;\n    ml->method_list = apr_array_make(p, nelts, sizeof(char *));\n    return ml;\n}"
    },
    "ap_copy_method_list@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1395, column 18>": {
      "basic_info": {
        "function_id": 1664,
        "name": "ap_copy_method_list",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1395, column 18>",
        "is_definition": true,
        "start_line": 1395,
        "end_line": 1408,
        "return_type": "void",
        "parameters": [
          {
            "name": "dest",
            "type": "ap_method_list_t *"
          },
          {
            "name": "src",
            "type": "ap_method_list_t *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_array_push": {
            "declaration": "APR_DECLARE(void *) apr_array_push(apr_array_header_t *arr)",
            "is_external": true,
            "definition": null
          },
          "apr_pstrdup": {
            "declaration": "APR_DECLARE(char *) apr_pstrdup(apr_pool_t *p, const char *s)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "ap_method_list_t": {
            "name": "ap_method_list_t",
            "definition": "struct ap_method_list_t {\n    /** The bitmask used for known methods */\n    apr_int64_t method_mask;\n    /** the array used for extension methods */\n    apr_array_header_t *method_list;\n}",
            "typedef_name": null,
            "fields": {
              "method_mask": "apr_int64_t",
              "method_list": "apr_array_header_t *"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(void) ap_copy_method_list(ap_method_list_t *dest,\n                                     ap_method_list_t *src)\n{\n    int i;\n    char **imethods;\n    char **omethods;\n\n    dest->method_mask = src->method_mask;\n    imethods = (char **) src->method_list->elts;\n    for (i = 0; i < src->method_list->nelts; ++i) {\n        omethods = (char **) apr_array_push(dest->method_list);\n        *omethods = apr_pstrdup(dest->method_list->pool, imethods[i]);\n    }\n}"
    },
    "ap_method_in_list@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1414, column 17>": {
      "basic_info": {
        "function_id": 1665,
        "name": "ap_method_in_list",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1414, column 17>",
        "is_definition": true,
        "start_line": 1414,
        "end_line": 1434,
        "return_type": "int",
        "parameters": [
          {
            "name": "l",
            "type": "ap_method_list_t *"
          },
          {
            "name": "method",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_method_number_of": {
            "declaration": "AP_DECLARE(int) ap_method_number_of(const char *method)\n{\n    int len = strlen(method);\n\n    /* check if the method has been dynamically registered */\n    int *methnum = apr_hash_get(methods_registry, method, len);\n\n    if (methnum != NULL) {\n        return *methnum;\n    }\n\n    return M_INVALID;\n}",
            "is_external": false,
            "definition": "AP_DECLARE(int) ap_method_number_of(const char *method)\n{\n    int len = strlen(method);\n\n    /* check if the method has been dynamically registered */\n    int *methnum = apr_hash_get(methods_registry, method, len);\n\n    if (methnum != NULL) {\n        return *methnum;\n    }\n\n    return M_INVALID;\n}"
          },
          "ap_array_str_contains": {
            "declaration": "AP_DECLARE(int) ap_array_str_contains(const apr_array_header_t *array, \n                                      const char *s)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "ap_method_list_t": {
            "name": "ap_method_list_t",
            "definition": "struct ap_method_list_t {\n    /** The bitmask used for known methods */\n    apr_int64_t method_mask;\n    /** the array used for extension methods */\n    apr_array_header_t *method_list;\n}",
            "typedef_name": null,
            "fields": {
              "method_mask": "apr_int64_t",
              "method_list": "apr_array_header_t *"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "apr_int64_t"
        ]
      },
      "source_code": "AP_DECLARE(int) ap_method_in_list(ap_method_list_t *l, const char *method)\n{\n    int methnum;\n\n    /*\n     * If it's one of our known methods, use the shortcut and check the\n     * bitmask.\n     */\n    methnum = ap_method_number_of(method);\n    if (methnum != M_INVALID) {\n        return !!(l->method_mask & (AP_METHOD_BIT << methnum));\n    }\n    /*\n     * Otherwise, see if the method name is in the array of string names.\n     */\n    if ((l->method_list == NULL) || (l->method_list->nelts == 0)) {\n        return 0;\n    }\n\n    return ap_array_str_contains(l->method_list, method);\n}"
    },
    "ap_method_list_add@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1439, column 18>": {
      "basic_info": {
        "function_id": 1666,
        "name": "ap_method_list_add",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1439, column 18>",
        "is_definition": true,
        "start_line": 1439,
        "end_line": 1462,
        "return_type": "void",
        "parameters": [
          {
            "name": "l",
            "type": "ap_method_list_t *"
          },
          {
            "name": "method",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_method_number_of": {
            "declaration": "AP_DECLARE(int) ap_method_number_of(const char *method)\n{\n    int len = strlen(method);\n\n    /* check if the method has been dynamically registered */\n    int *methnum = apr_hash_get(methods_registry, method, len);\n\n    if (methnum != NULL) {\n        return *methnum;\n    }\n\n    return M_INVALID;\n}",
            "is_external": false,
            "definition": "AP_DECLARE(int) ap_method_number_of(const char *method)\n{\n    int len = strlen(method);\n\n    /* check if the method has been dynamically registered */\n    int *methnum = apr_hash_get(methods_registry, method, len);\n\n    if (methnum != NULL) {\n        return *methnum;\n    }\n\n    return M_INVALID;\n}"
          },
          "ap_array_str_contains": {
            "declaration": "AP_DECLARE(int) ap_array_str_contains(const apr_array_header_t *array, \n                                      const char *s)",
            "is_external": true,
            "definition": null
          },
          "apr_array_push": {
            "declaration": "APR_DECLARE(void *) apr_array_push(apr_array_header_t *arr)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "ap_method_list_t": {
            "name": "ap_method_list_t",
            "definition": "struct ap_method_list_t {\n    /** The bitmask used for known methods */\n    apr_int64_t method_mask;\n    /** the array used for extension methods */\n    apr_array_header_t *method_list;\n}",
            "typedef_name": null,
            "fields": {
              "method_mask": "apr_int64_t",
              "method_list": "apr_array_header_t *"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "apr_int64_t"
        ]
      },
      "source_code": "AP_DECLARE(void) ap_method_list_add(ap_method_list_t *l, const char *method)\n{\n    int methnum;\n    const char **xmethod;\n\n    /*\n     * If it's one of our known methods, use the shortcut and use the\n     * bitmask.\n     */\n    methnum = ap_method_number_of(method);\n    if (methnum != M_INVALID) {\n        l->method_mask |= (AP_METHOD_BIT << methnum);\n        return;\n    }\n    /*\n     * Otherwise, see if the method name is in the array of string names.\n     */\n    if (ap_array_str_contains(l->method_list, method)) {\n        return;\n    }\n\n    xmethod = (const char **) apr_array_push(l->method_list);\n    *xmethod = method;\n}"
    },
    "ap_method_list_remove@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1467, column 18>": {
      "basic_info": {
        "function_id": 1667,
        "name": "ap_method_list_remove",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1467, column 18>",
        "is_definition": true,
        "start_line": 1467,
        "end_line": 1500,
        "return_type": "void",
        "parameters": [
          {
            "name": "l",
            "type": "ap_method_list_t *"
          },
          {
            "name": "method",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_method_number_of": {
            "declaration": "AP_DECLARE(int) ap_method_number_of(const char *method)\n{\n    int len = strlen(method);\n\n    /* check if the method has been dynamically registered */\n    int *methnum = apr_hash_get(methods_registry, method, len);\n\n    if (methnum != NULL) {\n        return *methnum;\n    }\n\n    return M_INVALID;\n}",
            "is_external": false,
            "definition": "AP_DECLARE(int) ap_method_number_of(const char *method)\n{\n    int len = strlen(method);\n\n    /* check if the method has been dynamically registered */\n    int *methnum = apr_hash_get(methods_registry, method, len);\n\n    if (methnum != NULL) {\n        return *methnum;\n    }\n\n    return M_INVALID;\n}"
          },
          "strcmp": {
            "declaration": "extern int strcmp (const char *__s1, const char *__s2)\n     __THROW __attribute_pure__ __nonnull ((1, 2))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "ap_method_list_t": {
            "name": "ap_method_list_t",
            "definition": "struct ap_method_list_t {\n    /** The bitmask used for known methods */\n    apr_int64_t method_mask;\n    /** the array used for extension methods */\n    apr_array_header_t *method_list;\n}",
            "typedef_name": null,
            "fields": {
              "method_mask": "apr_int64_t",
              "method_list": "apr_array_header_t *"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "apr_int64_t"
        ]
      },
      "source_code": "AP_DECLARE(void) ap_method_list_remove(ap_method_list_t *l,\n                                       const char *method)\n{\n    int methnum;\n    char **methods;\n\n    /*\n     * If it's a known methods, either builtin or registered\n     * by a module, use the bitmask.\n     */\n    methnum = ap_method_number_of(method);\n    if (methnum != M_INVALID) {\n        l->method_mask &= ~(AP_METHOD_BIT << methnum);\n        return;\n    }\n    /*\n     * Otherwise, see if the method name is in the array of string names.\n     */\n    if (l->method_list->nelts != 0) {\n        int i, j, k;\n        methods = (char **)l->method_list->elts;\n        for (i = 0; i < l->method_list->nelts; ) {\n            if (strcmp(method, methods[i]) == 0) {\n                for (j = i, k = i + 1; k < l->method_list->nelts; ++j, ++k) {\n                    methods[j] = methods[k];\n                }\n                --l->method_list->nelts;\n            }\n            else {\n                ++i;\n            }\n        }\n    }\n}"
    },
    "ap_clear_method_list@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1505, column 18>": {
      "basic_info": {
        "function_id": 1668,
        "name": "ap_clear_method_list",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1505, column 18>",
        "is_definition": true,
        "start_line": 1505,
        "end_line": 1509,
        "return_type": "void",
        "parameters": [
          {
            "name": "l",
            "type": "ap_method_list_t *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {},
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "ap_method_list_t": {
            "name": "ap_method_list_t",
            "definition": "struct ap_method_list_t {\n    /** The bitmask used for known methods */\n    apr_int64_t method_mask;\n    /** the array used for extension methods */\n    apr_array_header_t *method_list;\n}",
            "typedef_name": null,
            "fields": {
              "method_mask": "apr_int64_t",
              "method_list": "apr_array_header_t *"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(void) ap_clear_method_list(ap_method_list_t *l)\n{\n    l->method_mask = 0;\n    l->method_list->nelts = 0;\n}"
    },
    "ap_h1_append_header@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1511, column 26>": {
      "basic_info": {
        "function_id": 1669,
        "name": "ap_h1_append_header",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1511, column 26>",
        "is_definition": true,
        "start_line": 1511,
        "end_line": 1540,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "bb",
            "type": "apr_bucket_brigade *"
          },
          {
            "name": "pool",
            "type": "apr_pool_t *"
          },
          {
            "name": "name",
            "type": "const char *"
          },
          {
            "name": "value",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "strlen": {
            "declaration": "extern size_t strlen (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_writev": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_writev(apr_bucket_brigade *b,\n                                             apr_brigade_flush flush,\n                                             void *ctx,\n                                             const struct iovec *vec,\n                                             apr_size_t nvec)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "apr_pool_t": {
            "name": "apr_pool_t",
            "definition": "struct apr_pool_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          },
          "iovec": {
            "name": "iovec",
            "definition": "struct iovec\n  {\n    void *iov_base;\t/* Pointer to data.  */\n    size_t iov_len;\t/* Length of data.  */\n  }",
            "typedef_name": null,
            "fields": {
              "iov_base": "void *",
              "iov_len": "size_t"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "apr_status_t"
        ]
      },
      "source_code": "AP_DECLARE(apr_status_t) ap_h1_append_header(apr_bucket_brigade *bb,\n                                             apr_pool_t *pool,\n                                             const char *name, const char *value)\n{\n#if APR_CHARSET_EBCDIC\n    char *headfield;\n    apr_size_t len;\n\n    headfield = apr_pstrcat(pool, name, \": \", value, CRLF, NULL);\n    len = strlen(headfield);\n\n    ap_xlate_proto_to_ascii(headfield, len);\n    return apr_brigade_write(bb, NULL, NULL, headfield, len);\n#else\n    struct iovec vec[4];\n    struct iovec *v = vec;\n    v->iov_base = (void *)name;\n    v->iov_len = strlen(name);\n    v++;\n    v->iov_base = \": \";\n    v->iov_len = sizeof(\": \") - 1;\n    v++;\n    v->iov_base = (void *)value;\n    v->iov_len = strlen(value);\n    v++;\n    v->iov_base = CRLF;\n    v->iov_len = sizeof(CRLF) - 1;\n    return apr_brigade_writev(bb, NULL, NULL, vec, 4);\n#endif /* !APR_CHARSET_EBCDIC */\n}"
    },
    "ap_h1_append_headers@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1542, column 26>": {
      "basic_info": {
        "function_id": 1670,
        "name": "ap_h1_append_headers",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1542, column 26>",
        "is_definition": true,
        "start_line": 1542,
        "end_line": 1602,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "bb",
            "type": "apr_bucket_brigade *"
          },
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "headers",
            "type": "apr_table_t *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_table_elts": {
            "declaration": "APR_DECLARE(const apr_array_header_t *) apr_table_elts(const apr_table_t *t)",
            "is_external": true,
            "definition": null
          },
          "apr_palloc": {
            "declaration": "APR_DECLARE(void *) apr_palloc(apr_pool_t *p, apr_size_t size)\n#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))\n                    __attribute__((alloc_size(2)))\n#endif\n                    __attribute__((nonnull(1)))",
            "is_external": true,
            "definition": null
          },
          "strlen": {
            "declaration": "extern size_t strlen (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_writev": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_writev(apr_bucket_brigade *b,\n                                             apr_brigade_flush flush,\n                                             void *ctx,\n                                             const struct iovec *vec,\n                                             apr_size_t nvec)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_h1_add_end_chunk@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1614, column 18>": {
            "source_code": "AP_DECLARE(void) ap_h1_add_end_chunk(apr_bucket_brigade *b,\n                                     apr_bucket *eos,\n                                     request_rec *r,\n                                     apr_table_t *trailers)\n{\n    if (!trailers || apr_is_empty_table(trailers)) {\n        apr_bucket *e;\n\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                      \"append empty end chunk\");\n        e = apr_bucket_immortal_create(ZERO_ASCII CRLF_ASCII\n                                       CRLF_ASCII, 5, b->bucket_alloc);\n        if (eos) {\n            APR_BUCKET_INSERT_BEFORE(eos, e);\n        }\n        else {\n            APR_BRIGADE_INSERT_TAIL(b, e);\n        }\n    }\n    else {\n        apr_bucket_brigade *tmp;\n\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                      \"append end chunk with trailers\");\n        tmp = eos? apr_brigade_split_ex(b, eos, NULL) : NULL;\n        apr_brigade_write(b, NULL, NULL, ZERO_ASCII CRLF_ASCII, 3);\n        ap_h1_append_headers(b, r, trailers);\n        ap_h1_terminate_header(b);\n        if (tmp) APR_BRIGADE_CONCAT(b, tmp);\n    }\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1614, column 18>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_table_t": {
            "name": "apr_table_t",
            "definition": "struct apr_table_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          },
          "apr_array_header_t": {
            "name": "apr_array_header_t",
            "definition": "struct apr_array_header_t {\n    /** The pool the array is allocated out of */\n    apr_pool_t *pool;\n    /** The amount of memory allocated for each element of the array */\n    int elt_size;\n    /** The number of active elements in the array */\n    int nelts;\n    /** The number of elements allocated in the array */\n    int nalloc;\n    /** The elements in the array */\n    char *elts;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "elt_size": "int",
              "nelts": "int",
              "nalloc": "int",
              "elts": "char *"
            },
            "condition": ""
          },
          "apr_table_entry_t": {
            "name": "apr_table_entry_t",
            "definition": "struct apr_table_entry_t {\n    /** The key for the current table entry */\n    char *key;          /* maybe NULL in future;\n                         * check when iterating thru table_elts\n                         */\n    /** The value for the current table entry */\n    char *val;\n\n    /** A checksum for the key, for use by the apr_table internals */\n    apr_uint32_t key_checksum;\n}",
            "typedef_name": null,
            "fields": {
              "key": "char *",
              "val": "char *",
              "key_checksum": "apr_uint32_t"
            },
            "condition": ""
          },
          "iovec": {
            "name": "iovec",
            "definition": "struct iovec\n  {\n    void *iov_base;\t/* Pointer to data.  */\n    size_t iov_len;\t/* Length of data.  */\n  }",
            "typedef_name": null,
            "fields": {
              "iov_base": "void *",
              "iov_len": "size_t"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "apr_status_t"
        ]
      },
      "source_code": "AP_DECLARE(apr_status_t) ap_h1_append_headers(apr_bucket_brigade *bb,\n                                              request_rec *r,\n                                              apr_table_t *headers)\n{\n    const apr_array_header_t *elts;\n    const apr_table_entry_t *t_elt;\n    const apr_table_entry_t *t_end;\n    struct iovec *vec;\n    struct iovec *vec_next;\n\n    elts = apr_table_elts(headers);\n    if (elts->nelts == 0) {\n        return APR_SUCCESS;\n    }\n    t_elt = (const apr_table_entry_t *)(elts->elts);\n    t_end = t_elt + elts->nelts;\n    vec = (struct iovec *)apr_palloc(r->pool, 4 * elts->nelts *\n                                     sizeof(struct iovec));\n    vec_next = vec;\n\n    /* For each field, generate\n     *    name \": \" value CRLF\n     */\n    do {\n        if (t_elt->key && t_elt->val) {\n            vec_next->iov_base = (void*)(t_elt->key);\n            vec_next->iov_len = strlen(t_elt->key);\n            vec_next++;\n            vec_next->iov_base = \": \";\n            vec_next->iov_len = sizeof(\": \") - 1;\n            vec_next++;\n            vec_next->iov_base = (void*)(t_elt->val);\n            vec_next->iov_len = strlen(t_elt->val);\n            vec_next++;\n            vec_next->iov_base = CRLF;\n            vec_next->iov_len = sizeof(CRLF) - 1;\n            vec_next++;\n        }\n        t_elt++;\n    } while (t_elt < t_end);\n\n    if (APLOGrtrace4(r)) {\n        t_elt = (const apr_table_entry_t *)(elts->elts);\n        do {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r, \"  %s: %s\",\n                          t_elt->key, t_elt->val);\n            t_elt++;\n        } while (t_elt < t_end);\n    }\n\n#if APR_CHARSET_EBCDIC\n    {\n        apr_size_t len;\n        char *tmp = apr_pstrcatv(r->pool, vec, vec_next - vec, &len);\n        ap_xlate_proto_to_ascii(tmp, len);\n        return apr_brigade_write(bb, NULL, NULL, tmp, len);\n    }\n#else\n    return apr_brigade_writev(bb, NULL, NULL, vec, vec_next - vec);\n#endif\n}"
    },
    "ap_h1_terminate_header@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1604, column 26>": {
      "basic_info": {
        "function_id": 1671,
        "name": "ap_h1_terminate_header",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1604, column 26>",
        "is_definition": true,
        "start_line": 1604,
        "end_line": 1612,
        "return_type": "apr_status_t",
        "parameters": [
          {
            "name": "bb",
            "type": "apr_bucket_brigade *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "strlen": {
            "declaration": "extern size_t strlen (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_write": {
            "declaration": "APU_DECLARE(apr_status_t) apr_brigade_write(apr_bucket_brigade *b,\n                                            apr_brigade_flush flush, void *ctx,\n                                            const char *str, apr_size_t nbyte)",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_h1_add_end_chunk@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1614, column 18>": {
            "source_code": "AP_DECLARE(void) ap_h1_add_end_chunk(apr_bucket_brigade *b,\n                                     apr_bucket *eos,\n                                     request_rec *r,\n                                     apr_table_t *trailers)\n{\n    if (!trailers || apr_is_empty_table(trailers)) {\n        apr_bucket *e;\n\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                      \"append empty end chunk\");\n        e = apr_bucket_immortal_create(ZERO_ASCII CRLF_ASCII\n                                       CRLF_ASCII, 5, b->bucket_alloc);\n        if (eos) {\n            APR_BUCKET_INSERT_BEFORE(eos, e);\n        }\n        else {\n            APR_BRIGADE_INSERT_TAIL(b, e);\n        }\n    }\n    else {\n        apr_bucket_brigade *tmp;\n\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                      \"append end chunk with trailers\");\n        tmp = eos? apr_brigade_split_ex(b, eos, NULL) : NULL;\n        apr_brigade_write(b, NULL, NULL, ZERO_ASCII CRLF_ASCII, 3);\n        ap_h1_append_headers(b, r, trailers);\n        ap_h1_terminate_header(b);\n        if (tmp) APR_BRIGADE_CONCAT(b, tmp);\n    }\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1614, column 18>"
          }
        },
        "used_macros": {},
        "used_structs": {
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          }
        },
        "used_globals": {},
        "used_typedefs": [
          "apr_size_t",
          "apr_status_t"
        ]
      },
      "source_code": "AP_DECLARE(apr_status_t) ap_h1_terminate_header(apr_bucket_brigade *bb)\n{\n    char crlf[] = CRLF;\n    apr_size_t buflen;\n\n    buflen = strlen(crlf);\n    ap_xlate_proto_to_ascii(crlf, buflen);\n    return apr_brigade_write(bb, NULL, NULL, crlf, buflen);\n}"
    },
    "ap_h1_add_end_chunk@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1614, column 18>": {
      "basic_info": {
        "function_id": 1672,
        "name": "ap_h1_add_end_chunk",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1614, column 18>",
        "is_definition": true,
        "start_line": 1614,
        "end_line": 1644,
        "return_type": "void",
        "parameters": [
          {
            "name": "b",
            "type": "apr_bucket_brigade *"
          },
          {
            "name": "eos",
            "type": "apr_bucket *"
          },
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "trailers",
            "type": "apr_table_t *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "apr_is_empty_table": {
            "declaration": "APR_DECLARE(int) apr_is_empty_table(const apr_table_t *t)",
            "is_external": true,
            "definition": null
          },
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "apr_brigade_split_ex": {
            "declaration": "APU_DECLARE(apr_bucket_brigade *) apr_brigade_split_ex(apr_bucket_brigade *b,\n                                                       apr_bucket *e,\n                                                       apr_bucket_brigade *a)",
            "is_external": true,
            "definition": null
          },
          "ap_h1_append_headers": {
            "declaration": "AP_DECLARE(apr_status_t) ap_h1_append_headers(apr_bucket_brigade *bb,\n                                              request_rec *r,\n                                              apr_table_t *headers)\n{\n    const apr_array_header_t *elts;\n    const apr_table_entry_t *t_elt;\n    const apr_table_entry_t *t_end;\n    struct iovec *vec;\n    struct iovec *vec_next;\n\n    elts = apr_table_elts(headers);\n    if (elts->nelts == 0) {\n        return APR_SUCCESS;\n    }\n    t_elt = (const apr_table_entry_t *)(elts->elts);\n    t_end = t_elt + elts->nelts;\n    vec = (struct iovec *)apr_palloc(r->pool, 4 * elts->nelts *\n                                     sizeof(struct iovec));\n    vec_next = vec;\n\n    /* For each field, generate\n     *    name \": \" value CRLF\n     */\n    do {\n        if (t_elt->key && t_elt->val) {\n            vec_next->iov_base = (void*)(t_elt->key);\n            vec_next->iov_len = strlen(t_elt->key);\n            vec_next++;\n            vec_next->iov_base = \": \";\n            vec_next->iov_len = sizeof(\": \") - 1;\n            vec_next++;\n            vec_next->iov_base = (void*)(t_elt->val);\n            vec_next->iov_len = strlen(t_elt->val);\n            vec_next++;\n            vec_next->iov_base = CRLF;\n            vec_next->iov_len = sizeof(CRLF) - 1;\n            vec_next++;\n        }\n        t_elt++;\n    } while (t_elt < t_end);\n\n    if (APLOGrtrace4(r)) {\n        t_elt = (const apr_table_entry_t *)(elts->elts);\n        do {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r, \"  %s: %s\",\n                          t_elt->key, t_elt->val);\n            t_elt++;\n        } while (t_elt < t_end);\n    }\n\n#if APR_CHARSET_EBCDIC\n    {\n        apr_size_t len;\n        char *tmp = apr_pstrcatv(r->pool, vec, vec_next - vec, &len);\n        ap_xlate_proto_to_ascii(tmp, len);\n        return apr_brigade_write(bb, NULL, NULL, tmp, len);\n    }\n#else\n    return apr_brigade_writev(bb, NULL, NULL, vec, vec_next - vec);\n#endif\n}",
            "is_external": false,
            "definition": "AP_DECLARE(apr_status_t) ap_h1_append_headers(apr_bucket_brigade *bb,\n                                              request_rec *r,\n                                              apr_table_t *headers)\n{\n    const apr_array_header_t *elts;\n    const apr_table_entry_t *t_elt;\n    const apr_table_entry_t *t_end;\n    struct iovec *vec;\n    struct iovec *vec_next;\n\n    elts = apr_table_elts(headers);\n    if (elts->nelts == 0) {\n        return APR_SUCCESS;\n    }\n    t_elt = (const apr_table_entry_t *)(elts->elts);\n    t_end = t_elt + elts->nelts;\n    vec = (struct iovec *)apr_palloc(r->pool, 4 * elts->nelts *\n                                     sizeof(struct iovec));\n    vec_next = vec;\n\n    /* For each field, generate\n     *    name \": \" value CRLF\n     */\n    do {\n        if (t_elt->key && t_elt->val) {\n            vec_next->iov_base = (void*)(t_elt->key);\n            vec_next->iov_len = strlen(t_elt->key);\n            vec_next++;\n            vec_next->iov_base = \": \";\n            vec_next->iov_len = sizeof(\": \") - 1;\n            vec_next++;\n            vec_next->iov_base = (void*)(t_elt->val);\n            vec_next->iov_len = strlen(t_elt->val);\n            vec_next++;\n            vec_next->iov_base = CRLF;\n            vec_next->iov_len = sizeof(CRLF) - 1;\n            vec_next++;\n        }\n        t_elt++;\n    } while (t_elt < t_end);\n\n    if (APLOGrtrace4(r)) {\n        t_elt = (const apr_table_entry_t *)(elts->elts);\n        do {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r, \"  %s: %s\",\n                          t_elt->key, t_elt->val);\n            t_elt++;\n        } while (t_elt < t_end);\n    }\n\n#if APR_CHARSET_EBCDIC\n    {\n        apr_size_t len;\n        char *tmp = apr_pstrcatv(r->pool, vec, vec_next - vec, &len);\n        ap_xlate_proto_to_ascii(tmp, len);\n        return apr_brigade_write(bb, NULL, NULL, tmp, len);\n    }\n#else\n    return apr_brigade_writev(bb, NULL, NULL, vec, vec_next - vec);\n#endif\n}"
          },
          "ap_h1_terminate_header": {
            "declaration": "AP_DECLARE(apr_status_t) ap_h1_terminate_header(apr_bucket_brigade *bb)\n{\n    char crlf[] = CRLF;\n    apr_size_t buflen;\n\n    buflen = strlen(crlf);\n    ap_xlate_proto_to_ascii(crlf, buflen);\n    return apr_brigade_write(bb, NULL, NULL, crlf, buflen);\n}",
            "is_external": false,
            "definition": "AP_DECLARE(apr_status_t) ap_h1_terminate_header(apr_bucket_brigade *bb)\n{\n    char crlf[] = CRLF;\n    apr_size_t buflen;\n\n    buflen = strlen(crlf);\n    ap_xlate_proto_to_ascii(crlf, buflen);\n    return apr_brigade_write(bb, NULL, NULL, crlf, buflen);\n}"
          }
        },
        "callers": {},
        "used_macros": {},
        "used_structs": {
          "apr_bucket_brigade": {
            "name": "apr_bucket_brigade",
            "definition": "struct apr_bucket_brigade {\n    /** The pool to associate the brigade with.  The data is not allocated out\n     *  of the pool, but a cleanup is registered with this pool.  If the \n     *  brigade is destroyed by some mechanism other than pool destruction,\n     *  the destroying function is responsible for killing the cleanup.\n     */\n    apr_pool_t *p;\n    /** The buckets in the brigade are on this list. */\n    /*\n     * The apr_bucket_list structure doesn't actually need a name tag\n     * because it has no existence independent of struct apr_bucket_brigade;\n     * the ring macros are designed so that you can leave the name tag\n     * argument empty in this situation but apparently the Windows compiler\n     * doesn't like that.\n     */\n    APR_RING_HEAD(apr_bucket_list, apr_bucket) list;\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *bucket_alloc;\n}",
            "typedef_name": null,
            "fields": {
              "p": "apr_pool_t *",
              "list": "struct apr_bucket_list",
              "bucket_alloc": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "apr_bucket": {
            "name": "apr_bucket",
            "definition": "struct apr_bucket {\n    /** Links to the rest of the brigade */\n    APR_RING_ENTRY(apr_bucket) link;\n    /** The type of bucket.  */\n    const apr_bucket_type_t *type;\n    /** The length of the data in the bucket.  This could have been implemented\n     *  with a function, but this is an optimization, because the most\n     *  common thing to do will be to get the length.  If the length is unknown,\n     *  the value of this field will be (apr_size_t)(-1).\n     */\n    apr_size_t length;\n    /** The start of the data in the bucket relative to the private base\n     *  pointer.  The vast majority of bucket types allow a fixed block of\n     *  data to be referenced by multiple buckets, each bucket pointing to\n     *  a different segment of the data.  That segment starts at base+start\n     *  and ends at base+start+length.  \n     *  If the length == (apr_size_t)(-1), then start == -1.\n     */\n    apr_off_t start;\n    /** type-dependent data hangs off this pointer */\n    void *data;\t\n    /**\n     * Pointer to function used to free the bucket. This function should\n     * always be defined and it should be consistent with the memory\n     * function used to allocate the bucket. For example, if malloc() is \n     * used to allocate the bucket, this pointer should point to free().\n     * @param e Pointer to the bucket being freed\n     */\n    void (*free)(void *e);\n    /** The freelist from which this bucket was allocated */\n    apr_bucket_alloc_t *list;\n}",
            "typedef_name": null,
            "fields": {
              "link": "struct (unnamed struct at /data/a/ykw/httpd/include/apr_buckets.h:226:5)",
              "type": "const apr_bucket_type_t *",
              "length": "apr_size_t",
              "start": "apr_off_t",
              "data": "void *",
              "free": "void (*)(void *)",
              "list": "apr_bucket_alloc_t *"
            },
            "condition": ""
          },
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "apr_table_t": {
            "name": "apr_table_t",
            "definition": "struct apr_table_t",
            "typedef_name": null,
            "fields": {},
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": []
      },
      "source_code": "AP_DECLARE(void) ap_h1_add_end_chunk(apr_bucket_brigade *b,\n                                     apr_bucket *eos,\n                                     request_rec *r,\n                                     apr_table_t *trailers)\n{\n    if (!trailers || apr_is_empty_table(trailers)) {\n        apr_bucket *e;\n\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                      \"append empty end chunk\");\n        e = apr_bucket_immortal_create(ZERO_ASCII CRLF_ASCII\n                                       CRLF_ASCII, 5, b->bucket_alloc);\n        if (eos) {\n            APR_BUCKET_INSERT_BEFORE(eos, e);\n        }\n        else {\n            APR_BRIGADE_INSERT_TAIL(b, e);\n        }\n    }\n    else {\n        apr_bucket_brigade *tmp;\n\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                      \"append end chunk with trailers\");\n        tmp = eos? apr_brigade_split_ex(b, eos, NULL) : NULL;\n        apr_brigade_write(b, NULL, NULL, ZERO_ASCII CRLF_ASCII, 3);\n        ap_h1_append_headers(b, r, trailers);\n        ap_h1_terminate_header(b);\n        if (tmp) APR_BRIGADE_CONCAT(b, tmp);\n    }\n}"
    },
    "log_name_len@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1653, column 12>": {
      "basic_info": {
        "function_id": 1673,
        "name": "log_name_len",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1653, column 12>",
        "is_definition": true,
        "start_line": 1653,
        "end_line": 1657,
        "return_type": "int",
        "parameters": [
          {
            "name": "name",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "strlen": {
            "declaration": "extern size_t strlen (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "rrl_log_error@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1659, column 13>": {
            "source_code": "static void rrl_log_error(request_rec *r, rrl_error error, const char *etoken)\n{\n    switch (error) {\n    case rrl_none:\n        break;\n    case rrl_badprotocol:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02418)\n                      \"HTTP Request Line; Unrecognized protocol '%.*s' \"\n                      \"(perhaps whitespace was injected?)\",\n                      log_name_len(etoken), etoken);\n        break;\n    case rrl_badmethod:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03445)\n                      \"HTTP Request Line; Invalid method token: '%.*s'\",\n                      log_name_len(etoken), etoken);\n        break;\n    case rrl_badwhitespace:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03447)\n                      \"HTTP Request Line; Invalid whitespace\");\n        break;\n    case rrl_excesswhitespace:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03448)\n                      \"HTTP Request Line; Excess whitespace \"\n                      \"(disallowed by HttpProtocolOptions Strict)\");\n        break;\n    case rrl_missinguri:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03446)\n                      \"HTTP Request Line; Missing URI\");\n        break;\n    case rrl_baduri:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03454)\n                      \"HTTP Request Line; URI incorrectly encoded: '%.*s'\",\n                      log_name_len(etoken), etoken);\n        break;\n    case rrl_trailingtext:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03449)\n                      \"HTTP Request Line; Extraneous text found '%.*s' \"\n                      \"(perhaps whitespace was injected?)\",\n                      log_name_len(etoken), etoken);\n        break;\n    }\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1659, column 13>"
          }
        },
        "used_macros": {
          "LOG_NAME_MAX_LEN": {
            "name": "LOG_NAME_MAX_LEN",
            "value": "80",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "#define LOG_NAME_MAX_LEN 80",
            "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c:1652",
            "condition": ""
          }
        },
        "used_structs": {},
        "used_globals": {},
        "used_typedefs": [
          "apr_size_t"
        ]
      },
      "source_code": "static int log_name_len(const char *name)\n{\n    apr_size_t len = strlen(name);\n    return (len > LOG_NAME_MAX_LEN)? LOG_NAME_MAX_LEN : (int)len;\n}"
    },
    "rrl_log_error@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1659, column 13>": {
      "basic_info": {
        "function_id": 1674,
        "name": "rrl_log_error",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1659, column 13>",
        "is_definition": true,
        "start_line": 1659,
        "end_line": 1700,
        "return_type": "void",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "error",
            "type": "rrl_error"
          },
          {
            "name": "etoken",
            "type": "const char *"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "log_name_len": {
            "declaration": "static int log_name_len(const char *name)\n{\n    apr_size_t len = strlen(name);\n    return (len > LOG_NAME_MAX_LEN)? LOG_NAME_MAX_LEN : (int)len;\n}",
            "is_external": false,
            "definition": "static int log_name_len(const char *name)\n{\n    apr_size_t len = strlen(name);\n    return (len > LOG_NAME_MAX_LEN)? LOG_NAME_MAX_LEN : (int)len;\n}"
          }
        },
        "callers": {
          "ap_h1_tokenize_request_line@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1826, column 17>": {
            "source_code": "AP_DECLARE(int) ap_h1_tokenize_request_line(\n        request_rec *r, const char *line,\n        const char **pmethod, const char **puri, const char **pprotocol)\n{\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    int strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n    rrl_error error;\n    const char *error_token;\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                  \"ap_tokenize_request_line: '%s'\", line);\n    error = tokenize_request_line(apr_pstrdup(r->pool, line), strict, pmethod,\n                                  puri, pprotocol, &error_token);\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                  \"ap_tokenize_request: error=%d, method=%s, uri=%s, protocol=%s\",\n                  error, *pmethod, *puri, *pprotocol);\n    if (error != rrl_none) {\n        rrl_log_error(r, error, error_token);\n        return 0;\n    }\n    return 1;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1826, column 17>"
          }
        },
        "used_macros": {
          "rrl_none": {
            "name": "rrl_none",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum rrl_error rrl_none = 0",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1647, column 5>",
            "condition": ""
          },
          "rrl_badprotocol": {
            "name": "rrl_badprotocol",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum rrl_error rrl_badprotocol = 1",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1647, column 15>",
            "condition": ""
          },
          "rrl_badmethod": {
            "name": "rrl_badmethod",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum rrl_error rrl_badmethod = 2",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1647, column 32>",
            "condition": ""
          },
          "rrl_badwhitespace": {
            "name": "rrl_badwhitespace",
            "value": "3",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum rrl_error rrl_badwhitespace = 3",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1647, column 47>",
            "condition": ""
          },
          "rrl_excesswhitespace": {
            "name": "rrl_excesswhitespace",
            "value": "4",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum rrl_error rrl_excesswhitespace = 4",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1647, column 66>",
            "condition": ""
          },
          "rrl_missinguri": {
            "name": "rrl_missinguri",
            "value": "5",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum rrl_error rrl_missinguri = 5",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1648, column 5>",
            "condition": ""
          },
          "rrl_baduri": {
            "name": "rrl_baduri",
            "value": "6",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum rrl_error rrl_baduri = 6",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1648, column 21>",
            "condition": ""
          },
          "rrl_trailingtext": {
            "name": "rrl_trailingtext",
            "value": "7",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum rrl_error rrl_trailingtext = 7",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1648, column 33>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "rrl_error"
        ]
      },
      "source_code": "static void rrl_log_error(request_rec *r, rrl_error error, const char *etoken)\n{\n    switch (error) {\n    case rrl_none:\n        break;\n    case rrl_badprotocol:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02418)\n                      \"HTTP Request Line; Unrecognized protocol '%.*s' \"\n                      \"(perhaps whitespace was injected?)\",\n                      log_name_len(etoken), etoken);\n        break;\n    case rrl_badmethod:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03445)\n                      \"HTTP Request Line; Invalid method token: '%.*s'\",\n                      log_name_len(etoken), etoken);\n        break;\n    case rrl_badwhitespace:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03447)\n                      \"HTTP Request Line; Invalid whitespace\");\n        break;\n    case rrl_excesswhitespace:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03448)\n                      \"HTTP Request Line; Excess whitespace \"\n                      \"(disallowed by HttpProtocolOptions Strict)\");\n        break;\n    case rrl_missinguri:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03446)\n                      \"HTTP Request Line; Missing URI\");\n        break;\n    case rrl_baduri:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03454)\n                      \"HTTP Request Line; URI incorrectly encoded: '%.*s'\",\n                      log_name_len(etoken), etoken);\n        break;\n    case rrl_trailingtext:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03449)\n                      \"HTTP Request Line; Extraneous text found '%.*s' \"\n                      \"(perhaps whitespace was injected?)\",\n                      log_name_len(etoken), etoken);\n        break;\n    }\n}"
    },
    "tokenize_request_line@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1710, column 18>": {
      "basic_info": {
        "function_id": 1675,
        "name": "tokenize_request_line",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1710, column 18>",
        "is_definition": true,
        "start_line": 1710,
        "end_line": 1824,
        "return_type": "rrl_error",
        "parameters": [
          {
            "name": "line",
            "type": "char *"
          },
          {
            "name": "strict",
            "type": "int"
          },
          {
            "name": "pmethod",
            "type": "const char **"
          },
          {
            "name": "puri",
            "type": "const char **"
          },
          {
            "name": "pprotocol",
            "type": "const char **"
          },
          {
            "name": "perror_token",
            "type": "const char **"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "__ctype_b_loc": {
            "declaration": "extern const unsigned short int **__ctype_b_loc (void)\n     __THROW __attribute__ ((__const__))",
            "is_external": true,
            "definition": null
          },
          "ap_scan_http_token": {
            "declaration": "AP_DECLARE(const char *) ap_scan_http_token(const char *ptr)",
            "is_external": true,
            "definition": null
          },
          "ap_scan_vchar_obstext": {
            "declaration": "AP_DECLARE(const char *) ap_scan_vchar_obstext(const char *ptr)",
            "is_external": true,
            "definition": null
          },
          "strpbrk": {
            "declaration": "extern char *strpbrk (const char *__s, const char *__accept)\n     __THROW __attribute_pure__ __nonnull ((1, 2))",
            "is_external": true,
            "definition": null
          },
          "strlen": {
            "declaration": "extern size_t strlen (const char *__s)\n     __THROW __attribute_pure__ __nonnull ((1))",
            "is_external": true,
            "definition": null
          }
        },
        "callers": {
          "ap_h1_tokenize_request_line@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1826, column 17>": {
            "source_code": "AP_DECLARE(int) ap_h1_tokenize_request_line(\n        request_rec *r, const char *line,\n        const char **pmethod, const char **puri, const char **pprotocol)\n{\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    int strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n    rrl_error error;\n    const char *error_token;\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                  \"ap_tokenize_request_line: '%s'\", line);\n    error = tokenize_request_line(apr_pstrdup(r->pool, line), strict, pmethod,\n                                  puri, pprotocol, &error_token);\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                  \"ap_tokenize_request: error=%d, method=%s, uri=%s, protocol=%s\",\n                  error, *pmethod, *puri, *pprotocol);\n    if (error != rrl_none) {\n        rrl_log_error(r, error, error_token);\n        return 0;\n    }\n    return 1;\n}",
            "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1826, column 17>"
          }
        },
        "used_macros": {
          "rrl_none": {
            "name": "rrl_none",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum rrl_error rrl_none = 0",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1647, column 5>",
            "condition": ""
          },
          "_ISalnum": {
            "name": "_ISalnum",
            "value": "8",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISalnum = 8",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 59, column 3>",
            "condition": ""
          },
          "_ISalpha": {
            "name": "_ISalpha",
            "value": "1024",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISalpha = 1024",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 50, column 3>",
            "condition": ""
          },
          "_IScntrl": {
            "name": "_IScntrl",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _IScntrl = 2",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 57, column 3>",
            "condition": ""
          },
          "_ISdigit": {
            "name": "_ISdigit",
            "value": "2048",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISdigit = 2048",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 51, column 3>",
            "condition": ""
          },
          "_ISlower": {
            "name": "_ISlower",
            "value": "512",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISlower = 512",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 49, column 3>",
            "condition": ""
          },
          "_ISgraph": {
            "name": "_ISgraph",
            "value": "32768",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISgraph = 32768",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 55, column 3>",
            "condition": ""
          },
          "_ISprint": {
            "name": "_ISprint",
            "value": "16384",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISprint = 16384",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 54, column 3>",
            "condition": ""
          },
          "_ISpunct": {
            "name": "_ISpunct",
            "value": "4",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISpunct = 4",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 58, column 3>",
            "condition": ""
          },
          "_ISspace": {
            "name": "_ISspace",
            "value": "8192",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum enum (unnamed at /usr/include/ctype.h:46:1) _ISspace = 8192",
            "location": "<SourceLocation file '/usr/include/ctype.h', line 53, column 3>",
            "condition": ""
          },
          "rrl_badwhitespace": {
            "name": "rrl_badwhitespace",
            "value": "3",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum rrl_error rrl_badwhitespace = 3",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1647, column 47>",
            "condition": ""
          },
          "rrl_badmethod": {
            "name": "rrl_badmethod",
            "value": "2",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum rrl_error rrl_badmethod = 2",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1647, column 32>",
            "condition": ""
          },
          "rrl_missinguri": {
            "name": "rrl_missinguri",
            "value": "5",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum rrl_error rrl_missinguri = 5",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1648, column 5>",
            "condition": ""
          },
          "rrl_excesswhitespace": {
            "name": "rrl_excesswhitespace",
            "value": "4",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum rrl_error rrl_excesswhitespace = 4",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1647, column 66>",
            "condition": ""
          },
          "rrl_baduri": {
            "name": "rrl_baduri",
            "value": "6",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum rrl_error rrl_baduri = 6",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1648, column 21>",
            "condition": ""
          },
          "rrl_badprotocol": {
            "name": "rrl_badprotocol",
            "value": "1",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum rrl_error rrl_badprotocol = 1",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1647, column 15>",
            "condition": ""
          },
          "rrl_trailingtext": {
            "name": "rrl_trailingtext",
            "value": "7",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum rrl_error rrl_trailingtext = 7",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1648, column 33>",
            "condition": ""
          }
        },
        "used_structs": {},
        "used_globals": {},
        "used_typedefs": [
          "rrl_error",
          "apr_size_t"
        ]
      },
      "source_code": "static rrl_error tokenize_request_line(\n        char *line, int strict,\n        const char **pmethod, const char **puri, const char **pprotocol,\n        const char **perror_token)\n{\n    char *method, *protocol, *uri, *ll;\n    rrl_error e = rrl_none;\n    char *etoken = NULL;\n    apr_size_t len = 0;\n\n    method = line;\n    /* If there is whitespace before a method, skip it and mark in error */\n    if (apr_isspace(*method)) {\n        RRL_ERROR(e, etoken, rrl_badwhitespace, method);\n        for ( ; apr_isspace(*method); ++method)\n            ;\n    }\n\n    /* Scan the method up to the next whitespace, ensure it contains only\n     * valid http-token characters, otherwise mark in error\n     */\n    if (strict) {\n        ll = (char*) ap_scan_http_token(method);\n    }\n    else {\n        ll = (char*) ap_scan_vchar_obstext(method);\n    }\n\n    if ((ll == method) || (*ll && !apr_isspace(*ll))) {\n        RRL_ERROR(e, etoken, rrl_badmethod, ll);\n        ll = strpbrk(ll, \"\\t\\n\\v\\f\\r \");\n    }\n\n    /* Verify method terminated with a single SP, or mark as specific error */\n    if (!ll) {\n        RRL_ERROR(e, etoken, rrl_missinguri, NULL);\n        protocol = uri = \"\";\n        goto done;\n    }\n    else if (strict && ll[0] && apr_isspace(ll[1])) {\n        RRL_ERROR(e, etoken, rrl_excesswhitespace, ll);\n    }\n\n    /* Advance uri pointer over leading whitespace, NUL terminate the method\n     * If non-SP whitespace is encountered, mark as specific error\n     */\n    for (uri = ll; apr_isspace(*uri); ++uri)\n        if (*uri != ' ')\n            RRL_ERROR(e, etoken, rrl_badwhitespace, uri);\n    *ll = '\\0';\n\n    if (!*uri)\n        RRL_ERROR(e, etoken, rrl_missinguri, NULL);\n\n    /* Scan the URI up to the next whitespace, ensure it contains no raw\n     * control characters, otherwise mark in error\n     */\n    ll = (char*) ap_scan_vchar_obstext(uri);\n    if (ll == uri || (*ll && !apr_isspace(*ll))) {\n        RRL_ERROR(e, etoken, rrl_baduri, ll);\n        ll = strpbrk(ll, \"\\t\\n\\v\\f\\r \");\n    }\n\n    /* Verify URI terminated with a single SP, or mark as specific error */\n    if (!ll) {\n        protocol = \"\";\n        goto done;\n    }\n    else if (strict && ll[0] && apr_isspace(ll[1])) {\n        RRL_ERROR(e, etoken, rrl_excesswhitespace, ll);\n    }\n\n    /* Advance protocol pointer over leading whitespace, NUL terminate the uri\n     * If non-SP whitespace is encountered, mark as specific error\n     */\n    for (protocol = ll; apr_isspace(*protocol); ++protocol)\n        if (*protocol != ' ')\n            RRL_ERROR(e, etoken, rrl_badwhitespace, protocol);\n    *ll = '\\0';\n\n    /* Scan the protocol up to the next whitespace, validation comes later */\n    if (!(ll = (char*) ap_scan_vchar_obstext(protocol))) {\n        len = strlen(protocol);\n        goto done;\n    }\n    len = ll - protocol;\n\n    /* Advance over trailing whitespace, if found mark in error,\n     * determine if trailing text is found, unconditionally mark in error,\n     * finally NUL terminate the protocol string\n     */\n    if (*ll && !apr_isspace(*ll)) {\n        RRL_ERROR(e, etoken, rrl_badprotocol, ll);\n    }\n    else if (strict && *ll) {\n        RRL_ERROR(e, etoken, rrl_excesswhitespace, ll);\n    }\n    else {\n        for ( ; apr_isspace(*ll); ++ll)\n            if (*ll != ' ') {\n                RRL_ERROR(e, etoken, rrl_badwhitespace, ll);\n                break;\n            }\n        if (*ll)\n            RRL_ERROR(e, etoken, rrl_trailingtext, ll);\n    }\n    *((char *)protocol + len) = '\\0';\n\ndone:\n    *pmethod = method;\n    *puri = uri;\n    *pprotocol = protocol;\n    *perror_token = etoken;\n    return e;\n}"
    },
    "ap_h1_tokenize_request_line@<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1826, column 17>": {
      "basic_info": {
        "function_id": 1676,
        "name": "ap_h1_tokenize_request_line",
        "file": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c",
        "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1826, column 17>",
        "is_definition": true,
        "start_line": 1826,
        "end_line": 1847,
        "return_type": "int",
        "parameters": [
          {
            "name": "r",
            "type": "request_rec *"
          },
          {
            "name": "line",
            "type": "const char *"
          },
          {
            "name": "pmethod",
            "type": "const char **"
          },
          {
            "name": "puri",
            "type": "const char **"
          },
          {
            "name": "pprotocol",
            "type": "const char **"
          }
        ],
        "condition": ""
      },
      "dependencies": {
        "called_functions": {
          "ap_log_rerror_": {
            "declaration": "AP_DECLARE(void) ap_log_rerror_(const char *file, int line, int module_index,\n                                int level, apr_status_t status,\n                                const request_rec *r, const char *fmt, ...)\n                                __attribute__((format(printf,7,8)))",
            "is_external": true,
            "definition": null
          },
          "tokenize_request_line": {
            "declaration": "static rrl_error tokenize_request_line(\n        char *line, int strict,\n        const char **pmethod, const char **puri, const char **pprotocol,\n        const char **perror_token)\n{\n    char *method, *protocol, *uri, *ll;\n    rrl_error e = rrl_none;\n    char *etoken = NULL;\n    apr_size_t len = 0;\n\n    method = line;\n    /* If there is whitespace before a method, skip it and mark in error */\n    if (apr_isspace(*method)) {\n        RRL_ERROR(e, etoken, rrl_badwhitespace, method);\n        for ( ; apr_isspace(*method); ++method)\n            ;\n    }\n\n    /* Scan the method up to the next whitespace, ensure it contains only\n     * valid http-token characters, otherwise mark in error\n     */\n    if (strict) {\n        ll = (char*) ap_scan_http_token(method);\n    }\n    else {\n        ll = (char*) ap_scan_vchar_obstext(method);\n    }\n\n    if ((ll == method) || (*ll && !apr_isspace(*ll))) {\n        RRL_ERROR(e, etoken, rrl_badmethod, ll);\n        ll = strpbrk(ll, \"\\t\\n\\v\\f\\r \");\n    }\n\n    /* Verify method terminated with a single SP, or mark as specific error */\n    if (!ll) {\n        RRL_ERROR(e, etoken, rrl_missinguri, NULL);\n        protocol = uri = \"\";\n        goto done;\n    }\n    else if (strict && ll[0] && apr_isspace(ll[1])) {\n        RRL_ERROR(e, etoken, rrl_excesswhitespace, ll);\n    }\n\n    /* Advance uri pointer over leading whitespace, NUL terminate the method\n     * If non-SP whitespace is encountered, mark as specific error\n     */\n    for (uri = ll; apr_isspace(*uri); ++uri)\n        if (*uri != ' ')\n            RRL_ERROR(e, etoken, rrl_badwhitespace, uri);\n    *ll = '\\0';\n\n    if (!*uri)\n        RRL_ERROR(e, etoken, rrl_missinguri, NULL);\n\n    /* Scan the URI up to the next whitespace, ensure it contains no raw\n     * control characters, otherwise mark in error\n     */\n    ll = (char*) ap_scan_vchar_obstext(uri);\n    if (ll == uri || (*ll && !apr_isspace(*ll))) {\n        RRL_ERROR(e, etoken, rrl_baduri, ll);\n        ll = strpbrk(ll, \"\\t\\n\\v\\f\\r \");\n    }\n\n    /* Verify URI terminated with a single SP, or mark as specific error */\n    if (!ll) {\n        protocol = \"\";\n        goto done;\n    }\n    else if (strict && ll[0] && apr_isspace(ll[1])) {\n        RRL_ERROR(e, etoken, rrl_excesswhitespace, ll);\n    }\n\n    /* Advance protocol pointer over leading whitespace, NUL terminate the uri\n     * If non-SP whitespace is encountered, mark as specific error\n     */\n    for (protocol = ll; apr_isspace(*protocol); ++protocol)\n        if (*protocol != ' ')\n            RRL_ERROR(e, etoken, rrl_badwhitespace, protocol);\n    *ll = '\\0';\n\n    /* Scan the protocol up to the next whitespace, validation comes later */\n    if (!(ll = (char*) ap_scan_vchar_obstext(protocol))) {\n        len = strlen(protocol);\n        goto done;\n    }\n    len = ll - protocol;\n\n    /* Advance over trailing whitespace, if found mark in error,\n     * determine if trailing text is found, unconditionally mark in error,\n     * finally NUL terminate the protocol string\n     */\n    if (*ll && !apr_isspace(*ll)) {\n        RRL_ERROR(e, etoken, rrl_badprotocol, ll);\n    }\n    else if (strict && *ll) {\n        RRL_ERROR(e, etoken, rrl_excesswhitespace, ll);\n    }\n    else {\n        for ( ; apr_isspace(*ll); ++ll)\n            if (*ll != ' ') {\n                RRL_ERROR(e, etoken, rrl_badwhitespace, ll);\n                break;\n            }\n        if (*ll)\n            RRL_ERROR(e, etoken, rrl_trailingtext, ll);\n    }\n    *((char *)protocol + len) = '\\0';\n\ndone:\n    *pmethod = method;\n    *puri = uri;\n    *pprotocol = protocol;\n    *perror_token = etoken;\n    return e;\n}",
            "is_external": false,
            "definition": "static rrl_error tokenize_request_line(\n        char *line, int strict,\n        const char **pmethod, const char **puri, const char **pprotocol,\n        const char **perror_token)\n{\n    char *method, *protocol, *uri, *ll;\n    rrl_error e = rrl_none;\n    char *etoken = NULL;\n    apr_size_t len = 0;\n\n    method = line;\n    /* If there is whitespace before a method, skip it and mark in error */\n    if (apr_isspace(*method)) {\n        RRL_ERROR(e, etoken, rrl_badwhitespace, method);\n        for ( ; apr_isspace(*method); ++method)\n            ;\n    }\n\n    /* Scan the method up to the next whitespace, ensure it contains only\n     * valid http-token characters, otherwise mark in error\n     */\n    if (strict) {\n        ll = (char*) ap_scan_http_token(method);\n    }\n    else {\n        ll = (char*) ap_scan_vchar_obstext(method);\n    }\n\n    if ((ll == method) || (*ll && !apr_isspace(*ll))) {\n        RRL_ERROR(e, etoken, rrl_badmethod, ll);\n        ll = strpbrk(ll, \"\\t\\n\\v\\f\\r \");\n    }\n\n    /* Verify method terminated with a single SP, or mark as specific error */\n    if (!ll) {\n        RRL_ERROR(e, etoken, rrl_missinguri, NULL);\n        protocol = uri = \"\";\n        goto done;\n    }\n    else if (strict && ll[0] && apr_isspace(ll[1])) {\n        RRL_ERROR(e, etoken, rrl_excesswhitespace, ll);\n    }\n\n    /* Advance uri pointer over leading whitespace, NUL terminate the method\n     * If non-SP whitespace is encountered, mark as specific error\n     */\n    for (uri = ll; apr_isspace(*uri); ++uri)\n        if (*uri != ' ')\n            RRL_ERROR(e, etoken, rrl_badwhitespace, uri);\n    *ll = '\\0';\n\n    if (!*uri)\n        RRL_ERROR(e, etoken, rrl_missinguri, NULL);\n\n    /* Scan the URI up to the next whitespace, ensure it contains no raw\n     * control characters, otherwise mark in error\n     */\n    ll = (char*) ap_scan_vchar_obstext(uri);\n    if (ll == uri || (*ll && !apr_isspace(*ll))) {\n        RRL_ERROR(e, etoken, rrl_baduri, ll);\n        ll = strpbrk(ll, \"\\t\\n\\v\\f\\r \");\n    }\n\n    /* Verify URI terminated with a single SP, or mark as specific error */\n    if (!ll) {\n        protocol = \"\";\n        goto done;\n    }\n    else if (strict && ll[0] && apr_isspace(ll[1])) {\n        RRL_ERROR(e, etoken, rrl_excesswhitespace, ll);\n    }\n\n    /* Advance protocol pointer over leading whitespace, NUL terminate the uri\n     * If non-SP whitespace is encountered, mark as specific error\n     */\n    for (protocol = ll; apr_isspace(*protocol); ++protocol)\n        if (*protocol != ' ')\n            RRL_ERROR(e, etoken, rrl_badwhitespace, protocol);\n    *ll = '\\0';\n\n    /* Scan the protocol up to the next whitespace, validation comes later */\n    if (!(ll = (char*) ap_scan_vchar_obstext(protocol))) {\n        len = strlen(protocol);\n        goto done;\n    }\n    len = ll - protocol;\n\n    /* Advance over trailing whitespace, if found mark in error,\n     * determine if trailing text is found, unconditionally mark in error,\n     * finally NUL terminate the protocol string\n     */\n    if (*ll && !apr_isspace(*ll)) {\n        RRL_ERROR(e, etoken, rrl_badprotocol, ll);\n    }\n    else if (strict && *ll) {\n        RRL_ERROR(e, etoken, rrl_excesswhitespace, ll);\n    }\n    else {\n        for ( ; apr_isspace(*ll); ++ll)\n            if (*ll != ' ') {\n                RRL_ERROR(e, etoken, rrl_badwhitespace, ll);\n                break;\n            }\n        if (*ll)\n            RRL_ERROR(e, etoken, rrl_trailingtext, ll);\n    }\n    *((char *)protocol + len) = '\\0';\n\ndone:\n    *pmethod = method;\n    *puri = uri;\n    *pprotocol = protocol;\n    *perror_token = etoken;\n    return e;\n}"
          },
          "apr_pstrdup": {
            "declaration": "APR_DECLARE(char *) apr_pstrdup(apr_pool_t *p, const char *s)",
            "is_external": true,
            "definition": null
          },
          "rrl_log_error": {
            "declaration": "static void rrl_log_error(request_rec *r, rrl_error error, const char *etoken)\n{\n    switch (error) {\n    case rrl_none:\n        break;\n    case rrl_badprotocol:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02418)\n                      \"HTTP Request Line; Unrecognized protocol '%.*s' \"\n                      \"(perhaps whitespace was injected?)\",\n                      log_name_len(etoken), etoken);\n        break;\n    case rrl_badmethod:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03445)\n                      \"HTTP Request Line; Invalid method token: '%.*s'\",\n                      log_name_len(etoken), etoken);\n        break;\n    case rrl_badwhitespace:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03447)\n                      \"HTTP Request Line; Invalid whitespace\");\n        break;\n    case rrl_excesswhitespace:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03448)\n                      \"HTTP Request Line; Excess whitespace \"\n                      \"(disallowed by HttpProtocolOptions Strict)\");\n        break;\n    case rrl_missinguri:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03446)\n                      \"HTTP Request Line; Missing URI\");\n        break;\n    case rrl_baduri:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03454)\n                      \"HTTP Request Line; URI incorrectly encoded: '%.*s'\",\n                      log_name_len(etoken), etoken);\n        break;\n    case rrl_trailingtext:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03449)\n                      \"HTTP Request Line; Extraneous text found '%.*s' \"\n                      \"(perhaps whitespace was injected?)\",\n                      log_name_len(etoken), etoken);\n        break;\n    }\n}",
            "is_external": false,
            "definition": "static void rrl_log_error(request_rec *r, rrl_error error, const char *etoken)\n{\n    switch (error) {\n    case rrl_none:\n        break;\n    case rrl_badprotocol:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02418)\n                      \"HTTP Request Line; Unrecognized protocol '%.*s' \"\n                      \"(perhaps whitespace was injected?)\",\n                      log_name_len(etoken), etoken);\n        break;\n    case rrl_badmethod:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03445)\n                      \"HTTP Request Line; Invalid method token: '%.*s'\",\n                      log_name_len(etoken), etoken);\n        break;\n    case rrl_badwhitespace:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03447)\n                      \"HTTP Request Line; Invalid whitespace\");\n        break;\n    case rrl_excesswhitespace:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03448)\n                      \"HTTP Request Line; Excess whitespace \"\n                      \"(disallowed by HttpProtocolOptions Strict)\");\n        break;\n    case rrl_missinguri:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03446)\n                      \"HTTP Request Line; Missing URI\");\n        break;\n    case rrl_baduri:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03454)\n                      \"HTTP Request Line; URI incorrectly encoded: '%.*s'\",\n                      log_name_len(etoken), etoken);\n        break;\n    case rrl_trailingtext:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03449)\n                      \"HTTP Request Line; Extraneous text found '%.*s' \"\n                      \"(perhaps whitespace was injected?)\",\n                      log_name_len(etoken), etoken);\n        break;\n    }\n}"
          }
        },
        "callers": {},
        "used_macros": {
          "rrl_none": {
            "name": "rrl_none",
            "value": "0",
            "is_constant": true,
            "is_function_like": false,
            "parameters": [],
            "definition": "enum rrl_error rrl_none = 0",
            "location": "<SourceLocation file '/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c', line 1647, column 5>",
            "condition": ""
          }
        },
        "used_structs": {
          "request_rec": {
            "name": "request_rec",
            "definition": "struct request_rec {\n    /** The pool associated with the request */\n    apr_pool_t *pool;\n    /** The connection to the client */\n    conn_rec *connection;\n    /** The virtual host for this request */\n    server_rec *server;\n\n    /** Pointer to the redirected request if this is an external redirect */\n    request_rec *next;\n    /** Pointer to the previous request if this is an internal redirect */\n    request_rec *prev;\n\n    /** Pointer to the main request if this is a sub-request\n     * (see http_request.h) */\n    request_rec *main;\n\n    /* Info about the request itself... we begin with stuff that only\n     * protocol.c should ever touch...\n     */\n    /** First line of request */\n    char *the_request;\n    /** HTTP/0.9, \"simple\" request (e.g. GET /foo\\n w/no headers) */\n    int assbackwards;\n    /** A proxy request (calculated during post_read_request/translate_name)\n     *  possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,\n     *                  PROXYREQ_RESPONSE\n     */\n    int proxyreq;\n    /** HEAD request, as opposed to GET */\n    int header_only;\n    /** Protocol version number of protocol; 1.1 = 1001 */\n    int proto_num;\n    /** Protocol string, as given to us, or HTTP/0.9 */\n    char *protocol;\n    /** Host, as set by full URI or Host: header.\n     *  For literal IPv6 addresses, this does NOT include the surrounding [ ]\n     */\n    const char *hostname;\n\n    /** Time when the request started */\n    apr_time_t request_time;\n\n    /** Status line, if set by script */\n    const char *status_line;\n    /** Status line */\n    int status;\n\n    /* Request method, two ways; also, protocol, etc..  Outside of protocol.c,\n     * look, but don't touch.\n     */\n\n    /** M_GET, M_POST, etc. */\n    int method_number;\n    /** Request method (eg. GET, HEAD, POST, etc.) */\n    const char *method;\n\n    /**\n     *  'allowed' is a bitvector of the allowed methods.\n     *\n     *  A handler must ensure that the request method is one that\n     *  it is capable of handling.  Generally modules should DECLINE\n     *  any request methods they do not handle.  Prior to aborting the\n     *  handler like this the handler should set r->allowed to the list\n     *  of methods that it is willing to handle.  This bitvector is used\n     *  to construct the \"Allow:\" header required for OPTIONS requests,\n     *  and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.\n     *\n     *  Since the default_handler deals with OPTIONS, all modules can\n     *  usually decline to deal with OPTIONS.  TRACE is always allowed,\n     *  modules don't need to set it explicitly.\n     *\n     *  Since the default_handler will always handle a GET, a\n     *  module which does *not* implement GET should probably return\n     *  HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET\n     *  handler can't be installed by mod_actions.\n     */\n    apr_int64_t allowed;\n    /** Array of extension methods */\n    apr_array_header_t *allowed_xmethods;\n    /** List of allowed methods */\n    ap_method_list_t *allowed_methods;\n\n    /** byte count in stream is for body */\n    apr_off_t sent_bodyct;\n    /** body byte count, for easy access */\n    apr_off_t bytes_sent;\n    /** Last modified time of the requested resource */\n    apr_time_t mtime;\n\n    /* HTTP/1.1 connection-level features */\n\n    /** The Range: header */\n    const char *range;\n    /** The \"real\" content length */\n    apr_off_t clength;\n    /** sending chunked transfer-coding */\n    int chunked;\n\n    /** Method for reading the request body\n     * (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,\n     *  REQUEST_CHUNKED_DECHUNK, etc...) */\n    int read_body;\n    /** reading chunked transfer-coding */\n    int read_chunked;\n    /** is client waiting for a 100 response? */\n    unsigned expecting_100;\n    /** The optional kept body of the request. */\n    apr_bucket_brigade *kept_body;\n    /** For ap_body_to_table(): parsed body */\n    /* XXX: ap_body_to_table has been removed. Remove body_table too or\n     * XXX: keep it to reintroduce ap_body_to_table without major bump? */\n    apr_table_t *body_table;\n    /** Remaining bytes left to read from the request body */\n    apr_off_t remaining;\n    /** Number of bytes that have been read  from the request body */\n    apr_off_t read_length;\n\n    /* MIME header environments, in and out.  Also, an array containing\n     * environment variables to be passed to subprocesses, so people can\n     * write modules to add to that environment.\n     *\n     * The difference between headers_out and err_headers_out is that the\n     * latter are printed even on error, and persist across internal redirects\n     * (so the headers printed for ErrorDocument handlers will have them).\n     *\n     * The 'notes' apr_table_t is for notes from one module to another, with no\n     * other set purpose in mind...\n     */\n\n    /** MIME header environment from the request */\n    apr_table_t *headers_in;\n    /** MIME header environment for the response */\n    apr_table_t *headers_out;\n    /** MIME header environment for the response, printed even on errors and\n     * persist across internal redirects */\n    apr_table_t *err_headers_out;\n    /** Array of environment variables to be used for sub processes */\n    apr_table_t *subprocess_env;\n    /** Notes from one module to another */\n    apr_table_t *notes;\n\n    /* content_type, handler, content_encoding, and all content_languages\n     * MUST be lowercased strings.  They may be pointers to static strings;\n     * they should not be modified in place.\n     */\n    /** The content-type for the current request */\n    const char *content_type;   /* Break these out --- we dispatch on 'em */\n    /** The handler string that we use to call a handler function */\n    const char *handler;        /* What we *really* dispatch on */\n\n    /** How to encode the data */\n    const char *content_encoding;\n    /** Array of strings representing the content languages */\n    apr_array_header_t *content_languages;\n\n    /** variant list validator (if negotiated) */\n    char *vlist_validator;\n\n    /** If an authentication check was made, this gets set to the user name. */\n    char *user;\n    /** If an authentication check was made, this gets set to the auth type. */\n    char *ap_auth_type;\n\n    /* What object is being requested (either directly, or via include\n     * or content-negotiation mapping).\n     */\n\n    /** The URI without any parsing performed */\n    char *unparsed_uri;\n    /** The path portion of the URI, or \"/\" if no path provided */\n    char *uri;\n    /** The filename on disk corresponding to this response */\n    char *filename;\n    /** The true filename stored in the filesystem, as in the true alpha case\n     *  and alias correction, e.g. \"Image.jpeg\" not \"IMAGE$1.JPE\" on Windows.\n     *  The core map_to_storage canonicalizes r->filename when they mismatch */\n    char *canonical_filename;\n    /** The PATH_INFO extracted from this request */\n    char *path_info;\n    /** The QUERY_ARGS extracted from this request */\n    char *args;\n\n    /**\n     * Flag for the handler to accept or reject path_info on\n     * the current request.  All modules should respect the\n     * AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO\n     * values, while AP_REQ_DEFAULT_PATH_INFO indicates they\n     * may follow existing conventions.  This is set to the\n     * user's preference upon HOOK_VERY_FIRST of the fixups.\n     */\n    int used_path_info;\n\n    /** A flag to determine if the eos bucket has been sent yet */\n    int eos_sent;\n\n    /* Various other config info which may change with .htaccess files\n     * These are config vectors, with one void* pointer for each module\n     * (the thing pointed to being the module's business).\n     */\n\n    /** Options set in config files, etc. */\n    struct ap_conf_vector_t *per_dir_config;\n    /** Notes on *this* request */\n    struct ap_conf_vector_t *request_config;\n\n    /** Optional request log level configuration. Will usually point\n     *  to a server or per_dir config, i.e. must be copied before\n     *  modifying */\n    const struct ap_logconf *log;\n\n    /** Id to identify request in access and error log. Set when the first\n     *  error log entry for this request is generated.\n     */\n    const char *log_id;\n\n    /**\n     * A linked list of the .htaccess configuration directives\n     * accessed by this request.\n     * N.B. always add to the head of the list, _never_ to the end.\n     * that way, a sub request's list can (temporarily) point to a parent's list\n     */\n    const struct htaccess_result *htaccess;\n\n    /** A list of output filters to be used for this request */\n    struct ap_filter_t *output_filters;\n    /** A list of input filters to be used for this request */\n    struct ap_filter_t *input_filters;\n\n    /** A list of protocol level output filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_output_filters;\n    /** A list of protocol level input filters to be used for this\n     *  request */\n    struct ap_filter_t *proto_input_filters;\n\n    /** This response can not be cached */\n    int no_cache;\n    /** There is no local copy of this response */\n    int no_local_copy;\n\n    /** Mutex protect callbacks registered with ap_mpm_register_timed_callback\n     * from being run before the original handler finishes running\n     */\n    apr_thread_mutex_t *invoke_mtx;\n\n    /** A struct containing the components of URI */\n    apr_uri_t parsed_uri;\n    /**  finfo.protection (st_mode) set to zero if no such file */\n    apr_finfo_t finfo;\n\n    /** remote address information from conn_rec, can be overridden if\n     * necessary by a module.\n     * This is the address that originated the request.\n     */\n    apr_sockaddr_t *useragent_addr;\n    char *useragent_ip;\n\n    /** MIME trailer environment from the request */\n    apr_table_t *trailers_in;\n    /** MIME trailer environment from the response */\n    apr_table_t *trailers_out;\n\n    /** Originator's DNS name, if known.  NULL if DNS hasn't been checked,\n     *  \"\" if it has and no address was found.  N.B. Only access this though\n     *  ap_get_useragent_host() */\n    char *useragent_host;\n    /** have we done double-reverse DNS? -1 yes/failure, 0 not yet,\n     *  1 yes/success\n     */\n    int double_reverse;\n    /** Request flags associated with this request. Use\n     * AP_REQUEST_GET_FLAGS() and AP_REQUEST_SET_FLAGS() to access\n     * the elements of this field.\n     */\n    ap_request_bnotes_t bnotes;\n}",
            "typedef_name": null,
            "fields": {
              "pool": "apr_pool_t *",
              "connection": "conn_rec *",
              "server": "server_rec *",
              "next": "request_rec *",
              "prev": "request_rec *",
              "main": "request_rec *",
              "the_request": "char *",
              "assbackwards": "int",
              "proxyreq": "int",
              "header_only": "int",
              "proto_num": "int",
              "protocol": "char *",
              "hostname": "const char *",
              "request_time": "apr_time_t",
              "status_line": "const char *",
              "status": "int",
              "method_number": "int",
              "method": "const char *",
              "allowed": "apr_int64_t",
              "allowed_xmethods": "apr_array_header_t *",
              "allowed_methods": "ap_method_list_t *",
              "sent_bodyct": "apr_off_t",
              "bytes_sent": "apr_off_t",
              "mtime": "apr_time_t",
              "range": "const char *",
              "clength": "apr_off_t",
              "chunked": "int",
              "read_body": "int",
              "read_chunked": "int",
              "expecting_100": "unsigned int",
              "kept_body": "apr_bucket_brigade *",
              "body_table": "apr_table_t *",
              "remaining": "apr_off_t",
              "read_length": "apr_off_t",
              "headers_in": "apr_table_t *",
              "headers_out": "apr_table_t *",
              "err_headers_out": "apr_table_t *",
              "subprocess_env": "apr_table_t *",
              "notes": "apr_table_t *",
              "content_type": "const char *",
              "handler": "const char *",
              "content_encoding": "const char *",
              "content_languages": "apr_array_header_t *",
              "vlist_validator": "char *",
              "user": "char *",
              "ap_auth_type": "char *",
              "unparsed_uri": "char *",
              "uri": "char *",
              "filename": "char *",
              "canonical_filename": "char *",
              "path_info": "char *",
              "args": "char *",
              "used_path_info": "int",
              "eos_sent": "int",
              "per_dir_config": "struct ap_conf_vector_t *",
              "request_config": "struct ap_conf_vector_t *",
              "log": "const struct ap_logconf *",
              "log_id": "const char *",
              "htaccess": "const struct htaccess_result *",
              "output_filters": "struct ap_filter_t *",
              "input_filters": "struct ap_filter_t *",
              "proto_output_filters": "struct ap_filter_t *",
              "proto_input_filters": "struct ap_filter_t *",
              "no_cache": "int",
              "no_local_copy": "int",
              "invoke_mtx": "apr_thread_mutex_t *",
              "parsed_uri": "apr_uri_t",
              "finfo": "apr_finfo_t",
              "useragent_addr": "apr_sockaddr_t *",
              "useragent_ip": "char *",
              "trailers_in": "apr_table_t *",
              "trailers_out": "apr_table_t *",
              "useragent_host": "char *",
              "double_reverse": "int",
              "bnotes": "ap_request_bnotes_t"
            },
            "condition": ""
          },
          "core_server_config": {
            "name": "core_server_config",
            "definition": "struct {\n\n    char *gprof_dir;\n\n    /* Name translations --- we want the core to be able to do *something*\n     * so it's at least a minimally functional web server on its own (and\n     * can be tested that way).  But let's keep it to the bare minimum:\n     */\n    const char *ap_document_root;\n\n    /* Access control */\n\n    char *access_name;\n    apr_array_header_t *sec_dir;\n    apr_array_header_t *sec_url;\n\n    /* recursion backstopper */\n    int redirect_limit; /* maximum number of internal redirects */\n    int subreq_limit;   /* maximum nesting level of subrequests */\n\n    const char *protocol;\n    apr_table_t *accf_map;\n\n    /* array of ap_errorlog_format_item for error log format string */\n    apr_array_header_t *error_log_format;\n    /*\n     * two arrays of arrays of ap_errorlog_format_item for additional information\n     * logged to the error log once per connection/request\n     */\n    apr_array_header_t *error_log_conn;\n    apr_array_header_t *error_log_req;\n\n    /* TRACE control */\n#define AP_TRACE_UNSET    -1\n#define AP_TRACE_DISABLE   0\n#define AP_TRACE_ENABLE    1\n#define AP_TRACE_EXTENDED  2\n    int trace_enable;\n#define AP_MERGE_TRAILERS_UNSET    0\n#define AP_MERGE_TRAILERS_ENABLE   1\n#define AP_MERGE_TRAILERS_DISABLE  2\n    int merge_trailers;\n\n    apr_array_header_t *protocols;\n    int protocols_honor_order;\n\n#define AP_HTTP09_UNSET   0\n#define AP_HTTP09_ENABLE  1\n#define AP_HTTP09_DISABLE 2\n    char http09_enable;\n\n#define AP_HTTP_CONFORMANCE_UNSET     0\n#define AP_HTTP_CONFORMANCE_UNSAFE    1\n#define AP_HTTP_CONFORMANCE_STRICT    2\n    char http_conformance;\n\n#define AP_HTTP_METHODS_UNSET         0\n#define AP_HTTP_METHODS_LENIENT       1\n#define AP_HTTP_METHODS_REGISTERED    2\n    char http_methods;\n    unsigned int merge_slashes;\n \n    apr_size_t   flush_max_threshold;\n    apr_int32_t  flush_max_pipelined;\n    unsigned int strict_host_check;\n#ifdef WIN32\n    apr_array_header_t *unc_list;\n#endif\n}",
            "typedef_name": null,
            "fields": {
              "gprof_dir": "char *",
              "ap_document_root": "const char *",
              "access_name": "char *",
              "sec_dir": "apr_array_header_t *",
              "sec_url": "apr_array_header_t *",
              "redirect_limit": "int",
              "subreq_limit": "int",
              "protocol": "const char *",
              "accf_map": "apr_table_t *",
              "error_log_format": "apr_array_header_t *",
              "error_log_conn": "apr_array_header_t *",
              "error_log_req": "apr_array_header_t *",
              "trace_enable": "int",
              "merge_trailers": "int",
              "protocols": "apr_array_header_t *",
              "protocols_honor_order": "int",
              "http09_enable": "char",
              "http_conformance": "char",
              "http_methods": "char",
              "merge_slashes": "unsigned int",
              "flush_max_threshold": "apr_size_t",
              "flush_max_pipelined": "apr_int32_t",
              "strict_host_check": "unsigned int"
            },
            "condition": ""
          }
        },
        "used_globals": {
          "aplog_module_index": {
            "name": "aplog_module_index",
            "type": "int *const",
            "is_extern": false,
            "is_static": true,
            "definition": "APLOG_USE_MODULE(http)",
            "initializer": null,
            "full_definition": "APLOG_USE_MODULE(http)",
            "used_macros": {},
            "condition": ""
          }
        },
        "used_typedefs": [
          "rrl_error"
        ]
      },
      "source_code": "AP_DECLARE(int) ap_h1_tokenize_request_line(\n        request_rec *r, const char *line,\n        const char **pmethod, const char **puri, const char **pprotocol)\n{\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    int strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\n    rrl_error error;\n    const char *error_token;\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                  \"ap_tokenize_request_line: '%s'\", line);\n    error = tokenize_request_line(apr_pstrdup(r->pool, line), strict, pmethod,\n                                  puri, pprotocol, &error_token);\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,\n                  \"ap_tokenize_request: error=%d, method=%s, uri=%s, protocol=%s\",\n                  error, *pmethod, *puri, *pprotocol);\n    if (error != rrl_none) {\n        rrl_log_error(r, error, error_token);\n        return 0;\n    }\n    return 1;\n}"
    }
  },
  "structs": {},
  "globals": {},
  "macros": {
    "APR_WANT_STDIO": {
      "name": "APR_WANT_STDIO",
      "value": "/* for sscanf */",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c:30",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define APR_WANT_STDIO          /* for sscanf */",
      "condition": ""
    },
    "APR_WANT_STRFUNC": {
      "name": "APR_WANT_STRFUNC",
      "value": "",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c:31",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define APR_WANT_STRFUNC",
      "condition": ""
    },
    "APR_WANT_MEMFUNC": {
      "name": "APR_WANT_MEMFUNC",
      "value": "",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c:32",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define APR_WANT_MEMFUNC",
      "condition": ""
    },
    "AP_DEFAULT_MAX_RANGES": {
      "name": "AP_DEFAULT_MAX_RANGES",
      "value": "200",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c:59",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define AP_DEFAULT_MAX_RANGES 200",
      "condition": "#ifndef AP_DEFAULT_MAX_RANGES"
    },
    "AP_DEFAULT_MAX_OVERLAPS": {
      "name": "AP_DEFAULT_MAX_OVERLAPS",
      "value": "20",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c:62",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define AP_DEFAULT_MAX_OVERLAPS 20",
      "condition": "#ifndef AP_DEFAULT_MAX_OVERLAPS"
    },
    "AP_DEFAULT_MAX_REVERSALS": {
      "name": "AP_DEFAULT_MAX_REVERSALS",
      "value": "20",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c:65",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define AP_DEFAULT_MAX_REVERSALS 20",
      "condition": "#ifndef AP_DEFAULT_MAX_REVERSALS"
    },
    "MAX_PREALLOC_RANGES": {
      "name": "MAX_PREALLOC_RANGES",
      "value": "100",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c:68",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define MAX_PREALLOC_RANGES 100",
      "condition": ""
    },
    "BYTERANGE_FMT": {
      "name": "BYTERANGE_FMT",
      "value": "\"%\" APR_OFF_T_FMT \"-%\" APR_OFF_T_FMT \"/%\" APR_OFF_T_FMT",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/byterange_filter.c:286",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define BYTERANGE_FMT \"%\" APR_OFF_T_FMT \"-%\" APR_OFF_T_FMT \"/%\" APR_OFF_T_FMT",
      "condition": ""
    },
    "MULTIMATCH_UNSET": {
      "name": "MULTIMATCH_UNSET",
      "value": "0",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:71",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define MULTIMATCH_UNSET      0",
      "condition": ""
    },
    "MULTIMATCH_ANY": {
      "name": "MULTIMATCH_ANY",
      "value": "1",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:72",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define MULTIMATCH_ANY        1",
      "condition": ""
    },
    "MULTIMATCH_NEGOTIATED": {
      "name": "MULTIMATCH_NEGOTIATED",
      "value": "2",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:73",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define MULTIMATCH_NEGOTIATED 2",
      "condition": ""
    },
    "MULTIMATCH_HANDLERS": {
      "name": "MULTIMATCH_HANDLERS",
      "value": "4",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:74",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define MULTIMATCH_HANDLERS   4",
      "condition": ""
    },
    "MULTIMATCH_FILTERS": {
      "name": "MULTIMATCH_FILTERS",
      "value": "8",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/mod_mime.c:75",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define MULTIMATCH_FILTERS    8",
      "condition": ""
    },
    "LEVEL_200": {
      "name": "LEVEL_200",
      "value": "3",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c:78",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define LEVEL_200  3",
      "condition": ""
    },
    "LEVEL_300": {
      "name": "LEVEL_300",
      "value": "30",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c:106",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define LEVEL_300 30",
      "condition": ""
    },
    "LEVEL_400": {
      "name": "LEVEL_400",
      "value": "39",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c:116",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define LEVEL_400 39",
      "condition": ""
    },
    "LEVEL_500": {
      "name": "LEVEL_500",
      "value": "91",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c:169",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define LEVEL_500 91",
      "condition": ""
    },
    "METHOD_NUMBER_FIRST": {
      "name": "METHOD_NUMBER_FIRST",
      "value": "(M_INVALID + 1)",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c:193",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define METHOD_NUMBER_FIRST (M_INVALID + 1)",
      "condition": ""
    },
    "METHOD_NUMBER_LAST": {
      "name": "METHOD_NUMBER_LAST",
      "value": "62",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c:199",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define METHOD_NUMBER_LAST  62",
      "condition": ""
    },
    "LOG_NAME_MAX_LEN": {
      "name": "LOG_NAME_MAX_LEN",
      "value": "80",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c:1652",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define LOG_NAME_MAX_LEN 80",
      "condition": ""
    },
    "RRL_ERROR(e,": {
      "name": "RRL_ERROR(e,",
      "value": "et, y, yt)     \\\ndo { \\\nif (e == rrl_none) {\\\ne = y; et = yt;\\\n}\\\n} while (0)",
      "location": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/http/http_protocol.c:1703",
      "is_constant": true,
      "is_function_like": false,
      "parameters": [],
      "definition": "#define RRL_ERROR(e, et, y, yt)     \\\ndo { \\\nif (e == rrl_none) {\\\ne = y; et = yt;\\\n}\\\n} while (0)",
      "condition": ""
    }
  }
}