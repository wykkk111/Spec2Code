SR Text,Conditions,Actions,Keywords,Current Paragraph,Previous Paragraph,Next Paragraph,Section Number,Section Title,Section Level,Paragraph Index,Sentence Index,First_Keyword
"If (EC)DHE key establishment is in use, then the ServerHello contains a ""key_share"" extension with the server's ephemeral Diffie-Hellman share; the server's share MUST be in the same group as one of the client's shares.",(EC)DHE key establishment is in use,"The ServerHello MUST contain a ""key_share"" extension with the server's ephemeral Diffie-Hellman share, and the server's share MUST be in the same group as one of the client's shares.",MUST,"The server processes the ClientHello and determines the appropriate cryptographic parameters for the connection. It then responds with its own ServerHello (Section 4.1.3), which indicates the negotiated connection parameters. The combination of the ClientHello and the ServerHello determines the shared keys. If (EC)DHE key establishment is in use, then the ServerHello contains a ""key_share"" extension with the server's ephemeral Diffie-Hellman share; the server's share MUST be in the same group as one of the client's shares. If PSK key establishment is in use, then the ServerHello contains a ""pre_shared_key"" extension indicating which of the client's offered PSKs was selected. Note that implementations can use (EC)DHE and PSK together, in which case both extensions will be supplied.","In the Key Exchange phase, the client sends the ClientHello (Section 4.1.2) message, which contains a random nonce (ClientHello.random); its offered protocol versions; a list of symmetric cipher/HKDF hash pairs; either a set of Diffie-Hellman key shares (in the ""key_share"" (Section 4.2.8) extension), a set of pre-shared key labels (in the ""pre_shared_key"" (Section 4.2.11) extension), or both; and potentially additional extensions. Additional fields and/or messages may also be present for middlebox compatibility.",The server then sends two messages to establish the Server Parameters:,2,Protocol Overview,1,13,4,MUST
"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",Application Data is attempted to be sent before the Finished message is sent,"Do not send Application Data prior to sending the Finished message, except as specified in Section 2.3",MUST NOT,"At this point, the handshake is complete, and the client and server derive the keying material required by the record layer to exchange application-layer data protected through authenticated encryption. Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3. Note that while the server may send Application Data prior to receiving the client's Authentication messages, any data sent at that point is, of course, being sent to an unauthenticated peer.","Upon receiving the server's messages, the client responds with its Authentication messages, namely Certificate and CertificateVerify (if requested), and Finished.",,2,Protocol Overview,1,22,2,MUST
"If no common cryptographic parameters can be negotiated, the server MUST abort the handshake with an appropriate alert.",No common cryptographic parameters can be negotiated,The server MUST abort the handshake with an appropriate alert,MUST,"If the client has not provided a sufficient ""key_share"" extension (e.g., it includes only DHE or ECDHE groups unacceptable to or unsupported by the server), the server corrects the mismatch with a HelloRetryRequest and the client needs to restart the handshake with an appropriate ""key_share"" extension, as shown in Figure 2. If no common cryptographic parameters can be negotiated, the server MUST abort the handshake with an appropriate alert.",,Note: The handshake transcript incorporates the initial ClientHello/HelloRetryRequest exchange; it is not reset with the new ClientHello.,2.1,Incorrect DHE Share,2,1,2,MUST
"When a client offers resumption via a PSK, it SHOULD also supply a ""key_share"" extension to the server to allow the server to decline resumption and fall back to a full handshake, if needed.",When a client offers resumption via a PSK.,The client SHOULD also supply a 'key_share' extension to the server to allow the server to decline resumption and fall back to a full handshake if needed.,SHOULD,"As the server is authenticating via a PSK, it does not send a Certificate or a CertificateVerify message. When a client offers resumption via a PSK, it SHOULD also supply a ""key_share"" extension to the server to allow the server to decline resumption and fall back to a full handshake, if needed. The server responds with a ""pre_shared_key"" extension to negotiate the use of PSK key establishment and can (as shown here) respond with a ""key_share"" extension to do (EC)DHE key establishment, thus providing forward secrecy.",Subsequent Handshake: ClientHello + key_share* + pre_shared_key --------> ServerHello + pre_shared_key + key_share* {EncryptedExtensions} {Finished} <--------[Application Data*] {Finished} --------> [Application Data] <-------> [Application Data],"When PSKs are provisioned out of band, the PSK identity and the KDF hash algorithm to be used with the PSK MUST also be provisioned.",2.2,Resumption and Pre-Shared Key (PSK),2,6,2,SHOULD
"When PSKs are provisioned out of band, the PSK identity and the KDF hash algorithm to be used with the PSK MUST also be provisioned.",PSKs are provisioned out of band,The PSK identity and the KDF hash algorithm to be used with the PSK MUST also be provisioned,MUST,"When PSKs are provisioned out of band, the PSK identity and the KDF hash algorithm to be used with the PSK MUST also be provisioned.","As the server is authenticating via a PSK, it does not send a Certificate or a CertificateVerify message. When a client offers resumption via a PSK, it SHOULD also supply a ""key_share"" extension to the server to allow the server to decline resumption and fall back to a full handshake, if needed. The server responds with a ""pre_shared_key"" extension to negotiate the use of PSK key establishment and can (as shown here) respond with a ""key_share"" extension to do (EC)DHE key establishment, thus providing forward secrecy.","Note: When using an out-of-band provisioned pre-shared secret, a critical consideration is using sufficient entropy during the key generation, as discussed in [RFC4086]. Deriving a shared secret from a password or other low-entropy sources is not secure. A low-entropy secret, or password, is subject to dictionary attacks based on the PSK binder. The specified PSK authentication is not a strong password-based authenticated key exchange even when used with Diffie-Hellman key establishment. Specifically, it does not prevent an attacker that can observe the handshake from performing a brute-force attack on the password/pre-shared key.",2.2,Resumption and Pre-Shared Key (PSK),2,7,1,MUST
Protocol messages MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2.,,Protocol messages MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2.,MUST,"Protocol messages MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2. A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.","The handshake protocol is used to negotiate the security parameters of a connection. Handshake messages are supplied to the TLS record layer, where they are encapsulated within one or more TLSPlaintext or TLSCiphertext structures which are processed and transmitted as specified by the current active connection state.",New handshake message types are assigned by IANA as described in Section 11.,4,Handshake Protocol,1,2,1,MUST
"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",A handshake message is received in an unexpected order by a peer.,Abort the handshake with an 'unexpected_message' alert.,MUST,"Protocol messages MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2. A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.","The handshake protocol is used to negotiate the security parameters of a connection. Handshake messages are supplied to the TLS record layer, where they are encapsulated within one or more TLSPlaintext or TLSCiphertext structures which are processed and transmitted as specified by the current active connection state.",New handshake message types are assigned by IANA as described in Section 11.,4,Handshake Protocol,1,2,2,MUST
"If there is no overlap between the received ""supported_groups"" and the groups supported by the server, then the server MUST abort the handshake with a ""handshake_failure"" or an ""insufficient_security"" alert.","There is no overlap between the received ""supported_groups"" and the groups supported by the server.","The server MUST abort the handshake with a ""handshake_failure"" or an ""insufficient_security"" alert.",MUST,"If the server does not select a PSK, then the first three of these options are entirely orthogonal: the server independently selects a cipher suite, an (EC)DHE group and key share for key establishment, and a signature algorithm/certificate pair to authenticate itself to the client. If there is no overlap between the received ""supported_groups"" and the groups supported by the server, then the server MUST abort the handshake with a ""handshake_failure"" or an ""insufficient_security"" alert.","-A ""pre_shared_key"" (Section 4.2.11) extension which contains a list of symmetric key identities known to the client and a ""psk_key_exchange_modes"" (Section 4.2.9) extension which indicates the key exchange modes that may be used with PSKs.","If the server selects a PSK, then it MUST also select a key establishment mode from the set indicated by the client's ""psk_key_exchange_modes"" extension (at present, PSK alone or with (EC)DHE). Note that if the PSK can be used without (EC)DHE, then non-overlap in the ""supported_groups"" parameters need not be fatal, as it is in the non-PSK case discussed in the previous paragraph.",4.1.1,Cryptographic Negotiation,3,6,2,MUST
"If the server selects a PSK, then it MUST also select a key establishment mode from the set indicated by the client's ""psk_key_exchange_modes"" extension (at present, PSK alone or with (EC)DHE).",The condition is when the server selects a PSK.,"The server MUST also select a key establishment mode from the set indicated by the client's 'psk_key_exchange_modes' extension (at present, PSK alone or with (EC)DHE).",MUST,"If the server selects a PSK, then it MUST also select a key establishment mode from the set indicated by the client's ""psk_key_exchange_modes"" extension (at present, PSK alone or with (EC)DHE). Note that if the PSK can be used without (EC)DHE, then non-overlap in the ""supported_groups"" parameters need not be fatal, as it is in the non-PSK case discussed in the previous paragraph.","If the server does not select a PSK, then the first three of these options are entirely orthogonal: the server independently selects a cipher suite, an (EC)DHE group and key share for key establishment, and a signature algorithm/certificate pair to authenticate itself to the client. If there is no overlap between the received ""supported_groups"" and the groups supported by the server, then the server MUST abort the handshake with a ""handshake_failure"" or an ""insufficient_security"" alert.","If the server selects an (EC)DHE group and the client did not offer a compatible ""key_share"" extension in the initial ClientHello, the server MUST respond with a HelloRetryRequest (Section 4.1.4) message.",4.1.1,Cryptographic Negotiation,3,7,1,MUST
"If the server selects an (EC)DHE group and the client did not offer a compatible ""key_share"" extension in the initial ClientHello, the server MUST respond with a HelloRetryRequest (Section 4.1.4) message.",The server selects an (EC)DHE group and the client did not offer a compatible 'key_share' extension in the initial ClientHello,The server MUST respond with a HelloRetryRequest (Section 4.1.4) message,MUST,"If the server selects an (EC)DHE group and the client did not offer a compatible ""key_share"" extension in the initial ClientHello, the server MUST respond with a HelloRetryRequest (Section 4.1.4) message.","If the server selects a PSK, then it MUST also select a key establishment mode from the set indicated by the client's ""psk_key_exchange_modes"" extension (at present, PSK alone or with (EC)DHE). Note that if the PSK can be used without (EC)DHE, then non-overlap in the ""supported_groups"" parameters need not be fatal, as it is in the non-PSK case discussed in the previous paragraph.","If the server successfully selects parameters and does not require a HelloRetryRequest, it indicates the selected parameters in the ServerHello as follows:",4.1.1,Cryptographic Negotiation,3,8,1,MUST
"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6).","The server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters)",Abort the handshake with either a 'handshake_failure' or 'insufficient_security' fatal alert,MUST,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6).","-When authenticating via a certificate, the server will send the Certificate (Section 4.4.2) and CertificateVerify (Section 4.4.3) messages. In TLS 1.3 as defined by this document, either a PSK or a certificate is always used, but not both. Future documents may define how to use them together.",,4.1.1,Cryptographic Negotiation,3,13,1,MUST
"In that case, the client MUST send the same ClientHello without modification, except as follows:","The client receives a HelloRetryRequest from the server (triggering the re-sending of ClientHello).,If a 'key_share' extension was supplied in the HelloRetryRequest.","The client MUST send the same ClientHello message without modification, except that if a 'key_share' extension was supplied in the HelloRetryRequest, it must replace the list of shares with a list containing a single KeyShareEntry from the indicated group.",MUST,"When a client first connects to a server, it is REQUIRED to send the ClientHello as its first TLS message. The client will also send a ClientHello when the server has responded to its ClientHello with a HelloRetryRequest. In that case, the client MUST send the same ClientHello without modification, except as follows:",,"-If a ""key_share"" extension was supplied in the HelloRetryRequest, replacing the list of shares with a list containing a single KeyShareEntry from the indicated group.",4.1.2,Client Hello,3,1,3,MUST
"Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS 1.3 and receives a ClientHello at any other time, it MUST terminate the connection with an ""unexpected_message"" alert.","The server has negotiated TLS 1.3,The server receives a ClientHello at any other time","Terminate the connection with an ""unexpected_message"" alert",MUST,"Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS 1.3 and receives a ClientHello at any other time, it MUST terminate the connection with an ""unexpected_message"" alert.",-Other modifications that may be allowed by an extension defined in the future and present in the HelloRetryRequest.,"If a server established a TLS connection with a previous version of TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the previous protocol version. In particular, it MUST NOT negotiate TLS 1.3.",4.1.2,Client Hello,3,8,1,MUST
"If a server established a TLS connection with a previous version of TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the previous protocol version.","The server has previously established a TLS connection using a version prior to TLS 1.3,During a renegotiation, the server receives a TLS 1.3 ClientHello","The server MUST retain the previously negotiated protocol version,The server MUST NOT negotiate TLS 1.3",MUST,"If a server established a TLS connection with a previous version of TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the previous protocol version. In particular, it MUST NOT negotiate TLS 1.3.","Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS 1.3 and receives a ClientHello at any other time, it MUST terminate the connection with an ""unexpected_message"" alert.",Structure of this message:,4.1.2,Client Hello,3,9,1,MUST
"In particular, it MUST NOT negotiate TLS 1.3.",A server that has established a TLS connection with a previous version of TLS and subsequently receives a TLS 1.3 ClientHello during a renegotiation,The server MUST NOT negotiate TLS 1.3,MUST NOT,"If a server established a TLS connection with a previous version of TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the previous protocol version. In particular, it MUST NOT negotiate TLS 1.3.","Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS 1.3 and receives a ClientHello at any other time, it MUST terminate the connection with an ""unexpected_message"" alert.",Structure of this message:,4.1.2,Client Hello,3,9,2,MUST
"In TLS 1.3, the client indicates its version preferences in the ""supported_versions"" extension (Section 4.2.1) and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.","The client is constructing a TLS 1.3 ClientHello that includes the 'supported_versions' extension, indicating its version preferences.",The legacy_version field MUST be set to 0x0303 (the TLS 1.2 version number) in the ClientHello message.,MUST,"legacy_version: In previous versions of TLS, this field was used for version negotiation and represented the highest version number supported by the client. Experience has shown that many servers do not properly implement version negotiation, leading to ""version intolerance"" in which the server rejects an otherwise acceptable ClientHello with a version number higher than it supports. In TLS 1.3, the client indicates its version preferences in the ""supported_versions"" extension (Section 4.2.1) and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2. TLS 1.3 ClientHellos are identified as having a legacy_version of 0x0303 and a supported_versions extension present with 0x0304 as the highest version indicated therein. (See Appendix D for details about backward compatibility.)",Structure of this message:,random: 32 bytes generated by a secure random number generator. See Appendix C for additional information.,4.1.2,Client Hello,3,11,3,MUST
A client which has a cached session ID set by a pre-TLS 1.3 server SHOULD set this field to that value.,The client has a cached session ID that was set by a pre-TLS 1.3 server.,The client SHOULD set the legacy_session_id field to the value of the cached session ID.,SHOULD,"legacy_session_id: Versions of TLS before TLS 1.3 supported a ""session resumption"" feature which has been merged with pre-shared keys in this version (see Section 2.2). A client which has a cached session ID set by a pre-TLS 1.3 server SHOULD set this field to that value. In compatibility mode (see Appendix D.4), this field MUST be non-empty, so a client not offering a pre-TLS 1.3 session MUST generate a new 32-byte value. This value need not be random but SHOULD be unpredictable to avoid implementations fixating on a specific value (also known as ossification). Otherwise, it MUST be set as a zero-length vector (i.e., a zero-valued single byte length field).",random: 32 bytes generated by a secure random number generator. See Appendix C for additional information.,"cipher_suites: A list of the symmetric cipher options supported by the client, specifically the record protection algorithm (including secret key length) and a hash to be used with HKDF, in descending order of client preference. Values are defined in Appendix B.4. If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual. If the client is attempting a PSK key establishment, it SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK.",4.1.2,Client Hello,3,13,2,SHOULD
"In compatibility mode (see Appendix D.4), this field MUST be non-empty, so a client not offering a pre-TLS 1.3 session MUST generate a new 32-byte value.","The protocol is operating in compatibility mode as referenced in Appendix D.4,The client is not offering a pre-TLS 1.3 session","The client MUST generate a new 32-byte value for the field, ensuring it is non-empty",MUST,"legacy_session_id: Versions of TLS before TLS 1.3 supported a ""session resumption"" feature which has been merged with pre-shared keys in this version (see Section 2.2). A client which has a cached session ID set by a pre-TLS 1.3 server SHOULD set this field to that value. In compatibility mode (see Appendix D.4), this field MUST be non-empty, so a client not offering a pre-TLS 1.3 session MUST generate a new 32-byte value. This value need not be random but SHOULD be unpredictable to avoid implementations fixating on a specific value (also known as ossification). Otherwise, it MUST be set as a zero-length vector (i.e., a zero-valued single byte length field).",random: 32 bytes generated by a secure random number generator. See Appendix C for additional information.,"cipher_suites: A list of the symmetric cipher options supported by the client, specifically the record protection algorithm (including secret key length) and a hash to be used with HKDF, in descending order of client preference. Values are defined in Appendix B.4. If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual. If the client is attempting a PSK key establishment, it SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK.",4.1.2,Client Hello,3,13,3,MUST
This value need not be random but SHOULD be unpredictable to avoid implementations fixating on a specific value (also known as ossification).,When generating the legacy_session_id value (in scenarios such as compatibility mode where a new 32-byte value is generated because no pre-TLS 1.3 session is offered),The generated value SHOULD be unpredictable (even though it need not be random) to avoid implementations fixating on a specific value (ossification),SHOULD,"legacy_session_id: Versions of TLS before TLS 1.3 supported a ""session resumption"" feature which has been merged with pre-shared keys in this version (see Section 2.2). A client which has a cached session ID set by a pre-TLS 1.3 server SHOULD set this field to that value. In compatibility mode (see Appendix D.4), this field MUST be non-empty, so a client not offering a pre-TLS 1.3 session MUST generate a new 32-byte value. This value need not be random but SHOULD be unpredictable to avoid implementations fixating on a specific value (also known as ossification). Otherwise, it MUST be set as a zero-length vector (i.e., a zero-valued single byte length field).",random: 32 bytes generated by a secure random number generator. See Appendix C for additional information.,"cipher_suites: A list of the symmetric cipher options supported by the client, specifically the record protection algorithm (including secret key length) and a hash to be used with HKDF, in descending order of client preference. Values are defined in Appendix B.4. If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual. If the client is attempting a PSK key establishment, it SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK.",4.1.2,Client Hello,3,13,4,SHOULD
"Otherwise, it MUST be set as a zero-length vector (i.e., a zero-valued single byte length field).","If neither a cached pre-TLS 1.3 session ID is used nor is the client operating in compatibility mode requiring a non-empty legacy_session_id field (i.e., when none of the preceding conditions apply)","Set the legacy_session_id field as a zero-length vector (i.e., a zero-valued single byte length field)",MUST,"legacy_session_id: Versions of TLS before TLS 1.3 supported a ""session resumption"" feature which has been merged with pre-shared keys in this version (see Section 2.2). A client which has a cached session ID set by a pre-TLS 1.3 server SHOULD set this field to that value. In compatibility mode (see Appendix D.4), this field MUST be non-empty, so a client not offering a pre-TLS 1.3 session MUST generate a new 32-byte value. This value need not be random but SHOULD be unpredictable to avoid implementations fixating on a specific value (also known as ossification). Otherwise, it MUST be set as a zero-length vector (i.e., a zero-valued single byte length field).",random: 32 bytes generated by a secure random number generator. See Appendix C for additional information.,"cipher_suites: A list of the symmetric cipher options supported by the client, specifically the record protection algorithm (including secret key length) and a hash to be used with HKDF, in descending order of client preference. Values are defined in Appendix B.4. If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual. If the client is attempting a PSK key establishment, it SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK.",4.1.2,Client Hello,3,13,5,MUST
"If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual.","The list contains cipher suites that the server does not recognize, support, or wish to use.",The server MUST ignore those cipher suites and process the remaining ones as usual.,MUST,"cipher_suites: A list of the symmetric cipher options supported by the client, specifically the record protection algorithm (including secret key length) and a hash to be used with HKDF, in descending order of client preference. Values are defined in Appendix B.4. If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual. If the client is attempting a PSK key establishment, it SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK.","legacy_session_id: Versions of TLS before TLS 1.3 supported a ""session resumption"" feature which has been merged with pre-shared keys in this version (see Section 2.2). A client which has a cached session ID set by a pre-TLS 1.3 server SHOULD set this field to that value. In compatibility mode (see Appendix D.4), this field MUST be non-empty, so a client not offering a pre-TLS 1.3 session MUST generate a new 32-byte value. This value need not be random but SHOULD be unpredictable to avoid implementations fixating on a specific value (also known as ossification). Otherwise, it MUST be set as a zero-length vector (i.e., a zero-valued single byte length field).","legacy_compression_methods: Versions of TLS before 1.3 supported compression with the list of supported compression methods being sent in this field. For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS. If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST abort the handshake with an ""illegal_parameter"" alert. Note that TLS 1.3 servers might receive TLS 1.2 or prior ClientHellos which contain other compression methods and (if negotiating such a prior version) MUST follow the procedures for the appropriate prior version of TLS.",4.1.2,Client Hello,3,14,3,MUST
"If the client is attempting a PSK key establishment, it SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK.",The client is attempting a PSK key establishment.,The client SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK.,SHOULD,"cipher_suites: A list of the symmetric cipher options supported by the client, specifically the record protection algorithm (including secret key length) and a hash to be used with HKDF, in descending order of client preference. Values are defined in Appendix B.4. If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual. If the client is attempting a PSK key establishment, it SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK.","legacy_session_id: Versions of TLS before TLS 1.3 supported a ""session resumption"" feature which has been merged with pre-shared keys in this version (see Section 2.2). A client which has a cached session ID set by a pre-TLS 1.3 server SHOULD set this field to that value. In compatibility mode (see Appendix D.4), this field MUST be non-empty, so a client not offering a pre-TLS 1.3 session MUST generate a new 32-byte value. This value need not be random but SHOULD be unpredictable to avoid implementations fixating on a specific value (also known as ossification). Otherwise, it MUST be set as a zero-length vector (i.e., a zero-valued single byte length field).","legacy_compression_methods: Versions of TLS before 1.3 supported compression with the list of supported compression methods being sent in this field. For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS. If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST abort the handshake with an ""illegal_parameter"" alert. Note that TLS 1.3 servers might receive TLS 1.2 or prior ClientHellos which contain other compression methods and (if negotiating such a prior version) MUST follow the procedures for the appropriate prior version of TLS.",4.1.2,Client Hello,3,14,4,SHOULD
"For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS.","A TLS 1.3 ClientHello message is being processed.,A TLS 1.3 ClientHello is received where the legacy_compression_methods field does not contain exactly one byte set to zero.","For every TLS 1.3 ClientHello, ensure that the legacy_compression_methods vector contains exactly one byte, set to zero (corresponding to the 'null' compression method).,If a TLS 1.3 ClientHello is received with any other value in this field, abort the handshake by issuing an 'illegal_parameter' alert.",MUST,"legacy_compression_methods: Versions of TLS before 1.3 supported compression with the list of supported compression methods being sent in this field. For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS. If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST abort the handshake with an ""illegal_parameter"" alert. Note that TLS 1.3 servers might receive TLS 1.2 or prior ClientHellos which contain other compression methods and (if negotiating such a prior version) MUST follow the procedures for the appropriate prior version of TLS.","cipher_suites: A list of the symmetric cipher options supported by the client, specifically the record protection algorithm (including secret key length) and a hash to be used with HKDF, in descending order of client preference. Values are defined in Appendix B.4. If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual. If the client is attempting a PSK key establishment, it SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK.","extensions: Clients request extended functionality from servers by sending data in the extensions field. The actual ""Extension"" format is defined in Section 4.2. In TLS 1.3, the use of certain extensions is mandatory, as functionality has moved into extensions to preserve ClientHello compatibility with previous versions of TLS. Servers MUST ignore unrecognized extensions.",4.1.2,Client Hello,3,15,2,MUST
"If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST abort the handshake with an ""illegal_parameter"" alert.",A TLS 1.3 ClientHello is received with a legacy_compression_methods field value that is not exactly one byte set to zero.,"The server MUST abort the handshake with an ""illegal_parameter"" alert.",MUST,"legacy_compression_methods: Versions of TLS before 1.3 supported compression with the list of supported compression methods being sent in this field. For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS. If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST abort the handshake with an ""illegal_parameter"" alert. Note that TLS 1.3 servers might receive TLS 1.2 or prior ClientHellos which contain other compression methods and (if negotiating such a prior version) MUST follow the procedures for the appropriate prior version of TLS.","cipher_suites: A list of the symmetric cipher options supported by the client, specifically the record protection algorithm (including secret key length) and a hash to be used with HKDF, in descending order of client preference. Values are defined in Appendix B.4. If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual. If the client is attempting a PSK key establishment, it SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK.","extensions: Clients request extended functionality from servers by sending data in the extensions field. The actual ""Extension"" format is defined in Section 4.2. In TLS 1.3, the use of certain extensions is mandatory, as functionality has moved into extensions to preserve ClientHello compatibility with previous versions of TLS. Servers MUST ignore unrecognized extensions.",4.1.2,Client Hello,3,15,3,MUST
Note that TLS 1.3 servers might receive TLS 1.2 or prior ClientHellos which contain other compression methods and (if negotiating such a prior version) MUST follow the procedures for the appropriate prior version of TLS.,"A TLS 1.3 server receives a TLS 1.2 or prior ClientHello that contains compression methods other than the expected 'null' compression method, and is negotiating a prior version of TLS.",Follow the procedures for the appropriate prior version of TLS.,MUST,"legacy_compression_methods: Versions of TLS before 1.3 supported compression with the list of supported compression methods being sent in this field. For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS. If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST abort the handshake with an ""illegal_parameter"" alert. Note that TLS 1.3 servers might receive TLS 1.2 or prior ClientHellos which contain other compression methods and (if negotiating such a prior version) MUST follow the procedures for the appropriate prior version of TLS.","cipher_suites: A list of the symmetric cipher options supported by the client, specifically the record protection algorithm (including secret key length) and a hash to be used with HKDF, in descending order of client preference. Values are defined in Appendix B.4. If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual. If the client is attempting a PSK key establishment, it SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK.","extensions: Clients request extended functionality from servers by sending data in the extensions field. The actual ""Extension"" format is defined in Section 4.2. In TLS 1.3, the use of certain extensions is mandatory, as functionality has moved into extensions to preserve ClientHello compatibility with previous versions of TLS. Servers MUST ignore unrecognized extensions.",4.1.2,Client Hello,3,15,4,MUST
Servers MUST ignore unrecognized extensions.,When the server receives extensions in a TLS ClientHello message that are not recognized or defined by the TLS specification,The server MUST ignore the unrecognized extensions,MUST,"extensions: Clients request extended functionality from servers by sending data in the extensions field. The actual ""Extension"" format is defined in Section 4.2. In TLS 1.3, the use of certain extensions is mandatory, as functionality has moved into extensions to preserve ClientHello compatibility with previous versions of TLS. Servers MUST ignore unrecognized extensions.","legacy_compression_methods: Versions of TLS before 1.3 supported compression with the list of supported compression methods being sent in this field. For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS. If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST abort the handshake with an ""illegal_parameter"" alert. Note that TLS 1.3 servers might receive TLS 1.2 or prior ClientHellos which contain other compression methods and (if negotiating such a prior version) MUST follow the procedures for the appropriate prior version of TLS.","All versions of TLS allow an extensions field to optionally follow the compression_methods field. TLS 1.3 ClientHello messages always contain extensions (minimally ""supported_versions"", otherwise, they will be interpreted as TLS 1.2 ClientHello messages). However, TLS 1.3 servers might receive ClientHello messages without an extensions field from prior versions of TLS. The presence of extensions can be detected by determining whether there are bytes following the compression_methods field at the end of the ClientHello. Note that this method of detecting optional data differs from the normal TLS method of having a variable-length field, but it is used for compatibility with TLS before extensions were defined. TLS 1.3 servers will need to perform this check first and only attempt to negotiate TLS 1.3 if the ""supported_versions"" extension is present. If negotiating a version of TLS prior to 1.3, a server MUST check that the message either contains no data after legacy_compression_methods or that it contains a valid extensions block with no data following. If not, then it MUST abort the handshake with a ""decode_error"" alert.",4.1.2,Client Hello,3,16,4,MUST
"If negotiating a version of TLS prior to 1.3, a server MUST check that the message either contains no data after legacy_compression_methods or that it contains a valid extensions block with no data following.",Negotiating a version of TLS prior to 1.3,"The server MUST check that the ClientHello message either contains no data after legacy_compression_methods or contains a valid extensions block with no data following; if this condition is not met, the server MUST abort the handshake with a 'decode_error' alert",MUST,"All versions of TLS allow an extensions field to optionally follow the compression_methods field. TLS 1.3 ClientHello messages always contain extensions (minimally ""supported_versions"", otherwise, they will be interpreted as TLS 1.2 ClientHello messages). However, TLS 1.3 servers might receive ClientHello messages without an extensions field from prior versions of TLS. The presence of extensions can be detected by determining whether there are bytes following the compression_methods field at the end of the ClientHello. Note that this method of detecting optional data differs from the normal TLS method of having a variable-length field, but it is used for compatibility with TLS before extensions were defined. TLS 1.3 servers will need to perform this check first and only attempt to negotiate TLS 1.3 if the ""supported_versions"" extension is present. If negotiating a version of TLS prior to 1.3, a server MUST check that the message either contains no data after legacy_compression_methods or that it contains a valid extensions block with no data following. If not, then it MUST abort the handshake with a ""decode_error"" alert.","extensions: Clients request extended functionality from servers by sending data in the extensions field. The actual ""Extension"" format is defined in Section 4.2. In TLS 1.3, the use of certain extensions is mandatory, as functionality has moved into extensions to preserve ClientHello compatibility with previous versions of TLS. Servers MUST ignore unrecognized extensions.","In the event that a client requests additional functionality using extensions and this functionality is not supplied by the server, the client MAY abort the handshake.",4.1.2,Client Hello,3,17,7,MUST
"If not, then it MUST abort the handshake with a ""decode_error"" alert.",Negotiating a version of TLS prior to 1.3 and the received ClientHello message does not either contain no data after legacy_compression_methods or contain a valid extensions block with no extra data following,Abort the handshake with a 'decode_error' alert,MUST,"All versions of TLS allow an extensions field to optionally follow the compression_methods field. TLS 1.3 ClientHello messages always contain extensions (minimally ""supported_versions"", otherwise, they will be interpreted as TLS 1.2 ClientHello messages). However, TLS 1.3 servers might receive ClientHello messages without an extensions field from prior versions of TLS. The presence of extensions can be detected by determining whether there are bytes following the compression_methods field at the end of the ClientHello. Note that this method of detecting optional data differs from the normal TLS method of having a variable-length field, but it is used for compatibility with TLS before extensions were defined. TLS 1.3 servers will need to perform this check first and only attempt to negotiate TLS 1.3 if the ""supported_versions"" extension is present. If negotiating a version of TLS prior to 1.3, a server MUST check that the message either contains no data after legacy_compression_methods or that it contains a valid extensions block with no data following. If not, then it MUST abort the handshake with a ""decode_error"" alert.","extensions: Clients request extended functionality from servers by sending data in the extensions field. The actual ""Extension"" format is defined in Section 4.2. In TLS 1.3, the use of certain extensions is mandatory, as functionality has moved into extensions to preserve ClientHello compatibility with previous versions of TLS. Servers MUST ignore unrecognized extensions.","In the event that a client requests additional functionality using extensions and this functionality is not supplied by the server, the client MAY abort the handshake.",4.1.2,Client Hello,3,17,8,MUST
"In the event that a client requests additional functionality using extensions and this functionality is not supplied by the server, the client MAY abort the handshake.","A client requests additional functionality using extensions,The server does not supply the requested additional functionality",The client MAY abort the handshake,MAY,"In the event that a client requests additional functionality using extensions and this functionality is not supplied by the server, the client MAY abort the handshake.","All versions of TLS allow an extensions field to optionally follow the compression_methods field. TLS 1.3 ClientHello messages always contain extensions (minimally ""supported_versions"", otherwise, they will be interpreted as TLS 1.2 ClientHello messages). However, TLS 1.3 servers might receive ClientHello messages without an extensions field from prior versions of TLS. The presence of extensions can be detected by determining whether there are bytes following the compression_methods field at the end of the ClientHello. Note that this method of detecting optional data differs from the normal TLS method of having a variable-length field, but it is used for compatibility with TLS before extensions were defined. TLS 1.3 servers will need to perform this check first and only attempt to negotiate TLS 1.3 if the ""supported_versions"" extension is present. If negotiating a version of TLS prior to 1.3, a server MUST check that the message either contains no data after legacy_compression_methods or that it contains a valid extensions block with no data following. If not, then it MUST abort the handshake with a ""decode_error"" alert.","After sending the ClientHello message, the client waits for a ServerHello or HelloRetryRequest message. If early data is in use, the client may transmit early Application Data (Section 2.3) while waiting for the next handshake message.",4.1.2,Client Hello,3,18,1,MAY
"In TLS 1.3, the TLS server indicates its version using the ""supported_versions"" extension (Section 4.2.1), and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.",The server is operating under TLS 1.3 and indicating its version using the 'supported_versions' extension.,"The legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.",MUST,"legacy_version: In previous versions of TLS, this field was used for version negotiation and represented the selected version number for the connection. Unfortunately, some middleboxes fail when presented with new values. In TLS 1.3, the TLS server indicates its version using the ""supported_versions"" extension (Section 4.2.1), and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2. (See Appendix D for details about backward compatibility.)",Structure of this message:,"random: 32 bytes generated by a secure random number generator. See Appendix C for additional information. The last 8 bytes MUST be overwritten as described below if negotiating TLS 1.2 or TLS 1.1, but the remaining bytes MUST be random. This structure is generated by the server and MUST be generated independently of the ClientHello.random.",4.1.3,Server Hello,3,3,3,MUST
"The last 8 bytes MUST be overwritten as described below if negotiating TLS 1.2 or TLS 1.1, but the remaining bytes MUST be random.",Negotiating TLS 1.2 or TLS 1.1,"The last 8 bytes MUST be overwritten as described below,The remaining bytes MUST be random",MUST,"random: 32 bytes generated by a secure random number generator. See Appendix C for additional information. The last 8 bytes MUST be overwritten as described below if negotiating TLS 1.2 or TLS 1.1, but the remaining bytes MUST be random. This structure is generated by the server and MUST be generated independently of the ClientHello.random.","legacy_version: In previous versions of TLS, this field was used for version negotiation and represented the selected version number for the connection. Unfortunately, some middleboxes fail when presented with new values. In TLS 1.3, the TLS server indicates its version using the ""supported_versions"" extension (Section 4.2.1), and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2. (See Appendix D for details about backward compatibility.)","legacy_session_id_echo: The contents of the client's legacy_session_id field. Note that this field is echoed even if the client's value corresponded to a cached pre-TLS 1.3 session which the server has chosen not to resume. A client which receives a legacy_session_id_echo field that does not match what it sent in the ClientHello MUST abort the handshake with an ""illegal_parameter"" alert.",4.1.3,Server Hello,3,4,3,MUST
This structure is generated by the server and MUST be generated independently of the ClientHello.random.,When the server generates the random structure as part of the TLS handshake,The server MUST generate the structure independently of the ClientHello.random,MUST,"random: 32 bytes generated by a secure random number generator. See Appendix C for additional information. The last 8 bytes MUST be overwritten as described below if negotiating TLS 1.2 or TLS 1.1, but the remaining bytes MUST be random. This structure is generated by the server and MUST be generated independently of the ClientHello.random.","legacy_version: In previous versions of TLS, this field was used for version negotiation and represented the selected version number for the connection. Unfortunately, some middleboxes fail when presented with new values. In TLS 1.3, the TLS server indicates its version using the ""supported_versions"" extension (Section 4.2.1), and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2. (See Appendix D for details about backward compatibility.)","legacy_session_id_echo: The contents of the client's legacy_session_id field. Note that this field is echoed even if the client's value corresponded to a cached pre-TLS 1.3 session which the server has chosen not to resume. A client which receives a legacy_session_id_echo field that does not match what it sent in the ClientHello MUST abort the handshake with an ""illegal_parameter"" alert.",4.1.3,Server Hello,3,4,4,MUST
"A client which receives a legacy_session_id_echo field that does not match what it sent in the ClientHello MUST abort the handshake with an ""illegal_parameter"" alert.",A client receives a legacy_session_id_echo field that does not match what it sent in the ClientHello.,Abort the handshake with an 'illegal_parameter' alert.,MUST,"legacy_session_id_echo: The contents of the client's legacy_session_id field. Note that this field is echoed even if the client's value corresponded to a cached pre-TLS 1.3 session which the server has chosen not to resume. A client which receives a legacy_session_id_echo field that does not match what it sent in the ClientHello MUST abort the handshake with an ""illegal_parameter"" alert.","random: 32 bytes generated by a secure random number generator. See Appendix C for additional information. The last 8 bytes MUST be overwritten as described below if negotiating TLS 1.2 or TLS 1.1, but the remaining bytes MUST be random. This structure is generated by the server and MUST be generated independently of the ClientHello.random.","cipher_suite: The single cipher suite selected by the server from the list in ClientHello.cipher_suites. A client which receives a cipher suite that was not offered MUST abort the handshake with an ""illegal_parameter"" alert.",4.1.3,Server Hello,3,5,3,MUST
"A client which receives a cipher suite that was not offered MUST abort the handshake with an ""illegal_parameter"" alert.",A client receives a cipher suite that was not offered,Abort the handshake with an 'illegal_parameter' alert,MUST,"cipher_suite: The single cipher suite selected by the server from the list in ClientHello.cipher_suites. A client which receives a cipher suite that was not offered MUST abort the handshake with an ""illegal_parameter"" alert.","legacy_session_id_echo: The contents of the client's legacy_session_id field. Note that this field is echoed even if the client's value corresponded to a cached pre-TLS 1.3 session which the server has chosen not to resume. A client which receives a legacy_session_id_echo field that does not match what it sent in the ClientHello MUST abort the handshake with an ""illegal_parameter"" alert.",legacy_compression_method: A single byte which MUST have the value 0.,4.1.3,Server Hello,3,6,2,MUST
legacy_compression_method: A single byte which MUST have the value 0.,,The legacy_compression_method field MUST be a single byte with the value 0.,MUST,legacy_compression_method: A single byte which MUST have the value 0.,"cipher_suite: The single cipher suite selected by the server from the list in ClientHello.cipher_suites. A client which receives a cipher suite that was not offered MUST abort the handshake with an ""illegal_parameter"" alert.","extensions: A list of extensions. The ServerHello MUST only include extensions which are required to establish the cryptographic context and negotiate the protocol version. All TLS 1.3 ServerHello messages MUST contain the ""supported_versions"" extension. Current ServerHello messages additionally contain either the ""pre_shared_key"" extension or the ""key_share"" extension, or both (when using a PSK with (EC)DHE key establishment). Other extensions (see Section 4.2) are sent separately in the EncryptedExtensions message.",4.1.3,Server Hello,3,7,1,MUST
The ServerHello MUST only include extensions which are required to establish the cryptographic context and negotiate the protocol version.,When constructing or processing a ServerHello message,The ServerHello message MUST only include extensions that are required to establish the cryptographic context and negotiate the protocol version,MUST,"extensions: A list of extensions. The ServerHello MUST only include extensions which are required to establish the cryptographic context and negotiate the protocol version. All TLS 1.3 ServerHello messages MUST contain the ""supported_versions"" extension. Current ServerHello messages additionally contain either the ""pre_shared_key"" extension or the ""key_share"" extension, or both (when using a PSK with (EC)DHE key establishment). Other extensions (see Section 4.2) are sent separately in the EncryptedExtensions message.",legacy_compression_method: A single byte which MUST have the value 0.,"For reasons of backward compatibility with middleboxes (see Appendix D.4), the HelloRetryRequest message uses the same structure as the ServerHello, but with Random set to the special value of the SHA-256 of ""HelloRetryRequest"":",4.1.3,Server Hello,3,8,2,MUST
"All TLS 1.3 ServerHello messages MUST contain the ""supported_versions"" extension.",A message is a TLS 1.3 ServerHello message,"The ServerHello message MUST contain the ""supported_versions"" extension",MUST,"extensions: A list of extensions. The ServerHello MUST only include extensions which are required to establish the cryptographic context and negotiate the protocol version. All TLS 1.3 ServerHello messages MUST contain the ""supported_versions"" extension. Current ServerHello messages additionally contain either the ""pre_shared_key"" extension or the ""key_share"" extension, or both (when using a PSK with (EC)DHE key establishment). Other extensions (see Section 4.2) are sent separately in the EncryptedExtensions message.",legacy_compression_method: A single byte which MUST have the value 0.,"For reasons of backward compatibility with middleboxes (see Appendix D.4), the HelloRetryRequest message uses the same structure as the ServerHello, but with Random set to the special value of the SHA-256 of ""HelloRetryRequest"":",4.1.3,Server Hello,3,8,3,MUST
"Upon receiving a message with type server_hello, implementations MUST first examine the Random value and, if it matches this value, process it as described in Section 4.1.4).","A message with type server_hello is received.,The Random value in the message matches the specific value (i.e., the special value associated with HelloRetryRequest).",Process the message as described in Section 4.1.4.,MUST,"Upon receiving a message with type server_hello, implementations MUST first examine the Random value and, if it matches this value, process it as described in Section 4.1.4).","For reasons of backward compatibility with middleboxes (see Appendix D.4), the HelloRetryRequest message uses the same structure as the ServerHello, but with Random set to the special value of the SHA-256 of ""HelloRetryRequest"":",TLS 1.3 has a downgrade protection mechanism embedded in the server's random value. TLS 1.3 servers which negotiate TLS 1.2 or below in response to a ClientHello MUST set the last 8 bytes of their Random value specially in their ServerHello.,4.1.3,Server Hello,3,10,1,MUST
TLS 1.3 servers which negotiate TLS 1.2 or below in response to a ClientHello MUST set the last 8 bytes of their Random value specially in their ServerHello.,TLS 1.3 servers negotiating TLS 1.2 or below in response to a ClientHello,Set the last 8 bytes of their Random value specially in their ServerHello,MUST,TLS 1.3 has a downgrade protection mechanism embedded in the server's random value. TLS 1.3 servers which negotiate TLS 1.2 or below in response to a ClientHello MUST set the last 8 bytes of their Random value specially in their ServerHello.,"Upon receiving a message with type server_hello, implementations MUST first examine the Random value and, if it matches this value, process it as described in Section 4.1.4).","If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of their Random value to the bytes:",4.1.3,Server Hello,3,11,2,MUST
"If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of their Random value to the bytes:",Negotiation of TLS 1.2 (i.e. when TLS 1.3 servers are negotiating TLS 1.2),TLS 1.3 servers MUST set the last 8 bytes of their Random value to the specified bytes.,MUST,"If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of their Random value to the bytes:",TLS 1.3 has a downgrade protection mechanism embedded in the server's random value. TLS 1.3 servers which negotiate TLS 1.2 or below in response to a ClientHello MUST set the last 8 bytes of their Random value specially in their ServerHello.,"If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2 servers SHOULD, set the last 8 bytes of their ServerHello.Random value to the bytes:",4.1.3,Server Hello,3,12,1,MUST
"If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2 servers SHOULD, set the last 8 bytes of their ServerHello.Random value to the bytes:",Negotiation is taking place using TLS 1.1 or below,"TLS 1.3 servers MUST set the last 8 bytes of their ServerHello.Random value to the specified byte sequence, and TLS 1.2 servers SHOULD do the same.","MUST, SHOULD","If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2 servers SHOULD, set the last 8 bytes of their ServerHello.Random value to the bytes:","If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of their Random value to the bytes:","TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below MUST check that the last 8 bytes are not equal to either of these values. TLS 1.2 clients SHOULD also check that the last 8 bytes are not equal to the second value if the ServerHello indicates TLS 1.1 or below. If a match is found, the client MUST abort the handshake with an ""illegal_parameter"" alert. This mechanism provides limited protection against downgrade attacks over and above what is provided by the Finished exchange: because the ServerKeyExchange, a message present in TLS 1.2 and below, includes a signature over both random values, it is not possible for an active attacker to modify the",4.1.3,Server Hello,3,13,1,MUST
TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below MUST check that the last 8 bytes are not equal to either of these values.,TLS 1.3 clients receive a ServerHello message that indicates a TLS version of 1.2 or below,The client MUST check that the last 8 bytes of the ServerHello are not equal to either of the specified values,MUST,"TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below MUST check that the last 8 bytes are not equal to either of these values. TLS 1.2 clients SHOULD also check that the last 8 bytes are not equal to the second value if the ServerHello indicates TLS 1.1 or below. If a match is found, the client MUST abort the handshake with an ""illegal_parameter"" alert. This mechanism provides limited protection against downgrade attacks over and above what is provided by the Finished exchange: because the ServerKeyExchange, a message present in TLS 1.2 and below, includes a signature over both random values, it is not possible for an active attacker to modify the","If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2 servers SHOULD, set the last 8 bytes of their ServerHello.Random value to the bytes:",random values without detection as long as ephemeral ciphers are used. It does not provide downgrade protection when static RSA is used.,4.1.3,Server Hello,3,14,1,MUST
TLS 1.2 clients SHOULD also check that the last 8 bytes are not equal to the second value if the ServerHello indicates TLS 1.1 or below.,When the ServerHello indicates TLS 1.1 or below.,TLS 1.2 clients SHOULD check that the last 8 bytes of the ServerHello.Random value are not equal to the second value.,SHOULD,"TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below MUST check that the last 8 bytes are not equal to either of these values. TLS 1.2 clients SHOULD also check that the last 8 bytes are not equal to the second value if the ServerHello indicates TLS 1.1 or below. If a match is found, the client MUST abort the handshake with an ""illegal_parameter"" alert. This mechanism provides limited protection against downgrade attacks over and above what is provided by the Finished exchange: because the ServerKeyExchange, a message present in TLS 1.2 and below, includes a signature over both random values, it is not possible for an active attacker to modify the","If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2 servers SHOULD, set the last 8 bytes of their ServerHello.Random value to the bytes:",random values without detection as long as ephemeral ciphers are used. It does not provide downgrade protection when static RSA is used.,4.1.3,Server Hello,3,14,2,SHOULD
"If a match is found, the client MUST abort the handshake with an ""illegal_parameter"" alert.","A match is found (i.e., the last 8 bytes of the ServerHello.Random value equal one of the specified prohibited values).","The client MUST abort the handshake with an ""illegal_parameter"" alert.",MUST,"TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below MUST check that the last 8 bytes are not equal to either of these values. TLS 1.2 clients SHOULD also check that the last 8 bytes are not equal to the second value if the ServerHello indicates TLS 1.1 or below. If a match is found, the client MUST abort the handshake with an ""illegal_parameter"" alert. This mechanism provides limited protection against downgrade attacks over and above what is provided by the Finished exchange: because the ServerKeyExchange, a message present in TLS 1.2 and below, includes a signature over both random values, it is not possible for an active attacker to modify the","If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2 servers SHOULD, set the last 8 bytes of their ServerHello.Random value to the bytes:",random values without detection as long as ephemeral ciphers are used. It does not provide downgrade protection when static RSA is used.,4.1.3,Server Hello,3,14,3,MUST
"A legacy TLS client performing renegotiation with TLS 1.2 or prior and which receives a TLS 1.3 ServerHello during renegotiation MUST abort the handshake with a ""protocol_version"" alert.","Legacy TLS client performing renegotiation with TLS 1.2 or prior,Receipt of a TLS 1.3 ServerHello during renegotiation",Abort the handshake with a 'protocol_version' alert,MUST,"A legacy TLS client performing renegotiation with TLS 1.2 or prior and which receives a TLS 1.3 ServerHello during renegotiation MUST abort the handshake with a ""protocol_version"" alert. Note that renegotiation is not possible when TLS 1.3 has been negotiated.","Note: This is a change from [RFC5246], so in practice many TLS 1.2 clients and servers will not behave as specified above.",,4.1.3,Server Hello,3,17,1,MUST
"The server's extensions MUST contain ""supported_versions""",When the server is constructing its extensions for a HelloRetryRequest message,The server's extensions MUST contain 'supported_versions',MUST,"The server's extensions MUST contain ""supported_versions"". Additionally, it SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair. As with the ServerHello, a HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the ""cookie"" (see Section 4.2.2) extension.","The server will send this message in response to a ClientHello message if it is able to find an acceptable set of parameters but the ClientHello does not contain sufficient information to proceed with the handshake. As discussed in Section 4.1.3, the HelloRetryRequest has the same format as a ServerHello message, and the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method fields have the same meaning. However, for convenience we discuss ""HelloRetryRequest"" throughout this document as if it were a distinct message.","Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using ""supported_versions"". Clients MUST abort the handshake with an ""illegal_parameter"" alert if the HelloRetryRequest would not result in any change in the ClientHello. If a client receives a second HelloRetryRequest in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest), it MUST abort the handshake with an ""unexpected_message"" alert.",4.1.4,Hello Retry Request,3,2,1,MUST
"Additionally, it SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair.",When the server constructs a HelloRetryRequest in response to a ClientHello that lacks sufficient information to proceed with the handshake,The HelloRetryRequest SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair,SHOULD,"The server's extensions MUST contain ""supported_versions"". Additionally, it SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair. As with the ServerHello, a HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the ""cookie"" (see Section 4.2.2) extension.","The server will send this message in response to a ClientHello message if it is able to find an acceptable set of parameters but the ClientHello does not contain sufficient information to proceed with the handshake. As discussed in Section 4.1.3, the HelloRetryRequest has the same format as a ServerHello message, and the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method fields have the same meaning. However, for convenience we discuss ""HelloRetryRequest"" throughout this document as if it were a distinct message.","Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using ""supported_versions"". Clients MUST abort the handshake with an ""illegal_parameter"" alert if the HelloRetryRequest would not result in any change in the ClientHello. If a client receives a second HelloRetryRequest in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest), it MUST abort the handshake with an ""unexpected_message"" alert.",4.1.4,Hello Retry Request,3,2,2,SHOULD
"As with the ServerHello, a HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the ""cookie"" (see Section 4.2.2) extension.","When constructing a HelloRetryRequest message, the server considers the extensions to be included, verifying which ones were offered by the client in its ClientHello.","The HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, except for the optional 'cookie' extension.",MUST NOT,"The server's extensions MUST contain ""supported_versions"". Additionally, it SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair. As with the ServerHello, a HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the ""cookie"" (see Section 4.2.2) extension.","The server will send this message in response to a ClientHello message if it is able to find an acceptable set of parameters but the ClientHello does not contain sufficient information to proceed with the handshake. As discussed in Section 4.1.3, the HelloRetryRequest has the same format as a ServerHello message, and the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method fields have the same meaning. However, for convenience we discuss ""HelloRetryRequest"" throughout this document as if it were a distinct message.","Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using ""supported_versions"". Clients MUST abort the handshake with an ""illegal_parameter"" alert if the HelloRetryRequest would not result in any change in the ClientHello. If a client receives a second HelloRetryRequest in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest), it MUST abort the handshake with an ""unexpected_message"" alert.",4.1.4,Hello Retry Request,3,2,3,MUST
"Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using ""supported_versions"".",Receipt of a HelloRetryRequest,"The client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3, and then process the extensions, starting with determining the version using 'supported_versions'",MUST,"Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using ""supported_versions"". Clients MUST abort the handshake with an ""illegal_parameter"" alert if the HelloRetryRequest would not result in any change in the ClientHello. If a client receives a second HelloRetryRequest in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest), it MUST abort the handshake with an ""unexpected_message"" alert.","The server's extensions MUST contain ""supported_versions"". Additionally, it SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair. As with the ServerHello, a HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the ""cookie"" (see Section 4.2.2) extension.","Otherwise, the client MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello. The HelloRetryRequest extensions defined in this specification are:",4.1.4,Hello Retry Request,3,3,1,MUST
"Clients MUST abort the handshake with an ""illegal_parameter"" alert if the HelloRetryRequest would not result in any change in the ClientHello.",The HelloRetryRequest would not result in any change in the ClientHello.,Clients MUST abort the handshake with an 'illegal_parameter' alert.,MUST,"Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using ""supported_versions"". Clients MUST abort the handshake with an ""illegal_parameter"" alert if the HelloRetryRequest would not result in any change in the ClientHello. If a client receives a second HelloRetryRequest in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest), it MUST abort the handshake with an ""unexpected_message"" alert.","The server's extensions MUST contain ""supported_versions"". Additionally, it SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair. As with the ServerHello, a HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the ""cookie"" (see Section 4.2.2) extension.","Otherwise, the client MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello. The HelloRetryRequest extensions defined in this specification are:",4.1.4,Hello Retry Request,3,3,2,MUST
"If a client receives a second HelloRetryRequest in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest), it MUST abort the handshake with an ""unexpected_message"" alert.","A client receives a second HelloRetryRequest in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest)",The client MUST abort the handshake with an 'unexpected_message' alert,MUST,"Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using ""supported_versions"". Clients MUST abort the handshake with an ""illegal_parameter"" alert if the HelloRetryRequest would not result in any change in the ClientHello. If a client receives a second HelloRetryRequest in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest), it MUST abort the handshake with an ""unexpected_message"" alert.","The server's extensions MUST contain ""supported_versions"". Additionally, it SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair. As with the ServerHello, a HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the ""cookie"" (see Section 4.2.2) extension.","Otherwise, the client MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello. The HelloRetryRequest extensions defined in this specification are:",4.1.4,Hello Retry Request,3,3,3,MUST
"Otherwise, the client MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello.","The client has received a HelloRetryRequest that has passed prior validations (i.e. its legacy_version, legacy_session_id_echo, cipher_suite, legacy_compression_method, and extensions checks) and does not trigger an abort (such as when the HelloRetryRequest would not result in any change in the ClientHello or when it is not a repeated HelloRetryRequest in the same connection).",Process all extensions in the HelloRetryRequest and send a second updated ClientHello.,MUST,"Otherwise, the client MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello. The HelloRetryRequest extensions defined in this specification are:","Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using ""supported_versions"". Clients MUST abort the handshake with an ""illegal_parameter"" alert if the HelloRetryRequest would not result in any change in the ClientHello. If a client receives a second HelloRetryRequest in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest), it MUST abort the handshake with an ""unexpected_message"" alert.",-supported_versions (see Section 4.2.1),4.1.4,Hello Retry Request,3,4,1,MUST
A client which receives a cipher suite that was not offered MUST abort the handshake.,A client receives a cipher suite that was not offered.,The client MUST abort the handshake.,MUST,"A client which receives a cipher suite that was not offered MUST abort the handshake. Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello (if the server selects the cipher suite as the first step in the negotiation, then this will happen automatically). Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an ""illegal_parameter"" alert.",-key_share (see Section 4.2.8),"In addition, in its updated ClientHello, the client SHOULD NOT offer any pre-shared keys associated with a hash other than that of the selected cipher suite. This allows the client to avoid having to compute partial hash transcripts for multiple hashes in the second ClientHello.",4.1.4,Hello Retry Request,3,8,1,MUST
"Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello (if the server selects the cipher suite as the first step in the negotiation, then this will happen automatically).",When a server receives a conformant updated ClientHello,The server MUST ensure that the negotiated cipher suite remains the same as the one indicated in the updated ClientHello,MUST,"A client which receives a cipher suite that was not offered MUST abort the handshake. Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello (if the server selects the cipher suite as the first step in the negotiation, then this will happen automatically). Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an ""illegal_parameter"" alert.",-key_share (see Section 4.2.8),"In addition, in its updated ClientHello, the client SHOULD NOT offer any pre-shared keys associated with a hash other than that of the selected cipher suite. This allows the client to avoid having to compute partial hash transcripts for multiple hashes in the second ClientHello.",4.1.4,Hello Retry Request,3,8,2,MUST
"Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an ""illegal_parameter"" alert.",Upon receiving the ServerHello,"Clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and, if not, abort the handshake with an 'illegal_parameter' alert.",MUST,"A client which receives a cipher suite that was not offered MUST abort the handshake. Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello (if the server selects the cipher suite as the first step in the negotiation, then this will happen automatically). Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an ""illegal_parameter"" alert.",-key_share (see Section 4.2.8),"In addition, in its updated ClientHello, the client SHOULD NOT offer any pre-shared keys associated with a hash other than that of the selected cipher suite. This allows the client to avoid having to compute partial hash transcripts for multiple hashes in the second ClientHello.",4.1.4,Hello Retry Request,3,8,3,MUST
"In addition, in its updated ClientHello, the client SHOULD NOT offer any pre-shared keys associated with a hash other than that of the selected cipher suite.",When the client constructs and sends an updated ClientHello message.,The client SHOULD NOT offer any pre-shared keys that are associated with a hash other than that of the selected cipher suite.,SHOULD NOT,"In addition, in its updated ClientHello, the client SHOULD NOT offer any pre-shared keys associated with a hash other than that of the selected cipher suite. This allows the client to avoid having to compute partial hash transcripts for multiple hashes in the second ClientHello.","A client which receives a cipher suite that was not offered MUST abort the handshake. Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello (if the server selects the cipher suite as the first step in the negotiation, then this will happen automatically). Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an ""illegal_parameter"" alert.","The value of selected_version in the HelloRetryRequest ""supported_versions"" extension MUST be retained in the ServerHello, and a client MUST abort the handshake with an ""illegal_parameter"" alert if the value changes.",4.1.4,Hello Retry Request,3,9,1,SHOULD
"The value of selected_version in the HelloRetryRequest ""supported_versions"" extension MUST be retained in the ServerHello, and a client MUST abort the handshake with an ""illegal_parameter"" alert if the value changes.","If the value of selected_version in the HelloRetryRequest ""supported_versions"" extension is not retained in the ServerHello (i.e. it changes)","The server MUST retain the selected_version value from the HelloRetryRequest in the ServerHello.,The client MUST abort the handshake with an ""illegal_parameter"" alert if the value changes.",MUST,"The value of selected_version in the HelloRetryRequest ""supported_versions"" extension MUST be retained in the ServerHello, and a client MUST abort the handshake with an ""illegal_parameter"" alert if the value changes.","In addition, in its updated ClientHello, the client SHOULD NOT offer any pre-shared keys associated with a hash other than that of the selected cipher suite. This allows the client to avoid having to compute partial hash transcripts for multiple hashes in the second ClientHello.",,4.1.4,Hello Retry Request,3,10,1,MUST
The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message.,When the server constructs and sends a CertificateRequest message that includes extension requests (thereby offering an optional response opportunity for the client).,The server sends extension requests in the CertificateRequest message.,MAY,"Extensions are generally structured in a request/response fashion, though some extensions are just indications with no corresponding response. The client sends its extension requests in the ClientHello message, and the server sends its extension responses in the ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate messages. The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message. The server MAY also send unsolicited extensions in the NewSessionTicket, though the client does not respond directly to these.",The list of extension types is maintained by IANA as described in Section 11.,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest. Upon receiving such an extension, an endpoint MUST abort the handshake with an ""unsupported_extension"" alert.",4.2,Extensions,2,6,3,MAY
"The server MAY also send unsolicited extensions in the NewSessionTicket, though the client does not respond directly to these.",When the server is sending a NewSessionTicket message.,"The server MAY include unsolicited extensions in the NewSessionTicket message, and the client does not directly respond to these unsolicited extensions.",MAY,"Extensions are generally structured in a request/response fashion, though some extensions are just indications with no corresponding response. The client sends its extension requests in the ClientHello message, and the server sends its extension responses in the ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate messages. The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message. The server MAY also send unsolicited extensions in the NewSessionTicket, though the client does not respond directly to these.",The list of extension types is maintained by IANA as described in Section 11.,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest. Upon receiving such an extension, an endpoint MUST abort the handshake with an ""unsupported_extension"" alert.",4.2,Extensions,2,6,4,MAY
"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest.",The remote endpoint did not send the corresponding extension request for an extension (excluding the case of the 'cookie' extension in the HelloRetryRequest),Implementations MUST NOT send extension responses under these conditions,MUST NOT,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest. Upon receiving such an extension, an endpoint MUST abort the handshake with an ""unsupported_extension"" alert.","Extensions are generally structured in a request/response fashion, though some extensions are just indications with no corresponding response. The client sends its extension requests in the ClientHello message, and the server sends its extension responses in the ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate messages. The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message. The server MAY also send unsolicited extensions in the NewSessionTicket, though the client does not respond directly to these.","The table below indicates the messages where a given extension may appear, using the following notation: CH (ClientHello), SH (ServerHello), EE (EncryptedExtensions), CT (Certificate), CR (CertificateRequest), NST (NewSessionTicket), and HRR (HelloRetryRequest). If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an ""illegal_parameter"" alert.",4.2,Extensions,2,7,1,MUST
"Upon receiving such an extension, an endpoint MUST abort the handshake with an ""unsupported_extension"" alert.","An endpoint receives an unsolicited extension response (i.e., a response for an extension that was not previously requested, excluding the 'cookie' extension in the HelloRetryRequest).",Abort the handshake with an 'unsupported_extension' alert.,MUST,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest. Upon receiving such an extension, an endpoint MUST abort the handshake with an ""unsupported_extension"" alert.","Extensions are generally structured in a request/response fashion, though some extensions are just indications with no corresponding response. The client sends its extension requests in the ClientHello message, and the server sends its extension responses in the ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate messages. The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message. The server MAY also send unsolicited extensions in the NewSessionTicket, though the client does not respond directly to these.","The table below indicates the messages where a given extension may appear, using the following notation: CH (ClientHello), SH (ServerHello), EE (EncryptedExtensions), CT (Certificate), CR (CertificateRequest), NST (NewSessionTicket), and HRR (HelloRetryRequest). If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an ""illegal_parameter"" alert.",4.2,Extensions,2,7,2,MUST
"If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an ""illegal_parameter"" alert.","An implementation receives an extension which it recognizes,The extension is not specified for the message in which it appears",The implementation MUST abort the handshake with an 'illegal_parameter' alert,MUST,"The table below indicates the messages where a given extension may appear, using the following notation: CH (ClientHello), SH (ServerHello), EE (EncryptedExtensions), CT (Certificate), CR (CertificateRequest), NST (NewSessionTicket), and HRR (HelloRetryRequest). If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an ""illegal_parameter"" alert.","Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest. Upon receiving such an extension, an endpoint MUST abort the handshake with an ""unsupported_extension"" alert.","+--------------------------------------------------+-------------+ | Extension | TLS 1.3 | +--------------------------------------------------+-------------+ | server_name [RFC6066] | CH, EE | | | | | max_fragment_length [RFC6066] | CH, EE | | | | | status_request [RFC6066] | CH, CR, CT | | | | | supported_groups [RFC7919] | CH, EE | | | | | signature_algorithms (RFC 8446) | CH, CR | | | | | use_srtp [RFC5764] | CH, EE | | | | | heartbeat [RFC6520] | CH, EE | | | | | application_layer_protocol_negotiation [RFC7301] | CH, EE | | | | | signed_certificate_timestamp [RFC6962] | CH, CR, CT | | | | | client_certificate_type [RFC7250] | CH, EE | | | | | server_certificate_type [RFC7250] | CH, EE | | | | | padding [RFC7685] | CH | | | | | key_share (RFC 8446) | CH, SH, HRR | | | | | pre_shared_key (RFC 8446) | CH, SH | | | | | psk_key_exchange_modes (RFC 8446) | CH | | | | | early_data (RFC 8446) | CH, EE, NST | | | | | cookie (RFC 8446) | CH, HRR | | | | | supported_versions (RFC 8446) | CH, SH, HRR | | | | | certificate_authorities (RFC 8446) | CH, CR | | | | | oid_filters (RFC 8446) | CR | | | | | post_handshake_auth (RFC 8446) | CH | | | | | signature_algorithms_cert (RFC 8446) | CH, CR | +--------------------------------------------------+-------------+",4.2,Extensions,2,8,2,MUST
"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).","Multiple extensions of different types are present in an extension block.,Specifically, in the ClientHello, if the 'pre_shared_key' extension is present.","Extensions MAY appear in any order, except that in the ClientHello the 'pre_shared_key' extension MUST be the last extension. In the ServerHello extensions block, 'pre_shared_key' may appear anywhere.,There MUST NOT be more than one extension of the same type in a given extension block.","MUST, MAY","When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block). There MUST NOT be more than one extension of the same type in a given extension block.","+--------------------------------------------------+-------------+ | Extension | TLS 1.3 | +--------------------------------------------------+-------------+ | server_name [RFC6066] | CH, EE | | | | | max_fragment_length [RFC6066] | CH, EE | | | | | status_request [RFC6066] | CH, CR, CT | | | | | supported_groups [RFC7919] | CH, EE | | | | | signature_algorithms (RFC 8446) | CH, CR | | | | | use_srtp [RFC5764] | CH, EE | | | | | heartbeat [RFC6520] | CH, EE | | | | | application_layer_protocol_negotiation [RFC7301] | CH, EE | | | | | signed_certificate_timestamp [RFC6962] | CH, CR, CT | | | | | client_certificate_type [RFC7250] | CH, EE | | | | | server_certificate_type [RFC7250] | CH, EE | | | | | padding [RFC7685] | CH | | | | | key_share (RFC 8446) | CH, SH, HRR | | | | | pre_shared_key (RFC 8446) | CH, SH | | | | | psk_key_exchange_modes (RFC 8446) | CH | | | | | early_data (RFC 8446) | CH, EE, NST | | | | | cookie (RFC 8446) | CH, HRR | | | | | supported_versions (RFC 8446) | CH, SH, HRR | | | | | certificate_authorities (RFC 8446) | CH, CR | | | | | oid_filters (RFC 8446) | CR | | | | | post_handshake_auth (RFC 8446) | CH | | | | | signature_algorithms_cert (RFC 8446) | CH, CR | +--------------------------------------------------+-------------+","In TLS 1.3, unlike TLS 1.2, extensions are negotiated for each handshake even when in resumption-PSK mode. However, 0-RTT parameters are those negotiated in the previous handshake; mismatches may require rejecting 0-RTT (see Section 4.2.10).",4.2,Extensions,2,10,1,MUST
There MUST NOT be more than one extension of the same type in a given extension block.,A given extension block that may contain multiple extensions,Ensure that no extension block contains more than one extension of the same type,MUST NOT,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block). There MUST NOT be more than one extension of the same type in a given extension block.","+--------------------------------------------------+-------------+ | Extension | TLS 1.3 | +--------------------------------------------------+-------------+ | server_name [RFC6066] | CH, EE | | | | | max_fragment_length [RFC6066] | CH, EE | | | | | status_request [RFC6066] | CH, CR, CT | | | | | supported_groups [RFC7919] | CH, EE | | | | | signature_algorithms (RFC 8446) | CH, CR | | | | | use_srtp [RFC5764] | CH, EE | | | | | heartbeat [RFC6520] | CH, EE | | | | | application_layer_protocol_negotiation [RFC7301] | CH, EE | | | | | signed_certificate_timestamp [RFC6962] | CH, CR, CT | | | | | client_certificate_type [RFC7250] | CH, EE | | | | | server_certificate_type [RFC7250] | CH, EE | | | | | padding [RFC7685] | CH | | | | | key_share (RFC 8446) | CH, SH, HRR | | | | | pre_shared_key (RFC 8446) | CH, SH | | | | | psk_key_exchange_modes (RFC 8446) | CH | | | | | early_data (RFC 8446) | CH, EE, NST | | | | | cookie (RFC 8446) | CH, HRR | | | | | supported_versions (RFC 8446) | CH, SH, HRR | | | | | certificate_authorities (RFC 8446) | CH, CR | | | | | oid_filters (RFC 8446) | CR | | | | | post_handshake_auth (RFC 8446) | CH | | | | | signature_algorithms_cert (RFC 8446) | CH, CR | +--------------------------------------------------+-------------+","In TLS 1.3, unlike TLS 1.2, extensions are negotiated for each handshake even when in resumption-PSK mode. However, 0-RTT parameters are those negotiated in the previous handshake; mismatches may require rejecting 0-RTT (see Section 4.2.10).",4.2,Extensions,2,10,2,MUST
"Implementations of this specification MUST send this extension in the ClientHello containing all versions of TLS which they are prepared to negotiate (for this specification, that means minimally 0x0304, but if previous versions of TLS are allowed to be negotiated, they MUST be present as well).",When a client is initiating a TLS handshake by sending the ClientHello message,"The implementation MUST include the supported_versions extension in the ClientHello, containing all versions of TLS it is prepared to negotiate (at a minimum 0x0304, and any previous versions if they are allowed)",MUST,"The ""supported_versions"" extension is used by the client to indicate which versions of TLS it supports and by the server to indicate which version it is using. The extension contains a list of supported versions in preference order, with the most preferred version first. Implementations of this specification MUST send this extension in the ClientHello containing all versions of TLS which they are prepared to negotiate (for this specification, that means minimally 0x0304, but if previous versions of TLS are allowed to be negotiated, they MUST be present as well).",,"If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later. Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.",4.2.1,Supported Versions,3,1,3,MUST
"If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later.","The supported_versions extension is not present in the ClientHello.,The ClientHello.legacy_version may be 0x0304 or later.",Servers that are compliant with the specification and support TLS 1.2 MUST negotiate TLS 1.2 or an earlier version as specified in RFC5246.,MUST,"If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later. Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.","The ""supported_versions"" extension is used by the client to indicate which versions of TLS it supports and by the server to indicate which version it is using. The extension contains a list of supported versions in preference order, with the most preferred version first. Implementations of this specification MUST send this extension in the ClientHello containing all versions of TLS which they are prepared to negotiate (for this specification, that means minimally 0x0304, but if previous versions of TLS are allowed to be negotiated, they MUST be present as well).","If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension. Note that this mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.",4.2.1,Supported Versions,3,2,1,MUST
Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.,Receiving a ClientHello message where the legacy_version field is 0x0304 or later.,Servers MAY abort the handshake.,MAY,"If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later. Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.","The ""supported_versions"" extension is used by the client to indicate which versions of TLS it supports and by the server to indicate which version it is using. The extension contains a list of supported versions in preference order, with the most preferred version first. Implementations of this specification MUST send this extension in the ClientHello containing all versions of TLS which they are prepared to negotiate (for this specification, that means minimally 0x0304, but if previous versions of TLS are allowed to be negotiated, they MUST be present as well).","If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension. Note that this mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.",4.2.1,Supported Versions,3,2,2,MAY
"If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences.",The extension is present in the ClientHello message.,"Servers MUST NOT use the ClientHello.legacy_version value for version negotiation.,Servers MUST use only the 'supported_versions' extension to determine client preferences.",MUST NOT,"If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension. Note that this mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.","If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later. Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.","A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension. A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2). Clients MUST check for this extension prior to processing the rest of the ServerHello (although they will have to",4.2.1,Supported Versions,3,3,1,MUST
Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension.,"When the supported_versions extension is present in the ClientHello message, including cases where the extension lists versions (some of which may be unknown).",The server MUST select only a TLS version that is explicitly present in the supported_versions extension and MUST ignore any unknown versions in that extension.,MUST,"If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension. Note that this mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.","If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later. Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.","A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension. A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2). Clients MUST check for this extension prior to processing the rest of the ServerHello (although they will have to",4.2.1,Supported Versions,3,3,2,MUST
Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2.,Implementations of TLS 1.3 that choose to support prior versions of TLS,They SHOULD support TLS 1.2,SHOULD,"If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension. Note that this mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.","If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later. Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.","A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension. A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2). Clients MUST check for this extension prior to processing the rest of the ServerHello (although they will have to",4.2.1,Supported Versions,3,3,4,SHOULD
Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.,A ClientHello that includes the specified extension but does not include 0x0304 in its list of versions.,Servers MUST be prepared to receive such ClientHello messages.,MUST,"If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension. Note that this mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.","If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later. Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.","A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension. A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2). Clients MUST check for this extension prior to processing the rest of the ServerHello (although they will have to",4.2.1,Supported Versions,3,3,5,MUST
"A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension.",Server negotiates a version of TLS prior to TLS 1.3,"Set ServerHello.version,Do not send the 'supported_versions' extension","MUST, MUST NOT","A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension. A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2). Clients MUST check for this extension prior to processing the rest of the ServerHello (although they will have to","If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension. Note that this mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.","parse the ServerHello in order to read the extension). If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the ""supported_versions"" extension to determine the selected version. If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an ""illegal_parameter"" alert.",4.2.1,Supported Versions,3,4,1,MUST
"A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304).",The server negotiates TLS 1.3.,The server MUST respond by sending a 'supported_versions' extension containing the selected version value (0x0304).,MUST,"A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension. A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2). Clients MUST check for this extension prior to processing the rest of the ServerHello (although they will have to","If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension. Note that this mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.","parse the ServerHello in order to read the extension). If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the ""supported_versions"" extension to determine the selected version. If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an ""illegal_parameter"" alert.",4.2.1,Supported Versions,3,4,2,MUST
It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2).,The server negotiates TLS 1.3 and responds by sending a 'supported_versions' extension.,The server MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2).,MUST,"A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension. A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2). Clients MUST check for this extension prior to processing the rest of the ServerHello (although they will have to","If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension. Note that this mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.","parse the ServerHello in order to read the extension). If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the ""supported_versions"" extension to determine the selected version. If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an ""illegal_parameter"" alert.",4.2.1,Supported Versions,3,4,3,MUST
Clients MUST check for this extension prior to processing the rest of the ServerHello (although they will have to,"When a client begins processing a ServerHello message (i.e., before processing the remainder of the ServerHello)",The client MUST check for the presence of the supported_versions extension in the ServerHello,MUST,"A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension. A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2). Clients MUST check for this extension prior to processing the rest of the ServerHello (although they will have to","If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension. Note that this mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.","parse the ServerHello in order to read the extension). If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the ""supported_versions"" extension to determine the selected version. If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an ""illegal_parameter"" alert.",4.2.1,Supported Versions,3,4,4,MUST
"If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the ""supported_versions"" extension to determine the selected version.",The 'supported_versions' extension is present in the ServerHello message.,"Clients MUST ignore the ServerHello.legacy_version value.,Clients MUST use only the 'supported_versions' extension to determine the selected version.",MUST,"parse the ServerHello in order to read the extension). If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the ""supported_versions"" extension to determine the selected version. If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an ""illegal_parameter"" alert.","A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension. A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2). Clients MUST check for this extension prior to processing the rest of the ServerHello (although they will have to",,4.2.1,Supported Versions,3,5,2,MUST
"If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an ""illegal_parameter"" alert.","The 'supported_versions' extension in the ServerHello contains a version not offered by the client, or contains a version prior to TLS 1.3.",The client MUST abort the handshake with an 'illegal_parameter' alert.,MUST,"parse the ServerHello in order to read the extension). If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the ""supported_versions"" extension to determine the selected version. If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an ""illegal_parameter"" alert.","A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the ""supported_versions"" extension. A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2). Clients MUST check for this extension prior to processing the rest of the ServerHello (although they will have to",,4.2.1,Supported Versions,3,5,3,MUST
"When sending a HelloRetryRequest, the server MAY provide a ""cookie"" extension to the client (this is an exception to the usual rule that the only extensions that may be sent are those that appear in the ClientHello).",When sending a HelloRetryRequest,The server MAY provide a 'cookie' extension to the client,MAY,"When sending a HelloRetryRequest, the server MAY provide a ""cookie"" extension to the client (this is an exception to the usual rule that the only extensions that may be sent are those that appear in the ClientHello). When sending the new ClientHello, the client MUST copy the contents of the extension received in the HelloRetryRequest into a ""cookie"" extension in the new ClientHello. Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.","-Allowing the server to offload state to the client, thus allowing it to send a HelloRetryRequest without storing any state. The server can do this by storing the hash of the ClientHello in the HelloRetryRequest cookie (protected with some suitable integrity protection algorithm).","When a server is operating statelessly, it may receive an unprotected record of type change_cipher_spec between the first and second ClientHello (see Section 5). Since the server is not storing any state, this will appear as if it were the first message to be received. Servers operating statelessly MUST ignore these records.",4.2.2,Cookie,3,4,1,MAY
"When sending the new ClientHello, the client MUST copy the contents of the extension received in the HelloRetryRequest into a ""cookie"" extension in the new ClientHello.",When the client is sending a new ClientHello after receiving a HelloRetryRequest containing a cookie extension,The client MUST copy the contents of the extension received in the HelloRetryRequest into a 'cookie' extension in the new ClientHello,MUST,"When sending a HelloRetryRequest, the server MAY provide a ""cookie"" extension to the client (this is an exception to the usual rule that the only extensions that may be sent are those that appear in the ClientHello). When sending the new ClientHello, the client MUST copy the contents of the extension received in the HelloRetryRequest into a ""cookie"" extension in the new ClientHello. Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.","-Allowing the server to offload state to the client, thus allowing it to send a HelloRetryRequest without storing any state. The server can do this by storing the hash of the ClientHello in the HelloRetryRequest cookie (protected with some suitable integrity protection algorithm).","When a server is operating statelessly, it may receive an unprotected record of type change_cipher_spec between the first and second ClientHello (see Section 5). Since the server is not storing any state, this will appear as if it were the first message to be received. Servers operating statelessly MUST ignore these records.",4.2.2,Cookie,3,4,2,MUST
Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.,When sending an initial ClientHello as part of a subsequent connection.,Clients MUST NOT use cookies in the initial ClientHello.,MUST NOT,"When sending a HelloRetryRequest, the server MAY provide a ""cookie"" extension to the client (this is an exception to the usual rule that the only extensions that may be sent are those that appear in the ClientHello). When sending the new ClientHello, the client MUST copy the contents of the extension received in the HelloRetryRequest into a ""cookie"" extension in the new ClientHello. Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.","-Allowing the server to offload state to the client, thus allowing it to send a HelloRetryRequest without storing any state. The server can do this by storing the hash of the ClientHello in the HelloRetryRequest cookie (protected with some suitable integrity protection algorithm).","When a server is operating statelessly, it may receive an unprotected record of type change_cipher_spec between the first and second ClientHello (see Section 5). Since the server is not storing any state, this will appear as if it were the first message to be received. Servers operating statelessly MUST ignore these records.",4.2.2,Cookie,3,4,3,MUST
Servers operating statelessly MUST ignore these records.,When a server operating statelessly receives an unprotected record of type change_cipher_spec between the first and second ClientHello messages,The server MUST ignore these records,MUST,"When a server is operating statelessly, it may receive an unprotected record of type change_cipher_spec between the first and second ClientHello (see Section 5). Since the server is not storing any state, this will appear as if it were the first message to be received. Servers operating statelessly MUST ignore these records.","When sending a HelloRetryRequest, the server MAY provide a ""cookie"" extension to the client (this is an exception to the usual rule that the only extensions that may be sent are those that appear in the ClientHello). When sending the new ClientHello, the client MUST copy the contents of the extension received in the HelloRetryRequest into a ""cookie"" extension in the new ClientHello. Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.",,4.2.2,Cookie,3,5,3,MUST
The keys found in certificates MUST also be of appropriate type for the signature algorithms they are used with.,When keys are found in certificates and are used with signature algorithms,The keys MUST be of an appropriate type for the signature algorithms they are used with,MUST,"TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures. The ""signature_algorithms_cert"" extension applies to signatures in certificates, and the ""signature_algorithms"" extension, which originally appeared in TLS 1.2, applies to signatures in CertificateVerify messages. The keys found in certificates MUST also be of appropriate type for the signature algorithms they are used with. This is a particular issue for RSA keys and PSS signatures, as described below. If no ""signature_algorithms_cert"" extension is present, then the ""signature_algorithms"" extension also applies to signatures appearing in certificates. Clients which desire the server to authenticate itself via a certificate MUST send the ""signature_algorithms"" extension. If a server is authenticating via a certificate and the client has not sent a ""signature_algorithms"" extension, then the server MUST abort the handshake with a ""missing_extension"" alert (see Section 9.2).",,"The ""signature_algorithms_cert"" extension was added to allow implementations which supported different sets of algorithms for certificates and in TLS itself to clearly signal their capabilities. TLS 1.2 implementations SHOULD also process this extension. Implementations which have the same policy in both cases MAY omit the ""signature_algorithms_cert"" extension.",4.2.3,Signature Algorithms,3,1,3,MUST
"Clients which desire the server to authenticate itself via a certificate MUST send the ""signature_algorithms"" extension.",Clients desire the server to authenticate itself via a certificate.,Clients MUST send the 'signature_algorithms' extension.,MUST,"TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures. The ""signature_algorithms_cert"" extension applies to signatures in certificates, and the ""signature_algorithms"" extension, which originally appeared in TLS 1.2, applies to signatures in CertificateVerify messages. The keys found in certificates MUST also be of appropriate type for the signature algorithms they are used with. This is a particular issue for RSA keys and PSS signatures, as described below. If no ""signature_algorithms_cert"" extension is present, then the ""signature_algorithms"" extension also applies to signatures appearing in certificates. Clients which desire the server to authenticate itself via a certificate MUST send the ""signature_algorithms"" extension. If a server is authenticating via a certificate and the client has not sent a ""signature_algorithms"" extension, then the server MUST abort the handshake with a ""missing_extension"" alert (see Section 9.2).",,"The ""signature_algorithms_cert"" extension was added to allow implementations which supported different sets of algorithms for certificates and in TLS itself to clearly signal their capabilities. TLS 1.2 implementations SHOULD also process this extension. Implementations which have the same policy in both cases MAY omit the ""signature_algorithms_cert"" extension.",4.2.3,Signature Algorithms,3,1,6,MUST
"If a server is authenticating via a certificate and the client has not sent a ""signature_algorithms"" extension, then the server MUST abort the handshake with a ""missing_extension"" alert (see Section 9.2).",The server is authenticating via a certificate and the client has not sent a 'signature_algorithms' extension.,The server MUST abort the handshake with a 'missing_extension' alert.,MUST,"TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures. The ""signature_algorithms_cert"" extension applies to signatures in certificates, and the ""signature_algorithms"" extension, which originally appeared in TLS 1.2, applies to signatures in CertificateVerify messages. The keys found in certificates MUST also be of appropriate type for the signature algorithms they are used with. This is a particular issue for RSA keys and PSS signatures, as described below. If no ""signature_algorithms_cert"" extension is present, then the ""signature_algorithms"" extension also applies to signatures appearing in certificates. Clients which desire the server to authenticate itself via a certificate MUST send the ""signature_algorithms"" extension. If a server is authenticating via a certificate and the client has not sent a ""signature_algorithms"" extension, then the server MUST abort the handshake with a ""missing_extension"" alert (see Section 9.2).",,"The ""signature_algorithms_cert"" extension was added to allow implementations which supported different sets of algorithms for certificates and in TLS itself to clearly signal their capabilities. TLS 1.2 implementations SHOULD also process this extension. Implementations which have the same policy in both cases MAY omit the ""signature_algorithms_cert"" extension.",4.2.3,Signature Algorithms,3,1,7,MUST
TLS 1.2 implementations SHOULD also process this extension,"For TLS 1.2 implementations, i.e. when operating under TLS 1.2.",Process the signature_algorithms_cert extension.,SHOULD,"The ""signature_algorithms_cert"" extension was added to allow implementations which supported different sets of algorithms for certificates and in TLS itself to clearly signal their capabilities. TLS 1.2 implementations SHOULD also process this extension. Implementations which have the same policy in both cases MAY omit the ""signature_algorithms_cert"" extension.","TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures. The ""signature_algorithms_cert"" extension applies to signatures in certificates, and the ""signature_algorithms"" extension, which originally appeared in TLS 1.2, applies to signatures in CertificateVerify messages. The keys found in certificates MUST also be of appropriate type for the signature algorithms they are used with. This is a particular issue for RSA keys and PSS signatures, as described below. If no ""signature_algorithms_cert"" extension is present, then the ""signature_algorithms"" extension also applies to signatures appearing in certificates. Clients which desire the server to authenticate itself via a certificate MUST send the ""signature_algorithms"" extension. If a server is authenticating via a certificate and the client has not sent a ""signature_algorithms"" extension, then the server MUST abort the handshake with a ""missing_extension"" alert (see Section 9.2).","The ""extension_data"" field of these extensions contains a SignatureSchemeList value:",4.2.3,Signature Algorithms,3,2,2,SHOULD
"Implementations which have the same policy in both cases MAY omit the ""signature_algorithms_cert"" extension.",Implementations which have the same policy in both cases,"MAY omit the ""signature_algorithms_cert"" extension",MAY,"The ""signature_algorithms_cert"" extension was added to allow implementations which supported different sets of algorithms for certificates and in TLS itself to clearly signal their capabilities. TLS 1.2 implementations SHOULD also process this extension. Implementations which have the same policy in both cases MAY omit the ""signature_algorithms_cert"" extension.","TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures. The ""signature_algorithms_cert"" extension applies to signatures in certificates, and the ""signature_algorithms"" extension, which originally appeared in TLS 1.2, applies to signatures in CertificateVerify messages. The keys found in certificates MUST also be of appropriate type for the signature algorithms they are used with. This is a particular issue for RSA keys and PSS signatures, as described below. If no ""signature_algorithms_cert"" extension is present, then the ""signature_algorithms"" extension also applies to signatures appearing in certificates. Clients which desire the server to authenticate itself via a certificate MUST send the ""signature_algorithms"" extension. If a server is authenticating via a certificate and the client has not sent a ""signature_algorithms"" extension, then the server MUST abort the handshake with a ""missing_extension"" alert (see Section 9.2).","The ""extension_data"" field of these extensions contains a SignatureSchemeList value:",4.2.3,Signature Algorithms,3,2,3,MAY
"These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2.",When a signature algorithm value is encountered that is used in a certificate (and may also appear in the signature_algorithms or signature_algorithms_cert fields for TLS 1.2 backward compatibility),Interpret and apply these signature algorithm values solely for certificate signatures and do not define or use them for signed TLS handshake messages,MAY,"RSASSA-PKCS1-v1_5 algorithms: Indicates a signature algorithm using RSASSA-PKCS1-v1_5 [RFC8017] with the corresponding hash algorithm as defined in [SHS]. These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2.","Each SignatureScheme value lists a single signature algorithm that the client is willing to verify. The values are indicated in descending order of preference. Note that a signature algorithm takes as input an arbitrary-length message, rather than a digest. Algorithms which traditionally act on a digest should be defined in TLS to first hash the input with a specified hash algorithm and then proceed as usual. The code point groups listed above have the following meanings:","ECDSA algorithms: Indicates a signature algorithm using ECDSA [ECDSA], the corresponding curve as defined in ANSI X9.62 [ECDSA] and FIPS 186-4 [DSS], and the corresponding hash algorithm as defined in [SHS]. The signature is represented as a DER-encoded [X690] ECDSA-Sig-Value structure.",4.2.3,Signature Algorithms,3,6,2,MAY
The length of the Salt MUST be equal to the length of the output of the digest algorithm.,"When using the RSASSA-PSS RSAE signature algorithm with mask generation function 1, where a salt is applied as part of the signature computation",The length of the Salt MUST be equal to the length of the output of the digest algorithm,MUST,"RSASSA-PSS RSAE algorithms: Indicates a signature algorithm using RSASSA-PSS [RFC8017] with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST be equal to the length of the output of the digest algorithm. If the public key is carried in an X.509 certificate, it MUST use the rsaEncryption OID [RFC5280].","ECDSA algorithms: Indicates a signature algorithm using ECDSA [ECDSA], the corresponding curve as defined in ANSI X9.62 [ECDSA] and FIPS 186-4 [DSS], and the corresponding hash algorithm as defined in [SHS]. The signature is represented as a DER-encoded [X690] ECDSA-Sig-Value structure.","EdDSA algorithms: Indicates a signature algorithm using EdDSA as defined in [RFC8032] or its successors. Note that these correspond to the ""PureEdDSA"" algorithms and not the ""prehash"" variants.",4.2.3,Signature Algorithms,3,8,3,MUST
"If the public key is carried in an X.509 certificate, it MUST use the rsaEncryption OID [RFC5280].",The condition that the public key is carried in an X.509 certificate.,The certificate MUST use the rsaEncryption OID as specified in RFC5280.,MUST,"RSASSA-PSS RSAE algorithms: Indicates a signature algorithm using RSASSA-PSS [RFC8017] with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST be equal to the length of the output of the digest algorithm. If the public key is carried in an X.509 certificate, it MUST use the rsaEncryption OID [RFC5280].","ECDSA algorithms: Indicates a signature algorithm using ECDSA [ECDSA], the corresponding curve as defined in ANSI X9.62 [ECDSA] and FIPS 186-4 [DSS], and the corresponding hash algorithm as defined in [SHS]. The signature is represented as a DER-encoded [X690] ECDSA-Sig-Value structure.","EdDSA algorithms: Indicates a signature algorithm using EdDSA as defined in [RFC8032] or its successors. Note that these correspond to the ""PureEdDSA"" algorithms and not the ""prehash"" variants.",4.2.3,Signature Algorithms,3,8,4,MUST
The length of the Salt MUST be equal to the length of the digest algorithm.,"In the context of configuring RSASSA-PSS PSS algorithms (where the digest used for the mask generation function and for signing is defined), the specification applies to the use of Salt.",The length of the Salt MUST be equal to the length of the digest algorithm.,MUST,"RSASSA-PSS PSS algorithms: Indicates a signature algorithm using RSASSA-PSS [RFC8017] with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST be equal to the length of the digest algorithm. If the public key is carried in an X.509 certificate, it MUST use the RSASSA-PSS OID [RFC5756]. When used in certificate signatures, the algorithm parameters MUST be DER encoded. If the corresponding public key's parameters are present, then the parameters in the signature MUST be identical to those in the public key.","EdDSA algorithms: Indicates a signature algorithm using EdDSA as defined in [RFC8032] or its successors. Note that these correspond to the ""PureEdDSA"" algorithms and not the ""prehash"" variants.","Legacy algorithms: Indicates algorithms which are being deprecated because they use algorithms with known weaknesses, specifically SHA-1 which is used in this context with either (1) RSA using RSASSA-PKCS1-v1_5 or (2) ECDSA. These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2. Endpoints SHOULD NOT negotiate these algorithms but are permitted to do so solely for backward compatibility. Clients offering these values MUST list them as the lowest priority (listed after all other algorithms in SignatureSchemeList). TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it (see Section 4.4.2.2).",4.2.3,Signature Algorithms,3,10,3,MUST
"If the public key is carried in an X.509 certificate, it MUST use the RSASSA-PSS OID [RFC5756].",The public key is carried in an X.509 certificate.,It MUST use the RSASSA-PSS OID [RFC5756].,MUST,"RSASSA-PSS PSS algorithms: Indicates a signature algorithm using RSASSA-PSS [RFC8017] with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST be equal to the length of the digest algorithm. If the public key is carried in an X.509 certificate, it MUST use the RSASSA-PSS OID [RFC5756]. When used in certificate signatures, the algorithm parameters MUST be DER encoded. If the corresponding public key's parameters are present, then the parameters in the signature MUST be identical to those in the public key.","EdDSA algorithms: Indicates a signature algorithm using EdDSA as defined in [RFC8032] or its successors. Note that these correspond to the ""PureEdDSA"" algorithms and not the ""prehash"" variants.","Legacy algorithms: Indicates algorithms which are being deprecated because they use algorithms with known weaknesses, specifically SHA-1 which is used in this context with either (1) RSA using RSASSA-PKCS1-v1_5 or (2) ECDSA. These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2. Endpoints SHOULD NOT negotiate these algorithms but are permitted to do so solely for backward compatibility. Clients offering these values MUST list them as the lowest priority (listed after all other algorithms in SignatureSchemeList). TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it (see Section 4.4.2.2).",4.2.3,Signature Algorithms,3,10,4,MUST
"When used in certificate signatures, the algorithm parameters MUST be DER encoded.",When used in certificate signatures,The algorithm parameters MUST be DER encoded,MUST,"RSASSA-PSS PSS algorithms: Indicates a signature algorithm using RSASSA-PSS [RFC8017] with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST be equal to the length of the digest algorithm. If the public key is carried in an X.509 certificate, it MUST use the RSASSA-PSS OID [RFC5756]. When used in certificate signatures, the algorithm parameters MUST be DER encoded. If the corresponding public key's parameters are present, then the parameters in the signature MUST be identical to those in the public key.","EdDSA algorithms: Indicates a signature algorithm using EdDSA as defined in [RFC8032] or its successors. Note that these correspond to the ""PureEdDSA"" algorithms and not the ""prehash"" variants.","Legacy algorithms: Indicates algorithms which are being deprecated because they use algorithms with known weaknesses, specifically SHA-1 which is used in this context with either (1) RSA using RSASSA-PKCS1-v1_5 or (2) ECDSA. These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2. Endpoints SHOULD NOT negotiate these algorithms but are permitted to do so solely for backward compatibility. Clients offering these values MUST list them as the lowest priority (listed after all other algorithms in SignatureSchemeList). TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it (see Section 4.4.2.2).",4.2.3,Signature Algorithms,3,10,5,MUST
"If the corresponding public key's parameters are present, then the parameters in the signature MUST be identical to those in the public key.",The corresponding public key's parameters are present,The parameters in the signature MUST be identical to those in the public key,MUST,"RSASSA-PSS PSS algorithms: Indicates a signature algorithm using RSASSA-PSS [RFC8017] with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST be equal to the length of the digest algorithm. If the public key is carried in an X.509 certificate, it MUST use the RSASSA-PSS OID [RFC5756]. When used in certificate signatures, the algorithm parameters MUST be DER encoded. If the corresponding public key's parameters are present, then the parameters in the signature MUST be identical to those in the public key.","EdDSA algorithms: Indicates a signature algorithm using EdDSA as defined in [RFC8032] or its successors. Note that these correspond to the ""PureEdDSA"" algorithms and not the ""prehash"" variants.","Legacy algorithms: Indicates algorithms which are being deprecated because they use algorithms with known weaknesses, specifically SHA-1 which is used in this context with either (1) RSA using RSASSA-PKCS1-v1_5 or (2) ECDSA. These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2. Endpoints SHOULD NOT negotiate these algorithms but are permitted to do so solely for backward compatibility. Clients offering these values MUST list them as the lowest priority (listed after all other algorithms in SignatureSchemeList). TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it (see Section 4.4.2.2).",4.2.3,Signature Algorithms,3,10,6,MUST
"These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2.","When processing signature algorithm values in different contexts, particularly distinguishing between certificate signatures and signed TLS handshake messages","Interpret these signature values as applicable solely to signatures in certificates; they are not defined for use in signed TLS handshake messages, though their appearance in the 'signature_algorithms' and 'signature_algorithms_cert' extensions is permitted for TLS 1.2 backward compatibility",MAY,"Legacy algorithms: Indicates algorithms which are being deprecated because they use algorithms with known weaknesses, specifically SHA-1 which is used in this context with either (1) RSA using RSASSA-PKCS1-v1_5 or (2) ECDSA. These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2. Endpoints SHOULD NOT negotiate these algorithms but are permitted to do so solely for backward compatibility. Clients offering these values MUST list them as the lowest priority (listed after all other algorithms in SignatureSchemeList). TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it (see Section 4.4.2.2).","RSASSA-PSS PSS algorithms: Indicates a signature algorithm using RSASSA-PSS [RFC8017] with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST be equal to the length of the digest algorithm. If the public key is carried in an X.509 certificate, it MUST use the RSASSA-PSS OID [RFC5756]. When used in certificate signatures, the algorithm parameters MUST be DER encoded. If the corresponding public key's parameters are present, then the parameters in the signature MUST be identical to those in the public key.","The signatures on certificates that are self-signed or certificates that are trust anchors are not validated, since they begin a certification path (see [RFC5280], Section 3.2). A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the ""signature_algorithms"" extension.",4.2.3,Signature Algorithms,3,11,2,MAY
Endpoints SHOULD NOT negotiate these algorithms but are permitted to do so solely for backward compatibility.,"When an endpoint is engaging in the negotiation of signature algorithms, particularly those identified as legacy (deprecated due to known weaknesses).",The endpoint SHOULD NOT negotiate these legacy algorithms except solely for the purpose of maintaining backward compatibility.,SHOULD NOT,"Legacy algorithms: Indicates algorithms which are being deprecated because they use algorithms with known weaknesses, specifically SHA-1 which is used in this context with either (1) RSA using RSASSA-PKCS1-v1_5 or (2) ECDSA. These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2. Endpoints SHOULD NOT negotiate these algorithms but are permitted to do so solely for backward compatibility. Clients offering these values MUST list them as the lowest priority (listed after all other algorithms in SignatureSchemeList). TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it (see Section 4.4.2.2).","RSASSA-PSS PSS algorithms: Indicates a signature algorithm using RSASSA-PSS [RFC8017] with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST be equal to the length of the digest algorithm. If the public key is carried in an X.509 certificate, it MUST use the RSASSA-PSS OID [RFC5756]. When used in certificate signatures, the algorithm parameters MUST be DER encoded. If the corresponding public key's parameters are present, then the parameters in the signature MUST be identical to those in the public key.","The signatures on certificates that are self-signed or certificates that are trust anchors are not validated, since they begin a certification path (see [RFC5280], Section 3.2). A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the ""signature_algorithms"" extension.",4.2.3,Signature Algorithms,3,11,3,SHOULD
Clients offering these values MUST list them as the lowest priority (listed after all other algorithms in SignatureSchemeList),When a client offers the legacy algorithm values (SHA-1 based algorithms) in its SignatureSchemeList,"The client MUST list these legacy algorithm values as the lowest priority, placing them after all other algorithms in SignatureSchemeList",MUST,"Legacy algorithms: Indicates algorithms which are being deprecated because they use algorithms with known weaknesses, specifically SHA-1 which is used in this context with either (1) RSA using RSASSA-PKCS1-v1_5 or (2) ECDSA. These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2. Endpoints SHOULD NOT negotiate these algorithms but are permitted to do so solely for backward compatibility. Clients offering these values MUST list them as the lowest priority (listed after all other algorithms in SignatureSchemeList). TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it (see Section 4.4.2.2).","RSASSA-PSS PSS algorithms: Indicates a signature algorithm using RSASSA-PSS [RFC8017] with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST be equal to the length of the digest algorithm. If the public key is carried in an X.509 certificate, it MUST use the RSASSA-PSS OID [RFC5756]. When used in certificate signatures, the algorithm parameters MUST be DER encoded. If the corresponding public key's parameters are present, then the parameters in the signature MUST be identical to those in the public key.","The signatures on certificates that are self-signed or certificates that are trust anchors are not validated, since they begin a certification path (see [RFC5280], Section 3.2). A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the ""signature_algorithms"" extension.",4.2.3,Signature Algorithms,3,11,4,MUST
TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it (see Section 4.4.2.2).,TLS 1.3 servers are allowed to offer a SHA-1 signed certificate only if no valid certificate chain can be produced without it,TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate,MUST NOT,"Legacy algorithms: Indicates algorithms which are being deprecated because they use algorithms with known weaknesses, specifically SHA-1 which is used in this context with either (1) RSA using RSASSA-PKCS1-v1_5 or (2) ECDSA. These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2. Endpoints SHOULD NOT negotiate these algorithms but are permitted to do so solely for backward compatibility. Clients offering these values MUST list them as the lowest priority (listed after all other algorithms in SignatureSchemeList). TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it (see Section 4.4.2.2).","RSASSA-PSS PSS algorithms: Indicates a signature algorithm using RSASSA-PSS [RFC8017] with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST be equal to the length of the digest algorithm. If the public key is carried in an X.509 certificate, it MUST use the RSASSA-PSS OID [RFC5756]. When used in certificate signatures, the algorithm parameters MUST be DER encoded. If the corresponding public key's parameters are present, then the parameters in the signature MUST be identical to those in the public key.","The signatures on certificates that are self-signed or certificates that are trust anchors are not validated, since they begin a certification path (see [RFC5280], Section 3.2). A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the ""signature_algorithms"" extension.",4.2.3,Signature Algorithms,3,11,5,MUST
"A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the ""signature_algorithms"" extension.",A certificate that begins a certification path,May use a signature algorithm that is not advertised as being supported in the 'signature_algorithms' extension,MAY,"The signatures on certificates that are self-signed or certificates that are trust anchors are not validated, since they begin a certification path (see [RFC5280], Section 3.2). A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the ""signature_algorithms"" extension.","Legacy algorithms: Indicates algorithms which are being deprecated because they use algorithms with known weaknesses, specifically SHA-1 which is used in this context with either (1) RSA using RSASSA-PKCS1-v1_5 or (2) ECDSA. These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2. Endpoints SHOULD NOT negotiate these algorithms but are permitted to do so solely for backward compatibility. Clients offering these values MUST list them as the lowest priority (listed after all other algorithms in SignatureSchemeList). TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it (see Section 4.4.2.2).",Note that TLS 1.2 defines this extension differently. TLS 1.3 implementations willing to negotiate TLS 1.2 MUST behave in accordance with the requirements of [RFC5246] when negotiating that version. In particular:,4.2.3,Signature Algorithms,3,12,2,MAY
TLS 1.3 implementations willing to negotiate TLS 1.2 MUST behave in accordance with the requirements of [RFC5246] when negotiating that version.,TLS 1.3 implementations that are willing to negotiate TLS 1.2,MUST behave in accordance with the requirements of RFC5246 when negotiating TLS 1.2,MUST,Note that TLS 1.2 defines this extension differently. TLS 1.3 implementations willing to negotiate TLS 1.2 MUST behave in accordance with the requirements of [RFC5246] when negotiating that version. In particular:,"The signatures on certificates that are self-signed or certificates that are trust anchors are not validated, since they begin a certification path (see [RFC5280], Section 3.2). A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the ""signature_algorithms"" extension.",-TLS 1.2 ClientHellos MAY omit this extension.,4.2.3,Signature Algorithms,3,13,2,MUST
-TLS 1.2 ClientHellos MAY omit this extension.,The message is a TLS 1.2 ClientHello.,The TLS 1.2 ClientHello MAY omit the specified extension.,MAY,-TLS 1.2 ClientHellos MAY omit this extension.,Note that TLS 1.2 defines this extension differently. TLS 1.3 implementations willing to negotiate TLS 1.2 MUST behave in accordance with the requirements of [RFC5246] when negotiating that version. In particular:,"-In TLS 1.2, the extension contained hash/signature pairs. The pairs are encoded in two octets, so SignatureScheme values have been allocated to align with TLS 1.2's encoding. Some legacy pairs are left unallocated. These algorithms are deprecated as of TLS 1.3. They MUST NOT be offered or negotiated by any implementation. In particular, MD5 [SLOTH], SHA-224, and DSA MUST NOT be used.",4.2.3,Signature Algorithms,3,14,1,MAY
They MUST NOT be offered or negotiated by any implementation.,"When an implementation is in a position to offer or negotiate cryptographic algorithms—especially those now deprecated as of TLS 1.3, including MD5, SHA-224, and DSA.",The implementation MUST NOT offer or negotiate these algorithms.,MUST NOT,"-In TLS 1.2, the extension contained hash/signature pairs. The pairs are encoded in two octets, so SignatureScheme values have been allocated to align with TLS 1.2's encoding. Some legacy pairs are left unallocated. These algorithms are deprecated as of TLS 1.3. They MUST NOT be offered or negotiated by any implementation. In particular, MD5 [SLOTH], SHA-224, and DSA MUST NOT be used.",-TLS 1.2 ClientHellos MAY omit this extension.,"-ECDSA signature schemes align with TLS 1.2's ECDSA hash/signature pairs. However, the old semantics did not constrain the signing curve. If TLS 1.2 is negotiated, implementations MUST be prepared to accept a signature that uses any curve that they advertised in the ""supported_groups"" extension.",4.2.3,Signature Algorithms,3,15,5,MUST
"In particular, MD5 [SLOTH], SHA-224, and DSA MUST NOT be used.",,"MD5 [SLOTH], SHA-224, and DSA MUST NOT be used.",MUST NOT,"-In TLS 1.2, the extension contained hash/signature pairs. The pairs are encoded in two octets, so SignatureScheme values have been allocated to align with TLS 1.2's encoding. Some legacy pairs are left unallocated. These algorithms are deprecated as of TLS 1.3. They MUST NOT be offered or negotiated by any implementation. In particular, MD5 [SLOTH], SHA-224, and DSA MUST NOT be used.",-TLS 1.2 ClientHellos MAY omit this extension.,"-ECDSA signature schemes align with TLS 1.2's ECDSA hash/signature pairs. However, the old semantics did not constrain the signing curve. If TLS 1.2 is negotiated, implementations MUST be prepared to accept a signature that uses any curve that they advertised in the ""supported_groups"" extension.",4.2.3,Signature Algorithms,3,15,6,MUST
"If TLS 1.2 is negotiated, implementations MUST be prepared to accept a signature that uses any curve that they advertised in the ""supported_groups"" extension.",TLS 1.2 is negotiated,Implementation MUST be prepared to accept a signature that uses any curve that was advertised in the 'supported_groups' extension,MUST,"-ECDSA signature schemes align with TLS 1.2's ECDSA hash/signature pairs. However, the old semantics did not constrain the signing curve. If TLS 1.2 is negotiated, implementations MUST be prepared to accept a signature that uses any curve that they advertised in the ""supported_groups"" extension.","-In TLS 1.2, the extension contained hash/signature pairs. The pairs are encoded in two octets, so SignatureScheme values have been allocated to align with TLS 1.2's encoding. Some legacy pairs are left unallocated. These algorithms are deprecated as of TLS 1.3. They MUST NOT be offered or negotiated by any implementation. In particular, MD5 [SLOTH], SHA-224, and DSA MUST NOT be used.","-Implementations that advertise support for RSASSA-PSS (which is mandatory in TLS 1.3) MUST be prepared to accept a signature using that scheme even when TLS 1.2 is negotiated. In TLS 1.2, RSASSA-PSS is used with RSA cipher suites.",4.2.3,Signature Algorithms,3,16,3,MUST
-Implementations that advertise support for RSASSA-PSS (which is mandatory in TLS 1.3) MUST be prepared to accept a signature using that scheme even when TLS 1.2 is negotiated.,TLS 1.2 is negotiated on an implementation that advertises support for RSASSA-PSS,The implementation MUST be prepared to accept a signature using the RSASSA-PSS scheme in TLS 1.2,MUST,"-Implementations that advertise support for RSASSA-PSS (which is mandatory in TLS 1.3) MUST be prepared to accept a signature using that scheme even when TLS 1.2 is negotiated. In TLS 1.2, RSASSA-PSS is used with RSA cipher suites.","-ECDSA signature schemes align with TLS 1.2's ECDSA hash/signature pairs. However, the old semantics did not constrain the signing curve. If TLS 1.2 is negotiated, implementations MUST be prepared to accept a signature that uses any curve that they advertised in the ""supported_groups"" extension.",,4.2.3,Signature Algorithms,3,17,1,MUST
"The ""certificate_authorities"" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which SHOULD be used by the receiving endpoint to guide certificate selection.",Receipt of a message containing the 'certificate_authorities' extension which lists the supported certificate authorities (CAs) of the sending endpoint.,The receiving endpoint SHOULD use the indicated certificate authorities to guide its certificate selection process.,SHOULD,"The ""certificate_authorities"" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which SHOULD be used by the receiving endpoint to guide certificate selection.",,"The body of the ""certificate_authorities"" extension consists of a CertificateAuthoritiesExtension structure.",4.2.4,Certificate Authorities,3,1,1,SHOULD
"The client MAY send the ""certificate_authorities"" extension in the ClientHello message.",When a client is preparing to send a ClientHello message as part of initiating a TLS handshake,The client MAY include the 'certificate_authorities' extension in the ClientHello message,MAY,"The client MAY send the ""certificate_authorities"" extension in the ClientHello message. The server MAY send it in the CertificateRequest message.","authorities: A list of the distinguished names [X501] of acceptable certificate authorities, represented in DER-encoded [X690] format. These distinguished names specify a desired distinguished name for a trust anchor or subordinate CA; thus, this message can be used to describe known trust anchors as well as a desired authorization space.","The ""trusted_ca_keys"" extension [RFC6066], which serves a similar purpose but is more complicated, is not used in TLS 1.3 (although it may appear in ClientHello messages from clients which are offering prior versions of TLS).",4.2.4,Certificate Authorities,3,4,1,MAY
The server MAY send it in the CertificateRequest message.,,The server MAY include the certificate_authorities extension in the CertificateRequest message.,MAY,"The client MAY send the ""certificate_authorities"" extension in the ClientHello message. The server MAY send it in the CertificateRequest message.","authorities: A list of the distinguished names [X501] of acceptable certificate authorities, represented in DER-encoded [X690] format. These distinguished names specify a desired distinguished name for a trust anchor or subordinate CA; thus, this message can be used to describe known trust anchors as well as a desired authorization space.","The ""trusted_ca_keys"" extension [RFC6066], which serves a similar purpose but is more complicated, is not used in TLS 1.3 (although it may appear in ClientHello messages from clients which are offering prior versions of TLS).",4.2.4,Certificate Authorities,3,4,2,MAY
"This extension, if provided by the server, MUST only be sent in the CertificateRequest message.",The extension is provided by the server,The extension MUST only be sent in the CertificateRequest message,MUST,"The ""oid_filters"" extension allows servers to provide a set of OID/value pairs which it would like the client's certificate to match. This extension, if provided by the server, MUST only be sent in the CertificateRequest message.",,"filters: A list of certificate extension OIDs [RFC5280] with their allowed value(s) and represented in DER-encoded [X690] format. Some certificate extension OIDs allow multiple values (e.g., Extended Key Usage). If the server has included a non-empty filters list, the client certificate included in the response MUST contain all of the specified extension OIDs that the client recognizes. For each extension OID recognized by the client, all of the specified values MUST be present in the client certificate (but the certificate MAY have other values as well). However, the client MUST ignore and skip any unrecognized certificate extension OIDs. If the client ignored some of the required certificate extension OIDs and supplied a certificate that does not satisfy the request, the server MAY at its discretion either continue the connection without client authentication or abort the handshake with an ""unsupported_certificate"" alert. Any given OID MUST NOT appear more than once in the filters list.",4.2.5,OID Filters,3,1,2,MUST
"If the server has included a non-empty filters list, the client certificate included in the response MUST contain all of the specified extension OIDs that the client recognizes.",The server has included a non-empty filters list.,"The client certificate included in the response MUST contain all of the specified extension OIDs that the client recognizes. For each recognized extension OID, all of the specified values MUST be present in the client certificate.",MUST,"filters: A list of certificate extension OIDs [RFC5280] with their allowed value(s) and represented in DER-encoded [X690] format. Some certificate extension OIDs allow multiple values (e.g., Extended Key Usage). If the server has included a non-empty filters list, the client certificate included in the response MUST contain all of the specified extension OIDs that the client recognizes. For each extension OID recognized by the client, all of the specified values MUST be present in the client certificate (but the certificate MAY have other values as well). However, the client MUST ignore and skip any unrecognized certificate extension OIDs. If the client ignored some of the required certificate extension OIDs and supplied a certificate that does not satisfy the request, the server MAY at its discretion either continue the connection without client authentication or abort the handshake with an ""unsupported_certificate"" alert. Any given OID MUST NOT appear more than once in the filters list.","The ""oid_filters"" extension allows servers to provide a set of OID/value pairs which it would like the client's certificate to match. This extension, if provided by the server, MUST only be sent in the CertificateRequest message.","PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types. Depending on the type, matching certificate extension values are not necessarily bitwise-equal. It is expected that TLS implementations will rely on their PKI libraries to perform certificate selection using certificate extension OIDs.",4.2.5,OID Filters,3,2,3,MUST
"For each extension OID recognized by the client, all of the specified values MUST be present in the client certificate (but the certificate MAY have other values as well).",Each extension OID recognized by the client (i.e. the certificate contains an extension OID that is part of the server-provided filters list),"The client certificate MUST include all of the specified values for that recognized extension OID, although it may include additional values.","MUST, MAY","filters: A list of certificate extension OIDs [RFC5280] with their allowed value(s) and represented in DER-encoded [X690] format. Some certificate extension OIDs allow multiple values (e.g., Extended Key Usage). If the server has included a non-empty filters list, the client certificate included in the response MUST contain all of the specified extension OIDs that the client recognizes. For each extension OID recognized by the client, all of the specified values MUST be present in the client certificate (but the certificate MAY have other values as well). However, the client MUST ignore and skip any unrecognized certificate extension OIDs. If the client ignored some of the required certificate extension OIDs and supplied a certificate that does not satisfy the request, the server MAY at its discretion either continue the connection without client authentication or abort the handshake with an ""unsupported_certificate"" alert. Any given OID MUST NOT appear more than once in the filters list.","The ""oid_filters"" extension allows servers to provide a set of OID/value pairs which it would like the client's certificate to match. This extension, if provided by the server, MUST only be sent in the CertificateRequest message.","PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types. Depending on the type, matching certificate extension values are not necessarily bitwise-equal. It is expected that TLS implementations will rely on their PKI libraries to perform certificate selection using certificate extension OIDs.",4.2.5,OID Filters,3,2,4,MUST
"However, the client MUST ignore and skip any unrecognized certificate extension OIDs.",Encountering an unrecognized certificate extension OID,The client MUST ignore and skip the unrecognized certificate extension OID,MUST,"filters: A list of certificate extension OIDs [RFC5280] with their allowed value(s) and represented in DER-encoded [X690] format. Some certificate extension OIDs allow multiple values (e.g., Extended Key Usage). If the server has included a non-empty filters list, the client certificate included in the response MUST contain all of the specified extension OIDs that the client recognizes. For each extension OID recognized by the client, all of the specified values MUST be present in the client certificate (but the certificate MAY have other values as well). However, the client MUST ignore and skip any unrecognized certificate extension OIDs. If the client ignored some of the required certificate extension OIDs and supplied a certificate that does not satisfy the request, the server MAY at its discretion either continue the connection without client authentication or abort the handshake with an ""unsupported_certificate"" alert. Any given OID MUST NOT appear more than once in the filters list.","The ""oid_filters"" extension allows servers to provide a set of OID/value pairs which it would like the client's certificate to match. This extension, if provided by the server, MUST only be sent in the CertificateRequest message.","PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types. Depending on the type, matching certificate extension values are not necessarily bitwise-equal. It is expected that TLS implementations will rely on their PKI libraries to perform certificate selection using certificate extension OIDs.",4.2.5,OID Filters,3,2,5,MUST
"If the client ignored some of the required certificate extension OIDs and supplied a certificate that does not satisfy the request, the server MAY at its discretion either continue the connection without client authentication or abort the handshake with an ""unsupported_certificate"" alert.",The client ignored some of the required certificate extension OIDs and supplied a certificate that does not satisfy the request.,The server MAY at its discretion either continue the connection without client authentication or abort the handshake with an 'unsupported_certificate' alert.,MAY,"filters: A list of certificate extension OIDs [RFC5280] with their allowed value(s) and represented in DER-encoded [X690] format. Some certificate extension OIDs allow multiple values (e.g., Extended Key Usage). If the server has included a non-empty filters list, the client certificate included in the response MUST contain all of the specified extension OIDs that the client recognizes. For each extension OID recognized by the client, all of the specified values MUST be present in the client certificate (but the certificate MAY have other values as well). However, the client MUST ignore and skip any unrecognized certificate extension OIDs. If the client ignored some of the required certificate extension OIDs and supplied a certificate that does not satisfy the request, the server MAY at its discretion either continue the connection without client authentication or abort the handshake with an ""unsupported_certificate"" alert. Any given OID MUST NOT appear more than once in the filters list.","The ""oid_filters"" extension allows servers to provide a set of OID/value pairs which it would like the client's certificate to match. This extension, if provided by the server, MUST only be sent in the CertificateRequest message.","PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types. Depending on the type, matching certificate extension values are not necessarily bitwise-equal. It is expected that TLS implementations will rely on their PKI libraries to perform certificate selection using certificate extension OIDs.",4.2.5,OID Filters,3,2,6,MAY
Any given OID MUST NOT appear more than once in the filters list.,An OID appears more than once in the filters list.,Ensure that each OID appears only once in the filters list; duplicate occurrences are disallowed.,MUST NOT,"filters: A list of certificate extension OIDs [RFC5280] with their allowed value(s) and represented in DER-encoded [X690] format. Some certificate extension OIDs allow multiple values (e.g., Extended Key Usage). If the server has included a non-empty filters list, the client certificate included in the response MUST contain all of the specified extension OIDs that the client recognizes. For each extension OID recognized by the client, all of the specified values MUST be present in the client certificate (but the certificate MAY have other values as well). However, the client MUST ignore and skip any unrecognized certificate extension OIDs. If the client ignored some of the required certificate extension OIDs and supplied a certificate that does not satisfy the request, the server MAY at its discretion either continue the connection without client authentication or abort the handshake with an ""unsupported_certificate"" alert. Any given OID MUST NOT appear more than once in the filters list.","The ""oid_filters"" extension allows servers to provide a set of OID/value pairs which it would like the client's certificate to match. This extension, if provided by the server, MUST only be sent in the CertificateRequest message.","PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types. Depending on the type, matching certificate extension values are not necessarily bitwise-equal. It is expected that TLS implementations will rely on their PKI libraries to perform certificate selection using certificate extension OIDs.",4.2.5,OID Filters,3,2,7,MUST
The special anyExtendedKeyUsage OID MUST NOT be used in the request.,"When a certificate request is being processed that involves Extended Key Usage, the special anyExtendedKeyUsage OID is evaluated for inclusion in the request.",The special anyExtendedKeyUsage OID MUST NOT be used in the request.,MUST NOT,-The Extended Key Usage extension in a certificate matches the request when all key purpose OIDs present in the request are also found in the Extended Key Usage certificate extension. The special anyExtendedKeyUsage OID MUST NOT be used in the request.,-The Key Usage extension in a certificate matches the request when all key usage bits asserted in the request are also asserted in the Key Usage certificate extension.,Separate specifications may define matching rules for other certificate extensions.,4.2.5,OID Filters,3,6,2,MUST
Servers MUST NOT send a post-handshake CertificateRequest to clients which do not offer this extension.,The client does not offer the 'post_handshake_auth' extension.,The server MUST NOT send a post-handshake CertificateRequest to clients that do not offer the 'post_handshake_auth' extension.,MUST NOT,"The ""post_handshake_auth"" extension is used to indicate that a client is willing to perform post-handshake authentication (Section 4.6.2). Servers MUST NOT send a post-handshake CertificateRequest to clients which do not offer this extension. Servers MUST NOT send this extension.",,"The ""extension_data"" field of the ""post_handshake_auth"" extension is zero length.",4.2.6,Post-Handshake Client Authentication,3,1,2,MUST
Servers MUST NOT send this extension.,,Servers MUST NOT send this extension.,MUST NOT,"The ""post_handshake_auth"" extension is used to indicate that a client is willing to perform post-handshake authentication (Section 4.6.2). Servers MUST NOT send a post-handshake CertificateRequest to clients which do not offer this extension. Servers MUST NOT send this extension.",,"The ""extension_data"" field of the ""post_handshake_auth"" extension is zero length.",4.2.6,Post-Handshake Client Authentication,3,1,3,MUST
"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.","When a client receives the 'supported_groups' extension before the handshake has successfully completed,After a successful handshake, before initiating subsequent connections where the handshake information is available","Clients MUST NOT act upon any information found in 'supported_groups' prior to successful completion of the handshake,Clients MAY use the information learned from a successfully completed handshake to change the groups used in their 'key_share' extension in subsequent connections","MUST NOT, MAY","As of TLS 1.3, servers are permitted to send the ""supported_groups"" extension to the client. Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections. If the server has a group it prefers to the ones in the ""key_share"" extension but is still willing to accept the ClientHello, it SHOULD send ""supported_groups"" to update the client's view of its preferences; this extension SHOULD contain all groups the server supports, regardless of whether they are currently supported by the client.",Items in named_group_list are ordered according to the sender's preferences (most preferred choice first).,,4.2.7,Supported Groups,3,7,2,MUST
"If the server has a group it prefers to the ones in the ""key_share"" extension but is still willing to accept the ClientHello, it SHOULD send ""supported_groups"" to update the client's view of its preferences; this extension SHOULD contain all groups the server supports, regardless of whether they are currently supported by the client.",The server has a group it prefers compared to those in the 'key_share' extension and is still willing to accept the ClientHello,"The server SHOULD send the 'supported_groups' extension to update the client's view of its preferences, and this extension SHOULD contain all groups the server supports, regardless of whether they are currently supported by the client",SHOULD,"As of TLS 1.3, servers are permitted to send the ""supported_groups"" extension to the client. Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections. If the server has a group it prefers to the ones in the ""key_share"" extension but is still willing to accept the ClientHello, it SHOULD send ""supported_groups"" to update the client's view of its preferences; this extension SHOULD contain all groups the server supports, regardless of whether they are currently supported by the client.",Items in named_group_list are ordered according to the sender's preferences (most preferred choice first).,,4.2.7,Supported Groups,3,7,3,SHOULD
"Clients MAY send an empty client_shares vector in order to request group selection from the server, at the cost of an additional round trip (see Section 4.1.4).",A client sends an empty client_shares vector in its message.,"The empty vector acts as a request for group selection from the server, which will result in an additional round trip.",MAY,"Clients MAY send an empty client_shares vector in order to request group selection from the server, at the cost of an additional round trip (see Section 4.1.4).","The ""key_share"" extension contains the endpoint's cryptographic parameters.",group: The named group for the key being exchanged.,4.2.8,Key Share,3,2,1,MAY
This vector MAY be empty if the client is requesting a HelloRetryRequest.,The client is requesting a HelloRetryRequest.,The vector MAY be empty.,MAY,"This vector MAY be empty if the client is requesting a HelloRetryRequest. Each KeyShareEntry value MUST correspond to a group offered in the ""supported_groups"" extension and MUST appear in the same order. However, the values MAY be a non-contiguous subset of the ""supported_groups"" extension and MAY omit the most preferred groups. Such a situation could arise if the most preferred groups are new and unlikely to be supported in enough places to make pregenerating key shares for them efficient.",client_shares: A list of offered KeyShareEntry values in descending order of client preference.,"Clients can offer as many KeyShareEntry values as the number of supported groups it is offering, each representing a single set of key exchange parameters. For instance, a client might offer shares for several elliptic curves or multiple FFDHE groups. The key_exchange values for each KeyShareEntry MUST be generated independently. Clients MUST NOT offer multiple KeyShareEntry values for the same group. Clients MUST NOT offer any KeyShareEntry values for groups not listed in the client's ""supported_groups"" extension. Servers MAY check for violations of these rules and abort the handshake with an ""illegal_parameter"" alert if one is violated.",4.2.8,Key Share,3,7,1,MAY
"Each KeyShareEntry value MUST correspond to a group offered in the ""supported_groups"" extension and MUST appear in the same order.","When a client provides a list of KeyShareEntry values (i.e., in client_hello messages except in the case of a HelloRetryRequest where the vector may be empty)",Each KeyShareEntry value MUST correspond to a group offered in the 'supported_groups' extension and MUST appear in the same order as listed in that extension,MUST,"This vector MAY be empty if the client is requesting a HelloRetryRequest. Each KeyShareEntry value MUST correspond to a group offered in the ""supported_groups"" extension and MUST appear in the same order. However, the values MAY be a non-contiguous subset of the ""supported_groups"" extension and MAY omit the most preferred groups. Such a situation could arise if the most preferred groups are new and unlikely to be supported in enough places to make pregenerating key shares for them efficient.",client_shares: A list of offered KeyShareEntry values in descending order of client preference.,"Clients can offer as many KeyShareEntry values as the number of supported groups it is offering, each representing a single set of key exchange parameters. For instance, a client might offer shares for several elliptic curves or multiple FFDHE groups. The key_exchange values for each KeyShareEntry MUST be generated independently. Clients MUST NOT offer multiple KeyShareEntry values for the same group. Clients MUST NOT offer any KeyShareEntry values for groups not listed in the client's ""supported_groups"" extension. Servers MAY check for violations of these rules and abort the handshake with an ""illegal_parameter"" alert if one is violated.",4.2.8,Key Share,3,7,2,MUST
"However, the values MAY be a non-contiguous subset of the ""supported_groups"" extension and MAY omit the most preferred groups.","When constructing the vector of KeyShareEntry values from the client’s offered list (derived from the 'supported_groups' extension), where the order reflects client preference.",The implementation MAY select a non‐contiguous subset of the groups listed in the 'supported_groups' extension and is permitted to omit the most preferred groups.,MAY,"This vector MAY be empty if the client is requesting a HelloRetryRequest. Each KeyShareEntry value MUST correspond to a group offered in the ""supported_groups"" extension and MUST appear in the same order. However, the values MAY be a non-contiguous subset of the ""supported_groups"" extension and MAY omit the most preferred groups. Such a situation could arise if the most preferred groups are new and unlikely to be supported in enough places to make pregenerating key shares for them efficient.",client_shares: A list of offered KeyShareEntry values in descending order of client preference.,"Clients can offer as many KeyShareEntry values as the number of supported groups it is offering, each representing a single set of key exchange parameters. For instance, a client might offer shares for several elliptic curves or multiple FFDHE groups. The key_exchange values for each KeyShareEntry MUST be generated independently. Clients MUST NOT offer multiple KeyShareEntry values for the same group. Clients MUST NOT offer any KeyShareEntry values for groups not listed in the client's ""supported_groups"" extension. Servers MAY check for violations of these rules and abort the handshake with an ""illegal_parameter"" alert if one is violated.",4.2.8,Key Share,3,7,3,MAY
The key_exchange values for each KeyShareEntry MUST be generated independently.,For each KeyShareEntry offered in the client's handshake message,The key_exchange value for each KeyShareEntry MUST be generated independently,MUST,"Clients can offer as many KeyShareEntry values as the number of supported groups it is offering, each representing a single set of key exchange parameters. For instance, a client might offer shares for several elliptic curves or multiple FFDHE groups. The key_exchange values for each KeyShareEntry MUST be generated independently. Clients MUST NOT offer multiple KeyShareEntry values for the same group. Clients MUST NOT offer any KeyShareEntry values for groups not listed in the client's ""supported_groups"" extension. Servers MAY check for violations of these rules and abort the handshake with an ""illegal_parameter"" alert if one is violated.","This vector MAY be empty if the client is requesting a HelloRetryRequest. Each KeyShareEntry value MUST correspond to a group offered in the ""supported_groups"" extension and MUST appear in the same order. However, the values MAY be a non-contiguous subset of the ""supported_groups"" extension and MAY omit the most preferred groups. Such a situation could arise if the most preferred groups are new and unlikely to be supported in enough places to make pregenerating key shares for them efficient.","In a HelloRetryRequest message, the ""extension_data"" field of this extension contains a KeyShareHelloRetryRequest value:",4.2.8,Key Share,3,8,3,MUST
Clients MUST NOT offer multiple KeyShareEntry values for the same group.,"When a client includes KeyShareEntry values in its message for key exchange parameters, it must ensure each entry corresponds to a unique group. The condition arises if the client attempts to include more than one KeyShareEntry value for the same group.",The client MUST NOT offer multiple KeyShareEntry values for the same group.,MUST NOT,"Clients can offer as many KeyShareEntry values as the number of supported groups it is offering, each representing a single set of key exchange parameters. For instance, a client might offer shares for several elliptic curves or multiple FFDHE groups. The key_exchange values for each KeyShareEntry MUST be generated independently. Clients MUST NOT offer multiple KeyShareEntry values for the same group. Clients MUST NOT offer any KeyShareEntry values for groups not listed in the client's ""supported_groups"" extension. Servers MAY check for violations of these rules and abort the handshake with an ""illegal_parameter"" alert if one is violated.","This vector MAY be empty if the client is requesting a HelloRetryRequest. Each KeyShareEntry value MUST correspond to a group offered in the ""supported_groups"" extension and MUST appear in the same order. However, the values MAY be a non-contiguous subset of the ""supported_groups"" extension and MAY omit the most preferred groups. Such a situation could arise if the most preferred groups are new and unlikely to be supported in enough places to make pregenerating key shares for them efficient.","In a HelloRetryRequest message, the ""extension_data"" field of this extension contains a KeyShareHelloRetryRequest value:",4.2.8,Key Share,3,8,4,MUST
"Clients MUST NOT offer any KeyShareEntry values for groups not listed in the client's ""supported_groups"" extension",A client offers a KeyShareEntry value for a group that is not included in the client's 'supported_groups' extension.,Clients MUST NOT offer any KeyShareEntry values for groups not listed in the client's 'supported_groups' extension.,MUST NOT,"Clients can offer as many KeyShareEntry values as the number of supported groups it is offering, each representing a single set of key exchange parameters. For instance, a client might offer shares for several elliptic curves or multiple FFDHE groups. The key_exchange values for each KeyShareEntry MUST be generated independently. Clients MUST NOT offer multiple KeyShareEntry values for the same group. Clients MUST NOT offer any KeyShareEntry values for groups not listed in the client's ""supported_groups"" extension. Servers MAY check for violations of these rules and abort the handshake with an ""illegal_parameter"" alert if one is violated.","This vector MAY be empty if the client is requesting a HelloRetryRequest. Each KeyShareEntry value MUST correspond to a group offered in the ""supported_groups"" extension and MUST appear in the same order. However, the values MAY be a non-contiguous subset of the ""supported_groups"" extension and MAY omit the most preferred groups. Such a situation could arise if the most preferred groups are new and unlikely to be supported in enough places to make pregenerating key shares for them efficient.","In a HelloRetryRequest message, the ""extension_data"" field of this extension contains a KeyShareHelloRetryRequest value:",4.2.8,Key Share,3,8,5,MUST
"Servers MAY check for violations of these rules and abort the handshake with an ""illegal_parameter"" alert if one is violated.","Detection of any violation of the specified client rules (e.g., offering multiple KeyShareEntry values for the same group or offering KeyShareEntry values for groups not listed in the client's 'supported_groups' extension)",Abort the handshake with an 'illegal_parameter' alert,MAY,"Clients can offer as many KeyShareEntry values as the number of supported groups it is offering, each representing a single set of key exchange parameters. For instance, a client might offer shares for several elliptic curves or multiple FFDHE groups. The key_exchange values for each KeyShareEntry MUST be generated independently. Clients MUST NOT offer multiple KeyShareEntry values for the same group. Clients MUST NOT offer any KeyShareEntry values for groups not listed in the client's ""supported_groups"" extension. Servers MAY check for violations of these rules and abort the handshake with an ""illegal_parameter"" alert if one is violated.","This vector MAY be empty if the client is requesting a HelloRetryRequest. Each KeyShareEntry value MUST correspond to a group offered in the ""supported_groups"" extension and MUST appear in the same order. However, the values MAY be a non-contiguous subset of the ""supported_groups"" extension and MAY omit the most preferred groups. Such a situation could arise if the most preferred groups are new and unlikely to be supported in enough places to make pregenerating key shares for them efficient.","In a HelloRetryRequest message, the ""extension_data"" field of this extension contains a KeyShareHelloRetryRequest value:",4.2.8,Key Share,3,8,6,MAY
"Upon receipt of this extension in a HelloRetryRequest, the client MUST verify that (1) the selected_group field corresponds to a group which was provided in the ""supported_groups"" extension in the original ClientHello and (2) the selected_group field does not correspond to a group which was provided in the ""key_share"" extension in the original ClientHello.",Receipt of this extension in a HelloRetryRequest,"Verify that the selected_group field corresponds to a group provided in the 'supported_groups' extension in the original ClientHello and does not correspond to a group provided in the 'key_share' extension in the original ClientHello. If either check fails, abort the handshake with an 'illegal_parameter' alert.",MUST,"Upon receipt of this extension in a HelloRetryRequest, the client MUST verify that (1) the selected_group field corresponds to a group which was provided in the ""supported_groups"" extension in the original ClientHello and (2) the selected_group field does not correspond to a group which was provided in the ""key_share"" extension in the original ClientHello. If either of these checks fails, then the client MUST abort the handshake with an ""illegal_parameter"" alert. Otherwise, when sending the new ClientHello, the client MUST",selected_group: The mutually supported group the server intends to negotiate and is requesting a retried ClientHello/KeyShare for.,"replace the original ""key_share"" extension with one containing only a new KeyShareEntry for the group indicated in the selected_group field of the triggering HelloRetryRequest.",4.2.8,Key Share,3,11,1,MUST
"If either of these checks fails, then the client MUST abort the handshake with an ""illegal_parameter"" alert.","The selected_group field does not correspond to a group provided in the 'supported_groups' extension in the original ClientHello.,The selected_group field corresponds to a group provided in the 'key_share' extension in the original ClientHello.",The client MUST abort the handshake with an 'illegal_parameter' alert.,MUST,"Upon receipt of this extension in a HelloRetryRequest, the client MUST verify that (1) the selected_group field corresponds to a group which was provided in the ""supported_groups"" extension in the original ClientHello and (2) the selected_group field does not correspond to a group which was provided in the ""key_share"" extension in the original ClientHello. If either of these checks fails, then the client MUST abort the handshake with an ""illegal_parameter"" alert. Otherwise, when sending the new ClientHello, the client MUST",selected_group: The mutually supported group the server intends to negotiate and is requesting a retried ClientHello/KeyShare for.,"replace the original ""key_share"" extension with one containing only a new KeyShareEntry for the group indicated in the selected_group field of the triggering HelloRetryRequest.",4.2.8,Key Share,3,11,2,MUST
"Otherwise, when sending the new ClientHello, the client MUST",The client has successfully received a HelloRetryRequest and verified that the selected_group field corresponds to a group provided in the 'supported_groups' extension and does not correspond to a group provided in the 'key_share' extension in the original ClientHello.,"When sending the new ClientHello, the client MUST replace the original 'key_share' extension with one containing only a new KeyShareEntry for the group indicated in the selected_group field of the triggering HelloRetryRequest.",MUST,"Upon receipt of this extension in a HelloRetryRequest, the client MUST verify that (1) the selected_group field corresponds to a group which was provided in the ""supported_groups"" extension in the original ClientHello and (2) the selected_group field does not correspond to a group which was provided in the ""key_share"" extension in the original ClientHello. If either of these checks fails, then the client MUST abort the handshake with an ""illegal_parameter"" alert. Otherwise, when sending the new ClientHello, the client MUST",selected_group: The mutually supported group the server intends to negotiate and is requesting a retried ClientHello/KeyShare for.,"replace the original ""key_share"" extension with one containing only a new KeyShareEntry for the group indicated in the selected_group field of the triggering HelloRetryRequest.",4.2.8,Key Share,3,11,3,MUST
This value MUST be in the same group as the KeyShareEntry value offered by the client that the server has selected for the negotiated key exchange.,When the server selects a KeyShareEntry value offered by the client for the negotiated key exchange.,The value MUST be in the same group as the client's selected KeyShareEntry.,MUST,"If using (EC)DHE key establishment, servers offer exactly one KeyShareEntry in the ServerHello. This value MUST be in the same group as the KeyShareEntry value offered by the client that the server has selected for the negotiated key exchange. Servers MUST NOT send a KeyShareEntry for any group not indicated in the client's ""supported_groups"" extension and MUST NOT send a KeyShareEntry when using the ""psk_ke"" PskKeyExchangeMode. If using (EC)DHE key establishment and a HelloRetryRequest containing a ""key_share"" extension was received by the client, the client MUST verify that the selected NamedGroup in the ServerHello is the same as that in the HelloRetryRequest. If this check fails, the client MUST abort the handshake with an ""illegal_parameter"" alert.",server_share: A single KeyShareEntry value that is in the same group as one of the client's shares.,Diffie-Hellman [DH76] parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure. The opaque value contains the Diffie-Hellman public value (Y = g^X mod p) for the specified group (see [RFC7919] for group definitions) encoded as a big-endian integer and padded to the left with zeros to the size of p in bytes.,4.2.8,Key Share,3,15,2,MUST
"Servers MUST NOT send a KeyShareEntry for any group not indicated in the client's ""supported_groups"" extension and MUST NOT send a KeyShareEntry when using the ""psk_ke"" PskKeyExchangeMode.","The group for which a KeyShareEntry would be sent is not indicated in the client's 'supported_groups' extension,The server is using the 'psk_ke' PskKeyExchangeMode",Servers MUST NOT send a KeyShareEntry when either condition is met,MUST NOT,"If using (EC)DHE key establishment, servers offer exactly one KeyShareEntry in the ServerHello. This value MUST be in the same group as the KeyShareEntry value offered by the client that the server has selected for the negotiated key exchange. Servers MUST NOT send a KeyShareEntry for any group not indicated in the client's ""supported_groups"" extension and MUST NOT send a KeyShareEntry when using the ""psk_ke"" PskKeyExchangeMode. If using (EC)DHE key establishment and a HelloRetryRequest containing a ""key_share"" extension was received by the client, the client MUST verify that the selected NamedGroup in the ServerHello is the same as that in the HelloRetryRequest. If this check fails, the client MUST abort the handshake with an ""illegal_parameter"" alert.",server_share: A single KeyShareEntry value that is in the same group as one of the client's shares.,Diffie-Hellman [DH76] parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure. The opaque value contains the Diffie-Hellman public value (Y = g^X mod p) for the specified group (see [RFC7919] for group definitions) encoded as a big-endian integer and padded to the left with zeros to the size of p in bytes.,4.2.8,Key Share,3,15,3,MUST
"If using (EC)DHE key establishment and a HelloRetryRequest containing a ""key_share"" extension was received by the client, the client MUST verify that the selected NamedGroup in the ServerHello is the same as that in the HelloRetryRequest.",The client is using (EC)DHE key establishment and has received a HelloRetryRequest containing a 'key_share' extension.,The client MUST verify that the selected NamedGroup in the ServerHello is the same as that in the HelloRetryRequest.,MUST,"If using (EC)DHE key establishment, servers offer exactly one KeyShareEntry in the ServerHello. This value MUST be in the same group as the KeyShareEntry value offered by the client that the server has selected for the negotiated key exchange. Servers MUST NOT send a KeyShareEntry for any group not indicated in the client's ""supported_groups"" extension and MUST NOT send a KeyShareEntry when using the ""psk_ke"" PskKeyExchangeMode. If using (EC)DHE key establishment and a HelloRetryRequest containing a ""key_share"" extension was received by the client, the client MUST verify that the selected NamedGroup in the ServerHello is the same as that in the HelloRetryRequest. If this check fails, the client MUST abort the handshake with an ""illegal_parameter"" alert.",server_share: A single KeyShareEntry value that is in the same group as one of the client's shares.,Diffie-Hellman [DH76] parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure. The opaque value contains the Diffie-Hellman public value (Y = g^X mod p) for the specified group (see [RFC7919] for group definitions) encoded as a big-endian integer and padded to the left with zeros to the size of p in bytes.,4.2.8,Key Share,3,15,4,MUST
"If this check fails, the client MUST abort the handshake with an ""illegal_parameter"" alert.",The client verifies that the selected NamedGroup in the ServerHello is the same as that in the HelloRetryRequest and the verification fails.,"The client MUST abort the handshake with an ""illegal_parameter"" alert.",MUST,"If using (EC)DHE key establishment, servers offer exactly one KeyShareEntry in the ServerHello. This value MUST be in the same group as the KeyShareEntry value offered by the client that the server has selected for the negotiated key exchange. Servers MUST NOT send a KeyShareEntry for any group not indicated in the client's ""supported_groups"" extension and MUST NOT send a KeyShareEntry when using the ""psk_ke"" PskKeyExchangeMode. If using (EC)DHE key establishment and a HelloRetryRequest containing a ""key_share"" extension was received by the client, the client MUST verify that the selected NamedGroup in the ServerHello is the same as that in the HelloRetryRequest. If this check fails, the client MUST abort the handshake with an ""illegal_parameter"" alert.",server_share: A single KeyShareEntry value that is in the same group as one of the client's shares.,Diffie-Hellman [DH76] parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure. The opaque value contains the Diffie-Hellman public value (Y = g^X mod p) for the specified group (see [RFC7919] for group definitions) encoded as a big-endian integer and padded to the left with zeros to the size of p in bytes.,4.2.8,Key Share,3,15,5,MUST
Peers MUST validate each other's public key Y by ensuring that 1 < Y < p-1.,When a peer's public key Y is received for comparison.,Validate the public key Y by ensuring that 1 < Y < p-1.,MUST,Peers MUST validate each other's public key Y by ensuring that 1 < Y < p-1. This check ensures that the remote peer is properly behaved and isn't forcing the local system into a small subgroup.,"Note: For a given Diffie-Hellman group, the padding results in all public keys having the same length.",ECDHE parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure.,4.2.8,Key Share,3,18,1,MUST
"For the curves secp256r1, secp384r1, and secp521r1, peers MUST validate each other's public value Q by ensuring that the point is a valid point on the elliptic curve.","When the elliptic curves secp256r1, secp384r1, or secp521r1 are used and a peer receives a public value Q from another peer.","The peer MUST validate the public value Q by ensuring that the point is a valid point on the elliptic curve, according to the procedures defined (including verifying that Q is not the point at infinity, that its x and y components are within the correct intervals, and that (x, y) satisfies the curve equation).",MUST,"For the curves secp256r1, secp384r1, and secp521r1, peers MUST validate each other's public value Q by ensuring that the point is a valid point on the elliptic curve. The appropriate validation procedures are defined in Section 4.3.7 of [ECDSA] and alternatively in Section 5.6.2.3 of [KEYAGREEMENT]. This process consists of three steps: (1) verify that Q is not the point at infinity (O), (2) verify that for Q = (x, y) both integers x and y are in the correct interval, and (3) ensure that (x, y) is a correct solution to the elliptic curve equation. For these curves, implementors do not need to verify membership in the correct subgroup.","X and Y, respectively, are the binary representations of the x and y values in network byte order. There are no internal length markers, so each number representation occupies as many octets as implied by the curve parameters. For P-256, this means that each of X and Y use 32 octets, padded on the left by zeros if necessary. For P-384, they take 48 octets each. For P-521, they take 66 octets each.","For X25519 and X448, the contents of the public value are the byte string inputs and outputs of the corresponding functions defined in [RFC7748]: 32 bytes for X25519 and 56 bytes for X448.",4.2.8,Key Share,3,22,1,MUST
"In order to use PSKs, clients MUST also send a ""psk_key_exchange_modes"" extension.",When a client intends to use PSKs,The client MUST send a 'psk_key_exchange_modes' extension,MUST,"In order to use PSKs, clients MUST also send a ""psk_key_exchange_modes"" extension. The semantics of this extension are that the client only supports the use of PSKs with these modes, which restricts both the use of PSKs offered in this ClientHello and those which the server might supply via NewSessionTicket.",,"A client MUST provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension. If clients offer ""pre_shared_key"" without a ""psk_key_exchange_modes"" extension, servers MUST abort the handshake. Servers MUST NOT select a key exchange mode that is not listed by the client. This extension also restricts the modes for use with PSK resumption. Servers SHOULD NOT send NewSessionTicket with tickets that are not compatible with the advertised modes; however, if a server does so, the impact will just be that the client's attempts at resumption fail.",4.2.9,Pre-Shared Key Exchange Modes,3,1,1,MUST
"A client MUST provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension.",The client offers a 'pre_shared_key' extension.,The client MUST provide a 'psk_key_exchange_modes' extension.,MUST,"A client MUST provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension. If clients offer ""pre_shared_key"" without a ""psk_key_exchange_modes"" extension, servers MUST abort the handshake. Servers MUST NOT select a key exchange mode that is not listed by the client. This extension also restricts the modes for use with PSK resumption. Servers SHOULD NOT send NewSessionTicket with tickets that are not compatible with the advertised modes; however, if a server does so, the impact will just be that the client's attempts at resumption fail.","In order to use PSKs, clients MUST also send a ""psk_key_exchange_modes"" extension. The semantics of this extension are that the client only supports the use of PSKs with these modes, which restricts both the use of PSKs offered in this ClientHello and those which the server might supply via NewSessionTicket.","The server MUST NOT send a ""psk_key_exchange_modes"" extension.",4.2.9,Pre-Shared Key Exchange Modes,3,2,1,MUST
"If clients offer ""pre_shared_key"" without a ""psk_key_exchange_modes"" extension, servers MUST abort the handshake.",Clients offer a 'pre_shared_key' extension without including a 'psk_key_exchange_modes' extension.,Servers MUST abort the handshake.,MUST,"A client MUST provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension. If clients offer ""pre_shared_key"" without a ""psk_key_exchange_modes"" extension, servers MUST abort the handshake. Servers MUST NOT select a key exchange mode that is not listed by the client. This extension also restricts the modes for use with PSK resumption. Servers SHOULD NOT send NewSessionTicket with tickets that are not compatible with the advertised modes; however, if a server does so, the impact will just be that the client's attempts at resumption fail.","In order to use PSKs, clients MUST also send a ""psk_key_exchange_modes"" extension. The semantics of this extension are that the client only supports the use of PSKs with these modes, which restricts both the use of PSKs offered in this ClientHello and those which the server might supply via NewSessionTicket.","The server MUST NOT send a ""psk_key_exchange_modes"" extension.",4.2.9,Pre-Shared Key Exchange Modes,3,2,2,MUST
Servers MUST NOT select a key exchange mode that is not listed by the client.,"When a server is selecting a key exchange mode for use with PSK, particularly during the handshake where the client has provided a list of supported key exchange modes via the 'psk_key_exchange_modes' extension.","The server MUST only select a key exchange mode that is listed by the client, and MUST NOT select any key exchange mode that is not included in the client's advertised list.",MUST NOT,"A client MUST provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension. If clients offer ""pre_shared_key"" without a ""psk_key_exchange_modes"" extension, servers MUST abort the handshake. Servers MUST NOT select a key exchange mode that is not listed by the client. This extension also restricts the modes for use with PSK resumption. Servers SHOULD NOT send NewSessionTicket with tickets that are not compatible with the advertised modes; however, if a server does so, the impact will just be that the client's attempts at resumption fail.","In order to use PSKs, clients MUST also send a ""psk_key_exchange_modes"" extension. The semantics of this extension are that the client only supports the use of PSKs with these modes, which restricts both the use of PSKs offered in this ClientHello and those which the server might supply via NewSessionTicket.","The server MUST NOT send a ""psk_key_exchange_modes"" extension.",4.2.9,Pre-Shared Key Exchange Modes,3,2,3,MUST
"Servers SHOULD NOT send NewSessionTicket with tickets that are not compatible with the advertised modes; however, if a server does so, the impact will just be that the client's attempts at resumption fail.",A server sends a NewSessionTicket with tickets that are not compatible with the advertised modes,Servers SHOULD NOT send NewSessionTicket with tickets that are not compatible with the advertised modes,SHOULD NOT,"A client MUST provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension. If clients offer ""pre_shared_key"" without a ""psk_key_exchange_modes"" extension, servers MUST abort the handshake. Servers MUST NOT select a key exchange mode that is not listed by the client. This extension also restricts the modes for use with PSK resumption. Servers SHOULD NOT send NewSessionTicket with tickets that are not compatible with the advertised modes; however, if a server does so, the impact will just be that the client's attempts at resumption fail.","In order to use PSKs, clients MUST also send a ""psk_key_exchange_modes"" extension. The semantics of this extension are that the client only supports the use of PSKs with these modes, which restricts both the use of PSKs offered in this ClientHello and those which the server might supply via NewSessionTicket.","The server MUST NOT send a ""psk_key_exchange_modes"" extension.",4.2.9,Pre-Shared Key Exchange Modes,3,2,5,SHOULD
"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",MUST NOT,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.","A client MUST provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension. If clients offer ""pre_shared_key"" without a ""psk_key_exchange_modes"" extension, servers MUST abort the handshake. Servers MUST NOT select a key exchange mode that is not listed by the client. This extension also restricts the modes for use with PSK resumption. Servers SHOULD NOT send NewSessionTicket with tickets that are not compatible with the advertised modes; however, if a server does so, the impact will just be that the client's attempts at resumption fail.","psk_ke: PSK-only key establishment. In this mode, the server MUST NOT supply a ""key_share"" value.",4.2.9,Pre-Shared Key Exchange Modes,3,3,1,MUST
"In this mode, the server MUST NOT supply a ""key_share"" value.",When operating in PSK-only key establishment mode (psk_ke),The server MUST NOT supply a 'key_share' value.,MUST NOT,"psk_ke: PSK-only key establishment. In this mode, the server MUST NOT supply a ""key_share"" value.","The server MUST NOT send a ""psk_key_exchange_modes"" extension.","psk_dhe_ke: PSK with (EC)DHE key establishment. In this mode, the client and server MUST supply ""key_share"" values as described in Section 4.2.8.",4.2.9,Pre-Shared Key Exchange Modes,3,4,2,MUST
"In this mode, the client and server MUST supply ""key_share"" values as described in Section 4.2.8.",When operating in the PSK with (EC)DHE key establishment mode (psk_dhe_ke),The client and server MUST supply 'key_share' values as described in Section 4.2.8.,MUST,"psk_dhe_ke: PSK with (EC)DHE key establishment. In this mode, the client and server MUST supply ""key_share"" values as described in Section 4.2.8.","psk_ke: PSK-only key establishment. In this mode, the server MUST NOT supply a ""key_share"" value.","Any future values that are allocated must ensure that the transmitted protocol messages unambiguously identify which mode was selected by the server; at present, this is indicated by the presence of the ""key_share"" in the ServerHello.",4.2.9,Pre-Shared Key Exchange Modes,3,5,2,MUST
"If the client opts to do so, it MUST supply both the ""pre_shared_key"" and ""early_data"" extensions.","The client opts to send Application Data in its first flight of messages (i.e., the client has decided to use early data and PSK).",The client MUST supply both the 'pre_shared_key' and 'early_data' extensions.,MUST,"When a PSK is used and early data is allowed for that PSK, the client can send Application Data in its first flight of messages. If the client opts to do so, it MUST supply both the ""pre_shared_key"" and ""early_data"" extensions.",,"The ""extension_data"" field of this extension contains an ""EarlyDataIndication"" value.",4.2.10,Early Data Indication,3,1,2,MUST
"The PSK used to encrypt the early data MUST be the first PSK listed in the client's ""pre_shared_key"" extension.",When early data is encrypted using a PSK provided in the client's 'pre_shared_key' extension,The PSK used to encrypt the early data MUST be the first PSK listed in the client's 'pre_shared_key' extension,MUST,"The parameters for the 0-RTT data (version, symmetric cipher suite, Application-Layer Protocol Negotiation (ALPN) [RFC7301] protocol, etc.) are those associated with the PSK in use. For externally provisioned PSKs, the associated values are those provisioned along with the key. For PSKs established via a NewSessionTicket message, the associated values are those which were negotiated in the connection which established the PSK. The PSK used to encrypt the early data MUST be the first PSK listed in the client's ""pre_shared_key"" extension.",See Section 4.6.1 for details regarding the use of the max_early_data_size field.,"For PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued (see Section 8). If it is not, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.",4.2.10,Early Data Indication,3,4,4,MUST
"For PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued (see Section 8).","The PSK is provisioned via NewSessionTicket (i.e., the server is handling a PSK identity established via a NewSessionTicket).",The server MUST validate that the ticket age for the selected PSK identity—computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32—is within a small tolerance of the time elapsed since the ticket was issued.,MUST,"For PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued (see Section 8). If it is not, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.","The parameters for the 0-RTT data (version, symmetric cipher suite, Application-Layer Protocol Negotiation (ALPN) [RFC7301] protocol, etc.) are those associated with the PSK in use. For externally provisioned PSKs, the associated values are those provisioned along with the key. For PSKs established via a NewSessionTicket message, the associated values are those which were negotiated in the connection which established the PSK. The PSK used to encrypt the early data MUST be the first PSK listed in the client's ""pre_shared_key"" extension.","0-RTT messages sent in the first flight have the same (encrypted) content types as messages of the same type sent in other flights (handshake and application_data) but are protected under different keys. After receiving the server's Finished message, if the server has accepted early data, an EndOfEarlyData message will be sent to indicate the key change. This message will be encrypted with the 0-RTT traffic keys.",4.2.10,Early Data Indication,3,5,1,MUST
"If it is not, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.",The ticket age for the selected PSK identity is not within a small tolerance of the time since the ticket was issued,"Proceed with the handshake while rejecting 0-RTT,Do not take any further action that assumes that the ClientHello is fresh","SHOULD, SHOULD NOT","For PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued (see Section 8). If it is not, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.","The parameters for the 0-RTT data (version, symmetric cipher suite, Application-Layer Protocol Negotiation (ALPN) [RFC7301] protocol, etc.) are those associated with the PSK in use. For externally provisioned PSKs, the associated values are those provisioned along with the key. For PSKs established via a NewSessionTicket message, the associated values are those which were negotiated in the connection which established the PSK. The PSK used to encrypt the early data MUST be the first PSK listed in the client's ""pre_shared_key"" extension.","0-RTT messages sent in the first flight have the same (encrypted) content types as messages of the same type sent in other flights (handshake and application_data) but are protected under different keys. After receiving the server's Finished message, if the server has accepted early data, an EndOfEarlyData message will be sent to indicate the key change. This message will be encrypted with the 0-RTT traffic keys.",4.2.10,Early Data Indication,3,5,2,SHOULD
"A server which receives an ""early_data"" extension MUST behave in one of three ways:","The server receives an ""early_data"" extension.","The server MUST behave in one of three prescribed ways. In one option, it should ignore the extension, return a regular 1-RTT response, skip past early data by attempting to deprotect received records using the handshake traffic key (discarding records that fail deprotection up to the configured max_early_data_size), and then treat a successfully deprotected record as the start of the client's second flight, proceeding with an ordinary 1-RTT handshake.",MUST,"A server which receives an ""early_data"" extension MUST behave in one of three ways:","0-RTT messages sent in the first flight have the same (encrypted) content types as messages of the same type sent in other flights (handshake and application_data) but are protected under different keys. After receiving the server's Finished message, if the server has accepted early data, an EndOfEarlyData message will be sent to indicate the key change. This message will be encrypted with the 0-RTT traffic keys.","-Ignore the extension and return a regular 1-RTT response. The server then skips past early data by attempting to deprotect received records using the handshake traffic key, discarding records which fail deprotection (up to the configured max_early_data_size). Once a record is deprotected successfully, it is treated as the start of the client's second flight and the server proceeds as with an ordinary 1-RTT handshake.",4.2.10,Early Data Indication,3,7,1,MUST
"A client MUST NOT include the ""early_data"" extension in its followup ClientHello.",The client is sending a followup ClientHello (in response to a HelloRetryRequest).,The client MUST NOT include the 'early_data' extension in its followup ClientHello.,MUST NOT,"-Request that the client send another ClientHello by responding with a HelloRetryRequest. A client MUST NOT include the ""early_data"" extension in its followup ClientHello. The server then ignores early data by skipping all records with an external content type of ""application_data"" (indicating that they are encrypted), up to the configured max_early_data_size.","-Ignore the extension and return a regular 1-RTT response. The server then skips past early data by attempting to deprotect received records using the handshake traffic key, discarding records which fail deprotection (up to the configured max_early_data_size). Once a record is deprotected successfully, it is treated as the start of the client's second flight and the server proceeds as with an ordinary 1-RTT handshake.","-Return its own ""early_data"" extension in EncryptedExtensions, indicating that it intends to process the early data. It is not possible for the server to accept only a subset of the early data messages. Even though the server sends a message accepting early data, the actual early data itself may already be in flight by the time the server generates this message.",4.2.10,Early Data Indication,3,9,2,MUST
"In order to accept early data, the server MUST have accepted a PSK cipher suite and selected the first key offered in the client's ""pre_shared_key"" extension.",When the server intends to accept early data.,"The server MUST accept a PSK cipher suite and select the first key offered in the client's ""pre_shared_key"" extension.",MUST,"In order to accept early data, the server MUST have accepted a PSK cipher suite and selected the first key offered in the client's ""pre_shared_key"" extension. In addition, it MUST verify that the following values are the same as those associated with the selected PSK:","-Return its own ""early_data"" extension in EncryptedExtensions, indicating that it intends to process the early data. It is not possible for the server to accept only a subset of the early data messages. Even though the server sends a message accepting early data, the actual early data itself may already be in flight by the time the server generates this message.",-The TLS version number,4.2.10,Early Data Indication,3,11,1,MUST
"In addition, it MUST verify that the following values are the same as those associated with the selected PSK:",The server is processing early data after accepting a PSK cipher suite and selecting the first key offered in the client's 'pre_shared_key' extension.,The server MUST verify that the specified values (such as the TLS version number) are identical to those associated with the selected PSK.,MUST,"In order to accept early data, the server MUST have accepted a PSK cipher suite and selected the first key offered in the client's ""pre_shared_key"" extension. In addition, it MUST verify that the following values are the same as those associated with the selected PSK:","-Return its own ""early_data"" extension in EncryptedExtensions, indicating that it intends to process the early data. It is not possible for the server to accept only a subset of the early data messages. Even though the server sends a message accepting early data, the actual early data itself may already be in flight by the time the server generates this message.",-The TLS version number,4.2.10,Early Data Indication,3,11,2,MUST
Future extensions MUST define their interaction with 0-RTT.,"When a future extension is being developed or defined, especially one that might interact with 0-RTT.",The future extension MUST explicitly define its interaction with 0-RTT.,MUST,Future extensions MUST define their interaction with 0-RTT.,"These requirements are a superset of those needed to perform a 1-RTT handshake using the PSK in question. For externally established PSKs, the associated values are those provisioned along with the key. For PSKs established via a NewSessionTicket message, the associated values are those negotiated in the connection during which the ticket was established.","If any of these checks fail, the server MUST NOT respond with the extension and must discard all the first-flight data using one of the first two mechanisms listed above (thus falling back to 1-RTT or 2-RTT). If the client attempts a 0-RTT handshake but the server rejects it, the server will generally not have the 0-RTT record protection keys and must instead use trial decryption (either with the 1-RTT handshake keys or by looking for a cleartext ClientHello in the case of a HelloRetryRequest) to find the first non-0-RTT message.",4.2.10,Early Data Indication,3,16,1,MUST
"If any of these checks fail, the server MUST NOT respond with the extension and must discard all the first-flight data using one of the first two mechanisms listed above (thus falling back to 1-RTT or 2-RTT).",Any failure of the checks defined earlier in the document,The server MUST NOT respond with the extension and MUST discard all the first-flight data using one of the first two specified mechanisms (thus falling back to 1-RTT or 2-RTT),MUST NOT,"If any of these checks fail, the server MUST NOT respond with the extension and must discard all the first-flight data using one of the first two mechanisms listed above (thus falling back to 1-RTT or 2-RTT). If the client attempts a 0-RTT handshake but the server rejects it, the server will generally not have the 0-RTT record protection keys and must instead use trial decryption (either with the 1-RTT handshake keys or by looking for a cleartext ClientHello in the case of a HelloRetryRequest) to find the first non-0-RTT message.",Future extensions MUST define their interaction with 0-RTT.,"If the server chooses to accept the ""early_data"" extension, then it MUST comply with the same error-handling requirements specified for all records when processing early data records. Specifically, if the server fails to decrypt a 0-RTT record following an accepted ""early_data"" extension, it MUST terminate the connection with a ""bad_record_mac"" alert as per Section 5.2.",4.2.10,Early Data Indication,3,17,1,MUST
"If the server chooses to accept the ""early_data"" extension, then it MUST comply with the same error-handling requirements specified for all records when processing early data records.","The server chooses to accept the 'early_data' extension.,The server fails to decrypt a 0-RTT record following an accepted 'early_data' extension.","The server MUST comply with the error-handling requirements specified for all records when processing early data records, specifically terminating the connection with a 'bad_record_mac' alert if decryption of a 0-RTT record fails.",MUST,"If the server chooses to accept the ""early_data"" extension, then it MUST comply with the same error-handling requirements specified for all records when processing early data records. Specifically, if the server fails to decrypt a 0-RTT record following an accepted ""early_data"" extension, it MUST terminate the connection with a ""bad_record_mac"" alert as per Section 5.2.","If any of these checks fail, the server MUST NOT respond with the extension and must discard all the first-flight data using one of the first two mechanisms listed above (thus falling back to 1-RTT or 2-RTT). If the client attempts a 0-RTT handshake but the server rejects it, the server will generally not have the 0-RTT record protection keys and must instead use trial decryption (either with the 1-RTT handshake keys or by looking for a cleartext ClientHello in the case of a HelloRetryRequest) to find the first non-0-RTT message.","If the server rejects the ""early_data"" extension, the client application MAY opt to retransmit the Application Data previously sent in early data once the handshake has been completed. Note that automatic retransmission of early data could result in incorrect assumptions regarding the status of the connection. For instance, when the negotiated connection selects a different ALPN protocol from what was used for the early data, an application might need to construct different messages. Similarly, if early data assumes anything about the connection state, it might be sent in error after the handshake completes.",4.2.10,Early Data Indication,3,18,1,MUST
"Specifically, if the server fails to decrypt a 0-RTT record following an accepted ""early_data"" extension, it MUST terminate the connection with a ""bad_record_mac"" alert as per Section 5.2.",If the server fails to decrypt a 0-RTT record following an accepted 'early_data' extension,The server MUST terminate the connection with a 'bad_record_mac' alert as per Section 5.2,MUST,"If the server chooses to accept the ""early_data"" extension, then it MUST comply with the same error-handling requirements specified for all records when processing early data records. Specifically, if the server fails to decrypt a 0-RTT record following an accepted ""early_data"" extension, it MUST terminate the connection with a ""bad_record_mac"" alert as per Section 5.2.","If any of these checks fail, the server MUST NOT respond with the extension and must discard all the first-flight data using one of the first two mechanisms listed above (thus falling back to 1-RTT or 2-RTT). If the client attempts a 0-RTT handshake but the server rejects it, the server will generally not have the 0-RTT record protection keys and must instead use trial decryption (either with the 1-RTT handshake keys or by looking for a cleartext ClientHello in the case of a HelloRetryRequest) to find the first non-0-RTT message.","If the server rejects the ""early_data"" extension, the client application MAY opt to retransmit the Application Data previously sent in early data once the handshake has been completed. Note that automatic retransmission of early data could result in incorrect assumptions regarding the status of the connection. For instance, when the negotiated connection selects a different ALPN protocol from what was used for the early data, an application might need to construct different messages. Similarly, if early data assumes anything about the connection state, it might be sent in error after the handshake completes.",4.2.10,Early Data Indication,3,18,2,MUST
"If the server rejects the ""early_data"" extension, the client application MAY opt to retransmit the Application Data previously sent in early data once the handshake has been completed.",The server rejects the 'early_data' extension.,The client application MAY opt to retransmit the Application Data previously sent in early data once the handshake has been completed.,MAY,"If the server rejects the ""early_data"" extension, the client application MAY opt to retransmit the Application Data previously sent in early data once the handshake has been completed. Note that automatic retransmission of early data could result in incorrect assumptions regarding the status of the connection. For instance, when the negotiated connection selects a different ALPN protocol from what was used for the early data, an application might need to construct different messages. Similarly, if early data assumes anything about the connection state, it might be sent in error after the handshake completes.","If the server chooses to accept the ""early_data"" extension, then it MUST comply with the same error-handling requirements specified for all records when processing early data records. Specifically, if the server fails to decrypt a 0-RTT record following an accepted ""early_data"" extension, it MUST terminate the connection with a ""bad_record_mac"" alert as per Section 5.2.",A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate. A TLS implementation MUST NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol.,4.2.10,Early Data Indication,3,19,1,MAY
A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,"The TLS implementation contemplates automatically resending early data.,The negotiated connection does not select the same ALPN protocol.","The TLS implementation MUST NOT automatically resend early data (i.e., it should delegate retransmission decisions to the application), except when the negotiated connection selects the same ALPN protocol.",SHOULD NOT,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate. A TLS implementation MUST NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol.,"If the server rejects the ""early_data"" extension, the client application MAY opt to retransmit the Application Data previously sent in early data once the handshake has been completed. Note that automatic retransmission of early data could result in incorrect assumptions regarding the status of the connection. For instance, when the negotiated connection selects a different ALPN protocol from what was used for the early data, an application might need to construct different messages. Similarly, if early data assumes anything about the connection state, it might be sent in error after the handshake completes.",,4.2.10,Early Data Indication,3,20,1,SHOULD
A TLS implementation MUST NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol.,When the negotiated connection does not select the same ALPN protocol as the one used for early data,The TLS implementation MUST NOT automatically resend early data,MUST NOT,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate. A TLS implementation MUST NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol.,"If the server rejects the ""early_data"" extension, the client application MAY opt to retransmit the Application Data previously sent in early data once the handshake has been completed. Note that automatic retransmission of early data could result in incorrect assumptions regarding the status of the connection. For instance, when the negotiated connection selects a different ALPN protocol from what was used for the early data, an application might need to construct different messages. Similarly, if early data assumes anything about the connection state, it might be sent in error after the handshake completes.",,4.2.10,Early Data Indication,3,20,2,MUST
"For identities established externally, an obfuscated_ticket_age of 0 SHOULD be used, and servers MUST ignore the value.",When the identity is established externally,"An obfuscated_ticket_age of 0 SHOULD be used,Servers MUST ignore the provided obfuscated_ticket_age value","MUST, SHOULD","obfuscated_ticket_age: An obfuscated version of the age of the key. Section 4.2.11.1 describes how to form this value for identities established via the NewSessionTicket message. For identities established externally, an obfuscated_ticket_age of 0 SHOULD be used, and servers MUST ignore the value.","identity: A label for a key. For instance, a ticket (as defined in Appendix B.3.4) or a label for a pre-shared key established externally.","identities: A list of the identities that the client is willing to negotiate with the server. If sent alongside the ""early_data"" extension (see Section 4.2.10), the first identity is the one used for 0-RTT data.",4.2.11,Pre-Shared Key Extension,3,4,3,MUST
"For externally established PSKs, the Hash algorithm MUST be set when","This requirement applies to externally established PSKs, and it is triggered when a PSK is established.","The Hash algorithm MUST be set for the externally established PSK. If no algorithm is defined, it MUST default to SHA-256, and the server MUST ensure that it selects a compatible PSK (if any) and cipher suite.",MUST,"Each PSK is associated with a single Hash algorithm. For PSKs established via the ticket mechanism (Section 4.6.1), this is the KDF Hash algorithm on the connection where the ticket was established. For externally established PSKs, the Hash algorithm MUST be set when",selected_identity: The server's chosen identity expressed as a (0-based) index into the identities in the client's list.,the PSK is established or default to SHA-256 if no such algorithm is defined. The server MUST ensure that it selects a compatible PSK (if any) and cipher suite.,4.2.11,Pre-Shared Key Extension,3,8,3,MUST
The server MUST ensure that it selects a compatible PSK (if any) and cipher suite.,When a PSK is provided or available (if any),The server MUST select a compatible PSK and cipher suite,MUST,the PSK is established or default to SHA-256 if no such algorithm is defined. The server MUST ensure that it selects a compatible PSK (if any) and cipher suite.,"Each PSK is associated with a single Hash algorithm. For PSKs established via the ticket mechanism (Section 4.6.1), this is the KDF Hash algorithm on the connection where the ticket was established. For externally established PSKs, the Hash algorithm MUST be set when","In TLS versions prior to TLS 1.3, the Server Name Identification (SNI) value was intended to be associated with the session (Section 3 of [RFC6066]), with the server being required to enforce that the SNI value associated with the session matches the one specified in the resumption handshake. However, in reality the implementations were not consistent on which of two supplied SNI values they would use, leading to the consistency requirement being de facto enforced by the clients. In TLS 1.3, the SNI value is always explicitly specified in the resumption handshake, and there is no need for the server to associate an SNI value with the ticket. Clients, however, SHOULD store the SNI with the PSK to fulfill the requirements of Section 4.6.1.",4.2.11,Pre-Shared Key Extension,3,9,2,MUST
"Clients, however, SHOULD store the SNI with the PSK to fulfill the requirements of Section 4.6.1.",,Clients SHOULD store the SNI with the PSK to fulfill the requirements of Section 4.6.1.,SHOULD,"In TLS versions prior to TLS 1.3, the Server Name Identification (SNI) value was intended to be associated with the session (Section 3 of [RFC6066]), with the server being required to enforce that the SNI value associated with the session matches the one specified in the resumption handshake. However, in reality the implementations were not consistent on which of two supplied SNI values they would use, leading to the consistency requirement being de facto enforced by the clients. In TLS 1.3, the SNI value is always explicitly specified in the resumption handshake, and there is no need for the server to associate an SNI value with the ticket. Clients, however, SHOULD store the SNI with the PSK to fulfill the requirements of Section 4.6.1.",the PSK is established or default to SHA-256 if no such algorithm is defined. The server MUST ensure that it selects a compatible PSK (if any) and cipher suite.,"Implementor's note: When session resumption is the primary use case of PSKs, the most straightforward way to implement the PSK/cipher suite matching requirements is to negotiate the cipher suite first and then exclude any incompatible PSKs. Any unknown PSKs (e.g., ones not in the PSK database or encrypted with an unknown key) SHOULD simply be ignored. If no acceptable PSKs are found, the server SHOULD perform a non-PSK handshake if possible. If backward compatibility is important, client-provided, externally established PSKs SHOULD influence cipher suite selection.",4.2.11,Pre-Shared Key Extension,3,10,4,SHOULD
"Any unknown PSKs (e.g., ones not in the PSK database or encrypted with an unknown key) SHOULD simply be ignored.","The PSK is unknown (i.e., not present in the PSK database or encrypted with an unknown key)",The unknown PSK SHOULD simply be ignored,SHOULD,"Implementor's note: When session resumption is the primary use case of PSKs, the most straightforward way to implement the PSK/cipher suite matching requirements is to negotiate the cipher suite first and then exclude any incompatible PSKs. Any unknown PSKs (e.g., ones not in the PSK database or encrypted with an unknown key) SHOULD simply be ignored. If no acceptable PSKs are found, the server SHOULD perform a non-PSK handshake if possible. If backward compatibility is important, client-provided, externally established PSKs SHOULD influence cipher suite selection.","In TLS versions prior to TLS 1.3, the Server Name Identification (SNI) value was intended to be associated with the session (Section 3 of [RFC6066]), with the server being required to enforce that the SNI value associated with the session matches the one specified in the resumption handshake. However, in reality the implementations were not consistent on which of two supplied SNI values they would use, leading to the consistency requirement being de facto enforced by the clients. In TLS 1.3, the SNI value is always explicitly specified in the resumption handshake, and there is no need for the server to associate an SNI value with the ticket. Clients, however, SHOULD store the SNI with the PSK to fulfill the requirements of Section 4.6.1.","Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value (see Section 4.2.11.2 below). If this value is not present or does not validate, the server MUST abort the handshake. Servers SHOULD NOT attempt to validate multiple binders; rather, they SHOULD select a single PSK and validate solely the binder that corresponds to that PSK. See Section 8.2 and Appendix E.6 for the security rationale for this requirement. In order to accept PSK key establishment, the server sends a ""pre_shared_key"" extension indicating the selected identity.",4.2.11,Pre-Shared Key Extension,3,11,2,SHOULD
"If no acceptable PSKs are found, the server SHOULD perform a non-PSK handshake if possible.",No acceptable PSKs are found,The server SHOULD perform a non-PSK handshake if possible,SHOULD,"Implementor's note: When session resumption is the primary use case of PSKs, the most straightforward way to implement the PSK/cipher suite matching requirements is to negotiate the cipher suite first and then exclude any incompatible PSKs. Any unknown PSKs (e.g., ones not in the PSK database or encrypted with an unknown key) SHOULD simply be ignored. If no acceptable PSKs are found, the server SHOULD perform a non-PSK handshake if possible. If backward compatibility is important, client-provided, externally established PSKs SHOULD influence cipher suite selection.","In TLS versions prior to TLS 1.3, the Server Name Identification (SNI) value was intended to be associated with the session (Section 3 of [RFC6066]), with the server being required to enforce that the SNI value associated with the session matches the one specified in the resumption handshake. However, in reality the implementations were not consistent on which of two supplied SNI values they would use, leading to the consistency requirement being de facto enforced by the clients. In TLS 1.3, the SNI value is always explicitly specified in the resumption handshake, and there is no need for the server to associate an SNI value with the ticket. Clients, however, SHOULD store the SNI with the PSK to fulfill the requirements of Section 4.6.1.","Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value (see Section 4.2.11.2 below). If this value is not present or does not validate, the server MUST abort the handshake. Servers SHOULD NOT attempt to validate multiple binders; rather, they SHOULD select a single PSK and validate solely the binder that corresponds to that PSK. See Section 8.2 and Appendix E.6 for the security rationale for this requirement. In order to accept PSK key establishment, the server sends a ""pre_shared_key"" extension indicating the selected identity.",4.2.11,Pre-Shared Key Extension,3,11,3,SHOULD
"If backward compatibility is important, client-provided, externally established PSKs SHOULD influence cipher suite selection.",Backward compatibility is important,"Client-provided, externally established PSKs SHOULD influence cipher suite selection",SHOULD,"Implementor's note: When session resumption is the primary use case of PSKs, the most straightforward way to implement the PSK/cipher suite matching requirements is to negotiate the cipher suite first and then exclude any incompatible PSKs. Any unknown PSKs (e.g., ones not in the PSK database or encrypted with an unknown key) SHOULD simply be ignored. If no acceptable PSKs are found, the server SHOULD perform a non-PSK handshake if possible. If backward compatibility is important, client-provided, externally established PSKs SHOULD influence cipher suite selection.","In TLS versions prior to TLS 1.3, the Server Name Identification (SNI) value was intended to be associated with the session (Section 3 of [RFC6066]), with the server being required to enforce that the SNI value associated with the session matches the one specified in the resumption handshake. However, in reality the implementations were not consistent on which of two supplied SNI values they would use, leading to the consistency requirement being de facto enforced by the clients. In TLS 1.3, the SNI value is always explicitly specified in the resumption handshake, and there is no need for the server to associate an SNI value with the ticket. Clients, however, SHOULD store the SNI with the PSK to fulfill the requirements of Section 4.6.1.","Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value (see Section 4.2.11.2 below). If this value is not present or does not validate, the server MUST abort the handshake. Servers SHOULD NOT attempt to validate multiple binders; rather, they SHOULD select a single PSK and validate solely the binder that corresponds to that PSK. See Section 8.2 and Appendix E.6 for the security rationale for this requirement. In order to accept PSK key establishment, the server sends a ""pre_shared_key"" extension indicating the selected identity.",4.2.11,Pre-Shared Key Extension,3,11,4,SHOULD
"Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value (see Section 4.2.11.2 below).","When the server is about to accept PSK key establishment,If the corresponding binder value is not present or does not validate","The server MUST validate the corresponding binder value prior to accepting PSK key establishment,If the binder value is absent or fails validation, the server MUST abort the handshake,Servers SHOULD select a single PSK and validate solely the binder that corresponds to that PSK",MUST,"Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value (see Section 4.2.11.2 below). If this value is not present or does not validate, the server MUST abort the handshake. Servers SHOULD NOT attempt to validate multiple binders; rather, they SHOULD select a single PSK and validate solely the binder that corresponds to that PSK. See Section 8.2 and Appendix E.6 for the security rationale for this requirement. In order to accept PSK key establishment, the server sends a ""pre_shared_key"" extension indicating the selected identity.","Implementor's note: When session resumption is the primary use case of PSKs, the most straightforward way to implement the PSK/cipher suite matching requirements is to negotiate the cipher suite first and then exclude any incompatible PSKs. Any unknown PSKs (e.g., ones not in the PSK database or encrypted with an unknown key) SHOULD simply be ignored. If no acceptable PSKs are found, the server SHOULD perform a non-PSK handshake if possible. If backward compatibility is important, client-provided, externally established PSKs SHOULD influence cipher suite selection.","Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server ""key_share"" extension is present if required by the ClientHello ""psk_key_exchange_modes"" extension. If these values are not consistent, the client MUST abort the handshake with an ""illegal_parameter"" alert.",4.2.11,Pre-Shared Key Extension,3,12,1,MUST
"If this value is not present or does not validate, the server MUST abort the handshake.","The value is not present,The value does not validate",The server MUST abort the handshake,MUST,"Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value (see Section 4.2.11.2 below). If this value is not present or does not validate, the server MUST abort the handshake. Servers SHOULD NOT attempt to validate multiple binders; rather, they SHOULD select a single PSK and validate solely the binder that corresponds to that PSK. See Section 8.2 and Appendix E.6 for the security rationale for this requirement. In order to accept PSK key establishment, the server sends a ""pre_shared_key"" extension indicating the selected identity.","Implementor's note: When session resumption is the primary use case of PSKs, the most straightforward way to implement the PSK/cipher suite matching requirements is to negotiate the cipher suite first and then exclude any incompatible PSKs. Any unknown PSKs (e.g., ones not in the PSK database or encrypted with an unknown key) SHOULD simply be ignored. If no acceptable PSKs are found, the server SHOULD perform a non-PSK handshake if possible. If backward compatibility is important, client-provided, externally established PSKs SHOULD influence cipher suite selection.","Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server ""key_share"" extension is present if required by the ClientHello ""psk_key_exchange_modes"" extension. If these values are not consistent, the client MUST abort the handshake with an ""illegal_parameter"" alert.",4.2.11,Pre-Shared Key Extension,3,12,2,MUST
"Servers SHOULD NOT attempt to validate multiple binders; rather, they SHOULD select a single PSK and validate solely the binder that corresponds to that PSK.","When a client provides binder values for PSK key establishment, which may include multiple binders (i.e. multiple PSKs are indicated).","The server SHOULD select a single PSK and validate only the corresponding binder, and SHOULD NOT attempt to validate multiple binders.",SHOULD NOT,"Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value (see Section 4.2.11.2 below). If this value is not present or does not validate, the server MUST abort the handshake. Servers SHOULD NOT attempt to validate multiple binders; rather, they SHOULD select a single PSK and validate solely the binder that corresponds to that PSK. See Section 8.2 and Appendix E.6 for the security rationale for this requirement. In order to accept PSK key establishment, the server sends a ""pre_shared_key"" extension indicating the selected identity.","Implementor's note: When session resumption is the primary use case of PSKs, the most straightforward way to implement the PSK/cipher suite matching requirements is to negotiate the cipher suite first and then exclude any incompatible PSKs. Any unknown PSKs (e.g., ones not in the PSK database or encrypted with an unknown key) SHOULD simply be ignored. If no acceptable PSKs are found, the server SHOULD perform a non-PSK handshake if possible. If backward compatibility is important, client-provided, externally established PSKs SHOULD influence cipher suite selection.","Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server ""key_share"" extension is present if required by the ClientHello ""psk_key_exchange_modes"" extension. If these values are not consistent, the client MUST abort the handshake with an ""illegal_parameter"" alert.",4.2.11,Pre-Shared Key Extension,3,12,3,SHOULD
"Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server ""key_share"" extension is present if required by the ClientHello ""psk_key_exchange_modes"" extension.","When the client receives the server’s handshake parameters (specifically, the server’s selected_identity, chosen cipher suite, and, if applicable, a server 'key_share' extension based on the ClientHello 'psk_key_exchange_modes' extension) as part of a PSK key establishment.","The client MUST verify that the server’s selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server 'key_share' extension is present if the ClientHello 'psk_key_exchange_modes' extension requires it.",MUST,"Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server ""key_share"" extension is present if required by the ClientHello ""psk_key_exchange_modes"" extension. If these values are not consistent, the client MUST abort the handshake with an ""illegal_parameter"" alert.","Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value (see Section 4.2.11.2 below). If this value is not present or does not validate, the server MUST abort the handshake. Servers SHOULD NOT attempt to validate multiple binders; rather, they SHOULD select a single PSK and validate solely the binder that corresponds to that PSK. See Section 8.2 and Appendix E.6 for the security rationale for this requirement. In order to accept PSK key establishment, the server sends a ""pre_shared_key"" extension indicating the selected identity.","If the server supplies an ""early_data"" extension, the client MUST verify that the server's selected_identity is 0. If any other value is returned, the client MUST abort the handshake with an ""illegal_parameter"" alert.",4.2.11,Pre-Shared Key Extension,3,13,1,MUST
"If these values are not consistent, the client MUST abort the handshake with an ""illegal_parameter"" alert.","The situation where the server’s selected_identity is not within the range supplied by the client, or the server selected a cipher suite does not indicate a Hash associated with the PSK, or the server key_share extension is missing when required.","The client MUST abort the handshake with an ""illegal_parameter"" alert.",MUST,"Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server ""key_share"" extension is present if required by the ClientHello ""psk_key_exchange_modes"" extension. If these values are not consistent, the client MUST abort the handshake with an ""illegal_parameter"" alert.","Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value (see Section 4.2.11.2 below). If this value is not present or does not validate, the server MUST abort the handshake. Servers SHOULD NOT attempt to validate multiple binders; rather, they SHOULD select a single PSK and validate solely the binder that corresponds to that PSK. See Section 8.2 and Appendix E.6 for the security rationale for this requirement. In order to accept PSK key establishment, the server sends a ""pre_shared_key"" extension indicating the selected identity.","If the server supplies an ""early_data"" extension, the client MUST verify that the server's selected_identity is 0. If any other value is returned, the client MUST abort the handshake with an ""illegal_parameter"" alert.",4.2.11,Pre-Shared Key Extension,3,13,2,MUST
"If the server supplies an ""early_data"" extension, the client MUST verify that the server's selected_identity is 0.","The server supplies an ""early_data"" extension.,If the server's selected_identity value is not 0.","The client MUST verify that the server's selected_identity is 0.,If any other value is returned, the client MUST abort the handshake with an ""illegal_parameter"" alert.",MUST,"If the server supplies an ""early_data"" extension, the client MUST verify that the server's selected_identity is 0. If any other value is returned, the client MUST abort the handshake with an ""illegal_parameter"" alert.","Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server ""key_share"" extension is present if required by the ClientHello ""psk_key_exchange_modes"" extension. If these values are not consistent, the client MUST abort the handshake with an ""illegal_parameter"" alert.","The ""pre_shared_key"" extension MUST be the last extension in the ClientHello (this facilitates implementation as described below). Servers MUST check that it is the last extension and otherwise fail the handshake with an ""illegal_parameter"" alert.",4.2.11,Pre-Shared Key Extension,3,14,1,MUST
"If any other value is returned, the client MUST abort the handshake with an ""illegal_parameter"" alert.",The server supplies an 'early_data' extension and returns a selected_identity value that is not 0.,The client MUST abort the handshake with an 'illegal_parameter' alert.,MUST,"If the server supplies an ""early_data"" extension, the client MUST verify that the server's selected_identity is 0. If any other value is returned, the client MUST abort the handshake with an ""illegal_parameter"" alert.","Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server ""key_share"" extension is present if required by the ClientHello ""psk_key_exchange_modes"" extension. If these values are not consistent, the client MUST abort the handshake with an ""illegal_parameter"" alert.","The ""pre_shared_key"" extension MUST be the last extension in the ClientHello (this facilitates implementation as described below). Servers MUST check that it is the last extension and otherwise fail the handshake with an ""illegal_parameter"" alert.",4.2.11,Pre-Shared Key Extension,3,14,2,MUST
"The ""pre_shared_key"" extension MUST be the last extension in the ClientHello (this facilitates implementation as described below)","A ClientHello message includes the pre_shared_key extension, and its position is evaluated.","The pre_shared_key extension MUST be the last extension in the ClientHello.,Servers MUST verify that the pre_shared_key extension is the last extension, and if it is not, they MUST fail the handshake with an 'illegal_parameter' alert.",MUST,"The ""pre_shared_key"" extension MUST be the last extension in the ClientHello (this facilitates implementation as described below). Servers MUST check that it is the last extension and otherwise fail the handshake with an ""illegal_parameter"" alert.","If the server supplies an ""early_data"" extension, the client MUST verify that the server's selected_identity is 0. If any other value is returned, the client MUST abort the handshake with an ""illegal_parameter"" alert.","The client's view of the age of a ticket is the time since the receipt of the NewSessionTicket message. Clients MUST NOT attempt to use tickets which have ages greater than the ""ticket_lifetime"" value which was provided with the ticket. The ""obfuscated_ticket_age"" field of each PskIdentity contains an obfuscated version of the ticket age formed by taking the age in milliseconds and adding the ""ticket_age_add"" value that was included with the ticket (see Section 4.6.1), modulo 2^32. This addition prevents passive observers from correlating connections unless tickets are reused. Note that the ""ticket_lifetime"" field in the NewSessionTicket message is in seconds but the ""obfuscated_ticket_age"" is in milliseconds. Because ticket lifetimes are restricted to a week, 32 bits is enough to represent any plausible age, even in milliseconds.",4.2.11,Pre-Shared Key Extension,3,15,1,MUST
"Servers MUST check that it is the last extension and otherwise fail the handshake with an ""illegal_parameter"" alert.",The pre_shared_key extension is not the last extension in the ClientHello message.,Servers MUST fail the handshake with an 'illegal_parameter' alert.,MUST,"The ""pre_shared_key"" extension MUST be the last extension in the ClientHello (this facilitates implementation as described below). Servers MUST check that it is the last extension and otherwise fail the handshake with an ""illegal_parameter"" alert.","If the server supplies an ""early_data"" extension, the client MUST verify that the server's selected_identity is 0. If any other value is returned, the client MUST abort the handshake with an ""illegal_parameter"" alert.","The client's view of the age of a ticket is the time since the receipt of the NewSessionTicket message. Clients MUST NOT attempt to use tickets which have ages greater than the ""ticket_lifetime"" value which was provided with the ticket. The ""obfuscated_ticket_age"" field of each PskIdentity contains an obfuscated version of the ticket age formed by taking the age in milliseconds and adding the ""ticket_age_add"" value that was included with the ticket (see Section 4.6.1), modulo 2^32. This addition prevents passive observers from correlating connections unless tickets are reused. Note that the ""ticket_lifetime"" field in the NewSessionTicket message is in seconds but the ""obfuscated_ticket_age"" is in milliseconds. Because ticket lifetimes are restricted to a week, 32 bits is enough to represent any plausible age, even in milliseconds.",4.2.11,Pre-Shared Key Extension,3,15,2,MUST
"Clients MUST NOT attempt to use tickets which have ages greater than the ""ticket_lifetime"" value which was provided with the ticket.","A ticket’s age, as measured from the receipt of the NewSessionTicket message, exceeds the 'ticket_lifetime' value provided with that ticket.",Clients MUST NOT attempt to use tickets with ages greater than the provided 'ticket_lifetime' value.,MUST NOT,"The client's view of the age of a ticket is the time since the receipt of the NewSessionTicket message. Clients MUST NOT attempt to use tickets which have ages greater than the ""ticket_lifetime"" value which was provided with the ticket. The ""obfuscated_ticket_age"" field of each PskIdentity contains an obfuscated version of the ticket age formed by taking the age in milliseconds and adding the ""ticket_age_add"" value that was included with the ticket (see Section 4.6.1), modulo 2^32. This addition prevents passive observers from correlating connections unless tickets are reused. Note that the ""ticket_lifetime"" field in the NewSessionTicket message is in seconds but the ""obfuscated_ticket_age"" is in milliseconds. Because ticket lifetimes are restricted to a week, 32 bits is enough to represent any plausible age, even in milliseconds.","The ""pre_shared_key"" extension MUST be the last extension in the ClientHello (this facilitates implementation as described below). Servers MUST check that it is the last extension and otherwise fail the handshake with an ""illegal_parameter"" alert.","The PSK binder value forms a binding between a PSK and the current handshake, as well as a binding between the handshake in which the PSK was generated (if via a NewSessionTicket message) and the current handshake. Each entry in the binders list is computed as an HMAC over a transcript hash (see Section 4.4.1) containing a partial ClientHello up to and including the PreSharedKeyExtension.identities field. That is, it includes all of the ClientHello but not the binders list itself. The length fields for the message (including the overall length, the length of the extensions block, and the length of the ""pre_shared_key"" extension) are all set as if binders of the correct lengths were present.",4.2.11,Pre-Shared Key Extension,3,16,2,MUST
"In order to avoid deadlocks, when accepting ""early_data"", servers MUST process the client's ClientHello and then immediately send their flight of messages, rather than waiting for the client's EndOfEarlyData message before sending its ServerHello.",When accepting 'early_data',"Process the client's ClientHello and immediately send the server's flight of messages, rather than waiting for the client's EndOfEarlyData message before sending ServerHello.",MUST,"Clients are permitted to ""stream"" 0-RTT data until they receive the server's Finished, only then sending the EndOfEarlyData message, followed by the rest of the handshake. In order to avoid deadlocks, when accepting ""early_data"", servers MUST process the client's ClientHello and then immediately send their flight of messages, rather than waiting for the client's EndOfEarlyData message before sending its ServerHello.","The full ClientHello1/ClientHello2 is included in all other handshake hash computations. Note that in the first flight, Truncate(ClientHello1) is hashed directly, but in the second flight, ClientHello1 is hashed and then reinjected as a ""message_hash"" message, as described in Section 4.4.1.",,4.2.11,Pre-Shared Key Extension,3,23,2,MUST
"In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message.","The handshake context where a ServerHello message has been sent (i.e., in all handshakes)",The server MUST send the EncryptedExtensions message immediately after the ServerHello message.,MUST,"In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message. This is the first message that is encrypted under keys derived from the server_handshake_traffic_secret.",,"The EncryptedExtensions message contains extensions that can be protected, i.e., any which are not needed to establish the cryptographic context but which are not associated with individual certificates. The client MUST check EncryptedExtensions for the presence of any forbidden extensions and if any are found MUST abort the handshake with an ""illegal_parameter"" alert.",4.3.1,Encrypted Extensions,3,1,1,MUST
"The client MUST check EncryptedExtensions for the presence of any forbidden extensions and if any are found MUST abort the handshake with an ""illegal_parameter"" alert.",The EncryptedExtensions message contains any forbidden extensions,The client MUST abort the handshake with an 'illegal_parameter' alert,MUST,"The EncryptedExtensions message contains extensions that can be protected, i.e., any which are not needed to establish the cryptographic context but which are not associated with individual certificates. The client MUST check EncryptedExtensions for the presence of any forbidden extensions and if any are found MUST abort the handshake with an ""illegal_parameter"" alert.","In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message. This is the first message that is encrypted under keys derived from the server_handshake_traffic_secret.",Structure of this message:,4.3.1,Encrypted Extensions,3,2,2,MUST
A server which is authenticating with a certificate MAY optionally request a certificate from the client.,The server is authenticating with a certificate.,"The server MAY optionally request a certificate from the client.,If the certificate request message is sent, it MUST follow EncryptedExtensions.",MAY,"A server which is authenticating with a certificate MAY optionally request a certificate from the client. This message, if sent, MUST follow EncryptedExtensions.",,Structure of this message:,4.3.2,Certificate Request,3,1,1,MAY
"This message, if sent, MUST follow EncryptedExtensions.",The message is sent,The message MUST follow EncryptedExtensions,MUST,"A server which is authenticating with a certificate MAY optionally request a certificate from the client. This message, if sent, MUST follow EncryptedExtensions.",,Structure of this message:,4.3.2,Certificate Request,3,1,2,MUST
The certificate_request_context MUST be unique within the scope of this connection (thus preventing replay of client CertificateVerify messages).,The certificate_request_context field is present in the certificate request message within a connection.,The certificate_request_context MUST be unique within the scope of this connection.,MUST,"certificate_request_context: An opaque string which identifies the certificate request and which will be echoed in the client's Certificate message. The certificate_request_context MUST be unique within the scope of this connection (thus preventing replay of client CertificateVerify messages). This field SHALL be zero length unless used for the post-handshake authentication exchanges described in Section 4.6.2. When requesting post-handshake authentication, the server SHOULD make the context unpredictable to the client (e.g., by randomly generating it) in order to prevent an attacker who has temporary access to the client's private key from pre-computing valid CertificateVerify messages.",Structure of this message:,"extensions: A set of extensions describing the parameters of the certificate being requested. The ""signature_algorithms"" extension MUST be specified, and other extensions may optionally be included if defined for this message. Clients MUST ignore unrecognized extensions.",4.3.2,Certificate Request,3,3,2,MUST
"When requesting post-handshake authentication, the server SHOULD make the context unpredictable to the client (e.g., by randomly generating it) in order to prevent an attacker who has temporary access to the client's private key from pre-computing valid CertificateVerify messages.",When requesting post-handshake authentication,"The server SHOULD make the certificate_request_context unpredictable to the client (e.g., by randomly generating it) to prevent an attacker with temporary access to the client's private key from pre-computing valid CertificateVerify messages.",SHOULD,"certificate_request_context: An opaque string which identifies the certificate request and which will be echoed in the client's Certificate message. The certificate_request_context MUST be unique within the scope of this connection (thus preventing replay of client CertificateVerify messages). This field SHALL be zero length unless used for the post-handshake authentication exchanges described in Section 4.6.2. When requesting post-handshake authentication, the server SHOULD make the context unpredictable to the client (e.g., by randomly generating it) in order to prevent an attacker who has temporary access to the client's private key from pre-computing valid CertificateVerify messages.",Structure of this message:,"extensions: A set of extensions describing the parameters of the certificate being requested. The ""signature_algorithms"" extension MUST be specified, and other extensions may optionally be included if defined for this message. Clients MUST ignore unrecognized extensions.",4.3.2,Certificate Request,3,3,4,SHOULD
"The ""signature_algorithms"" extension MUST be specified, and other extensions may optionally be included if defined for this message.",,"The certificate request message MUST include the ""signature_algorithms"" extension.,Other extensions MAY be included if they are defined for this message.",MUST,"extensions: A set of extensions describing the parameters of the certificate being requested. The ""signature_algorithms"" extension MUST be specified, and other extensions may optionally be included if defined for this message. Clients MUST ignore unrecognized extensions.","certificate_request_context: An opaque string which identifies the certificate request and which will be echoed in the client's Certificate message. The certificate_request_context MUST be unique within the scope of this connection (thus preventing replay of client CertificateVerify messages). This field SHALL be zero length unless used for the post-handshake authentication exchanges described in Section 4.6.2. When requesting post-handshake authentication, the server SHOULD make the context unpredictable to the client (e.g., by randomly generating it) in order to prevent an attacker who has temporary access to the client's private key from pre-computing valid CertificateVerify messages.","In prior versions of TLS, the CertificateRequest message carried a list of signature algorithms and certificate authorities which the server would accept. In TLS 1.3, the former is expressed by sending the ""signature_algorithms"" and optionally ""signature_algorithms_cert"" extensions. The latter is expressed by sending the ""certificate_authorities"" extension (see Section 4.2.4).",4.3.2,Certificate Request,3,4,2,MUST
Clients MUST ignore unrecognized extensions.,The presence of unrecognized extensions in a certificate request message.,Clients MUST ignore the unrecognized extensions.,MUST,"extensions: A set of extensions describing the parameters of the certificate being requested. The ""signature_algorithms"" extension MUST be specified, and other extensions may optionally be included if defined for this message. Clients MUST ignore unrecognized extensions.","certificate_request_context: An opaque string which identifies the certificate request and which will be echoed in the client's Certificate message. The certificate_request_context MUST be unique within the scope of this connection (thus preventing replay of client CertificateVerify messages). This field SHALL be zero length unless used for the post-handshake authentication exchanges described in Section 4.6.2. When requesting post-handshake authentication, the server SHOULD make the context unpredictable to the client (e.g., by randomly generating it) in order to prevent an attacker who has temporary access to the client's private key from pre-computing valid CertificateVerify messages.","In prior versions of TLS, the CertificateRequest message carried a list of signature algorithms and certificate authorities which the server would accept. In TLS 1.3, the former is expressed by sending the ""signature_algorithms"" and optionally ""signature_algorithms_cert"" extensions. The latter is expressed by sending the ""certificate_authorities"" extension (see Section 4.2.4).",4.3.2,Certificate Request,3,4,3,MUST
"Servers which are authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, though they MAY send it in post-handshake authentication (see Section 4.6.2) provided that the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6).","When a server is authenticating with a PSK and is engaged in the main handshake.,When a server is authenticating with a PSK and is performing post-handshake authentication, provided that the client has sent the ""post_handshake_auth"" extension.","The server MUST NOT send the CertificateRequest message in the main handshake. However, in post-handshake authentication, the server MAY send the CertificateRequest message if the client has sent the ""post_handshake_auth"" extension.","MUST NOT, MAY","Servers which are authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, though they MAY send it in post-handshake authentication (see Section 4.6.2) provided that the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6).","In prior versions of TLS, the CertificateRequest message carried a list of signature algorithms and certificate authorities which the server would accept. In TLS 1.3, the former is expressed by sending the ""signature_algorithms"" and optionally ""signature_algorithms_cert"" extensions. The latter is expressed by sending the ""certificate_authorities"" extension (see Section 4.2.4).",,4.3.2,Certificate Request,3,6,1,MUST
The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK).,"When the agreed-upon key exchange method uses certificates for authentication (i.e., for all key exchange methods defined in this document except PSK)",The server MUST send a Certificate message,MUST,The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK).,This message conveys the endpoint's certificate chain to the peer.,"The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2). If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message containing no certificates (i.e., with the ""certificate_list"" field having length 0). A Finished message MUST be sent regardless of whether the Certificate message is empty.",4.4.2,Certificate,3,2,1,MUST
The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2).,The server has requested client authentication via a CertificateRequest message (Section 4.3.2).,The client MUST send a Certificate message.,MUST,"The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2). If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message containing no certificates (i.e., with the ""certificate_list"" field having length 0). A Finished message MUST be sent regardless of whether the Certificate message is empty.",The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK).,Structure of this message:,4.4.2,Certificate,3,3,1,MUST
"If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message containing no certificates (i.e., with the ""certificate_list"" field having length 0).","The server requests client authentication,No suitable certificate is available",The client MUST send a Certificate message containing no certificates (with the 'certificate_list' field having length 0),MUST,"The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2). If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message containing no certificates (i.e., with the ""certificate_list"" field having length 0). A Finished message MUST be sent regardless of whether the Certificate message is empty.",The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK).,Structure of this message:,4.4.2,Certificate,3,3,2,MUST
A Finished message MUST be sent regardless of whether the Certificate message is empty.,The sequence proceeds to the Finished message phase regardless of whether the Certificate message is empty or non-empty.,A Finished message MUST be sent.,MUST,"The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2). If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message containing no certificates (i.e., with the ""certificate_list"" field having length 0). A Finished message MUST be sent regardless of whether the Certificate message is empty.",The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK).,Structure of this message:,4.4.2,Certificate,3,3,3,MUST
Extensions in the Certificate message from the server MUST correspond to ones from the ClientHello message.,When a Certificate message from the server is constructed or processed that includes extension values.,Ensure that the extensions in the Certificate message from the server correspond exactly to the extensions present in the ClientHello message.,MUST,"extensions: A set of extension values for the CertificateEntry. The ""Extension"" format is defined in Section 4.2. Valid extensions for server certificates at present include the OCSP Status extension [RFC6066] and the SignedCertificateTimestamp extension [RFC6962]; future extensions may be defined for this message as well. Extensions in the Certificate message from the server MUST correspond to ones from the ClientHello message. Extensions in the Certificate message from the client MUST correspond to extensions in the CertificateRequest message from the server. If an extension applies to the entire chain, it SHOULD be included in the first CertificateEntry.","certificate_list: A sequence (chain) of CertificateEntry structures, each containing a single certificate and set of extensions.","If the corresponding certificate type extension (""server_certificate_type"" or ""client_certificate_type"") was not negotiated in EncryptedExtensions, or the X.509 certificate type was negotiated, then each CertificateEntry contains a DER-encoded X.509 certificate. The sender's certificate MUST come in the first CertificateEntry in the list. Each following certificate SHOULD directly certify the one immediately preceding it. Because certificate validation requires that trust anchors be distributed independently, a certificate that specifies a trust anchor MAY be omitted from the chain, provided that supported peers are known to possess any omitted certificates.",4.4.2,Certificate,3,7,4,MUST
Extensions in the Certificate message from the client MUST correspond to extensions in the CertificateRequest message from the server.,"When processing the Certificate message sent from the client, specifically in cases where it contains extensions.",The extensions in the Certificate message from the client MUST correspond to the extensions specified in the CertificateRequest message from the server.,MUST,"extensions: A set of extension values for the CertificateEntry. The ""Extension"" format is defined in Section 4.2. Valid extensions for server certificates at present include the OCSP Status extension [RFC6066] and the SignedCertificateTimestamp extension [RFC6962]; future extensions may be defined for this message as well. Extensions in the Certificate message from the server MUST correspond to ones from the ClientHello message. Extensions in the Certificate message from the client MUST correspond to extensions in the CertificateRequest message from the server. If an extension applies to the entire chain, it SHOULD be included in the first CertificateEntry.","certificate_list: A sequence (chain) of CertificateEntry structures, each containing a single certificate and set of extensions.","If the corresponding certificate type extension (""server_certificate_type"" or ""client_certificate_type"") was not negotiated in EncryptedExtensions, or the X.509 certificate type was negotiated, then each CertificateEntry contains a DER-encoded X.509 certificate. The sender's certificate MUST come in the first CertificateEntry in the list. Each following certificate SHOULD directly certify the one immediately preceding it. Because certificate validation requires that trust anchors be distributed independently, a certificate that specifies a trust anchor MAY be omitted from the chain, provided that supported peers are known to possess any omitted certificates.",4.4.2,Certificate,3,7,5,MUST
"If an extension applies to the entire chain, it SHOULD be included in the first CertificateEntry.",When an extension applies to the entire certificate chain,The extension SHOULD be included in the first CertificateEntry,SHOULD,"extensions: A set of extension values for the CertificateEntry. The ""Extension"" format is defined in Section 4.2. Valid extensions for server certificates at present include the OCSP Status extension [RFC6066] and the SignedCertificateTimestamp extension [RFC6962]; future extensions may be defined for this message as well. Extensions in the Certificate message from the server MUST correspond to ones from the ClientHello message. Extensions in the Certificate message from the client MUST correspond to extensions in the CertificateRequest message from the server. If an extension applies to the entire chain, it SHOULD be included in the first CertificateEntry.","certificate_list: A sequence (chain) of CertificateEntry structures, each containing a single certificate and set of extensions.","If the corresponding certificate type extension (""server_certificate_type"" or ""client_certificate_type"") was not negotiated in EncryptedExtensions, or the X.509 certificate type was negotiated, then each CertificateEntry contains a DER-encoded X.509 certificate. The sender's certificate MUST come in the first CertificateEntry in the list. Each following certificate SHOULD directly certify the one immediately preceding it. Because certificate validation requires that trust anchors be distributed independently, a certificate that specifies a trust anchor MAY be omitted from the chain, provided that supported peers are known to possess any omitted certificates.",4.4.2,Certificate,3,7,6,SHOULD
The sender's certificate MUST come in the first CertificateEntry in the list.,When constructing the certificate list for transmission during the TLS handshake.,The sender's certificate MUST be placed in the first CertificateEntry in the list.,MUST,"If the corresponding certificate type extension (""server_certificate_type"" or ""client_certificate_type"") was not negotiated in EncryptedExtensions, or the X.509 certificate type was negotiated, then each CertificateEntry contains a DER-encoded X.509 certificate. The sender's certificate MUST come in the first CertificateEntry in the list. Each following certificate SHOULD directly certify the one immediately preceding it. Because certificate validation requires that trust anchors be distributed independently, a certificate that specifies a trust anchor MAY be omitted from the chain, provided that supported peers are known to possess any omitted certificates.","extensions: A set of extension values for the CertificateEntry. The ""Extension"" format is defined in Section 4.2. Valid extensions for server certificates at present include the OCSP Status extension [RFC6066] and the SignedCertificateTimestamp extension [RFC6962]; future extensions may be defined for this message as well. Extensions in the Certificate message from the server MUST correspond to ones from the ClientHello message. Extensions in the Certificate message from the client MUST correspond to extensions in the CertificateRequest message from the server. If an extension applies to the entire chain, it SHOULD be included in the first CertificateEntry.","Note: Prior to TLS 1.3, ""certificate_list"" ordering required each certificate to certify the one immediately preceding it; however, some implementations allowed some flexibility. Servers sometimes send both a current and deprecated intermediate for transitional purposes, and others are simply configured incorrectly, but these cases can nonetheless be validated properly. For maximum compatibility, all implementations SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, with the exception of the end-entity certificate which MUST be first.",4.4.2,Certificate,3,8,2,MUST
Each following certificate SHOULD directly certify the one immediately preceding it.,For each certificate in the chain following the first entry.,Each following certificate SHOULD directly certify the one immediately preceding it.,SHOULD,"If the corresponding certificate type extension (""server_certificate_type"" or ""client_certificate_type"") was not negotiated in EncryptedExtensions, or the X.509 certificate type was negotiated, then each CertificateEntry contains a DER-encoded X.509 certificate. The sender's certificate MUST come in the first CertificateEntry in the list. Each following certificate SHOULD directly certify the one immediately preceding it. Because certificate validation requires that trust anchors be distributed independently, a certificate that specifies a trust anchor MAY be omitted from the chain, provided that supported peers are known to possess any omitted certificates.","extensions: A set of extension values for the CertificateEntry. The ""Extension"" format is defined in Section 4.2. Valid extensions for server certificates at present include the OCSP Status extension [RFC6066] and the SignedCertificateTimestamp extension [RFC6962]; future extensions may be defined for this message as well. Extensions in the Certificate message from the server MUST correspond to ones from the ClientHello message. Extensions in the Certificate message from the client MUST correspond to extensions in the CertificateRequest message from the server. If an extension applies to the entire chain, it SHOULD be included in the first CertificateEntry.","Note: Prior to TLS 1.3, ""certificate_list"" ordering required each certificate to certify the one immediately preceding it; however, some implementations allowed some flexibility. Servers sometimes send both a current and deprecated intermediate for transitional purposes, and others are simply configured incorrectly, but these cases can nonetheless be validated properly. For maximum compatibility, all implementations SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, with the exception of the end-entity certificate which MUST be first.",4.4.2,Certificate,3,8,3,SHOULD
"Because certificate validation requires that trust anchors be distributed independently, a certificate that specifies a trust anchor MAY be omitted from the chain, provided that supported peers are known to possess any omitted certificates.","A certificate in the chain specifies a trust anchor,Supported peers are known to possess the omitted certificate(s)",The certificate that specifies a trust anchor MAY be omitted from the chain,MAY,"If the corresponding certificate type extension (""server_certificate_type"" or ""client_certificate_type"") was not negotiated in EncryptedExtensions, or the X.509 certificate type was negotiated, then each CertificateEntry contains a DER-encoded X.509 certificate. The sender's certificate MUST come in the first CertificateEntry in the list. Each following certificate SHOULD directly certify the one immediately preceding it. Because certificate validation requires that trust anchors be distributed independently, a certificate that specifies a trust anchor MAY be omitted from the chain, provided that supported peers are known to possess any omitted certificates.","extensions: A set of extension values for the CertificateEntry. The ""Extension"" format is defined in Section 4.2. Valid extensions for server certificates at present include the OCSP Status extension [RFC6066] and the SignedCertificateTimestamp extension [RFC6962]; future extensions may be defined for this message as well. Extensions in the Certificate message from the server MUST correspond to ones from the ClientHello message. Extensions in the Certificate message from the client MUST correspond to extensions in the CertificateRequest message from the server. If an extension applies to the entire chain, it SHOULD be included in the first CertificateEntry.","Note: Prior to TLS 1.3, ""certificate_list"" ordering required each certificate to certify the one immediately preceding it; however, some implementations allowed some flexibility. Servers sometimes send both a current and deprecated intermediate for transitional purposes, and others are simply configured incorrectly, but these cases can nonetheless be validated properly. For maximum compatibility, all implementations SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, with the exception of the end-entity certificate which MUST be first.",4.4.2,Certificate,3,8,4,MAY
"For maximum compatibility, all implementations SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, with the exception of the end-entity certificate which MUST be first.",When processing certificate lists from any TLS version that may include extraneous certificates or have certificates in an arbitrary order.,"Implementations SHOULD be prepared to handle extraneous certificates and arbitrary orderings, and MUST ensure that the end-entity certificate is the first entry in the certificate list.","MUST, SHOULD","Note: Prior to TLS 1.3, ""certificate_list"" ordering required each certificate to certify the one immediately preceding it; however, some implementations allowed some flexibility. Servers sometimes send both a current and deprecated intermediate for transitional purposes, and others are simply configured incorrectly, but these cases can nonetheless be validated properly. For maximum compatibility, all implementations SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, with the exception of the end-entity certificate which MUST be first.","If the corresponding certificate type extension (""server_certificate_type"" or ""client_certificate_type"") was not negotiated in EncryptedExtensions, or the X.509 certificate type was negotiated, then each CertificateEntry contains a DER-encoded X.509 certificate. The sender's certificate MUST come in the first CertificateEntry in the list. Each following certificate SHOULD directly certify the one immediately preceding it. Because certificate validation requires that trust anchors be distributed independently, a certificate that specifies a trust anchor MAY be omitted from the chain, provided that supported peers are known to possess any omitted certificates.","If the RawPublicKey certificate type was negotiated, then the certificate_list MUST contain no more than one CertificateEntry, which contains an ASN1_subjectPublicKeyInfo value as defined in [RFC7250], Section 3.",4.4.2,Certificate,3,9,3,MUST
"If the RawPublicKey certificate type was negotiated, then the certificate_list MUST contain no more than one CertificateEntry, which contains an ASN1_subjectPublicKeyInfo value as defined in [RFC7250], Section 3.",RawPublicKey certificate type was negotiated,"The certificate_list MUST contain no more than one CertificateEntry, which contains an ASN1_subjectPublicKeyInfo value as defined in [RFC7250], Section 3",MUST,"If the RawPublicKey certificate type was negotiated, then the certificate_list MUST contain no more than one CertificateEntry, which contains an ASN1_subjectPublicKeyInfo value as defined in [RFC7250], Section 3.","Note: Prior to TLS 1.3, ""certificate_list"" ordering required each certificate to certify the one immediately preceding it; however, some implementations allowed some flexibility. Servers sometimes send both a current and deprecated intermediate for transitional purposes, and others are simply configured incorrectly, but these cases can nonetheless be validated properly. For maximum compatibility, all implementations SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, with the exception of the end-entity certificate which MUST be first.",The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,4.4.2,Certificate,3,10,1,MUST
The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,When TLS 1.3 is in use,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3,MUST NOT,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,"If the RawPublicKey certificate type was negotiated, then the certificate_list MUST contain no more than one CertificateEntry, which contains an ASN1_subjectPublicKeyInfo value as defined in [RFC7250], Section 3.",The server's certificate_list MUST always be non-empty. A client will send an empty certificate_list if it does not have an appropriate certificate to send in response to the server's authentication request.,4.4.2,Certificate,3,11,1,MUST
The server's certificate_list MUST always be non-empty.,,The server's certificate_list MUST always be non-empty.,MUST,The server's certificate_list MUST always be non-empty. A client will send an empty certificate_list if it does not have an appropriate certificate to send in response to the server's authentication request.,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,"[RFC6066] and [RFC6961] provide extensions to negotiate the server sending OCSP responses to the client. In TLS 1.2 and below, the server replies with an empty extension to indicate negotiation of this extension and the OCSP information is carried in a CertificateStatus message. In TLS 1.3, the server's OCSP information is carried in an extension in the CertificateEntry containing the associated certificate. Specifically, the body of the ""status_request"" extension from the server MUST be a CertificateStatus structure as defined in [RFC6066], which is interpreted as defined in [RFC6960].",4.4.2,Certificate,3,12,1,MUST
"Specifically, the body of the ""status_request"" extension from the server MUST be a CertificateStatus structure as defined in [RFC6066], which is interpreted as defined in [RFC6960].",When the server sends the 'status_request' extension,The body of the 'status_request' extension MUST be a CertificateStatus structure as defined in [RFC6066] and interpreted as defined in [RFC6960],MUST,"[RFC6066] and [RFC6961] provide extensions to negotiate the server sending OCSP responses to the client. In TLS 1.2 and below, the server replies with an empty extension to indicate negotiation of this extension and the OCSP information is carried in a CertificateStatus message. In TLS 1.3, the server's OCSP information is carried in an extension in the CertificateEntry containing the associated certificate. Specifically, the body of the ""status_request"" extension from the server MUST be a CertificateStatus structure as defined in [RFC6066], which is interpreted as defined in [RFC6960].",The server's certificate_list MUST always be non-empty. A client will send an empty certificate_list if it does not have an appropriate certificate to send in response to the server's authentication request.,"Note: The status_request_v2 extension [RFC6961] is deprecated. TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. TLS 1.3 servers MUST be able to process ClientHello messages that include it, as it MAY be sent by clients that wish to use it in earlier protocol versions.",4.4.2,Certificate,3,13,4,MUST
"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",When processing ClientHello messages that include the status_request_v2 extension,"TLS 1.3 servers MUST NOT act upon the presence or information of the status_request_v2 extension and MUST NOT include it in the EncryptedExtensions, CertificateRequest, or Certificate messages",MUST NOT,"Note: The status_request_v2 extension [RFC6961] is deprecated. TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. TLS 1.3 servers MUST be able to process ClientHello messages that include it, as it MAY be sent by clients that wish to use it in earlier protocol versions.","[RFC6066] and [RFC6961] provide extensions to negotiate the server sending OCSP responses to the client. In TLS 1.2 and below, the server replies with an empty extension to indicate negotiation of this extension and the OCSP information is carried in a CertificateStatus message. In TLS 1.3, the server's OCSP information is carried in an extension in the CertificateEntry containing the associated certificate. Specifically, the body of the ""status_request"" extension from the server MUST be a CertificateStatus structure as defined in [RFC6066], which is interpreted as defined in [RFC6960].","A server MAY request that a client present an OCSP response with its certificate by sending an empty ""status_request"" extension in its CertificateRequest message. If the client opts to send an OCSP response, the body of its ""status_request"" extension MUST be a CertificateStatus structure as defined in [RFC6066].",4.4.2,Certificate,3,14,2,MUST
"TLS 1.3 servers MUST be able to process ClientHello messages that include it, as it MAY be sent by clients that wish to use it in earlier protocol versions.","A ClientHello message that includes the status_request_v2 extension, which clients may send when using earlier protocol versions.",TLS 1.3 servers MUST be able to process the ClientHello messages that include the status_request_v2 extension.,"MUST, MAY","Note: The status_request_v2 extension [RFC6961] is deprecated. TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. TLS 1.3 servers MUST be able to process ClientHello messages that include it, as it MAY be sent by clients that wish to use it in earlier protocol versions.","[RFC6066] and [RFC6961] provide extensions to negotiate the server sending OCSP responses to the client. In TLS 1.2 and below, the server replies with an empty extension to indicate negotiation of this extension and the OCSP information is carried in a CertificateStatus message. In TLS 1.3, the server's OCSP information is carried in an extension in the CertificateEntry containing the associated certificate. Specifically, the body of the ""status_request"" extension from the server MUST be a CertificateStatus structure as defined in [RFC6066], which is interpreted as defined in [RFC6960].","A server MAY request that a client present an OCSP response with its certificate by sending an empty ""status_request"" extension in its CertificateRequest message. If the client opts to send an OCSP response, the body of its ""status_request"" extension MUST be a CertificateStatus structure as defined in [RFC6066].",4.4.2,Certificate,3,14,3,MUST
"A server MAY request that a client present an OCSP response with its certificate by sending an empty ""status_request"" extension in its CertificateRequest message.",When the server decides to request that a client provide an OCSP response with its certificate,"The server sends an empty ""status_request"" extension in its CertificateRequest message",MAY,"A server MAY request that a client present an OCSP response with its certificate by sending an empty ""status_request"" extension in its CertificateRequest message. If the client opts to send an OCSP response, the body of its ""status_request"" extension MUST be a CertificateStatus structure as defined in [RFC6066].","Note: The status_request_v2 extension [RFC6961] is deprecated. TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. TLS 1.3 servers MUST be able to process ClientHello messages that include it, as it MAY be sent by clients that wish to use it in earlier protocol versions.","Similarly, [RFC6962] provides a mechanism for a server to send a Signed Certificate Timestamp (SCT) as an extension in the ServerHello in TLS 1.2 and below. In TLS 1.3, the server's SCT information is carried in an extension in the CertificateEntry.",4.4.2,Certificate,3,15,1,MAY
"If the client opts to send an OCSP response, the body of its ""status_request"" extension MUST be a CertificateStatus structure as defined in [RFC6066].",The client opts to send an OCSP response.,"The body of the client's ""status_request"" extension MUST be a CertificateStatus structure as defined in [RFC6066].",MUST,"A server MAY request that a client present an OCSP response with its certificate by sending an empty ""status_request"" extension in its CertificateRequest message. If the client opts to send an OCSP response, the body of its ""status_request"" extension MUST be a CertificateStatus structure as defined in [RFC6066].","Note: The status_request_v2 extension [RFC6961] is deprecated. TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. TLS 1.3 servers MUST be able to process ClientHello messages that include it, as it MAY be sent by clients that wish to use it in earlier protocol versions.","Similarly, [RFC6962] provides a mechanism for a server to send a Signed Certificate Timestamp (SCT) as an extension in the ServerHello in TLS 1.2 and below. In TLS 1.3, the server's SCT information is carried in an extension in the CertificateEntry.",4.4.2,Certificate,3,15,2,MUST
"-The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).","No explicit negotiation for an alternative certificate type is performed (i.e., the default negotiation applies)",The certificate type MUST be X.509v3 as specified in RFC5280,MUST,"-The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).",The following rules apply to the certificates sent by the server:,"-The server's end-entity certificate's public key (and associated restrictions) MUST be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension (currently RSA, ECDSA, or EdDSA).",4.4.2,Certificate,3,18,1,MUST
"-The server's end-entity certificate's public key (and associated restrictions) MUST be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension (currently RSA, ECDSA, or EdDSA).","When the client provides a 'signature_algorithms' extension that selects an authentication algorithm (currently RSA, ECDSA, or EdDSA)",The server's end-entity certificate's public key and its associated restrictions MUST be compatible with the selected authentication algorithm from the client's 'signature_algorithms' extension,MUST,"-The server's end-entity certificate's public key (and associated restrictions) MUST be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension (currently RSA, ECDSA, or EdDSA).","-The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).","-The certificate MUST allow the key to be used for signing (i.e., the digitalSignature bit MUST be set if the Key Usage extension is present) with a signature scheme indicated in the client's ""signature_algorithms""/""signature_algorithms_cert"" extensions (see Section 4.2.3).",4.4.2,Certificate,3,19,1,MUST
"-The certificate MUST allow the key to be used for signing (i.e., the digitalSignature bit MUST be set if the Key Usage extension is present) with a signature scheme indicated in the client's ""signature_algorithms""/""signature_algorithms_cert"" extensions (see Section 4.2.3).","If the certificate includes a Key Usage extension (which, if present, requires checking the digitalSignature bit),If the client's 'signature_algorithms' or 'signature_algorithms_cert' extensions indicate a specific signature scheme",The certificate MUST allow the key to be used for signing by ensuring the digitalSignature bit is set (when the Key Usage extension is present) and by supporting a signature scheme indicated in the client's 'signature_algorithms'/'signature_algorithms_cert' extensions,MUST,"-The certificate MUST allow the key to be used for signing (i.e., the digitalSignature bit MUST be set if the Key Usage extension is present) with a signature scheme indicated in the client's ""signature_algorithms""/""signature_algorithms_cert"" extensions (see Section 4.2.3).","-The server's end-entity certificate's public key (and associated restrictions) MUST be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension (currently RSA, ECDSA, or EdDSA).","-The ""server_name"" [RFC6066] and ""certificate_authorities"" extensions are used to guide certificate selection. As servers MAY require the presence of the ""server_name"" extension, clients SHOULD send this extension, when applicable.",4.4.2,Certificate,3,20,1,MUST
"As servers MAY require the presence of the ""server_name"" extension, clients SHOULD send this extension, when applicable.","When applicable, meaning when the server may require the presence of the 'server_name' extension.",Clients SHOULD send the 'server_name' extension.,"SHOULD, MAY","-The ""server_name"" [RFC6066] and ""certificate_authorities"" extensions are used to guide certificate selection. As servers MAY require the presence of the ""server_name"" extension, clients SHOULD send this extension, when applicable.","-The certificate MUST allow the key to be used for signing (i.e., the digitalSignature bit MUST be set if the Key Usage extension is present) with a signature scheme indicated in the client's ""signature_algorithms""/""signature_algorithms_cert"" extensions (see Section 4.2.3).",All certificates provided by the server MUST be signed by a signature algorithm advertised by the client if it is able to provide such a chain (see Section 4.2.3). Certificates that are self-signed or certificates that are expected to be trust anchors are not validated as part of the chain and therefore MAY be signed with any algorithm.,4.4.2,Certificate,3,21,2,SHOULD
All certificates provided by the server MUST be signed by a signature algorithm advertised by the client if it is able to provide such a chain (see Section 4.2.3).,The server is able to provide a certificate chain using a signature algorithm that is among those advertised by the client.,"All certificates provided by the server MUST be signed by a signature algorithm advertised by the client, except that self-signed certificates or certificates expected to be trust anchors MAY be signed with any algorithm.",MUST,All certificates provided by the server MUST be signed by a signature algorithm advertised by the client if it is able to provide such a chain (see Section 4.2.3). Certificates that are self-signed or certificates that are expected to be trust anchors are not validated as part of the chain and therefore MAY be signed with any algorithm.,"-The ""server_name"" [RFC6066] and ""certificate_authorities"" extensions are used to guide certificate selection. As servers MAY require the presence of the ""server_name"" extension, clients SHOULD send this extension, when applicable.","If the server cannot produce a certificate chain that is signed only via the indicated supported algorithms, then it SHOULD continue the handshake by sending the client a certificate chain of its choice that may include algorithms that are not known to be supported by the client. This fallback chain SHOULD NOT use the deprecated SHA-1 hash algorithm in general, but MAY do so if the client's advertisement permits it, and MUST NOT do so otherwise.",4.4.2,Certificate,3,22,1,MUST
Certificates that are self-signed or certificates that are expected to be trust anchors are not validated as part of the chain and therefore MAY be signed with any algorithm.,The certificate is self-signed or is expected to be a trust anchor,The certificate MAY be signed with any algorithm,MAY,All certificates provided by the server MUST be signed by a signature algorithm advertised by the client if it is able to provide such a chain (see Section 4.2.3). Certificates that are self-signed or certificates that are expected to be trust anchors are not validated as part of the chain and therefore MAY be signed with any algorithm.,"-The ""server_name"" [RFC6066] and ""certificate_authorities"" extensions are used to guide certificate selection. As servers MAY require the presence of the ""server_name"" extension, clients SHOULD send this extension, when applicable.","If the server cannot produce a certificate chain that is signed only via the indicated supported algorithms, then it SHOULD continue the handshake by sending the client a certificate chain of its choice that may include algorithms that are not known to be supported by the client. This fallback chain SHOULD NOT use the deprecated SHA-1 hash algorithm in general, but MAY do so if the client's advertisement permits it, and MUST NOT do so otherwise.",4.4.2,Certificate,3,22,2,MAY
"If the server cannot produce a certificate chain that is signed only via the indicated supported algorithms, then it SHOULD continue the handshake by sending the client a certificate chain of its choice that may include algorithms that are not known to be supported by the client.",The server cannot produce a certificate chain that is signed only via the indicated supported algorithms.,"The server SHOULD continue the handshake by sending the client a certificate chain of its choice that may include algorithms not known to be supported by the client.,The fallback chain SHOULD NOT use the deprecated SHA-1 hash algorithm in general, but MAY do so if the client's advertisement permits it, and MUST NOT do so otherwise.",SHOULD,"If the server cannot produce a certificate chain that is signed only via the indicated supported algorithms, then it SHOULD continue the handshake by sending the client a certificate chain of its choice that may include algorithms that are not known to be supported by the client. This fallback chain SHOULD NOT use the deprecated SHA-1 hash algorithm in general, but MAY do so if the client's advertisement permits it, and MUST NOT do so otherwise.",All certificates provided by the server MUST be signed by a signature algorithm advertised by the client if it is able to provide such a chain (see Section 4.2.3). Certificates that are self-signed or certificates that are expected to be trust anchors are not validated as part of the chain and therefore MAY be signed with any algorithm.,"If the client cannot construct an acceptable chain using the provided certificates and decides to abort the handshake, then it MUST abort the handshake with an appropriate certificate-related alert (by default, ""unsupported_certificate""; see Section 6.2 for more information).",4.4.2,Certificate,3,23,1,SHOULD
"This fallback chain SHOULD NOT use the deprecated SHA-1 hash algorithm in general, but MAY do so if the client's advertisement permits it, and MUST NOT do so otherwise.","When constructing a fallback certificate chain because the server cannot produce a chain signed solely via the indicated supported algorithms,When the client’s advertisement either permits or does not permit the use of the SHA-1 hash algorithm","The fallback chain SHOULD NOT use the deprecated SHA-1 hash algorithm in general; it MAY use SHA-1 if the client’s advertisement permits its use, and it MUST NOT use SHA-1 if the advertisement does not permit it","MUST NOT, SHOULD NOT, MAY","If the server cannot produce a certificate chain that is signed only via the indicated supported algorithms, then it SHOULD continue the handshake by sending the client a certificate chain of its choice that may include algorithms that are not known to be supported by the client. This fallback chain SHOULD NOT use the deprecated SHA-1 hash algorithm in general, but MAY do so if the client's advertisement permits it, and MUST NOT do so otherwise.",All certificates provided by the server MUST be signed by a signature algorithm advertised by the client if it is able to provide such a chain (see Section 4.2.3). Certificates that are self-signed or certificates that are expected to be trust anchors are not validated as part of the chain and therefore MAY be signed with any algorithm.,"If the client cannot construct an acceptable chain using the provided certificates and decides to abort the handshake, then it MUST abort the handshake with an appropriate certificate-related alert (by default, ""unsupported_certificate""; see Section 6.2 for more information).",4.4.2,Certificate,3,23,2,MUST
"If the client cannot construct an acceptable chain using the provided certificates and decides to abort the handshake, then it MUST abort the handshake with an appropriate certificate-related alert (by default, ""unsupported_certificate""; see Section 6.2 for more information).",The client cannot construct an acceptable certificate chain using the provided certificates and decides to abort the handshake.,"The client MUST abort the handshake with an appropriate certificate-related alert (by default, 'unsupported_certificate').",MUST,"If the client cannot construct an acceptable chain using the provided certificates and decides to abort the handshake, then it MUST abort the handshake with an appropriate certificate-related alert (by default, ""unsupported_certificate""; see Section 6.2 for more information).","If the server cannot produce a certificate chain that is signed only via the indicated supported algorithms, then it SHOULD continue the handshake by sending the client a certificate chain of its choice that may include algorithms that are not known to be supported by the client. This fallback chain SHOULD NOT use the deprecated SHA-1 hash algorithm in general, but MAY do so if the client's advertisement permits it, and MUST NOT do so otherwise.","If the server has multiple certificates, it chooses one of them based on the above-mentioned criteria (in addition to other criteria, such as transport-layer endpoint, local configuration, and preferences).",4.4.2,Certificate,3,24,1,MUST
"-The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).","Applies when no alternative certificate type has been explicitly negotiated (i.e., in the default scenario)",The certificate type MUST be X.509v3 [RFC5280],MUST,"-The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).",The following rules apply to certificates sent by the client:,"-If the ""certificate_authorities"" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.",4.4.2,Certificate,3,27,1,MUST
"-If the ""certificate_authorities"" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.",The 'certificate_authorities' extension in the CertificateRequest message is present.,At least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.,SHOULD,"-If the ""certificate_authorities"" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.","-The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).","-The certificates MUST be signed using an acceptable signature algorithm, as described in Section 4.3.2. Note that this relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.",4.4.2,Certificate,3,28,1,SHOULD
"-The certificates MUST be signed using an acceptable signature algorithm, as described in Section 4.3.2.",,"The certificates MUST be signed using an acceptable signature algorithm, as described in Section 4.3.2.",MUST,"-The certificates MUST be signed using an acceptable signature algorithm, as described in Section 4.3.2. Note that this relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.","-If the ""certificate_authorities"" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.","-If the CertificateRequest message contained a non-empty ""oid_filters"" extension, the end-entity certificate MUST match the extension OIDs that are recognized by the client, as described in Section 4.2.5.",4.4.2,Certificate,3,29,1,MUST
"-If the CertificateRequest message contained a non-empty ""oid_filters"" extension, the end-entity certificate MUST match the extension OIDs that are recognized by the client, as described in Section 4.2.5.","The CertificateRequest message contains a non-empty ""oid_filters"" extension","The end-entity certificate MUST match the extension OIDs that are recognized by the client, as described in Section 4.2.5",MUST,"-If the CertificateRequest message contained a non-empty ""oid_filters"" extension, the end-entity certificate MUST match the extension OIDs that are recognized by the client, as described in Section 4.2.5.","-The certificates MUST be signed using an acceptable signature algorithm, as described in Section 4.3.2. Note that this relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.","In general, detailed certificate validation procedures are out of scope for TLS (see [RFC5280]). This section provides TLS-specific requirements.",4.4.2,Certificate,3,30,1,MUST
"If the server supplies an empty Certificate message, the client MUST abort the handshake with a ""decode_error"" alert.",The server supplies an empty Certificate message.,The client MUST abort the handshake with a 'decode_error' alert.,MUST,"If the server supplies an empty Certificate message, the client MUST abort the handshake with a ""decode_error"" alert.","In general, detailed certificate validation procedures are out of scope for TLS (see [RFC5280]). This section provides TLS-specific requirements.","If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either continue the handshake without client authentication or abort the handshake with a ""certificate_required"" alert. Also, if some aspect of the certificate chain was unacceptable (e.g., it was not signed by a known, trusted CA), the server MAY at its discretion either continue the handshake (considering the client unauthenticated) or abort the handshake.",4.4.2,Certificate,3,32,1,MUST
"If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either continue the handshake without client authentication or abort the handshake with a ""certificate_required"" alert.","The client does not send any certificates (i.e., it sends an empty Certificate message)",The server MAY either continue the handshake without client authentication or abort the handshake with a 'certificate_required' alert,MAY,"If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either continue the handshake without client authentication or abort the handshake with a ""certificate_required"" alert. Also, if some aspect of the certificate chain was unacceptable (e.g., it was not signed by a known, trusted CA), the server MAY at its discretion either continue the handshake (considering the client unauthenticated) or abort the handshake.","If the server supplies an empty Certificate message, the client MUST abort the handshake with a ""decode_error"" alert.","Any endpoint receiving any certificate which it would need to validate using any signature algorithm using an MD5 hash MUST abort the handshake with a ""bad_certificate"" alert. SHA-1 is deprecated, and it is RECOMMENDED that any endpoint receiving any certificate which it would need to validate using any signature algorithm using a SHA-1 hash abort the handshake with a ""bad_certificate"" alert. For clarity, this means that endpoints can accept these algorithms for certificates that are self-signed or are trust anchors.",4.4.2,Certificate,3,33,1,MAY
"Also, if some aspect of the certificate chain was unacceptable (e.g., it was not signed by a known, trusted CA), the server MAY at its discretion either continue the handshake (considering the client unauthenticated) or abort the handshake.","Some aspect of the certificate chain is unacceptable, for example, it is not signed by a known, trusted CA",The server MAY at its discretion either continue the handshake (considering the client unauthenticated) or abort the handshake,MAY,"If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either continue the handshake without client authentication or abort the handshake with a ""certificate_required"" alert. Also, if some aspect of the certificate chain was unacceptable (e.g., it was not signed by a known, trusted CA), the server MAY at its discretion either continue the handshake (considering the client unauthenticated) or abort the handshake.","If the server supplies an empty Certificate message, the client MUST abort the handshake with a ""decode_error"" alert.","Any endpoint receiving any certificate which it would need to validate using any signature algorithm using an MD5 hash MUST abort the handshake with a ""bad_certificate"" alert. SHA-1 is deprecated, and it is RECOMMENDED that any endpoint receiving any certificate which it would need to validate using any signature algorithm using a SHA-1 hash abort the handshake with a ""bad_certificate"" alert. For clarity, this means that endpoints can accept these algorithms for certificates that are self-signed or are trust anchors.",4.4.2,Certificate,3,33,2,MAY
"Any endpoint receiving any certificate which it would need to validate using any signature algorithm using an MD5 hash MUST abort the handshake with a ""bad_certificate"" alert.",An endpoint receives any certificate that requires validation using any signature algorithm that employs an MD5 hash.,The endpoint MUST abort the handshake and send a 'bad_certificate' alert.,MUST,"Any endpoint receiving any certificate which it would need to validate using any signature algorithm using an MD5 hash MUST abort the handshake with a ""bad_certificate"" alert. SHA-1 is deprecated, and it is RECOMMENDED that any endpoint receiving any certificate which it would need to validate using any signature algorithm using a SHA-1 hash abort the handshake with a ""bad_certificate"" alert. For clarity, this means that endpoints can accept these algorithms for certificates that are self-signed or are trust anchors.","If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either continue the handshake without client authentication or abort the handshake with a ""certificate_required"" alert. Also, if some aspect of the certificate chain was unacceptable (e.g., it was not signed by a known, trusted CA), the server MAY at its discretion either continue the handshake (considering the client unauthenticated) or abort the handshake.",All endpoints are RECOMMENDED to transition to SHA-256 or better as soon as possible to maintain interoperability with implementations currently in the process of phasing out SHA-1 support.,4.4.2,Certificate,3,34,1,MUST
"Note that a certificate containing a key for one signature algorithm MAY be signed using a different signature algorithm (for instance, an RSA key signed with an ECDSA key).",A certificate contains a key for one signature algorithm.,"The certificate MAY be signed using a different signature algorithm (e.g., an RSA key may be signed with an ECDSA key).",MAY,"Note that a certificate containing a key for one signature algorithm MAY be signed using a different signature algorithm (for instance, an RSA key signed with an ECDSA key).",All endpoints are RECOMMENDED to transition to SHA-256 or better as soon as possible to maintain interoperability with implementations currently in the process of phasing out SHA-1 support.,,4.4.2,Certificate,3,36,1,MAY
Servers MUST send this message when authenticating via a certificate.,When the server is authenticating via a certificate.,The server MUST send this message.,MUST,"This message is used to provide explicit proof that an endpoint possesses the private key corresponding to its certificate. The CertificateVerify message also provides integrity for the handshake up to this point. Servers MUST send this message when authenticating via a certificate. Clients MUST send this message whenever authenticating via a certificate (i.e., when the Certificate message is non-empty). When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message.",,Structure of this message:,4.4.3,Certificate Verify,3,1,3,MUST
"Clients MUST send this message whenever authenticating via a certificate (i.e., when the Certificate message is non-empty).","Clients are authenticating via a certificate (i.e., the Certificate message is non-empty)",Clients MUST send this message,MUST,"This message is used to provide explicit proof that an endpoint possesses the private key corresponding to its certificate. The CertificateVerify message also provides integrity for the handshake up to this point. Servers MUST send this message when authenticating via a certificate. Clients MUST send this message whenever authenticating via a certificate (i.e., when the Certificate message is non-empty). When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message.",,Structure of this message:,4.4.3,Certificate Verify,3,1,4,MUST
"When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message.","The message is being sent (i.e., in the context of certificate-based authentication when the Certificate message is non-empty)",The message MUST appear immediately after the Certificate message and immediately prior to the Finished message,MUST,"This message is used to provide explicit proof that an endpoint possesses the private key corresponding to its certificate. The CertificateVerify message also provides integrity for the handshake up to this point. Servers MUST send this message when authenticating via a certificate. Clients MUST send this message whenever authenticating via a certificate (i.e., when the Certificate message is non-empty). When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message.",,Structure of this message:,4.4.3,Certificate Verify,3,1,5,MUST
"If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client's ""signature_algorithms"" extension unless no valid certificate chain can be produced without unsupported algorithms (see Section 4.2.3).","The CertificateVerify message is sent by a server,A valid certificate chain can be produced without resorting to unsupported algorithms",The signature algorithm used in the CertificateVerify message MUST be one offered in the client's 'signature_algorithms' extension,MUST,"If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client's ""signature_algorithms"" extension unless no valid certificate chain can be produced without unsupported algorithms (see Section 4.2.3).",-The private signing key corresponding to the certificate sent in the previous message,"If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the ""signature_algorithms"" extension in the CertificateRequest message.",4.4.3,Certificate Verify,3,15,1,MUST
"If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the ""signature_algorithms"" extension in the CertificateRequest message.",The condition applies if the CertificateVerify message is sent by a client.,The signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the 'signature_algorithms' extension in the CertificateRequest message.,MUST,"If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the ""signature_algorithms"" extension in the CertificateRequest message.","If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client's ""signature_algorithms"" extension unless no valid certificate chain can be produced without unsupported algorithms (see Section 4.2.3).","In addition, the signature algorithm MUST be compatible with the key in the sender's end-entity certificate. RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in ""signature_algorithms"". The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages.",4.4.3,Certificate Verify,3,16,1,MUST
"In addition, the signature algorithm MUST be compatible with the key in the sender's end-entity certificate.","When a signature is generated using the sender's end-entity certificate (including cases where the certificate’s key is of type RSA),When a CertificateVerify message is being signed","The signature algorithm MUST be compatible with the key in the sender's end-entity certificate,If the sender’s key is RSA, then an RSASSA-PSS algorithm MUST be used, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in the 'signature_algorithms' extension,The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages",MUST,"In addition, the signature algorithm MUST be compatible with the key in the sender's end-entity certificate. RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in ""signature_algorithms"". The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages.","If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the ""signature_algorithms"" extension in the CertificateRequest message.",All SHA-1 signature algorithms in this specification are defined solely for use in legacy certificates and are not valid for CertificateVerify signatures.,4.4.3,Certificate Verify,3,17,1,MUST
"RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in ""signature_algorithms"".","The operation involves generating an RSA signature, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in the 'signature_algorithms' extension.",RSA signatures MUST use an RSASSA-PSS algorithm.,MUST,"In addition, the signature algorithm MUST be compatible with the key in the sender's end-entity certificate. RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in ""signature_algorithms"". The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages.","If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the ""signature_algorithms"" extension in the CertificateRequest message.",All SHA-1 signature algorithms in this specification are defined solely for use in legacy certificates and are not valid for CertificateVerify signatures.,4.4.3,Certificate Verify,3,17,2,MUST
The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages.,"When a CertificateVerify message is being signed (i.e., a signature is generated for a CertificateVerify message)",The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages,MUST NOT,"In addition, the signature algorithm MUST be compatible with the key in the sender's end-entity certificate. RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in ""signature_algorithms"". The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages.","If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the ""signature_algorithms"" extension in the CertificateRequest message.",All SHA-1 signature algorithms in this specification are defined solely for use in legacy certificates and are not valid for CertificateVerify signatures.,4.4.3,Certificate Verify,3,17,3,MUST
The receiver of a CertificateVerify message MUST verify the signature field.,Upon receiving a CertificateVerify message,The receiver MUST verify the signature field.,MUST,The receiver of a CertificateVerify message MUST verify the signature field. The verification process takes as input:,All SHA-1 signature algorithms in this specification are defined solely for use in legacy certificates and are not valid for CertificateVerify signatures.,-The content covered by the digital signature,4.4.3,Certificate Verify,3,19,1,MUST
"If the verification fails, the receiver MUST terminate the handshake with a ""decrypt_error"" alert.",The verification fails,Terminate the handshake with a 'decrypt_error' alert,MUST,"If the verification fails, the receiver MUST terminate the handshake with a ""decrypt_error"" alert.",-The digital signature received in the signature field of the CertificateVerify message,,4.4.3,Certificate Verify,3,23,1,MUST
"Recipients of Finished messages MUST verify that the contents are correct and if incorrect MUST terminate the connection with a ""decrypt_error"" alert.",A Finished message is received by a recipient and its contents are found to be incorrect.,"The recipient MUST verify the contents of the Finished message, and if they are incorrect, MUST terminate the connection with a 'decrypt_error' alert.",MUST,"Recipients of Finished messages MUST verify that the contents are correct and if incorrect MUST terminate the connection with a ""decrypt_error"" alert.",The Finished message is the final message in the Authentication Block. It is essential for providing authentication of the handshake and of the computed keys.,"Once a side has sent its Finished message and has received and validated the Finished message from its peer, it may begin to send and receive Application Data over the connection. There are two settings in which it is permitted to send data prior to receiving the peer's Finished: 1. Clients sending 0-RTT data as described in Section 4.2.10. 2. Servers MAY send data after sending their first flight, but because the handshake is not yet complete, they have no assurance of either the peer's identity or its liveness (i.e., the ClientHello might have been replayed).",4.4.4,Finished,3,2,1,MUST
"Servers MAY send data after sending their first flight, but because the handshake is not yet complete, they have no assurance of either the peer's identity or its liveness (i.e., the ClientHello might have been replayed).",Servers have sent their first flight and the handshake is not yet complete,Servers MAY send data,MAY,"Once a side has sent its Finished message and has received and validated the Finished message from its peer, it may begin to send and receive Application Data over the connection. There are two settings in which it is permitted to send data prior to receiving the peer's Finished: 1. Clients sending 0-RTT data as described in Section 4.2.10. 2. Servers MAY send data after sending their first flight, but because the handshake is not yet complete, they have no assurance of either the peer's identity or its liveness (i.e., the ClientHello might have been replayed).","Recipients of Finished messages MUST verify that the contents are correct and if incorrect MUST terminate the connection with a ""decrypt_error"" alert.",The key used to compute the Finished message is computed from the Base Key defined in Section 4.4 using HKDF (see Section 7.1). Specifically:,4.4.4,Finished,3,3,5,MAY
Any records following a Finished message MUST be encrypted under the appropriate application traffic key as described in Section 7.2.,Records following a Finished message (including alerts sent by the server in response to client Certificate and CertificateVerify messages),The records MUST be encrypted under the appropriate application traffic key as described in Section 7.2,MUST,"Any records following a Finished message MUST be encrypted under the appropriate application traffic key as described in Section 7.2. In particular, this includes any alerts sent by the server in response to client Certificate and CertificateVerify messages.",Note: Alerts and any other non-handshake record types are not handshake messages and are not included in the hash computations.,,4.4.4,Finished,3,11,1,MUST
"If the server sent an ""early_data"" extension in EncryptedExtensions, the client MUST send an EndOfEarlyData message after receiving the server Finished.","The server sent an ""early_data"" extension in EncryptedExtensions,The client received the server Finished message",The client MUST send an EndOfEarlyData message after receiving the server Finished,MUST,"If the server sent an ""early_data"" extension in EncryptedExtensions, the client MUST send an EndOfEarlyData message after receiving the server Finished. If the server does not send an ""early_data"" extension in EncryptedExtensions, then the client MUST NOT send an EndOfEarlyData message. This message indicates that all 0-RTT application_data messages, if any, have been transmitted and that the",,"following records are protected under handshake traffic keys. Servers MUST NOT send this message, and clients receiving it MUST terminate the connection with an ""unexpected_message"" alert. This message is encrypted under keys derived from the client_early_traffic_secret.",4.5,End of Early Data,2,1,1,MUST
"If the server does not send an ""early_data"" extension in EncryptedExtensions, then the client MUST NOT send an EndOfEarlyData message.",Server does not send an 'early_data' extension in EncryptedExtensions.,Client MUST NOT send an EndOfEarlyData message.,MUST NOT,"If the server sent an ""early_data"" extension in EncryptedExtensions, the client MUST send an EndOfEarlyData message after receiving the server Finished. If the server does not send an ""early_data"" extension in EncryptedExtensions, then the client MUST NOT send an EndOfEarlyData message. This message indicates that all 0-RTT application_data messages, if any, have been transmitted and that the",,"following records are protected under handshake traffic keys. Servers MUST NOT send this message, and clients receiving it MUST terminate the connection with an ""unexpected_message"" alert. This message is encrypted under keys derived from the client_early_traffic_secret.",4.5,End of Early Data,2,1,2,MUST
"Servers MUST NOT send this message, and clients receiving it MUST terminate the connection with an ""unexpected_message"" alert.","If a server sends this message,If a client receives this message","Servers MUST NOT send this message,Clients receiving this message MUST terminate the connection with an 'unexpected_message' alert",MUST NOT,"following records are protected under handshake traffic keys. Servers MUST NOT send this message, and clients receiving it MUST terminate the connection with an ""unexpected_message"" alert. This message is encrypted under keys derived from the client_early_traffic_secret.","If the server sent an ""early_data"" extension in EncryptedExtensions, the client MUST send an EndOfEarlyData message after receiving the server Finished. If the server does not send an ""early_data"" extension in EncryptedExtensions, then the client MUST NOT send an EndOfEarlyData message. This message indicates that all 0-RTT application_data messages, if any, have been transmitted and that the",,4.5,End of Early Data,2,2,2,MUST
"At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message.",After the server has received the client Finished message,The server MAY send a NewSessionTicket message,MAY,"At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message. This message creates a unique association between the ticket value and a secret PSK derived from the resumption master secret (see Section 7).",,"The client MAY use this PSK for future handshakes by including the ticket value in the ""pre_shared_key"" extension in its ClientHello (Section 4.2.11). Servers MAY send multiple tickets on a single connection, either immediately after each other or after specific events (see Appendix C.4). For instance, the server might send a new ticket after post-handshake authentication in order to encapsulate the additional client authentication state. Multiple tickets are useful for clients for a variety of purposes, including:",4.6.1,New Session Ticket Message,3,1,1,MAY
"The client MAY use this PSK for future handshakes by including the ticket value in the ""pre_shared_key"" extension in its ClientHello (Section 4.2.11).",The client is initiating a future handshake (ClientHello) where it intends to use a PSK obtained from a previous NewSessionTicket.,"The client includes the ticket value in the ""pre_shared_key"" extension in its ClientHello.",MAY,"The client MAY use this PSK for future handshakes by including the ticket value in the ""pre_shared_key"" extension in its ClientHello (Section 4.2.11). Servers MAY send multiple tickets on a single connection, either immediately after each other or after specific events (see Appendix C.4). For instance, the server might send a new ticket after post-handshake authentication in order to encapsulate the additional client authentication state. Multiple tickets are useful for clients for a variety of purposes, including:","At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message. This message creates a unique association between the ticket value and a secret PSK derived from the resumption master secret (see Section 7).",-Opening multiple parallel HTTP connections.,4.6.1,New Session Ticket Message,3,2,1,MAY
"Servers MAY send multiple tickets on a single connection, either immediately after each other or after specific events (see Appendix C.4).","When a ticket has already been sent on the connection (allowing for immediate successive ticket transmissions),Upon occurrence of specific events (as detailed in Appendix C.4), such as after post‐handshake authentication","The server MAY send multiple tickets on a single connection, either immediately after each other or following the specific events.",MAY,"The client MAY use this PSK for future handshakes by including the ticket value in the ""pre_shared_key"" extension in its ClientHello (Section 4.2.11). Servers MAY send multiple tickets on a single connection, either immediately after each other or after specific events (see Appendix C.4). For instance, the server might send a new ticket after post-handshake authentication in order to encapsulate the additional client authentication state. Multiple tickets are useful for clients for a variety of purposes, including:","At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message. This message creates a unique association between the ticket value and a secret PSK derived from the resumption master secret (see Section 7).",-Opening multiple parallel HTTP connections.,4.6.1,New Session Ticket Message,3,2,2,MAY
Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection.,When a ticket is being resumed,The ticket MUST only be resumed using a cipher suite that employs the same KDF hash algorithm as was used in the original connection.,MUST,Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection.,-Performing connection racing across interfaces and address families via (for example) Happy Eyeballs [RFC8305] or related techniques.,"Clients MUST only resume if the new SNI value is valid for the server certificate presented in the original session and SHOULD only resume if the SNI value matches the one used in the original session. The latter is a performance optimization: normally, there is no reason to expect that different servers covered by a single certificate would be able to accept each other's tickets; hence, attempting resumption in that case would waste a single-use ticket. If such an indication is provided (externally or by any other means), clients MAY resume with a different SNI value.",4.6.1,New Session Ticket Message,3,5,1,MUST
Clients MUST only resume if the new SNI value is valid for the server certificate presented in the original session and SHOULD only resume if the SNI value matches the one used in the original session.,When a client attempts to resume a session using a new SNI value.,"The client MUST ensure that the new SNI value is valid for the server certificate presented in the original session.,The client SHOULD ensure that the new SNI value matches the one used in the original session.","MUST, SHOULD","Clients MUST only resume if the new SNI value is valid for the server certificate presented in the original session and SHOULD only resume if the SNI value matches the one used in the original session. The latter is a performance optimization: normally, there is no reason to expect that different servers covered by a single certificate would be able to accept each other's tickets; hence, attempting resumption in that case would waste a single-use ticket. If such an indication is provided (externally or by any other means), clients MAY resume with a different SNI value.",Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection.,"On resumption, if reporting an SNI value to the calling application, implementations MUST use the value sent in the resumption ClientHello rather than the value sent in the previous session. Note that if a server implementation declines all PSK identities with different SNI values, these two values are always the same.",4.6.1,New Session Ticket Message,3,6,1,MUST
"If such an indication is provided (externally or by any other means), clients MAY resume with a different SNI value.",An indication is provided (externally or by any other means) that permits a different SNI value for session resumption.,Clients MAY resume with a different SNI value.,MAY,"Clients MUST only resume if the new SNI value is valid for the server certificate presented in the original session and SHOULD only resume if the SNI value matches the one used in the original session. The latter is a performance optimization: normally, there is no reason to expect that different servers covered by a single certificate would be able to accept each other's tickets; hence, attempting resumption in that case would waste a single-use ticket. If such an indication is provided (externally or by any other means), clients MAY resume with a different SNI value.",Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection.,"On resumption, if reporting an SNI value to the calling application, implementations MUST use the value sent in the resumption ClientHello rather than the value sent in the previous session. Note that if a server implementation declines all PSK identities with different SNI values, these two values are always the same.",4.6.1,New Session Ticket Message,3,6,3,MAY
"On resumption, if reporting an SNI value to the calling application, implementations MUST use the value sent in the resumption ClientHello rather than the value sent in the previous session.","On resumption, if reporting an SNI value to the calling application",Implementations MUST use the SNI value sent in the resumption ClientHello rather than the value sent in the previous session,MUST,"On resumption, if reporting an SNI value to the calling application, implementations MUST use the value sent in the resumption ClientHello rather than the value sent in the previous session. Note that if a server implementation declines all PSK identities with different SNI values, these two values are always the same.","Clients MUST only resume if the new SNI value is valid for the server certificate presented in the original session and SHOULD only resume if the SNI value matches the one used in the original session. The latter is a performance optimization: normally, there is no reason to expect that different servers covered by a single certificate would be able to accept each other's tickets; hence, attempting resumption in that case would waste a single-use ticket. If such an indication is provided (externally or by any other means), clients MAY resume with a different SNI value.","Note: Although the resumption master secret depends on the client's second flight, a server which does not request client authentication MAY compute the remainder of the transcript independently and then send a NewSessionTicket immediately upon sending its Finished rather than waiting for the client Finished. This might be appropriate in cases where the client is expected to open multiple TLS connections in parallel and would benefit from the reduced overhead of a resumption handshake, for example.",4.6.1,New Session Ticket Message,3,7,1,MUST
"Note: Although the resumption master secret depends on the client's second flight, a server which does not request client authentication MAY compute the remainder of the transcript independently and then send a NewSessionTicket immediately upon sending its Finished rather than waiting for the client Finished.","The server does not request client authentication,The server is in the process of completing the handshake (i.e., after sending its Finished message)","Compute the remainder of the transcript independently and send a NewSessionTicket immediately upon sending its Finished, rather than waiting for the client Finished",MAY,"Note: Although the resumption master secret depends on the client's second flight, a server which does not request client authentication MAY compute the remainder of the transcript independently and then send a NewSessionTicket immediately upon sending its Finished rather than waiting for the client Finished. This might be appropriate in cases where the client is expected to open multiple TLS connections in parallel and would benefit from the reduced overhead of a resumption handshake, for example.","On resumption, if reporting an SNI value to the calling application, implementations MUST use the value sent in the resumption ClientHello rather than the value sent in the previous session. Note that if a server implementation declines all PSK identities with different SNI values, these two values are always the same.","ticket_lifetime: Indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance. Servers MUST NOT use any value greater than 604800 seconds (7 days). The value of zero indicates that the ticket should be discarded immediately. Clients MUST NOT cache tickets for longer than 7 days, regardless of the ticket_lifetime, and MAY delete tickets earlier based on local policy. A server MAY treat a ticket as valid for a shorter period of time than what is stated in the ticket_lifetime.",4.6.1,New Session Ticket Message,3,8,1,MAY
Servers MUST NOT use any value greater than 604800 seconds (7 days).,When setting the ticket_lifetime value for NewSessionTicket issuance,The server MUST NOT use any value greater than 604800 seconds (7 days),MUST NOT,"ticket_lifetime: Indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance. Servers MUST NOT use any value greater than 604800 seconds (7 days). The value of zero indicates that the ticket should be discarded immediately. Clients MUST NOT cache tickets for longer than 7 days, regardless of the ticket_lifetime, and MAY delete tickets earlier based on local policy. A server MAY treat a ticket as valid for a shorter period of time than what is stated in the ticket_lifetime.","Note: Although the resumption master secret depends on the client's second flight, a server which does not request client authentication MAY compute the remainder of the transcript independently and then send a NewSessionTicket immediately upon sending its Finished rather than waiting for the client Finished. This might be appropriate in cases where the client is expected to open multiple TLS connections in parallel and would benefit from the reduced overhead of a resumption handshake, for example.","ticket_age_add: A securely generated, random 32-bit value that is used to obscure the age of the ticket that the client includes in the ""pre_shared_key"" extension. The client-side ticket age is added to this value modulo 2^32 to obtain the value that is transmitted by the client. The server MUST generate a fresh value for each ticket it sends.",4.6.1,New Session Ticket Message,3,9,2,MUST
"Clients MUST NOT cache tickets for longer than 7 days, regardless of the ticket_lifetime, and MAY delete tickets earlier based on local policy.","Any instance where a client caches a received ticket, irrespective of the ticket_lifetime value.","The client MUST NOT cache tickets for longer than 7 days.,Optionally, the client MAY delete tickets earlier based on its local policy.","MUST NOT, MAY","ticket_lifetime: Indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance. Servers MUST NOT use any value greater than 604800 seconds (7 days). The value of zero indicates that the ticket should be discarded immediately. Clients MUST NOT cache tickets for longer than 7 days, regardless of the ticket_lifetime, and MAY delete tickets earlier based on local policy. A server MAY treat a ticket as valid for a shorter period of time than what is stated in the ticket_lifetime.","Note: Although the resumption master secret depends on the client's second flight, a server which does not request client authentication MAY compute the remainder of the transcript independently and then send a NewSessionTicket immediately upon sending its Finished rather than waiting for the client Finished. This might be appropriate in cases where the client is expected to open multiple TLS connections in parallel and would benefit from the reduced overhead of a resumption handshake, for example.","ticket_age_add: A securely generated, random 32-bit value that is used to obscure the age of the ticket that the client includes in the ""pre_shared_key"" extension. The client-side ticket age is added to this value modulo 2^32 to obtain the value that is transmitted by the client. The server MUST generate a fresh value for each ticket it sends.",4.6.1,New Session Ticket Message,3,9,4,MUST
A server MAY treat a ticket as valid for a shorter period of time than what is stated in the ticket_lifetime.,The server is processing a session ticket associated with a ticket_lifetime value.,The server MAY treat the ticket as valid for a shorter period of time than what is stated in the ticket_lifetime.,MAY,"ticket_lifetime: Indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance. Servers MUST NOT use any value greater than 604800 seconds (7 days). The value of zero indicates that the ticket should be discarded immediately. Clients MUST NOT cache tickets for longer than 7 days, regardless of the ticket_lifetime, and MAY delete tickets earlier based on local policy. A server MAY treat a ticket as valid for a shorter period of time than what is stated in the ticket_lifetime.","Note: Although the resumption master secret depends on the client's second flight, a server which does not request client authentication MAY compute the remainder of the transcript independently and then send a NewSessionTicket immediately upon sending its Finished rather than waiting for the client Finished. This might be appropriate in cases where the client is expected to open multiple TLS connections in parallel and would benefit from the reduced overhead of a resumption handshake, for example.","ticket_age_add: A securely generated, random 32-bit value that is used to obscure the age of the ticket that the client includes in the ""pre_shared_key"" extension. The client-side ticket age is added to this value modulo 2^32 to obtain the value that is transmitted by the client. The server MUST generate a fresh value for each ticket it sends.",4.6.1,New Session Ticket Message,3,9,5,MAY
The server MUST generate a fresh value for each ticket it sends.,When the server sends a ticket,The server MUST generate a fresh value for the ticket each time it is sent,MUST,"ticket_age_add: A securely generated, random 32-bit value that is used to obscure the age of the ticket that the client includes in the ""pre_shared_key"" extension. The client-side ticket age is added to this value modulo 2^32 to obtain the value that is transmitted by the client. The server MUST generate a fresh value for each ticket it sends.","ticket_lifetime: Indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance. Servers MUST NOT use any value greater than 604800 seconds (7 days). The value of zero indicates that the ticket should be discarded immediately. Clients MUST NOT cache tickets for longer than 7 days, regardless of the ticket_lifetime, and MAY delete tickets earlier based on local policy. A server MAY treat a ticket as valid for a shorter period of time than what is stated in the ticket_lifetime.",ticket_nonce: A per-ticket value that is unique across all tickets issued on this connection.,4.6.1,New Session Ticket Message,3,10,3,MUST
It MAY be either a database lookup key or a self-encrypted and self-authenticated value.,,The ticket value used as the PSK identity MUST be an opaque label that is either a database lookup key or a self-encrypted and self-authenticated value.,MAY,ticket: The value of the ticket to be used as the PSK identity. The ticket itself is an opaque label. It MAY be either a database lookup key or a self-encrypted and self-authenticated value.,ticket_nonce: A per-ticket value that is unique across all tickets issued on this connection.,"extensions: A set of extension values for the ticket. The ""Extension"" format is defined in Section 4.2. Clients MUST ignore unrecognized extensions.",4.6.1,New Session Ticket Message,3,12,3,MAY
Clients MUST ignore unrecognized extensions.,The presence of an extension within the ticket that is not recognized by the client.,Clients MUST ignore the unrecognized extensions.,MUST,"extensions: A set of extension values for the ticket. The ""Extension"" format is defined in Section 4.2. Clients MUST ignore unrecognized extensions.",ticket: The value of the ticket to be used as the PSK identity. The ticket itself is an opaque label. It MAY be either a database lookup key or a self-encrypted and self-authenticated value.,"The sole extension currently defined for NewSessionTicket is ""early_data"", indicating that the ticket may be used to send 0-RTT data (Section 4.2.10). It contains the following value:",4.6.1,New Session Ticket Message,3,13,3,MUST
"A server receiving more than max_early_data_size bytes of 0-RTT data SHOULD terminate the connection with an ""unexpected_message"" alert.",When a server receives more than max_early_data_size bytes of 0-RTT data,The server SHOULD terminate the connection with an 'unexpected_message' alert,SHOULD,"max_early_data_size: The maximum amount of 0-RTT data that the client is allowed to send when using this ticket, in bytes. Only Application Data payload (i.e., plaintext but not padding or the inner content type byte) is counted. A server receiving more than max_early_data_size bytes of 0-RTT data SHOULD terminate the connection with an ""unexpected_message"" alert. Note that servers that reject early data due to lack of cryptographic material will be unable to differentiate padding from content, so clients SHOULD NOT depend on being able to send large quantities of padding in early data records.","The sole extension currently defined for NewSessionTicket is ""early_data"", indicating that the ticket may be used to send 0-RTT data (Section 4.2.10). It contains the following value:",The PSK associated with the ticket is computed as:,4.6.1,New Session Ticket Message,3,15,3,SHOULD
"Note that servers that reject early data due to lack of cryptographic material will be unable to differentiate padding from content, so clients SHOULD NOT depend on being able to send large quantities of padding in early data records.",Servers that reject early data due to lack of cryptographic material (which results in an inability to differentiate padding from content),Clients SHOULD NOT depend on being able to send large quantities of padding in early data records,SHOULD NOT,"max_early_data_size: The maximum amount of 0-RTT data that the client is allowed to send when using this ticket, in bytes. Only Application Data payload (i.e., plaintext but not padding or the inner content type byte) is counted. A server receiving more than max_early_data_size bytes of 0-RTT data SHOULD terminate the connection with an ""unexpected_message"" alert. Note that servers that reject early data due to lack of cryptographic material will be unable to differentiate padding from content, so clients SHOULD NOT depend on being able to send large quantities of padding in early data records.","The sole extension currently defined for NewSessionTicket is ""early_data"", indicating that the ticket may be used to send 0-RTT data (Section 4.2.10). It contains the following value:",The PSK associated with the ticket is computed as:,4.6.1,New Session Ticket Message,3,15,4,SHOULD
"When the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message.","The client has sent the ""post_handshake_auth"" extension,The handshake has completed",The server MAY request client authentication by sending a CertificateRequest message,MAY,"When the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message. The client MUST respond with the appropriate Authentication messages (see Section 4.4). If the client chooses to authenticate, it MUST send Certificate, CertificateVerify,",,"and Finished. If it declines, it MUST send a Certificate message containing no certificates followed by Finished. All of the client's messages for a given response MUST appear consecutively on the wire with no intervening messages of other types.",4.6.2,Post-Handshake Authentication,3,1,1,MAY
The client MUST respond with the appropriate Authentication messages (see Section 4.4).,"When the client has sent the 'post_handshake_auth' extension and the server sends a CertificateRequest message (i.e., when the server requests client authentication after the handshake).","The client MUST respond with the appropriate Authentication messages as described in Section 4.4. This involves sending a sequence of messages: if authenticating, a Certificate, CertificateVerify, and Finished; if declining, a Certificate message with no certificates followed by Finished. All these messages must appear consecutively on the wire.",MUST,"When the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message. The client MUST respond with the appropriate Authentication messages (see Section 4.4). If the client chooses to authenticate, it MUST send Certificate, CertificateVerify,",,"and Finished. If it declines, it MUST send a Certificate message containing no certificates followed by Finished. All of the client's messages for a given response MUST appear consecutively on the wire with no intervening messages of other types.",4.6.2,Post-Handshake Authentication,3,1,2,MUST
"If the client chooses to authenticate, it MUST send Certificate, CertificateVerify,",The client chooses to authenticate (i.e. it elects to perform authentication following a request for client authentication),"The client MUST send the authentication messages – specifically, a Certificate and a CertificateVerify (followed by a Finished message as indicated in the surrounding context) – ensuring that all of these messages appear consecutively without any intervening messages",MUST,"When the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message. The client MUST respond with the appropriate Authentication messages (see Section 4.4). If the client chooses to authenticate, it MUST send Certificate, CertificateVerify,",,"and Finished. If it declines, it MUST send a Certificate message containing no certificates followed by Finished. All of the client's messages for a given response MUST appear consecutively on the wire with no intervening messages of other types.",4.6.2,Post-Handshake Authentication,3,1,3,MUST
"If it declines, it MUST send a Certificate message containing no certificates followed by Finished.","The client declines to provide post-handshake authentication (i.e., chooses not to authenticate).","The client MUST send a Certificate message containing no certificates followed by a Finished message, with all messages appearing consecutively on the wire.",MUST,"and Finished. If it declines, it MUST send a Certificate message containing no certificates followed by Finished. All of the client's messages for a given response MUST appear consecutively on the wire with no intervening messages of other types.","When the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message. The client MUST respond with the appropriate Authentication messages (see Section 4.4). If the client chooses to authenticate, it MUST send Certificate, CertificateVerify,","A client that receives a CertificateRequest message without having sent the ""post_handshake_auth"" extension MUST send an ""unexpected_message"" fatal alert.",4.6.2,Post-Handshake Authentication,3,2,2,MUST
All of the client's messages for a given response MUST appear consecutively on the wire with no intervening messages of other types.,When sending all messages corresponding to a single response,The client's messages for that response MUST appear consecutively on the wire with no intervening messages of other types,MUST,"and Finished. If it declines, it MUST send a Certificate message containing no certificates followed by Finished. All of the client's messages for a given response MUST appear consecutively on the wire with no intervening messages of other types.","When the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message. The client MUST respond with the appropriate Authentication messages (see Section 4.4). If the client chooses to authenticate, it MUST send Certificate, CertificateVerify,","A client that receives a CertificateRequest message without having sent the ""post_handshake_auth"" extension MUST send an ""unexpected_message"" fatal alert.",4.6.2,Post-Handshake Authentication,3,2,3,MUST
"A client that receives a CertificateRequest message without having sent the ""post_handshake_auth"" extension MUST send an ""unexpected_message"" fatal alert.","The client receives a CertificateRequest message without having sent the ""post_handshake_auth"" extension","The client MUST send an ""unexpected_message"" fatal alert",MUST,"A client that receives a CertificateRequest message without having sent the ""post_handshake_auth"" extension MUST send an ""unexpected_message"" fatal alert.","and Finished. If it declines, it MUST send a Certificate message containing no certificates followed by Finished. All of the client's messages for a given response MUST appear consecutively on the wire with no intervening messages of other types.","Note: Because client authentication could involve prompting the user, servers MUST be prepared for some delay, including receiving an arbitrary number of other messages between sending the CertificateRequest and receiving a response. In addition, clients which receive multiple CertificateRequests in close succession MAY respond to them in a different order than they were received (the certificate_request_context value allows the server to disambiguate the responses).",4.6.2,Post-Handshake Authentication,3,3,1,MUST
"Note: Because client authentication could involve prompting the user, servers MUST be prepared for some delay, including receiving an arbitrary number of other messages between sending the CertificateRequest and receiving a response.","After sending a CertificateRequest message and while waiting for the client's response, during which client authentication may require user prompting",Servers MUST be prepared for some delay and be capable of handling an arbitrary number of other messages that may be received between sending the CertificateRequest and receiving the client's response,MUST,"Note: Because client authentication could involve prompting the user, servers MUST be prepared for some delay, including receiving an arbitrary number of other messages between sending the CertificateRequest and receiving a response. In addition, clients which receive multiple CertificateRequests in close succession MAY respond to them in a different order than they were received (the certificate_request_context value allows the server to disambiguate the responses).","A client that receives a CertificateRequest message without having sent the ""post_handshake_auth"" extension MUST send an ""unexpected_message"" fatal alert.",,4.6.2,Post-Handshake Authentication,3,4,1,MUST
"In addition, clients which receive multiple CertificateRequests in close succession MAY respond to them in a different order than they were received (the certificate_request_context value allows the server to disambiguate the responses).",Clients receive multiple CertificateRequests in close succession.,"Clients MAY respond to the CertificateRequests in a different order than they were received, leveraging the certificate_request_context value to disambiguate the responses.",MAY,"Note: Because client authentication could involve prompting the user, servers MUST be prepared for some delay, including receiving an arbitrary number of other messages between sending the CertificateRequest and receiving a response. In addition, clients which receive multiple CertificateRequests in close succession MAY respond to them in a different order than they were received (the certificate_request_context value allows the server to disambiguate the responses).","A client that receives a CertificateRequest message without having sent the ""post_handshake_auth"" extension MUST send an ""unexpected_message"" fatal alert.",,4.6.2,Post-Handshake Authentication,3,4,2,MAY
"Implementations that receive a KeyUpdate message prior to receiving a Finished message MUST terminate the connection with an ""unexpected_message"" alert.",Receiving a KeyUpdate message prior to receiving a Finished message.,Terminate the connection with an 'unexpected_message' alert.,MUST,"The KeyUpdate handshake message is used to indicate that the sender is updating its sending cryptographic keys. This message can be sent by either peer after it has sent a Finished message. Implementations that receive a KeyUpdate message prior to receiving a Finished message MUST terminate the connection with an ""unexpected_message"" alert. After sending a KeyUpdate message, the sender SHALL send all its traffic using the next generation of keys, computed as described in Section 7.2. Upon receiving a KeyUpdate, the receiver MUST update its receiving keys.",,"request_update: Indicates whether the recipient of the KeyUpdate should respond with its own KeyUpdate. If an implementation receives any other value, it MUST terminate the connection with an ""illegal_parameter"" alert.",4.6.3,Key and Initialization Vector Update,3,1,3,MUST
"Upon receiving a KeyUpdate, the receiver MUST update its receiving keys.",Upon receiving a KeyUpdate,The receiver MUST update its receiving keys,MUST,"The KeyUpdate handshake message is used to indicate that the sender is updating its sending cryptographic keys. This message can be sent by either peer after it has sent a Finished message. Implementations that receive a KeyUpdate message prior to receiving a Finished message MUST terminate the connection with an ""unexpected_message"" alert. After sending a KeyUpdate message, the sender SHALL send all its traffic using the next generation of keys, computed as described in Section 7.2. Upon receiving a KeyUpdate, the receiver MUST update its receiving keys.",,"request_update: Indicates whether the recipient of the KeyUpdate should respond with its own KeyUpdate. If an implementation receives any other value, it MUST terminate the connection with an ""illegal_parameter"" alert.",4.6.3,Key and Initialization Vector Update,3,1,5,MUST
"If an implementation receives any other value, it MUST terminate the connection with an ""illegal_parameter"" alert.","An implementation receives any value for the request_update field that is not a valid value (i.e., any value other than the defined valid ones)",Terminate the connection with an 'illegal_parameter' alert,MUST,"request_update: Indicates whether the recipient of the KeyUpdate should respond with its own KeyUpdate. If an implementation receives any other value, it MUST terminate the connection with an ""illegal_parameter"" alert.","The KeyUpdate handshake message is used to indicate that the sender is updating its sending cryptographic keys. This message can be sent by either peer after it has sent a Finished message. Implementations that receive a KeyUpdate message prior to receiving a Finished message MUST terminate the connection with an ""unexpected_message"" alert. After sending a KeyUpdate message, the sender SHALL send all its traffic using the next generation of keys, computed as described in Section 7.2. Upon receiving a KeyUpdate, the receiver MUST update its receiving keys.","If the request_update field is set to ""update_requested"", then the receiver MUST send a KeyUpdate of its own with request_update set to ""update_not_requested"" prior to sending its next Application Data record. This mechanism allows either side to force an update to the entire connection, but causes an implementation which receives",4.6.3,Key and Initialization Vector Update,3,2,2,MUST
"If the request_update field is set to ""update_requested"", then the receiver MUST send a KeyUpdate of its own with request_update set to ""update_not_requested"" prior to sending its next Application Data record.",The request_update field is set to 'update_requested',The receiver MUST send a KeyUpdate of its own with request_update set to 'update_not_requested' prior to sending its next Application Data record,MUST,"If the request_update field is set to ""update_requested"", then the receiver MUST send a KeyUpdate of its own with request_update set to ""update_not_requested"" prior to sending its next Application Data record. This mechanism allows either side to force an update to the entire connection, but causes an implementation which receives","request_update: Indicates whether the recipient of the KeyUpdate should respond with its own KeyUpdate. If an implementation receives any other value, it MUST terminate the connection with an ""illegal_parameter"" alert.","multiple KeyUpdates while it is silent to respond with a single update. Note that implementations may receive an arbitrary number of messages between sending a KeyUpdate with request_update set to ""update_requested"" and receiving the peer's KeyUpdate, because those messages may already be in flight. However, because send and receive keys are derived from independent traffic secrets, retaining the receive traffic secret does not threaten the forward secrecy of data sent before the sender changed keys.",4.6.3,Key and Initialization Vector Update,3,3,1,MUST
Both sender and receiver MUST encrypt their KeyUpdate messages with the old keys.,"When a KeyUpdate message is being sent by either the sender or receiver,Before accepting any messages encrypted with the new key","Both sender and receiver MUST encrypt their KeyUpdate messages with the old keys,Both sides MUST enforce that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key",MUST,"Both sender and receiver MUST encrypt their KeyUpdate messages with the old keys. Additionally, both sides MUST enforce that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key. Failure to do so may allow message truncation attacks.","If implementations independently send their own KeyUpdates with request_update set to ""update_requested"" and they cross in flight, then each side will also send a response, with the result that each side increments by two generations.",,4.6.3,Key and Initialization Vector Update,3,6,1,MUST
"Additionally, both sides MUST enforce that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key.","Before accepting any messages encrypted with the new key, i.e. when such messages are received.",Both sides MUST enforce that a KeyUpdate message sent with the old key is received prior to accepting any messages encrypted with the new key.,MUST,"Both sender and receiver MUST encrypt their KeyUpdate messages with the old keys. Additionally, both sides MUST enforce that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key. Failure to do so may allow message truncation attacks.","If implementations independently send their own KeyUpdates with request_update set to ""update_requested"" and they cross in flight, then each side will also send a response, with the result that each side increments by two generations.",,4.6.3,Key and Initialization Vector Update,3,6,2,MUST
An implementation may receive an unencrypted record of type change_cipher_spec consisting of the single byte value 0x01 at any time after the first ClientHello message has been sent or received and before the peer's Finished message has been received and MUST simply drop it without further processing.,An unencrypted record of type change_cipher_spec consisting of the single byte value 0x01 is received after the first ClientHello message has been sent or received and before the peer's Finished message has been received.,The implementation MUST simply drop the record without further processing.,MUST,"An implementation may receive an unencrypted record of type change_cipher_spec consisting of the single byte value 0x01 at any time after the first ClientHello message has been sent or received and before the peer's Finished message has been received and MUST simply drop it without further processing. Note that this record may appear at a point at the handshake where the implementation is expecting protected records, and so it is necessary to detect this condition prior to attempting to deprotect the record. An implementation which receives any other change_cipher_spec value or which receives a protected change_cipher_spec record MUST abort the handshake with an ""unexpected_message"" alert. If an implementation detects a change_cipher_spec record received before the first ClientHello message or after the peer's Finished message, it MUST be treated as an unexpected record type (though stateless servers may not be able to distinguish these cases from allowed cases).","TLS records are typed, which allows multiple higher-level protocols to be multiplexed over the same record layer. This document specifies four content types: handshake, application_data, alert, and change_cipher_spec. The change_cipher_spec record is used only for compatibility purposes (see Appendix D.4).","Implementations MUST NOT send record types not defined in this document unless negotiated by some extension. If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert. New record content type values are assigned by IANA in the TLS ContentType registry as described in Section 11.",5,Record Protocol,1,3,1,MUST
"An implementation which receives any other change_cipher_spec value or which receives a protected change_cipher_spec record MUST abort the handshake with an ""unexpected_message"" alert.","Receiving any other change_cipher_spec value,Receiving a protected change_cipher_spec record",Abort the handshake with an 'unexpected_message' alert,MUST,"An implementation may receive an unencrypted record of type change_cipher_spec consisting of the single byte value 0x01 at any time after the first ClientHello message has been sent or received and before the peer's Finished message has been received and MUST simply drop it without further processing. Note that this record may appear at a point at the handshake where the implementation is expecting protected records, and so it is necessary to detect this condition prior to attempting to deprotect the record. An implementation which receives any other change_cipher_spec value or which receives a protected change_cipher_spec record MUST abort the handshake with an ""unexpected_message"" alert. If an implementation detects a change_cipher_spec record received before the first ClientHello message or after the peer's Finished message, it MUST be treated as an unexpected record type (though stateless servers may not be able to distinguish these cases from allowed cases).","TLS records are typed, which allows multiple higher-level protocols to be multiplexed over the same record layer. This document specifies four content types: handshake, application_data, alert, and change_cipher_spec. The change_cipher_spec record is used only for compatibility purposes (see Appendix D.4).","Implementations MUST NOT send record types not defined in this document unless negotiated by some extension. If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert. New record content type values are assigned by IANA in the TLS ContentType registry as described in Section 11.",5,Record Protocol,1,3,3,MUST
"If an implementation detects a change_cipher_spec record received before the first ClientHello message or after the peer's Finished message, it MUST be treated as an unexpected record type (though stateless servers may not be able to distinguish these cases from allowed cases).",A change_cipher_spec record is detected before the first ClientHello message or after the peer's Finished message,The implementation MUST treat the change_cipher_spec record as an unexpected record type,MUST,"An implementation may receive an unencrypted record of type change_cipher_spec consisting of the single byte value 0x01 at any time after the first ClientHello message has been sent or received and before the peer's Finished message has been received and MUST simply drop it without further processing. Note that this record may appear at a point at the handshake where the implementation is expecting protected records, and so it is necessary to detect this condition prior to attempting to deprotect the record. An implementation which receives any other change_cipher_spec value or which receives a protected change_cipher_spec record MUST abort the handshake with an ""unexpected_message"" alert. If an implementation detects a change_cipher_spec record received before the first ClientHello message or after the peer's Finished message, it MUST be treated as an unexpected record type (though stateless servers may not be able to distinguish these cases from allowed cases).","TLS records are typed, which allows multiple higher-level protocols to be multiplexed over the same record layer. This document specifies four content types: handshake, application_data, alert, and change_cipher_spec. The change_cipher_spec record is used only for compatibility purposes (see Appendix D.4).","Implementations MUST NOT send record types not defined in this document unless negotiated by some extension. If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert. New record content type values are assigned by IANA in the TLS ContentType registry as described in Section 11.",5,Record Protocol,1,3,4,MUST
Implementations MUST NOT send record types not defined in this document unless negotiated by some extension.,When an implementation is about to send a record type that is not defined in this document and no extension has been negotiated to allow it,The implementation MUST NOT send the undefined record type,MUST NOT,"Implementations MUST NOT send record types not defined in this document unless negotiated by some extension. If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert. New record content type values are assigned by IANA in the TLS ContentType registry as described in Section 11.","An implementation may receive an unencrypted record of type change_cipher_spec consisting of the single byte value 0x01 at any time after the first ClientHello message has been sent or received and before the peer's Finished message has been received and MUST simply drop it without further processing. Note that this record may appear at a point at the handshake where the implementation is expecting protected records, and so it is necessary to detect this condition prior to attempting to deprotect the record. An implementation which receives any other change_cipher_spec value or which receives a protected change_cipher_spec record MUST abort the handshake with an ""unexpected_message"" alert. If an implementation detects a change_cipher_spec record received before the first ClientHello message or after the peer's Finished message, it MUST be treated as an unexpected record type (though stateless servers may not be able to distinguish these cases from allowed cases).",,5,Record Protocol,1,4,1,MUST
"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",A TLS implementation receives an unexpected record type.,Terminate the connection with an 'unexpected_message' alert.,MUST,"Implementations MUST NOT send record types not defined in this document unless negotiated by some extension. If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert. New record content type values are assigned by IANA in the TLS ContentType registry as described in Section 11.","An implementation may receive an unencrypted record of type change_cipher_spec consisting of the single byte value 0x01 at any time after the first ClientHello message has been sent or received and before the peer's Finished message has been received and MUST simply drop it without further processing. Note that this record may appear at a point at the handshake where the implementation is expecting protected records, and so it is necessary to detect this condition prior to attempting to deprotect the record. An implementation which receives any other change_cipher_spec value or which receives a protected change_cipher_spec record MUST abort the handshake with an ""unexpected_message"" alert. If an implementation detects a change_cipher_spec record received before the first ClientHello message or after the peer's Finished message, it MUST be treated as an unexpected record type (though stateless servers may not be able to distinguish these cases from allowed cases).",,5,Record Protocol,1,4,2,MUST
Any future content types MUST specify appropriate rules.,The requirement applies when handling any future content types.,The future content types MUST specify appropriate rules.,MUST,The record layer fragments information blocks into TLSPlaintext records carrying data in chunks of 2^14 bytes or less. Message boundaries are handled differently depending on the underlying ContentType. Any future content types MUST specify appropriate rules. Note that these rules are stricter than what was enforced in TLS 1.2.,,"Handshake messages MAY be coalesced into a single TLSPlaintext record or fragmented across several records, provided that:",5.1,Record Layer,2,1,3,MUST
"Handshake messages MAY be coalesced into a single TLSPlaintext record or fragmented across several records, provided that:",Handshake messages are being coalesced into a single TLSPlaintext record or fragmented across several TLSPlaintext records.,"If handshake messages are split across multiple records, they MUST NOT be interleaved with any records of other types.",MAY,"Handshake messages MAY be coalesced into a single TLSPlaintext record or fragmented across several records, provided that:",The record layer fragments information blocks into TLSPlaintext records carrying data in chunks of 2^14 bytes or less. Message boundaries are handled differently depending on the underlying ContentType. Any future content types MUST specify appropriate rules. Note that these rules are stricter than what was enforced in TLS 1.2.,"-Handshake messages MUST NOT be interleaved with other record types. That is, if a handshake message is split over two or more records, there MUST NOT be any other records between them.",5.1,Record Layer,2,2,1,MAY
-Handshake messages MUST NOT be interleaved with other record types.,A handshake message is split over two or more TLSPlaintext records,Handshake messages MUST NOT be interleaved with other record types; no other records are allowed between the fragments of a split handshake message,MUST NOT,"-Handshake messages MUST NOT be interleaved with other record types. That is, if a handshake message is split over two or more records, there MUST NOT be any other records between them.","Handshake messages MAY be coalesced into a single TLSPlaintext record or fragmented across several records, provided that:","-Handshake messages MUST NOT span key changes. Implementations MUST verify that all messages immediately preceding a key change align with a record boundary; if not, then they MUST terminate the connection with an ""unexpected_message"" alert. Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages can immediately precede a key change, implementations MUST send these messages in alignment with a record boundary.",5.1,Record Layer,2,3,1,MUST
"That is, if a handshake message is split over two or more records, there MUST NOT be any other records between them.",A handshake message is split over two or more records,There MUST NOT be any other records between the split handshake message records,MUST NOT,"-Handshake messages MUST NOT be interleaved with other record types. That is, if a handshake message is split over two or more records, there MUST NOT be any other records between them.","Handshake messages MAY be coalesced into a single TLSPlaintext record or fragmented across several records, provided that:","-Handshake messages MUST NOT span key changes. Implementations MUST verify that all messages immediately preceding a key change align with a record boundary; if not, then they MUST terminate the connection with an ""unexpected_message"" alert. Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages can immediately precede a key change, implementations MUST send these messages in alignment with a record boundary.",5.1,Record Layer,2,3,2,MUST
-Handshake messages MUST NOT span key changes.,"A handshake message (or messages immediately preceding a key change) that does not align with a record boundary, i.e. spanning a key change.","Implementations MUST verify that all handshake messages immediately preceding a key change align with a record boundary; if they do not, the connection MUST be terminated with an 'unexpected_message' alert.",MUST NOT,"-Handshake messages MUST NOT span key changes. Implementations MUST verify that all messages immediately preceding a key change align with a record boundary; if not, then they MUST terminate the connection with an ""unexpected_message"" alert. Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages can immediately precede a key change, implementations MUST send these messages in alignment with a record boundary.","-Handshake messages MUST NOT be interleaved with other record types. That is, if a handshake message is split over two or more records, there MUST NOT be any other records between them.","Implementations MUST NOT send zero-length fragments of Handshake types, even if those fragments contain padding.",5.1,Record Layer,2,4,1,MUST
"Implementations MUST verify that all messages immediately preceding a key change align with a record boundary; if not, then they MUST terminate the connection with an ""unexpected_message"" alert.",All messages immediately preceding a key change do not align with a record boundary,Terminate the connection with an 'unexpected_message' alert,MUST,"-Handshake messages MUST NOT span key changes. Implementations MUST verify that all messages immediately preceding a key change align with a record boundary; if not, then they MUST terminate the connection with an ""unexpected_message"" alert. Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages can immediately precede a key change, implementations MUST send these messages in alignment with a record boundary.","-Handshake messages MUST NOT be interleaved with other record types. That is, if a handshake message is split over two or more records, there MUST NOT be any other records between them.","Implementations MUST NOT send zero-length fragments of Handshake types, even if those fragments contain padding.",5.1,Record Layer,2,4,2,MUST
"Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages can immediately precede a key change, implementations MUST send these messages in alignment with a record boundary.","The scenario where the handshake messages (ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate) can immediately precede a key change.",Implementations MUST send these messages in alignment with a record boundary.,MUST,"-Handshake messages MUST NOT span key changes. Implementations MUST verify that all messages immediately preceding a key change align with a record boundary; if not, then they MUST terminate the connection with an ""unexpected_message"" alert. Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages can immediately precede a key change, implementations MUST send these messages in alignment with a record boundary.","-Handshake messages MUST NOT be interleaved with other record types. That is, if a handshake message is split over two or more records, there MUST NOT be any other records between them.","Implementations MUST NOT send zero-length fragments of Handshake types, even if those fragments contain padding.",5.1,Record Layer,2,4,3,MUST
"Implementations MUST NOT send zero-length fragments of Handshake types, even if those fragments contain padding.","A fragment of a Handshake type message that is zero-length, even if it contains padding.",Implementations MUST NOT send such zero-length fragments of Handshake types.,MUST NOT,"Implementations MUST NOT send zero-length fragments of Handshake types, even if those fragments contain padding.","-Handshake messages MUST NOT span key changes. Implementations MUST verify that all messages immediately preceding a key change align with a record boundary; if not, then they MUST terminate the connection with an ""unexpected_message"" alert. Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages can immediately precede a key change, implementations MUST send these messages in alignment with a record boundary.","Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record. In other words, a record with an Alert type MUST contain exactly one message.",5.1,Record Layer,2,5,1,MUST
"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.","When alert messages (as defined in Section 6) are being sent in TLSPlaintext records, i.e., when a record is of the Alert type.","Alert messages MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record; in other words, a record with an Alert type MUST contain exactly one message.",MUST NOT,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record. In other words, a record with an Alert type MUST contain exactly one message.","Implementations MUST NOT send zero-length fragments of Handshake types, even if those fragments contain padding.","Application Data messages contain data that is opaque to TLS. Application Data messages are always protected. Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure. Application Data fragments MAY be split across multiple records or coalesced into a single record.",5.1,Record Layer,2,6,1,MUST
"In other words, a record with an Alert type MUST contain exactly one message.",A record is of Alert type,The record MUST contain exactly one message,MUST,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record. In other words, a record with an Alert type MUST contain exactly one message.","Implementations MUST NOT send zero-length fragments of Handshake types, even if those fragments contain padding.","Application Data messages contain data that is opaque to TLS. Application Data messages are always protected. Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure. Application Data fragments MAY be split across multiple records or coalesced into a single record.",5.1,Record Layer,2,6,2,MUST
"Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure.",,"Implement allowance for sending zero-length fragments of Application Data, as these fragments are potentially useful as a traffic analysis countermeasure.",MAY,"Application Data messages contain data that is opaque to TLS. Application Data messages are always protected. Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure. Application Data fragments MAY be split across multiple records or coalesced into a single record.","Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record. In other words, a record with an Alert type MUST contain exactly one message.",type: The higher-level protocol used to process the enclosed fragment.,5.1,Record Layer,2,7,3,MAY
Application Data fragments MAY be split across multiple records or coalesced into a single record.,When handling transmission of Application Data fragments.,Application Data fragments MAY be split across multiple records or coalesced into a single record.,MAY,"Application Data messages contain data that is opaque to TLS. Application Data messages are always protected. Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure. Application Data fragments MAY be split across multiple records or coalesced into a single record.","Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record. In other words, a record with an Alert type MUST contain exactly one message.",type: The higher-level protocol used to process the enclosed fragment.,5.1,Record Layer,2,7,4,MAY
"legacy_record_version: MUST be set to 0x0303 for all records generated by a TLS 1.3 implementation other than an initial ClientHello (i.e., one not generated after a HelloRetryRequest), where it MAY also be 0x0301 for compatibility purposes.","The requirement applies to all records generated by a TLS 1.3 implementation that are not initial ClientHello messages (i.e., those not generated after a HelloRetryRequest)","The legacy_record_version field MUST be set to 0x0303, with an option to be set to 0x0301 for compatibility purposes","MUST, MAY","legacy_record_version: MUST be set to 0x0303 for all records generated by a TLS 1.3 implementation other than an initial ClientHello (i.e., one not generated after a HelloRetryRequest), where it MAY also be 0x0301 for compatibility purposes. This field is deprecated and MUST be ignored for all purposes. Previous versions of TLS would use other values in this field under some circumstances.",type: The higher-level protocol used to process the enclosed fragment.,"length: The length (in bytes) of the following TLSPlaintext.fragment. The length MUST NOT exceed 2^14 bytes. An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.",5.1,Record Layer,2,9,1,MUST
This field is deprecated and MUST be ignored for all purposes,"Applies to any instance where the deprecated field is encountered (i.e., in all cases or records where the field is present)",The field MUST be ignored for all purposes,MUST,"legacy_record_version: MUST be set to 0x0303 for all records generated by a TLS 1.3 implementation other than an initial ClientHello (i.e., one not generated after a HelloRetryRequest), where it MAY also be 0x0301 for compatibility purposes. This field is deprecated and MUST be ignored for all purposes. Previous versions of TLS would use other values in this field under some circumstances.",type: The higher-level protocol used to process the enclosed fragment.,"length: The length (in bytes) of the following TLSPlaintext.fragment. The length MUST NOT exceed 2^14 bytes. An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.",5.1,Record Layer,2,9,2,MUST
The length MUST NOT exceed 2^14 bytes.,An endpoint receives a TLS record where the length field indicates a size greater than 2^14 bytes.,Terminate the connection and send a 'record_overflow' alert.,MUST NOT,"length: The length (in bytes) of the following TLSPlaintext.fragment. The length MUST NOT exceed 2^14 bytes. An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.","legacy_record_version: MUST be set to 0x0303 for all records generated by a TLS 1.3 implementation other than an initial ClientHello (i.e., one not generated after a HelloRetryRequest), where it MAY also be 0x0301 for compatibility purposes. This field is deprecated and MUST be ignored for all purposes. Previous versions of TLS would use other values in this field under some circumstances.",fragment: The data being transmitted. This value is transparent and is treated as an independent block to be dealt with by the higher-level protocol specified by the type field.,5.1,Record Layer,2,10,2,MUST
"An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.","An endpoint receives a record that exceeds the specified length (in bytes) of the TLSPlaintext.fragment, which must not exceed 2^14 bytes.","The endpoint MUST terminate the connection with a ""record_overflow"" alert.",MUST,"length: The length (in bytes) of the following TLSPlaintext.fragment. The length MUST NOT exceed 2^14 bytes. An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.","legacy_record_version: MUST be set to 0x0303 for all records generated by a TLS 1.3 implementation other than an initial ClientHello (i.e., one not generated after a HelloRetryRequest), where it MAY also be 0x0301 for compatibility purposes. This field is deprecated and MUST be ignored for all purposes. Previous versions of TLS would use other values in this field under some circumstances.",fragment: The data being transmitted. This value is transparent and is treated as an independent block to be dealt with by the higher-level protocol specified by the type field.,5.1,Record Layer,2,10,3,MUST
"In order to maximize backward compatibility, a record containing an initial ClientHello SHOULD have version 0x0301 (reflecting TLS 1.0) and a record containing a second ClientHello or a ServerHello MUST have version 0x0303 (reflecting TLS 1.2).","A record containing an initial ClientHello,A record containing a second ClientHello or a ServerHello","For a record containing an initial ClientHello, the version SHOULD be set to 0x0301 (reflecting TLS 1.0),For a record containing a second ClientHello or a ServerHello, the version MUST be set to 0x0303 (reflecting TLS 1.2)","MUST, SHOULD","This document describes TLS 1.3, which uses the version 0x0304. This version value is historical, deriving from the use of 0x0301 for TLS 1.0 and 0x0300 for SSL 3.0. In order to maximize backward compatibility, a record containing an initial ClientHello SHOULD have version 0x0301 (reflecting TLS 1.0) and a record containing a second ClientHello or a ServerHello MUST have version 0x0303 (reflecting TLS 1.2). When negotiating prior versions of TLS, endpoints follow the procedure and requirements provided in Appendix D.",fragment: The data being transmitted. This value is transparent and is treated as an independent block to be dealt with by the higher-level protocol specified by the type field.,"When record protection has not yet been engaged, TLSPlaintext structures are written directly onto the wire. Once record protection has started, TLSPlaintext records are protected and sent as described in the following section. Note that Application Data records MUST NOT be written to the wire unprotected (see Section 2 for details).",5.1,Record Layer,2,12,3,MUST
Note that Application Data records MUST NOT be written to the wire unprotected (see Section 2 for details).,When Application Data records are sent over the wire.,Application Data records MUST NOT be written to the wire unprotected.,MUST NOT,"When record protection has not yet been engaged, TLSPlaintext structures are written directly onto the wire. Once record protection has started, TLSPlaintext records are protected and sent as described in the following section. Note that Application Data records MUST NOT be written to the wire unprotected (see Section 2 for details).","This document describes TLS 1.3, which uses the version 0x0304. This version value is historical, deriving from the use of 0x0301 for TLS 1.0 and 0x0300 for SSL 3.0. In order to maximize backward compatibility, a record containing an initial ClientHello SHOULD have version 0x0301 (reflecting TLS 1.0) and a record containing a second ClientHello or a ServerHello MUST have version 0x0303 (reflecting TLS 1.2). When negotiating prior versions of TLS, endpoints follow the procedure and requirements provided in Appendix D.",,5.1,Record Layer,2,13,3,MUST
The length MUST NOT exceed 2^14 + 256 bytes.,A TLS record is received where the length exceeds 2^14 + 256 bytes.,Terminate the connection and generate a 'record_overflow' alert.,MUST NOT,"length: The length (in bytes) of the following TLSCiphertext.encrypted_record, which is the sum of the lengths of the content and the padding, plus one for the inner content type, plus any expansion added by the AEAD algorithm. The length MUST NOT exceed 2^14 + 256 bytes. An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.","legacy_record_version: The legacy_record_version field is always 0x0303. TLS 1.3 TLSCiphertexts are not generated until after TLS 1.3 has been negotiated, so there are no historical compatibility concerns where other values might be received. Note that the handshake protocol, including the ClientHello and ServerHello messages, authenticates the protocol version, so this value is redundant.",encrypted_record: The AEAD-encrypted form of the serialized TLSInnerPlaintext structure.,5.2,Record Payload Protection,2,7,2,MUST
"An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.",An endpoint receives a record whose length exceeds the allowed maximum (2^14 + 256 bytes),Terminate the connection with a 'record_overflow' alert,MUST,"length: The length (in bytes) of the following TLSCiphertext.encrypted_record, which is the sum of the lengths of the content and the padding, plus one for the inner content type, plus any expansion added by the AEAD algorithm. The length MUST NOT exceed 2^14 + 256 bytes. An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.","legacy_record_version: The legacy_record_version field is always 0x0303. TLS 1.3 TLSCiphertexts are not generated until after TLS 1.3 has been negotiated, so there are no historical compatibility concerns where other values might be received. Note that the handshake protocol, including the ClientHello and ServerHello messages, authenticates the protocol version, so this value is redundant.",encrypted_record: The AEAD-encrypted form of the serialized TLSInnerPlaintext structure.,5.2,Record Payload Protection,2,7,3,MUST
"If the decryption fails, the receiver MUST terminate the connection with a ""bad_record_mac"" alert.",Decryption fails,"Terminate the connection with a ""bad_record_mac"" alert",MUST,"If the decryption fails, the receiver MUST terminate the connection with a ""bad_record_mac"" alert.","In order to decrypt and verify, the cipher takes as input the key, nonce, additional data, and the AEADEncrypted value. The output is either the plaintext or an error indicating that the decryption failed. There is no separate integrity check. Symbolically,","An AEAD algorithm used in TLS 1.3 MUST NOT produce an expansion greater than 255 octets. An endpoint that receives a record from its peer with TLSCiphertext.length larger than 2^14 + 256 octets MUST terminate the connection with a ""record_overflow"" alert. This limit is derived from the maximum TLSInnerPlaintext length of 2^14 octets + 1 octet for ContentType + the maximum AEAD expansion of 255 octets.",5.2,Record Payload Protection,2,16,1,MUST
An AEAD algorithm used in TLS 1.3 MUST NOT produce an expansion greater than 255 octets.,When an AEAD algorithm is used in TLS 1.3,The AEAD algorithm MUST NOT produce an expansion greater than 255 octets,MUST NOT,"An AEAD algorithm used in TLS 1.3 MUST NOT produce an expansion greater than 255 octets. An endpoint that receives a record from its peer with TLSCiphertext.length larger than 2^14 + 256 octets MUST terminate the connection with a ""record_overflow"" alert. This limit is derived from the maximum TLSInnerPlaintext length of 2^14 octets + 1 octet for ContentType + the maximum AEAD expansion of 255 octets.","If the decryption fails, the receiver MUST terminate the connection with a ""bad_record_mac"" alert.",,5.2,Record Payload Protection,2,17,1,MUST
"An endpoint that receives a record from its peer with TLSCiphertext.length larger than 2^14 + 256 octets MUST terminate the connection with a ""record_overflow"" alert.",The endpoint receives a record from its peer with TLSCiphertext.length larger than 2^14 + 256 octets.,Terminate the connection with a 'record_overflow' alert.,MUST,"An AEAD algorithm used in TLS 1.3 MUST NOT produce an expansion greater than 255 octets. An endpoint that receives a record from its peer with TLSCiphertext.length larger than 2^14 + 256 octets MUST terminate the connection with a ""record_overflow"" alert. This limit is derived from the maximum TLSInnerPlaintext length of 2^14 octets + 1 octet for ContentType + the maximum AEAD expansion of 255 octets.","If the decryption fails, the receiver MUST terminate the connection with a ""bad_record_mac"" alert.",,5.2,Record Payload Protection,2,17,2,MUST
Each sequence number is set to zero at the beginning of a connection and whenever the key is changed; the first record transmitted under a particular traffic key MUST use sequence number 0.,"At the beginning of a connection,Whenever the key is changed","The first record transmitted under a particular traffic key MUST use sequence number 0 (i.e., the sequence number is set to zero)",MUST,A 64-bit sequence number is maintained separately for reading and writing records. The appropriate sequence number is incremented by one after reading or writing each record. Each sequence number is set to zero at the beginning of a connection and whenever the key is changed; the first record transmitted under a particular traffic key MUST use sequence number 0.,,"Because the size of sequence numbers is 64-bit, they should not wrap. If a TLS implementation would need to wrap a sequence number, it MUST either rekey (Section 4.6.3) or terminate the connection.",5.3,Per-Record Nonce,2,1,3,MUST
"If a TLS implementation would need to wrap a sequence number, it MUST either rekey (Section 4.6.3) or terminate the connection.","When a TLS implementation is about to wrap a sequence number (i.e., when the sequence number reaches its maximum value and would roll over)",The TLS implementation MUST either rekey (as specified in Section 4.6.3) or terminate the connection,MUST,"Because the size of sequence numbers is 64-bit, they should not wrap. If a TLS implementation would need to wrap a sequence number, it MUST either rekey (Section 4.6.3) or terminate the connection.",A 64-bit sequence number is maintained separately for reading and writing records. The appropriate sequence number is incremented by one after reading or writing each record. Each sequence number is set to zero at the beginning of a connection and whenever the key is changed; the first record transmitted under a particular traffic key MUST use sequence number 0.,"Each AEAD algorithm will specify a range of possible lengths for the per-record nonce, from N_MIN bytes to N_MAX bytes of input [RFC5116]. The length of the TLS per-record nonce (iv_length) is set to the larger of 8 bytes and N_MIN for the AEAD algorithm (see [RFC5116], Section 4). An AEAD algorithm where N_MAX is less than 8 bytes MUST NOT be used with TLS. The per-record nonce for the AEAD construction is formed as follows: 1. The 64-bit record sequence number is encoded in network byte order and padded to the left with zeros to iv_length. 2. The padded sequence number is XORed with either the static client_write_iv or server_write_iv (depending on the role).",5.3,Per-Record Nonce,2,2,2,MUST
An AEAD algorithm where N_MAX is less than 8 bytes MUST NOT be used with TLS.,An AEAD algorithm where N_MAX is less than 8 bytes,MUST NOT be used with TLS,MUST NOT,"Each AEAD algorithm will specify a range of possible lengths for the per-record nonce, from N_MIN bytes to N_MAX bytes of input [RFC5116]. The length of the TLS per-record nonce (iv_length) is set to the larger of 8 bytes and N_MIN for the AEAD algorithm (see [RFC5116], Section 4). An AEAD algorithm where N_MAX is less than 8 bytes MUST NOT be used with TLS. The per-record nonce for the AEAD construction is formed as follows: 1. The 64-bit record sequence number is encoded in network byte order and padded to the left with zeros to iv_length. 2. The padded sequence number is XORed with either the static client_write_iv or server_write_iv (depending on the role).","Because the size of sequence numbers is 64-bit, they should not wrap. If a TLS implementation would need to wrap a sequence number, it MUST either rekey (Section 4.6.3) or terminate the connection.",The resulting quantity (of length iv_length) is used as the per-record nonce.,5.3,Per-Record Nonce,2,3,3,MUST
"When generating a TLSCiphertext record, implementations MAY choose to pad.",When generating a TLSCiphertext record.,Implementations MAY choose to pad the TLSCiphertext record.,MAY,"When generating a TLSCiphertext record, implementations MAY choose to pad. An unpadded record is just a record with a padding length of zero. Padding is a string of zero-valued bytes appended to the ContentType field before encryption. Implementations MUST set the padding octets to all zeros before encrypting.",All encrypted TLS records can be padded to inflate the size of the TLSCiphertext. This allows the sender to hide the size of the traffic from an observer.,"Application Data records may contain a zero-length TLSInnerPlaintext.content if the sender desires. This permits generation of plausibly sized cover traffic in contexts where the presence or absence of activity may be sensitive. Implementations MUST NOT send Handshake and Alert records that have a zero-length TLSInnerPlaintext.content; if such a message is received, the receiving implementation MUST terminate the connection with an ""unexpected_message"" alert.",5.4,Record Padding,2,2,1,MAY
Implementations MUST set the padding octets to all zeros before encrypting.,"Immediately prior to performing encryption, i.e., when generating a TLSCiphertext record where padding is applied.",Set all padding octets to zero before encryption.,MUST,"When generating a TLSCiphertext record, implementations MAY choose to pad. An unpadded record is just a record with a padding length of zero. Padding is a string of zero-valued bytes appended to the ContentType field before encryption. Implementations MUST set the padding octets to all zeros before encrypting.",All encrypted TLS records can be padded to inflate the size of the TLSCiphertext. This allows the sender to hide the size of the traffic from an observer.,"Application Data records may contain a zero-length TLSInnerPlaintext.content if the sender desires. This permits generation of plausibly sized cover traffic in contexts where the presence or absence of activity may be sensitive. Implementations MUST NOT send Handshake and Alert records that have a zero-length TLSInnerPlaintext.content; if such a message is received, the receiving implementation MUST terminate the connection with an ""unexpected_message"" alert.",5.4,Record Padding,2,2,4,MUST
"Implementations MUST NOT send Handshake and Alert records that have a zero-length TLSInnerPlaintext.content; if such a message is received, the receiving implementation MUST terminate the connection with an ""unexpected_message"" alert.",If a Handshake or Alert record with a zero-length TLSInnerPlaintext.content is received,Terminate the connection with an 'unexpected_message' alert,MUST NOT,"Application Data records may contain a zero-length TLSInnerPlaintext.content if the sender desires. This permits generation of plausibly sized cover traffic in contexts where the presence or absence of activity may be sensitive. Implementations MUST NOT send Handshake and Alert records that have a zero-length TLSInnerPlaintext.content; if such a message is received, the receiving implementation MUST terminate the connection with an ""unexpected_message"" alert.","When generating a TLSCiphertext record, implementations MAY choose to pad. An unpadded record is just a record with a padding length of zero. Padding is a string of zero-valued bytes appended to the ContentType field before encryption. Implementations MUST set the padding octets to all zeros before encrypting.","The padding sent is automatically verified by the record protection mechanism; upon successful decryption of a TLSCiphertext.encrypted_record, the receiving implementation scans the field from the end toward the beginning until it finds a non-zero octet. This non-zero octet is the content type of the message. This padding scheme was selected because it allows padding of any encrypted TLS record by an arbitrary size (from zero up to TLS record size limits) without introducing new content types. The design also enforces all-zero padding octets, which allows for quick detection of padding errors.",5.4,Record Padding,2,3,3,MUST
Implementations MUST limit their scanning to the cleartext returned from the AEAD decryption.,"When scanning the cleartext returned from the AEAD decryption, no non‑zero octet is found","Implementations MUST limit their scanning exclusively to the cleartext returned from the AEAD decryption,If no non‑zero octet is found in that cleartext, the connection MUST be terminated with an 'unexpected_message' alert",MUST,"Implementations MUST limit their scanning to the cleartext returned from the AEAD decryption. If a receiving implementation does not find a non-zero octet in the cleartext, it MUST terminate the connection with an ""unexpected_message"" alert.","The padding sent is automatically verified by the record protection mechanism; upon successful decryption of a TLSCiphertext.encrypted_record, the receiving implementation scans the field from the end toward the beginning until it finds a non-zero octet. This non-zero octet is the content type of the message. This padding scheme was selected because it allows padding of any encrypted TLS record by an arbitrary size (from zero up to TLS record size limits) without introducing new content types. The design also enforces all-zero padding octets, which allows for quick detection of padding errors.","The presence of padding does not change the overall record size limitations: the full encoded TLSInnerPlaintext MUST NOT exceed 2^14 + 1 octets. If the maximum fragment length is reduced --as, for example, by the record_size_limit extension from [RFC8449] --then the reduced limit applies to the full plaintext, including the content type and padding.",5.4,Record Padding,2,5,1,MUST
"If a receiving implementation does not find a non-zero octet in the cleartext, it MUST terminate the connection with an ""unexpected_message"" alert.",A receiving implementation does not find a non-zero octet in the cleartext.,Terminate the connection with an 'unexpected_message' alert.,MUST,"Implementations MUST limit their scanning to the cleartext returned from the AEAD decryption. If a receiving implementation does not find a non-zero octet in the cleartext, it MUST terminate the connection with an ""unexpected_message"" alert.","The padding sent is automatically verified by the record protection mechanism; upon successful decryption of a TLSCiphertext.encrypted_record, the receiving implementation scans the field from the end toward the beginning until it finds a non-zero octet. This non-zero octet is the content type of the message. This padding scheme was selected because it allows padding of any encrypted TLS record by an arbitrary size (from zero up to TLS record size limits) without introducing new content types. The design also enforces all-zero padding octets, which allows for quick detection of padding errors.","The presence of padding does not change the overall record size limitations: the full encoded TLSInnerPlaintext MUST NOT exceed 2^14 + 1 octets. If the maximum fragment length is reduced --as, for example, by the record_size_limit extension from [RFC8449] --then the reduced limit applies to the full plaintext, including the content type and padding.",5.4,Record Padding,2,5,2,MUST
The presence of padding does not change the overall record size limitations: the full encoded TLSInnerPlaintext MUST NOT exceed 2^14 + 1 octets.,The record includes padding (i.e. when padding is present),"The full encoded TLSInnerPlaintext MUST NOT exceed 2^14 + 1 octets, regardless of the presence of padding",MUST NOT,"The presence of padding does not change the overall record size limitations: the full encoded TLSInnerPlaintext MUST NOT exceed 2^14 + 1 octets. If the maximum fragment length is reduced --as, for example, by the record_size_limit extension from [RFC8449] --then the reduced limit applies to the full plaintext, including the content type and padding.","Implementations MUST limit their scanning to the cleartext returned from the AEAD decryption. If a receiving implementation does not find a non-zero octet in the cleartext, it MUST terminate the connection with an ""unexpected_message"" alert.","Selecting a padding policy that suggests when and how much to pad is a complex topic and is beyond the scope of this specification. If the application-layer protocol on top of TLS has its own padding, it may be preferable to pad Application Data TLS records within the application layer. Padding for encrypted Handshake or Alert records must still be handled at the TLS layer, though. Later documents may define padding selection algorithms or define a padding policy request mechanism through TLS extensions or some other means.",5.4,Record Padding,2,6,1,MUST
Implementations SHOULD do a key update as described in Section 4.6.3 prior to reaching these limits.,When the amount of plaintext encrypted under a given set of keys is approaching the cryptographic limits (as described in [AEAD-LIMITS]).,Implement a key update as described in Section 4.6.3.,SHOULD,There are cryptographic limits on the amount of plaintext which can be safely encrypted under a given set of keys. [AEAD-LIMITS] provides an analysis of these limits under the assumption that the underlying primitive (AES or ChaCha20) has no weaknesses. Implementations SHOULD do a key update as described in Section 4.6.3 prior to reaching these limits.,,"For AES-GCM, up to 2^24.5 full-size records (about 24 million) may be encrypted on a given connection while keeping a safety margin of approximately 2^-57 for Authenticated Encryption (AE) security. For ChaCha20/Poly1305, the record sequence number would wrap before the safety limit is reached.",5.5,Limits on Key Usage,2,1,3,SHOULD
"Upon receiving such an alert, the TLS implementation SHOULD indicate end-of-data to the application.",Receiving the alert (close_notify) indicating orderly closure of one direction of the connection,The TLS implementation SHOULD indicate end-of-data to the application,SHOULD,"Alert messages convey a description of the alert and a legacy field that conveyed the severity level of the message in previous versions of TLS. Alerts are divided into two classes: closure alerts and error alerts. In TLS 1.3, the severity is implicit in the type of alert being sent, and the ""level"" field can safely be ignored. The ""close_notify"" alert is used to indicate orderly closure of one direction of the connection. Upon receiving such an alert, the TLS implementation SHOULD indicate end-of-data to the application.","TLS provides an Alert content type to indicate closure information and errors. Like other messages, alert messages are encrypted as specified by the current connection state.","Error alerts indicate abortive closure of the connection (see Section 6.2). Upon receiving an error alert, the TLS implementation SHOULD indicate an error to the application and MUST NOT allow any further data to be sent or received on the connection. Servers and clients MUST forget the secret values and keys established in failed connections, with the exception of the PSKs associated with session tickets, which SHOULD be discarded if possible.",6,Alert Protocol,1,2,5,SHOULD
"Upon receiving an error alert, the TLS implementation SHOULD indicate an error to the application and MUST NOT allow any further data to be sent or received on the connection.",Upon receiving an error alert,"Indicate an error to the application,Do not allow any further data to be sent or received on the connection","MUST NOT, SHOULD","Error alerts indicate abortive closure of the connection (see Section 6.2). Upon receiving an error alert, the TLS implementation SHOULD indicate an error to the application and MUST NOT allow any further data to be sent or received on the connection. Servers and clients MUST forget the secret values and keys established in failed connections, with the exception of the PSKs associated with session tickets, which SHOULD be discarded if possible.","Alert messages convey a description of the alert and a legacy field that conveyed the severity level of the message in previous versions of TLS. Alerts are divided into two classes: closure alerts and error alerts. In TLS 1.3, the severity is implicit in the type of alert being sent, and the ""level"" field can safely be ignored. The ""close_notify"" alert is used to indicate orderly closure of one direction of the connection. Upon receiving such an alert, the TLS implementation SHOULD indicate end-of-data to the application.",All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message. Unknown Alert types MUST be treated as error alerts.,6,Alert Protocol,1,3,2,MUST
"Servers and clients MUST forget the secret values and keys established in failed connections, with the exception of the PSKs associated with session tickets, which SHOULD be discarded if possible.",Failed connections,"Servers and clients MUST forget the secret values and keys established in those failed connections, with the exception that the PSKs associated with session tickets SHOULD be discarded if possible.","MUST, SHOULD","Error alerts indicate abortive closure of the connection (see Section 6.2). Upon receiving an error alert, the TLS implementation SHOULD indicate an error to the application and MUST NOT allow any further data to be sent or received on the connection. Servers and clients MUST forget the secret values and keys established in failed connections, with the exception of the PSKs associated with session tickets, which SHOULD be discarded if possible.","Alert messages convey a description of the alert and a legacy field that conveyed the severity level of the message in previous versions of TLS. Alerts are divided into two classes: closure alerts and error alerts. In TLS 1.3, the severity is implicit in the type of alert being sent, and the ""level"" field can safely be ignored. The ""close_notify"" alert is used to indicate orderly closure of one direction of the connection. Upon receiving such an alert, the TLS implementation SHOULD indicate end-of-data to the application.",All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message. Unknown Alert types MUST be treated as error alerts.,6,Alert Protocol,1,3,3,MUST
All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,"Alerts listed in Section 6.2 are subject to the rule,Unknown Alert types are subject to the rule","Alerts MUST be sent with AlertLevel=fatal,Alerts MUST be treated as error alerts when received regardless of the AlertLevel in the message",MUST,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message. Unknown Alert types MUST be treated as error alerts.,"Error alerts indicate abortive closure of the connection (see Section 6.2). Upon receiving an error alert, the TLS implementation SHOULD indicate an error to the application and MUST NOT allow any further data to be sent or received on the connection. Servers and clients MUST forget the secret values and keys established in failed connections, with the exception of the PSKs associated with session tickets, which SHOULD be discarded if possible.","Note: TLS defines two generic alerts (see Section 6) to use upon failure to parse a message. Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert. Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",6,Alert Protocol,1,4,1,MUST
Unknown Alert types MUST be treated as error alerts.,When an alert with an unknown alert type is received,Treat the unknown alert as an error alert,MUST,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message. Unknown Alert types MUST be treated as error alerts.,"Error alerts indicate abortive closure of the connection (see Section 6.2). Upon receiving an error alert, the TLS implementation SHOULD indicate an error to the application and MUST NOT allow any further data to be sent or received on the connection. Servers and clients MUST forget the secret values and keys established in failed connections, with the exception of the PSKs associated with session tickets, which SHOULD be discarded if possible.","Note: TLS defines two generic alerts (see Section 6) to use upon failure to parse a message. Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert. Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",6,Alert Protocol,1,4,2,MUST
"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert","Peer receives a message that cannot be parsed according to the syntax (e.g., having a length extending beyond the message boundary or containing an out-of-range length)",Terminate the connection with a 'decode_error' alert,MUST,"Note: TLS defines two generic alerts (see Section 6) to use upon failure to parse a message. Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert. Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message. Unknown Alert types MUST be treated as error alerts.,,6,Alert Protocol,1,5,2,MUST
"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.","Peer receives a message that is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum)",Terminate the connection with an 'illegal_parameter' alert,MUST,"Note: TLS defines two generic alerts (see Section 6) to use upon failure to parse a message. Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert. Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message. Unknown Alert types MUST be treated as error alerts.,,6,Alert Protocol,1,5,3,MUST
Any data received after a closure alert has been received MUST be ignored.,Any data that is received after a closure alert has been received,The received data MUST be ignored,MUST,close_notify: This alert notifies the recipient that the sender will not send any more messages on this connection. Any data received after a closure alert has been received MUST be ignored.,The client and the server must share knowledge that the connection is ending in order to avoid a truncation attack.,"user_canceled: This alert notifies the recipient that the sender is canceling the handshake for some reason unrelated to a protocol failure. If a user cancels an operation after the handshake is complete, just closing the connection by sending a ""close_notify"" is more appropriate. This alert SHOULD be followed by a ""close_notify"". This alert generally has AlertLevel=warning.",6.1,Closure Alerts,2,2,2,MUST
"This alert SHOULD be followed by a ""close_notify"".",When a user_canceled alert is sent to notify that the sender is canceling the handshake (for reasons unrelated to a protocol failure),The alert SHOULD be followed by a close_notify alert to indicate the sender will not send any more messages on the connection,SHOULD,"user_canceled: This alert notifies the recipient that the sender is canceling the handshake for some reason unrelated to a protocol failure. If a user cancels an operation after the handshake is complete, just closing the connection by sending a ""close_notify"" is more appropriate. This alert SHOULD be followed by a ""close_notify"". This alert generally has AlertLevel=warning.",close_notify: This alert notifies the recipient that the sender will not send any more messages on this connection. Any data received after a closure alert has been received MUST be ignored.,"Either party MAY initiate a close of its write side of the connection by sending a ""close_notify"" alert. Any data received after a closure alert has been received MUST be ignored. If a transport-level close is received prior to a ""close_notify"", the receiver cannot know that all the data that was sent has been received.",6.1,Closure Alerts,2,3,3,SHOULD
"Either party MAY initiate a close of its write side of the connection by sending a ""close_notify"" alert.","A party decides to initiate a close of its write side of the connection (i.e., when it opts to begin the closing process)",The party sends a 'close_notify' alert to initiate the closure of its write side of the connection,MAY,"Either party MAY initiate a close of its write side of the connection by sending a ""close_notify"" alert. Any data received after a closure alert has been received MUST be ignored. If a transport-level close is received prior to a ""close_notify"", the receiver cannot know that all the data that was sent has been received.","user_canceled: This alert notifies the recipient that the sender is canceling the handshake for some reason unrelated to a protocol failure. If a user cancels an operation after the handshake is complete, just closing the connection by sending a ""close_notify"" is more appropriate. This alert SHOULD be followed by a ""close_notify"". This alert generally has AlertLevel=warning.","Each party MUST send a ""close_notify"" alert before closing its write side of the connection, unless it has already sent some error alert. This does not have any effect on its read side of the connection. Note that this is a change from versions of TLS prior to TLS 1.3 in which implementations were required to react to a ""close_notify"" by discarding pending writes and sending an immediate ""close_notify"" alert of their own. That previous requirement could cause truncation in the read side. Both parties need not wait to receive a ""close_notify"" alert before closing their read side of the connection, though doing so would introduce the possibility of truncation.",6.1,Closure Alerts,2,4,1,MAY
Any data received after a closure alert has been received MUST be ignored.,Data received after a closure alert has been received,The data MUST be ignored,MUST,"Either party MAY initiate a close of its write side of the connection by sending a ""close_notify"" alert. Any data received after a closure alert has been received MUST be ignored. If a transport-level close is received prior to a ""close_notify"", the receiver cannot know that all the data that was sent has been received.","user_canceled: This alert notifies the recipient that the sender is canceling the handshake for some reason unrelated to a protocol failure. If a user cancels an operation after the handshake is complete, just closing the connection by sending a ""close_notify"" is more appropriate. This alert SHOULD be followed by a ""close_notify"". This alert generally has AlertLevel=warning.","Each party MUST send a ""close_notify"" alert before closing its write side of the connection, unless it has already sent some error alert. This does not have any effect on its read side of the connection. Note that this is a change from versions of TLS prior to TLS 1.3 in which implementations were required to react to a ""close_notify"" by discarding pending writes and sending an immediate ""close_notify"" alert of their own. That previous requirement could cause truncation in the read side. Both parties need not wait to receive a ""close_notify"" alert before closing their read side of the connection, though doing so would introduce the possibility of truncation.",6.1,Closure Alerts,2,4,2,MUST
"Each party MUST send a ""close_notify"" alert before closing its write side of the connection, unless it has already sent some error alert",A party is about to close its write side of the connection and has not already sent an error alert,The party MUST send a 'close_notify' alert before closing its write side of the connection,MUST,"Each party MUST send a ""close_notify"" alert before closing its write side of the connection, unless it has already sent some error alert. This does not have any effect on its read side of the connection. Note that this is a change from versions of TLS prior to TLS 1.3 in which implementations were required to react to a ""close_notify"" by discarding pending writes and sending an immediate ""close_notify"" alert of their own. That previous requirement could cause truncation in the read side. Both parties need not wait to receive a ""close_notify"" alert before closing their read side of the connection, though doing so would introduce the possibility of truncation.","Either party MAY initiate a close of its write side of the connection by sending a ""close_notify"" alert. Any data received after a closure alert has been received MUST be ignored. If a transport-level close is received prior to a ""close_notify"", the receiver cannot know that all the data that was sent has been received.","If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation MUST receive a ""close_notify"" alert before indicating end-of-data to the application layer. No part of this standard should be taken to dictate the manner in which a usage profile for TLS manages its data transport, including when connections are opened or closed.",6.1,Closure Alerts,2,5,1,MUST
"If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation MUST receive a ""close_notify"" alert before indicating end-of-data to the application layer.",When the application protocol using TLS allows that any data may be carried over the underlying transport after the TLS connection is closed.,The TLS implementation MUST receive a 'close_notify' alert before indicating end-of-data to the application layer.,MUST,"If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation MUST receive a ""close_notify"" alert before indicating end-of-data to the application layer. No part of this standard should be taken to dictate the manner in which a usage profile for TLS manages its data transport, including when connections are opened or closed.","Each party MUST send a ""close_notify"" alert before closing its write side of the connection, unless it has already sent some error alert. This does not have any effect on its read side of the connection. Note that this is a change from versions of TLS prior to TLS 1.3 in which implementations were required to react to a ""close_notify"" by discarding pending writes and sending an immediate ""close_notify"" alert of their own. That previous requirement could cause truncation in the read side. Both parties need not wait to receive a ""close_notify"" alert before closing their read side of the connection, though doing so would introduce the possibility of truncation.",Note: It is assumed that closing the write side of a connection reliably delivers pending data before destroying the transport.,6.1,Closure Alerts,2,6,1,MUST
"Upon transmission or receipt of a fatal alert message, both parties MUST immediately close the connection.","Upon transmission of a fatal alert message,Upon receipt of a fatal alert message",Both parties MUST immediately close the connection,MUST,"Error handling in TLS is very simple. When an error is detected, the detecting party sends a message to its peer. Upon transmission or receipt of a fatal alert message, both parties MUST immediately close the connection.",,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data. In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below. The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert. All alerts defined below in this section, as well as all unknown alerts, are universally considered fatal as of TLS 1.3 (see Section 6). The implementation SHOULD provide a way to facilitate logging the sending and receiving of alerts.",6.2,Error Alerts,2,1,3,MUST
"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data.",An implementation encounters a fatal error condition.,"The implementation SHOULD send an appropriate fatal alert.,The implementation MUST close the connection without sending or receiving any additional data.","MUST, SHOULD","Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data. In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below. The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert. All alerts defined below in this section, as well as all unknown alerts, are universally considered fatal as of TLS 1.3 (see Section 6). The implementation SHOULD provide a way to facilitate logging the sending and receiving of alerts.","Error handling in TLS is very simple. When an error is detected, the detecting party sends a message to its peer. Upon transmission or receipt of a fatal alert message, both parties MUST immediately close the connection.",The following error alerts are defined:,6.2,Error Alerts,2,2,1,MUST
"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",When the phrases 'terminate the connection' and 'abort the handshake' are used without specifying an alert,The implementation SHOULD send the alert indicated by the descriptions below,SHOULD,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data. In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below. The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert. All alerts defined below in this section, as well as all unknown alerts, are universally considered fatal as of TLS 1.3 (see Section 6). The implementation SHOULD provide a way to facilitate logging the sending and receiving of alerts.","Error handling in TLS is very simple. When an error is detected, the detecting party sends a message to its peer. Upon transmission or receipt of a fatal alert message, both parties MUST immediately close the connection.",The following error alerts are defined:,6.2,Error Alerts,2,2,2,SHOULD
"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",When the implementation sends any alert in response to the directive to 'terminate the connection with an X alert' or 'abort the handshake with an X alert'.,The implementation MUST send alert X if it sends any alert.,MUST,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data. In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below. The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert. All alerts defined below in this section, as well as all unknown alerts, are universally considered fatal as of TLS 1.3 (see Section 6). The implementation SHOULD provide a way to facilitate logging the sending and receiving of alerts.","Error handling in TLS is very simple. When an error is detected, the detecting party sends a message to its peer. Upon transmission or receipt of a fatal alert message, both parties MUST immediately close the connection.",The following error alerts are defined:,6.2,Error Alerts,2,2,3,MUST
The implementation SHOULD provide a way to facilitate logging the sending and receiving of alerts.,When alerts are sent or received.,The implementation SHOULD provide a way to facilitate logging the sending and receiving of alerts.,SHOULD,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data. In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below. The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert. All alerts defined below in this section, as well as all unknown alerts, are universally considered fatal as of TLS 1.3 (see Section 6). The implementation SHOULD provide a way to facilitate logging the sending and receiving of alerts.","Error handling in TLS is very simple. When an error is detected, the detecting party sends a message to its peer. Upon transmission or receipt of a fatal alert message, both parties MUST immediately close the connection.",The following error alerts are defined:,6.2,Error Alerts,2,2,5,SHOULD
"Sending this alert is OPTIONAL; servers MAY instead choose to send a ""decrypt_error"" alert to merely indicate an invalid PSK identity.",When PSK key establishment is desired but no acceptable PSK identity is provided by the client.,Servers MAY choose to send a 'decrypt_error' alert to merely indicate an invalid PSK identity in lieu of sending the unknown_psk_identity alert.,"MAY, OPTIONAL","unknown_psk_identity: Sent by servers when PSK key establishment is desired but no acceptable PSK identity is provided by the client. Sending this alert is OPTIONAL; servers MAY instead choose to send a ""decrypt_error"" alert to merely indicate an invalid PSK identity.","bad_certificate_status_response: Sent by clients when an invalid or unacceptable OCSP response is provided by the server via the ""status_request"" extension (see [RFC6066]).",certificate_required: Sent by servers when a client certificate is desired but none was provided by the client.,6.2,Error Alerts,2,26,2,MAY
"Once all the values which are to be derived from a given secret have been computed, that secret SHOULD be erased.",All values which are to be derived from a given secret have been computed.,Erase the given secret (it SHOULD be erased).,SHOULD,"Once all the values which are to be derived from a given secret have been computed, that secret SHOULD be erased.","There are multiple potential Early Secret values, depending on which PSK the server ultimately selects. The client will need to compute one for each potential PSK; if no PSK is selected, it will then need to compute the Early Secret corresponding to the zero PSK.",,7.1,Key Schedule,2,15,1,SHOULD
"Once client_/server_application_traffic_secret_N+1 and its associated traffic keys have been computed, implementations SHOULD delete client_/server_application_traffic_secret_N and its associated traffic keys.",client_/server_application_traffic_secret_N+1 and its associated traffic keys have been computed,delete client_/server_application_traffic_secret_N and its associated traffic keys,SHOULD,"Once client_/server_application_traffic_secret_N+1 and its associated traffic keys have been computed, implementations SHOULD delete client_/server_application_traffic_secret_N and its associated traffic keys.",The next-generation application_traffic_secret is computed as:,,7.2,Updating Traffic Secrets,2,3,1,SHOULD
"Note that this octet string (""Z"" in IEEE 1363 terminology) as output by FE2OSP (the Field Element to Octet String Conversion Primitive) has constant length for any given field; leading zeros found in this octet string MUST NOT be truncated.",An octet string produced by FE2OSP with constant length for the given field.,Leading zeros found in this octet string MUST NOT be truncated.,MUST NOT,"For secp256r1, secp384r1, and secp521r1, ECDH calculations (including parameter and key generation as well as the shared secret calculation) are performed according to [IEEE1363] using the ECKAS-DH1 scheme with the identity map as the key derivation function (KDF), so that the shared secret is the x-coordinate of the ECDH shared secret elliptic curve point represented as an octet string. Note that this octet string (""Z"" in IEEE 1363 terminology) as output by FE2OSP (the Field Element to Octet String Conversion Primitive) has constant length for any given field; leading zeros found in this octet string MUST NOT be truncated.",,(Note that this use of the identity KDF is a technicality. The complete picture is that ECDH is employed with a non-trivial KDF because TLS does not directly use this secret for anything other than for computing other secrets.),7.4.2,Elliptic Curve Diffie-Hellman,3,1,2,MUST
"For these curves, implementations SHOULD use the approach specified in [RFC7748] to calculate the Diffie-Hellman shared secret","When operating on the specified elliptic curves,When the computed Diffie-Hellman shared secret results in the all-zero value,When an alternative implementation of these elliptic curves is used","Use the approach specified in RFC7748 to calculate the Diffie-Hellman shared secret,Check if the computed Diffie-Hellman shared secret is the all-zero value and abort if so, as described in Section 6 of RFC7748,Perform the additional checks specified in Section 7 of RFC7748 when using an alternative implementation",SHOULD,"For these curves, implementations SHOULD use the approach specified in [RFC7748] to calculate the Diffie-Hellman shared secret. Implementations MUST check whether the computed Diffie-Hellman shared secret is the all-zero value and abort if so, as described in Section 6 of [RFC7748]. If implementors use an alternative implementation of these elliptic curves, they SHOULD perform the additional checks specified in Section 7 of [RFC7748].","-The ECDH shared secret is the result of applying the ECDH scalar multiplication function to the secret key (into scalar input) and the peer's public key (into u-coordinate point input). The output is used raw, with no processing.",,7.4.2,Elliptic Curve Diffie-Hellman,3,6,1,SHOULD
"Implementations MUST check whether the computed Diffie-Hellman shared secret is the all-zero value and abort if so, as described in Section 6 of [RFC7748].",The computed Diffie-Hellman shared secret is the all-zero value.,"Implementations MUST check whether the computed Diffie-Hellman shared secret is the all-zero value and abort the operation if that condition is met, as described in Section 6 of [RFC7748].",MUST,"For these curves, implementations SHOULD use the approach specified in [RFC7748] to calculate the Diffie-Hellman shared secret. Implementations MUST check whether the computed Diffie-Hellman shared secret is the all-zero value and abort if so, as described in Section 6 of [RFC7748]. If implementors use an alternative implementation of these elliptic curves, they SHOULD perform the additional checks specified in Section 7 of [RFC7748].","-The ECDH shared secret is the result of applying the ECDH scalar multiplication function to the secret key (into scalar input) and the peer's public key (into u-coordinate point input). The output is used raw, with no processing.",,7.4.2,Elliptic Curve Diffie-Hellman,3,6,2,MUST
"If implementors use an alternative implementation of these elliptic curves, they SHOULD perform the additional checks specified in Section 7 of [RFC7748].",Implementors use an alternative implementation of these elliptic curves.,Perform the additional checks specified in Section 7 of [RFC7748].,SHOULD,"For these curves, implementations SHOULD use the approach specified in [RFC7748] to calculate the Diffie-Hellman shared secret. Implementations MUST check whether the computed Diffie-Hellman shared secret is the all-zero value and abort if so, as described in Section 6 of [RFC7748]. If implementors use an alternative implementation of these elliptic curves, they SHOULD perform the additional checks specified in Section 7 of [RFC7748].","-The ECDH shared secret is the result of applying the ECDH scalar multiplication function to the secret key (into scalar input) and the peer's public key (into u-coordinate point input). The output is used raw, with no processing.",,7.4.2,Elliptic Curve Diffie-Hellman,3,6,3,SHOULD
Implementations MUST use the exporter_master_secret unless explicitly specified by the application.,No explicit specification by the application to use a different exporter secret,Implementations MUST use the exporter_master_secret,MUST,Where Secret is either the early_exporter_master_secret or the exporter_master_secret. Implementations MUST use the exporter_master_secret unless explicitly specified by the application. The early_exporter_master_secret is defined for use in settings where an exporter is needed for 0-RTT data. A separate interface for the early exporter is RECOMMENDED; this avoids the exporter user accidentally using an early exporter when a regular one is desired or vice versa.,"TLS-Exporter(label, context_value, key_length) = HKDF-Expand-Label(Derive-Secret(Secret, label, """"), ""exporter"", Hash(context_value), key_length)","If no context is provided, the context_value is zero length. Consequently, providing no context computes the same value as providing an empty context. This is a change from previous versions of TLS where an empty context produced a different output than an absent context. As of this document's publication, no allocated exporter label is used both with and without a context. Future specifications MUST NOT define a use of exporters that permit both an empty context and no context with the same label. New uses of exporters SHOULD provide a context in all exporter computations, though the value could be empty.",7.5,Exporters,2,4,2,MUST
Future specifications MUST NOT define a use of exporters that permit both an empty context and no context with the same label.,When a specification defines an exporter use permitting both an empty context and no context with the same label,Future specifications MUST NOT define a use of exporters that permit both an empty context and no context with the same label,MUST NOT,"If no context is provided, the context_value is zero length. Consequently, providing no context computes the same value as providing an empty context. This is a change from previous versions of TLS where an empty context produced a different output than an absent context. As of this document's publication, no allocated exporter label is used both with and without a context. Future specifications MUST NOT define a use of exporters that permit both an empty context and no context with the same label. New uses of exporters SHOULD provide a context in all exporter computations, though the value could be empty.",Where Secret is either the early_exporter_master_secret or the exporter_master_secret. Implementations MUST use the exporter_master_secret unless explicitly specified by the application. The early_exporter_master_secret is defined for use in settings where an exporter is needed for 0-RTT data. A separate interface for the early exporter is RECOMMENDED; this avoids the exporter user accidentally using an early exporter when a regular one is desired or vice versa.,Requirements for the format of exporter labels are defined in Section 4 of [RFC5705].,7.5,Exporters,2,5,5,MUST
"New uses of exporters SHOULD provide a context in all exporter computations, though the value could be empty.",When a new use of an exporter is invoked for computing an exporter value.,Provide a context in all exporter computations (the context value may be empty).,SHOULD,"If no context is provided, the context_value is zero length. Consequently, providing no context computes the same value as providing an empty context. This is a change from previous versions of TLS where an empty context produced a different output than an absent context. As of this document's publication, no allocated exporter label is used both with and without a context. Future specifications MUST NOT define a use of exporters that permit both an empty context and no context with the same label. New uses of exporters SHOULD provide a context in all exporter computations, though the value could be empty.",Where Secret is either the early_exporter_master_secret or the exporter_master_secret. Implementations MUST use the exporter_master_secret unless explicitly specified by the application. The early_exporter_master_secret is defined for use in settings where an exporter is needed for 0-RTT data. A separate interface for the early exporter is RECOMMENDED; this avoids the exporter user accidentally using an early exporter when a regular one is desired or vice versa.,Requirements for the format of exporter labels are defined in Section 4 of [RFC5705].,7.5,Exporters,2,5,6,SHOULD
Servers SHOULD provide that level of replay safety by implementing one of the methods described in this section or by equivalent means.,"When handling 0-RTT early data that may be replayed, leading to possible duplicate processing across multiple server instances (as described in the context of replay attacks).",Servers SHOULD provide the specified level of replay safety by implementing one of the methods described in this section or by using equivalent means.,SHOULD,"The first class of attack can be prevented by sharing state to guarantee that the 0-RTT data is accepted at most once. Servers SHOULD provide that level of replay safety by implementing one of the methods described in this section or by equivalent means. It is understood, however, that due to operational concerns not all deployments will maintain state at that level. Therefore, in normal operation, clients will not know which, if any, of these mechanisms servers actually implement and hence MUST only send early data which they deem safe to be replayed.","-Network attackers who take advantage of client retry behavior to arrange for the server to receive multiple copies of an application message. This threat already exists to some extent because clients that value robustness respond to network errors by attempting to retry requests. However, 0-RTT adds an additional dimension for any server system which does not maintain globally consistent server state. Specifically, if a server system has multiple zones where tickets from zone A will not be accepted in zone B, then an attacker can duplicate a ClientHello and early data intended for A to both A and B. At A, the data will be accepted in 0-RTT, but at B the server will reject 0-RTT data and instead force a full handshake. If the attacker blocks the ServerHello from A, then the client will complete the handshake with B and probably retry the request, leading to duplication on the server system as a whole.","In addition to the direct effects of replays, there is a class of attacks where even operations normally considered idempotent could be exploited by a large number of replays (timing attacks, resource limit exhaustion and others, as described in Appendix E.5). Those can be mitigated by ensuring that every 0-RTT payload can be replayed only a limited number of times. The server MUST ensure that any instance of it (be it a machine, a thread, or any other entity within the relevant serving infrastructure) would accept 0-RTT for the same 0-RTT handshake at most once; this limits the number of replays to the number of server instances in the deployment. Such a guarantee can be accomplished by locally recording data from recently received ClientHellos and rejecting repeats, or by any other method that",8,0-RTT and Anti-Replay,1,4,2,SHOULD
"Therefore, in normal operation, clients will not know which, if any, of these mechanisms servers actually implement and hence MUST only send early data which they deem safe to be replayed.","In normal operation, clients do not know which, if any, replay-safety mechanisms the server implements.",Clients MUST only send early data which they deem safe to be replayed.,MUST,"The first class of attack can be prevented by sharing state to guarantee that the 0-RTT data is accepted at most once. Servers SHOULD provide that level of replay safety by implementing one of the methods described in this section or by equivalent means. It is understood, however, that due to operational concerns not all deployments will maintain state at that level. Therefore, in normal operation, clients will not know which, if any, of these mechanisms servers actually implement and hence MUST only send early data which they deem safe to be replayed.","-Network attackers who take advantage of client retry behavior to arrange for the server to receive multiple copies of an application message. This threat already exists to some extent because clients that value robustness respond to network errors by attempting to retry requests. However, 0-RTT adds an additional dimension for any server system which does not maintain globally consistent server state. Specifically, if a server system has multiple zones where tickets from zone A will not be accepted in zone B, then an attacker can duplicate a ClientHello and early data intended for A to both A and B. At A, the data will be accepted in 0-RTT, but at B the server will reject 0-RTT data and instead force a full handshake. If the attacker blocks the ServerHello from A, then the client will complete the handshake with B and probably retry the request, leading to duplication on the server system as a whole.","In addition to the direct effects of replays, there is a class of attacks where even operations normally considered idempotent could be exploited by a large number of replays (timing attacks, resource limit exhaustion and others, as described in Appendix E.5). Those can be mitigated by ensuring that every 0-RTT payload can be replayed only a limited number of times. The server MUST ensure that any instance of it (be it a machine, a thread, or any other entity within the relevant serving infrastructure) would accept 0-RTT for the same 0-RTT handshake at most once; this limits the number of replays to the number of server instances in the deployment. Such a guarantee can be accomplished by locally recording data from recently received ClientHellos and rejecting repeats, or by any other method that",8,0-RTT and Anti-Replay,1,4,4,MUST
"The server MUST ensure that any instance of it (be it a machine, a thread, or any other entity within the relevant serving infrastructure) would accept 0-RTT for the same 0-RTT handshake at most once; this limits the number of replays to the number of server instances in the deployment.",When a 0-RTT handshake is received that has already been accepted by the same server instance,"The server MUST ensure that each server instance accepts 0-RTT for the same handshake at most once (e.g., by recording received ClientHellos and rejecting repeats), thereby limiting the number of replays to the number of server instances.",MUST,"In addition to the direct effects of replays, there is a class of attacks where even operations normally considered idempotent could be exploited by a large number of replays (timing attacks, resource limit exhaustion and others, as described in Appendix E.5). Those can be mitigated by ensuring that every 0-RTT payload can be replayed only a limited number of times. The server MUST ensure that any instance of it (be it a machine, a thread, or any other entity within the relevant serving infrastructure) would accept 0-RTT for the same 0-RTT handshake at most once; this limits the number of replays to the number of server instances in the deployment. Such a guarantee can be accomplished by locally recording data from recently received ClientHellos and rejecting repeats, or by any other method that","The first class of attack can be prevented by sharing state to guarantee that the 0-RTT data is accepted at most once. Servers SHOULD provide that level of replay safety by implementing one of the methods described in this section or by equivalent means. It is understood, however, that due to operational concerns not all deployments will maintain state at that level. Therefore, in normal operation, clients will not know which, if any, of these mechanisms servers actually implement and hence MUST only send early data which they deem safe to be replayed.","provides the same or a stronger guarantee. The ""at most once per server instance"" guarantee is a minimum requirement; servers SHOULD limit 0-RTT replays further when feasible.",8,0-RTT and Anti-Replay,1,5,3,MUST
"The ""at most once per server instance"" guarantee is a minimum requirement; servers SHOULD limit 0-RTT replays further when feasible.",When the server instance is processing 0-RTT handshake replays—i.e. after ensuring the minimum 'at most once per server instance' replay guarantee—the potential exists for additional replays.,Servers SHOULD limit further 0-RTT replays beyond the minimum guarantee when feasible.,SHOULD,"provides the same or a stronger guarantee. The ""at most once per server instance"" guarantee is a minimum requirement; servers SHOULD limit 0-RTT replays further when feasible.","In addition to the direct effects of replays, there is a class of attacks where even operations normally considered idempotent could be exploited by a large number of replays (timing attacks, resource limit exhaustion and others, as described in Appendix E.5). Those can be mitigated by ensuring that every 0-RTT payload can be replayed only a limited number of times. The server MUST ensure that any instance of it (be it a machine, a thread, or any other entity within the relevant serving infrastructure) would accept 0-RTT for the same 0-RTT handshake at most once; this limits the number of replays to the number of server instances in the deployment. Such a guarantee can be accomplished by locally recording data from recently received ClientHellos and rejecting repeats, or by any other method that",The second class of attack cannot be prevented at the TLS layer and MUST be dealt with by any application. Note that any application whose clients implement any kind of retry behavior already needs to implement some sort of anti-replay defense.,8,0-RTT and Anti-Replay,1,6,2,SHOULD
The second class of attack cannot be prevented at the TLS layer and MUST be dealt with by any application.,The scenario in which a second class of attack occurs that cannot be prevented at the TLS layer,"Any application MUST deal with the second class of attack, including implementing appropriate anti-replay defenses if clients implement any kind of retry behavior",MUST,The second class of attack cannot be prevented at the TLS layer and MUST be dealt with by any application. Note that any application whose clients implement any kind of retry behavior already needs to implement some sort of anti-replay defense.,"provides the same or a stronger guarantee. The ""at most once per server instance"" guarantee is a minimum requirement; servers SHOULD limit 0-RTT replays further when feasible.",,8,0-RTT and Anti-Replay,1,7,1,MUST
"Servers MAY also implement data stores with false positives, such as Bloom filters, in which case they MUST respond to apparent replay by rejecting 0-RTT but MUST NOT abort the handshake.","The server implements a data store with false positives (e.g., using Bloom filters) and detects an apparent replay of a ClientHello.",The server MUST reject 0-RTT and MUST NOT abort the handshake.,"MUST, MUST NOT, MAY","If the expected_arrival_time is in the window, then the server checks to see if it has recorded a matching ClientHello. If one is found, it either aborts the handshake with an ""illegal_parameter"" alert or accepts the PSK but rejects 0-RTT. If no matching ClientHello is found, then it accepts 0-RTT and then stores the ClientHello for as long as the expected_arrival_time is inside the window. Servers MAY also implement data stores with false positives, such as Bloom filters, in which case they MUST respond to apparent replay by rejecting 0-RTT but MUST NOT abort the handshake.","In order to implement this, when a ClientHello is received, the server first verifies the PSK binder as described in Section 4.2.11. It then computes the expected_arrival_time as described in the next section and rejects 0-RTT if it is outside the recording window, falling back to the 1-RTT handshake.","The server MUST derive the storage key only from validated sections of the ClientHello. If the ClientHello contains multiple PSK identities, then an attacker can create multiple ClientHellos with different binder values for the less-preferred identity on the assumption that the server will not verify it (as recommended by Section 4.2.11). I.e., if the client sends PSKs A and B but the server prefers A, then the attacker can change the binder for B without affecting the binder for A. If the binder for B is part of the storage key, then this ClientHello will not appear as a duplicate, which will cause the ClientHello to be accepted, and may cause side effects such as replay cache pollution, although any 0-RTT data will not be decryptable because it will use different keys. If the validated binder or the ClientHello.random is used as the storage key, then this attack is not possible.",8.2,Client Hello Recording,2,3,4,MUST
The server MUST derive the storage key only from validated sections of the ClientHello.,When processing a ClientHello message for storage key derivation,The server MUST derive the storage key only from validated sections of the ClientHello,MUST,"The server MUST derive the storage key only from validated sections of the ClientHello. If the ClientHello contains multiple PSK identities, then an attacker can create multiple ClientHellos with different binder values for the less-preferred identity on the assumption that the server will not verify it (as recommended by Section 4.2.11). I.e., if the client sends PSKs A and B but the server prefers A, then the attacker can change the binder for B without affecting the binder for A. If the binder for B is part of the storage key, then this ClientHello will not appear as a duplicate, which will cause the ClientHello to be accepted, and may cause side effects such as replay cache pollution, although any 0-RTT data will not be decryptable because it will use different keys. If the validated binder or the ClientHello.random is used as the storage key, then this attack is not possible.","If the expected_arrival_time is in the window, then the server checks to see if it has recorded a matching ClientHello. If one is found, it either aborts the handshake with an ""illegal_parameter"" alert or accepts the PSK but rejects 0-RTT. If no matching ClientHello is found, then it accepts 0-RTT and then stores the ClientHello for as long as the expected_arrival_time is inside the window. Servers MAY also implement data stores with false positives, such as Bloom filters, in which case they MUST respond to apparent replay by rejecting 0-RTT but MUST NOT abort the handshake.","Because this mechanism does not require storing all outstanding tickets, it may be easier to implement in distributed systems with high rates of resumption and 0-RTT, at the cost of potentially weaker anti-replay defense because of the difficulty of reliably storing and retrieving the received ClientHello messages. In many such systems, it is impractical to have globally consistent storage of all the received ClientHellos. In this case, the best anti-replay protection is provided by having a single storage zone be authoritative for a given ticket and refusing 0-RTT for that ticket in any other zone. This approach prevents simple replay by the attacker because only one zone will accept 0-RTT data. A weaker design is to implement separate storage for each zone but allow 0-RTT in any zone. This approach limits the number of replays to once per zone. Application message duplication of course remains possible with either design.",8.2,Client Hello Recording,2,4,1,MUST
"When implementations are freshly started, they SHOULD reject 0-RTT as long as any portion of their recording window overlaps the startup time.",Implementations are freshly started and have any portion of their recording window overlapping the startup time,Reject 0-RTT,SHOULD,"When implementations are freshly started, they SHOULD reject 0-RTT as long as any portion of their recording window overlaps the startup time. Otherwise, they run the risk of accepting replays which were originally sent during that period.","Because this mechanism does not require storing all outstanding tickets, it may be easier to implement in distributed systems with high rates of resumption and 0-RTT, at the cost of potentially weaker anti-replay defense because of the difficulty of reliably storing and retrieving the received ClientHello messages. In many such systems, it is impractical to have globally consistent storage of all the received ClientHellos. In this case, the best anti-replay protection is provided by having a single storage zone be authoritative for a given ticket and refusing 0-RTT for that ticket in any other zone. This approach prevents simple replay by the attacker because only one zone will accept 0-RTT data. A weaker design is to implement separate storage for each zone but allow 0-RTT in any zone. This approach limits the number of replays to once per zone. Application message duplication of course remains possible with either design.","Note: If the client's clock is running much faster than the server's, then a ClientHello may be received that is outside the window in the future, in which case it might be accepted for 1-RTT, causing a client retry, and then acceptable later for 0-RTT. This is another variant of the second form of attack described in Section 8.",8.2,Client Hello Recording,2,6,1,SHOULD
A TLS-compliant application MUST implement the TLS_AES_128_GCM_SHA256 [GCM] cipher suite and SHOULD implement the TLS_AES_256_GCM_SHA384 [GCM] and TLS_CHACHA20_POLY1305_SHA256 [RFC8439] cipher suites (see Appendix B.4).,When no alternate application profile standard is specified and the application claims TLS compliance,"The application MUST implement the TLS_AES_128_GCM_SHA256 cipher suite,The application SHOULD implement the TLS_AES_256_GCM_SHA384 and TLS_CHACHA20_POLY1305_SHA256 cipher suites","MUST, SHOULD",A TLS-compliant application MUST implement the TLS_AES_128_GCM_SHA256 [GCM] cipher suite and SHOULD implement the TLS_AES_256_GCM_SHA384 [GCM] and TLS_CHACHA20_POLY1305_SHA256 [RFC8439] cipher suites (see Appendix B.4).,In the absence of an application profile standard specifying otherwise:,"A TLS-compliant application MUST support digital signatures with rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for CertificateVerify and certificates), and ecdsa_secp256r1_sha256. A TLS-compliant application MUST support key exchange with secp256r1 (NIST P-256) and SHOULD support key exchange with X25519 [RFC7748].",9.1,Mandatory-to-Implement Cipher Suites,2,2,1,MUST
"A TLS-compliant application MUST support digital signatures with rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for CertificateVerify and certificates), and ecdsa_secp256r1_sha256.",When the application is required to be TLS-compliant.,"The TLS-compliant application MUST support digital signatures with rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for CertificateVerify and certificates), and ecdsa_secp256r1_sha256.",MUST,"A TLS-compliant application MUST support digital signatures with rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for CertificateVerify and certificates), and ecdsa_secp256r1_sha256. A TLS-compliant application MUST support key exchange with secp256r1 (NIST P-256) and SHOULD support key exchange with X25519 [RFC7748].",A TLS-compliant application MUST implement the TLS_AES_128_GCM_SHA256 [GCM] cipher suite and SHOULD implement the TLS_AES_256_GCM_SHA384 [GCM] and TLS_CHACHA20_POLY1305_SHA256 [RFC8439] cipher suites (see Appendix B.4).,,9.1,Mandatory-to-Implement Cipher Suites,2,3,1,MUST
A TLS-compliant application MUST support key exchange with secp256r1 (NIST P-256) and SHOULD support key exchange with X25519 [RFC7748].,The requirement applies to a TLS-compliant application,"The application MUST support key exchange with secp256r1 (NIST P-256),The application SHOULD support key exchange with X25519 [RFC7748]","MUST, SHOULD","A TLS-compliant application MUST support digital signatures with rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for CertificateVerify and certificates), and ecdsa_secp256r1_sha256. A TLS-compliant application MUST support key exchange with secp256r1 (NIST P-256) and SHOULD support key exchange with X25519 [RFC7748].",A TLS-compliant application MUST implement the TLS_AES_128_GCM_SHA256 [GCM] cipher suite and SHOULD implement the TLS_AES_256_GCM_SHA384 [GCM] and TLS_CHACHA20_POLY1305_SHA256 [RFC8439] cipher suites (see Appendix B.4).,,9.1,Mandatory-to-Implement Cipher Suites,2,3,2,MUST
"In the absence of an application profile standard specifying otherwise, a TLS-compliant application MUST implement the following TLS extensions:",In the absence of an application profile standard specifying otherwise,"A TLS-compliant application MUST implement the following TLS extensions: Supported Versions (""supported_versions""; Section 4.2.1)",MUST,"In the absence of an application profile standard specifying otherwise, a TLS-compliant application MUST implement the following TLS extensions:",,"-Supported Versions (""supported_versions""; Section 4.2.1)",9.2,Mandatory-to-Implement Extensions,2,1,1,MUST
All implementations MUST send and use these extensions when offering applicable features:,When offering applicable features,All implementations MUST send and use these extensions,MUST,All implementations MUST send and use these extensions when offering applicable features:,"-Server Name Indication (""server_name""; Section 3 of [RFC6066])","-""supported_versions"" is REQUIRED for all ClientHello, ServerHello, and HelloRetryRequest messages.",9.2,Mandatory-to-Implement Extensions,2,9,1,MUST
Such a ClientHello message MUST meet the following requirements:,A ClientHello message is considered to be attempting to negotiate using this specification if it contains a 'supported_versions' extension with 0x0304 in its body.,"If the ClientHello message does not contain a 'pre_shared_key' extension, it MUST contain both a 'signature_algorithms' extension and a 'supported_groups' extension.",MUST,"A client is considered to be attempting to negotiate using this specification if the ClientHello contains a ""supported_versions"" extension with 0x0304 contained in its body. Such a ClientHello message MUST meet the following requirements:","-""psk_key_exchange_modes"" is REQUIRED for PSK key agreement.","-If not containing a ""pre_shared_key"" extension, it MUST contain both a ""signature_algorithms"" extension and a ""supported_groups"" extension.",9.2,Mandatory-to-Implement Extensions,2,16,2,MUST
"-If not containing a ""pre_shared_key"" extension, it MUST contain both a ""signature_algorithms"" extension and a ""supported_groups"" extension.",ClientHello message does not contain a 'pre_shared_key' extension.,ClientHello message MUST contain both a 'signature_algorithms' extension and a 'supported_groups' extension.,MUST,"-If not containing a ""pre_shared_key"" extension, it MUST contain both a ""signature_algorithms"" extension and a ""supported_groups"" extension.","A client is considered to be attempting to negotiate using this specification if the ClientHello contains a ""supported_versions"" extension with 0x0304 contained in its body. Such a ClientHello message MUST meet the following requirements:","-If containing a ""supported_groups"" extension, it MUST also contain a ""key_share"" extension, and vice versa. An empty KeyShare.client_shares vector is permitted.",9.2,Mandatory-to-Implement Extensions,2,17,1,MUST
"-If containing a ""supported_groups"" extension, it MUST also contain a ""key_share"" extension, and vice versa.","The ClientHello message contains a 'supported_groups' extension.,The ClientHello message contains a 'key_share' extension.","If a 'supported_groups' extension is present, the ClientHello message MUST also include a 'key_share' extension, and vice versa.",MUST,"-If containing a ""supported_groups"" extension, it MUST also contain a ""key_share"" extension, and vice versa. An empty KeyShare.client_shares vector is permitted.","-If not containing a ""pre_shared_key"" extension, it MUST contain both a ""signature_algorithms"" extension and a ""supported_groups"" extension.","Servers receiving a ClientHello which does not conform to these requirements MUST abort the handshake with a ""missing_extension"" alert.",9.2,Mandatory-to-Implement Extensions,2,18,1,MUST
"Servers receiving a ClientHello which does not conform to these requirements MUST abort the handshake with a ""missing_extension"" alert.",A ClientHello message that does not conform to the specified requirements,Abort the handshake with a 'missing_extension' alert,MUST,"Servers receiving a ClientHello which does not conform to these requirements MUST abort the handshake with a ""missing_extension"" alert.","-If containing a ""supported_groups"" extension, it MUST also contain a ""key_share"" extension, and vice versa. An empty KeyShare.client_shares vector is permitted.","Additionally, all implementations MUST support the use of the ""server_name"" extension with applications capable of using it. Servers MAY require clients to send a valid ""server_name"" extension. Servers requiring this extension SHOULD respond to a ClientHello lacking a ""server_name"" extension by terminating the connection with a ""missing_extension"" alert.",9.2,Mandatory-to-Implement Extensions,2,19,1,MUST
"Additionally, all implementations MUST support the use of the ""server_name"" extension with applications capable of using it",When an application is capable of using the 'server_name' extension,All implementations MUST support the use of the 'server_name' extension,MUST,"Additionally, all implementations MUST support the use of the ""server_name"" extension with applications capable of using it. Servers MAY require clients to send a valid ""server_name"" extension. Servers requiring this extension SHOULD respond to a ClientHello lacking a ""server_name"" extension by terminating the connection with a ""missing_extension"" alert.","Servers receiving a ClientHello which does not conform to these requirements MUST abort the handshake with a ""missing_extension"" alert.",,9.2,Mandatory-to-Implement Extensions,2,20,1,MUST
"Servers MAY require clients to send a valid ""server_name"" extension",A ClientHello message is received without a valid 'server_name' extension (when the server is configured to require it),Terminate the connection by responding with a 'missing_extension' alert,MAY,"Additionally, all implementations MUST support the use of the ""server_name"" extension with applications capable of using it. Servers MAY require clients to send a valid ""server_name"" extension. Servers requiring this extension SHOULD respond to a ClientHello lacking a ""server_name"" extension by terminating the connection with a ""missing_extension"" alert.","Servers receiving a ClientHello which does not conform to these requirements MUST abort the handshake with a ""missing_extension"" alert.",,9.2,Mandatory-to-Implement Extensions,2,20,2,MAY
"Servers requiring this extension SHOULD respond to a ClientHello lacking a ""server_name"" extension by terminating the connection with a ""missing_extension"" alert.",A ClientHello message lacking a 'server_name' extension,Terminate the connection with a 'missing_extension' alert,SHOULD,"Additionally, all implementations MUST support the use of the ""server_name"" extension with applications capable of using it. Servers MAY require clients to send a valid ""server_name"" extension. Servers requiring this extension SHOULD respond to a ClientHello lacking a ""server_name"" extension by terminating the connection with a ""missing_extension"" alert.","Servers receiving a ClientHello which does not conform to these requirements MUST abort the handshake with a ""missing_extension"" alert.",,9.2,Mandatory-to-Implement Extensions,2,20,3,SHOULD
This section describes invariants that TLS endpoints and middleboxes MUST follow.,Applies to TLS endpoints and middleboxes (including those operating with earlier versions of TLS),TLS endpoints and middleboxes MUST follow the invariants described in this section.,MUST,This section describes invariants that TLS endpoints and middleboxes MUST follow. It also applies to earlier versions of TLS.,,"TLS is designed to be securely and compatibly extensible. Newer clients or servers, when communicating with newer peers, should negotiate the most preferred common parameters. The TLS handshake provides downgrade protection: Middleboxes passing traffic between a newer client and newer server without terminating TLS should be unable to influence the handshake (see Appendix E.1). At the same time, deployments update at different rates, so a newer client or server MAY continue to support older parameters, which would allow it to interoperate with older endpoints.",9.3,Protocol Invariants,2,1,1,MUST
"At the same time, deployments update at different rates, so a newer client or server MAY continue to support older parameters, which would allow it to interoperate with older endpoints.","Deployments update at different rates, potentially resulting in newer clients or servers needing to interoperate with older endpoints.",A newer client or server MAY continue to support older parameters to allow interoperation with older endpoints.,MAY,"TLS is designed to be securely and compatibly extensible. Newer clients or servers, when communicating with newer peers, should negotiate the most preferred common parameters. The TLS handshake provides downgrade protection: Middleboxes passing traffic between a newer client and newer server without terminating TLS should be unable to influence the handshake (see Appendix E.1). At the same time, deployments update at different rates, so a newer client or server MAY continue to support older parameters, which would allow it to interoperate with older endpoints.",This section describes invariants that TLS endpoints and middleboxes MUST follow. It also applies to earlier versions of TLS.,"For this to work, implementations MUST correctly handle extensible fields:",9.3,Protocol Invariants,2,2,4,MAY
"For this to work, implementations MUST correctly handle extensible fields:","When TLS handshakes involve the use of extensible fields for negotiating parameters (i.e., in scenarios where newer and older endpoints interoperate using extensible fields)",Implementations MUST correctly handle extensible fields,MUST,"For this to work, implementations MUST correctly handle extensible fields:","TLS is designed to be securely and compatibly extensible. Newer clients or servers, when communicating with newer peers, should negotiate the most preferred common parameters. The TLS handshake provides downgrade protection: Middleboxes passing traffic between a newer client and newer server without terminating TLS should be unable to influence the handshake (see Appendix E.1). At the same time, deployments update at different rates, so a newer client or server MAY continue to support older parameters, which would allow it to interoperate with older endpoints.","-A client sending a ClientHello MUST support all parameters advertised in it. Otherwise, the server may fail to interoperate by selecting one of those parameters.",9.3,Protocol Invariants,2,3,1,MUST
-A client sending a ClientHello MUST support all parameters advertised in it.,A client is sending a ClientHello message,The client MUST support all parameters advertised in the ClientHello,MUST,"-A client sending a ClientHello MUST support all parameters advertised in it. Otherwise, the server may fail to interoperate by selecting one of those parameters.","For this to work, implementations MUST correctly handle extensible fields:","-A server receiving a ClientHello MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters. Otherwise, it may fail to interoperate with newer clients. In TLS 1.3, a client receiving a CertificateRequest or NewSessionTicket MUST also ignore all unrecognized extensions.",9.3,Protocol Invariants,2,4,1,MUST
"-A server receiving a ClientHello MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters",A server receiving a ClientHello,"The server MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters",MUST,"-A server receiving a ClientHello MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters. Otherwise, it may fail to interoperate with newer clients. In TLS 1.3, a client receiving a CertificateRequest or NewSessionTicket MUST also ignore all unrecognized extensions.","-A client sending a ClientHello MUST support all parameters advertised in it. Otherwise, the server may fail to interoperate by selecting one of those parameters.","-A middlebox which terminates a TLS connection MUST behave as a compliant TLS server (to the original client), including having a certificate which the client is willing to accept, and also as a compliant TLS client (to the original server), including verifying the original server's certificate. In particular, it MUST generate its own ClientHello containing only parameters it understands, and it MUST generate a fresh ServerHello random value, rather than forwarding the endpoint's value.",9.3,Protocol Invariants,2,5,1,MUST
"In TLS 1.3, a client receiving a CertificateRequest or NewSessionTicket MUST also ignore all unrecognized extensions.","Client receives a CertificateRequest,Client receives a NewSessionTicket",Ignore all unrecognized extensions,MUST,"-A server receiving a ClientHello MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters. Otherwise, it may fail to interoperate with newer clients. In TLS 1.3, a client receiving a CertificateRequest or NewSessionTicket MUST also ignore all unrecognized extensions.","-A client sending a ClientHello MUST support all parameters advertised in it. Otherwise, the server may fail to interoperate by selecting one of those parameters.","-A middlebox which terminates a TLS connection MUST behave as a compliant TLS server (to the original client), including having a certificate which the client is willing to accept, and also as a compliant TLS client (to the original server), including verifying the original server's certificate. In particular, it MUST generate its own ClientHello containing only parameters it understands, and it MUST generate a fresh ServerHello random value, rather than forwarding the endpoint's value.",9.3,Protocol Invariants,2,5,3,MUST
"-A middlebox which terminates a TLS connection MUST behave as a compliant TLS server (to the original client), including having a certificate which the client is willing to accept, and also as a compliant TLS client (to the original server), including verifying the original server's certificate.",A middlebox that terminates a TLS connection,"Behave as a compliant TLS server to the original client, including having a certificate which the client is willing to accept,Behave as a compliant TLS client to the original server, including verifying the original server's certificate,Generate its own ClientHello containing only parameters it understands,Generate a fresh ServerHello random value rather than forwarding the endpoint's value",MUST,"-A middlebox which terminates a TLS connection MUST behave as a compliant TLS server (to the original client), including having a certificate which the client is willing to accept, and also as a compliant TLS client (to the original server), including verifying the original server's certificate. In particular, it MUST generate its own ClientHello containing only parameters it understands, and it MUST generate a fresh ServerHello random value, rather than forwarding the endpoint's value.","-A server receiving a ClientHello MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters. Otherwise, it may fail to interoperate with newer clients. In TLS 1.3, a client receiving a CertificateRequest or NewSessionTicket MUST also ignore all unrecognized extensions.","-A middlebox which forwards ClientHello parameters it does not understand MUST NOT process any messages beyond that ClientHello. It MUST forward all subsequent traffic unmodified. Otherwise, it may fail to interoperate with newer clients and servers.",9.3,Protocol Invariants,2,6,1,MUST
"In particular, it MUST generate its own ClientHello containing only parameters it understands, and it MUST generate a fresh ServerHello random value, rather than forwarding the endpoint's value.",When a middlebox terminates a TLS connection and acts as both a TLS server (to the client) and a TLS client (to the server),"Generate its own ClientHello containing only parameters it understands,Generate a fresh ServerHello random value instead of forwarding the endpoint's value",MUST,"-A middlebox which terminates a TLS connection MUST behave as a compliant TLS server (to the original client), including having a certificate which the client is willing to accept, and also as a compliant TLS client (to the original server), including verifying the original server's certificate. In particular, it MUST generate its own ClientHello containing only parameters it understands, and it MUST generate a fresh ServerHello random value, rather than forwarding the endpoint's value.","-A server receiving a ClientHello MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters. Otherwise, it may fail to interoperate with newer clients. In TLS 1.3, a client receiving a CertificateRequest or NewSessionTicket MUST also ignore all unrecognized extensions.","-A middlebox which forwards ClientHello parameters it does not understand MUST NOT process any messages beyond that ClientHello. It MUST forward all subsequent traffic unmodified. Otherwise, it may fail to interoperate with newer clients and servers.",9.3,Protocol Invariants,2,6,2,MUST
-A middlebox which forwards ClientHello parameters it does not understand MUST NOT process any messages beyond that ClientHello,A middlebox forwards ClientHello parameters it does not understand,"The middlebox MUST NOT process any messages beyond that ClientHello,It MUST forward all subsequent traffic unmodified",MUST NOT,"-A middlebox which forwards ClientHello parameters it does not understand MUST NOT process any messages beyond that ClientHello. It MUST forward all subsequent traffic unmodified. Otherwise, it may fail to interoperate with newer clients and servers.","-A middlebox which terminates a TLS connection MUST behave as a compliant TLS server (to the original client), including having a certificate which the client is willing to accept, and also as a compliant TLS client (to the original server), including verifying the original server's certificate. In particular, it MUST generate its own ClientHello containing only parameters it understands, and it MUST generate a fresh ServerHello random value, rather than forwarding the endpoint's value.","The design of TLS 1.3 was constrained by widely deployed non-compliant TLS middleboxes (see Appendix D.4); however, it does not relax the invariants. Those middleboxes continue to be non-compliant.",9.3,Protocol Invariants,2,7,1,MUST
It MUST forward all subsequent traffic unmodified.,This behavior is triggered when a middlebox forwards ClientHello parameters it does not understand.,The middlebox MUST forward all subsequent traffic unmodified.,MUST,"-A middlebox which forwards ClientHello parameters it does not understand MUST NOT process any messages beyond that ClientHello. It MUST forward all subsequent traffic unmodified. Otherwise, it may fail to interoperate with newer clients and servers.","-A middlebox which terminates a TLS connection MUST behave as a compliant TLS server (to the original client), including having a certificate which the client is willing to accept, and also as a compliant TLS client (to the original server), including verifying the original server's certificate. In particular, it MUST generate its own ClientHello containing only parameters it understands, and it MUST generate a fresh ServerHello random value, rather than forwarding the endpoint's value.","The design of TLS 1.3 was constrained by widely deployed non-compliant TLS middleboxes (see Appendix D.4); however, it does not relax the invariants. Those middleboxes continue to be non-compliant.",9.3,Protocol Invariants,2,7,2,MUST
"If clients need to send such alerts, they SHOULD first rekey to the handshake keys if possible.",When clients need to send alerts (specifically alerts derived from post-ServerHello messages in the clear or with early data keys),"Clients SHOULD first rekey to the handshake keys, if possible",SHOULD,"Note that with the transitions as shown above, clients may send alerts that derive from post-ServerHello messages in the clear or with the early data keys. If clients need to send such alerts, they SHOULD first rekey to the handshake keys if possible.","This appendix provides a summary of the legal state transitions for the client and server handshakes. State names (in all capitals, e.g., START) have no formal meaning but are provided for ease of comprehension. Actions which are taken only in certain circumstances are indicated in []. The notation ""K_{send,recv} = foo"" means ""set the send/recv key to the given key"".",K_recv = handshake | | K_recv = early data [Skip decrypt errors] | +------> WAIT_EOED -+ | | Recv | | Recv EndOfEarlyData | | early data | | K_recv = handshake | +------------+ | | | +> WAIT_FLIGHT2 <--------+ | +--------+--------+ No auth | | Client auth | | | v | WAIT_CERT | Recv | | Recv Certificate | empty | v | Certificate | WAIT_CV | | | Recv | v | CertificateVerify +-> WAIT_FINISHED <---+ | Recv Finished | K_recv = application v CONNECTED,12.2,Informative References,2,71,2,SHOULD
TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,When constructing outgoing TLS messages that might include values previously used in older TLS versions (i.e. values denoted as '_RESERVED'),TLS 1.3 implementations MUST NOT include or send these reserved values in any transmitted messages,MUST NOT,"This appendix provides the normative protocol types and the definitions for constants. Values listed as ""_RESERVED"" were used in previous versions of TLS and are listed here for completeness. TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.",K_recv = handshake | | K_recv = early data [Skip decrypt errors] | +------> WAIT_EOED -+ | | Recv | | Recv EndOfEarlyData | | early data | | K_recv = handshake | +------------+ | | | +> WAIT_FLIGHT2 <--------+ | +--------+--------+ No auth | | Client auth | | | v | WAIT_CERT | Recv | | Recv Certificate | empty | v | Certificate | WAIT_CV | | | Recv | v | CertificateVerify +-> WAIT_FINISHED <---+ | Recv Finished | K_recv = application v CONNECTED,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations. The obsolete curves have various known/theoretical weaknesses or have had very little usage, in some cases only due to unintentional server configuration issues. They are no longer considered appropriate for general use and should be assumed to be potentially unsafe. The set of curves specified here is sufficient for interoperability with all currently deployed and properly configured TLS implementations.",12.2,Informative References,2,73,3,MUST
"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.","When values fall within the ""obsolete_RESERVED"" ranges that were used in previous versions of TLS.",TLS 1.3 implementations MUST NOT offer or negotiate these values.,MUST NOT,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations. The obsolete curves have various known/theoretical weaknesses or have had very little usage, in some cases only due to unintentional server configuration issues. They are no longer considered appropriate for general use and should be assumed to be potentially unsafe. The set of curves specified here is sufficient for interoperability with all currently deployed and properly configured TLS implementations.","This appendix provides the normative protocol types and the definitions for constants. Values listed as ""_RESERVED"" were used in previous versions of TLS and are listed here for completeness. TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.",A symmetric cipher suite defines the pair of the AEAD algorithm and hash algorithm to be used with HKDF. Cipher suite names follow the naming convention:,12.2,Informative References,2,74,1,MUST
Applications SHOULD also enforce minimum and maximum key sizes.,"When processing certificates or certification paths, particularly when keys or signatures are encountered that could be below accepted security thresholds (e.g., keys weaker than 2048-bit RSA or 224-bit ECDSA).",Applications SHOULD enforce minimum and maximum key sizes to ensure that keys used in certificates or communications meet the required security criteria.,SHOULD,"Implementations are responsible for verifying the integrity of certificates and should generally support certificate revocation messages. Absent a specific indication from an application profile, certificates should always be verified to ensure proper signing by a trusted certificate authority (CA). The selection and addition of trust anchors should be done very carefully. Users should be able to view information about the certificate and trust anchor. Applications SHOULD also enforce minimum and maximum key sizes. For example, certification paths containing keys or signatures weaker than 2048-bit RSA or 224-bit ECDSA are not appropriate for secure applications.","TLS uses random values (1) in public protocol fields such as the public Random values in the ClientHello and ServerHello and (2) to generate keying material. With a properly functioning CSPRNG, this does not present a security problem, as it is not feasible to determine the CSPRNG state from its output. However, with a broken CSPRNG, it may be possible for an attacker to use the public output to determine the CSPRNG internal state and thereby predict the keying material, as documented in [CHECKOWAY]. Implementations can provide extra security against this form of attack by using separate CSPRNGs to generate public and private values.","Implementation experience has shown that certain parts of earlier TLS specifications are not easy to understand and have been a source of interoperability and security problems. Many of these areas have been clarified in this document, but this appendix contains a short list of the most important things that require special attention from implementors.",12.2,Informative References,2,83,5,SHOULD
Clients SHOULD NOT reuse a ticket for multiple connections.,"When a client attempts to use an already issued ticket for a new connection, thereby reusing a ticket across multiple connections",Clients SHOULD NOT reuse a ticket for multiple connections,SHOULD NOT,"Clients SHOULD NOT reuse a ticket for multiple connections. Reuse of a ticket allows passive observers to correlate different connections. Servers that issue tickets SHOULD offer at least as many tickets as the number of connections that a client might use; for example, a web browser using HTTP/1.1 [RFC7230] might open six connections to a server. Servers SHOULD issue new tickets with every connection. This ensures that clients are always able to use a new ticket when creating a new connection.","-Do you verify signatures after making them, to protect against RSA-CRT key leaks [FW15]?","Previous versions of TLS offered explicitly unauthenticated cipher suites based on anonymous Diffie-Hellman. These modes have been deprecated in TLS 1.3. However, it is still possible to negotiate parameters that do not provide verifiable server authentication by several methods, including:",12.2,Informative References,2,101,1,SHOULD
"Servers that issue tickets SHOULD offer at least as many tickets as the number of connections that a client might use; for example, a web browser using HTTP/1.1 [RFC7230] might open six connections to a server.","When a server issues tickets and the client may open multiple simultaneous connections (e.g., a web browser using HTTP/1.1 might open six connections)",The server SHOULD offer at least as many tickets as the number of connections that the client might use.,SHOULD,"Clients SHOULD NOT reuse a ticket for multiple connections. Reuse of a ticket allows passive observers to correlate different connections. Servers that issue tickets SHOULD offer at least as many tickets as the number of connections that a client might use; for example, a web browser using HTTP/1.1 [RFC7230] might open six connections to a server. Servers SHOULD issue new tickets with every connection. This ensures that clients are always able to use a new ticket when creating a new connection.","-Do you verify signatures after making them, to protect against RSA-CRT key leaks [FW15]?","Previous versions of TLS offered explicitly unauthenticated cipher suites based on anonymous Diffie-Hellman. These modes have been deprecated in TLS 1.3. However, it is still possible to negotiate parameters that do not provide verifiable server authentication by several methods, including:",12.2,Informative References,2,101,3,SHOULD
Servers SHOULD issue new tickets with every connection,When a client establishes a new connection to the server.,The server SHOULD issue a new ticket for each new connection.,SHOULD,"Clients SHOULD NOT reuse a ticket for multiple connections. Reuse of a ticket allows passive observers to correlate different connections. Servers that issue tickets SHOULD offer at least as many tickets as the number of connections that a client might use; for example, a web browser using HTTP/1.1 [RFC7230] might open six connections to a server. Servers SHOULD issue new tickets with every connection. This ensures that clients are always able to use a new ticket when creating a new connection.","-Do you verify signatures after making them, to protect against RSA-CRT key leaks [FW15]?","Previous versions of TLS offered explicitly unauthenticated cipher suites based on anonymous Diffie-Hellman. These modes have been deprecated in TLS 1.3. However, it is still possible to negotiate parameters that do not provide verifiable server authentication by several methods, including:",12.2,Informative References,2,101,4,SHOULD
"If no such mechanism is used, then the connection has no protection against active man-in-the-middle attack; applications MUST NOT use TLS in such a way absent explicit configuration or a specific application profile.","No external authentication mechanism (such as explicit configuration, a specific application profile, out-of-band server public key validation, trust on first use, or channel bindings) is applied to the TLS connection",Applications MUST NOT use TLS in such a way,MUST NOT,"Either technique used alone is vulnerable to man-in-the-middle attacks and therefore unsafe for general use. However, it is also possible to bind such connections to an external authentication mechanism via out-of-band validation of the server's public key, trust on first use, or a mechanism such as channel bindings (though the channel bindings described in [RFC5929] are not defined for TLS 1.3). If no such mechanism is used, then the connection has no protection against active man-in-the-middle attack; applications MUST NOT use TLS in such a way absent explicit configuration or a specific application profile.",-Using a public key contained in a certificate but without validation of the certificate chain or any of its contents.,The TLS protocol provides a built-in mechanism for version negotiation between endpoints potentially supporting different versions of TLS.,12.2,Informative References,2,105,3,MUST
The value of TLSPlaintext.legacy_record_version MUST be ignored by all implementations.,"When processing a TLSPlaintext record, regardless of its legacy_record_version value.",All implementations MUST ignore the value of TLSPlaintext.legacy_record_version.,MUST,"Prior versions of TLS used the record layer version number (TLSPlaintext.legacy_record_version and TLSCiphertext.legacy_record_version) for various purposes. As of TLS 1.3, this field is deprecated. The value of TLSPlaintext.legacy_record_version MUST be ignored by all implementations. The value of TLSCiphertext.legacy_record_version is included in the additional data for deprotection but MAY otherwise be ignored or MAY be validated to match the fixed constant value. Version negotiation is performed using only the handshake versions (ClientHello.legacy_version and ServerHello.legacy_version, as well as the ClientHello, HelloRetryRequest, and ServerHello ""supported_versions"" extensions). In order to maximize interoperability with older endpoints, implementations that negotiate the use of TLS 1.0-1.2 SHOULD set the record layer version number to the negotiated version for the ServerHello and all records thereafter.",TLS 1.x and SSL 3.0 use compatible ClientHello messages. Servers can also handle clients trying to use future versions of TLS as long as the ClientHello format remains compatible and there is at least one protocol version supported by both the client and the server.,"For maximum compatibility with previously non-standard behavior and misconfigured deployments, all implementations SHOULD support validation of certification paths based on the expectations in this document, even when handling prior TLS versions' handshakes (see Section 4.4.2.2).",12.2,Informative References,2,108,3,MUST
The value of TLSCiphertext.legacy_record_version is included in the additional data for deprotection but MAY otherwise be ignored or MAY be validated to match the fixed constant value,When processing a TLSCiphertext record for deprotection,The value of TLSCiphertext.legacy_record_version MUST be included in the additional data used for deprotection,MAY,"Prior versions of TLS used the record layer version number (TLSPlaintext.legacy_record_version and TLSCiphertext.legacy_record_version) for various purposes. As of TLS 1.3, this field is deprecated. The value of TLSPlaintext.legacy_record_version MUST be ignored by all implementations. The value of TLSCiphertext.legacy_record_version is included in the additional data for deprotection but MAY otherwise be ignored or MAY be validated to match the fixed constant value. Version negotiation is performed using only the handshake versions (ClientHello.legacy_version and ServerHello.legacy_version, as well as the ClientHello, HelloRetryRequest, and ServerHello ""supported_versions"" extensions). In order to maximize interoperability with older endpoints, implementations that negotiate the use of TLS 1.0-1.2 SHOULD set the record layer version number to the negotiated version for the ServerHello and all records thereafter.",TLS 1.x and SSL 3.0 use compatible ClientHello messages. Servers can also handle clients trying to use future versions of TLS as long as the ClientHello format remains compatible and there is at least one protocol version supported by both the client and the server.,"For maximum compatibility with previously non-standard behavior and misconfigured deployments, all implementations SHOULD support validation of certification paths based on the expectations in this document, even when handling prior TLS versions' handshakes (see Section 4.4.2.2).",12.2,Informative References,2,108,4,MAY
"In order to maximize interoperability with older endpoints, implementations that negotiate the use of TLS 1.0-1.2 SHOULD set the record layer version number to the negotiated version for the ServerHello and all records thereafter.",Negotiation results in the use of TLS 1.0-1.2,Set the record layer version number to the negotiated version for the ServerHello and all records thereafter,SHOULD,"Prior versions of TLS used the record layer version number (TLSPlaintext.legacy_record_version and TLSCiphertext.legacy_record_version) for various purposes. As of TLS 1.3, this field is deprecated. The value of TLSPlaintext.legacy_record_version MUST be ignored by all implementations. The value of TLSCiphertext.legacy_record_version is included in the additional data for deprotection but MAY otherwise be ignored or MAY be validated to match the fixed constant value. Version negotiation is performed using only the handshake versions (ClientHello.legacy_version and ServerHello.legacy_version, as well as the ClientHello, HelloRetryRequest, and ServerHello ""supported_versions"" extensions). In order to maximize interoperability with older endpoints, implementations that negotiate the use of TLS 1.0-1.2 SHOULD set the record layer version number to the negotiated version for the ServerHello and all records thereafter.",TLS 1.x and SSL 3.0 use compatible ClientHello messages. Servers can also handle clients trying to use future versions of TLS as long as the ClientHello format remains compatible and there is at least one protocol version supported by both the client and the server.,"For maximum compatibility with previously non-standard behavior and misconfigured deployments, all implementations SHOULD support validation of certification paths based on the expectations in this document, even when handling prior TLS versions' handshakes (see Section 4.4.2.2).",12.2,Informative References,2,108,6,SHOULD
"For maximum compatibility with previously non-standard behavior and misconfigured deployments, all implementations SHOULD support validation of certification paths based on the expectations in this document, even when handling prior TLS versions' handshakes (see Section 4.4.2.2).","Handling prior TLS versions' handshakes, especially in environments exhibiting non-standard behavior and misconfigured deployments",Implementations SHOULD support validation of certification paths based on the expectations in the document,SHOULD,"For maximum compatibility with previously non-standard behavior and misconfigured deployments, all implementations SHOULD support validation of certification paths based on the expectations in this document, even when handling prior TLS versions' handshakes (see Section 4.4.2.2).","Prior versions of TLS used the record layer version number (TLSPlaintext.legacy_record_version and TLSCiphertext.legacy_record_version) for various purposes. As of TLS 1.3, this field is deprecated. The value of TLSPlaintext.legacy_record_version MUST be ignored by all implementations. The value of TLSCiphertext.legacy_record_version is included in the additional data for deprotection but MAY otherwise be ignored or MAY be validated to match the fixed constant value. Version negotiation is performed using only the handshake versions (ClientHello.legacy_version and ServerHello.legacy_version, as well as the ClientHello, HelloRetryRequest, and ServerHello ""supported_versions"" extensions). In order to maximize interoperability with older endpoints, implementations that negotiate the use of TLS 1.0-1.2 SHOULD set the record layer version number to the negotiated version for the ServerHello and all records thereafter.","TLS 1.2 and prior supported an ""Extended Master Secret"" [RFC7627] extension which digested large parts of the handshake transcript into the master secret. Because TLS 1.3 always hashes in the transcript up to the server Finished, implementations which support both TLS 1.3 and earlier versions SHOULD indicate the use of the Extended Master Secret extension in their APIs whenever TLS 1.3 is used.",12.2,Informative References,2,109,1,SHOULD
"Because TLS 1.3 always hashes in the transcript up to the server Finished, implementations which support both TLS 1.3 and earlier versions SHOULD indicate the use of the Extended Master Secret extension in their APIs whenever TLS 1.3 is used.",Implementations that support both TLS 1.3 and earlier versions when TLS 1.3 is used.,Indicate the use of the Extended Master Secret extension in their APIs.,SHOULD,"TLS 1.2 and prior supported an ""Extended Master Secret"" [RFC7627] extension which digested large parts of the handshake transcript into the master secret. Because TLS 1.3 always hashes in the transcript up to the server Finished, implementations which support both TLS 1.3 and earlier versions SHOULD indicate the use of the Extended Master Secret extension in their APIs whenever TLS 1.3 is used.","For maximum compatibility with previously non-standard behavior and misconfigured deployments, all implementations SHOULD support validation of certification paths based on the expectations in this document, even when handling prior TLS versions' handshakes (see Section 4.4.2.2).","A TLS 1.3 client who wishes to negotiate with servers that do not support TLS 1.3 will send a normal TLS 1.3 ClientHello containing 0x0303 (TLS 1.2) in ClientHello.legacy_version but with the correct version(s) in the ""supported_versions"" extension. If the server does not support TLS 1.3, it will respond with a ServerHello containing an older version number. If the client agrees to use this version, the negotiation will proceed as appropriate for the negotiated protocol. A client using a ticket for resumption SHOULD initiate the connection using the version that was previously negotiated.",12.2,Informative References,2,110,2,SHOULD
A client using a ticket for resumption SHOULD initiate the connection using the version that was previously negotiated.,A client is using a ticket for resumption.,The client SHOULD initiate the connection using the version that was previously negotiated.,SHOULD,"A TLS 1.3 client who wishes to negotiate with servers that do not support TLS 1.3 will send a normal TLS 1.3 ClientHello containing 0x0303 (TLS 1.2) in ClientHello.legacy_version but with the correct version(s) in the ""supported_versions"" extension. If the server does not support TLS 1.3, it will respond with a ServerHello containing an older version number. If the client agrees to use this version, the negotiation will proceed as appropriate for the negotiated protocol. A client using a ticket for resumption SHOULD initiate the connection using the version that was previously negotiated.","TLS 1.2 and prior supported an ""Extended Master Secret"" [RFC7627] extension which digested large parts of the handshake transcript into the master secret. Because TLS 1.3 always hashes in the transcript up to the server Finished, implementations which support both TLS 1.3 and earlier versions SHOULD indicate the use of the Extended Master Secret extension in their APIs whenever TLS 1.3 is used.",Note that 0-RTT data is not compatible with older servers and SHOULD NOT be sent absent knowledge that the server supports TLS 1.3. See Appendix D.3.,12.2,Informative References,2,111,4,SHOULD
Note that 0-RTT data is not compatible with older servers and SHOULD NOT be sent absent knowledge that the server supports TLS 1.3,"When the client does not have knowledge that the server supports TLS 1.3 (i.e., when communicating with older servers or lacking explicit confirmation of TLS 1.3 support)",The client SHOULD NOT send 0-RTT data.,SHOULD NOT,Note that 0-RTT data is not compatible with older servers and SHOULD NOT be sent absent knowledge that the server supports TLS 1.3. See Appendix D.3.,"A TLS 1.3 client who wishes to negotiate with servers that do not support TLS 1.3 will send a normal TLS 1.3 ClientHello containing 0x0303 (TLS 1.2) in ClientHello.legacy_version but with the correct version(s) in the ""supported_versions"" extension. If the server does not support TLS 1.3, it will respond with a ServerHello containing an older version number. If the client agrees to use this version, the negotiation will proceed as appropriate for the negotiated protocol. A client using a ticket for resumption SHOULD initiate the connection using the version that was previously negotiated.","If the version chosen by the server is not supported by the client (or is not acceptable), the client MUST abort the handshake with a ""protocol_version"" alert.",12.2,Informative References,2,112,1,SHOULD
"If the version chosen by the server is not supported by the client (or is not acceptable), the client MUST abort the handshake with a ""protocol_version"" alert.",The version chosen by the server is not supported by the client (or is not acceptable),"The client MUST abort the handshake with a ""protocol_version"" alert",MUST,"If the version chosen by the server is not supported by the client (or is not acceptable), the client MUST abort the handshake with a ""protocol_version"" alert.",Note that 0-RTT data is not compatible with older servers and SHOULD NOT be sent absent knowledge that the server supports TLS 1.3. See Appendix D.3.,"Some legacy server implementations are known to not implement the TLS specification properly and might abort connections upon encountering TLS extensions or versions which they are not aware of. Interoperability with buggy servers is a complex topic beyond the scope of this document. Multiple connection attempts may be required in order to negotiate a backward-compatible connection; however, this practice is vulnerable to downgrade attacks and is NOT RECOMMENDED.",12.2,Informative References,2,113,1,MUST
"If the ""supported_versions"" extension is present, the server MUST negotiate using that extension as described in Section 4.2.1.",The 'supported_versions' extension is present in the ClientHello message.,The server MUST negotiate using the 'supported_versions' extension as described in Section 4.2.1.,MUST,"A TLS server can also receive a ClientHello indicating a version number smaller than its highest supported version. If the ""supported_versions"" extension is present, the server MUST negotiate using that extension as described in Section 4.2.1. If the ""supported_versions"" extension is not present, the server MUST negotiate the minimum of ClientHello.legacy_version and TLS 1.2. For example, if the server supports TLS 1.0, 1.1, and 1.2, and legacy_version is TLS 1.0, the server will proceed with a TLS 1.0 ServerHello. If the ""supported_versions"" extension is absent and the server only supports versions greater than ClientHello.legacy_version, the server MUST abort the handshake with a ""protocol_version"" alert.","Some legacy server implementations are known to not implement the TLS specification properly and might abort connections upon encountering TLS extensions or versions which they are not aware of. Interoperability with buggy servers is a complex topic beyond the scope of this document. Multiple connection attempts may be required in order to negotiate a backward-compatible connection; however, this practice is vulnerable to downgrade attacks and is NOT RECOMMENDED.","Note that earlier versions of TLS did not clearly specify the record layer version number value in all cases (TLSPlaintext.legacy_record_version). Servers will receive various TLS 1.x versions in this field, but its value MUST always be ignored.",12.2,Informative References,2,115,2,MUST
"If the ""supported_versions"" extension is not present, the server MUST negotiate the minimum of ClientHello.legacy_version and TLS 1.2.",The 'supported_versions' extension is not present in the ClientHello message.,The server MUST negotiate the minimum of ClientHello.legacy_version and TLS 1.2.,MUST,"A TLS server can also receive a ClientHello indicating a version number smaller than its highest supported version. If the ""supported_versions"" extension is present, the server MUST negotiate using that extension as described in Section 4.2.1. If the ""supported_versions"" extension is not present, the server MUST negotiate the minimum of ClientHello.legacy_version and TLS 1.2. For example, if the server supports TLS 1.0, 1.1, and 1.2, and legacy_version is TLS 1.0, the server will proceed with a TLS 1.0 ServerHello. If the ""supported_versions"" extension is absent and the server only supports versions greater than ClientHello.legacy_version, the server MUST abort the handshake with a ""protocol_version"" alert.","Some legacy server implementations are known to not implement the TLS specification properly and might abort connections upon encountering TLS extensions or versions which they are not aware of. Interoperability with buggy servers is a complex topic beyond the scope of this document. Multiple connection attempts may be required in order to negotiate a backward-compatible connection; however, this practice is vulnerable to downgrade attacks and is NOT RECOMMENDED.","Note that earlier versions of TLS did not clearly specify the record layer version number value in all cases (TLSPlaintext.legacy_record_version). Servers will receive various TLS 1.x versions in this field, but its value MUST always be ignored.",12.2,Informative References,2,115,3,MUST
"If the ""supported_versions"" extension is absent and the server only supports versions greater than ClientHello.legacy_version, the server MUST abort the handshake with a ""protocol_version"" alert.","The 'supported_versions' extension is absent,The server only supports versions greater than ClientHello.legacy_version",Abort the handshake with a 'protocol_version' alert,MUST,"A TLS server can also receive a ClientHello indicating a version number smaller than its highest supported version. If the ""supported_versions"" extension is present, the server MUST negotiate using that extension as described in Section 4.2.1. If the ""supported_versions"" extension is not present, the server MUST negotiate the minimum of ClientHello.legacy_version and TLS 1.2. For example, if the server supports TLS 1.0, 1.1, and 1.2, and legacy_version is TLS 1.0, the server will proceed with a TLS 1.0 ServerHello. If the ""supported_versions"" extension is absent and the server only supports versions greater than ClientHello.legacy_version, the server MUST abort the handshake with a ""protocol_version"" alert.","Some legacy server implementations are known to not implement the TLS specification properly and might abort connections upon encountering TLS extensions or versions which they are not aware of. Interoperability with buggy servers is a complex topic beyond the scope of this document. Multiple connection attempts may be required in order to negotiate a backward-compatible connection; however, this practice is vulnerable to downgrade attacks and is NOT RECOMMENDED.","Note that earlier versions of TLS did not clearly specify the record layer version number value in all cases (TLSPlaintext.legacy_record_version). Servers will receive various TLS 1.x versions in this field, but its value MUST always be ignored.",12.2,Informative References,2,115,5,MUST
"Servers will receive various TLS 1.x versions in this field, but its value MUST always be ignored.",When servers receive various TLS 1.x version numbers in the TLSPlaintext.legacy_record_version field.,Servers MUST always ignore the value of that field.,MUST,"Note that earlier versions of TLS did not clearly specify the record layer version number value in all cases (TLSPlaintext.legacy_record_version). Servers will receive various TLS 1.x versions in this field, but its value MUST always be ignored.","A TLS server can also receive a ClientHello indicating a version number smaller than its highest supported version. If the ""supported_versions"" extension is present, the server MUST negotiate using that extension as described in Section 4.2.1. If the ""supported_versions"" extension is not present, the server MUST negotiate the minimum of ClientHello.legacy_version and TLS 1.2. For example, if the server supports TLS 1.0, 1.1, and 1.2, and legacy_version is TLS 1.0, the server will proceed with a TLS 1.0 ServerHello. If the ""supported_versions"" extension is absent and the server only supports versions greater than ClientHello.legacy_version, the server MUST abort the handshake with a ""protocol_version"" alert.","0-RTT data is not compatible with older servers. An older server will respond to the ClientHello with an older ServerHello, but it will not correctly skip the 0-RTT data and will fail to complete the handshake. This can cause issues when a client attempts to use 0-RTT, particularly against multi-server deployments. For example, a deployment could deploy TLS 1.3 gradually with some servers implementing TLS 1.3 and some implementing TLS 1.2, or a TLS 1.3 deployment could be downgraded to TLS 1.2.",12.2,Informative References,2,116,2,MUST
A client that attempts to send 0-RTT data MUST fail a connection if it receives a ServerHello with TLS 1.2 or older.,A client attempts to send 0-RTT data and receives a ServerHello with TLS 1.2 or older,The client MUST fail the connection,MUST,"A client that attempts to send 0-RTT data MUST fail a connection if it receives a ServerHello with TLS 1.2 or older. It can then retry the connection with 0-RTT disabled. To avoid a downgrade attack, the client SHOULD NOT disable TLS 1.3, only 0-RTT.","0-RTT data is not compatible with older servers. An older server will respond to the ClientHello with an older ServerHello, but it will not correctly skip the 0-RTT data and will fail to complete the handshake. This can cause issues when a client attempts to use 0-RTT, particularly against multi-server deployments. For example, a deployment could deploy TLS 1.3 gradually with some servers implementing TLS 1.3 and some implementing TLS 1.2, or a TLS 1.3 deployment could be downgraded to TLS 1.2.","To avoid this error condition, multi-server deployments SHOULD ensure a uniform and stable deployment of TLS 1.3 without 0-RTT prior to enabling 0-RTT.",12.2,Informative References,2,118,1,MUST
"To avoid a downgrade attack, the client SHOULD NOT disable TLS 1.3, only 0-RTT.",Risk of a downgrade attack,The client SHOULD NOT disable TLS 1.3 and SHOULD disable only 0-RTT,SHOULD NOT,"A client that attempts to send 0-RTT data MUST fail a connection if it receives a ServerHello with TLS 1.2 or older. It can then retry the connection with 0-RTT disabled. To avoid a downgrade attack, the client SHOULD NOT disable TLS 1.3, only 0-RTT.","0-RTT data is not compatible with older servers. An older server will respond to the ClientHello with an older ServerHello, but it will not correctly skip the 0-RTT data and will fail to complete the handshake. This can cause issues when a client attempts to use 0-RTT, particularly against multi-server deployments. For example, a deployment could deploy TLS 1.3 gradually with some servers implementing TLS 1.3 and some implementing TLS 1.2, or a TLS 1.3 deployment could be downgraded to TLS 1.2.","To avoid this error condition, multi-server deployments SHOULD ensure a uniform and stable deployment of TLS 1.3 without 0-RTT prior to enabling 0-RTT.",12.2,Informative References,2,118,3,SHOULD
"To avoid this error condition, multi-server deployments SHOULD ensure a uniform and stable deployment of TLS 1.3 without 0-RTT prior to enabling 0-RTT.","In multi-server deployments planning to enable 0-RTT, where there is a risk of encountering an error condition due to non-uniform or unstable TLS 1.3 deployment.",Ensure a uniform and stable deployment of TLS 1.3 without 0-RTT prior to enabling 0-RTT.,SHOULD,"To avoid this error condition, multi-server deployments SHOULD ensure a uniform and stable deployment of TLS 1.3 without 0-RTT prior to enabling 0-RTT.","A client that attempts to send 0-RTT data MUST fail a connection if it receives a ServerHello with TLS 1.2 or older. It can then retry the connection with 0-RTT disabled. To avoid a downgrade attack, the client SHOULD NOT disable TLS 1.3, only 0-RTT.",Field measurements [Ben17a] [Ben17b] [Res17a] [Res17b] have found that a significant number of middleboxes misbehave when a TLS client/server pair negotiates TLS 1.3. Implementations can increase the chance of making connections through those middleboxes by making the TLS 1.3 handshake look more like a TLS 1.2 handshake:,12.2,Informative References,2,119,1,SHOULD
"change_cipher_spec at any time during the handshake, as they must be ignored by the peer, but if the client sends a non-empty session ID, the server MUST send the change_cipher_spec as described in this appendix.",The client sends a non-empty session ID,The server MUST send the change_cipher_spec as described in this appendix,MUST,"change_cipher_spec at any time during the handshake, as they must be ignored by the peer, but if the client sends a non-empty session ID, the server MUST send the change_cipher_spec as described in this appendix.","When put together, these changes make the TLS 1.3 handshake resemble TLS 1.2 session resumption, which improves the chance of successfully connecting through middleboxes. This ""compatibility mode"" is partially negotiated: the client can opt to provide a session ID or not, and the server has to echo it. Either side can send","Implementations negotiating the use of older versions of TLS SHOULD prefer forward secret and AEAD cipher suites, when available.",12.2,Informative References,2,125,1,MUST
"Implementations negotiating the use of older versions of TLS SHOULD prefer forward secret and AEAD cipher suites, when available.",Implementations are in a negotiation process for older versions of TLS.,Prefer forward secret and AEAD cipher suites when available.,SHOULD,"Implementations negotiating the use of older versions of TLS SHOULD prefer forward secret and AEAD cipher suites, when available.","change_cipher_spec at any time during the handshake, as they must be ignored by the peer, but if the client sends a non-empty session ID, the server MUST send the change_cipher_spec as described in this appendix.",The security of RC4 cipher suites is considered insufficient for the reasons cited in [RFC7465]. Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,12.2,Informative References,2,126,1,SHOULD
Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,"During TLS handshake processes where cipher suites are offered or negotiated, specifically when determining which cipher suite to use.",The implementation MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,MUST NOT,The security of RC4 cipher suites is considered insufficient for the reasons cited in [RFC7465]. Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,"Implementations negotiating the use of older versions of TLS SHOULD prefer forward secret and AEAD cipher suites, when available.",Old versions of TLS permitted the use of very low strength ciphers. Ciphers with a strength less than 112 bits MUST NOT be offered or negotiated for any version of TLS for any reason.,12.2,Informative References,2,127,2,MUST
Ciphers with a strength less than 112 bits MUST NOT be offered or negotiated for any version of TLS for any reason.,Ciphers with a strength less than 112 bits,MUST NOT be offered or negotiated for any version of TLS for any reason,MUST NOT,Old versions of TLS permitted the use of very low strength ciphers. Ciphers with a strength less than 112 bits MUST NOT be offered or negotiated for any version of TLS for any reason.,The security of RC4 cipher suites is considered insufficient for the reasons cited in [RFC7465]. Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",12.2,Informative References,2,128,2,MUST
"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",Any attempt to negotiate or use SSL 3.0 as the security protocol.,SSL 3.0 MUST NOT be negotiated under any circumstances.,MUST NOT,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",Old versions of TLS permitted the use of very low strength ciphers. Ciphers with a strength less than 112 bits MUST NOT be offered or negotiated for any version of TLS for any reason.,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",12.2,Informative References,2,129,1,MUST
"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",Any attempt to negotiate a connection using SSL 2.0,SSL 2.0 MUST NOT be negotiated for any reason,MUST NOT,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.","The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",Implementations MUST NOT send an SSL version 2.0 compatible CLIENT-HELLO. Implementations MUST NOT negotiate TLS 1.3 or later using an SSL version 2.0 compatible CLIENT-HELLO. Implementations are NOT RECOMMENDED to accept an SSL version 2.0 compatible CLIENT-HELLO in order to negotiate older versions of TLS.,12.2,Informative References,2,130,1,MUST
Implementations MUST NOT send an SSL version 2.0 compatible CLIENT-HELLO.,When constructing or transmitting a CLIENT-HELLO message (used in initiating a secure connection),Implementations MUST NOT send an SSL version 2.0 compatible CLIENT-HELLO.,MUST NOT,Implementations MUST NOT send an SSL version 2.0 compatible CLIENT-HELLO. Implementations MUST NOT negotiate TLS 1.3 or later using an SSL version 2.0 compatible CLIENT-HELLO. Implementations are NOT RECOMMENDED to accept an SSL version 2.0 compatible CLIENT-HELLO in order to negotiate older versions of TLS.,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.","Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less. Any endpoint receiving a Hello message with ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 MUST abort the handshake with a ""protocol_version"" alert.",12.2,Informative References,2,131,1,MUST
Implementations MUST NOT negotiate TLS 1.3 or later using an SSL version 2.0 compatible CLIENT-HELLO.,A negotiation attempt for TLS 1.3 or later is made using an SSL version 2.0 compatible CLIENT-HELLO message.,The implementation MUST NOT negotiate TLS 1.3 or later when an SSL version 2.0 compatible CLIENT-HELLO is used.,MUST NOT,Implementations MUST NOT send an SSL version 2.0 compatible CLIENT-HELLO. Implementations MUST NOT negotiate TLS 1.3 or later using an SSL version 2.0 compatible CLIENT-HELLO. Implementations are NOT RECOMMENDED to accept an SSL version 2.0 compatible CLIENT-HELLO in order to negotiate older versions of TLS.,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.","Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less. Any endpoint receiving a Hello message with ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 MUST abort the handshake with a ""protocol_version"" alert.",12.2,Informative References,2,131,2,MUST
Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less.,When constructing and sending a ClientHello or ServerHello handshake message,Do not set the legacy_version field in a ClientHello or ServerHello to 0x0300 or any value less than 0x0300,MUST NOT,"Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less. Any endpoint receiving a Hello message with ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 MUST abort the handshake with a ""protocol_version"" alert.",Implementations MUST NOT send an SSL version 2.0 compatible CLIENT-HELLO. Implementations MUST NOT negotiate TLS 1.3 or later using an SSL version 2.0 compatible CLIENT-HELLO. Implementations are NOT RECOMMENDED to accept an SSL version 2.0 compatible CLIENT-HELLO in order to negotiate older versions of TLS.,Implementations MUST NOT send any records with a version less than 0x0300. Implementations SHOULD NOT accept any records with a version less than 0x0300 (but may inadvertently do so if the record version number is ignored completely).,12.2,Informative References,2,132,1,MUST
"Any endpoint receiving a Hello message with ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 MUST abort the handshake with a ""protocol_version"" alert.","Receiving a Hello message with ClientHello.legacy_version set to 0x0300,Receiving a Hello message with ServerHello.legacy_version set to 0x0300",Abort the handshake with a 'protocol_version' alert,MUST,"Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less. Any endpoint receiving a Hello message with ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 MUST abort the handshake with a ""protocol_version"" alert.",Implementations MUST NOT send an SSL version 2.0 compatible CLIENT-HELLO. Implementations MUST NOT negotiate TLS 1.3 or later using an SSL version 2.0 compatible CLIENT-HELLO. Implementations are NOT RECOMMENDED to accept an SSL version 2.0 compatible CLIENT-HELLO in order to negotiate older versions of TLS.,Implementations MUST NOT send any records with a version less than 0x0300. Implementations SHOULD NOT accept any records with a version less than 0x0300 (but may inadvertently do so if the record version number is ignored completely).,12.2,Informative References,2,132,2,MUST
Implementations MUST NOT send any records with a version less than 0x0300.,An implementation is about to send a record that has a version number less than 0x0300.,The implementation MUST NOT send any records with a version less than 0x0300.,MUST NOT,Implementations MUST NOT send any records with a version less than 0x0300. Implementations SHOULD NOT accept any records with a version less than 0x0300 (but may inadvertently do so if the record version number is ignored completely).,"Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less. Any endpoint receiving a Hello message with ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 MUST abort the handshake with a ""protocol_version"" alert.","Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",12.2,Informative References,2,133,1,MUST
Implementations SHOULD NOT accept any records with a version less than 0x0300 (but may inadvertently do so if the record version number is ignored completely).,A record is received with a version less than 0x0300.,The implementation SHOULD NOT accept the record.,SHOULD NOT,Implementations MUST NOT send any records with a version less than 0x0300. Implementations SHOULD NOT accept any records with a version less than 0x0300 (but may inadvertently do so if the record version number is ignored completely).,"Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less. Any endpoint receiving a Hello message with ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 MUST abort the handshake with a ""protocol_version"" alert.","Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",12.2,Informative References,2,133,2,SHOULD
"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], because it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",MUST NOT,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",Implementations MUST NOT send any records with a version less than 0x0300. Implementations SHOULD NOT accept any records with a version less than 0x0300 (but may inadvertently do so if the record version number is ignored completely).,"A complete security analysis of TLS is outside the scope of this document. In this appendix, we provide an informal description of the desired properties as well as references to more detailed work in the research literature which provides more formal definitions.",12.2,Informative References,2,134,1,MUST
Implementations MUST NOT combine external PSKs with certificate-based authentication of either the client or the server unless negotiated by some extension.,When external PSKs are used with certificate-based authentication of either the client or the server without a negotiated extension.,Implementations MUST NOT combine external PSKs with certificate-based authentication unless negotiated by some extension.,MUST NOT,"TLS does not currently permit the server to send a certificate_request message in non-certificate-based handshakes (e.g., PSK). If this restriction were to be relaxed in future, the client's signature would not cover the server's certificate directly. However, if the PSK was established through a NewSessionTicket, the client's signature would transitively cover the server's certificate through the PSK binder. [PSK-FINISHED] describes a concrete attack on constructions that do not bind to the server's certificate (see also [Kraw16]). It is unsafe to use certificate-based client authentication when the client might potentially share the same PSK/key-id pair with two different endpoints. Implementations MUST NOT combine external PSKs with certificate-based authentication of either the client or the server unless negotiated by some extension.","The PSK binder value forms a binding between a PSK and the current handshake, as well as between the session where the PSK was established and the current session. This binding transitively includes the original handshake transcript, because that transcript is digested into the values which produce the resumption master secret. This requires that both the KDF used to produce the resumption master secret and the MAC used to compute the binder be collision resistant. See Appendix E.1.1 for more on this. Note: The binder does not cover the binder values from other PSKs, though they are included in the Finished MAC.","If an exporter is used, then it produces values which are unique and secret (because they are generated from a unique session key). Exporters computed with different labels and contexts are computationally independent, so it is not feasible to compute one from another or the session secret from the exported value. Note: Exporters can produce arbitrary-length values; if exporters are to be used as channel bindings, the exported value MUST be large enough to provide collision resistance. The exporters provided in TLS 1.3 are derived from the same Handshake Contexts as the early traffic keys and the application traffic keys, respectively, and thus have similar security properties. Note that they do not include the client's certificate; future applications which wish to bind to the client's certificate may need to define a new exporter that includes the full handshake transcript.",12.2,Informative References,2,154,6,MUST
"Note: Exporters can produce arbitrary-length values; if exporters are to be used as channel bindings, the exported value MUST be large enough to provide collision resistance.",Exporters are to be used as channel bindings,The exported value MUST be large enough to provide collision resistance,MUST,"If an exporter is used, then it produces values which are unique and secret (because they are generated from a unique session key). Exporters computed with different labels and contexts are computationally independent, so it is not feasible to compute one from another or the session secret from the exported value. Note: Exporters can produce arbitrary-length values; if exporters are to be used as channel bindings, the exported value MUST be large enough to provide collision resistance. The exporters provided in TLS 1.3 are derived from the same Handshake Contexts as the early traffic keys and the application traffic keys, respectively, and thus have similar security properties. Note that they do not include the client's certificate; future applications which wish to bind to the client's certificate may need to define a new exporter that includes the full handshake transcript.","TLS does not currently permit the server to send a certificate_request message in non-certificate-based handshakes (e.g., PSK). If this restriction were to be relaxed in future, the client's signature would not cover the server's certificate directly. However, if the PSK was established through a NewSessionTicket, the client's signature would transitively cover the server's certificate through the PSK binder. [PSK-FINISHED] describes a concrete attack on constructions that do not bind to the server's certificate (see also [Kraw16]). It is unsafe to use certificate-based client authentication when the client might potentially share the same PSK/key-id pair with two different endpoints. Implementations MUST NOT combine external PSKs with certificate-based authentication of either the client or the server unless negotiated by some extension.","For all handshake modes, the Finished MAC (and, where present, the signature) prevents downgrade attacks. In addition, the use of certain bytes in the random nonces as described in Section 4.1.3 allows the detection of downgrade to previous TLS versions. See [BBFGKZ16] for more details on TLS 1.3 and downgrade.",12.2,Informative References,2,155,3,MUST
"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",When an output of HKDF-Extract is used as an input to another application of HKDF-Extract without an intervening HKDF-Expand,"Always insert at least one HKDF-Expand between consecutive applications of HKDF-Extract; that is, never use the output of HKDF-Extract as an input to another HKDF-Extract without an intervening HKDF-Expand.",SHOULD NOT,"Key derivation in TLS 1.3 uses HKDF as defined in [RFC5869] and its two components, HKDF-Extract and HKDF-Expand. The full rationale for the HKDF construction can be found in [Kraw10] and the rationale for the way it is used in TLS 1.3 in [KW16]. Throughout this document, each application of HKDF-Extract is followed by one or more invocations of HKDF-Expand. This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between. Multiple applications of HKDF-Expand to some of the same inputs are allowed as long as these are differentiated via the key and/or the labels.","As soon as the client and the server have exchanged enough information to establish shared keys, the remainder of the handshake is encrypted, thus providing protection against passive attackers, even if the computed shared key is not authenticated. Because the server authenticates before the client, the client can ensure that if it authenticates to the server, it only reveals its identity to an authenticated server. Note that implementations must use the provided record-padding mechanism during the handshake to avoid leaking information about the identities due to length. The client's proposed PSK identities are not encrypted, nor is the one that the server selects.","Note that HKDF-Expand implements a pseudorandom function (PRF) with both inputs and outputs of variable length. In some of the uses of HKDF in this document (e.g., for generating exporters and the resumption_master_secret), it is necessary that the application of HKDF-Expand be collision resistant; namely, it should be infeasible to find two different inputs to HKDF-Expand that output the same value. This requires the underlying hash function to be collision resistant and the output length from HKDF-Expand to be of size at least 256 bits (or as much as needed for the hash function to prevent finding collisions).",12.2,Informative References,2,158,4,SHOULD
"However, because these secrets can be used to compute any exporter value, they SHOULD be erased as soon as possible.","When the exporter secrets (exporter_master_secret and early_exporter_master_secret) exist and can be used to compute any exporter value.,When the total set of exporter labels is known.","The secrets SHOULD be erased as soon as possible.,If the total set of exporter labels is known, implementations SHOULD pre-compute the inner Derive-Secret stage of the exporter computation for all those labels, then erase the [early_]exporter_master_secret, followed by each inner value as soon as it is known that it will not be needed again.",SHOULD,"The exporter_master_secret and early_exporter_master_secret are derived to be independent of the traffic keys and therefore do not represent a threat to the security of traffic encrypted with those keys. However, because these secrets can be used to compute any exporter value, they SHOULD be erased as soon as possible. If the total set of exporter labels is known, then implementations SHOULD pre-compute the inner Derive-Secret stage of the exporter computation for all those labels, then erase the [early_]exporter_master_secret, followed by each inner value as soon as it is known that it will not be needed again.","The 0-RTT mode of operation generally provides security properties similar to those of 1-RTT data, with the two exceptions that the 0-RTT encryption keys do not provide full forward secrecy and that the server is not able to guarantee uniqueness of the handshake (non-replayability) without keeping potentially undue amounts of state. See Section 8 for mechanisms to limit the exposure to replay.","TLS does not provide security for handshakes which take place after the peer's long-term secret (signature key or external PSK) is compromised. It therefore does not provide post-compromise security [CCG16], sometimes also referred to as backward or future secrecy. This is in contrast to KCI resistance, which describes the security guarantees that a party has after its own long-term secret has been compromised.",12.2,Informative References,2,162,2,SHOULD
"If the total set of exporter labels is known, then implementations SHOULD pre-compute the inner Derive-Secret stage of the exporter computation for all those labels, then erase the [early_]exporter_master_secret, followed by each inner value as soon as it is known that it will not be needed again.",The total set of exporter labels is known.,"Pre-compute the inner Derive-Secret stage of the exporter computation for all exporter labels.,Erase the [early_]exporter_master_secret.,Erase each inner value as soon as it is known that it will not be needed again.",SHOULD,"The exporter_master_secret and early_exporter_master_secret are derived to be independent of the traffic keys and therefore do not represent a threat to the security of traffic encrypted with those keys. However, because these secrets can be used to compute any exporter value, they SHOULD be erased as soon as possible. If the total set of exporter labels is known, then implementations SHOULD pre-compute the inner Derive-Secret stage of the exporter computation for all those labels, then erase the [early_]exporter_master_secret, followed by each inner value as soon as it is known that it will not be needed again.","The 0-RTT mode of operation generally provides security properties similar to those of 1-RTT data, with the two exceptions that the 0-RTT encryption keys do not provide full forward secrecy and that the server is not able to guarantee uniqueness of the handshake (non-replayability) without keeping potentially undue amounts of state. See Section 8 for mechanisms to limit the exposure to replay.","TLS does not provide security for handshakes which take place after the peer's long-term secret (signature key or external PSK) is compromised. It therefore does not provide post-compromise security [CCG16], sometimes also referred to as backward or future secrecy. This is in contrast to KCI resistance, which describes the security guarantees that a party has after its own long-term secret has been compromised.",12.2,Informative References,2,162,3,SHOULD
"Because clients do not know the exact details of server behavior, they MUST NOT send messages in early data which are not safe to have replayed and which they would not be willing to retry across multiple 1-RTT connections.","The message is being sent in early data and is not safe to have replayed,The message is one that the client would not be willing to retry across multiple 1-RTT connections",Clients MUST NOT send such messages in early data,MUST NOT,"If implemented correctly, the mechanisms described in Sections 8.1 and 8.2 prevent a replayed ClientHello and its associated 0-RTT data from being accepted multiple times by any cluster with consistent state; for servers which limit the use of 0-RTT to one cluster for a single ticket, then a given ClientHello and its associated 0-RTT data will only be accepted once. However, if state is not completely consistent, then an attacker might be able to have multiple copies of the data be accepted during the replication window. Because clients do not know the exact details of server behavior, they MUST NOT send messages in early data which are not safe to have replayed and which they would not be willing to retry across multiple 1-RTT connections.","Ultimately, servers have the responsibility to protect themselves against attacks employing 0-RTT data replication. The mechanisms described in Section 8 are intended to prevent replay at the TLS layer but do not provide complete protection against receiving multiple copies of client data. TLS 1.3 falls back to the 1-RTT handshake when the server does not have any information about the client, e.g., because it is in a different cluster which does not share state or because the ticket has been deleted as described in Section 8.1. If the application-layer protocol retransmits data in this setting, then it is possible for an attacker to induce message duplication by sending the ClientHello to both the original cluster (which processes the data immediately) and another cluster which will fall back to 1-RTT and process the data upon application-layer replay. The scale of this attack is limited by the client's willingness to retry transactions and therefore only allows a limited amount of duplication, with each copy appearing as a new connection at the server.",Application protocols MUST NOT use 0-RTT data without a profile that defines its use. That profile needs to identify which messages or interactions are safe to use with 0-RTT and how to handle the situation when the server rejects 0-RTT and falls back to 1-RTT.,12.2,Informative References,2,190,3,MUST
Application protocols MUST NOT use 0-RTT data without a profile that defines its use.,The application is using 0-RTT data without a defined profile that specifies how its use is managed.,"Application protocols MUST NOT use 0-RTT data unless there is a profile that defines its use, including safe messages or interactions and handling server rejections.",MUST NOT,Application protocols MUST NOT use 0-RTT data without a profile that defines its use. That profile needs to identify which messages or interactions are safe to use with 0-RTT and how to handle the situation when the server rejects 0-RTT and falls back to 1-RTT.,"If implemented correctly, the mechanisms described in Sections 8.1 and 8.2 prevent a replayed ClientHello and its associated 0-RTT data from being accepted multiple times by any cluster with consistent state; for servers which limit the use of 0-RTT to one cluster for a single ticket, then a given ClientHello and its associated 0-RTT data will only be accepted once. However, if state is not completely consistent, then an attacker might be able to have multiple copies of the data be accepted during the replication window. Because clients do not know the exact details of server behavior, they MUST NOT send messages in early data which are not safe to have replayed and which they would not be willing to retry across multiple 1-RTT connections.","In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application. Server-side applications may wish to implement special processing for 0-RTT data for some kinds of application traffic (e.g., abort the connection, request that data be resent at the application layer, or delay processing until the handshake completes). In order to allow applications to implement this kind of processing, TLS implementations MUST provide a way for the application to determine if the handshake has completed.",12.2,Informative References,2,191,1,MUST
"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.","TLS implementations should only enable 0-RTT when specifically requested by the application,0-RTT data rejection by the server triggers a check for explicit instruction from the application before any resend","TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application,TLS implementations MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application",MUST NOT,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application. Server-side applications may wish to implement special processing for 0-RTT data for some kinds of application traffic (e.g., abort the connection, request that data be resent at the application layer, or delay processing until the handshake completes). In order to allow applications to implement this kind of processing, TLS implementations MUST provide a way for the application to determine if the handshake has completed.",Application protocols MUST NOT use 0-RTT data without a profile that defines its use. That profile needs to identify which messages or interactions are safe to use with 0-RTT and how to handle the situation when the server rejects 0-RTT and falls back to 1-RTT.,"Replays of the ClientHello produce the same early exporter, thus requiring additional care by applications which use these exporters. In particular, if these exporters are used as an authentication channel binding (e.g., by signing the output of the exporter), an attacker who compromises the PSK can transplant authenticators between connections without compromising the authentication key.",12.2,Informative References,2,192,1,MUST
"In order to allow applications to implement this kind of processing, TLS implementations MUST provide a way for the application to determine if the handshake has completed.",The application requires knowing whether the TLS handshake has completed in order to implement special processing for 0-RTT data.,TLS implementations MUST provide a way for the application to determine if the handshake has completed.,MUST,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application. Server-side applications may wish to implement special processing for 0-RTT data for some kinds of application traffic (e.g., abort the connection, request that data be resent at the application layer, or delay processing until the handshake completes). In order to allow applications to implement this kind of processing, TLS implementations MUST provide a way for the application to determine if the handshake has completed.",Application protocols MUST NOT use 0-RTT data without a profile that defines its use. That profile needs to identify which messages or interactions are safe to use with 0-RTT and how to handle the situation when the server rejects 0-RTT and falls back to 1-RTT.,"Replays of the ClientHello produce the same early exporter, thus requiring additional care by applications which use these exporters. In particular, if these exporters are used as an authentication channel binding (e.g., by signing the output of the exporter), an attacker who compromises the PSK can transplant authenticators between connections without compromising the authentication key.",12.2,Informative References,2,192,3,MUST
"In addition, the early exporter SHOULD NOT be used to generate server-to-client encryption keys because that would entail the reuse of those keys.",When the early exporter is to be used for generating server-to-client encryption keys,The early exporter SHOULD NOT be used to generate server-to-client encryption keys to avoid key reuse,SHOULD NOT,"In addition, the early exporter SHOULD NOT be used to generate server-to-client encryption keys because that would entail the reuse of those keys. This parallels the use of the early application traffic keys only in the client-to-server direction.","Replays of the ClientHello produce the same early exporter, thus requiring additional care by applications which use these exporters. In particular, if these exporters are used as an authentication channel binding (e.g., by signing the output of the exporter), an attacker who compromises the PSK can transplant authenticators between connections without compromising the authentication key.","Because implementations respond to an invalid PSK binder by aborting the handshake, it may be possible for an attacker to verify whether a given PSK identity is valid. Specifically, if a server accepts both external-PSK handshakes and certificate-based handshakes, a valid PSK identity will result in a failed handshake, whereas an invalid identity will just be skipped and result in a successful certificate handshake. Servers which solely support PSK handshakes may be able to resist this form of attack by treating the cases where there is no valid PSK identity and where there is an identity but it has an invalid binder identically.",12.2,Informative References,2,194,1,SHOULD
