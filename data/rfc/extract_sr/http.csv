SR Text,Conditions,Actions,Role,Keywords,Current Paragraph,Previous Paragraph,Next Paragraph,Section Number,Section Title,Section Level,Paragraph Index,Sentence Index,status_code,field_name,content_coding,method,syntax,class,First_Keyword
Other recipients SHOULD ignore unrecognized header and trailer fields.,When an unrecognized header field or trailer field is received,Other recipients SHOULD ignore the unrecognized header and trailer fields,Recipient,SHOULD,"A proxy MUST forward unrecognized header fields unless the field name is listed in the Connection header field (Section 7.6.1) or the proxy is specifically configured to block, or otherwise transform, such fields. Other recipients SHOULD ignore unrecognized header and trailer fields. Adhering to these requirements allows HTTP's functionality to be extended without updating or removing deployed intermediaries.",New fields can be introduced without changing the protocol version if their defined semantics allow them to be safely ignored by recipients that do not recognize them; see Section 16.3.,,5.1,Field Names,2,5,2,,trailer,,,,,SHOULD
"A server that receives a request header field line, field value, or set of fields larger than it wishes to process MUST respond with an appropriate 4xx (Client Error) status code.","A request header field line, field value, or set of fields is larger than the server wishes to process.",The server MUST respond with an appropriate 4xx (Client Error) status code.,Server,MUST,"A server that receives a request header field line, field value, or set of fields larger than it wishes to process MUST respond with an appropriate 4xx (Client Error) status code. Ignoring such header fields would increase the server's vulnerability to request smuggling attacks (Section 11.2 of [HTTP/1.1]).","HTTP does not place a predefined limit on the length of each field line, field value, or on the length of a header or trailer section as a whole, as described in Section 2. Various ad hoc limitations on individual lengths are found in practice, often depending on the specific field's semantics.",A client MAY discard or truncate received field lines that are larger than the client wishes to process if the field semantics are such that the dropped value(s) can be safely ignored without changing the message framing or response semantics.,5.4,Field Limits,2,2,1,4xx,,,,,,MUST
"Specifications for newly defined fields SHOULD limit their values to visible US-ASCII octets (VCHAR), SP, and HTAB",When a field is newly defined.,"The specification directs that its values SHOULD be limited to visible US-ASCII octets (VCHAR), SP, and HTAB.",Recipient,SHOULD,"Field values are usually constrained to the range of US-ASCII characters [USASCII]. Fields needing a greater range of characters can use an encoding, such as the one defined in [RFC8187]. Historically, HTTP allowed field content with text in the ISO-8859-1 charset [ISO-8859-1], supporting other charsets only through use of [RFC2047] encoding. Specifications for newly defined fields SHOULD limit their values to visible US-ASCII octets (VCHAR), SP, and HTAB. A recipient SHOULD treat other allowed octets in field content (i.e., obs-text) as opaque data.","A field value does not include leading or trailing whitespace. When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.","Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message. Field values containing other CTL characters are also invalid; however, recipients MAY retain such characters for the sake of robustness when they appear within a safe context (e.g., an application-specific quoted string that will not be processed by any downstream HTTP parser).",5.5,Field Values,2,3,4,,,,,"SP,VCHAR",,SHOULD
"Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message.","A field value contains any of the characters CR, LF, or NUL.","The recipient MUST either reject the message, or replace each occurrence of CR, LF, or NUL with a SP, before further processing or forwarding the message.",Recipient,MUST,"Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message. Field values containing other CTL characters are also invalid; however, recipients MAY retain such characters for the sake of robustness when they appear within a safe context (e.g., an application-specific quoted string that will not be processed by any downstream HTTP parser).","Field values are usually constrained to the range of US-ASCII characters [USASCII]. Fields needing a greater range of characters can use an encoding, such as the one defined in [RFC8187]. Historically, HTTP allowed field content with text in the ISO-8859-1 charset [ISO-8859-1], supporting other charsets only through use of [RFC2047] encoding. Specifications for newly defined fields SHOULD limit their values to visible US-ASCII octets (VCHAR), SP, and HTAB. A recipient SHOULD treat other allowed octets in field content (i.e., obs-text) as opaque data.","Fields that only anticipate a single member as the field value are referred to as ""singleton fields"".",5.5,Field Values,2,4,1,,,,,"CR,LF,SP",,MUST
"Field values containing other CTL characters are also invalid; however, recipients MAY retain such characters for the sake of robustness when they appear within a safe context (e.g., an application-specific quoted string that will not be processed by any downstream HTTP parser).","Field values containing other CTL characters, specifically when these characters appear within a safe context (e.g., within an application-specific quoted string that will not be processed by any downstream HTTP parser)",Recipients MAY retain such CTL characters for the sake of robustness,Recipient,MAY,"Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message. Field values containing other CTL characters are also invalid; however, recipients MAY retain such characters for the sake of robustness when they appear within a safe context (e.g., an application-specific quoted string that will not be processed by any downstream HTTP parser).","Field values are usually constrained to the range of US-ASCII characters [USASCII]. Fields needing a greater range of characters can use an encoding, such as the one defined in [RFC8187]. Historically, HTTP allowed field content with text in the ISO-8859-1 charset [ISO-8859-1], supporting other charsets only through use of [RFC2047] encoding. Specifications for newly defined fields SHOULD limit their values to visible US-ASCII octets (VCHAR), SP, and HTAB. A recipient SHOULD treat other allowed octets in field content (i.e., obs-text) as opaque data.","Fields that only anticipate a single member as the field value are referred to as ""singleton fields"".",5.5,Field Values,2,4,2,,,,,CTL,,MAY
"For protocol elements where optional whitespace is preferred to improve readability, a sender SHOULD generate the optional whitespace as a single SP; otherwise, a sender SHOULD NOT generate optional whitespace except as needed to overwrite invalid or unwanted protocol elements during in-place message filtering.","Protocol elements where optional whitespace is preferred to improve readability,Protocol elements where optional whitespace is not preferred to improve readability","A sender SHOULD generate the optional whitespace as a single SP,A sender SHOULD NOT generate optional whitespace except as needed to overwrite invalid or unwanted protocol elements during in-place message filtering",Sender,"SHOULD, SHOULD NOT","The OWS rule is used where zero or more linear whitespace octets might appear. For protocol elements where optional whitespace is preferred to improve readability, a sender SHOULD generate the optional whitespace as a single SP; otherwise, a sender SHOULD NOT generate optional whitespace except as needed to overwrite invalid or unwanted protocol elements during in-place message filtering.","This specification uses three rules to denote the use of linear whitespace: OWS (optional whitespace), RWS (required whitespace), and BWS (""bad"" whitespace).",The RWS rule is used when at least one linear whitespace octet is required to separate field tokens. A sender SHOULD generate RWS as a single SP.,5.6.3,Whitespace,3,2,2,,,,,SP,,SHOULD
A sender SHOULD generate RWS as a single SP.,"When at least one linear whitespace octet is required to separate field tokens (i.e., when the RWS rule applies)",The sender SHOULD generate RWS as a single SP,Sender,SHOULD,The RWS rule is used when at least one linear whitespace octet is required to separate field tokens. A sender SHOULD generate RWS as a single SP.,"The OWS rule is used where zero or more linear whitespace octets might appear. For protocol elements where optional whitespace is preferred to improve readability, a sender SHOULD generate the optional whitespace as a single SP; otherwise, a sender SHOULD NOT generate optional whitespace except as needed to overwrite invalid or unwanted protocol elements during in-place message filtering.",OWS and RWS have the same semantics as a single SP. Any content known to be defined as OWS or RWS MAY be replaced with a single SP before interpreting it or forwarding the message downstream.,5.6.3,Whitespace,3,3,2,,,,,SP,,SHOULD
Any content known to be defined as OWS or RWS MAY be replaced with a single SP before interpreting it or forwarding the message downstream.,Content that is defined as OWS or RWS is present in the message,Replace the OWS or RWS content with a single SP before interpreting the message or forwarding it downstream,Recipient,MAY,OWS and RWS have the same semantics as a single SP. Any content known to be defined as OWS or RWS MAY be replaced with a single SP before interpreting it or forwarding the message downstream.,The RWS rule is used when at least one linear whitespace octet is required to separate field tokens. A sender SHOULD generate RWS as a single SP.,The BWS rule is used where the grammar allows optional whitespace only for historical reasons. A sender MUST NOT generate BWS in messages. A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,5.6.3,Whitespace,3,4,2,,,,,SP,,MAY
A sender SHOULD NOT generate a quoted-pair in a quoted-string except where necessary to quote DQUOTE and backslash octets occurring within that string.,"When a sender is constructing a quoted-string and is about to generate a quoted-pair (i.e., when embedding special octets within the quoted-string)",The sender SHOULD NOT generate a quoted-pair except when it is necessary to quote DQUOTE and backslash octets within the quoted-string,Sender,SHOULD NOT,"A sender SHOULD NOT generate a quoted-pair in a quoted-string except where necessary to quote DQUOTE and backslash octets occurring within that string. A sender SHOULD NOT generate a quoted-pair in a comment except where necessary to quote parentheses [""("" and "")""] and backslash octets occurring within that comment.","The backslash octet (""\"") can be used as a single-octet quoting mechanism within quoted-string and comment constructs. Recipients that process the value of a quoted-string MUST handle a quoted-pair as if it were replaced by the octet following the backslash.",,5.6.4,Quoted Strings,3,3,1,,,,,DQUOTE,,SHOULD
A sender MUST NOT generate additional whitespace in an HTTP-date beyond that specifically included as SP in the grammar.,When generating an HTTP-date,The sender MUST NOT generate additional whitespace in an HTTP-date beyond that specifically included as SP in the grammar,Sender,MUST NOT,"A sender MUST NOT generate additional whitespace in an HTTP-date beyond that specifically included as SP in the grammar. The semantics of day-name, day, month, year, and time-of-day are the same as those defined for the Internet Message Format constructs with the corresponding name ([RFC5322], Section 3.3).",HTTP-date is case sensitive. Note that Section 4.2 of [CACHING] relaxes this for cache recipients.,"Recipients of a timestamp value in rfc850-date format, which uses a two-digit year, MUST interpret a timestamp that appears to be more than 50 years in the future as representing the most recent year in the past that had the same last two digits.",5.6.7,Date/Time Formats,3,10,1,,,,,SP,,MUST
A sender MUST NOT generate a trailer field unless the sender knows the corresponding header field name's definition permits the field to be sent in trailers.,When a sender is about to generate a trailer field without confirmed knowledge that the corresponding header field name's definition permits the field to be sent in trailers.,The sender MUST NOT generate a trailer field unless the sender knows the corresponding header field name's definition permits the field to be sent in trailers.,Sender,MUST NOT,"Many fields cannot be processed outside the header section because their evaluation is necessary prior to receiving the content, such as those that describe message framing, routing, authentication, request modifiers, response controls, or content format. A sender MUST NOT generate a trailer field unless the sender knows the corresponding header field name's definition permits the field to be sent in trailers.","A trailer section is only possible when supported by the version of HTTP in use and enabled by an explicit framing mechanism. For example, the chunked transfer coding in HTTP/1.1 allows a trailer section to be sent after the content (Section 7.1.2 of [HTTP/1.1]).","Trailer fields can be difficult to process by intermediaries that forward messages from one protocol version to another. If the entire message can be buffered in transit, some intermediaries could merge trailer fields into the header section (as appropriate) before it is forwarded. However, in most cases, the trailers are simply discarded. A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.",6.5.1,Limitations on Use of Trailers,3,2,2,,trailer,,,,,MUST
A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,"When a recipient considers merging a trailer field into a header section and may lack explicit understanding of the corresponding header field’s definition, or the definition does not explicitly permit and define safe merging.",The recipient MUST NOT merge a trailer field into a header section unless it understands the corresponding header field’s definition and that definition explicitly permits and defines how trailer field values can be safely merged.,Recipient,MUST NOT,"Trailer fields can be difficult to process by intermediaries that forward messages from one protocol version to another. If the entire message can be buffered in transit, some intermediaries could merge trailer fields into the header section (as appropriate) before it is forwarded. However, in most cases, the trailers are simply discarded. A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.","Many fields cannot be processed outside the header section because their evaluation is necessary prior to receiving the content, such as those that describe message framing, routing, authentication, request modifiers, response controls, or content format. A sender MUST NOT generate a trailer field unless the sender knows the corresponding header field name's definition permits the field to be sent in trailers.","The presence of the keyword ""trailers"" in the TE header field (Section 10.1.4) of a request indicates that the client is willing to accept trailer fields, on behalf of itself and any downstream clients. For requests from an intermediary, this implies that all downstream clients are willing to accept trailer fields in the forwarded response. Note that the presence of ""trailers"" does not mean that the client(s) will process any particular trailer field in the response; only that the trailer section(s) will not be dropped by any of the clients.",6.5.1,Limitations on Use of Trailers,3,3,4,,trailer,,,,,MUST
"Because of the potential for trailer fields to be discarded in transit, a server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive.",The potential for trailer fields to be discarded in transit.,The server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive.,Server,SHOULD NOT,"Because of the potential for trailer fields to be discarded in transit, a server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive.","The presence of the keyword ""trailers"" in the TE header field (Section 10.1.4) of a request indicates that the client is willing to accept trailer fields, on behalf of itself and any downstream clients. For requests from an intermediary, this implies that all downstream clients are willing to accept trailer fields in the forwarded response. Note that the presence of ""trailers"" does not mean that the client(s) will process any particular trailer field in the response; only that the trailer section(s) will not be dropped by any of the clients.",,6.5.1,Limitations on Use of Trailers,3,5,1,,trailer,,,,,SHOULD
Trailer fields that might be generated more than once during a message MUST be defined as a list-based field even if each member value is only processed once per field line received.,Trailer fields that might be generated more than once during a message,Trailer fields MUST be defined as a list-based field even if each member value is only processed once per field line received,Recipient,MUST,"Like header fields, trailer fields with the same name are processed in the order received; multiple trailer field lines with the same name have the equivalent semantics as appending the multiple values as a list of members. Trailer fields that might be generated more than once during a message MUST be defined as a list-based field even if each member value is only processed once per field line received.","The ""Trailer"" header field (Section 6.6.2) can be sent to indicate fields likely to be sent in the trailer section, which allows recipients to prepare for their receipt before processing the content. For example, this could be useful if a field name indicates that a dynamic checksum should be calculated as the content is received and then immediately checked upon receipt of the trailer field value.","At the end of a message, a recipient MAY treat the set of received trailer fields as a data structure of name/value pairs, similar to (but separate from) the header fields. Additional processing expectations, if any, can be defined within the field specification for a field intended for use in trailers.",6.5.2,Processing Trailer Fields,3,2,2,,Trailer,,,,,MUST
"At the end of a message, a recipient MAY treat the set of received trailer fields as a data structure of name/value pairs, similar to (but separate from) the header fields.",At the end of a message,"The recipient MAY treat the set of received trailer fields as a data structure of name/value pairs, similar to (but separate from) the header fields",Recipient,MAY,"At the end of a message, a recipient MAY treat the set of received trailer fields as a data structure of name/value pairs, similar to (but separate from) the header fields. Additional processing expectations, if any, can be defined within the field specification for a field intended for use in trailers.","Like header fields, trailer fields with the same name are processed in the order received; multiple trailer field lines with the same name have the equivalent semantics as appending the multiple values as a list of members. Trailer fields that might be generated more than once during a message MUST be defined as a list-based field even if each member value is only processed once per field line received.",,6.5.2,Processing Trailer Fields,3,3,1,,trailer,,,,,MAY
A sender that generates a Date header field SHOULD generate its field value as the best available approximation of the date and time of message generation.,When a sender generates a Date header field,The sender SHOULD generate the field value as the best available approximation of the date and time of message generation.,Sender,SHOULD,"A sender that generates a Date header field SHOULD generate its field value as the best available approximation of the date and time of message generation. In theory, the date ought to represent the moment just before generating the message content. In practice, a sender can generate the date value at any time during message origination.","Date: Tue, 15 Nov 1994 08:12:31 GMT","An origin server with a clock (as defined in Section 5.6.7) MUST generate a Date header field in all 2xx (Successful), 3xx (Redirection), and 4xx (Client Error) responses, and MAY generate a Date header field in 1xx (Informational) and 5xx (Server Error) responses.",6.6.1,Date,3,4,1,,Date,,,,,SHOULD
"An origin server with a clock (as defined in Section 5.6.7) MUST generate a Date header field in all 2xx (Successful), 3xx (Redirection), and 4xx (Client Error) responses, and MAY generate a Date header field in 1xx (Informational) and 5xx (Server Error) responses.","An origin server that has a clock and is generating a response with a status code in the 2xx, 3xx, or 4xx range.,An origin server that has a clock and is generating a response with a status code in the 1xx or 5xx range.","For responses with status codes 2xx, 3xx, and 4xx, the origin server MUST generate a Date header field.,For responses with status codes 1xx and 5xx, the origin server MAY generate a Date header field.",Origin Server,"MUST, MAY","An origin server with a clock (as defined in Section 5.6.7) MUST generate a Date header field in all 2xx (Successful), 3xx (Redirection), and 4xx (Client Error) responses, and MAY generate a Date header field in 1xx (Informational) and 5xx (Server Error) responses.","A sender that generates a Date header field SHOULD generate its field value as the best available approximation of the date and time of message generation. In theory, the date ought to represent the moment just before generating the message content. In practice, a sender can generate the date value at any time during message origination.",An origin server without a clock MUST NOT generate a Date header field.,6.6.1,Date,3,5,1,"1xx,2xx,3xx,4xx,5xx","Date,Server",,,,,MUST
An origin server without a clock MUST NOT generate a Date header field.,An origin server without a clock,MUST NOT generate a Date header field,Origin Server,MUST NOT,An origin server without a clock MUST NOT generate a Date header field.,"An origin server with a clock (as defined in Section 5.6.7) MUST generate a Date header field in all 2xx (Successful), 3xx (Redirection), and 4xx (Client Error) responses, and MAY generate a Date header field in 1xx (Informational) and 5xx (Server Error) responses.",A recipient with a clock that receives a response message without a Date header field MUST record the time it was received and append a corresponding Date header field to the message's header section if it is cached or forwarded downstream.,6.6.1,Date,3,6,1,,Date,,,,,MUST
A recipient with a clock that receives a response message without a Date header field MUST record the time it was received and append a corresponding Date header field to the message's header section if it is cached or forwarded downstream.,"The recipient has a clock and receives a response message without a Date header field,The response message is either cached or forwarded downstream","Record the time the response message was received,Append a corresponding Date header field to the message's header section",Recipient,MUST,A recipient with a clock that receives a response message without a Date header field MUST record the time it was received and append a corresponding Date header field to the message's header section if it is cached or forwarded downstream.,An origin server without a clock MUST NOT generate a Date header field.,A recipient with a clock that receives a response with an invalid Date header field value MAY replace that value with the time that response was received.,6.6.1,Date,3,7,1,,Date,,,,,MUST
A recipient with a clock that receives a response with an invalid Date header field value MAY replace that value with the time that response was received.,A recipient with a clock receives a response with an invalid Date header field value.,The recipient MAY replace the invalid Date header field value with the time that the response was received.,Recipient,MAY,A recipient with a clock that receives a response with an invalid Date header field value MAY replace that value with the time that response was received.,A recipient with a clock that receives a response message without a Date header field MUST record the time it was received and append a corresponding Date header field to the message's header section if it is cached or forwarded downstream.,"A user agent MAY send a Date header field in a request, though generally will not do so unless it is believed to convey useful information to the server. For example, custom applications of HTTP might convey a Date if the server is expected to adjust its interpretation of the user's request based on differences between the user agent and server clocks.",6.6.1,Date,3,8,1,,Date,,,,,MAY
A sender that intends to generate one or more trailer fields in a message SHOULD generate a Trailer header field in the header section of that message to indicate which fields might be present in the trailers.,A sender intends to generate one or more trailer fields in a message.,The sender SHOULD generate a Trailer header field in the header section of the message to indicate which fields might be present in the trailers.,Sender,SHOULD,A sender that intends to generate one or more trailer fields in a message SHOULD generate a Trailer header field in the header section of that message to indicate which fields might be present in the trailers.,"For example, a sender might indicate that a signature will be computed as the content is being streamed and provide the final signature as a trailer field. This allows a recipient to perform the same check on the fly as it receives the content.","If an intermediary discards the trailer section in transit, the Trailer field could provide a hint of what metadata was lost, though there is no guarantee that a sender of Trailer will always follow through by sending the named fields.",6.6.2,Trailer,3,3,1,,"Trailer,trailer",,,,,SHOULD
"When a field aside from Connection is used to supply control information for or about the current connection, the sender MUST list the corresponding field name within the Connection header field",A field (other than Connection) is used to supply control information for or about the current connection.,The sender MUST list the corresponding field name within the Connection header field.,Sender,MUST,"When a field aside from Connection is used to supply control information for or about the current connection, the sender MUST list the corresponding field name within the Connection header field. Note that some versions of HTTP prohibit the use of fields for such information, and therefore do not allow the Connection field.",Connection options are case-insensitive.,"Intermediaries MUST parse a received Connection header field before a message is forwarded and, for each connection-option in this field, remove any header or trailer field(s) from the message with the same name as the connection-option, and then remove the Connection header field itself (or replace it with the intermediary's own control options for the forwarded message).",7.6.1,Connection,3,3,1,,Connection,,,,,MUST
A recipient MAY ignore a Max-Forwards header field received with any other request methods.,A Max-Forwards header field is received with a request method other than TRACE or OPTIONS.,The recipient MAY ignore the received Max-Forwards header field.,Recipient,MAY,A recipient MAY ignore a Max-Forwards header field received with any other request methods.,"Each intermediary that receives a TRACE or OPTIONS request containing a Max-Forwards header field MUST check and update its value prior to forwarding the request. If the received value is zero (0), the intermediary MUST NOT forward the request; instead, the intermediary MUST respond as the final recipient. If the received Max-Forwards value is greater than zero, the intermediary MUST generate an updated Max-Forwards field in the forwarded message with a field value that is the lesser of a) the received value decremented by one (1) or b) the recipient's maximum supported value for Max-Forwards.",,7.6.2,Max-Forwards,3,4,1,,Max-Forwards,,,,,MAY
"A sender MAY generate comments to identify the software of each recipient, analogous to the User-Agent and Server header fields","When the sender is constructing the Via header field in an HTTP message for forwarding to recipients (i.e., during message processing where recipient information is included)","The sender MAY generate comments that identify the software of each recipient, analogous to the User-Agent and Server header fields",Sender,MAY,"A sender MAY generate comments to identify the software of each recipient, analogous to the User-Agent and Server header fields. However, comments in Via are optional, and a recipient MAY remove them prior to forwarding the message.","The received-by portion is normally the host and optional port number of a recipient server or client that subsequently forwarded the message. However, if the real host is considered to be sensitive information, a sender MAY replace it with a pseudonym. If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.","For example, a request message could be sent from an HTTP/1.0 user agent to an internal proxy code-named ""fred"", which uses HTTP/1.1 to forward the request to a public proxy at p.example.net, which completes the request by forwarding it to the origin server at www.example.com. The request received by www.example.com would then have the following Via header field:",7.6.3,Via,3,6,1,,"Server,User-Agent",,,,,MAY
"However, comments in Via are optional, and a recipient MAY remove them prior to forwarding the message.",When a recipient is about to forward a message that contains the Via header field with optional comments,The recipient MAY remove the comments in the Via header prior to forwarding the message,Recipient,MAY,"A sender MAY generate comments to identify the software of each recipient, analogous to the User-Agent and Server header fields. However, comments in Via are optional, and a recipient MAY remove them prior to forwarding the message.","The received-by portion is normally the host and optional port number of a recipient server or client that subsequently forwarded the message. However, if the real host is considered to be sensitive information, a sender MAY replace it with a pseudonym. If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.","For example, a request message could be sent from an HTTP/1.0 user agent to an internal proxy code-named ""fred"", which uses HTTP/1.1 to forward the request to a public proxy at p.example.net, which completes the request by forwarding it to the origin server at www.example.com. The request received by www.example.com would then have the following Via header field:",7.6.3,Via,3,6,2,,Via,,,,,MAY
A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection.,An Upgrade header field is received on the connection and the server chooses to continue using the current protocol.,The server MAY ignore the received Upgrade header field.,Server,MAY,"A client MAY send a list of protocol names in the Upgrade header field of a request to invite the server to switch to one or more of the named protocols, in order of descending preference, before sending the final response. A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection. Upgrade cannot be used to insist on a protocol change.","The ""Upgrade"" header field is intended to provide a simple mechanism for transitioning from HTTP/1.1 to some other protocol on the same connection.","Although protocol names are registered with a preferred case, recipients SHOULD use case-insensitive comparison when matching each protocol-name to supported protocols.",7.8,Upgrade,2,2,2,,Upgrade,,,,,MAY
"A server that sends a 101 (Switching Protocols) response MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched; if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order.",A server sends a 101 (Switching Protocols) response,"The server MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched,If multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order",Server,MUST,"A server that sends a 101 (Switching Protocols) response MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched; if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order. A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field. A server MAY choose to ignore the order of preference indicated by the client and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.","Although protocol names are registered with a preferred case, recipients SHOULD use case-insensitive comparison when matching each protocol-name to supported protocols.","A server that sends a 426 (Upgrade Required) response MUST send an Upgrade header field to indicate the acceptable protocols, in order of descending preference.",7.8,Upgrade,2,4,1,101,Upgrade,,,,,MUST
A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field.,When the server is initiating a protocol switch as indicated by the corresponding request's Upgrade header field.,The server MUST NOT switch to any protocol that was not indicated by the client in the corresponding request's Upgrade header field.,Server,MUST NOT,"A server that sends a 101 (Switching Protocols) response MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched; if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order. A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field. A server MAY choose to ignore the order of preference indicated by the client and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.","Although protocol names are registered with a preferred case, recipients SHOULD use case-insensitive comparison when matching each protocol-name to supported protocols.","A server that sends a 426 (Upgrade Required) response MUST send an Upgrade header field to indicate the acceptable protocols, in order of descending preference.",7.8,Upgrade,2,4,2,,Upgrade,,,,,MUST
"A server that sends a 426 (Upgrade Required) response MUST send an Upgrade header field to indicate the acceptable protocols, in order of descending preference.",The server sends a 426 (Upgrade Required) response.,The server MUST send an Upgrade header field indicating the acceptable protocols in order of descending preference.,Server,MUST,"A server that sends a 426 (Upgrade Required) response MUST send an Upgrade header field to indicate the acceptable protocols, in order of descending preference.","A server that sends a 101 (Switching Protocols) response MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched; if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order. A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field. A server MAY choose to ignore the order of preference indicated by the client and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.","A server MAY send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.",7.8,Upgrade,2,5,1,426,Upgrade,,,,,MUST
"A server MAY send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.",When generating any response that is not a 426 (Upgrade Required) and when it is appropriate for a future request to upgrade protocols.,"The server MAY send an Upgrade header field in the response that advertises its support for upgrading to the listed protocols, listed in order of descending preference.",Server,MAY,"A server MAY send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.","A server that sends a 426 (Upgrade Required) response MUST send an Upgrade header field to indicate the acceptable protocols, in order of descending preference.",The following is a hypothetical example sent by a client:,7.8,Upgrade,2,6,1,,Upgrade,,,,,MAY
A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.,"When a server is set to switch protocols,When the new protocol does not inherently support honoring the semantics of the received message (with the exception that an OPTIONS request is not subject to this requirement)",The server MUST NOT switch protocols unless the new protocol can honor the received message semantics,Server,MUST NOT,"For example, if the Upgrade header field is received in a GET request and the server decides to switch protocols, it first responds with a 101 (Switching Protocols) message in HTTP/1.1 and then immediately follows that with the new protocol's equivalent of a response to a GET on the target resource. This allows a connection to be upgraded to protocols with the same semantics as HTTP without the latency cost of an additional round trip. A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.","The capabilities and nature of the application-level communication after the protocol change is entirely dependent upon the new protocol(s) chosen. However, immediately after sending the 101 (Switching Protocols) response, the server is expected to continue responding to the original request as if it had received its equivalent within the new protocol (i.e., the server still has an outstanding request to satisfy after the protocol has been changed, and is expected to do so without requiring the request to be repeated).",The following is an example response to the above hypothetical request:,7.8,Upgrade,2,10,3,,,,OPTIONS,,,MUST
"A sender of Upgrade MUST also send an ""Upgrade"" connection option in the Connection header field (Section 7.6.1) to inform intermediaries not to forward this field.",When a sender includes an Upgrade header field in its request.,"The sender MUST also include an ""Upgrade"" connection option in the Connection header field (Section 7.6.1) to inform intermediaries not to forward the Upgrade field.",Sender,MUST,"A sender of Upgrade MUST also send an ""Upgrade"" connection option in the Connection header field (Section 7.6.1) to inform intermediaries not to forward this field. A server that receives an Upgrade header field in an HTTP/1.0 request MUST ignore that Upgrade field.","[... data stream switches to websocket with an appropriate response (as defined by new protocol) to the ""GET /hello"" request ...]","A client cannot begin using an upgraded protocol on the connection until it has completely sent the request message (i.e., the client can't change the protocol it is sending in the middle of a message). If a server receives both an Upgrade and an Expect header field with the ""100-continue"" expectation (Section 10.1.1), the server MUST send a 100 (Continue) response before sending a 101 (Switching Protocols) response.",7.8,Upgrade,2,14,1,,"Connection,Upgrade",,,,,MUST
A server that receives an Upgrade header field in an HTTP/1.0 request MUST ignore that Upgrade field.,A server receives an Upgrade header field in an HTTP/1.0 request.,The server MUST ignore the Upgrade header field.,Server,MUST,"A sender of Upgrade MUST also send an ""Upgrade"" connection option in the Connection header field (Section 7.6.1) to inform intermediaries not to forward this field. A server that receives an Upgrade header field in an HTTP/1.0 request MUST ignore that Upgrade field.","[... data stream switches to websocket with an appropriate response (as defined by new protocol) to the ""GET /hello"" request ...]","A client cannot begin using an upgraded protocol on the connection until it has completely sent the request message (i.e., the client can't change the protocol it is sending in the middle of a message). If a server receives both an Upgrade and an Expect header field with the ""100-continue"" expectation (Section 10.1.1), the server MUST send a 100 (Continue) response before sending a 101 (Switching Protocols) response.",7.8,Upgrade,2,14,2,,Upgrade,,,,,MUST
"If a server receives both an Upgrade and an Expect header field with the ""100-continue"" expectation (Section 10.1.1), the server MUST send a 100 (Continue) response before sending a 101 (Switching Protocols) response.",A server receives both an Upgrade header field and an Expect header field with the '100-continue' expectation.,The server MUST send a 100 (Continue) response before sending a 101 (Switching Protocols) response.,Server,MUST,"A client cannot begin using an upgraded protocol on the connection until it has completely sent the request message (i.e., the client can't change the protocol it is sending in the middle of a message). If a server receives both an Upgrade and an Expect header field with the ""100-continue"" expectation (Section 10.1.1), the server MUST send a 100 (Continue) response before sending a 101 (Switching Protocols) response.","A sender of Upgrade MUST also send an ""Upgrade"" connection option in the Connection header field (Section 7.6.1) to inform intermediaries not to forward this field. A server that receives an Upgrade header field in an HTTP/1.0 request MUST ignore that Upgrade field.","The Upgrade header field only applies to switching protocols on top of the existing connection; it cannot be used to switch the underlying connection (transport) protocol, nor to switch the existing communication to a different connection. For those purposes, it is more appropriate to use a 3xx (Redirection) response (Section 15.4).",7.8,Upgrade,2,15,2,"100,101","Expect,Upgrade,100-continue",,,,,MUST
A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,"A sender generates a message containing content,The intended media type of the enclosed representation is known to the sender",The sender SHOULD generate a Content-Type header field in the message,Sender,SHOULD,"A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender. If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type.",Content-Type: text/html; charset=ISO-8859-4,"In practice, resource owners do not always properly configure their origin server to provide the correct Content-Type for a given representation. Some user agents examine the content and, in certain cases, override the received type (for example, see [Sniffing]). This ""MIME sniffing"" risks drawing incorrect conclusions about the data, which might expose the user to additional security risks (e.g., ""privilege escalation""). Furthermore, distinct media types often share a common data format, differing only in how the data is intended to be processed, which is impossible to distinguish by inspecting the data alone. When sniffing is implemented, implementers are encouraged to provide a means for the user to disable it.",8.3,Content-Type,2,4,1,,Content-Type,,,,,SHOULD
"If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type.",A Content-Type header field is not present in the message.,"The recipient MAY either assume a media type of ""application/octet-stream"" or examine the data to determine its type.",Recipient,MAY,"A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender. If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type.",Content-Type: text/html; charset=ISO-8859-4,"In practice, resource owners do not always properly configure their origin server to provide the correct Content-Type for a given representation. Some user agents examine the content and, in certain cases, override the received type (for example, see [Sniffing]). This ""MIME sniffing"" risks drawing incorrect conclusions about the data, which might expose the user to additional security risks (e.g., ""privilege escalation""). Furthermore, distinct media types often share a common data format, differing only in how the data is intended to be processed, which is impossible to distinguish by inspecting the data alone. When sniffing is implemented, implementers are encouraged to provide a means for the user to disable it.",8.3,Content-Type,2,4,2,204,Content-Type,,,,,MAY
The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,"When generating the message body as a protocol element (i.e., in multipart message types where body parts are delineated)",The sender MUST generate only CRLF to represent line breaks between body parts.,Sender,MUST,"MIME provides for a number of ""multipart"" types --encapsulations of one or more representations within a single message body. All multipart types share a common syntax, as defined in Section 5.1.1 of [RFC2046], and include a boundary parameter as part of the media type value. The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.",,"HTTP message framing does not use the multipart boundary as an indicator of message body length, though it might be used by implementations that generate or process the content. For example, the ""multipart/form-data"" type is often used for carrying form data in a request, as described in [RFC7578], and the ""multipart/ byteranges"" type is defined by this specification for use in some 206 (Partial Content) responses (see Section 15.3.7).",8.3.3,Multipart Types,3,1,3,,,,,CRLF,,MUST
"If one or more encodings have been applied to a representation, the sender that applied the encodings MUST generate a Content-Encoding header field that lists the content codings in the order in which they were applied.",One or more encodings have been applied to a representation.,The sender that applied the encodings MUST generate a Content-Encoding header field that lists the content codings in the order in which they were applied.,Sender,MUST,"If one or more encodings have been applied to a representation, the sender that applied the encodings MUST generate a Content-Encoding header field that lists the content codings in the order in which they were applied. Note that the coding named ""identity"" is reserved for its special role in Accept-Encoding and thus SHOULD NOT be included.",Content-Encoding: gzip,Additional information about the encoding parameters can be provided by other header fields not defined by this specification.,8.4,Content-Encoding,2,4,1,,Content-Encoding,,,,,MUST
"Note that the coding named ""identity"" is reserved for its special role in Accept-Encoding and thus SHOULD NOT be included.",When generating the Content-Encoding header field that lists one or more applied content codings,"Do not include the coding named 'identity' in the list, as it is reserved for its special role in Accept-Encoding",Sender,SHOULD NOT,"If one or more encodings have been applied to a representation, the sender that applied the encodings MUST generate a Content-Encoding header field that lists the content codings in the order in which they were applied. Note that the coding named ""identity"" is reserved for its special role in Accept-Encoding and thus SHOULD NOT be included.",Content-Encoding: gzip,Additional information about the encoding parameters can be provided by other header fields not defined by this specification.,8.4,Content-Encoding,2,4,2,,"Accept,Accept-Encoding",identity,,,,SHOULD
An origin server MAY respond with a status code of 415 (Unsupported Media Type) if a representation in the request message has a content coding that is not acceptable.,A representation in the request message has a content coding that is not acceptable.,The origin server MAY respond with a status code of 415 (Unsupported Media Type).,Origin Server,MAY,An origin server MAY respond with a status code of 415 (Unsupported Media Type) if a representation in the request message has a content coding that is not acceptable.,"If the media type includes an inherent encoding, such as a data format that is always compressed, then that encoding would not be restated in Content-Encoding even if it happens to be the same algorithm as one of the content codings. Such a content coding would only be listed if, for some bizarre reason, it is applied a second time to form the representation. Likewise, an origin server might choose to publish the same data as multiple representations that differ only in whether the coding is defined as part of Content-Type or Content-Encoding, since some user agents will behave differently in their handling of each response (e.g., open a ""Save as ..."" dialog instead of automatic decompression and rendering of content).",,8.4,Content-Encoding,2,8,1,415,,,,,,MAY
"A recipient SHOULD consider ""x-compress"" to be equivalent to ""compress"".","When a recipient encounters the content-coding value ""x-compress"" (e.g., as found in the Accept-Encoding or Content-Encoding header fields)","The recipient SHOULD treat ""x-compress"" as equivalent to ""compress"" and process it accordingly.",Recipient,SHOULD,"The ""compress"" coding is an adaptive Lempel-Ziv-Welch (LZW) coding [Welch] that is commonly produced by the UNIX file compression program ""compress"". A recipient SHOULD consider ""x-compress"" to be equivalent to ""compress"".",Content-coding values are used in the Accept-Encoding (Section 12.5.3) and Content-Encoding (Section 8.4) header fields.,"The ""deflate"" coding is a ""zlib"" data format [RFC1950] containing a ""deflate"" compressed data stream [RFC1951] that uses a combination of the Lempel-Ziv (LZ77) compression algorithm and Huffman coding.",8.4.1,Content Codings,3,4,2,,,"compress,x-compress",,,,SHOULD
"A recipient SHOULD consider ""x-gzip"" to be equivalent to ""gzip"".",When a recipient encounters the compression coding identifier 'x-gzip',The recipient SHOULD consider 'x-gzip' to be equivalent to 'gzip',Recipient,SHOULD,"The ""gzip"" coding is an LZ77 coding with a 32-bit Cyclic Redundancy Check (CRC) that is commonly produced by the gzip file compression program [RFC1952]. A recipient SHOULD consider ""x-gzip"" to be equivalent to ""gzip"".","The ""deflate"" coding is a ""zlib"" data format [RFC1950] containing a ""deflate"" compressed data stream [RFC1951] that uses a combination of the Lempel-Ziv (LZ77) compression algorithm and Huffman coding.",,8.4.1,Content Codings,3,6,2,,,"gzip,x-gzip",,,,SHOULD
Content-Language MAY be applied to any media type --it is not limited to textual documents.,,Content-Language may be applied to any media type and is not limited to textual documents.,Sender,MAY,Content-Language MAY be applied to any media type --it is not limited to textual documents.,"However, just because multiple languages are present within a representation does not mean that it is intended for multiple linguistic audiences. An example would be a beginner's language primer, such as ""A First Lesson in Latin"", which is clearly intended to be used by an English-literate audience. In this case, the Content-Language would properly only include ""en"".",,8.5,Content-Language,2,8,1,,Content-Language,,,,,MAY
A server MAY send a Content-Length header field in a response to a HEAD request (Section 9.3.2); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a response if the same request had used the GET method.,When a server is generating a response to a HEAD request and considers sending a Content-Length header field,The server MUST NOT include the Content-Length header field in the response unless its value equals the decimal number of octets that would have been sent in the content of the response if the request had used the GET method,Server,"MUST NOT, MAY",A server MAY send a Content-Length header field in a response to a HEAD request (Section 9.3.2); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a response if the same request had used the GET method.,"A user agent SHOULD send Content-Length in a request when the method defines a meaning for enclosed content and it is not sending Transfer-Encoding. For example, a user agent normally sends Content-Length in a POST request even when the value is 0 (indicating empty content). A user agent SHOULD NOT send a Content-Length header field when the request message does not contain content and the method semantics do not anticipate such data.",A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,8.6,Content-Length,2,5,1,,Content-Length,,"GET,HEAD",,,MUST
A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,When a server sends a 304 (Not Modified) response to a conditional GET request including a Content-Length header field.,The server MUST NOT send the Content-Length header field in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,Server,"MUST NOT, MAY",A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,A server MAY send a Content-Length header field in a response to a HEAD request (Section 9.3.2); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a response if the same request had used the GET method.,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content). A server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6).,8.6,Content-Length,2,6,1,"200,304",Content-Length,,GET,,,MUST
A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,"Response has a status code of 1xx (Informational),Response has a status code of 204 (No Content)",The server MUST NOT send a Content-Length header field in the response,Server,MUST NOT,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content). A server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6).,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section. This will allow downstream recipients to measure transfer progress, know when a received message is complete, and potentially reuse the connection for additional requests.",8.6,Content-Length,2,7,1,"1xx,204",Content-Length,,,,,MUST
A server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6).,A response is a 2xx (Successful) response to a CONNECT request,The server MUST NOT send a Content-Length header field in the response,Server,MUST NOT,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content). A server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6).,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section. This will allow downstream recipients to measure transfer progress, know when a received message is complete, and potentially reuse the connection for additional requests.",8.6,Content-Length,2,7,2,2xx,Content-Length,,CONNECT,,,MUST
"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.","Transfer-Encoding header field is absent,The content size is known prior to sending the complete header section,The response does not fall into the exceptional cases defined above (status codes 1xx, 204, or 2xx for CONNECT requests)",The origin server SHOULD send a Content-Length header field,Origin Server,SHOULD,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section. This will allow downstream recipients to measure transfer progress, know when a received message is complete, and potentially reuse the connection for additional requests.",A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content). A server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6).,"Any Content-Length field value greater than or equal to zero is valid. Since there is no predefined limit to the length of content, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer conversion (Section 17.5).",8.6,Content-Length,2,8,1,,"Content-Length,Transfer-Encoding",,,,,SHOULD
"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",A message with a Content-Length header field value that is known to be incorrect,The sender MUST NOT forward the message,Sender,MUST NOT,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.","Because Content-Length is used for message delimitation in HTTP/1.1, its field value can impact how the message is parsed by downstream recipients even when the immediate connection is not using HTTP/1.1. If the message is forwarded by a downstream intermediary, a Content-Length field value that is inconsistent with the received message framing might cause a security failure due to request smuggling or response splitting.","Likewise, a sender MUST NOT forward a message with a Content-Length header field value that does not match the ABNF above, with one exception: a recipient of a Content-Length header field value consisting of the same decimal value repeated as a comma-separated list (e.g, ""Content-Length: 42, 42"") MAY either reject the message as invalid or replace that invalid field value with a single instance of the decimal value, since this likely indicates that a duplicate was generated or combined by an upstream message processor.",8.6,Content-Length,2,11,1,,Content-Length,,,,,MUST
"Likewise, a sender MUST NOT forward a message with a Content-Length header field value that does not match the ABNF above, with one exception: a recipient of a Content-Length header field value consisting of the same decimal value repeated as a comma-separated list (e.g, ""Content-Length: 42, 42"") MAY either reject the message as invalid or replace that invalid field value with a single instance of the decimal value, since this likely indicates that a duplicate was generated or combined by an upstream message processor.","A message with a Content-Length header field value that does not match the ABNF defined above.,Exception: A message where the Content-Length header field value consists of the same decimal value repeated as a comma‐separated list (e.g., 'Content-Length: 42, 42').","For senders: MUST NOT forward a message whose Content-Length header field value does not match the ABNF.,For recipients (in the exception case): MAY either reject the message as invalid or replace the invalid header field value with a single instance of the decimal value.","Sender,Recipient","MUST NOT, MAY","Likewise, a sender MUST NOT forward a message with a Content-Length header field value that does not match the ABNF above, with one exception: a recipient of a Content-Length header field value consisting of the same decimal value repeated as a comma-separated list (e.g, ""Content-Length: 42, 42"") MAY either reject the message as invalid or replace that invalid field value with a single instance of the decimal value, since this likely indicates that a duplicate was generated or combined by an upstream message processor.","As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",,8.6,Content-Length,2,12,1,,Content-Length,,,,,MUST
"If Content-Location is included in a 2xx (Successful) response message and its value refers (after conversion to absolute form) to a URI that is the same as the target URI, then the recipient MAY consider the content to be a current representation of that resource at the time indicated by the message origination date.","Content-Location header is included in a 2xx (Successful) response message,The value of the Content-Location header, when converted to an absolute URI, is identical to the target URI",The recipient MAY consider the content to be a current representation of the resource at the time indicated by the message origination date,Recipient,MAY,"If Content-Location is included in a 2xx (Successful) response message and its value refers (after conversion to absolute form) to a URI that is the same as the target URI, then the recipient MAY consider the content to be a current representation of that resource at the time indicated by the message origination date. For a GET (Section 9.3.1) or HEAD (Section 9.3.2) request, this is the same as the default semantics when no Content-Location is provided by the server. For a state-changing request like PUT (Section 9.3.4) or POST (Section 9.3.3), it implies that the server's response contains the new representation of that resource, thereby distinguishing it from representations that might only report about the action (e.g., ""It worked!""). This allows authoring applications to update their local copies without the need for a subsequent GET request.","The Content-Location value is not a replacement for the target URI (Section 7.1). It is representation metadata. It has the same syntax and semantics as the header field of the same name defined for MIME body parts in Section 4 of [RFC2557]. However, its appearance in an HTTP message has some special implications for HTTP recipients.","If Content-Location is included in a 2xx (Successful) response message and its field value refers to a URI that differs from the target URI, then the origin server claims that the URI is an identifier for a different resource corresponding to the enclosed representation. Such a claim can only be trusted if both identifiers share the same resource owner, which cannot be programmatically determined via HTTP.",8.7,Content-Location,2,4,1,2xx,"Content-Location,Location",,,,,MAY
An origin server that receives a Content-Location field in a request message MUST treat the information as transitory request context rather than as metadata to be saved verbatim as part of the representation.,The origin server receives a request message containing a Content-Location field.,The origin server MUST treat the Content-Location information as transitory request context rather than as metadata to be saved verbatim as part of the representation.,Origin Server,MUST,"An origin server that receives a Content-Location field in a request message MUST treat the information as transitory request context rather than as metadata to be saved verbatim as part of the representation. An origin server MAY use that context to guide in processing the request or to save it for other uses, such as within source links or versioning metadata. However, an origin server MUST NOT use such context information to alter the request semantics.","A user agent that sends Content-Location in a request message is stating that its value refers to where the user agent originally obtained the content of the enclosed representation (prior to any modifications made by that user agent). In other words, the user agent is providing a back link to the source of the original representation.","For example, if a client makes a PUT request on a negotiated resource and the origin server accepts that PUT (without redirection), then the new state of that resource is expected to be consistent with the one representation supplied in that PUT; the Content-Location cannot be used as a form of reverse content selection identifier to update only one of the negotiated representations. If the user agent had wanted the latter semantics, it would have applied the PUT directly to the Content-Location URI.",8.7,Content-Location,2,10,1,,"Content-Location,Location",,,,,MUST
"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.",For any selected representation where a last modification date can be reasonably and consistently determined,The origin server SHOULD send the Last-Modified header for that representation,Origin Server,SHOULD,"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.","Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT",A representation is typically the sum of many parts behind the resource interface. The last-modified time would usually be the most recent time that any of those parts were changed. How that value is determined for any given resource is an implementation detail beyond the scope of this specification.,8.8.2,Last-Modified,3,4,1,,Last-Modified,,,,,SHOULD
An origin server SHOULD obtain the Last-Modified value of the representation as close as possible to the time that it generates the Date field value for its response.,When the origin server generates the Date field value for its response,The origin server SHOULD obtain the Last-Modified value of the representation as close as possible to the time it generates the Date field value,Origin Server,SHOULD,"An origin server SHOULD obtain the Last-Modified value of the representation as close as possible to the time that it generates the Date field value for its response. This allows a recipient to make an accurate assessment of the representation's modification time, especially if the representation changes near the time that the response is generated.",A representation is typically the sum of many parts behind the resource interface. The last-modified time would usually be the most recent time that any of those parts were changed. How that value is determined for any given resource is an implementation detail beyond the scope of this specification.,"An origin server with a clock (as defined in Section 5.6.7) MUST NOT generate a Last-Modified date that is later than the server's time of message origination (Date, Section 6.6.1). If the last modification time is derived from implementation-specific metadata that evaluates to some time in the future, according to the origin server's clock, then the origin server MUST replace that value with the message origination date. This prevents a future modification date from having an adverse impact on cache validation.",8.8.2,Last-Modified,3,6,1,,"Date,Last-Modified",,,,,SHOULD
"An origin server with a clock (as defined in Section 5.6.7) MUST NOT generate a Last-Modified date that is later than the server's time of message origination (Date, Section 6.6.1).","The origin server has a clock and is generating a Last-Modified date for a response.,The Last-Modified value is derived from implementation-specific metadata that evaluates to a time later than the server's time of message origination.","The origin server MUST NOT generate a Last-Modified date that is later than the server's time of message origination. If the computed Last-Modified date is in the future, it MUST be replaced with the message origination date.",Origin Server,MUST NOT,"An origin server with a clock (as defined in Section 5.6.7) MUST NOT generate a Last-Modified date that is later than the server's time of message origination (Date, Section 6.6.1). If the last modification time is derived from implementation-specific metadata that evaluates to some time in the future, according to the origin server's clock, then the origin server MUST replace that value with the message origination date. This prevents a future modification date from having an adverse impact on cache validation.","An origin server SHOULD obtain the Last-Modified value of the representation as close as possible to the time that it generates the Date field value for its response. This allows a recipient to make an accurate assessment of the representation's modification time, especially if the representation changes near the time that the response is generated.",An origin server without a clock MUST NOT generate a Last-Modified date for a response unless that date value was assigned to the resource by some other system (presumably one with a clock).,8.8.2,Last-Modified,3,7,1,,"Date,Last-Modified",,,,,MUST
An origin server without a clock MUST NOT generate a Last-Modified date for a response unless that date value was assigned to the resource by some other system (presumably one with a clock).,"The origin server is operating without a clock,No Last-Modified date value was externally assigned to the resource by another system (i.e., one with a clock)",The server MUST NOT generate a Last-Modified date for a response,Origin Server,MUST NOT,An origin server without a clock MUST NOT generate a Last-Modified date for a response unless that date value was assigned to the resource by some other system (presumably one with a clock).,"An origin server with a clock (as defined in Section 5.6.7) MUST NOT generate a Last-Modified date that is later than the server's time of message origination (Date, Section 6.6.1). If the last modification time is derived from implementation-specific metadata that evaluates to some time in the future, according to the origin server's clock, then the origin server MUST replace that value with the message origination date. This prevents a future modification date from having an adverse impact on cache validation.","A Last-Modified time, when used as a validator in a request, is implicitly weak unless it is possible to deduce that it is strong, using the following rules:",8.8.2,Last-Modified,3,8,1,,Last-Modified,,,,,MUST
A sender MAY send the ETag field in a trailer section (see Section 6.5).,,The sender MAY send the ETag field in a trailer section (see Section 6.5).,Sender,MAY,"A sender MAY send the ETag field in a trailer section (see Section 6.5). However, since trailers are often ignored, it is preferable to send ETag as a header field unless the entity tag is generated while sending the content.","An entity tag can be either a weak or strong validator, with strong being the default. If an origin server provides an entity tag for a representation and the generation of that entity tag does not satisfy all of the characteristics of a strong validator (Section 8.8.1), then the origin server MUST mark the entity tag as weak by prefixing its opaque value with ""W/"" (case-sensitive).","The principle behind entity tags is that only the service author knows the implementation of a resource well enough to select the most accurate and efficient validation mechanism for that resource, and that any such mechanism can be mapped to a simple sequence of octets for easy comparison. Since the value is opaque, there is no need for the client to be aware of how each entity tag is constructed.",8.8.3,ETag,3,6,1,,"ETag,trailer",,,,,MAY
"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.",A selected representation for which detection of changes can be reasonably and consistently determined,The origin server SHOULD send an ETag for the selected representation,Origin Server,SHOULD,"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.","For example, a resource that has implementation-specific versioning applied to all changes might use an internal revision number, perhaps combined with a variance identifier for content negotiation, to accurately differentiate between representations. Other implementations might use a collision-resistant hash of representation content, a combination of various file attributes, or a modification timestamp that has sub-second resolution.","There are two entity tag comparison functions, depending on whether or not the comparison context allows the use of weak validators:",8.8.3,ETag,3,9,1,,ETag,,,,,SHOULD
All general-purpose servers MUST support the methods GET and HEAD,The server is classified as a general-purpose server.,The server MUST support the HTTP methods GET and HEAD.,Server,MUST,All general-purpose servers MUST support the methods GET and HEAD. All other methods are OPTIONAL.,"+=========+============================================+=========+ | Method | Description | Section | | Name | | | +=========+============================================+=========+ | GET | Transfer a current representation of the | 9.3.1 | | | target resource. | | +---------+--------------------------------------------+---------+ | HEAD | Same as GET, but do not transfer the | 9.3.2 | | | response content. | | +---------+--------------------------------------------+---------+ | POST | Perform resource-specific processing on | 9.3.3 | | | the request content. | | +---------+--------------------------------------------+---------+ | PUT | Replace all current representations of the | 9.3.4 | | | target resource with the request content. | | +---------+--------------------------------------------+---------+ | DELETE | Remove all current representations of the | 9.3.5 | | | target resource. | | +---------+--------------------------------------------+---------+ | CONNECT | Establish a tunnel to the server | 9.3.6 | | | identified by the target resource. | | +---------+--------------------------------------------+---------+ | OPTIONS | Describe the communication options for the | 9.3.7 | | | target resource. | | +---------+--------------------------------------------+---------+ | TRACE | Perform a message loop-back test along the | 9.3.8 | | | path to the target resource. | | +---------+--------------------------------------------+---------+","The set of methods allowed by a target resource can be listed in an Allow header field (Section 10.2.1). However, the set of allowed methods can change dynamically. An origin server that receives a request method that is unrecognized or not implemented SHOULD respond with the 501 (Not Implemented) status code. An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",9.1,Overview,2,8,1,,,,"GET,HEAD",,,MUST
An origin server that receives a request method that is unrecognized or not implemented SHOULD respond with the 501 (Not Implemented) status code.,"The origin server receives a request method that is unrecognized,The origin server receives a request method that is not implemented",The origin server SHOULD respond with the 501 (Not Implemented) status code,Origin Server,SHOULD,"The set of methods allowed by a target resource can be listed in an Allow header field (Section 10.2.1). However, the set of allowed methods can change dynamically. An origin server that receives a request method that is unrecognized or not implemented SHOULD respond with the 501 (Not Implemented) status code. An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",All general-purpose servers MUST support the methods GET and HEAD. All other methods are OPTIONAL.,"Additional methods, outside the scope of this specification, have been specified for use in HTTP. All such methods ought to be registered within the ""Hypertext Transfer Protocol (HTTP) Method Registry"", as described in Section 16.1.",9.1,Overview,2,9,3,501,,,,,,SHOULD
"An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",The origin server receives a request method that is recognized and implemented but is not allowed for the target resource.,The origin server SHOULD respond with the 405 (Method Not Allowed) status code.,Origin Server,SHOULD,"The set of methods allowed by a target resource can be listed in an Allow header field (Section 10.2.1). However, the set of allowed methods can change dynamically. An origin server that receives a request method that is unrecognized or not implemented SHOULD respond with the 501 (Not Implemented) status code. An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",All general-purpose servers MUST support the methods GET and HEAD. All other methods are OPTIONAL.,"Additional methods, outside the scope of this specification, have been specified for use in HTTP. All such methods ought to be registered within the ""Hypertext Transfer Protocol (HTTP) Method Registry"", as described in Section 16.1.",9.1,Overview,2,9,4,405,,,,,,SHOULD
The HEAD method is identical to GET except that the server MUST NOT send content in the response.,When a client issues a HEAD method request (as opposed to a GET).,The server MUST NOT send content in the response.,Server,MUST NOT,"The HEAD method is identical to GET except that the server MUST NOT send content in the response. HEAD is used to obtain metadata about the selected representation without transferring its representation data, often for the sake of testing hypertext links or finding recent modifications.",,"The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request method had been GET. However, a server MAY omit header fields for which a value is determined only while generating the content. For example, some servers buffer a dynamic response to GET until a minimum amount of data is generated so that they can more efficiently delimit small responses or make late decisions with regard to content selection. Such a response to GET might contain Content-Length and Vary fields, for example, that are not generated within a HEAD response. These minor inconsistencies are considered preferable to generating and discarding the content for a HEAD request, since HEAD is usually requested for the sake of efficiency.",9.3.2,HEAD,3,1,1,,,,"GET,HEAD",,,MUST
The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request method had been GET,A HEAD request is received by the server.,"The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request method had been GET, with the exception that header fields determined solely during content generation may be omitted.",Server,SHOULD,"The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request method had been GET. However, a server MAY omit header fields for which a value is determined only while generating the content. For example, some servers buffer a dynamic response to GET until a minimum amount of data is generated so that they can more efficiently delimit small responses or make late decisions with regard to content selection. Such a response to GET might contain Content-Length and Vary fields, for example, that are not generated within a HEAD response. These minor inconsistencies are considered preferable to generating and discarding the content for a HEAD request, since HEAD is usually requested for the sake of efficiency.","The HEAD method is identical to GET except that the server MUST NOT send content in the response. HEAD is used to obtain metadata about the selected representation without transferring its representation data, often for the sake of testing hypertext links or finding recent modifications.","Although request message framing is independent of the method used, content received in a HEAD request has no generally defined semantics, cannot alter the meaning or target of the request, and might lead some implementations to reject the request and close the connection because of its potential as a request smuggling attack (Section 11.2 of [HTTP/1.1]). A client SHOULD NOT generate content in a HEAD request unless it is made directly to an origin server that has previously indicated, in or out of band, that such a request has a purpose and will be adequately supported. An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",9.3.2,HEAD,3,2,1,,,,"GET,HEAD",,,SHOULD
"If one or more resources has been created on the origin server as a result of successfully processing a POST request, the origin server SHOULD send a 201 (Created) response containing a Location header field that provides an identifier for the primary resource created (Section 10.2.2) and a representation that describes the status of the request while referring to the new resource(s).",One or more resources has been created on the origin server as a result of successfully processing a POST request,The origin server SHOULD send a 201 (Created) response containing a Location header field that provides an identifier for the primary resource created and a representation that describes the status of the request while referring to the new resource(s),Origin Server,SHOULD,"If one or more resources has been created on the origin server as a result of successfully processing a POST request, the origin server SHOULD send a 201 (Created) response containing a Location header field that provides an identifier for the primary resource created (Section 10.2.2) and a representation that describes the status of the request while referring to the new resource(s).","An origin server indicates response semantics by choosing an appropriate status code depending on the result of processing the POST request; almost all of the status codes defined by this specification could be received in a response to POST (the exceptions being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not Satisfiable)).","Responses to POST requests are only cacheable when they include explicit freshness information (see Section 4.2.1 of [CACHING]) and a Content-Location header field that has the same value as the POST's target URI (Section 8.7). A cached POST response can be reused to satisfy a later GET or HEAD request. In contrast, a POST request cannot be satisfied by a cached POST response because POST is potentially unsafe; see Section 4 of [CACHING].",9.3.3,POST,3,7,1,201,Location,,POST,,,SHOULD
"If the result of processing a POST would be equivalent to a representation of an existing resource, an origin server MAY redirect the user agent to that resource by sending a 303 (See Other) response with the existing resource's identifier in the Location field.",The result of processing a POST would be equivalent to a representation of an existing resource.,The origin server MAY redirect the user agent to that resource by sending a 303 (See Other) response with the existing resource's identifier in the Location field.,Origin Server,MAY,"If the result of processing a POST would be equivalent to a representation of an existing resource, an origin server MAY redirect the user agent to that resource by sending a 303 (See Other) response with the existing resource's identifier in the Location field. This has the benefits of providing the user agent a resource identifier and transferring the representation via a method more amenable to shared caching, though at the cost of an extra request if the user agent does not already have the representation cached.","Responses to POST requests are only cacheable when they include explicit freshness information (see Section 4.2.1 of [CACHING]) and a Content-Location header field that has the same value as the POST's target URI (Section 8.7). A cached POST response can be reused to satisfy a later GET or HEAD request. In contrast, a POST request cannot be satisfied by a cached POST response because POST is potentially unsafe; see Section 4 of [CACHING].",,9.3.3,POST,3,9,1,303,Location,,POST,,,MAY
"If the target resource does not have a current representation and the PUT successfully creates one, then the origin server MUST inform the user agent by sending a 201 (Created) response.",The target resource does not have a current representation and the PUT operation successfully creates a representation.,The origin server MUST inform the user agent by sending a 201 (Created) response.,Origin Server,MUST,"If the target resource does not have a current representation and the PUT successfully creates one, then the origin server MUST inform the user agent by sending a 201 (Created) response. If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server MUST send either a 200 (OK) or a 204 (No Content) response to indicate successful completion of the request.","The PUT method requests that the state of the target resource be created or replaced with the state defined by the representation enclosed in the request message content. A successful PUT of a given representation would suggest that a subsequent GET on that same target resource will result in an equivalent representation being sent in a 200 (OK) response. However, there is no guarantee that such a state change will be observable, since the target resource might be acted upon by other user agents in parallel, or might be subject to dynamic processing by the origin server, before any subsequent GET is received. A successful response only implies that the user agent's intent was achieved at the time of its processing by the origin server.","An origin server SHOULD verify that the PUT representation is consistent with its configured constraints for the target resource. For example, if an origin server determines a resource's representation metadata based on the URI, then the origin server needs to ensure that the content received in a successful PUT request is consistent with that metadata. When a PUT representation is inconsistent with the target resource, the origin server SHOULD either make them consistent, by transforming the representation or changing the resource configuration, or respond with an appropriate error message containing sufficient information to explain why the representation is unsuitable. The 409 (Conflict) or 415 (Unsupported Media Type) status codes are suggested, with the latter being specific to constraints on Content-Type values.",9.3.4,PUT,3,2,1,201,,,PUT,,,MUST
"If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server MUST send either a 200 (OK) or a 204 (No Content) response to indicate successful completion of the request.",The target resource has a current representation and that representation is successfully modified in accordance with the state of the enclosed representation,The origin server MUST send either a 200 (OK) or a 204 (No Content) response to indicate successful completion of the request,Origin Server,MUST,"If the target resource does not have a current representation and the PUT successfully creates one, then the origin server MUST inform the user agent by sending a 201 (Created) response. If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server MUST send either a 200 (OK) or a 204 (No Content) response to indicate successful completion of the request.","The PUT method requests that the state of the target resource be created or replaced with the state defined by the representation enclosed in the request message content. A successful PUT of a given representation would suggest that a subsequent GET on that same target resource will result in an equivalent representation being sent in a 200 (OK) response. However, there is no guarantee that such a state change will be observable, since the target resource might be acted upon by other user agents in parallel, or might be subject to dynamic processing by the origin server, before any subsequent GET is received. A successful response only implies that the user agent's intent was achieved at the time of its processing by the origin server.","An origin server SHOULD verify that the PUT representation is consistent with its configured constraints for the target resource. For example, if an origin server determines a resource's representation metadata based on the URI, then the origin server needs to ensure that the content received in a successful PUT request is consistent with that metadata. When a PUT representation is inconsistent with the target resource, the origin server SHOULD either make them consistent, by transforming the representation or changing the resource configuration, or respond with an appropriate error message containing sufficient information to explain why the representation is unsuitable. The 409 (Conflict) or 415 (Unsupported Media Type) status codes are suggested, with the latter being specific to constraints on Content-Type values.",9.3.4,PUT,3,2,2,"200,204",,,,,,MUST
An origin server SHOULD verify that the PUT representation is consistent with its configured constraints for the target resource,When a PUT representation is received for the target resource,The origin server SHOULD verify that the PUT representation is consistent with its configured constraints for the target resource,Origin Server,SHOULD,"An origin server SHOULD verify that the PUT representation is consistent with its configured constraints for the target resource. For example, if an origin server determines a resource's representation metadata based on the URI, then the origin server needs to ensure that the content received in a successful PUT request is consistent with that metadata. When a PUT representation is inconsistent with the target resource, the origin server SHOULD either make them consistent, by transforming the representation or changing the resource configuration, or respond with an appropriate error message containing sufficient information to explain why the representation is unsuitable. The 409 (Conflict) or 415 (Unsupported Media Type) status codes are suggested, with the latter being specific to constraints on Content-Type values.","If the target resource does not have a current representation and the PUT successfully creates one, then the origin server MUST inform the user agent by sending a 201 (Created) response. If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server MUST send either a 200 (OK) or a 204 (No Content) response to indicate successful completion of the request.","For example, if the target resource is configured to always have a Content-Type of ""text/html"" and the representation being PUT has a Content-Type of ""image/jpeg"", the origin server ought to do one of:",9.3.4,PUT,3,3,1,,,,PUT,,,SHOULD
"When a PUT representation is inconsistent with the target resource, the origin server SHOULD either make them consistent, by transforming the representation or changing the resource configuration, or respond with an appropriate error message containing sufficient information to explain why the representation is unsuitable.",A PUT representation is inconsistent with the target resource.,The origin server SHOULD either make the representation and resource consistent (by transforming the representation or changing the resource configuration) or respond with an appropriate error message containing sufficient information to explain why the representation is unsuitable.,Origin Server,SHOULD,"An origin server SHOULD verify that the PUT representation is consistent with its configured constraints for the target resource. For example, if an origin server determines a resource's representation metadata based on the URI, then the origin server needs to ensure that the content received in a successful PUT request is consistent with that metadata. When a PUT representation is inconsistent with the target resource, the origin server SHOULD either make them consistent, by transforming the representation or changing the resource configuration, or respond with an appropriate error message containing sufficient information to explain why the representation is unsuitable. The 409 (Conflict) or 415 (Unsupported Media Type) status codes are suggested, with the latter being specific to constraints on Content-Type values.","If the target resource does not have a current representation and the PUT successfully creates one, then the origin server MUST inform the user agent by sending a 201 (Created) response. If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server MUST send either a 200 (OK) or a 204 (No Content) response to indicate successful completion of the request.","For example, if the target resource is configured to always have a Content-Type of ""text/html"" and the representation being PUT has a Content-Type of ""image/jpeg"", the origin server ought to do one of:",9.3.4,PUT,3,3,3,,,,PUT,,,SHOULD
"As a result, an origin server SHOULD ignore unrecognized header and trailer fields received in a PUT request (i.e., not save them as part of the resource state).",A PUT request that contains unrecognized header and trailer fields.,"The origin server SHOULD ignore these unrecognized header and trailer fields, meaning that they should not be saved as part of the resource state.",Origin Server,SHOULD,"This extends to how header and trailer fields are stored; while common header fields like Content-Type will typically be stored and returned upon subsequent GET requests, header and trailer field handling is specific to the resource that received the request. As a result, an origin server SHOULD ignore unrecognized header and trailer fields received in a PUT request (i.e., not save them as part of the resource state).","HTTP does not define exactly how a PUT method affects the state of an origin server beyond what can be expressed by the intent of the user agent request and the semantics of the origin server response. It does not define what a resource might be, in any sense of that word, beyond the interface provided via HTTP. It does not define how resource state is ""stored"", nor how such storage might change as a result of a change in resource state, nor how the origin server translates resource state into representations. Generally speaking, all implementation details behind the resource interface are intentionally hidden by the server.","An origin server MUST NOT send a validator field (Section 8.8), such as an ETag or Last-Modified field, in a successful response to PUT unless the request's representation data was saved without any transformation applied to the content (i.e., the resource's new representation data is identical to the content received in the PUT request) and the validator field value reflects the new representation. This requirement allows a user agent to know when the representation it sent (and retains in memory) is the result of the PUT, and thus it doesn't need to be retrieved again from the origin server. The new validator(s) received in the response can be used for future conditional requests in order to prevent accidental overwrites (Section 13.1).",9.3.4,PUT,3,9,2,,trailer,,PUT,,,SHOULD
"An origin server MUST NOT send a validator field (Section 8.8), such as an ETag or Last-Modified field, in a successful response to PUT unless the request's representation data was saved without any transformation applied to the content (i.e., the resource's new representation data is identical to the content received in the PUT request) and the validator field value reflects the new representation.","When a successful response to a PUT request is being generated, if the request’s representation data was not saved without transformation (i.e., the new representation is not identical to the content received) or the validator field value does not reflect the new representation.",The origin server MUST NOT include any validator field (such as an ETag or Last-Modified field) in the successful response to the PUT request.,Origin Server,MUST NOT,"An origin server MUST NOT send a validator field (Section 8.8), such as an ETag or Last-Modified field, in a successful response to PUT unless the request's representation data was saved without any transformation applied to the content (i.e., the resource's new representation data is identical to the content received in the PUT request) and the validator field value reflects the new representation. This requirement allows a user agent to know when the representation it sent (and retains in memory) is the result of the PUT, and thus it doesn't need to be retrieved again from the origin server. The new validator(s) received in the response can be used for future conditional requests in order to prevent accidental overwrites (Section 13.1).","This extends to how header and trailer fields are stored; while common header fields like Content-Type will typically be stored and returned upon subsequent GET requests, header and trailer field handling is specific to the resource that received the request. As a result, an origin server SHOULD ignore unrecognized header and trailer fields received in a PUT request (i.e., not save them as part of the resource state).","The fundamental difference between the POST and PUT methods is highlighted by the different intent for the enclosed representation. The target resource in a POST request is intended to handle the enclosed representation according to the resource's own semantics, whereas the enclosed representation in a PUT request is defined as replacing the state of the target resource. Hence, the intent of PUT is idempotent and visible to intermediaries, even though the exact effect is only known by the origin server.",9.3.4,PUT,3,10,1,,"ETag,Last-Modified",,PUT,,,MUST
"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT","After receiving a state-changing request (i.e., when the service selects a proper URI on behalf of the client)",The service SHOULD be implemented using the POST method rather than PUT,Origin Server,SHOULD,"Proper interpretation of a PUT request presumes that the user agent knows which target resource is desired. A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT. If the origin server will not make the requested PUT state change to the target resource and instead wishes to have it applied to a different resource, such as when the resource has been moved to a different URI, then the origin server MUST send an appropriate 3xx (Redirection) response; the user agent MAY then make its own decision regarding whether or not to redirect the request.","The fundamental difference between the POST and PUT methods is highlighted by the different intent for the enclosed representation. The target resource in a POST request is intended to handle the enclosed representation according to the resource's own semantics, whereas the enclosed representation in a PUT request is defined as replacing the state of the target resource. Hence, the intent of PUT is idempotent and visible to intermediaries, even though the exact effect is only known by the origin server.","A PUT request applied to the target resource can have side effects on other resources. For example, an article might have a URI for identifying ""the current version"" (a resource) that is separate from the URIs identifying each particular version (different resources that at one point shared the same state as the current version resource). A successful PUT request on ""the current version"" URI might therefore create a new version resource in addition to changing the state of the target resource, and might also cause links to be added between the related resources.",9.3.4,PUT,3,12,2,,,,"POST,PUT",,,SHOULD
"If the origin server will not make the requested PUT state change to the target resource and instead wishes to have it applied to a different resource, such as when the resource has been moved to a different URI, then the origin server MUST send an appropriate 3xx (Redirection) response; the user agent MAY then make its own decision regarding whether or not to redirect the request.","The origin server will not make the requested PUT state change to the target resource,The origin server wishes the state change to be applied to a different resource (e.g., when the resource has been moved to another URI)",The origin server MUST send an appropriate 3xx (Redirection) response,Origin Server,"MUST, MAY","Proper interpretation of a PUT request presumes that the user agent knows which target resource is desired. A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT. If the origin server will not make the requested PUT state change to the target resource and instead wishes to have it applied to a different resource, such as when the resource has been moved to a different URI, then the origin server MUST send an appropriate 3xx (Redirection) response; the user agent MAY then make its own decision regarding whether or not to redirect the request.","The fundamental difference between the POST and PUT methods is highlighted by the different intent for the enclosed representation. The target resource in a POST request is intended to handle the enclosed representation according to the resource's own semantics, whereas the enclosed representation in a PUT request is defined as replacing the state of the target resource. Hence, the intent of PUT is idempotent and visible to intermediaries, even though the exact effect is only known by the origin server.","A PUT request applied to the target resource can have side effects on other resources. For example, an article might have a URI for identifying ""the current version"" (a resource) that is separate from the URIs identifying each particular version (different resources that at one point shared the same state as the current version resource). A successful PUT request on ""the current version"" URI might therefore create a new version resource in addition to changing the state of the target resource, and might also cause links to be added between the related resources.",9.3.4,PUT,3,12,3,3xx,,,PUT,,,MUST
"If a DELETE method is successfully applied, the origin server SHOULD send",A DELETE method is successfully applied.,"The origin server SHOULD send a response, such as a 202 (Accepted) status code if the action will likely succeed but has not yet been enacted.",Origin Server,SHOULD,"If a DELETE method is successfully applied, the origin server SHOULD send","Relatively few resources allow the DELETE method --its primary use is for remote authoring environments, where the user has some direction regarding its effect. For example, a resource that was previously created using a PUT request, or identified via the Location header field after a 201 (Created) response to a POST request, might allow a corresponding DELETE request to undo those actions. Similarly, custom user agent implementations that implement an authoring function, such as revision control clients using HTTP for remote operations, might use DELETE based on an assumption that the server's URI space has been crafted to correspond to a version repository.","* a 202 (Accepted) status code if the action will likely succeed but has not yet been enacted,",9.3.5,DELETE,3,4,1,,,,DELETE,,,SHOULD
"A server MUST reject a CONNECT request that targets an empty or invalid port number, typically by responding with a 400 (Bad Request) status code.",A CONNECT request that targets an empty or invalid port number,"The server MUST reject the CONNECT request, typically by responding with a 400 (Bad Request) status code",Server,MUST,"A server MUST reject a CONNECT request that targets an empty or invalid port number, typically by responding with a 400 (Bad Request) status code.",CONNECT server.example.com:80 HTTP/1.1 Host: server.example.com,"Because CONNECT changes the request/response nature of an HTTP connection, specific HTTP versions might have different ways of mapping its semantics into the protocol's wire format.",9.3.6,CONNECT,3,4,1,400,,,CONNECT,,,MUST
"An origin server MAY accept a CONNECT request, but most origin servers do not implement CONNECT.",A CONNECT request is received by the origin server.,"The origin server MAY accept the CONNECT request, although most origin servers do not implement CONNECT.",Origin Server,MAY,"CONNECT is intended for use in requests to a proxy. The recipient can establish a tunnel either by directly connecting to the server identified by the request target or, if configured to use another proxy, by forwarding the CONNECT request to the next inbound proxy. An origin server MAY accept a CONNECT request, but most origin servers do not implement CONNECT.","Because CONNECT changes the request/response nature of an HTTP connection, specific HTTP versions might have different ways of mapping its semantics into the protocol's wire format.",Any 2xx (Successful) response indicates that the sender (and all inbound proxies) will switch to tunnel mode immediately after the response header section; data received after that header section is from the server identified by the request target. Any response other than a successful response indicates that the tunnel has not yet been formed.,9.3.6,CONNECT,3,6,3,,,,CONNECT,,,MAY
A server MUST NOT send any Transfer-Encoding or Content-Length header fields in a 2xx (Successful) response to CONNECT.,2xx (Successful) response to CONNECT,The server MUST NOT send any Transfer-Encoding or Content-Length header fields in such a response,Server,MUST NOT,A server MUST NOT send any Transfer-Encoding or Content-Length header fields in a 2xx (Successful) response to CONNECT. A client MUST ignore any Content-Length or Transfer-Encoding header fields received in a successful response to CONNECT.,"There are significant risks in establishing a tunnel to arbitrary servers, particularly when the destination is a well-known or reserved TCP port that is not intended for Web traffic. For example, a CONNECT to ""example.com:25"" would suggest that the proxy connect to the reserved port for SMTP traffic; if allowed, that could trick the proxy into relaying spam email. Proxies that support CONNECT SHOULD restrict its use to a limited set of known ports or a configurable list of safe request targets.",A CONNECT request message does not have content. The interpretation of data sent after the header section of the CONNECT request message is specific to the version of HTTP in use.,9.3.6,CONNECT,3,12,1,2xx,"Content-Length,Transfer-Encoding",,CONNECT,,,MUST
"A server generating a successful response to OPTIONS SHOULD send any header that might indicate optional features implemented by the server and applicable to the target resource (e.g., Allow), including potential extensions not defined by this specification.",A server generates a successful response to an OPTIONS request.,"The server SHOULD send any header that might indicate optional features implemented by the server and applicable to the target resource (e.g., Allow), including potential extensions not defined by this specification.",Server,SHOULD,"A server generating a successful response to OPTIONS SHOULD send any header that might indicate optional features implemented by the server and applicable to the target resource (e.g., Allow), including potential extensions not defined by this specification. The response content, if any, might also describe the communication options in a machine or human-readable representation. A standard format for such a representation is not defined by this specification, but might be defined by future extensions to HTTP.","If the request target is not an asterisk, the OPTIONS request applies to the options that are available when communicating with the target resource.",A client MAY send a Max-Forwards header field in an OPTIONS request to target a specific recipient in the request chain (see Section 7.6.2). A proxy MUST NOT generate a Max-Forwards header field while forwarding a request unless that request was received with a Max-Forwards field.,9.3.7,OPTIONS,3,4,1,,Allow,,OPTIONS,,,SHOULD
"The final recipient of the request SHOULD reflect the message received, excluding some fields described below, back to the client as the content of a 200 (OK) response.","When a TRACE request is received by the final recipient (i.e., the origin server or the first server to receive a Max-Forwards value of zero)","The final recipient SHOULD reflect the received message, excluding certain fields described in the specification, back to the client as the content of a 200 (OK) response.",Recipient,SHOULD,"The TRACE method requests a remote, application-level loop-back of the request message. The final recipient of the request SHOULD reflect the message received, excluding some fields described below, back to the client as the content of a 200 (OK) response. The ""message/http"" format (Section 10.1 of [HTTP/1.1]) is one way to do so. The final recipient is either the origin server or the first server to receive a Max-Forwards value of zero (0) in the request (Section 7.6.2).",,"A client MUST NOT generate fields in a TRACE request containing sensitive data that might be disclosed by the response. For example, it would be foolish for a user agent to send stored user credentials (Section 11) or cookies [COOKIE] in a TRACE request. The final recipient of the request SHOULD exclude any request fields that are likely to contain sensitive data when that recipient generates the response content.",9.3.8,TRACE,3,1,2,200,,,,,,SHOULD
A server that receives an Expect field value containing a member other than 100-continue MAY respond with a 417 (Expectation Failed) status code to indicate that the unexpected expectation cannot be met.,A server receives an Expect field value that includes a member other than '100-continue'.,The server MAY respond with a 417 (Expectation Failed) status code to indicate that the unexpected expectation cannot be met.,Server,MAY,A server that receives an Expect field value containing a member other than 100-continue MAY respond with a 417 (Expectation Failed) status code to indicate that the unexpected expectation cannot be met.,"The only expectation defined by this specification is ""100-continue"" (with no defined parameters).","A ""100-continue"" expectation informs recipients that the client is about to send (presumably large) content in this request and wishes to receive a 100 (Continue) interim response if the method, target URI, and header fields are not sufficient to cause an immediate success, redirect, or error response. This allows the client to wait for an indication that it is worthwhile to send the content before actually doing so, which can improve efficiency when the data is huge or when the client anticipates that an error is likely (e.g., when sending a state-changing method, for the first time, without previously verified authentication credentials).",10.1.1,Expect,3,4,1,417,"Expect,100-continue",,,,,MAY
* A server that receives a 100-continue expectation in an HTTP/1.0 request MUST ignore that expectation.,A server receives a 100-continue expectation in an HTTP/1.0 request.,The server MUST ignore the 100-continue expectation.,Server,MUST,* A server that receives a 100-continue expectation in an HTTP/1.0 request MUST ignore that expectation.,Requirements for servers:,"* A server MAY omit sending a 100 (Continue) response if it has already received some or all of the content for the corresponding request, or if the framing indicates that there is no content.",10.1.1,Expect,3,15,1,,100-continue,,,,,MUST
"* A server MAY omit sending a 100 (Continue) response if it has already received some or all of the content for the corresponding request, or if the framing indicates that there is no content.","The server has already received some or all of the content for the corresponding request,The framing indicates that there is no content",The server MAY omit sending a 100 (Continue) response,Server,MAY,"* A server MAY omit sending a 100 (Continue) response if it has already received some or all of the content for the corresponding request, or if the framing indicates that there is no content.",* A server that receives a 100-continue expectation in an HTTP/1.0 request MUST ignore that expectation.,"* A server that sends a 100 (Continue) response MUST ultimately send a final status code, once it receives and processes the request content, unless the connection is closed prematurely.",10.1.1,Expect,3,16,1,100,,,,,,MAY
"* A server that sends a 100 (Continue) response MUST ultimately send a final status code, once it receives and processes the request content, unless the connection is closed prematurely.","A server sends a 100 (Continue) response and, provided the connection is not closed prematurely, receives and processes the request content",The server MUST ultimately send a final status code,Server,MUST,"* A server that sends a 100 (Continue) response MUST ultimately send a final status code, once it receives and processes the request content, unless the connection is closed prematurely.","* A server MAY omit sending a 100 (Continue) response if it has already received some or all of the content for the corresponding request, or if the framing indicates that there is no content.","* A server that responds with a final status code before reading the entire request content SHOULD indicate whether it intends to close the connection (e.g., see Section 9.6 of [HTTP/1.1]) or continue reading the request content.",10.1.1,Expect,3,17,1,100,,,,,,MUST
"Upon receiving an HTTP/1.1 (or later) request that has a method, target URI, and complete header section that contains a 100-continue expectation and an indication that request content will follow, an origin server MUST send either:","An HTTP/1.1 (or later) request that includes a method, a target URI, and a complete header section containing a 100-continue expectation along with an indication that request content will follow","The origin server MUST send either an immediate response with a final status code (if that status can be determined by examining just the method, target URI, and header fields) or an alternative immediate response as specified by the later branches of the directive",Origin Server,MUST,"Upon receiving an HTTP/1.1 (or later) request that has a method, target URI, and complete header section that contains a 100-continue expectation and an indication that request content will follow, an origin server MUST send either:","* A server that responds with a final status code before reading the entire request content SHOULD indicate whether it intends to close the connection (e.g., see Section 9.6 of [HTTP/1.1]) or continue reading the request content.","* an immediate response with a final status code, if that status can be determined by examining just the method, target URI, and header fields, or",10.1.1,Expect,3,19,1,,100-continue,,,,,MUST
The origin server MUST NOT wait for the content before sending the 100 (Continue) response.,When the origin server is processing a request that includes a 100-continue expectation and indicates that request content will follow,"The origin server MUST send the 100 (Continue) response immediately, without waiting for the request content",Origin Server,MUST NOT,The origin server MUST NOT wait for the content before sending the 100 (Continue) response.,* an immediate 100 (Continue) response to encourage the client to send the request content.,"Upon receiving an HTTP/1.1 (or later) request that has a method, target URI, and complete header section that contains a 100-continue expectation and indicates a request content will follow, a proxy MUST either:",10.1.1,Expect,3,22,1,100,,,,,,MUST
"A user agent SHOULD NOT send a From header field without explicit configuration by the user, since that might conflict with the user's privacy interests or their site's security policy.",The user agent is not explicitly configured by the user to include a From header field.,The user agent SHOULD NOT send a From header field.,Sender,SHOULD NOT,"The From header field is rarely sent by non-robotic user agents. A user agent SHOULD NOT send a From header field without explicit configuration by the user, since that might conflict with the user's privacy interests or their site's security policy.",From: spider-admin@example.org,"A robotic user agent SHOULD send a valid From header field so that the person responsible for running the robot can be contacted if problems occur on servers, such as if the robot is sending excessive, unwanted, or invalid requests.",10.1.2,From,3,4,2,,From,,,,,SHOULD
"A server SHOULD NOT use the From header field for access control or authentication, since its value is expected to be visible to anyone receiving or observing the request and is often recorded within logfiles and error reports without any expectation of privacy.",When the From header field is considered for use in access control or authentication,The server SHOULD NOT use the From header field for access control or authentication,Server,SHOULD NOT,"A server SHOULD NOT use the From header field for access control or authentication, since its value is expected to be visible to anyone receiving or observing the request and is often recorded within logfiles and error reports without any expectation of privacy.","A robotic user agent SHOULD send a valid From header field so that the person responsible for running the robot can be contacted if problems occur on servers, such as if the robot is sending excessive, unwanted, or invalid requests.",,10.1.2,From,3,6,1,,From,,,,,SHOULD
"A sender of TE MUST also send a ""TE"" connection option within the Connection header field (Section 7.6.1) to inform intermediaries not to forward this field.",When a sender includes the TE field in a message,The sender MUST include a 'TE' connection option within the Connection header field to instruct intermediaries not to forward the TE field,Sender,MUST,"A sender of TE MUST also send a ""TE"" connection option within the Connection header field (Section 7.6.1) to inform intermediaries not to forward this field.","The TE field value is a list of members, with each member (aside from ""trailers"") consisting of a transfer coding name token with an optional weight indicating the client's relative preference for that transfer coding (Section 12.4.2) and optional parameters for that transfer coding.",,10.1.4,TE,3,5,1,,"Connection,TE",,,,,MUST
An origin server MUST generate an Allow header field in a 405 (Method Not Allowed) response and MAY do so in any other response.,"When the origin server sends a 405 (Method Not Allowed) response,Optionally, in any other response if chosen by the server",The origin server MUST generate an Allow header field in the 405 (Method Not Allowed) response,Origin Server,"MUST, MAY","The actual set of allowed methods is defined by the origin server at the time of each request. An origin server MUST generate an Allow header field in a 405 (Method Not Allowed) response and MAY do so in any other response. An empty Allow field value indicates that the resource allows no methods, which might occur in a 405 response if the resource has been temporarily disabled by configuration.","Allow: GET, HEAD, PUT",A proxy MUST NOT modify the Allow header field --it does not need to understand all of the indicated methods in order to handle them according to the generic message handling rules.,10.2.1,Allow,3,4,2,405,Allow,,,,,MUST
An origin server MAY generate a Server header field in its responses.,When the origin server is formulating a response to a client request,The origin server MAY generate a Server header field in its responses,Origin Server,MAY,"The ""Server"" header field contains information about the software used by the origin server to handle the request, which is often used by clients to help identify the scope of reported interoperability problems, to work around or tailor requests to avoid particular server limitations, and for analytics regarding server or operating system use. An origin server MAY generate a Server header field in its responses.",,"The Server header field value consists of one or more product identifiers, each followed by zero or more comments (Section 5.6.5), which together identify the origin server software and its significant subproducts. By convention, the product identifiers are listed in decreasing order of their significance for identifying the origin server software. Each product identifier consists of a name and optional version, as defined in Section 10.1.5.",10.2.4,Server,3,1,2,,Server,,,,,MAY
An origin server SHOULD NOT generate a Server header field containing needlessly fine-grained detail and SHOULD limit the addition of subproducts by third parties.,When an origin server generates a Server header field for an HTTP response.,"The origin server SHOULD NOT generate a Server header field containing needlessly fine-grained detail.,The origin server SHOULD limit the addition of subproducts by third parties.",Origin Server,SHOULD NOT,An origin server SHOULD NOT generate a Server header field containing needlessly fine-grained detail and SHOULD limit the addition of subproducts by third parties. Overly long and detailed Server field values increase response latency and potentially reveal internal implementation details that might make it (slightly) easier for attackers to find and exploit known security holes.,Server: CERN/3.0 libwww/2.17,,10.2.4,Server,3,5,1,,Server,,,,,SHOULD
"Upon receipt of a request for a protected resource that omits credentials, contains invalid credentials (e.g., a bad password) or partial credentials (e.g., when the authentication scheme requires more than one round trip), an origin server SHOULD send a 401 (Unauthorized) response that contains a WWW-Authenticate header field with at least one (possibly new) challenge applicable to the requested resource.","A request for a protected resource that omits credentials,A request for a protected resource that contains invalid credentials (e.g., a bad password),A request for a protected resource that contains partial credentials (e.g., when the authentication scheme requires more than one round trip)",The origin server SHOULD send a 401 (Unauthorized) response that includes a WWW-Authenticate header field with at least one (possibly new) challenge applicable to the requested resource,Origin Server,SHOULD,"Upon receipt of a request for a protected resource that omits credentials, contains invalid credentials (e.g., a bad password) or partial credentials (e.g., when the authentication scheme requires more than one round trip), an origin server SHOULD send a 401 (Unauthorized) response that contains a WWW-Authenticate header field with at least one (possibly new) challenge applicable to the requested resource.","Both the Authorization field value and the Proxy-Authorization field value contain the client's credentials for the realm of the resource being requested, based upon a challenge received in a response (possibly at some point in the past). When creating their values, the user agent ought to do so by selecting the challenge with what it considers to be the most secure auth-scheme that it understands, obtaining credentials from the user as appropriate. Transmission of credentials within header field values implies significant security considerations regarding the confidentiality of the underlying connection, as described in Section 17.16.1.","Likewise, upon receipt of a request that omits proxy credentials or contains invalid or partial proxy credentials, a proxy that requires authentication SHOULD generate a 407 (Proxy Authentication Required) response that contains a Proxy-Authenticate header field with at least one (possibly new) challenge applicable to the proxy.",11.4,Credentials,2,2,1,401,WWW-Authenticate,,,,,SHOULD
A server generating a 401 (Unauthorized) response MUST send a WWW-Authenticate header field containing at least one challenge.,When a server generates a 401 (Unauthorized) response,The server MUST send a WWW-Authenticate header field containing at least one challenge,Server,MUST,A server generating a 401 (Unauthorized) response MUST send a WWW-Authenticate header field containing at least one challenge. A server MAY generate a WWW-Authenticate header field in other response messages to indicate that supplying credentials (or different credentials) might affect the response.,"The ""WWW-Authenticate"" response header field indicates the authentication scheme(s) and parameters applicable to the target resource.",A proxy forwarding a response MUST NOT modify any WWW-Authenticate header fields in that response.,11.6.1,WWW-Authenticate,3,2,1,401,WWW-Authenticate,,,,,MUST
A server MAY generate a WWW-Authenticate header field in other response messages to indicate that supplying credentials (or different credentials) might affect the response.,"In response messages other than those with a 401 (Unauthorized) status, where it is beneficial to indicate that supplying credentials (or different credentials) might affect the response.",The server MAY generate a WWW-Authenticate header field in these response messages to indicate that supplying credentials (or different credentials) might affect the response.,Server,MAY,A server generating a 401 (Unauthorized) response MUST send a WWW-Authenticate header field containing at least one challenge. A server MAY generate a WWW-Authenticate header field in other response messages to indicate that supplying credentials (or different credentials) might affect the response.,"The ""WWW-Authenticate"" response header field indicates the authentication scheme(s) and parameters applicable to the target resource.",A proxy forwarding a response MUST NOT modify any WWW-Authenticate header fields in that response.,11.6.1,WWW-Authenticate,3,2,2,,WWW-Authenticate,,,,,MAY
"If a non-empty Accept-Encoding header field is present in a request and none of the available representations for the response have a content coding that is listed as acceptable, the origin server SHOULD send a response without any content coding unless the identity coding is indicated as unacceptable.","A non-empty Accept-Encoding header field is present in a request,None of the available representations for the response have a content coding that is listed as acceptable",The origin server SHOULD send a response without any content coding unless the identity coding is indicated as unacceptable,Origin Server,SHOULD,"An Accept-Encoding header field with a field value that is empty implies that the user agent does not want any content coding in response. If a non-empty Accept-Encoding header field is present in a request and none of the available representations for the response have a content coding that is listed as acceptable, the origin server SHOULD send a response without any content coding unless the identity coding is indicated as unacceptable.","A representation could be encoded with multiple content codings. However, most content codings are alternative ways to accomplish the same purpose (e.g., data compression). When selecting between multiple content codings that have the same purpose, the acceptable content coding with the highest non-zero qvalue is preferred.","When the Accept-Encoding header field is present in a response, it indicates what content codings the resource was willing to accept in the associated request. The field value is evaluated the same way as in a request.",12.5.3,Accept-Encoding,3,10,2,,"Accept,Accept-Encoding",identity,,,,SHOULD
"In order to avoid confusion with issues related to media types, servers that fail a request with a 415 status for reasons unrelated to content codings MUST NOT include the Accept-Encoding header field.",A server fails a request with a 415 status code for reasons unrelated to content codings.,The server MUST NOT include the Accept-Encoding header field in the response.,Server,MUST NOT,"Servers that fail a request due to an unsupported content coding ought to respond with a 415 (Unsupported Media Type) status and include an Accept-Encoding header field in that response, allowing clients to distinguish between issues related to content codings and media types. In order to avoid confusion with issues related to media types, servers that fail a request with a 415 status for reasons unrelated to content codings MUST NOT include the Accept-Encoding header field.",Note that this information is specific to the associated request; the set of supported encodings might be different for other resources on the same server and could change over time or depend on other aspects of the request (such as the request method).,"The most common use of Accept-Encoding is in responses with a 415 (Unsupported Media Type) status code, in response to optimistic use of a content coding by clients. However, the header field can also be used to indicate to clients that content codings are supported in order to optimize future interactions. For example, a resource might include it in a 2xx (Successful) response when the request content was big enough to justify use of a compression coding but the client failed do so.",12.5.3,Accept-Encoding,3,13,2,415,"Accept,Accept-Encoding",,,,,MUST
An origin server SHOULD generate a Vary header field on a cacheable response when it wishes that response to be selectively reused for subsequent requests.,"The response is cacheable and the origin server wishes the response to be selectively reused for subsequent requests (for example, when the response content has been tailored to user preferences via selecting header fields).",The origin server SHOULD generate a Vary header field on the cacheable response.,Origin Server,SHOULD,"An origin server SHOULD generate a Vary header field on a cacheable response when it wishes that response to be selectively reused for subsequent requests. Generally, that is the case when the response content has been tailored to better fit the preferences expressed by those selecting header fields, such as when an origin server has selected the response's language based on the request's Accept-Language header field.","A Vary field containing a list of field names has two purposes: 1. To inform cache recipients that they MUST NOT use this response to satisfy a later request unless the later request has the same values for the listed header fields as the original request (Section 4.1 of [CACHING]) or reuse of the response has been validated by the origin server. In other words, Vary expands the cache key required to match a new request to the stored cache entry. 2. To inform user agent recipients that this response was subject to content negotiation (Section 12) and a different representation might be sent in a subsequent request if other values are provided in the listed header fields (proactive negotiation).","Vary might be elided when an origin server considers variance in content selection to be less significant than Vary's performance impact on caching, particularly when reuse is already limited by cache response directives (Section 5.2 of [CACHING]).",12.5.5,Vary,3,8,1,,Vary,,,,,SHOULD
"An origin server MUST use the strong comparison function when comparing entity tags for If-Match (Section 8.8.3.2), since the client intends this precondition to prevent the method from being applied if there have been any changes to the representation data.","When processing an 'If-Match' conditional request where the client intends to prevent the method from being applied if the representation data has changed (i.e., when comparing entity tags for an 'If-Match' header).",The origin server MUST use the strong comparison function when comparing entity tags for 'If-Match' as specified in Section 8.8.3.2.,Origin Server,MUST,"An origin server MUST use the strong comparison function when comparing entity tags for If-Match (Section 8.8.3.2), since the client intends this precondition to prevent the method from being applied if there have been any changes to the representation data.","The ""If-Match"" header field makes the request method conditional on the recipient origin server either having at least one current representation of the target resource, when the field value is ""*"", or having a current representation of the target resource that has an entity tag matching a member of the list of entity tags provided in the field value.",Examples:,13.1.1,If-Match,3,2,1,,If-Match,,,,,MUST
"When an origin server receives a request that selects a representation and that request includes an If-Match header field, the origin server MUST evaluate the If-Match condition per Section 13.2 prior to performing the method.",An origin server receives a request that selects a representation and that request includes an If-Match header field.,The origin server MUST evaluate the If-Match condition per Section 13.2 prior to performing the method.,Origin Server,MUST,"When an origin server receives a request that selects a representation and that request includes an If-Match header field, the origin server MUST evaluate the If-Match condition per Section 13.2 prior to performing the method.","If-Match is most often used with state-changing methods (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple user agents might be acting in parallel on the same resource (i.e., to prevent the ""lost update"" problem). In general, it can be used with any method that involves the selection or modification of a representation to abort the request if the selected representation's current entity tag is not a member within the If-Match field value.","To evaluate a received If-Match header field: 1. If the field value is ""*"", the condition is true if the origin server has a current representation for the target resource. 2. If the field value is a list of entity tags, the condition is true if any of the listed tags match the entity tag of the selected representation. 3. Otherwise, the condition is false.",13.1.1,If-Match,3,6,1,,If-Match,,,,,MUST
An origin server that evaluates an If-Match condition MUST NOT perform the requested method if the condition evaluates to false,The If-Match condition evaluates to false,The origin server MUST NOT perform the requested method,Origin Server,MUST NOT,"An origin server that evaluates an If-Match condition MUST NOT perform the requested method if the condition evaluates to false. Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code. Alternatively, if the request is a state-changing operation that appears to have already been applied to the selected representation, the origin server MAY respond with a 2xx (Successful) status code (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or an equivalent change was made by some other user agent).","To evaluate a received If-Match header field: 1. If the field value is ""*"", the condition is true if the origin server has a current representation for the target resource. 2. If the field value is a list of entity tags, the condition is true if any of the listed tags match the entity tag of the selected representation. 3. Otherwise, the condition is false.","Allowing an origin server to send a success response when a change request appears to have already been applied is more efficient for many authoring use cases, but comes with some risk if multiple user agents are making change requests that are very similar but not cooperative. For example, multiple user agents writing to a common resource as a semaphore (e.g., a nonatomic increment) are likely to collide and potentially lose important state transitions. For those kinds of resources, an origin server is better off being stringent in sending 412 for every failed precondition on an unsafe method. In other cases, excluding the ETag field from a success response might encourage the user agent to perform a GET as its next request to eliminate confusion about the resource's current state.",13.1.1,If-Match,3,8,1,,If-Match,,,,,MUST
"Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code","The conditional request fails (i.e., the evaluated condition, such as the If-Match header, is false)",The origin server MAY indicate the failure by responding with a 412 (Precondition Failed) status code,Origin Server,MAY,"An origin server that evaluates an If-Match condition MUST NOT perform the requested method if the condition evaluates to false. Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code. Alternatively, if the request is a state-changing operation that appears to have already been applied to the selected representation, the origin server MAY respond with a 2xx (Successful) status code (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or an equivalent change was made by some other user agent).","To evaluate a received If-Match header field: 1. If the field value is ""*"", the condition is true if the origin server has a current representation for the target resource. 2. If the field value is a list of entity tags, the condition is true if any of the listed tags match the entity tag of the selected representation. 3. Otherwise, the condition is false.","Allowing an origin server to send a success response when a change request appears to have already been applied is more efficient for many authoring use cases, but comes with some risk if multiple user agents are making change requests that are very similar but not cooperative. For example, multiple user agents writing to a common resource as a semaphore (e.g., a nonatomic increment) are likely to collide and potentially lose important state transitions. For those kinds of resources, an origin server is better off being stringent in sending 412 for every failed precondition on an unsafe method. In other cases, excluding the ETag field from a success response might encourage the user agent to perform a GET as its next request to eliminate confusion about the resource's current state.",13.1.1,If-Match,3,8,2,412,,,,,,MAY
"Alternatively, if the request is a state-changing operation that appears to have already been applied to the selected representation, the origin server MAY respond with a 2xx (Successful) status code (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or an equivalent change was made by some other user agent).","The request is a state-changing operation that appears to have already been applied to the selected representation (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it due to a lost prior response or an equivalent change made by another user agent)",The origin server MAY respond with a 2xx (Successful) status code,Origin Server,MAY,"An origin server that evaluates an If-Match condition MUST NOT perform the requested method if the condition evaluates to false. Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code. Alternatively, if the request is a state-changing operation that appears to have already been applied to the selected representation, the origin server MAY respond with a 2xx (Successful) status code (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or an equivalent change was made by some other user agent).","To evaluate a received If-Match header field: 1. If the field value is ""*"", the condition is true if the origin server has a current representation for the target resource. 2. If the field value is a list of entity tags, the condition is true if any of the listed tags match the entity tag of the selected representation. 3. Otherwise, the condition is false.","Allowing an origin server to send a success response when a change request appears to have already been applied is more efficient for many authoring use cases, but comes with some risk if multiple user agents are making change requests that are very similar but not cooperative. For example, multiple user agents writing to a common resource as a semaphore (e.g., a nonatomic increment) are likely to collide and potentially lose important state transitions. For those kinds of resources, an origin server is better off being stringent in sending 412 for every failed precondition on an unsafe method. In other cases, excluding the ETag field from a success response might encourage the user agent to perform a GET as its next request to eliminate confusion about the resource's current state.",13.1.1,If-Match,3,8,3,2xx,,,,,,MAY
"A recipient MUST use the weak comparison function when comparing entity tags for If-None-Match (Section 8.8.3.2), since weak entity tags can be used for cache validation even if there have been changes to the representation data.","When comparing entity tags for the If-None-Match header field, potentially during cache validation even if there have been changes to the representation data.",The recipient MUST use the weak comparison function when comparing entity tags for If-None-Match.,Recipient,MUST,"A recipient MUST use the weak comparison function when comparing entity tags for If-None-Match (Section 8.8.3.2), since weak entity tags can be used for cache validation even if there have been changes to the representation data.","The ""If-None-Match"" header field makes the request method conditional on a recipient cache or origin server either not having any current representation of the target resource, when the field value is ""*"", or having a selected representation with an entity tag that does not match any of those listed in the field value.",Examples:,13.1.2,If-None-Match,3,2,1,,If-None-Match,,,,,MUST
"When an origin server receives a request that selects a representation and that request includes an If-None-Match header field, the origin server MUST evaluate the If-None-Match condition per Section 13.2 prior to performing the method.",An origin server receives a request that selects a representation and that request includes an If-None-Match header field,The origin server MUST evaluate the If-None-Match condition per Section 13.2 prior to performing the method,Origin Server,MUST,"When an origin server receives a request that selects a representation and that request includes an If-None-Match header field, the origin server MUST evaluate the If-None-Match condition per Section 13.2 prior to performing the method.","If-None-Match can also be used with a value of ""*"" to prevent an unsafe request method (e.g., PUT) from inadvertently modifying an existing representation of the target resource when the client believes that the resource does not have a current representation (Section 9.2.1). This is a variation on the ""lost update"" problem that might arise if more than one client attempts to create an initial representation for the target resource.","To evaluate a received If-None-Match header field: 1. If the field value is ""*"", the condition is false if the origin server has a current representation for the target resource. 2. If the field value is a list of entity tags, the condition is false if one of the listed tags matches the entity tag of the selected representation. 3. Otherwise, the condition is true.",13.1.2,If-None-Match,3,7,1,,If-None-Match,,,,,MUST
"An origin server that evaluates an If-None-Match condition MUST NOT perform the requested method if the condition evaluates to false; instead, the origin server MUST respond with either a) the 304 (Not Modified) status code if the request method is GET or HEAD or b) the 412 (Precondition Failed) status code for all other request methods.",The origin server evaluates an If-None-Match condition as false.,"Do not perform the requested method.,If the request method is GET or HEAD, respond with a 304 (Not Modified) status code.,For all other request methods, respond with a 412 (Precondition Failed) status code.",Origin Server,MUST NOT,"An origin server that evaluates an If-None-Match condition MUST NOT perform the requested method if the condition evaluates to false; instead, the origin server MUST respond with either a) the 304 (Not Modified) status code if the request method is GET or HEAD or b) the 412 (Precondition Failed) status code for all other request methods.","To evaluate a received If-None-Match header field: 1. If the field value is ""*"", the condition is false if the origin server has a current representation for the target resource. 2. If the field value is a list of entity tags, the condition is false if one of the listed tags matches the entity tag of the selected representation. 3. Otherwise, the condition is true.",Requirements on cache handling of a received If-None-Match header field are defined in Section 4.3.2 of [CACHING].,13.1.2,If-None-Match,3,9,1,"304,412",If-None-Match,,"GET,HEAD",,,MUST
"A recipient MUST ignore If-Modified-Since if the request contains an If-None-Match header field; the condition in If-None-Match is considered to be a more accurate replacement for the condition in If-Modified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-None-Match.",The request contains an If-None-Match header field.,The recipient MUST ignore the If-Modified-Since header field.,Recipient,MUST,"A recipient MUST ignore If-Modified-Since if the request contains an If-None-Match header field; the condition in If-None-Match is considered to be a more accurate replacement for the condition in If-Modified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-None-Match.","If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT","A recipient MUST ignore the If-Modified-Since header field if the received field value is not a valid HTTP-date, the field value has more than one member, or if the request method is neither GET nor HEAD.",13.1.3,If-Modified-Since,3,4,1,,"If-Modified-Since,If-None-Match",,,,,MUST
"A recipient MUST ignore the If-Modified-Since header field if the received field value is not a valid HTTP-date, the field value has more than one member, or if the request method is neither GET nor HEAD.","The received If-Modified-Since field value is not a valid HTTP-date,The If-Modified-Since field value has more than one member,The request method is neither GET nor HEAD",The recipient MUST ignore the If-Modified-Since header field,Recipient,MUST,"A recipient MUST ignore the If-Modified-Since header field if the received field value is not a valid HTTP-date, the field value has more than one member, or if the request method is neither GET nor HEAD.","A recipient MUST ignore If-Modified-Since if the request contains an If-None-Match header field; the condition in If-None-Match is considered to be a more accurate replacement for the condition in If-Modified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-None-Match.",A recipient MUST ignore the If-Modified-Since header field if the resource does not have a modification date available.,13.1.3,If-Modified-Since,3,5,1,,If-Modified-Since,,"GET,HEAD",,,MUST
A recipient MUST ignore the If-Modified-Since header field if the resource does not have a modification date available.,The resource does not have a modification date available.,The recipient MUST ignore the If-Modified-Since header field.,Recipient,MUST,A recipient MUST ignore the If-Modified-Since header field if the resource does not have a modification date available.,"A recipient MUST ignore the If-Modified-Since header field if the received field value is not a valid HTTP-date, the field value has more than one member, or if the request method is neither GET nor HEAD.",A recipient MUST interpret an If-Modified-Since field value's timestamp in terms of the origin server's clock.,13.1.3,If-Modified-Since,3,6,1,,If-Modified-Since,,,,,MUST
A recipient MUST interpret an If-Modified-Since field value's timestamp in terms of the origin server's clock.,When an If-Modified-Since header field is present in a message,The recipient MUST interpret the If-Modified-Since field value's timestamp in terms of the origin server's clock,Recipient,MUST,A recipient MUST interpret an If-Modified-Since field value's timestamp in terms of the origin server's clock.,A recipient MUST ignore the If-Modified-Since header field if the resource does not have a modification date available.,If-Modified-Since is typically used for two distinct purposes: 1) to allow efficient updates of a cached representation that does not have an entity tag and 2) to limit the scope of a web traversal to resources that have recently changed.,13.1.3,If-Modified-Since,3,7,1,,If-Modified-Since,,,,,MUST
"When an origin server receives a request that selects a representation and that request includes an If-Modified-Since header field without an If-None-Match header field, the origin server SHOULD evaluate the If-Modified-Since condition per Section 13.2 prior to performing the method.",An origin server receives a request that selects a representation and that request includes an If-Modified-Since header field without an If-None-Match header field.,The origin server SHOULD evaluate the If-Modified-Since condition per Section 13.2 prior to performing the method.,Origin Server,SHOULD,"When an origin server receives a request that selects a representation and that request includes an If-Modified-Since header field without an If-None-Match header field, the origin server SHOULD evaluate the If-Modified-Since condition per Section 13.2 prior to performing the method.","When used for limiting the scope of retrieval to a recent time window, a user agent will generate an If-Modified-Since field value based on either its own clock or a Date header field received from the server in a prior response. Origin servers that choose an exact timestamp match based on the selected representation's Last-Modified header field will not be able to help the user agent limit its data transfers to only those changed during the specified window.","To evaluate a received If-Modified-Since header field: 1. If the selected representation's last modification date is earlier or equal to the date provided in the field value, the condition is false. 2. Otherwise, the condition is true.",13.1.3,If-Modified-Since,3,11,1,,"If-Modified-Since,If-None-Match",,,,,SHOULD
"An origin server that evaluates an If-Modified-Since condition SHOULD NOT perform the requested method if the condition evaluates to false; instead, the origin server SHOULD generate a 304 (Not Modified) response, including only those metadata that are useful for identifying or updating a previously cached response.","The origin server evaluates an If-Modified-Since condition that results in false (i.e., the selected representation’s last modification date is earlier than or equal to the date provided in the header).","The origin server SHOULD NOT perform the requested method and SHOULD generate a 304 (Not Modified) response, including only those metadata that are useful for identifying or updating a previously cached response.",Origin Server,SHOULD,"An origin server that evaluates an If-Modified-Since condition SHOULD NOT perform the requested method if the condition evaluates to false; instead, the origin server SHOULD generate a 304 (Not Modified) response, including only those metadata that are useful for identifying or updating a previously cached response.","To evaluate a received If-Modified-Since header field: 1. If the selected representation's last modification date is earlier or equal to the date provided in the field value, the condition is false. 2. Otherwise, the condition is true.",Requirements on cache handling of a received If-Modified-Since header field are defined in Section 4.3.2 of [CACHING].,13.1.3,If-Modified-Since,3,13,1,304,If-Modified-Since,,,,,SHOULD
"A recipient MUST ignore If-Unmodified-Since if the request contains an If-Match header field; the condition in If-Match is considered to be a more accurate replacement for the condition in If-Unmodified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-Match.",The request contains an If-Match header field.,The recipient MUST ignore the If-Unmodified-Since header field.,Recipient,MUST,"A recipient MUST ignore If-Unmodified-Since if the request contains an If-Match header field; the condition in If-Match is considered to be a more accurate replacement for the condition in If-Unmodified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-Match.","If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT",A recipient MUST ignore the If-Unmodified-Since header field if the received field value is not a valid HTTP-date (including when the field value appears to be a list of dates).,13.1.4,If-Unmodified-Since,3,4,1,,"If-Match,If-Unmodified-Since",,,,,MUST
A recipient MUST ignore the If-Unmodified-Since header field if the received field value is not a valid HTTP-date (including when the field value appears to be a list of dates).,The received field value is not a valid HTTP-date (including when the field value appears to be a list of dates),The recipient MUST ignore the If-Unmodified-Since header field,Recipient,MUST,A recipient MUST ignore the If-Unmodified-Since header field if the received field value is not a valid HTTP-date (including when the field value appears to be a list of dates).,"A recipient MUST ignore If-Unmodified-Since if the request contains an If-Match header field; the condition in If-Match is considered to be a more accurate replacement for the condition in If-Unmodified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-Match.",A recipient MUST ignore the If-Unmodified-Since header field if the resource does not have a modification date available.,13.1.4,If-Unmodified-Since,3,5,1,,If-Unmodified-Since,,,,,MUST
A recipient MUST ignore the If-Unmodified-Since header field if the resource does not have a modification date available.,The resource does not have a modification date available,The recipient MUST ignore the If-Unmodified-Since header field,Recipient,MUST,A recipient MUST ignore the If-Unmodified-Since header field if the resource does not have a modification date available.,A recipient MUST ignore the If-Unmodified-Since header field if the received field value is not a valid HTTP-date (including when the field value appears to be a list of dates).,A recipient MUST interpret an If-Unmodified-Since field value's timestamp in terms of the origin server's clock.,13.1.4,If-Unmodified-Since,3,6,1,,If-Unmodified-Since,,,,,MUST
A recipient MUST interpret an If-Unmodified-Since field value's timestamp in terms of the origin server's clock.,When a recipient receives a request that includes an If-Unmodified-Since header field with a timestamp.,The recipient MUST interpret the If-Unmodified-Since field value's timestamp in terms of the origin server's clock.,Recipient,MUST,A recipient MUST interpret an If-Unmodified-Since field value's timestamp in terms of the origin server's clock.,A recipient MUST ignore the If-Unmodified-Since header field if the resource does not have a modification date available.,"If-Unmodified-Since is most often used with state-changing methods (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple user agents might be acting in parallel on a resource that does not supply entity tags with its representations (i.e., to prevent the ""lost update"" problem). In general, it can be used with any method that involves the selection or modification of a representation to abort the request if the selected representation's last modification date has changed since the date provided in the If-Unmodified-Since field value.",13.1.4,If-Unmodified-Since,3,7,1,,If-Unmodified-Since,,,,,MUST
"When an origin server receives a request that selects a representation and that request includes an If-Unmodified-Since header field without an If-Match header field, the origin server MUST evaluate the If-Unmodified-Since condition per Section 13.2 prior to performing the method.","An origin server receives a request that selects a representation.,The request includes an If-Unmodified-Since header field without including an If-Match header field.",The origin server MUST evaluate the If-Unmodified-Since condition per Section 13.2 prior to performing the method.,Origin Server,MUST,"When an origin server receives a request that selects a representation and that request includes an If-Unmodified-Since header field without an If-Match header field, the origin server MUST evaluate the If-Unmodified-Since condition per Section 13.2 prior to performing the method.","If-Unmodified-Since is most often used with state-changing methods (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple user agents might be acting in parallel on a resource that does not supply entity tags with its representations (i.e., to prevent the ""lost update"" problem). In general, it can be used with any method that involves the selection or modification of a representation to abort the request if the selected representation's last modification date has changed since the date provided in the If-Unmodified-Since field value.","To evaluate a received If-Unmodified-Since header field: 1. If the selected representation's last modification date is earlier than or equal to the date provided in the field value, the condition is true. 2. Otherwise, the condition is false.",13.1.4,If-Unmodified-Since,3,9,1,,"If-Match,If-Unmodified-Since",,,,,MUST
An origin server that evaluates an If-Unmodified-Since condition MUST NOT perform the requested method if the condition evaluates to false,"The If-Unmodified-Since condition evaluates to false (i.e., the selected representation’s last modification date is later than the date provided)",The origin server MUST NOT perform the requested method,Origin Server,MUST,"An origin server that evaluates an If-Unmodified-Since condition MUST NOT perform the requested method if the condition evaluates to false. Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code. Alternatively, if the request is a state-changing operation that appears to have already been applied to the selected representation, the origin server MAY respond with a 2xx (Successful) status code (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or an equivalent change was made by some other user agent).","To evaluate a received If-Unmodified-Since header field: 1. If the selected representation's last modification date is earlier than or equal to the date provided in the field value, the condition is true. 2. Otherwise, the condition is false.","Allowing an origin server to send a success response when a change request appears to have already been applied is more efficient for many authoring use cases, but comes with some risk if multiple user agents are making change requests that are very similar but not cooperative. In those cases, an origin server is better off being stringent in sending 412 for every failed precondition on an unsafe method.",13.1.4,If-Unmodified-Since,3,11,1,,If-Unmodified-Since,,,,,MUST
"Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code","The evaluated If-Unmodified-Since condition is false (i.e., the representation’s last modification date is later than the date provided in the header)",The origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code,Origin Server,MAY,"An origin server that evaluates an If-Unmodified-Since condition MUST NOT perform the requested method if the condition evaluates to false. Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code. Alternatively, if the request is a state-changing operation that appears to have already been applied to the selected representation, the origin server MAY respond with a 2xx (Successful) status code (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or an equivalent change was made by some other user agent).","To evaluate a received If-Unmodified-Since header field: 1. If the selected representation's last modification date is earlier than or equal to the date provided in the field value, the condition is true. 2. Otherwise, the condition is false.","Allowing an origin server to send a success response when a change request appears to have already been applied is more efficient for many authoring use cases, but comes with some risk if multiple user agents are making change requests that are very similar but not cooperative. In those cases, an origin server is better off being stringent in sending 412 for every failed precondition on an unsafe method.",13.1.4,If-Unmodified-Since,3,11,2,412,,,,,,MAY
"Alternatively, if the request is a state-changing operation that appears to have already been applied to the selected representation, the origin server MAY respond with a 2xx (Successful) status code (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or an equivalent change was made by some other user agent).","The request is a state-changing operation that appears to have already been applied to the selected representation (i.e., the change requested by the user agent has already succeeded, possibly due to a lost prior response or an equivalent change being made by another user agent)",The origin server MAY respond with a 2xx (Successful) status code,Origin Server,MAY,"An origin server that evaluates an If-Unmodified-Since condition MUST NOT perform the requested method if the condition evaluates to false. Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code. Alternatively, if the request is a state-changing operation that appears to have already been applied to the selected representation, the origin server MAY respond with a 2xx (Successful) status code (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or an equivalent change was made by some other user agent).","To evaluate a received If-Unmodified-Since header field: 1. If the selected representation's last modification date is earlier than or equal to the date provided in the field value, the condition is true. 2. Otherwise, the condition is false.","Allowing an origin server to send a success response when a change request appears to have already been applied is more efficient for many authoring use cases, but comes with some risk if multiple user agents are making change requests that are very similar but not cooperative. In those cases, an origin server is better off being stringent in sending 412 for every failed precondition on an unsafe method.",13.1.4,If-Unmodified-Since,3,11,3,2xx,,,,,,MAY
A server MUST ignore an If-Range header field received in a request that does not contain a Range header field.,A request that contains an If-Range header field but does not contain a Range header field,The server MUST ignore the If-Range header field,Server,MUST,A client MUST NOT generate an If-Range header field in a request that does not contain a Range header field. A server MUST ignore an If-Range header field received in a request that does not contain a Range header field. An origin server MUST ignore an If-Range header field received in a request for a target resource that does not support Range requests.,A valid entity-tag can be distinguished from a valid HTTP-date by examining the first three characters for a DQUOTE.,A client MUST NOT generate an If-Range header field containing an entity tag that is marked as weak. A client MUST NOT generate an If-Range header field containing an HTTP-date unless the client has no entity tag for the corresponding representation and the date is a strong validator in the sense defined by Section 8.8.2.2.,13.1.5,If-Range,3,5,2,,"If-Range,Range",,,,,MUST
An origin server MUST ignore an If-Range header field received in a request for a target resource that does not support Range requests.,A request is received for a target resource that does not support Range requests and includes an If-Range header field.,The origin server MUST ignore the If-Range header field.,Origin Server,MUST,A client MUST NOT generate an If-Range header field in a request that does not contain a Range header field. A server MUST ignore an If-Range header field received in a request that does not contain a Range header field. An origin server MUST ignore an If-Range header field received in a request for a target resource that does not support Range requests.,A valid entity-tag can be distinguished from a valid HTTP-date by examining the first three characters for a DQUOTE.,A client MUST NOT generate an If-Range header field containing an entity tag that is marked as weak. A client MUST NOT generate an If-Range header field containing an HTTP-date unless the client has no entity tag for the corresponding representation and the date is a strong validator in the sense defined by Section 8.8.2.2.,13.1.5,If-Range,3,5,3,,"If-Range,Range",,,,,MUST
A server that receives an If-Range header field on a Range request MUST evaluate the condition per Section 13.2 prior to performing the method.,A server receives an If-Range header field on a Range request.,The server MUST evaluate the condition per Section 13.2 prior to performing the method.,Server,MUST,A server that receives an If-Range header field on a Range request MUST evaluate the condition per Section 13.2 prior to performing the method.,A client MUST NOT generate an If-Range header field containing an entity tag that is marked as weak. A client MUST NOT generate an If-Range header field containing an HTTP-date unless the client has no entity tag for the corresponding representation and the date is a strong validator in the sense defined by Section 8.8.2.2.,"To evaluate a received If-Range header field containing an HTTP-date: 1. If the HTTP-date validator provided is not a strong validator in the sense defined by Section 8.8.2.2, the condition is false. 2. If the HTTP-date validator provided exactly matches the Last-Modified field value for the selected representation, the condition is true. 3. Otherwise, the condition is false.",13.1.5,If-Range,3,7,1,,"If-Range,Range",,,,,MUST
A recipient of an If-Range header field MUST ignore the Range header field if the If-Range condition evaluates to false.,If the If-Range condition evaluates to false,The recipient MUST ignore the Range header field,Recipient,MUST,"A recipient of an If-Range header field MUST ignore the Range header field if the If-Range condition evaluates to false. Otherwise, the recipient SHOULD process the Range header field as requested.","To evaluate a received If-Range header field containing an entity-tag: 1. If the entity-tag validator provided exactly matches the ETag field value for the selected representation using the strong comparison function (Section 8.8.3.2), the condition is true. 2. Otherwise, the condition is false.","Note that the If-Range comparison is by exact match, including when the validator is an HTTP-date, and so it differs from the ""earlier than or equal to"" comparison used when evaluating an If-Unmodified-Since conditional.",13.1.5,If-Range,3,10,1,,"If-Range,Range",,,,,MUST
"Otherwise, the recipient SHOULD process the Range header field as requested.","The If-Range condition does not evaluate to false (i.e., it evaluates to true)",The recipient SHOULD process the Range header field as requested,Recipient,SHOULD,"A recipient of an If-Range header field MUST ignore the Range header field if the If-Range condition evaluates to false. Otherwise, the recipient SHOULD process the Range header field as requested.","To evaluate a received If-Range header field containing an entity-tag: 1. If the entity-tag validator provided exactly matches the ETag field value for the selected representation using the strong comparison function (Section 8.8.3.2), the condition is true. 2. Otherwise, the condition is false.","Note that the If-Range comparison is by exact match, including when the validator is an HTTP-date, and so it differs from the ""earlier than or equal to"" comparison used when evaluating an If-Unmodified-Since conditional.",13.1.5,If-Range,3,10,2,,Range,,,,,SHOULD
"A server MUST ignore all received preconditions if its response to the same request without those conditions, prior to processing the request content, would have been a status code other than a 2xx (Successful) or 412 (Precondition Failed).","The condition where the server's response to the same request without the preconditions, prior to processing the request content, would have been a status code other than 2xx (Successful) or 412 (Precondition Failed).",The server MUST ignore all received preconditions.,Server,MUST,"Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method. A server MUST ignore all received preconditions if its response to the same request without those conditions, prior to processing the request content, would have been a status code other than a 2xx (Successful) or 412 (Precondition Failed). In other words, redirects and failures that can be detected before significant processing occurs take precedence over the evaluation of preconditions.",,"A server that is not the origin server for the target resource and cannot act as a cache for requests on the target resource MUST NOT evaluate the conditional request header fields defined by this specification, and it MUST forward them if the request is forwarded, since the generating client intends that they be evaluated by a server that can provide a current representation. Likewise, a server MUST ignore the conditional request header fields defined by this specification when received with a request method that does not involve the selection or modification of a selected representation, such as CONNECT, OPTIONS, or TRACE.",13.2.1,When to Evaluate,3,1,2,"2xx,412",,,,,,MUST
"Likewise, a server MUST ignore the conditional request header fields defined by this specification when received with a request method that does not involve the selection or modification of a selected representation, such as CONNECT, OPTIONS, or TRACE.","Request received with a method that does not involve the selection or modification of a selected representation, such as CONNECT, OPTIONS, or TRACE.",The server MUST ignore the conditional request header fields defined by this specification.,Server,MUST,"A server that is not the origin server for the target resource and cannot act as a cache for requests on the target resource MUST NOT evaluate the conditional request header fields defined by this specification, and it MUST forward them if the request is forwarded, since the generating client intends that they be evaluated by a server that can provide a current representation. Likewise, a server MUST ignore the conditional request header fields defined by this specification when received with a request method that does not involve the selection or modification of a selected representation, such as CONNECT, OPTIONS, or TRACE.","Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method. A server MUST ignore all received preconditions if its response to the same request without those conditions, prior to processing the request content, would have been a status code other than a 2xx (Successful) or 412 (Precondition Failed). In other words, redirects and failures that can be detected before significant processing occurs take precedence over the evaluation of preconditions.","Note that protocol extensions can modify the conditions under which preconditions are evaluated or the consequences of their evaluation. For example, the immutable cache directive (defined by [RFC8246]) instructs caches to forgo forwarding conditional requests when they hold a fresh response.",13.2.1,When to Evaluate,3,2,2,,,,"CONNECT,OPTIONS,TRACE",,,MUST
A server MAY ignore the Range header field.,A request is received that includes a Range header field.,The server MAY ignore the Range header field.,Server,MAY,"A server MAY ignore the Range header field. However, origin servers and intermediate caches ought to support byte ranges when possible, since they support efficient recovery from partially failed transfers and partial retrieval of large representations.","The ""Range"" header field on a GET request modifies the method semantics to request transfer of only one or more subranges of the selected representation data (Section 8.1), rather than the entire selected representation.","A server MUST ignore a Range header field received with a request method that is unrecognized or for which range handling is not defined. For this specification, GET is the only method for which range handling is defined.",14.2,Range,2,2,1,,Range,,,,,MAY
A server MUST ignore a Range header field received with a request method that is unrecognized or for which range handling is not defined.,A request method that is unrecognized or for which range handling is not defined.,The server MUST ignore the Range header field received with such a request.,Server,MUST,"A server MUST ignore a Range header field received with a request method that is unrecognized or for which range handling is not defined. For this specification, GET is the only method for which range handling is defined.","A server MAY ignore the Range header field. However, origin servers and intermediate caches ought to support byte ranges when possible, since they support efficient recovery from partially failed transfers and partial retrieval of large representations.",An origin server MUST ignore a Range header field that contains a range unit it does not understand. A proxy MAY discard a Range header field that contains a range unit it does not understand.,14.2,Range,2,3,1,,Range,,,,,MUST
An origin server MUST ignore a Range header field that contains a range unit it does not understand.,A Range header field that contains a range unit it does not understand,The origin server MUST ignore the Range header field,Origin Server,MUST,An origin server MUST ignore a Range header field that contains a range unit it does not understand. A proxy MAY discard a Range header field that contains a range unit it does not understand.,"A server MUST ignore a Range header field received with a request method that is unrecognized or for which range handling is not defined. For this specification, GET is the only method for which range handling is defined.","A server that supports range requests MAY ignore or reject a Range header field that contains an invalid ranges-specifier (Section 14.1.1), a ranges-specifier with more than two overlapping ranges, or a set of many small ranges that are not listed in ascending order, since these are indications of either a broken client or a deliberate denial-of-service attack (Section 17.15). A client SHOULD NOT request multiple ranges that are inherently less efficient to process and transfer than a single range that encompasses the same data.",14.2,Range,2,4,1,,Range,,,,,MUST
"A server that supports range requests MAY ignore or reject a Range header field that contains an invalid ranges-specifier (Section 14.1.1), a ranges-specifier with more than two overlapping ranges, or a set of many small ranges that are not listed in ascending order, since these are indications of either a broken client or a deliberate denial-of-service attack (Section 17.15).","A Range header field that contains an invalid ranges-specifier (as per Section 14.1.1),A Range header field with a ranges-specifier containing more than two overlapping ranges,A Range header field with a set of many small ranges that are not listed in ascending order",The server MAY ignore or reject the Range header field when any of the above conditions are met,Server,MAY,"A server that supports range requests MAY ignore or reject a Range header field that contains an invalid ranges-specifier (Section 14.1.1), a ranges-specifier with more than two overlapping ranges, or a set of many small ranges that are not listed in ascending order, since these are indications of either a broken client or a deliberate denial-of-service attack (Section 17.15). A client SHOULD NOT request multiple ranges that are inherently less efficient to process and transfer than a single range that encompasses the same data.",An origin server MUST ignore a Range header field that contains a range unit it does not understand. A proxy MAY discard a Range header field that contains a range unit it does not understand.,"A server that supports range requests MAY ignore a Range header field when the selected representation has no content (i.e., the selected representation's data is of zero length).",14.2,Range,2,5,1,,Range,,,,,MAY
"A server that supports range requests MAY ignore a Range header field when the selected representation has no content (i.e., the selected representation's data is of zero length).","When the selected representation has no content (i.e., its data is of zero length)",The server MAY ignore the Range header field,Server,MAY,"A server that supports range requests MAY ignore a Range header field when the selected representation has no content (i.e., the selected representation's data is of zero length).","A server that supports range requests MAY ignore or reject a Range header field that contains an invalid ranges-specifier (Section 14.1.1), a ranges-specifier with more than two overlapping ranges, or a set of many small ranges that are not listed in ascending order, since these are indications of either a broken client or a deliberate denial-of-service attack (Section 17.15). A client SHOULD NOT request multiple ranges that are inherently less efficient to process and transfer than a single range that encompasses the same data.","A client that is requesting multiple ranges SHOULD list those ranges in ascending order (the order in which they would typically be received in a complete representation) unless there is a specific need to request a later part earlier. For example, a user agent processing a large representation with an internal catalog of parts might need to request later parts first, particularly if the representation consists of pages stored in reverse order and the user agent wishes to transfer one page at a time.",14.2,Range,2,6,1,,Range,,,,,MAY
"If all of the preconditions are true, the server supports the Range header field for the target resource, the received Range field-value contains a valid ranges-specifier with a range-unit supported for that target resource, and that ranges-specifier is satisfiable with respect to the selected representation, the server SHOULD send a 206 (Partial Content) response with content containing one or more partial representations that correspond to the satisfiable range-spec(s) requested.","All preconditions are true,The server supports the Range header field for the target resource,The received Range field-value contains a valid ranges-specifier with a range-unit supported for that target resource,The ranges-specifier is satisfiable with respect to the selected representation",The server SHOULD send a 206 (Partial Content) response with content containing one or more partial representations corresponding to the satisfiable range-spec(s) requested,Server,SHOULD,"If all of the preconditions are true, the server supports the Range header field for the target resource, the received Range field-value contains a valid ranges-specifier with a range-unit supported for that target resource, and that ranges-specifier is satisfiable with respect to the selected representation, the server SHOULD send a 206 (Partial Content) response with content containing one or more partial representations that correspond to the satisfiable range-spec(s) requested.",The If-Range header field (Section 13.1.5) can be used as a precondition to applying the Range header field.,"The above does not imply that a server will send all requested ranges. In some cases, it may only be possible (or efficient) to send a portion of the requested ranges first, while expecting the client to re-request the remaining portions later if they are still desired (see Section 15.3.7).",14.2,Range,2,10,1,206,Range,,,,,SHOULD
"If all of the preconditions are true, the server supports the Range header field for the target resource, the received Range field-value contains a valid ranges-specifier, and either the range-unit is not supported for that target resource or the ranges-specifier is unsatisfiable with respect to the selected representation, the server SHOULD send a 416 (Range Not Satisfiable) response.","All of the preconditions are true,The server supports the Range header field for the target resource,The received Range field-value contains a valid ranges-specifier,Either the range-unit is not supported for that target resource or the ranges-specifier is unsatisfiable with respect to the selected representation",The server SHOULD send a 416 (Range Not Satisfiable) response,Server,SHOULD,"If all of the preconditions are true, the server supports the Range header field for the target resource, the received Range field-value contains a valid ranges-specifier, and either the range-unit is not supported for that target resource or the ranges-specifier is unsatisfiable with respect to the selected representation, the server SHOULD send a 416 (Range Not Satisfiable) response.","The above does not imply that a server will send all requested ranges. In some cases, it may only be possible (or efficient) to send a portion of the requested ranges first, while expecting the client to re-request the remaining portions later if they are still desired (see Section 15.3.7).",,14.2,Range,2,12,1,416,Range,,,,,SHOULD
"The Accept-Ranges field MAY be sent in a trailer section, but is preferred to be sent as a header field because the information is particularly useful for restarting large information transfers that have failed in mid-content (before the trailer section is received).",Large information transfers that have failed in mid-content (before the trailer section is received) and require restart capability,The Accept-Ranges field SHOULD be sent as a header field (even though it MAY also be sent in a trailer section),Origin Server,MAY,"The Accept-Ranges field MAY be sent in a trailer section, but is preferred to be sent as a header field because the information is particularly useful for restarting large information transfers that have failed in mid-content (before the trailer section is received).","to advise the client not to attempt a range request on the same request path. The range unit ""none"" is reserved for this purpose.",,14.3,Accept-Ranges,2,10,1,,"Accept,Accept-Ranges,trailer",,,,,MAY
"If a 206 (Partial Content) response contains a Content-Range header field with a range unit (Section 14.1) that the recipient does not understand, the recipient MUST NOT attempt to recombine it with a stored representation.",A 206 (Partial Content) response that contains a Content-Range header field with a range unit (Section 14.1) that the recipient does not understand,The recipient MUST NOT attempt to recombine the response with a stored representation,"Recipient,Proxy",MUST NOT,"If a 206 (Partial Content) response contains a Content-Range header field with a range unit (Section 14.1) that the recipient does not understand, the recipient MUST NOT attempt to recombine it with a stored representation. A proxy that receives such a message SHOULD forward it downstream.","The ""Content-Range"" header field is sent in a single part 206 (Partial Content) response to indicate the partial range of the selected representation enclosed as the message content, sent in each part of a multipart 206 response to indicate the range enclosed within each body part (Section 14.6), and sent in 416 (Range Not Satisfiable) responses to provide information about the selected representation.","Content-Range might also be sent as a request modifier to request a partial PUT, as described in Section 14.5, based on private agreements between client and origin server. A server MUST ignore a Content-Range header field received in a request with a method for which Content-Range support is not defined.",14.4,Content-Range,2,2,1,206,"Content-Range,Range",,,,,MUST
A server MUST ignore a Content-Range header field received in a request with a method for which Content-Range support is not defined.,The request uses a method for which Content-Range support is not defined and includes a Content-Range header field.,The server MUST ignore the Content-Range header field.,Server,MUST,"Content-Range might also be sent as a request modifier to request a partial PUT, as described in Section 14.5, based on private agreements between client and origin server. A server MUST ignore a Content-Range header field received in a request with a method for which Content-Range support is not defined.","If a 206 (Partial Content) response contains a Content-Range header field with a range unit (Section 14.1) that the recipient does not understand, the recipient MUST NOT attempt to recombine it with a stored representation. A proxy that receives such a message SHOULD forward it downstream.","For byte ranges, a sender SHOULD indicate the complete length of the representation from which the range has been extracted, unless the complete length is unknown or difficult to determine. An asterisk character (""*"") in place of the complete-length indicates that the representation length was unknown when the header field was generated.",14.4,Content-Range,2,3,2,,"Content-Range,Range",,,,,MUST
The recipient of an invalid Content-Range MUST NOT attempt to recombine the received content with a stored representation.,"The recipient receives an invalid Content-Range header field (i.e., one that contains a range-resp with a last-pos value less than its first-pos value or a complete-length value less than or equal to its last-pos value)",The recipient MUST NOT attempt to recombine the received content with a stored representation.,Recipient,MUST NOT,"A Content-Range field value is invalid if it contains a range-resp that has a last-pos value less than its first-pos value, or a complete-length value less than or equal to its last-pos value. The recipient of an invalid Content-Range MUST NOT attempt to recombine the received content with a stored representation.",Content-Range: bytes 42-1233/*,"A server generating a 416 (Range Not Satisfiable) response to a byte-range request SHOULD send a Content-Range header field with an unsatisfied-range value, as in the following example:",14.4,Content-Range,2,9,2,,"Content-Range,Range",,,,,MUST
"A server generating a 416 (Range Not Satisfiable) response to a byte-range request SHOULD send a Content-Range header field with an unsatisfied-range value, as in the following example:",A server generates a 416 (Range Not Satisfiable) response to a byte-range request.,The server SHOULD send a Content-Range header field with an unsatisfied-range value.,Server,SHOULD,"A server generating a 416 (Range Not Satisfiable) response to a byte-range request SHOULD send a Content-Range header field with an unsatisfied-range value, as in the following example:","A Content-Range field value is invalid if it contains a range-resp that has a last-pos value less than its first-pos value, or a complete-length value less than or equal to its last-pos value. The recipient of an invalid Content-Range MUST NOT attempt to recombine the received content with a stored representation.",Content-Range: bytes */1234,14.4,Content-Range,2,10,1,416,"Content-Range,Range",,,,,SHOULD
An origin server SHOULD respond with a 400 (Bad Request) status code if it receives Content-Range on a PUT for a target resource that does not support partial PUT requests.,The origin server receives a PUT request containing a Content-Range header on a target resource that does not support partial PUT requests.,The origin server SHOULD respond with a 400 (Bad Request) status code.,Origin Server,SHOULD,An origin server SHOULD respond with a 400 (Bad Request) status code if it receives Content-Range on a PUT for a target resource that does not support partial PUT requests.,"Some origin servers support PUT of a partial representation when the user agent sends a Content-Range header field (Section 14.4) in the request, though such support is inconsistent and depends on private agreements with user agents. In general, it requests that the state of the target resource be partly replaced with the enclosed content at an offset and length indicated by the Content-Range value, where the offset is relative to the current selected representation.",Partial PUT is not backwards compatible with the original definition of PUT. It may result in the content being written as a complete replacement for the current representation.,14.5,Partial PUT,2,2,1,400,"Content-Range,Range",,PUT,,,SHOULD
"Since HTTP/1.0 did not define any 1xx status codes, a server MUST NOT send a 1xx response to an HTTP/1.0 client.","The client is using HTTP/1.0 (i.e., the client does not support 1xx status codes).",The server MUST NOT send a 1xx (Informational) response to an HTTP/1.0 client.,Server,MUST NOT,"The 1xx (Informational) class of status code indicates an interim response for communicating connection status or request progress prior to completing the requested action and sending a final response. Since HTTP/1.0 did not define any 1xx status codes, a server MUST NOT send a 1xx response to an HTTP/1.0 client.",,A 1xx response is terminated by the end of the header section; it cannot contain content or trailers.,15.2,Informational 1xx,2,1,2,1xx,,,,,,MUST
The server MUST generate an Upgrade header field in the response that indicates which protocol(s) will be in effect after this response.,When the server is sending a 101 (Switching Protocols) response indicating a protocol change,The server MUST generate an Upgrade header field in the response that indicates which protocol(s) will be in effect after this response,Server,MUST,"The 101 (Switching Protocols) status code indicates that the server understands and is willing to comply with the client's request, via the Upgrade header field (Section 7.8), for a change in the application protocol being used on this connection. The server MUST generate an Upgrade header field in the response that indicates which protocol(s) will be in effect after this response.",,"It is assumed that the server will only agree to switch protocols when it is advantageous to do so. For example, switching to a newer version of HTTP might be advantageous over older versions, and switching to a real-time, synchronous protocol might be advantageous when delivering resources that use such features.",15.2.2,101 Switching Protocols,3,1,2,,Upgrade,,,,,MUST
"In 200 responses to GET or HEAD, an origin server SHOULD send any available validator fields (Section 8.8) for the selected representation, with both a strong entity tag and a Last-Modified date being preferred.",The response is a 200 response to a GET or HEAD request,"The origin server SHOULD send any available validator fields for the selected representation, with a strong entity tag and a Last-Modified date being preferred",Origin Server,SHOULD,"In 200 responses to GET or HEAD, an origin server SHOULD send any available validator fields (Section 8.8) for the selected representation, with both a strong entity tag and a Last-Modified date being preferred.","A 200 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).","In 200 responses to state-changing methods, any validator fields (Section 8.8) sent in the response convey the current validators for the new representation formed as a result of successfully applying the request semantics. Note that the PUT method (Section 9.3.4) has additional requirements that might preclude sending such validators.",15.3.1,200 OK,3,5,1,200,Last-Modified,,"GET,HEAD",,,SHOULD
"Since the 205 status code implies that no additional content will be provided, a server MUST NOT generate content in a 205 response.","A response is being generated with a 205 HTTP status code, which implies that no additional content will be provided.",The server MUST NOT generate any content in a 205 response.,Server,MUST NOT,"Since the 205 status code implies that no additional content will be provided, a server MUST NOT generate content in a 205 response.","This response is intended to support a common data entry use case where the user receives content that supports data entry (a form, notepad, canvas, etc.), enters or manipulates data in that space, causes the entered data to be submitted in a request, and then the data entry mechanism is reset for the next entry so that the user can easily initiate another input action.",,15.3.6,205 Reset Content,3,3,1,205,,,,,,MUST
"A server that generates a 206 response MUST generate the following header fields, in addition to those required in the subsections below, if the field would have been sent in a 200 (OK) response to the same request: Date, Cache-Control, ETag, Expires, Content-Location, and Vary.","The server generates a 206 response,The header field is one that would have been sent in a 200 (OK) response to the same request","The server MUST generate the following header fields: Date, Cache-Control, ETag, Expires, Content-Location, and Vary (in addition to those required in the subsections below)",Server,MUST,"A server that generates a 206 response MUST generate the following header fields, in addition to those required in the subsections below, if the field would have been sent in a 200 (OK) response to the same request: Date, Cache-Control, ETag, Expires, Content-Location, and Vary.",A client MUST inspect a 206 response's Content-Type and Content-Range field(s) to determine what parts are enclosed and whether additional requests are needed.,"A Content-Length header field present in a 206 response indicates the number of octets in the content of this message, which is usually not the complete length of the selected representation. Each Content-Range header field includes information about the selected representation's complete length.",15.3.7,206 Partial Content,3,4,1,"200,206","Content-Location,Date,ETag,Location,Vary",,,,,MUST
A sender that generates a 206 response to a request with an If-Range header field SHOULD NOT generate other representation header fields beyond those required because the client already has a prior response containing those header fields.,A sender generates a 206 response to a request that includes an If-Range header field.,The sender SHOULD NOT generate other representation header fields beyond those required because the client already has a prior response containing those header fields.,Sender,SHOULD NOT,"A sender that generates a 206 response to a request with an If-Range header field SHOULD NOT generate other representation header fields beyond those required because the client already has a prior response containing those header fields. Otherwise, a sender MUST generate all of the representation header fields that would have been sent in a 200 (OK) response to the same request.","A Content-Length header field present in a 206 response indicates the number of octets in the content of this message, which is usually not the complete length of the selected representation. Each Content-Range header field includes information about the selected representation's complete length.","A 206 response is heuristically cacheable; i.e., unless otherwise indicated by explicit cache controls (see Section 4.2.2 of [CACHING]).",15.3.7,206 Partial Content,3,6,1,206,"If-Range,Range",,,,,SHOULD
"Otherwise, a sender MUST generate all of the representation header fields that would have been sent in a 200 (OK) response to the same request.","The request does not fall under the special case where the If-Range header field is present (i.e., the sender is not limited to generating only the minimal required representation header fields).",The sender MUST generate all of the representation header fields that would have been sent in a 200 (OK) response to the same request.,Sender,MUST,"A sender that generates a 206 response to a request with an If-Range header field SHOULD NOT generate other representation header fields beyond those required because the client already has a prior response containing those header fields. Otherwise, a sender MUST generate all of the representation header fields that would have been sent in a 200 (OK) response to the same request.","A Content-Length header field present in a 206 response indicates the number of octets in the content of this message, which is usually not the complete length of the selected representation. Each Content-Range header field includes information about the selected representation's complete length.","A 206 response is heuristically cacheable; i.e., unless otherwise indicated by explicit cache controls (see Section 4.2.2 of [CACHING]).",15.3.7,206 Partial Content,3,6,2,200,,,,,,MUST
"If a single part is being transferred, the server generating the 206 response MUST generate a Content-Range header field, describing what range of the selected representation is enclosed, and a content consisting of the range.","A single part is being transferred (i.e., when the response is a 206 Partial Content and only one part of the range is being sent)","The server generating the 206 response MUST generate a Content-Range header field that describes what range of the selected representation is enclosed, and include a content consisting of that range",Server,MUST,"If a single part is being transferred, the server generating the 206 response MUST generate a Content-Range header field, describing what range of the selected representation is enclosed, and a content consisting of the range. For example:","A 206 response is heuristically cacheable; i.e., unless otherwise indicated by explicit cache controls (see Section 4.2.2 of [CACHING]).","HTTP/1.1 206 Partial Content Date: Wed, 15 Nov 1995 06:25:24 GMT Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT Content-Range: bytes 21010-47021/47022 Content-Length: 26012 Content-Type: image/gif",15.3.7,206 Partial Content,3,8,1,206,"Content-Range,Range",,,,,MUST
"If multiple parts are being transferred, the server generating the 206 response MUST generate ""multipart/byteranges"" content, as defined in Section 14.6, and a Content-Type header field containing the ""multipart/byteranges"" media type and its required boundary parameter.","Multiple parts are being transferred (i.e., when the server is generating a 206 response with multiple parts).","The server MUST generate 'multipart/byteranges' content as defined in Section 14.6, and include a Content-Type header field containing the 'multipart/byteranges' media type along with its required boundary parameter.",Server,MUST,"If multiple parts are being transferred, the server generating the 206 response MUST generate ""multipart/byteranges"" content, as defined in Section 14.6, and a Content-Type header field containing the ""multipart/byteranges"" media type and its required boundary parameter. To avoid confusion with single-part responses, a server MUST NOT generate a Content-Range header field in the HTTP header section of a multiple part response (this field will be sent in each part instead).",... 26012 bytes of partial image data ...,"Within the header area of each body part in the multipart content, the server MUST generate a Content-Range header field corresponding to the range being enclosed in that body part. If the selected representation would have had a Content-Type header field in a 200 (OK) response, the server SHOULD generate that same Content-Type header field in the header area of each body part. For example:",15.3.7,206 Partial Content,3,11,1,206,Content-Type,,,,,MUST
"To avoid confusion with single-part responses, a server MUST NOT generate a Content-Range header field in the HTTP header section of a multiple part response (this field will be sent in each part instead).","When a multiple part response is being generated (i.e., when transferring multiple parts)","The server MUST NOT generate a Content-Range header field in the HTTP header section of the multiple part response (instead, it will be included in each individual part)",Server,MUST NOT,"If multiple parts are being transferred, the server generating the 206 response MUST generate ""multipart/byteranges"" content, as defined in Section 14.6, and a Content-Type header field containing the ""multipart/byteranges"" media type and its required boundary parameter. To avoid confusion with single-part responses, a server MUST NOT generate a Content-Range header field in the HTTP header section of a multiple part response (this field will be sent in each part instead).",... 26012 bytes of partial image data ...,"Within the header area of each body part in the multipart content, the server MUST generate a Content-Range header field corresponding to the range being enclosed in that body part. If the selected representation would have had a Content-Type header field in a 200 (OK) response, the server SHOULD generate that same Content-Type header field in the header area of each body part. For example:",15.3.7,206 Partial Content,3,11,2,,"Content-Range,Range",,,,,MUST
"Within the header area of each body part in the multipart content, the server MUST generate a Content-Range header field corresponding to the range being enclosed in that body part.",Within the header area of each body part in the multipart content,The server MUST generate a Content-Range header field corresponding to the range being enclosed in that body part,Server,MUST,"Within the header area of each body part in the multipart content, the server MUST generate a Content-Range header field corresponding to the range being enclosed in that body part. If the selected representation would have had a Content-Type header field in a 200 (OK) response, the server SHOULD generate that same Content-Type header field in the header area of each body part. For example:","If multiple parts are being transferred, the server generating the 206 response MUST generate ""multipart/byteranges"" content, as defined in Section 14.6, and a Content-Type header field containing the ""multipart/byteranges"" media type and its required boundary parameter. To avoid confusion with single-part responses, a server MUST NOT generate a Content-Range header field in the HTTP header section of a multiple part response (this field will be sent in each part instead).","HTTP/1.1 206 Partial Content Date: Wed, 15 Nov 1995 06:25:24 GMT Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT Content-Length: 1741 Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES",15.3.7,206 Partial Content,3,12,1,,"Content-Range,Range",,,,,MUST
"If the selected representation would have had a Content-Type header field in a 200 (OK) response, the server SHOULD generate that same Content-Type header field in the header area of each body part.",The selected representation would have had a Content-Type header field in a 200 (OK) response.,The server SHOULD generate that same Content-Type header field in the header area of each body part.,Server,SHOULD,"Within the header area of each body part in the multipart content, the server MUST generate a Content-Range header field corresponding to the range being enclosed in that body part. If the selected representation would have had a Content-Type header field in a 200 (OK) response, the server SHOULD generate that same Content-Type header field in the header area of each body part. For example:","If multiple parts are being transferred, the server generating the 206 response MUST generate ""multipart/byteranges"" content, as defined in Section 14.6, and a Content-Type header field containing the ""multipart/byteranges"" media type and its required boundary parameter. To avoid confusion with single-part responses, a server MUST NOT generate a Content-Range header field in the HTTP header section of a multiple part response (this field will be sent in each part instead).","HTTP/1.1 206 Partial Content Date: Wed, 15 Nov 1995 06:25:24 GMT Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT Content-Length: 1741 Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES",15.3.7,206 Partial Content,3,12,2,200,Content-Type,,,,,SHOULD
"When multiple ranges are requested, a server MAY coalesce any of the ranges that overlap, or that are separated by a gap that is smaller than the overhead of sending multiple parts, regardless of the order in which the corresponding range-spec appeared in the received Range header field.","A client request containing multiple ranges, where some ranges overlap or are separated by a gap smaller than the overhead of sending multiple parts","The server MAY coalesce the overlapping ranges or the ranges separated by a small gap, regardless of the order of the range-spec values in the Range header",Server,MAY,"When multiple ranges are requested, a server MAY coalesce any of the ranges that overlap, or that are separated by a gap that is smaller than the overhead of sending multiple parts, regardless of the order in which the corresponding range-spec appeared in the received Range header field. Since the typical overhead between each part of a ""multipart/byteranges"" is around 80 bytes, depending on the selected representation's media type and the chosen boundary parameter length, it can be less efficient to transfer many small disjoint parts than it is to transfer the entire selected representation.",...the second range --THIS_STRING_SEPARATES--,"A server MUST NOT generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses. However, a server MAY generate a ""multipart/byteranges"" response with only a single body part if multiple ranges were requested and only one range was found to be satisfiable or only one range remained after coalescing. A client that cannot process a ""multipart/byteranges"" response MUST NOT generate a request that asks for multiple ranges.",15.3.7,206 Partial Content,3,17,1,,Range,,,,,MAY
"A server that generates a multipart response SHOULD send the parts in the same order that the corresponding range-spec appeared in the received Range header field, excluding those ranges that were deemed unsatisfiable or that were coalesced into other ranges.","When a server generates a multipart response (i.e., in response to a request involving multiple ranges)","The server SHOULD send the response parts in the same order as the corresponding range-spec appeared in the received Range header field, excluding those ranges that were deemed unsatisfiable or that were coalesced into other ranges.",Server,SHOULD,"A server that generates a multipart response SHOULD send the parts in the same order that the corresponding range-spec appeared in the received Range header field, excluding those ranges that were deemed unsatisfiable or that were coalesced into other ranges. A client that receives a multipart response MUST inspect the Content-Range header field present in each body part in order to determine which range is contained in that body part; a client cannot rely on receiving the same ranges that it requested, nor the same order that it requested.","A server MUST NOT generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses. However, a server MAY generate a ""multipart/byteranges"" response with only a single body part if multiple ranges were requested and only one range was found to be satisfiable or only one range remained after coalescing. A client that cannot process a ""multipart/byteranges"" response MUST NOT generate a request that asks for multiple ranges.","A response might transfer only a subrange of a representation if the connection closed prematurely or if the request used one or more Range specifications. After several such transfers, a client might have received several ranges of the same representation. These ranges can only be safely combined if they all have in common the same strong validator (Section 8.8.1).",15.3.7,206 Partial Content,3,19,1,,Range,,,,,SHOULD
"If the server has a preferred choice, the server SHOULD generate a Location header field containing a preferred choice's URI reference",The server has a preferred choice,The server SHOULD generate a Location header field containing a preferred choice's URI reference,Server,SHOULD,"If the server has a preferred choice, the server SHOULD generate a Location header field containing a preferred choice's URI reference. The user agent MAY use the Location field value for automatic redirection.","The 300 (Multiple Choices) status code indicates that the target resource has more than one representation, each with its own more specific identifier, and information about the alternatives is being provided so that the user (or user agent) can select a preferred representation by redirecting its request to one or more of those identifiers. In other words, the server desires that the user agent engage in reactive negotiation to select the most appropriate representation(s) for its needs (Section 12).","For request methods other than HEAD, the server SHOULD generate content in the 300 response containing a list of representation metadata and URI reference(s) from which the user or user agent can choose the one most preferred. The user agent MAY make a selection from that list automatically if it understands the provided media type. A specific format for automatic selection is not defined by this specification because HTTP tries to remain orthogonal to the definition of its content. In practice, the representation is provided in some easily parsed format believed to be acceptable to the user agent, as determined by shared design or content negotiation, or in some commonly accepted hypertext format.",15.4.1,300 Multiple Choices,3,2,1,,Location,,,,,SHOULD
"For request methods other than HEAD, the server SHOULD generate content in the 300 response containing a list of representation metadata and URI reference(s) from which the user or user agent can choose the one most preferred.",For request methods other than HEAD,The server SHOULD generate content in the 300 response containing a list of representation metadata and URI reference(s) from which the user or user agent can choose the one most preferred.,Server,SHOULD,"For request methods other than HEAD, the server SHOULD generate content in the 300 response containing a list of representation metadata and URI reference(s) from which the user or user agent can choose the one most preferred. The user agent MAY make a selection from that list automatically if it understands the provided media type. A specific format for automatic selection is not defined by this specification because HTTP tries to remain orthogonal to the definition of its content. In practice, the representation is provided in some easily parsed format believed to be acceptable to the user agent, as determined by shared design or content negotiation, or in some commonly accepted hypertext format.","If the server has a preferred choice, the server SHOULD generate a Location header field containing a preferred choice's URI reference. The user agent MAY use the Location field value for automatic redirection.","A 300 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).",15.4.1,300 Multiple Choices,3,3,1,300,,,HEAD,,,SHOULD
The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,When responding with a 301 (Moved Permanently) status code indicating that the target resource has been permanently moved.,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,Server,SHOULD,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI. The user agent MAY use the Location field value for automatic redirection. The server's response content usually contains a short hypertext note with a hyperlink to the new URI(s).,"The 301 (Moved Permanently) status code indicates that the target resource has been assigned a new permanent URI and any future references to this resource ought to use one of the enclosed URIs. The server is suggesting that a user agent with link-editing capability can permanently replace references to the target URI with one of the new references sent by the server. However, this suggestion is usually ignored unless the user agent is actively editing references (e.g., engaged in authoring content), the connection is secured, and the origin server is a trusted authority for the content being edited.","A 301 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).",15.4.2,301 Moved Permanently,3,2,1,,Location,,,,,SHOULD
The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,"When the server is issuing a redirection response (e.g., 302 Found) indicating that the target resource temporarily resides under a different URI",The server SHOULD generate a Location header field in the response containing a URI reference for the different URI,Server,SHOULD,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI. The user agent MAY use the Location field value for automatic redirection. The server's response content usually contains a short hypertext note with a hyperlink to the different URI(s).,"The 302 (Found) status code indicates that the target resource resides temporarily under a different URI. Since the redirection might be altered on occasion, the client ought to continue to use the target URI for future requests.",,15.4.3,302 Found,3,2,1,,Location,,,,,SHOULD
The server generating a 304 response MUST generate any of the following header fields that would have been sent in a 200 (OK) response to the same request:,"When the server is generating a 304 (Not Modified) response, indicating that a conditional GET or HEAD request was received and the condition evaluated to false.","The server MUST generate any of the header fields that would have been sent in a 200 (OK) response to the same request, specifically including header fields such as Content-Location, Date, ETag, and Vary.",Server,MUST,The server generating a 304 response MUST generate any of the following header fields that would have been sent in a 200 (OK) response to the same request:,"The 304 (Not Modified) status code indicates that a conditional GET or HEAD request has been received and would have resulted in a 200 (OK) response if it were not for the fact that the condition evaluated to false. In other words, there is no need for the server to transfer a representation of the target resource because the request indicates that the client, which made the request conditional, already has a valid representation; the server is therefore redirecting the client to make use of that stored representation as if it were the content of a 200 (OK) response.","* Content-Location, Date, ETag, and Vary",15.4.5,304 Not Modified,3,2,1,"200,304",,,,,,MUST
"Since the goal of a 304 response is to minimize information transfer when the recipient already has one or more cached representations, a sender SHOULD NOT generate representation metadata other than the above listed fields unless said metadata exists for the purpose of guiding cache updates (e.g., Last-Modified might be useful if the response does not have an ETag field).","When generating a 304 response intended for a recipient that already has one or more cached representations,When no metadata is being produced for the purpose of guiding cache updates","The sender SHOULD NOT generate representation metadata other than the above listed fields, unless the metadata exists for the purpose of guiding cache updates",Sender,SHOULD NOT,"Since the goal of a 304 response is to minimize information transfer when the recipient already has one or more cached representations, a sender SHOULD NOT generate representation metadata other than the above listed fields unless said metadata exists for the purpose of guiding cache updates (e.g., Last-Modified might be useful if the response does not have an ETag field).",* Cache-Control and Expires (see [CACHING]),"Requirements on a cache that receives a 304 response are defined in Section 4.3.4 of [CACHING]. If the conditional request originated with an outbound client, such as a user agent with its own cache sending a conditional GET to a shared proxy, then the proxy SHOULD forward the 304 response to that client.",15.4.5,304 Not Modified,3,5,1,304,"ETag,Last-Modified",,,,,SHOULD
The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,"When the server is responding with a temporary redirection (e.g., 307 Temporary Redirect) indicating that the target resource resides under a different URI",The server SHOULD generate a Location header field in the response containing a URI reference for the different URI,Server,SHOULD,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI. The user agent MAY use the Location field value for automatic redirection. The server's response content usually contains a short hypertext note with a hyperlink to the different URI(s).,"The 307 (Temporary Redirect) status code indicates that the target resource resides temporarily under a different URI and the user agent MUST NOT change the request method if it performs an automatic redirection to that URI. Since the redirection can change over time, the client ought to continue using the original target URI for future requests.",,15.4.8,307 Temporary Redirect,3,2,1,,Location,,,,,SHOULD
The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,"When the server is issuing a response for a new permanent URI assignment (e.g., in a 308 Permanent Redirect response)",The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,Server,SHOULD,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI. The user agent MAY use the Location field value for automatic redirection. The server's response content usually contains a short hypertext note with a hyperlink to the new URI(s).,"The 308 (Permanent Redirect) status code indicates that the target resource has been assigned a new permanent URI and any future references to this resource ought to use one of the enclosed URIs. The server is suggesting that a user agent with link-editing capability can permanently replace references to the target URI with one of the new references sent by the server. However, this suggestion is usually ignored unless the user agent is actively editing references (e.g., engaged in authoring content), the connection is secured, and the origin server is a trusted authority for the content being edited.","A 308 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).",15.4.9,308 Permanent Redirect,3,2,1,,Location,,,,,SHOULD
"Except when responding to a HEAD request, the server SHOULD send a representation containing an explanation of the error situation, and whether it is a temporary or permanent condition.",The request is not a HEAD request.,The server SHOULD send a representation containing an explanation of the error situation and whether it is a temporary or permanent condition.,Server,SHOULD,"The 4xx (Client Error) class of status code indicates that the client seems to have erred. Except when responding to a HEAD request, the server SHOULD send a representation containing an explanation of the error situation, and whether it is a temporary or permanent condition. These status codes are applicable to any request method. User agents SHOULD display any included representation to the user.",,,15.5,Client Error 4xx,2,1,2,,,,HEAD,,,SHOULD
The server generating a 401 response MUST send a WWW-Authenticate header field (Section 11.6.1) containing at least one challenge applicable to the target resource.,A 401 (Unauthorized) response is being generated by the server,The server MUST send a WWW-Authenticate header field (Section 11.6.1) containing at least one challenge applicable to the target resource,Server,MUST,The 401 (Unauthorized) status code indicates that the request has not been applied because it lacks valid authentication credentials for the target resource. The server generating a 401 response MUST send a WWW-Authenticate header field (Section 11.6.1) containing at least one challenge applicable to the target resource.,,"If the request included authentication credentials, then the 401 response indicates that authorization has been refused for those credentials. The user agent MAY repeat the request with a new or replaced Authorization header field (Section 11.6.2). If the 401 response contains the same challenge as the prior response, and the user agent has already attempted authentication at least once, then the user agent SHOULD present the enclosed representation to the user, since it usually contains relevant diagnostic information.",15.5.2,401 Unauthorized,3,1,2,401,WWW-Authenticate,,,,,MUST
"An origin server that wishes to ""hide"" the current existence of a forbidden target resource MAY instead respond with a status code of 404 (Not Found).",An origin server that wishes to 'hide' the current existence of a forbidden target resource,Respond with a status code of 404 (Not Found),Origin Server,MAY,"An origin server that wishes to ""hide"" the current existence of a forbidden target resource MAY instead respond with a status code of 404 (Not Found).","If authentication credentials were provided in the request, the server considers them insufficient to grant access. The client SHOULD NOT automatically repeat the request with the same credentials. The client MAY repeat the request with new or different credentials. However, a request might be forbidden for reasons unrelated to the credentials.",,15.5.4,403 Forbidden,3,3,1,"302,404",,,,,,MAY
The origin server MUST generate an Allow header field in a 405 response containing a list of the target resource's currently supported methods.,When the origin server returns a 405 (Method Not Allowed) response,The origin server MUST generate an Allow header field in the 405 response containing a list of the target resource's currently supported methods,Origin Server,MUST,The 405 (Method Not Allowed) status code indicates that the method received in the request-line is known by the origin server but not supported by the target resource. The origin server MUST generate an Allow header field in a 405 response containing a list of the target resource's currently supported methods.,,"A 405 response is heuristically cacheable; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [CACHING]).",15.5.6,405 Method Not Allowed,3,1,2,405,Allow,,,,,MUST
"If the condition is temporary, the server SHOULD generate a Retry-After header field to indicate that it is temporary and after what time the client MAY try again.",The condition is temporary.,The server SHOULD generate a Retry-After header field to indicate that it is temporary and to specify after what time the client MAY try again.,Server,"SHOULD, MAY","If the condition is temporary, the server SHOULD generate a Retry-After header field to indicate that it is temporary and after what time the client MAY try again.","The 413 (Content Too Large) status code indicates that the server is refusing to process a request because the request content is larger than the server is willing or able to process. The server MAY terminate the request, if the protocol version in use allows it; otherwise, the server MAY close the connection.",,15.5.14,413 Content Too Large,3,2,1,,Retry-After,,,,,SHOULD
A server that generates a 416 response to a byte-range request SHOULD generate a Content-Range header field specifying the current length of the selected representation (Section 14.4).,A server generates a 416 response to a byte-range request,The server SHOULD generate a Content-Range header field specifying the current length of the selected representation,Server,SHOULD,A server that generates a 416 response to a byte-range request SHOULD generate a Content-Range header field specifying the current length of the selected representation (Section 14.4).,"Each range unit defines what is required for its own range sets to be satisfiable. For example, Section 14.1.2 defines what makes a bytes range set satisfiable.",For example:,15.5.17,416 Range Not Satisfiable,3,3,1,416,"Content-Range,Range",,,,,SHOULD
The server MUST send an Upgrade header field in a 426 response to indicate the required protocol(s) (Section 7.8).,The response is a 426 (Upgrade Required) response produced by the server.,The server MUST send an Upgrade header field in the 426 response to indicate the required protocol(s) (Section 7.8).,Server,MUST,The 426 (Upgrade Required) status code indicates that the server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol. The server MUST send an Upgrade header field in a 426 response to indicate the required protocol(s) (Section 7.8).,,Example:,15.5.22,426 Upgrade Required,3,1,2,426,Upgrade,,,,,MUST
"Except when responding to a HEAD request, the server SHOULD send a representation containing an explanation of the error situation, and whether it is a temporary or permanent condition.","The response is not for a HEAD request (i.e., when responding to any request method other than HEAD)",The server SHOULD send a representation that includes an explanation of the error situation and also indicates whether the error is temporary or permanent,Server,SHOULD,"The 5xx (Server Error) class of status code indicates that the server is aware that it has erred or is incapable of performing the requested method. Except when responding to a HEAD request, the server SHOULD send a representation containing an explanation of the error situation, and whether it is a temporary or permanent condition. A user agent SHOULD display any included representation to the user. These status codes are applicable to any request method.",,,15.6,Server Error 5xx,2,1,2,,,,HEAD,,,SHOULD
The server MAY send a Retry-After header field (Section 10.2.3) to suggest an appropriate amount of time for the client to wait before retrying the request.,"The server is unable to handle the request, indicated by a 503 (Service Unavailable) status due to temporary overload or scheduled maintenance.",The server MAY send a Retry-After header field (Section 10.2.3) to suggest an appropriate amount of time for the client to wait before retrying the request.,Server,MAY,"The 503 (Service Unavailable) status code indicates that the server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay. The server MAY send a Retry-After header field (Section 10.2.3) to suggest an appropriate amount of time for the client to wait before retrying the request.",,,15.6.4,503 Service Unavailable,3,1,2,,Retry-After,,,,,MAY
The server SHOULD generate a representation for the 505 response that describes why that version is not supported and what other protocols are supported by that server.,"A request uses an HTTP major version that the server does not support, triggering a 505 (HTTP Version Not Supported) response.",The server SHOULD generate a representation for the 505 response that describes why that version is not supported and what other protocols are supported by the server.,Server,SHOULD,"The 505 (HTTP Version Not Supported) status code indicates that the server does not support, or refuses to support, the major version of HTTP that was used in the request message. The server is indicating that it is unable or unwilling to complete the request using the same major version as the client, as described in Section 2.5, other than with this error message. The server SHOULD generate a representation for the 505 response that describes why that version is not supported and what other protocols are supported by that server.",,,15.6.6,505 HTTP Version Not Supported,3,1,3,505,,,,,,SHOULD
"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.","When a recipient receives a line termination that consists of a single LF, possibly preceded by a CR.",The recipient MAY recognize the single LF as the line terminator and ignore any preceding CR.,Recipient,MAY,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.","A recipient MUST parse an HTTP message as a sequence of octets in an encoding that is a superset of US-ASCII [USASCII]. Parsing an HTTP message as a stream of Unicode characters, without regard for the specific encoding, creates security vulnerabilities due to the varying ways that string processing libraries handle invalid multibyte character sequences that contain the octet LF (%x0A). String-based parsers can only be safely used within protocol elements after the element has been extracted from the message, such as within a header field line value after message parsing has delineated the individual field lines.",A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content. A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.,2.2,Message Parsing,2,3,1,,,,,"CR,LF,CRLF",,MAY
A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,"When generating any protocol element other than the content, involving a CR character that is not immediately followed by LF",The sender MUST NOT generate a bare CR (a CR character not immediately followed by LF),"Sender,Recipient",MUST NOT,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content. A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.","Older HTTP/1.0 user agent implementations might send an extra CRLF after a POST request as a workaround for some early server applications that failed to read message body content that was not terminated by a line-ending. An HTTP/1.1 user agent MUST NOT preface or follow a request with an extra CRLF. If terminating the request message body with a line-ending is desired, then the user agent MUST count the terminating CRLF octets as part of the message body length.",2.2,Message Parsing,2,4,1,,,,,"CR,LF",,MUST
A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.,A bare CR (a CR character not immediately followed by LF) is encountered within any protocol element (excluding the content).,Consider the element invalid or replace each bare CR with SP before processing the element or forwarding the message.,Recipient,MUST,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content. A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.","Older HTTP/1.0 user agent implementations might send an extra CRLF after a POST request as a workaround for some early server applications that failed to read message body content that was not terminated by a line-ending. An HTTP/1.1 user agent MUST NOT preface or follow a request with an extra CRLF. If terminating the request message body with a line-ending is desired, then the user agent MUST count the terminating CRLF octets as part of the message body length.",2.2,Message Parsing,2,4,2,,,,,"CR,SP",,MUST
"In the interest of robustness, a server that is expecting to receive and parse a request-line SHOULD ignore at least one empty line (CRLF) received prior to the request-line.",A server that is expecting to receive and parse a request-line receives an empty line (CRLF) prior to the request-line.,The server SHOULD ignore at least one empty line (CRLF) received prior to the request-line.,Server,SHOULD,"In the interest of robustness, a server that is expecting to receive and parse a request-line SHOULD ignore at least one empty line (CRLF) received prior to the request-line.","Older HTTP/1.0 user agent implementations might send an extra CRLF after a POST request as a workaround for some early server applications that failed to read message body content that was not terminated by a line-ending. An HTTP/1.1 user agent MUST NOT preface or follow a request with an extra CRLF. If terminating the request message body with a line-ending is desired, then the user agent MUST count the terminating CRLF octets as part of the message body length.",A sender MUST NOT send whitespace between the start-line and the first header field.,2.2,Message Parsing,2,6,1,,,,,CRLF,,SHOULD
"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",A server that is either listening only for HTTP request messages or processing what appears from the start-line to be an HTTP request message receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above.,The server SHOULD respond with a 400 (Bad Request) response and close the connection.,Server,SHOULD,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.","A recipient that receives whitespace between the start-line and the first header field MUST either reject the message as invalid or consume each whitespace-preceded line without further processing of it (i.e., ignore the entire line, along with any subsequent lines preceded by whitespace, until a properly formed header field is received or the header section is terminated). Rejection or removal of invalid whitespace-preceded lines is necessary to prevent their misinterpretation by downstream recipients that might be vulnerable to request smuggling (Section 11.2) or response splitting (Section 11.1) attacks.",,2.2,Message Parsing,2,9,1,400,,,,,,SHOULD
"Such protocol downgrades SHOULD NOT be performed unless triggered by specific client attributes, such as when one or more of the request header fields (e.g., User-Agent) uniquely match the values sent by a client known to be in error.","Protocol downgrade is triggered only when specific client attributes are present, for example when one or more request header fields (e.g., User-Agent) uniquely match the values sent by a client known to be in error.",Do not perform protocol downgrades unless the trigger condition based on specific client attributes is met.,Server,SHOULD NOT,"A server MAY send an HTTP/1.0 response to an HTTP/1.1 request if it is known or suspected that the client incorrectly implements the HTTP specification and is incapable of correctly processing later version responses, such as when a client fails to parse the version number correctly or when an intermediary is known to blindly forward the HTTP-version even when it doesn't conform to the given minor version of the protocol. Such protocol downgrades SHOULD NOT be performed unless triggered by specific client attributes, such as when one or more of the request header fields (e.g., User-Agent) uniquely match the values sent by a client known to be in error.","Intermediaries that process HTTP messages (i.e., all intermediaries other than those acting as tunnels) MUST send their own HTTP-version in forwarded messages, unless it is purposefully downgraded as a workaround for an upstream issue. In other words, an intermediary is not allowed to blindly forward the start-line without ensuring that the protocol version in that message matches a version to which that intermediary is conformant for both the receiving and sending of messages. Forwarding an HTTP message without rewriting the HTTP-version might result in communication errors when downstream recipients use the message sender's version to determine what features are safe to use for later communication with that sender.",,2.3,HTTP Version,2,5,2,,User-Agent,,,,,SHOULD
"Although the request-line grammar rule requires that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the CRLF terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR.",When parsing the HTTP request-line instead of strictly enforcing a single SP octet as the separator between its components.,"Recipients MAY parse the request-line using whitespace-delimited word boundaries by treating any form of whitespace (i.e. one or more of SP, HTAB, VT (%x0B), FF (%x0C), or bare CR) as the separator (excluding the CRLF terminator) and ignoring any preceding or trailing whitespace.",Recipient,MAY,"Although the request-line grammar rule requires that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the CRLF terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR. However, lenient parsing can result in request smuggling security vulnerabilities if there are multiple recipients of the message and each has its own unique interpretation of robustness (see Section 11.2).","A request-line begins with a method token, followed by a single space (SP), the request-target, and another single space (SP), and ends with the protocol version.","HTTP does not place a predefined limit on the length of a request-line, as described in Section 2.3 of [HTTP]. A server that receives a method longer than any that it implements SHOULD respond with a 501 (Not Implemented) status code. A server that receives a request-target longer than any URI it wishes to parse MUST respond with a 414 (URI Too Long) status code (see Section 15.5.15 of [HTTP]).",3,Request Line,1,2,1,,,,,"CR,CRLF,SP",,MAY
A server that receives a method longer than any that it implements SHOULD respond with a 501 (Not Implemented) status code.,A server receives a method longer than any that it implements.,The server SHOULD respond with a 501 (Not Implemented) status code.,Server,SHOULD,"HTTP does not place a predefined limit on the length of a request-line, as described in Section 2.3 of [HTTP]. A server that receives a method longer than any that it implements SHOULD respond with a 501 (Not Implemented) status code. A server that receives a request-target longer than any URI it wishes to parse MUST respond with a 414 (URI Too Long) status code (see Section 15.5.15 of [HTTP]).","Although the request-line grammar rule requires that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the CRLF terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR. However, lenient parsing can result in request smuggling security vulnerabilities if there are multiple recipients of the message and each has its own unique interpretation of robustness (see Section 11.2).","Various ad hoc limitations on request-line length are found in practice. It is RECOMMENDED that all HTTP senders and recipients support, at a minimum, request-line lengths of 8000 octets.",3,Request Line,1,3,2,501,,,,,,SHOULD
A server that receives a request-target longer than any URI it wishes to parse MUST respond with a 414 (URI Too Long) status code (see Section 15.5.15 of [HTTP]).,Server receives a request-target longer than any URI it wishes to parse,Server MUST respond with a 414 (URI Too Long) status code,Server,MUST,"HTTP does not place a predefined limit on the length of a request-line, as described in Section 2.3 of [HTTP]. A server that receives a method longer than any that it implements SHOULD respond with a 501 (Not Implemented) status code. A server that receives a request-target longer than any URI it wishes to parse MUST respond with a 414 (URI Too Long) status code (see Section 15.5.15 of [HTTP]).","Although the request-line grammar rule requires that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the CRLF terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR. However, lenient parsing can result in request smuggling security vulnerabilities if there are multiple recipients of the message and each has its own unique interpretation of robustness (see Section 11.2).","Various ad hoc limitations on request-line length are found in practice. It is RECOMMENDED that all HTTP senders and recipients support, at a minimum, request-line lengths of 8000 octets.",3,Request Line,1,3,3,414,,,,,,MUST
Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,"The request-line is invalid (e.g., due to improperly encoded request-target, such as containing disallowed whitespace).","Recipients SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,Recipients SHOULD NOT attempt to autocorrect and then process the request without a redirect.",Recipient,SHOULD,"Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded. A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain.","No whitespace is allowed in the request-target. Unfortunately, some user agents fail to properly encode or exclude whitespace found in hypertext references, resulting in those disallowed characters being sent as the request-target in a malformed request-line.","A client MUST send a Host header field (Section 7.2 of [HTTP]) in all HTTP/1.1 request messages. If the target URI includes an authority component, then a client MUST send a field value for Host that is identical to that authority component, excluding any userinfo subcomponent and its ""@"" delimiter (Section 4.2 of [HTTP]). If the authority component is missing or undefined for the target URI, then a client MUST send a Host header field with an empty field value.",3.2,Request Target,2,3,1,"301,400",,,,,,SHOULD
A server MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message that lacks a Host header field and to any request message that contains more than one Host header field line or a Host header field with an invalid field value.,"HTTP/1.1 request message lacks a Host header field,HTTP/1.1 request message contains more than one Host header field line,HTTP/1.1 request message contains a Host header field with an invalid field value",Server MUST respond with a 400 (Bad Request) status code,Server,MUST,A server MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message that lacks a Host header field and to any request message that contains more than one Host header field line or a Host header field with an invalid field value.,"A client MUST send a Host header field (Section 7.2 of [HTTP]) in all HTTP/1.1 request messages. If the target URI includes an authority component, then a client MUST send a field value for Host that is identical to that authority component, excluding any userinfo subcomponent and its ""@"" delimiter (Section 4.2 of [HTTP]). If the authority component is missing or undefined for the target URI, then a client MUST send a Host header field with an empty field value.",,3.2,Request Target,2,5,1,400,Host,,,,,MUST
"When an origin server receives a request with an absolute-form of request-target, the origin server MUST ignore the received Host header field (if any) and instead use the host information of the request-target.",When an origin server receives a request with an absolute-form of request-target,The origin server MUST ignore the received Host header field (if any) and instead use the host information of the request-target,Origin Server,MUST,"When an origin server receives a request with an absolute-form of request-target, the origin server MUST ignore the received Host header field (if any) and instead use the host information of the request-target. Note that if the request-target does not have an authority component, an empty Host header field will be sent in this case.","When a proxy receives a request with an absolute-form of request-target, the proxy MUST ignore the received Host header field (if any) and instead replace it with the host information of the request-target. A proxy that forwards such a request MUST generate a new Host field value based on the received request-target rather than forward the received Host field value.",A server MUST accept the absolute-form in requests even though most HTTP/1.1 clients will only send the absolute-form to a proxy.,3.2.2,absolute-form,3,7,1,,Host,,,,,MUST
A server that can uniquely identify an authority from the request context MAY use that identity as a default without this risk,The server can uniquely identify an authority from the request context.,The server MAY use that identified authority as the default without incurring the risk associated with using a potentially incorrect default.,Server,MAY,"Supplying a default name for authority within the context of a secured connection is inherently unsafe if there is any chance that the user agent's intended authority might differ from the default. A server that can uniquely identify an authority from the request context MAY use that identity as a default without this risk. Alternatively, it might be better to redirect the request to a safe resource that explains how to obtain a new client.","If the target URI's authority component is empty and its URI scheme requires a non-empty authority (as is the case for ""http"" and ""https""), the server can reject the request or determine whether a configured default applies that is consistent with the incoming connection's context. Context might include connection details like address and port, what security has been applied, and locally defined information specific to that server's configuration. An empty authority is replaced with the configured default before further processing of the request.","Note that reconstructing the client's target URI is only half of the process for identifying a target resource. The other half is determining whether that target URI identifies a resource for which the server is willing and able to send a response, as defined in Section 7.4 of [HTTP].",3.3,Reconstructing the Target URI,2,14,2,,,identity,,,,MAY
"Although the status-line grammar rule requires that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the line terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR.","When parsing the status‐line, the component elements may be separated by whitespace that is not strictly a single SP octet; this includes cases where there is preceding or trailing whitespace, or where multiple forms of whitespace (SP, HTAB, VT, FF, or bare CR) are used between elements.",Recipients MAY parse the status‐line on whitespace-delimited word boundaries by treating any form of whitespace (as listed) as the SP separator (aside from the line terminator) and ignoring any preceding or trailing whitespace.,Recipient,MAY,"Although the status-line grammar rule requires that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the line terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR. However, lenient parsing can result in response splitting security vulnerabilities if there are multiple recipients of the message and each has its own unique interpretation of robustness (see Section 11.1).","The first line of a response message is the status-line, consisting of the protocol version, a space (SP), the status code, and another space and ending with an OPTIONAL textual phrase describing the status code.","The status-code element is a 3-digit integer code describing the result of the server's attempt to understand and satisfy the client's corresponding request. A recipient parses and interprets the remainder of the response message in light of the semantics defined for that status code, if the status code is recognized by that recipient, or in accordance with the class of that status code when the specific code is unrecognized.",4,Status Line,1,2,1,,,,,"CR,SP",,MAY
"A server MUST reject, with a response status code of 400 (Bad Request), any received request message that contains whitespace between a header field name and colon.",A received request message that contains whitespace between a header field name and colon.,The server MUST reject the request message and respond with a status code of 400 (Bad Request).,Server,MUST,"No whitespace is allowed between the field name and colon. In the past, differences in the handling of such whitespace have led to security vulnerabilities in request routing and response handling. A server MUST reject, with a response status code of 400 (Bad Request), any received request message that contains whitespace between a header field name and colon. A proxy MUST remove any such whitespace from a response message before forwarding the message downstream.","Messages are parsed using a generic algorithm, independent of the individual field names. The contents within a given field line value are not parsed until a later stage of message interpretation (usually after the message's entire field section has been processed).","A field line value might be preceded and/or followed by optional whitespace (OWS); a single SP preceding the field line value is preferred for consistent readability by humans. The field line value does not include that leading or trailing whitespace: OWS occurring before the first non-whitespace octet of the field line value, or after the last non-whitespace octet of the field line value, is excluded by parsers when extracting the field line value from a field line.",5.1,Field Line Parsing,2,2,3,400,,,,,,MUST
"A server that receives an obs-fold in a request message that is not within a ""message/http"" container MUST either reject the message by sending a 400 (Bad Request), preferably with a representation explaining that obsolete line folding is unacceptable, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.",The server receives an obs-fold in a request message that is not within a 'message/http' container.,"Either reject the message by sending a 400 (Bad Request) response, preferably with a representation explaining that obsolete line folding is unacceptable, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.",Server,MUST,"A server that receives an obs-fold in a request message that is not within a ""message/http"" container MUST either reject the message by sending a 400 (Bad Request), preferably with a representation explaining that obsolete line folding is unacceptable, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.","A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the ""message/http"" media type.","A proxy or gateway that receives an obs-fold in a response message that is not within a ""message/http"" container MUST either discard the message and replace it with a 502 (Bad Gateway) response, preferably with a representation explaining that unacceptable line folding was received, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.",5.2,Obsolete Line Folding,2,3,1,400,,,,SP,,MUST
A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance.,"The content size is not known in advance, necessitating accurate message framing.",The recipient MUST be able to parse the chunked transfer coding (Section 7.1).,Recipient,MUST,"A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance. A sender MUST NOT apply the chunked transfer coding more than once to a message body (i.e., chunking an already chunked message is not allowed). If any transfer coding other than chunked is applied to a request's content, the sender MUST apply chunked as the final transfer coding to ensure that the message is properly framed. If any transfer coding other than chunked is applied to a response's content, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection.","Transfer-Encoding is analogous to the Content-Transfer-Encoding field of MIME, which was designed to enable safe transport of binary data over a 7-bit transport service ([RFC2045], Section 6). However, safe transport has a different focus for an 8bit-clean transfer protocol. In HTTP's case, Transfer-Encoding is primarily intended to accurately delimit dynamically generated content. It also serves to distinguish encodings that are only applied in transit from the encodings that are a characteristic of the selected representation.","For example,",6.1,Transfer-Encoding,2,3,1,,,chunked,,,,MUST
"A sender MUST NOT apply the chunked transfer coding more than once to a message body (i.e., chunking an already chunked message is not allowed).","When a sender attempts to apply the chunked transfer coding to a message body that has already been chunked (i.e., the message body already contains chunked encoding).",The sender MUST NOT apply the chunked transfer coding more than once to a message body.,Sender,MUST NOT,"A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance. A sender MUST NOT apply the chunked transfer coding more than once to a message body (i.e., chunking an already chunked message is not allowed). If any transfer coding other than chunked is applied to a request's content, the sender MUST apply chunked as the final transfer coding to ensure that the message is properly framed. If any transfer coding other than chunked is applied to a response's content, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection.","Transfer-Encoding is analogous to the Content-Transfer-Encoding field of MIME, which was designed to enable safe transport of binary data over a 7-bit transport service ([RFC2045], Section 6). However, safe transport has a different focus for an 8bit-clean transfer protocol. In HTTP's case, Transfer-Encoding is primarily intended to accurately delimit dynamically generated content. It also serves to distinguish encodings that are only applied in transit from the encodings that are a characteristic of the selected representation.","For example,",6.1,Transfer-Encoding,2,3,2,,,chunked,,,,MUST
"If any transfer coding other than chunked is applied to a request's content, the sender MUST apply chunked as the final transfer coding to ensure that the message is properly framed.",Any transfer coding other than chunked is applied to a request's content.,The sender MUST apply chunked as the final transfer coding to ensure that the message is properly framed.,Sender,MUST,"A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance. A sender MUST NOT apply the chunked transfer coding more than once to a message body (i.e., chunking an already chunked message is not allowed). If any transfer coding other than chunked is applied to a request's content, the sender MUST apply chunked as the final transfer coding to ensure that the message is properly framed. If any transfer coding other than chunked is applied to a response's content, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection.","Transfer-Encoding is analogous to the Content-Transfer-Encoding field of MIME, which was designed to enable safe transport of binary data over a 7-bit transport service ([RFC2045], Section 6). However, safe transport has a different focus for an 8bit-clean transfer protocol. In HTTP's case, Transfer-Encoding is primarily intended to accurately delimit dynamically generated content. It also serves to distinguish encodings that are only applied in transit from the encodings that are a characteristic of the selected representation.","For example,",6.1,Transfer-Encoding,2,3,3,,,chunked,,,,MUST
"If any transfer coding other than chunked is applied to a response's content, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection.",Any transfer coding other than chunked is applied to a response's content,"Apply chunked as the final transfer coding,Or terminate the message by closing the connection",Sender,MUST,"A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance. A sender MUST NOT apply the chunked transfer coding more than once to a message body (i.e., chunking an already chunked message is not allowed). If any transfer coding other than chunked is applied to a request's content, the sender MUST apply chunked as the final transfer coding to ensure that the message is properly framed. If any transfer coding other than chunked is applied to a response's content, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection.","Transfer-Encoding is analogous to the Content-Transfer-Encoding field of MIME, which was designed to enable safe transport of binary data over a 7-bit transport service ([RFC2045], Section 6). However, safe transport has a different focus for an 8bit-clean transfer protocol. In HTTP's case, Transfer-Encoding is primarily intended to accurately delimit dynamically generated content. It also serves to distinguish encodings that are only applied in transit from the encodings that are a characteristic of the selected representation.","For example,",6.1,Transfer-Encoding,2,3,4,,,chunked,,,,MUST
"Any recipient along the request/response chain MAY decode the received transfer coding(s) or apply additional transfer coding(s) to the message body, assuming that corresponding changes are made to the Transfer-Encoding field value.",A recipient along the request/response chain receives a message in which transfer coding(s) have been applied to the message body.,"When decoding received transfer coding(s) or applying additional transfer coding(s) to the message body, the recipient MUST make corresponding changes to the Transfer-Encoding field value.",Recipient,MAY,"Unlike Content-Encoding (Section 8.4.1 of [HTTP]), Transfer-Encoding is a property of the message, not of the representation. Any recipient along the request/response chain MAY decode the received transfer coding(s) or apply additional transfer coding(s) to the message body, assuming that corresponding changes are made to the Transfer-Encoding field value. Additional information about the encoding parameters can be provided by other header fields not defined by this specification.",indicates that the content has been compressed using the gzip coding and then chunked using the chunked coding while forming the message body.,"Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response (Section 15.4.5 of [HTTP]) to a GET request, neither of which includes a message body, to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET. This indication is not required, however, because any recipient on the response chain (including the origin server) can remove transfer codings when they are not needed.",6.1,Transfer-Encoding,2,7,2,,Transfer-Encoding,,,,,MAY
"Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response (Section 15.4.5 of [HTTP]) to a GET request, neither of which includes a message body, to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET.","A response to a HEAD request,A response with a 304 (Not Modified) status to a GET request, where the response does not include a message body",The response MAY include the Transfer-Encoding header field to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET,Origin Server,MAY,"Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response (Section 15.4.5 of [HTTP]) to a GET request, neither of which includes a message body, to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET. This indication is not required, however, because any recipient on the response chain (including the origin server) can remove transfer codings when they are not needed.","Unlike Content-Encoding (Section 8.4.1 of [HTTP]), Transfer-Encoding is a property of the message, not of the representation. Any recipient along the request/response chain MAY decode the received transfer coding(s) or apply additional transfer coding(s) to the message body, assuming that corresponding changes are made to the Transfer-Encoding field value. Additional information about the encoding parameters can be provided by other header fields not defined by this specification.",A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content). A server MUST NOT send a Transfer-Encoding header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6 of [HTTP]).,6.1,Transfer-Encoding,2,8,1,304,Transfer-Encoding,,"GET,HEAD",,,MAY
A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content).,"Response with status code of 1xx (Informational) or 204 (No Content),2xx (Successful) response to a CONNECT request",The server MUST NOT send a Transfer-Encoding header field in the response.,Server,MUST NOT,A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content). A server MUST NOT send a Transfer-Encoding header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6 of [HTTP]).,"Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response (Section 15.4.5 of [HTTP]) to a GET request, neither of which includes a message body, to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET. This indication is not required, however, because any recipient on the response chain (including the origin server) can remove transfer codings when they are not needed.",A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 (Not Implemented).,6.1,Transfer-Encoding,2,9,1,"1xx,204",Transfer-Encoding,,,,,MUST
A server MUST NOT send a Transfer-Encoding header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6 of [HTTP]).,A response with a status code in the 2xx (Successful) range that is sent in reply to a CONNECT request,The server MUST NOT send a Transfer-Encoding header field,Server,MUST NOT,A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content). A server MUST NOT send a Transfer-Encoding header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6 of [HTTP]).,"Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response (Section 15.4.5 of [HTTP]) to a GET request, neither of which includes a message body, to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET. This indication is not required, however, because any recipient on the response chain (including the origin server) can remove transfer codings when they are not needed.",A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 (Not Implemented).,6.1,Transfer-Encoding,2,9,2,2xx,Transfer-Encoding,,CONNECT,,,MUST
A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 (Not Implemented).,A server receives a request message with a transfer coding it does not understand.,The server SHOULD respond with a 501 (Not Implemented) status code.,Server,SHOULD,A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 (Not Implemented).,A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content). A server MUST NOT send a Transfer-Encoding header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6 of [HTTP]).,"Transfer-Encoding was added in HTTP/1.1. It is generally assumed that implementations advertising only HTTP/1.0 support will not understand how to process transfer-encoded content, and that an HTTP/1.0 message received with a Transfer-Encoding is likely to have been forwarded without proper handling of the chunked transfer coding in transit.",6.1,Transfer-Encoding,2,10,1,501,,,,,,SHOULD
A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 requests (or later minor revisions); such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response.,A client is about to send a request containing the Transfer-Encoding header without confirmed knowledge that the server supports HTTP/1.1 (or later minor revisions).,"The client MUST NOT send a request containing Transfer-Encoding unless it knows, via user configuration or by memorizing a prior received response, that the server will handle HTTP/1.1 requests (or later minor revisions).","Client,Server",MUST NOT,A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 requests (or later minor revisions); such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response. A server MUST NOT send a response containing Transfer-Encoding unless the corresponding request indicates HTTP/1.1 (or later minor revisions).,"Transfer-Encoding was added in HTTP/1.1. It is generally assumed that implementations advertising only HTTP/1.0 support will not understand how to process transfer-encoded content, and that an HTTP/1.0 message received with a Transfer-Encoding is likely to have been forwarded without proper handling of the chunked transfer coding in transit.","Early implementations of Transfer-Encoding would occasionally send both a chunked transfer coding for message framing and an estimated Content-Length header field for use by progress bars. This is why Transfer-Encoding is defined as overriding Content-Length, as opposed to them being mutually incompatible. Unfortunately, forwarding such a message can lead to vulnerabilities regarding request smuggling (Section 11.2) or response splitting (Section 11.1) attacks if any downstream recipient fails to parse the message according to this specification, particularly when a downstream recipient only implements HTTP/1.0.",6.1,Transfer-Encoding,2,12,1,,Transfer-Encoding,,,,,MUST
A server MUST NOT send a response containing Transfer-Encoding unless the corresponding request indicates HTTP/1.1 (or later minor revisions).,"The response would include a Transfer-Encoding header, but the corresponding request does not indicate HTTP/1.1 (or later minor revisions)",The server MUST NOT send a response containing Transfer-Encoding unless the corresponding request indicates HTTP/1.1 (or later minor revisions),Server,MUST NOT,A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 requests (or later minor revisions); such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response. A server MUST NOT send a response containing Transfer-Encoding unless the corresponding request indicates HTTP/1.1 (or later minor revisions).,"Transfer-Encoding was added in HTTP/1.1. It is generally assumed that implementations advertising only HTTP/1.0 support will not understand how to process transfer-encoded content, and that an HTTP/1.0 message received with a Transfer-Encoding is likely to have been forwarded without proper handling of the chunked transfer coding in transit.","Early implementations of Transfer-Encoding would occasionally send both a chunked transfer coding for message framing and an estimated Content-Length header field for use by progress bars. This is why Transfer-Encoding is defined as overriding Content-Length, as opposed to them being mutually incompatible. Unfortunately, forwarding such a message can lead to vulnerabilities regarding request smuggling (Section 11.2) or response splitting (Section 11.1) attacks if any downstream recipient fails to parse the message according to this specification, particularly when a downstream recipient only implements HTTP/1.0.",6.1,Transfer-Encoding,2,12,2,,Transfer-Encoding,,,,,MUST
A server MAY reject a request that contains both Content-Length and Transfer-Encoding or process such a request in accordance with the Transfer-Encoding alone.,The request contains both Content-Length and Transfer-Encoding header fields,"After responding to such a request, the server MUST close the connection to avoid potential attacks",Server,MAY,"A server MAY reject a request that contains both Content-Length and Transfer-Encoding or process such a request in accordance with the Transfer-Encoding alone. Regardless, the server MUST close the connection after responding to such a request to avoid the potential attacks.","Early implementations of Transfer-Encoding would occasionally send both a chunked transfer coding for message framing and an estimated Content-Length header field for use by progress bars. This is why Transfer-Encoding is defined as overriding Content-Length, as opposed to them being mutually incompatible. Unfortunately, forwarding such a message can lead to vulnerabilities regarding request smuggling (Section 11.2) or response splitting (Section 11.1) attacks if any downstream recipient fails to parse the message according to this specification, particularly when a downstream recipient only implements HTTP/1.0.","A server or client that receives an HTTP/1.0 message containing a Transfer-Encoding header field MUST treat the message as if the framing is faulty, even if a Content-Length is present, and close the connection after processing the message. The message sender might have retained a portion of the message, in buffer, that could be misinterpreted by further use of the connection.",6.1,Transfer-Encoding,2,14,1,,"Content-Length,Transfer-Encoding",,,,,MAY
"A server or client that receives an HTTP/1.0 message containing a Transfer-Encoding header field MUST treat the message as if the framing is faulty, even if a Content-Length is present, and close the connection after processing the message.",The message is an HTTP/1.0 message containing a Transfer-Encoding header field,"Treat the message as if the framing is faulty, even if a Content-Length is present,Close the connection after processing the message","Server,Client",MUST,"A server or client that receives an HTTP/1.0 message containing a Transfer-Encoding header field MUST treat the message as if the framing is faulty, even if a Content-Length is present, and close the connection after processing the message. The message sender might have retained a portion of the message, in buffer, that could be misinterpreted by further use of the connection.","A server MAY reject a request that contains both Content-Length and Transfer-Encoding or process such a request in accordance with the Transfer-Encoding alone. Regardless, the server MUST close the connection after responding to such a request to avoid the potential attacks.",,6.1,Transfer-Encoding,2,15,1,,"Content-Length,Transfer-Encoding",,,,,MUST
A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,A message that contains a Transfer-Encoding header field,The sender MUST NOT send a Content-Length header field in that message,Sender,MUST NOT,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,"When a message does not have a Transfer-Encoding header field, a Content-Length header field (Section 8.6 of [HTTP]) can provide the anticipated size, as a decimal number of octets, for potential content. For messages that do include content, the Content-Length field value provides the framing information necessary for determining where the data (and message) ends. For messages that do not include content, the Content-Length indicates the size of the selected representation (Section 8.6 of [HTTP]).",,6.2,Content-Length,2,2,1,,"Content-Length,Transfer-Encoding",,,,,MUST
"If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value).","A message is received without a Transfer-Encoding header field and with an invalid Content-Length header field, except when the field value can be successfully parsed as a comma‐separated list in which all values are valid and identical.",The message framing is considered invalid and the recipient MUST treat it as an unrecoverable error (with specific actions taken based on whether the message is a request or response).,Recipient,MUST,"5. If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value). If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection. If it is in a response message received by a proxy, the proxy MUST close the connection to the server, discard the received response, and send a 502 (Bad Gateway) response to the client. If it is in a response message received by a user agent, the user agent MUST close the connection to the server and discard the received response. 6. If a valid Content-Length header field is present without Transfer-Encoding, its decimal value defines the expected message body length in octets. If the sender closes the connection or the recipient times out before the indicated number of octets are received, the recipient MUST consider the message to be incomplete and close the connection. 7. If this is a request message and none of the above are true, then the message body length is zero (no message body is present). 8. Otherwise, this is a response message without a declared message body length, so the message body length is determined by the number of octets received prior to the server closing the connection.","The length of a message body is determined by one of the following (in order of precedence): 1. Any response to a HEAD request and any response with a 1xx (Informational), 204 (No Content), or 304 (Not Modified) status code is always terminated by the first empty line after the header fields, regardless of the header fields present in the message, and thus cannot contain a message body or trailer section. 2. Any 2xx (Successful) response to a CONNECT request implies that the connection will become a tunnel immediately after the empty line that concludes the header fields. A client MUST ignore any Content-Length or Transfer-Encoding header fields received in such a message. 3. If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length. Such a message might indicate an attempt to perform request smuggling (Section 11.2) or response splitting (Section 11.1) and ought to be handled as an error. An intermediary that chooses to forward the message MUST first remove the received Content-Length field and process the Transfer-Encoding (as described below) prior to forwarding the message downstream. 4. If a Transfer-Encoding header field is present and the chunked transfer coding (Section 7.1) is the final encoding, the message body length is determined by reading and decoding the chunked data until the transfer coding indicates the data is complete.","Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible. The close-delimiting feature exists primarily for backwards compatibility with HTTP/1.0.",6.3,Message Body Length,2,2,2,,"Content-Length,Transfer-Encoding",,,,,MUST
"If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.",An unrecoverable error is detected in a request message,"The server MUST respond with a 400 (Bad Request) status code,The server MUST then close the connection",Server,MUST,"5. If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value). If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection. If it is in a response message received by a proxy, the proxy MUST close the connection to the server, discard the received response, and send a 502 (Bad Gateway) response to the client. If it is in a response message received by a user agent, the user agent MUST close the connection to the server and discard the received response. 6. If a valid Content-Length header field is present without Transfer-Encoding, its decimal value defines the expected message body length in octets. If the sender closes the connection or the recipient times out before the indicated number of octets are received, the recipient MUST consider the message to be incomplete and close the connection. 7. If this is a request message and none of the above are true, then the message body length is zero (no message body is present). 8. Otherwise, this is a response message without a declared message body length, so the message body length is determined by the number of octets received prior to the server closing the connection.","The length of a message body is determined by one of the following (in order of precedence): 1. Any response to a HEAD request and any response with a 1xx (Informational), 204 (No Content), or 304 (Not Modified) status code is always terminated by the first empty line after the header fields, regardless of the header fields present in the message, and thus cannot contain a message body or trailer section. 2. Any 2xx (Successful) response to a CONNECT request implies that the connection will become a tunnel immediately after the empty line that concludes the header fields. A client MUST ignore any Content-Length or Transfer-Encoding header fields received in such a message. 3. If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length. Such a message might indicate an attempt to perform request smuggling (Section 11.2) or response splitting (Section 11.1) and ought to be handled as an error. An intermediary that chooses to forward the message MUST first remove the received Content-Length field and process the Transfer-Encoding (as described below) prior to forwarding the message downstream. 4. If a Transfer-Encoding header field is present and the chunked transfer coding (Section 7.1) is the final encoding, the message body length is determined by reading and decoding the chunked data until the transfer coding indicates the data is complete.","Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible. The close-delimiting feature exists primarily for backwards compatibility with HTTP/1.0.",6.3,Message Body Length,2,2,3,400,,,,,,MUST
A server MAY reject a request that contains a message body but not a Content-Length by responding with 411 (Length Required).,A request contains a message body but does not include a Content-Length header,The server MAY reject the request by responding with a 411 (Length Required) status code,Server,MAY,A server MAY reject a request that contains a message body but not a Content-Length by responding with 411 (Length Required).,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible. The close-delimiting feature exists primarily for backwards compatibility with HTTP/1.0.","Unless a transfer coding other than chunked has been applied, a client that sends a request containing a message body SHOULD use a valid Content-Length header field if the message body length is known in advance, rather than the chunked transfer coding, since some existing services respond to chunked with a 411 (Length Required) status code even though they understand the chunked transfer coding. This is typically because such services are implemented via a gateway that requires a content length in advance of being called, and the server is unable or unwilling to buffer the entire request before processing.",6.3,Message Body Length,2,4,1,411,Content-Length,,,,,MAY
A recipient MUST be able to parse and decode the chunked transfer coding.,When a received HTTP message utilizes chunked transfer coding,The recipient MUST be able to parse and decode the chunked transfer coding,Recipient,MUST,A recipient MUST be able to parse and decode the chunked transfer coding.,"The chunk-size field is a string of hex digits indicating the size of the chunk-data in octets. The chunked transfer coding is complete when a chunk with a chunk-size of zero is received, possibly followed by a trailer section, and finally terminated by an empty line.","HTTP/1.1 does not define any means to limit the size of a chunked response such that an intermediary can be assured of buffering the entire response. Additionally, very large chunk sizes may cause overflows or loss of precision if their values are not represented accurately in a receiving implementation. Therefore, recipients MUST anticipate potentially large hexadecimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer representation.",7.1,Chunked Transfer Coding,2,3,1,,,chunked,,,,MUST
A recipient that removes the chunked coding from a message MAY selectively retain or discard the received trailer fields.,A recipient removes the chunked coding from a message.,The recipient may selectively retain or discard the received trailer fields.,Recipient,MAY,A recipient that removes the chunked coding from a message MAY selectively retain or discard the received trailer fields. A recipient that retains a received trailer field MUST either store/ forward the trailer field separately from the received header fields or merge the received trailer field into the header section. A recipient MUST NOT merge a received trailer field into the header section unless its corresponding header field definition explicitly permits and instructs how the trailer field value can be safely merged.,"A trailer section allows the sender to include additional fields at the end of a chunked message in order to supply metadata that might be dynamically generated while the content is sent, such as a message integrity check, digital signature, or post-processing status. The proper use and limitations of trailer fields are defined in Section 6.5 of [HTTP].",,7.1.2,Chunked Trailer Section,3,2,1,,trailer,chunked,,,,MAY
A recipient that retains a received trailer field MUST either store/ forward the trailer field separately from the received header fields or merge the received trailer field into the header section.,A recipient that retains a received trailer field,Store/forward the trailer field separately from the received header fields or merge the received trailer field into the header section,Recipient,MUST,A recipient that removes the chunked coding from a message MAY selectively retain or discard the received trailer fields. A recipient that retains a received trailer field MUST either store/ forward the trailer field separately from the received header fields or merge the received trailer field into the header section. A recipient MUST NOT merge a received trailer field into the header section unless its corresponding header field definition explicitly permits and instructs how the trailer field value can be safely merged.,"A trailer section allows the sender to include additional fields at the end of a chunked message in order to supply metadata that might be dynamically generated while the content is sent, such as a message integrity check, digital signature, or post-processing status. The proper use and limitations of trailer fields are defined in Section 6.5 of [HTTP].",,7.1.2,Chunked Trailer Section,3,2,2,,trailer,,,,,MUST
A recipient MUST NOT merge a received trailer field into the header section unless its corresponding header field definition explicitly permits and instructs how the trailer field value can be safely merged.,"A recipient is handling a received trailer field in a message,The corresponding header field definition does not explicitly permit and instruct how the trailer field value can be safely merged",The recipient MUST NOT merge the received trailer field into the header section,Recipient,MUST NOT,A recipient that removes the chunked coding from a message MAY selectively retain or discard the received trailer fields. A recipient that retains a received trailer field MUST either store/ forward the trailer field separately from the received header fields or merge the received trailer field into the header section. A recipient MUST NOT merge a received trailer field into the header section unless its corresponding header field definition explicitly permits and instructs how the trailer field value can be safely merged.,"A trailer section allows the sender to include additional fields at the end of a chunked message in order to supply metadata that might be dynamically generated while the content is sent, such as a message integrity check, digital signature, or post-processing status. The proper use and limitations of trailer fields are defined in Section 6.5 of [HTTP].",,7.1.2,Chunked Trailer Section,3,2,3,,trailer,,,,,MUST
The presence of parameters with any of these compression codings SHOULD be treated as an error.,"The presence of parameters with any of the specified compression codings (e.g., gzip, x-gzip)",Treat the occurrence as an error,Recipient,SHOULD,The compression codings do not define any parameters. The presence of parameters with any of these compression codings SHOULD be treated as an error.,gzip (and x-gzip) See Section 8.4.1.3 of [HTTP].,,7.2,Transfer Codings for Compression,2,5,2,,,compress,,,,SHOULD
"Names of transfer codings MUST NOT overlap with names of content codings (Section 8.4.1 of [HTTP]) unless the encoding transformation is identical, as is the case for the compression codings defined in Section 7.2.","When a transfer coding name is identical to a content coding name, except in cases where the encoding transformation is identical (as with compression codings).",Names of transfer codings MUST NOT overlap with names of content codings.,"Sender,Recipient",MUST NOT,"Names of transfer codings MUST NOT overlap with names of content codings (Section 8.4.1 of [HTTP]) unless the encoding transformation is identical, as is the case for the compression codings defined in Section 7.2.",* Pointer to specification text,"The TE header field (Section 10.1.4 of [HTTP]) uses a pseudo-parameter named ""q"" as the rank value when multiple transfer codings are acceptable. Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",7.3,Transfer Coding Registry,2,6,1,,,compress,,,,MUST
"Since the TE header field only applies to the immediate connection, a sender of TE MUST also send a ""TE"" connection option within the Connection header field (Section 7.6.1 of [HTTP]) in order to prevent the TE header field from being forwarded by intermediaries that do not support its semantics.","When a sender includes a TE header field in a message, given that the TE header field only applies to the immediate connection",The sender MUST also send a 'TE' connection option within the Connection header field to prevent the TE header field from being forwarded by intermediaries that do not support its semantics,Sender,MUST,"Since the TE header field only applies to the immediate connection, a sender of TE MUST also send a ""TE"" connection option within the Connection header field (Section 7.6.1 of [HTTP]) in order to prevent the TE header field from being forwarded by intermediaries that do not support its semantics.","The keyword ""trailers"" indicates that the sender will not discard trailer fields, as described in Section 6.5 of [HTTP].",,7.4,Negotiating Transfer Codings,2,8,1,,"Connection,TE",,,,,MUST
"A server that does not support persistent connections MUST send the ""close"" connection option in every response message that does not have a 1xx (Informational) status code.",The server does not support persistent connections and the response message does not have a 1xx (Informational) status code,The server MUST send the 'close' connection option in the response message,Server,MUST,"A server that does not support persistent connections MUST send the ""close"" connection option in every response message that does not have a 1xx (Informational) status code.","A client that does not support persistent connections MUST send the ""close"" connection option in every request message.","A client MAY send additional requests on a persistent connection until it sends or receives a ""close"" connection option or receives an HTTP/1.0 response without a ""keep-alive"" connection option.",9.3,Persistence,2,8,1,1xx,,,,,,MUST
"A sender SHOULD send a Connection header field (Section 7.6.1 of [HTTP]) containing the ""close"" connection option when it intends to close a connection.",When the sender intends to close a connection,The sender SHOULD send a Connection header field containing the 'close' connection option,Sender,SHOULD,"The ""close"" connection option is defined as a signal that the sender will close this connection after completion of the response. A sender SHOULD send a Connection header field (Section 7.6.1 of [HTTP]) containing the ""close"" connection option when it intends to close a connection. For example,",,Connection: close,9.6,Tear-down,2,1,2,,Connection,,,,,SHOULD
"A recipient of ""message/http"" data MUST replace any obsolete line folding with one or more SP characters when the message is consumed.","When consuming 'message/http' data, if the message contains obsolete line folding",Replace any obsolete line folding with one or more SP characters,Recipient,MUST,"The ""message/http"" media type can be used to enclose a single HTTP request or response message, provided that it obeys the MIME restrictions for all ""message"" types regarding line length and encodings. Because of the line length limitations, field values within ""message/http"" are allowed to use line folding (obs-fold), as described in Section 5.2, to convey the field value over multiple lines. A recipient of ""message/http"" data MUST replace any obsolete line folding with one or more SP characters when the message is consumed.",,Type name: message,10.1,Media Type message/http,2,1,3,,,,,SP,,MUST
A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,"When a sender is about to generate a protocol element, the element does not conform to the grammar defined by the corresponding ABNF rules.",The sender MUST NOT generate any protocol element that does not match the specified ABNF grammar.,Sender,MUST NOT,"A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",An implementation is considered conformant if it complies with all of the requirements associated with the roles it partakes in HTTP.,"Conformance to HTTP includes both conformance to the particular messaging syntax of the protocol version in use and conformance to the semantics of protocol elements sent. For example, a client that claims conformance to HTTP/1.1 but fails to recognize the features required of HTTP/1.1 recipients will fail to interoperate with servers that adjust their responses in accordance with those claims. Features that reflect user choices, such as content negotiation and user-selected extensions, can impact application behavior beyond the protocol stream; sending protocol elements that inaccurately reflect a user's choices will confuse the user and inhibit choice.",2.2,Requirements Notation,2,5,1,,,,,,A1,MUST
"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).","Within a given message, if a sender generates protocol elements or syntax alternatives that are only allowed to be generated by participants in roles not held by the sender for that message.",The sender MUST NOT generate such protocol elements or syntax alternatives.,Sender,MUST NOT,"A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",An implementation is considered conformant if it complies with all of the requirements associated with the roles it partakes in HTTP.,"Conformance to HTTP includes both conformance to the particular messaging syntax of the protocol version in use and conformance to the semantics of protocol elements sent. For example, a client that claims conformance to HTTP/1.1 but fails to recognize the features required of HTTP/1.1 recipients will fail to interoperate with servers that adjust their responses in accordance with those claims. Features that reflect user choices, such as content negotiation and user-selected extensions, can impact application behavior beyond the protocol stream; sending protocol elements that inaccurately reflect a user's choices will confuse the user and inhibit choice.",2.2,Requirements Notation,2,5,2,,,,,,A1,MUST
A recipient MAY employ such workarounds while remaining conformant to this protocol if the workarounds are limited to the implementations at fault.,Workarounds must be limited to the implementations at fault.,The recipient MAY employ such workarounds while remaining conformant to the protocol.,Recipient,MAY,"When an implementation fails semantic conformance, recipients of that implementation's messages will eventually develop workarounds to adjust their behavior accordingly. A recipient MAY employ such workarounds while remaining conformant to this protocol if the workarounds are limited to the implementations at fault. For example, servers often scan portions of the User-Agent field value, and user agents often scan the Server field value, to adjust their own behavior with respect to known bugs or poorly chosen defaults.","Conformance to HTTP includes both conformance to the particular messaging syntax of the protocol version in use and conformance to the semantics of protocol elements sent. For example, a client that claims conformance to HTTP/1.1 but fails to recognize the features required of HTTP/1.1 recipients will fail to interoperate with servers that adjust their responses in accordance with those claims. Features that reflect user choices, such as content negotiation and user-selected extensions, can impact application behavior beyond the protocol stream; sending protocol elements that inaccurately reflect a user's choices will confuse the user and inhibit choice.",,2.2,Requirements Notation,2,7,2,,,,,,A2,MAY
"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",A protocol element is received,"The recipient SHOULD parse the received protocol element defensively, operating under the assumption that the element may only marginally conform to its ABNF grammar and may not fit within a reasonable buffer size",Recipient,SHOULD,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",,"HTTP does not have specific length limitations for many of its protocol elements because the lengths that might be appropriate will vary widely, depending on the deployment context and purpose of the implementation. Hence, interoperability between senders and recipients depends on shared expectations regarding what is a reasonable length for each protocol element. Furthermore, what is commonly understood to be a reasonable length for some protocol elements has changed over the course of the past three decades of HTTP use and is expected to continue changing in the future.",2.3,Length Requirements,2,1,1,,,,,,A2,SHOULD
"At a minimum, a recipient MUST be able to parse and process protocol element lengths that are at least as long as the values that it generates for those same protocol elements in other messages.","When a recipient-generated protocol element is used in other messages, resulting in protocol element lengths in incoming messages that are at least as long as those generated by the recipient.",The recipient MUST be able to parse and process protocol element lengths that are at least as long as the values it generates for those same protocol elements in outgoing messages.,Recipient,MUST,"At a minimum, a recipient MUST be able to parse and process protocol element lengths that are at least as long as the values that it generates for those same protocol elements in other messages. For example, an origin server that publishes very long URI references to its own resources needs to be able to parse and process those same references when received as a target URI.","HTTP does not have specific length limitations for many of its protocol elements because the lengths that might be appropriate will vary widely, depending on the deployment context and purpose of the implementation. Hence, interoperability between senders and recipients depends on shared expectations regarding what is a reasonable length for each protocol element. Furthermore, what is commonly understood to be a reasonable length for some protocol elements has changed over the course of the past three decades of HTTP use and is expected to continue changing in the future.","Many received protocol elements are only parsed to the extent necessary to identify and forward that element downstream. For example, an intermediary might parse a received field into its field name and field value components, but then forward the field without further parsing inside the field value.",2.3,Length Requirements,2,3,1,,,,,,A2,MUST
"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.","A protocol element is received, and the recipient has not determined (through experience or configuration) that the sender incorrectly implements its implied semantics.","Interpret the received protocol element according to the semantics defined for it by the specification, including its extensions.",Recipient,MUST,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics. For example, an origin server might disregard the contents of a received Accept-Encoding header field if inspection of the User-Agent header field indicates a specific implementation version that is known to fail on receipt of certain content codings.",,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct. HTTP does not define specific error handling mechanisms except when they have a direct impact on security, since different applications of the protocol require different error handling strategies. For example, a Web browser might wish to transparently recover from a response where the Location header field doesn't parse according to the ABNF, whereas a systems control client might consider any form of error recovery to be dangerous.",2.4,Error Handling,2,1,1,,,,,,A2,MUST
"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",The protocol element is invalid (i.e. received in an invalid construct) and there is no specific directive that prohibits recovery.,The recipient MAY attempt to recover a usable protocol element from the invalid construct.,Recipient,MAY,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct. HTTP does not define specific error handling mechanisms except when they have a direct impact on security, since different applications of the protocol require different error handling strategies. For example, a Web browser might wish to transparently recover from a response where the Location header field doesn't parse according to the ABNF, whereas a systems control client might consider any form of error recovery to be dangerous.","A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics. For example, an origin server might disregard the contents of a received Accept-Encoding header field if inspection of the User-Agent header field indicates a specific implementation version that is known to fail on receipt of certain content codings.","Some requests can be automatically retried by a client in the event of an underlying connection failure, as described in Section 9.2.2.",2.4,Error Handling,2,2,1,,,,,,A2,MAY
"As a result, a server MUST NOT assume that two requests on the same connection are from the same user agent unless the connection is secured and specific to that agent.",Two requests are received on the same connection without assurance that the connection is secured and specific to a particular user agent.,"The server MUST NOT assume that the two requests on the same connection originate from the same user agent, unless the connection is secured and specific to that agent.",Server,MUST NOT,"As a result, a server MUST NOT assume that two requests on the same connection are from the same user agent unless the connection is secured and specific to that agent. Some non-standard HTTP extensions (e.g., [RFC4559]) have been known to violate this requirement, resulting in security and interoperability problems.","HTTP is defined as a stateless protocol, meaning that each request message's semantics can be understood in isolation, and that the relationship between connections and messages on them has no impact on the interpretation of those messages. For example, a CONNECT request (Section 9.3.6) or a request with the Upgrade header field (Section 7.8) can occur at any time, not just in the first message on a connection. Many implementations depend on HTTP's stateless design in order to reuse proxied connections or dynamically load balance requests across multiple servers.",,3.3,"Connections, Clients, and Servers",2,5,1,,,,,,G2,MUST
"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",When a client or server is acting as a tunnel,A cache MUST NOT be used while acting as a tunnel,"Client,Server",MAY,"A ""cache"" is a local store of previous response messages and the subsystem that controls its message storage, retrieval, and deletion. A cache stores cacheable responses in order to reduce the response time and network bandwidth consumption on future, equivalent requests. Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",,The effect of a cache is that the request/response chain is shortened if one of the participants along the chain has a cached response applicable to that request. The following illustrates the resulting chain if B has a cached copy of an earlier response from O (via C) for a request that has not been cached by UA or A.,3.8,Caches,2,1,3,,,,,,F1,MAY
"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",A situation where a sender is about to generate an 'http' URI that has an empty host identifier.,The sender MUST NOT generate an 'http' URI with an empty host identifier.,"Sender,Recipient",MUST NOT,"A sender MUST NOT generate an ""http"" URI with an empty host identifier. A recipient that processes such a URI reference MUST reject it as invalid.","The origin server for an ""http"" URI is identified by the authority component, which includes a host identifier ([URI], Section 3.2.2) and optional port number ([URI], Section 3.2.3). If the port subcomponent is empty or not given, TCP port 80 (the reserved port for WWW services) is the default. The origin determines who has the right to respond authoritatively to requests that target the identified resource, as defined in Section 4.3.2.",The hierarchical path component and optional query component identify the target resource within that origin server's namespace.,4.2.1,http URI Scheme,3,3,1,,,,,,B1,MUST
A recipient that processes such a URI reference MUST reject it as invalid.,The recipient processes a URI reference that has an empty host identifier (as implied by the preceding requirement that a sender MUST NOT generate an 'http' URI with an empty host identifier),The recipient MUST reject the URI reference as invalid.,Recipient,MUST,"A sender MUST NOT generate an ""http"" URI with an empty host identifier. A recipient that processes such a URI reference MUST reject it as invalid.","The origin server for an ""http"" URI is identified by the authority component, which includes a host identifier ([URI], Section 3.2.2) and optional port number ([URI], Section 3.2.3). If the port subcomponent is empty or not given, TCP port 80 (the reserved port for WWW services) is the default. The origin determines who has the right to respond authoritatively to requests that target the identified resource, as defined in Section 4.3.2.",The hierarchical path component and optional query component identify the target resource within that origin server's namespace.,4.2.1,http URI Scheme,3,3,2,,,,,,B1,MUST
"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",When a sender attempts to generate an 'https' URI such that the host identifier is empty.,The sender MUST NOT generate an 'https' URI with an empty host identifier.,"Sender,Recipient",MUST NOT,"A sender MUST NOT generate an ""https"" URI with an empty host identifier. A recipient that processes such a URI reference MUST reject it as invalid.","The origin server for an ""https"" URI is identified by the authority component, which includes a host identifier ([URI], Section 3.2.2) and optional port number ([URI], Section 3.2.3). If the port subcomponent is empty or not given, TCP port 443 (the reserved port for HTTP over TLS) is the default. The origin determines who has the right to respond authoritatively to requests that target the identified resource, as defined in Section 4.3.3.",The hierarchical path component and optional query component identify the target resource within that origin server's namespace.,4.2.2,https URI Scheme,3,3,1,,,,,,B1,MUST
A recipient that processes such a URI reference MUST reject it as invalid.,A recipient processes an 'https' URI reference with an empty host identifier,The recipient MUST reject the URI reference as invalid,Recipient,MUST,"A sender MUST NOT generate an ""https"" URI with an empty host identifier. A recipient that processes such a URI reference MUST reject it as invalid.","The origin server for an ""https"" URI is identified by the authority component, which includes a host identifier ([URI], Section 3.2.2) and optional port number ([URI], Section 3.2.3). If the port subcomponent is empty or not given, TCP port 443 (the reserved port for HTTP over TLS) is the default. The origin determines who has the right to respond authoritatively to requests that target the identified resource, as defined in Section 4.3.3.",The hierarchical path component and optional query component identify the target resource within that origin server's namespace.,4.2.2,https URI Scheme,3,3,2,,,,,,B1,MUST
"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",When two HTTP URIs are determined to be equivalent after applying normalization (using any method),"Such equivalent normalized HTTP URIs can be assumed to identify the same resource,Any HTTP component MAY perform normalization","Sender,Recipient",MAY,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization. As a result, distinct resources SHOULD NOT be identified by HTTP URIs that are equivalent after normalization (using any method defined in Section 6.2 of [URI]).","For example, the following three URIs are equivalent:",,4.2.3,http(s) Normalization and Comparison,3,9,1,,,,,,B2,MAY
"As a result, distinct resources SHOULD NOT be identified by HTTP URIs that are equivalent after normalization (using any method defined in Section 6.2 of [URI]).",When HTTP URIs are found to be equivalent after normalization (using any method defined in Section 6.2 of [URI]),Distinct resources SHOULD NOT be identified by such equivalent HTTP URIs,Origin Server,SHOULD NOT,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization. As a result, distinct resources SHOULD NOT be identified by HTTP URIs that are equivalent after normalization (using any method defined in Section 6.2 of [URI]).","For example, the following three URIs are equivalent:",,4.2.3,http(s) Normalization and Comparison,3,9,2,,,,,,B2,SHOULD
"A sender MUST NOT generate the userinfo subcomponent (and its ""@"" delimiter) when an ""http"" or ""https"" URI reference is generated within a message as a target URI or field value.",When an 'http' or 'https' URI reference is generated within a message as a target URI or field value.,The sender MUST NOT generate the userinfo subcomponent (and its '@' delimiter).,Sender,MUST NOT,"A sender MUST NOT generate the userinfo subcomponent (and its ""@"" delimiter) when an ""http"" or ""https"" URI reference is generated within a message as a target URI or field value.","Some implementations make use of the userinfo component for internal configuration of authentication information, such as within command invocation options, configuration files, or bookmark lists, even though such usage might expose a user identifier or password.","Before making use of an ""http"" or ""https"" URI reference received from an untrusted source, a recipient SHOULD parse for userinfo and treat its presence as an error; it is likely being used to obscure the authority for the sake of phishing attacks.",4.2.4,Deprecation of userinfo in http(s) URIs,3,3,1,,,,,,B3,MUST
"Before making use of an ""http"" or ""https"" URI reference received from an untrusted source, a recipient SHOULD parse for userinfo and treat its presence as an error; it is likely being used to obscure the authority for the sake of phishing attacks.",An 'http' or 'https' URI reference is received from an untrusted source and is about to be used.,The recipient SHOULD parse the URI for the presence of userinfo and treat its presence as an error.,Recipient,SHOULD,"Before making use of an ""http"" or ""https"" URI reference received from an untrusted source, a recipient SHOULD parse for userinfo and treat its presence as an error; it is likely being used to obscure the authority for the sake of phishing attacks.","A sender MUST NOT generate the userinfo subcomponent (and its ""@"" delimiter) when an ""http"" or ""https"" URI reference is generated within a message as a target URI or field value.",,4.2.4,Deprecation of userinfo in http(s) URIs,3,4,1,,,,,,B3,SHOULD
"A recipient MAY combine multiple field lines within a field section that have the same field name into one field line, without changing the semantics of the message, by appending each subsequent field line value to the initial field line value in order, separated by a comma ("","") and optional whitespace (OWS, defined in Section 5.6.3).",When a field section contains multiple field lines with the same field name,"The recipient MAY combine those multiple field lines into a single field line by appending each subsequent field line value to the initial field line value in order, separated by a comma ("","") and optional whitespace (OWS, as defined in Section 5.6.3)",Recipient,MAY,"A recipient MAY combine multiple field lines within a field section that have the same field name into one field line, without changing the semantics of the message, by appending each subsequent field line value to the initial field line value in order, separated by a comma ("","") and optional whitespace (OWS, defined in Section 5.6.3). For consistency, use comma SP.",,The order in which field lines with the same name are received is therefore significant to the interpretation of the field value; a proxy MUST NOT change the order of these field line values when forwarding a message.,5.3,Field Order,2,1,1,,,,,,C1,MAY
"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).","A sender generates multiple field lines with the same name in a message (in headers or trailers),A sender appends a field line when a field line of the same name already exists in the message,Unless the field's definition allows multiple field line values to be recombined as a comma-separated list",The sender MUST NOT generate multiple field lines with the same name or append a field line when a field of the same name already exists in the message,Sender,MUST NOT,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",The order in which field lines with the same name are received is therefore significant to the interpretation of the field value; a proxy MUST NOT change the order of these field line values when forwarding a message.,"The order in which field lines with differing field names are received in a section is not significant. However, it is good practice to send header fields that contain additional control data first, such as Host on requests and Date on responses, so that implementations can decide when not to handle a message as early as possible.",5.3,Field Order,2,3,1,,,,,,C1,MUST
"A server MUST NOT apply a request to the target resource until it receives the entire request header section, since later header field lines might include conditionals, authentication credentials, or deliberately misleading duplicate header fields that could impact request processing.","A request for which the server has not yet received the entire request header section (i.e., initial header field lines that may be incomplete or misleading due to later additions)",The server MUST NOT apply the request to the target resource until it has received the entire request header section,Server,MUST NOT,"A server MUST NOT apply a request to the target resource until it receives the entire request header section, since later header field lines might include conditionals, authentication credentials, or deliberately misleading duplicate header fields that could impact request processing.","The order in which field lines with differing field names are received in a section is not significant. However, it is good practice to send header fields that contain additional control data first, such as Host on requests and Date on responses, so that implementations can decide when not to handle a message as early as possible.",,5.3,Field Order,2,5,1,,,,,,D2,MUST
"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",A specific version of HTTP allows whitespace to appear in a message.,The field parsing implementation MUST exclude such whitespace prior to evaluating the field value.,Recipient,MUST,"A field value does not include leading or trailing whitespace. When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",HTTP field values consist of a sequence of characters in a format defined by the field's grammar. Each field's grammar is usually defined using ABNF ([RFC5234]).,"Field values are usually constrained to the range of US-ASCII characters [USASCII]. Fields needing a greater range of characters can use an encoding, such as the one defined in [RFC8187]. Historically, HTTP allowed field content with text in the ISO-8859-1 charset [ISO-8859-1], supporting other charsets only through use of [RFC2047] encoding. Specifications for newly defined fields SHOULD limit their values to visible US-ASCII octets (VCHAR), SP, and HTAB. A recipient SHOULD treat other allowed octets in field content (i.e., obs-text) as opaque data.",5.5,Field Values,2,2,2,,,,,,C3,MUST
"A recipient SHOULD treat other allowed octets in field content (i.e., obs-text) as opaque data.",Field content that includes allowed octets defined as obs-text,The recipient SHOULD treat these octets as opaque data,Recipient,SHOULD,"Field values are usually constrained to the range of US-ASCII characters [USASCII]. Fields needing a greater range of characters can use an encoding, such as the one defined in [RFC8187]. Historically, HTTP allowed field content with text in the ISO-8859-1 charset [ISO-8859-1], supporting other charsets only through use of [RFC2047] encoding. Specifications for newly defined fields SHOULD limit their values to visible US-ASCII octets (VCHAR), SP, and HTAB. A recipient SHOULD treat other allowed octets in field content (i.e., obs-text) as opaque data.","A field value does not include leading or trailing whitespace. When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.","Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message. Field values containing other CTL characters are also invalid; however, recipients MAY retain such characters for the sake of robustness when they appear within a safe context (e.g., an application-specific quoted string that will not be processed by any downstream HTTP parser).",5.5,Field Values,2,3,5,,,,,,C3,SHOULD
"In any production that uses the list construct, a sender MUST NOT generate empty list elements.",Any production that uses the list construct.,A sender MUST NOT generate empty list elements.,Sender,MUST NOT,"In any production that uses the list construct, a sender MUST NOT generate empty list elements. In other words, a sender has to generate lists that satisfy the following syntax:","A construct ""#"" is defined, similar to ""*"", for defining comma-delimited lists of elements. The full form is ""<n>#<m>element"" indicating at least <n> and at most <m> elements, each separated by a single comma ("","") and optional whitespace (OWS, defined in Section 5.6.3).",and:,5.6.1,Lists (#rule ABNF Extension),3,3,1,,,,,,C2,MUST
"A recipient MUST parse and ignore a reasonable number of empty list elements: enough to handle common mistakes by senders that merge values, but not so much that they could be used as a denial-of-service mechanism.","When processing a list containing empty elements (i.e., list elements that are present but have no value), which may occur due to common mistakes by senders merging values.","The recipient MUST parse and ignore a reasonable number of empty list elements, ensuring they handle common mistakes while preventing potential denial-of-service mechanisms.",Recipient,MUST,"Empty elements do not contribute to the count of elements present. A recipient MUST parse and ignore a reasonable number of empty list elements: enough to handle common mistakes by senders that merge values, but not so much that they could be used as a denial-of-service mechanism. In other words, a recipient MUST accept lists that satisfy the following syntax:",Appendix A shows the collected ABNF for senders after the list constructs have been expanded.,"Note that because of the potential presence of empty list elements, the RFC 5234 ABNF cannot enforce the cardinality of list elements, and consequently all cases are mapped as if there was no cardinality specified.",5.6.1,Lists (#rule ABNF Extension),3,7,2,,,,,,C2,MUST
"In other words, a recipient MUST accept lists that satisfy the following syntax:",A list that satisfies the specified syntax (including proper handling of empty elements as described),The recipient MUST accept the list,Recipient,MUST,"Empty elements do not contribute to the count of elements present. A recipient MUST parse and ignore a reasonable number of empty list elements: enough to handle common mistakes by senders that merge values, but not so much that they could be used as a denial-of-service mechanism. In other words, a recipient MUST accept lists that satisfy the following syntax:",Appendix A shows the collected ABNF for senders after the list constructs have been expanded.,"Note that because of the potential presence of empty list elements, the RFC 5234 ABNF cannot enforce the cardinality of list elements, and consequently all cases are mapped as if there was no cardinality specified.",5.6.1,Lists (#rule ABNF Extension),3,7,3,,,,,,C2,MUST
A sender MUST NOT generate BWS in messages.,When a sender generates a message,The sender MUST NOT generate Bad Whitespace (BWS) in messages,Sender,MUST NOT,The BWS rule is used where the grammar allows optional whitespace only for historical reasons. A sender MUST NOT generate BWS in messages. A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,OWS and RWS have the same semantics as a single SP. Any content known to be defined as OWS or RWS MAY be replaced with a single SP before interpreting it or forwarding the message downstream.,BWS has no semantics. Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,5.6.3,Whitespace,3,5,2,,,,,,C3,MUST
A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,When a message is received that contains bad whitespace (BWS),The recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,Recipient,MUST,The BWS rule is used where the grammar allows optional whitespace only for historical reasons. A sender MUST NOT generate BWS in messages. A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,OWS and RWS have the same semantics as a single SP. Any content known to be defined as OWS or RWS MAY be replaced with a single SP before interpreting it or forwarding the message downstream.,BWS has no semantics. Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,5.6.3,Whitespace,3,5,3,,,,,,C3,MUST
Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,Content that is known to be defined as BWS is present in the message,The content known to be defined as BWS MAY be removed before interpreting the message or forwarding it downstream,Recipient,MAY,BWS has no semantics. Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,The BWS rule is used where the grammar allows optional whitespace only for historical reasons. A sender MUST NOT generate BWS in messages. A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,,5.6.3,Whitespace,3,6,2,,,,,,C3,MAY
Recipients that process the value of a quoted-string MUST handle a quoted-pair as if it were replaced by the octet following the backslash.,When a recipient processes the value of a quoted-string.,Handle a quoted-pair as if it were replaced by the octet following the backslash.,Recipient,MUST,"The backslash octet (""\"") can be used as a single-octet quoting mechanism within quoted-string and comment constructs. Recipients that process the value of a quoted-string MUST handle a quoted-pair as if it were replaced by the octet following the backslash.",A string of text is parsed as a single value if it is quoted using double-quote marks.,"A sender SHOULD NOT generate a quoted-pair in a quoted-string except where necessary to quote DQUOTE and backslash octets occurring within that string. A sender SHOULD NOT generate a quoted-pair in a comment except where necessary to quote parentheses [""("" and "")""] and backslash octets occurring within that comment.",5.6.4,Quoted Strings,3,2,2,,,,,,C4,MUST
"A sender SHOULD NOT generate a quoted-pair in a comment except where necessary to quote parentheses [""("" and "")""] and backslash octets occurring within that comment.","When generating a comment, except in cases where quoting is necessary for parentheses (""("" and "")"") or backslash octets within that comment",The sender SHOULD NOT generate a quoted-pair in a comment,Sender,SHOULD NOT,"A sender SHOULD NOT generate a quoted-pair in a quoted-string except where necessary to quote DQUOTE and backslash octets occurring within that string. A sender SHOULD NOT generate a quoted-pair in a comment except where necessary to quote parentheses [""("" and "")""] and backslash octets occurring within that comment.","The backslash octet (""\"") can be used as a single-octet quoting mechanism within quoted-string and comment constructs. Recipients that process the value of a quoted-string MUST handle a quoted-pair as if it were replaced by the octet following the backslash.",,5.6.4,Quoted Strings,3,3,2,,,,,,C4,SHOULD
A recipient that parses a timestamp value in an HTTP field MUST accept all three HTTP-date formats.,The recipient parses a timestamp value in an HTTP field,The recipient MUST accept all three HTTP-date formats,Recipient,MUST,"A recipient that parses a timestamp value in an HTTP field MUST accept all three HTTP-date formats. When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.",Examples of the two obsolete formats are,"An HTTP-date value represents time as an instance of Coordinated Universal Time (UTC). The first two formats indicate UTC by the three-letter abbreviation for Greenwich Mean Time, ""GMT"", a predecessor of the UTC name; values in the asctime format are assumed to be in UTC.",5.6.7,Date/Time Formats,3,4,1,,,,,,C5,MUST
"When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.",A sender generates a field that contains one or more timestamps defined as HTTP-date.,The sender MUST generate those timestamps in the IMF-fixdate format.,Sender,MUST,"A recipient that parses a timestamp value in an HTTP field MUST accept all three HTTP-date formats. When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.",Examples of the two obsolete formats are,"An HTTP-date value represents time as an instance of Coordinated Universal Time (UTC). The first two formats indicate UTC by the three-letter abbreviation for Greenwich Mean Time, ""GMT"", a predecessor of the UTC name; values in the asctime format are assumed to be in UTC.",5.6.7,Date/Time Formats,3,4,2,,,,,,C5,MUST
"Recipients of a timestamp value in rfc850-date format, which uses a two-digit year, MUST interpret a timestamp that appears to be more than 50 years in the future as representing the most recent year in the past that had the same last two digits.",A timestamp value in rfc850-date format with a two-digit year that appears to be more than 50 years in the future.,Interpret the timestamp as representing the most recent year in the past that has the same last two digits.,Recipient,MUST,"Recipients of a timestamp value in rfc850-date format, which uses a two-digit year, MUST interpret a timestamp that appears to be more than 50 years in the future as representing the most recent year in the past that had the same last two digits.","A sender MUST NOT generate additional whitespace in an HTTP-date beyond that specifically included as SP in the grammar. The semantics of day-name, day, month, year, and time-of-day are the same as those defined for the Internet Message Format constructs with the corresponding name ([RFC5322], Section 3.3).","Recipients of timestamp values are encouraged to be robust in parsing timestamps unless otherwise restricted by the field definition. For example, messages are occasionally forwarded over HTTP from a non-HTTP source that might generate any of the date and time specifications defined by the Internet Message Format.",5.6.7,Date/Time Formats,3,11,1,,,,,,C5,MUST
A server SHOULD send a response version equal to the highest version to which the server is conformant that has a major version less than or equal to the one received in the request.,"When a request is received containing a version number, specifically with a major version component.",The server SHOULD send a response version equal to the highest version to which it is conformant that has a major version less than or equal to the version received in the request.,Server,SHOULD,"A server SHOULD send a response version equal to the highest version to which the server is conformant that has a major version less than or equal to the one received in the request. A server MUST NOT send a version to which it is not conformant. A server can send a 505 (HTTP Version Not Supported) response if it wishes, for any reason, to refuse service of the client's major protocol version.","A client MAY send a lower request version if it is known that the server incorrectly implements the HTTP specification, but only after the client has attempted at least one normal request and determined from the response status code or header fields (e.g., Server) that the server improperly handles higher request versions.","A recipient that receives a message with a major version number that it implements and a minor version number higher than what it implements SHOULD process the message as if it were in the highest minor version within that major version to which the recipient is conformant. A recipient can assume that a message with a higher minor version, when sent to a recipient that has not yet indicated support for that higher version, is sufficiently backwards-compatible to be safely processed by any implementation of the same major version.",6.2,Control Data,2,7,1,,,,,,A4,SHOULD
A server MUST NOT send a version to which it is not conformant.,When the server is sending a response that includes a version designation,The server MUST NOT send a version to which it is not conformant,Server,MUST NOT,"A server SHOULD send a response version equal to the highest version to which the server is conformant that has a major version less than or equal to the one received in the request. A server MUST NOT send a version to which it is not conformant. A server can send a 505 (HTTP Version Not Supported) response if it wishes, for any reason, to refuse service of the client's major protocol version.","A client MAY send a lower request version if it is known that the server incorrectly implements the HTTP specification, but only after the client has attempted at least one normal request and determined from the response status code or header fields (e.g., Server) that the server improperly handles higher request versions.","A recipient that receives a message with a major version number that it implements and a minor version number higher than what it implements SHOULD process the message as if it were in the highest minor version within that major version to which the recipient is conformant. A recipient can assume that a message with a higher minor version, when sent to a recipient that has not yet indicated support for that higher version, is sufficiently backwards-compatible to be safely processed by any implementation of the same major version.",6.2,Control Data,2,7,2,,,,,,A4,MUST
A recipient that receives a message with a major version number that it implements and a minor version number higher than what it implements SHOULD process the message as if it were in the highest minor version within that major version to which the recipient is conformant.,A recipient receives a message with a major version number that it implements and a minor version number higher than what it implements,Process the message as if it were in the highest minor version within that major version to which the recipient is conformant,Recipient,SHOULD,"A recipient that receives a message with a major version number that it implements and a minor version number higher than what it implements SHOULD process the message as if it were in the highest minor version within that major version to which the recipient is conformant. A recipient can assume that a message with a higher minor version, when sent to a recipient that has not yet indicated support for that higher version, is sufficiently backwards-compatible to be safely processed by any implementation of the same major version.","A server SHOULD send a response version equal to the highest version to which the server is conformant that has a major version less than or equal to the one received in the request. A server MUST NOT send a version to which it is not conformant. A server can send a 505 (HTTP Version Not Supported) response if it wishes, for any reason, to refuse service of the client's major protocol version.",,6.2,Control Data,2,8,1,,,,,,A4,SHOULD
"Unless the connection is from a trusted gateway, an origin server MUST reject a request if any scheme-specific requirements for the target URI are not met.","The connection is not from a trusted gateway.,Any scheme-specific requirements for the target URI are not met (for example, an 'https' request received over an insecure connection).",The origin server MUST reject the request.,Origin Server,MUST,"Unless the connection is from a trusted gateway, an origin server MUST reject a request if any scheme-specific requirements for the target URI are not met. In particular, a request for an ""https"" resource MUST be rejected unless it has been received over a connection that has been secured via a certificate valid for that target URI's origin, as defined by Section 4.2.2.","For example, a request might have been misdirected, deliberately or accidentally, such that the information within a received Host header field differs from the connection's host or port. If the connection is from a trusted gateway, such inconsistency might be expected; otherwise, it might indicate an attempt to bypass security filters, trick the server into delivering non-public content, or poison a cache. See Section 17 for security considerations regarding message routing.",The 421 (Misdirected Request) status code in a response indicates that the origin server has rejected the request because it appears to have been misdirected (Section 15.5.20).,7.4,Rejecting Misdirected Requests,2,3,1,,,,,,B4,MUST
"In particular, a request for an ""https"" resource MUST be rejected unless it has been received over a connection that has been secured via a certificate valid for that target URI's origin, as defined by Section 4.2.2.",The request is for an 'https' resource and has not been received over a connection secured with a certificate valid for the target URI's origin as defined by Section 4.2.2.,The request MUST be rejected.,Origin Server,MUST,"Unless the connection is from a trusted gateway, an origin server MUST reject a request if any scheme-specific requirements for the target URI are not met. In particular, a request for an ""https"" resource MUST be rejected unless it has been received over a connection that has been secured via a certificate valid for that target URI's origin, as defined by Section 4.2.2.","For example, a request might have been misdirected, deliberately or accidentally, such that the information within a received Host header field differs from the connection's host or port. If the connection is from a trusted gateway, such inconsistency might be expected; otherwise, it might indicate an attempt to bypass security filters, trick the server into delivering non-public content, or poison a cache. See Section 17 for security considerations regarding message routing.",The 421 (Misdirected Request) status code in a response indicates that the origin server has rejected the request because it appears to have been misdirected (Section 15.5.20).,7.4,Rejecting Misdirected Requests,2,3,2,,,,,,B4,MUST
A sender MUST NOT send a connection option corresponding to a field that is intended for all recipients of the content.,A situation where the sender is about to send a connection option that corresponds to a field intended for all recipients of the content.,The sender MUST NOT send that connection option.,Sender,MUST NOT,"A sender MUST NOT send a connection option corresponding to a field that is intended for all recipients of the content. For example, Cache-Control is never appropriate as a connection option (Section 5.2 of [CACHING]).",* Upgrade (Section 7.8),"Connection options do not always correspond to a field present in the message, since a connection-specific field might not be needed if there are no parameters associated with a connection option. In contrast, a connection-specific field received without a corresponding connection option usually indicates that the field has been improperly forwarded by an intermediary and ought to be ignored by the recipient.",7.6.1,Connection,3,12,1,,,,,,C6,MUST
"However, if the real host is considered to be sensitive information, a sender MAY replace it with a pseudonym.",the real host is considered to be sensitive information,a sender MAY replace the real host with a pseudonym,Sender,MAY,"The received-by portion is normally the host and optional port number of a recipient server or client that subsequently forwarded the message. However, if the real host is considered to be sensitive information, a sender MAY replace it with a pseudonym. If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.","For each intermediary, the received-protocol indicates the protocol and protocol version used by the upstream sender of the message. Hence, the Via field value records the advertised protocol capabilities of the request/response chain such that they remain visible to downstream recipients; this can be useful for determining what backwards-incompatible features might be safe to use in response, or within a later request, as described in Section 2.5. For brevity, the protocol-name is omitted when the received protocol is HTTP.","A sender MAY generate comments to identify the software of each recipient, analogous to the User-Agent and Server header fields. However, comments in Via are optional, and a recipient MAY remove them prior to forwarding the message.",7.6.3,Via,3,5,2,,,,,,G1,MAY
"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",A port is not provided in the received message.,The recipient MAY interpret the omission of a port as meaning the message was received on the default port (if any) for the received-protocol.,Recipient,MAY,"The received-by portion is normally the host and optional port number of a recipient server or client that subsequently forwarded the message. However, if the real host is considered to be sensitive information, a sender MAY replace it with a pseudonym. If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.","For each intermediary, the received-protocol indicates the protocol and protocol version used by the upstream sender of the message. Hence, the Via field value records the advertised protocol capabilities of the request/response chain such that they remain visible to downstream recipients; this can be useful for determining what backwards-incompatible features might be safe to use in response, or within a later request, as described in Section 2.5. For brevity, the protocol-name is omitted when the received protocol is HTTP.","A sender MAY generate comments to identify the software of each recipient, analogous to the User-Agent and Server header fields. However, comments in Via are optional, and a recipient MAY remove them prior to forwarding the message.",7.6.3,Via,3,5,3,,,,,,B1,MAY
A sender SHOULD NOT combine multiple list members unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms.,When a sender attempts to combine multiple list members and either (a) not all members are under the same organizational control or (b) the hosts have not already been replaced by pseudonyms,The sender SHOULD NOT combine the multiple list members under those conditions.,Sender,SHOULD NOT,A sender SHOULD NOT combine multiple list members unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms. A sender MUST NOT combine members that have different received-protocol values.,"Via: 1.0 ricky, 1.1 mertz, 1.0 lucy",,7.6.3,Via,3,14,1,,,,,,G1,SHOULD
A sender MUST NOT combine members that have different received-protocol values.,When attempting to combine list members that have different received-protocol values,The sender MUST NOT combine these members,Sender,MUST NOT,A sender SHOULD NOT combine multiple list members unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms. A sender MUST NOT combine members that have different received-protocol values.,"Via: 1.0 ricky, 1.1 mertz, 1.0 lucy",,7.6.3,Via,3,14,2,,,,,,G1,MUST
"Although protocol names are registered with a preferred case, recipients SHOULD use case-insensitive comparison when matching each protocol-name to supported protocols.",When matching a received protocol-name to supported protocols,Recipients SHOULD use case-insensitive comparison when matching each protocol-name to supported protocols,Recipient,SHOULD,"Although protocol names are registered with a preferred case, recipients SHOULD use case-insensitive comparison when matching each protocol-name to supported protocols.","A client MAY send a list of protocol names in the Upgrade header field of a request to invite the server to switch to one or more of the named protocols, in order of descending preference, before sending the final response. A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection. Upgrade cannot be used to insist on a protocol change.","A server that sends a 101 (Switching Protocols) response MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched; if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order. A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field. A server MAY choose to ignore the order of preference indicated by the client and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.",7.8,Upgrade,2,3,1,,,,,,D5,SHOULD
"A server MAY choose to ignore the order of preference indicated by the client and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.",When processing a client's request that includes an Upgrade header field indicating protocol preference.,"The server MAY ignore the client's indicated order of preference and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.",Server,MAY,"A server that sends a 101 (Switching Protocols) response MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched; if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order. A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field. A server MAY choose to ignore the order of preference indicated by the client and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.","Although protocol names are registered with a preferred case, recipients SHOULD use case-insensitive comparison when matching each protocol-name to supported protocols.","A server that sends a 426 (Upgrade Required) response MUST send an Upgrade header field to indicate the acceptable protocols, in order of descending preference.",7.8,Upgrade,2,4,3,,,,,,D5,MAY
The type/subtype MAY be followed by semicolon-delimited parameters (Section 5.6.6) in the form of name/value pairs.,When a media type is specified using a type/subtype format,The type/subtype MAY be followed by semicolon-delimited parameters (as defined in Section 5.6.6) in the form of name/value pairs,Sender,MAY,"The type/subtype MAY be followed by semicolon-delimited parameters (Section 5.6.6) in the form of name/value pairs. The presence or absence of a parameter might be significant to the processing of a media type, depending on its definition within the media type registry. Parameter values might or might not be case-sensitive, depending on the semantics of the parameter name.",The type and subtype tokens are case-insensitive.,"For example, the following media types are equivalent in describing HTML text data encoded in the UTF-8 character encoding scheme, but the first is preferred for consistency (the ""charset"" parameter value is defined as being case-insensitive in [RFC2046], Section 4.1.2):",8.3.1,Media Type,3,3,1,,,,,,E3,MAY
Multiple languages MAY be listed for content that is intended for multiple audiences.,Content is intended for multiple audiences.,Multiple languages MAY be listed.,Sender,MAY,"Multiple languages MAY be listed for content that is intended for multiple audiences. For example, a rendition of the ""Treaty of Waitangi"", presented simultaneously in the original Maori and English versions, would call for","If no Content-Language is specified, the default is that the content is intended for all language audiences. This might mean that the sender does not consider it to be specific to any natural language, or that the sender does not know for which language it is intended.","Content-Language: mi, en",8.5,Content-Language,2,5,1,,,,,,E3,MAY
"Since there is no predefined limit to the length of content, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer conversion (Section 17.5).",The absence of a predefined limit to the length of content leads to potentially large decimal numeral values in the Content-Length header.,The recipient MUST anticipate these large decimal numeral values and prevent parsing errors caused by integer conversion overflows or precision loss.,Recipient,MUST,"Any Content-Length field value greater than or equal to zero is valid. Since there is no predefined limit to the length of content, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer conversion (Section 17.5).","Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section. This will allow downstream recipients to measure transfer progress, know when a received message is complete, and potentially reuse the connection for additional requests.","Because Content-Length is used for message delimitation in HTTP/1.1, its field value can impact how the message is parsed by downstream recipients even when the immediate connection is not using HTTP/1.1. If the message is forwarded by a downstream intermediary, a Content-Length field value that is inconsistent with the received message framing might cause a security failure due to request smuggling or response splitting.",8.6,Content-Length,2,9,2,,,,,,A5,MUST
"An origin server MAY use that context to guide in processing the request or to save it for other uses, such as within source links or versioning metadata.","An origin server receives a request message that contains a Content-Location field, providing context about the original source of the representation.","The origin server MAY use that context to guide in processing the request or to save it for other uses, such as within source links or versioning metadata.",Origin Server,MAY,"An origin server that receives a Content-Location field in a request message MUST treat the information as transitory request context rather than as metadata to be saved verbatim as part of the representation. An origin server MAY use that context to guide in processing the request or to save it for other uses, such as within source links or versioning metadata. However, an origin server MUST NOT use such context information to alter the request semantics.","A user agent that sends Content-Location in a request message is stating that its value refers to where the user agent originally obtained the content of the enclosed representation (prior to any modifications made by that user agent). In other words, the user agent is providing a back link to the source of the original representation.","For example, if a client makes a PUT request on a negotiated resource and the origin server accepts that PUT (without redirection), then the new state of that resource is expected to be consistent with the one representation supplied in that PUT; the Content-Location cannot be used as a form of reverse content selection identifier to update only one of the negotiated representations. If the user agent had wanted the latter semantics, it would have applied the PUT directly to the Content-Location URI.",8.7,Content-Location,2,10,2,,,,,,E4,MAY
"However, an origin server MUST NOT use such context information to alter the request semantics.","When an origin server receives context information provided via a Content-Location field within a request message (i.e., context treated as transitory request context).",The origin server MUST NOT use the received context information to alter the request semantics.,Origin Server,MUST,"An origin server that receives a Content-Location field in a request message MUST treat the information as transitory request context rather than as metadata to be saved verbatim as part of the representation. An origin server MAY use that context to guide in processing the request or to save it for other uses, such as within source links or versioning metadata. However, an origin server MUST NOT use such context information to alter the request semantics.","A user agent that sends Content-Location in a request message is stating that its value refers to where the user agent originally obtained the content of the enclosed representation (prior to any modifications made by that user agent). In other words, the user agent is providing a back link to the source of the original representation.","For example, if a client makes a PUT request on a negotiated resource and the origin server accepts that PUT (without redirection), then the new state of that resource is expected to be consistent with the one representation supplied in that PUT; the Content-Location cannot be used as a form of reverse content selection identifier to update only one of the negotiated representations. If the user agent had wanted the latter semantics, it would have applied the PUT directly to the Content-Location URI.",8.7,Content-Location,2,10,3,,,,,,E4,MUST
An origin server SHOULD change a weak entity tag whenever it considers prior representations to be unacceptable as a substitute for the current representation.,When the origin server considers prior representations to be unacceptable as a substitute for the current representation.,The origin server SHOULD change the weak entity tag.,Origin Server,SHOULD,"An origin server SHOULD change a weak entity tag whenever it considers prior representations to be unacceptable as a substitute for the current representation. In other words, a weak entity tag ought to change whenever the origin server wants caches to invalidate old responses.","In contrast, a ""weak validator"" is representation metadata that might not change for every change to the representation data. This weakness might be due to limitations in how the value is calculated (e.g., clock resolution), an inability to ensure uniqueness for all possible representations of the resource, or a desire of the resource owner to group representations by some self-determined set of equivalency rather than unique sequences of data.","For example, the representation of a weather report that changes in content every second, based on dynamic measurements, might be grouped into sets of equivalent representations (from the origin server's perspective) with the same weak validator in order to allow cached representations to be valid for a reasonable period of time (perhaps adjusted dynamically based on server load or weather quality). Likewise, a representation's modification time, if defined with only one-second resolution, might be a weak validator if it is possible for the representation to be modified twice during a single second and retrieved between those modifications.",8.8.1,Weak versus Strong,3,7,1,,,,,,F2,SHOULD
"If the last modification time is derived from implementation-specific metadata that evaluates to some time in the future, according to the origin server's clock, then the origin server MUST replace that value with the message origination date.",The last modification time is derived from implementation-specific metadata that evaluates to some time in the future according to the origin server's clock.,The origin server MUST replace that value with the message origination date.,Origin Server,MUST,"An origin server with a clock (as defined in Section 5.6.7) MUST NOT generate a Last-Modified date that is later than the server's time of message origination (Date, Section 6.6.1). If the last modification time is derived from implementation-specific metadata that evaluates to some time in the future, according to the origin server's clock, then the origin server MUST replace that value with the message origination date. This prevents a future modification date from having an adverse impact on cache validation.","An origin server SHOULD obtain the Last-Modified value of the representation as close as possible to the time that it generates the Date field value for its response. This allows a recipient to make an accurate assessment of the representation's modification time, especially if the representation changes near the time that the response is generated.",An origin server without a clock MUST NOT generate a Last-Modified date for a response unless that date value was assigned to the resource by some other system (presumably one with a clock).,8.8.2,Last-Modified,3,7,2,,,,,,F2,MUST
"If an origin server provides an entity tag for a representation and the generation of that entity tag does not satisfy all of the characteristics of a strong validator (Section 8.8.1), then the origin server MUST mark the entity tag as weak by prefixing its opaque value with ""W/"" (case-sensitive).",An origin server provides an entity tag for a representation and the generation of that entity tag does not satisfy all the characteristics of a strong validator (Section 8.8.1),"The origin server MUST mark the entity tag as weak by prefixing its opaque value with ""W/"" (case-sensitive)",Origin Server,MUST,"An entity tag can be either a weak or strong validator, with strong being the default. If an origin server provides an entity tag for a representation and the generation of that entity tag does not satisfy all of the characteristics of a strong validator (Section 8.8.1), then the origin server MUST mark the entity tag as weak by prefixing its opaque value with ""W/"" (case-sensitive).","ETag: ""xyzzy"" ETag: W/""xyzzy"" ETag: """"","A sender MAY send the ETag field in a trailer section (see Section 6.5). However, since trailers are often ignored, it is preferable to send ETag as a header field unless the entity tag is generated while sending the content.",8.8.3,ETag,3,5,2,,,,,,F2,MUST
"If the purpose of such a resource is to perform an unsafe action, then the resource owner MUST disable or disallow that action when it is accessed using a safe request method.","The resource's purpose is to perform an unsafe action.,The resource is accessed using a safe request method.",The resource owner MUST disable or disallow the unsafe action when the resource is accessed using a safe request method.,Origin Server,MUST,"When a resource is constructed such that parameters within the target URI have the effect of selecting an action, it is the resource owner's responsibility to ensure that the action is consistent with the request method semantics. For example, it is common for Web-based content editing software to use actions within query parameters, such as ""page?do=delete"". If the purpose of such a resource is to perform an unsafe action, then the resource owner MUST disable or disallow that action when it is accessed using a safe request method. Failure to do so will result in unfortunate side effects when automated processes perform a GET on every URI reference for the sake of link maintenance, pre-fetching, building a search index, etc.","A user agent SHOULD distinguish between safe and unsafe methods when presenting potential actions to a user, such that the user can be made aware of an unsafe action before it is requested.",,9.2.1,Safe Methods,3,6,3,,,,,,E1,MUST
"An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",,The origin server SHOULD NOT rely on private agreements to receive content.,Origin Server,SHOULD,"Although request message framing is independent of the method used, content received in a GET request has no generally defined semantics, cannot alter the meaning or target of the request, and might lead some implementations to reject the request and close the connection because of its potential as a request smuggling attack (Section 11.2 of [HTTP/1.1]). A client SHOULD NOT generate content in a GET request unless it is made directly to an origin server that has previously indicated, in or out of band, that such a request has a purpose and will be adequately supported. An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.","A client can alter the semantics of GET to be a ""range request"", requesting transfer of only some part(s) of the selected representation, by sending a Range header field in the request (Section 14.2).",The response to a GET request is cacheable; a cache MAY use it to satisfy subsequent GET and HEAD requests unless otherwise indicated by the Cache-Control header field (Section 5.2 of [CACHING]).,9.3.1,GET,3,6,3,,,,,,F1,SHOULD
"However, a server MAY omit header fields for which a value is determined only while generating the content.",When a header field’s value is determined only while generating the content,The server MAY omit such header fields,Server,MAY,"The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request method had been GET. However, a server MAY omit header fields for which a value is determined only while generating the content. For example, some servers buffer a dynamic response to GET until a minimum amount of data is generated so that they can more efficiently delimit small responses or make late decisions with regard to content selection. Such a response to GET might contain Content-Length and Vary fields, for example, that are not generated within a HEAD response. These minor inconsistencies are considered preferable to generating and discarding the content for a HEAD request, since HEAD is usually requested for the sake of efficiency.","The HEAD method is identical to GET except that the server MUST NOT send content in the response. HEAD is used to obtain metadata about the selected representation without transferring its representation data, often for the sake of testing hypertext links or finding recent modifications.","Although request message framing is independent of the method used, content received in a HEAD request has no generally defined semantics, cannot alter the meaning or target of the request, and might lead some implementations to reject the request and close the connection because of its potential as a request smuggling attack (Section 11.2 of [HTTP/1.1]). A client SHOULD NOT generate content in a HEAD request unless it is made directly to an origin server that has previously indicated, in or out of band, that such a request has a purpose and will be adequately supported. An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",9.3.2,HEAD,3,2,2,,,,,,E1,MAY
"An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.","When receiving content as part of HTTP communications where the participants may be unaware of intermediaries along the request chain, potentially leading to reliance on private agreements.",An origin server SHOULD NOT rely on private agreements to receive content.,Origin Server,SHOULD,"Although request message framing is independent of the method used, content received in a HEAD request has no generally defined semantics, cannot alter the meaning or target of the request, and might lead some implementations to reject the request and close the connection because of its potential as a request smuggling attack (Section 11.2 of [HTTP/1.1]). A client SHOULD NOT generate content in a HEAD request unless it is made directly to an origin server that has previously indicated, in or out of band, that such a request has a purpose and will be adequately supported. An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.","The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request method had been GET. However, a server MAY omit header fields for which a value is determined only while generating the content. For example, some servers buffer a dynamic response to GET until a minimum amount of data is generated so that they can more efficiently delimit small responses or make late decisions with regard to content selection. Such a response to GET might contain Content-Length and Vary fields, for example, that are not generated within a HEAD response. These minor inconsistencies are considered preferable to generating and discarding the content for a HEAD request, since HEAD is usually requested for the sake of efficiency.",The response to a HEAD request is cacheable; a cache MAY use it to satisfy subsequent HEAD requests unless otherwise indicated by the Cache-Control header field (Section 5.2 of [CACHING]). A HEAD response might also affect previously cached responses to GET; see Section 4.3.5 of [CACHING].,9.3.2,HEAD,3,3,3,,,,,,F1,SHOULD
"An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",,The origin server SHOULD NOT rely on private agreements to receive content.,Origin Server,SHOULD NOT,"Although request message framing is independent of the method used, content received in a DELETE request has no generally defined semantics, cannot alter the meaning or target of the request, and might lead some implementations to reject the request and close the connection because of its potential as a request smuggling attack (Section 11.2 of [HTTP/1.1]). A client SHOULD NOT generate content in a DELETE request unless it is made directly to an origin server that has previously indicated, in or out of band, that such a request has a purpose and will be adequately supported. An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",* a 200 (OK) status code if the action has been enacted and the response message includes a representation describing the status.,"Responses to the DELETE method are not cacheable. If a successful DELETE request passes through a cache that has one or more stored responses for the target URI, those stored responses will be invalidated (see Section 4.4 of [CACHING]).",9.3.5,DELETE,3,8,3,,,,,,F1,SHOULD
The final recipient of the request SHOULD exclude any request fields that are likely to contain sensitive data when that recipient generates the response content.,When the final recipient of the request generates the response content.,Exclude any request fields that are likely to contain sensitive data from the generated response content.,Recipient,SHOULD,"A client MUST NOT generate fields in a TRACE request containing sensitive data that might be disclosed by the response. For example, it would be foolish for a user agent to send stored user credentials (Section 11) or cookies [COOKIE] in a TRACE request. The final recipient of the request SHOULD exclude any request fields that are likely to contain sensitive data when that recipient generates the response content.","The TRACE method requests a remote, application-level loop-back of the request message. The final recipient of the request SHOULD reflect the message received, excluding some fields described below, back to the client as the content of a 200 (OK) response. The ""message/http"" format (Section 10.1 of [HTTP/1.1]) is one way to do so. The final recipient is either the origin server or the first server to receive a Max-Forwards value of zero (0) in the request (Section 7.6.2).","TRACE allows the client to see what is being received at the other end of the request chain and use that data for testing or diagnostic information. The value of the Via header field (Section 7.6.3) is of particular interest, since it acts as a trace of the request chain. Use of the Max-Forwards header field allows the client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an infinite loop.",9.3.8,TRACE,3,2,3,,,,,,G2,SHOULD
"* A server that responds with a final status code before reading the entire request content SHOULD indicate whether it intends to close the connection (e.g., see Section 9.6 of [HTTP/1.1]) or continue reading the request content.",A server responds with a final status code before reading the entire request content.,"The server SHOULD indicate whether it intends to close the connection or continue reading the request content (e.g., see Section 9.6 of HTTP/1.1).",Server,SHOULD,"* A server that responds with a final status code before reading the entire request content SHOULD indicate whether it intends to close the connection (e.g., see Section 9.6 of [HTTP/1.1]) or continue reading the request content.","* A server that sends a 100 (Continue) response MUST ultimately send a final status code, once it receives and processes the request content, unless the connection is closed prematurely.","Upon receiving an HTTP/1.1 (or later) request that has a method, target URI, and complete header section that contains a 100-continue expectation and an indication that request content will follow, an origin server MUST send either:",10.1.1,Expect,3,18,1,,,,,,D2,SHOULD
A sender SHOULD limit generated product identifiers to what is necessary to identify the product; a sender MUST NOT generate advertising or other nonessential information within the product identifier.,When generating product identifiers for the User-Agent field,"Limit the product identifiers to only what is necessary to identify the product,Do not generate advertising or other nonessential information within the product identifier",Sender,"MUST NOT, SHOULD","A sender SHOULD limit generated product identifiers to what is necessary to identify the product; a sender MUST NOT generate advertising or other nonessential information within the product identifier. A sender SHOULD NOT generate information in product-version that is not a version identifier (i.e., successive versions of the same product name ought to differ only in the product-version portion of the product identifier).","The User-Agent field value consists of one or more product identifiers, each followed by zero or more comments (Section 5.6.5), which together identify the user agent software and its significant subproducts. By convention, the product identifiers are listed in decreasing order of their significance for identifying the user agent software. Each product identifier consists of a name and optional version.",Example:,10.1.5,User-Agent,3,3,1,,,,,,E2,MUST
"A sender SHOULD NOT generate information in product-version that is not a version identifier (i.e., successive versions of the same product name ought to differ only in the product-version portion of the product identifier).",When generating the product-version portion of a product identifier,"The sender SHOULD NOT generate any information in product-version that is not a version identifier, ensuring that successive versions of the same product name differ only in the product-version portion.",Sender,SHOULD NOT,"A sender SHOULD limit generated product identifiers to what is necessary to identify the product; a sender MUST NOT generate advertising or other nonessential information within the product identifier. A sender SHOULD NOT generate information in product-version that is not a version identifier (i.e., successive versions of the same product name ought to differ only in the product-version portion of the product identifier).","The User-Agent field value consists of one or more product identifiers, each followed by zero or more comments (Section 5.6.5), which together identify the user agent software and its significant subproducts. By convention, the product identifiers are listed in decreasing order of their significance for identifying the user agent software. Each product identifier consists of a name and optional version.",Example:,10.1.5,User-Agent,3,3,2,,,,,,E2,SHOULD
"Authentication parameters are name/value pairs, where the name token is matched case-insensitively and each parameter name MUST only occur once per challenge.",During the processing of an authentication challenge that includes authentication parameters (name/value pairs),"Ensure that each parameter name appears only once per challenge, with the name token being matched case-insensitively","Sender,Recipient",MUST,"Authentication parameters are name/value pairs, where the name token is matched case-insensitively and each parameter name MUST only occur once per challenge.","The token68 syntax allows the 66 unreserved URI characters ([URI]), plus a few others, so that it can hold a base64, base64url (URL and filename safe alphabet), base32, or base16 (hex) encoding, with or without padding, but excluding whitespace ([RFC4648]).","Parameter values can be expressed either as ""token"" or as ""quoted-string"" (Section 5.6). Authentication scheme definitions need to accept both notations, both for senders and recipients, to allow recipients to use generic parsing components regardless of the authentication scheme.",11.2,Authentication Parameters,2,3,1,,,,,,E5,MUST
"For historical reasons, a sender MUST only generate the quoted-string syntax.",,The sender MUST only generate the quoted-string syntax.,Sender,MUST,"For historical reasons, a sender MUST only generate the quoted-string syntax. Recipients might have to support both token and quoted-string syntax for maximum interoperability with existing clients that have been accepting both notations for a long time.","The extent of a protection space, and therefore the requests to which credentials might be automatically applied, is not necessarily known to clients without additional information. An authentication scheme might define parameters that describe the extent of a protection space. Unless specifically allowed by the authentication scheme, a single protection space cannot extend outside the scope of its server.",,11.5,Establishing a Protection Space (Realm),2,5,1,,,,,,E5,MUST
"In order to improve the server's guess, a user agent MAY send request header fields that describe its preferences.","When the user agent seeks to improve the server's guess for selecting the preferred representation (i.e., during proactive negotiation).",The user agent MAY send request header fields that describe its preferences.,"Client,Sender",MAY,"Proactive negotiation is advantageous when the algorithm for selecting from among the available representations is difficult to describe to a user agent, or when the server desires to send its ""best guess"" to the user agent along with the first response (when that ""best guess"" is good enough for the user, this avoids the round-trip delay of a subsequent request). In order to improve the server's guess, a user agent MAY send request header fields that describe its preferences.","When content negotiation preferences are sent by the user agent in a request to encourage an algorithm located at the server to select the preferred representation, it is called ""proactive negotiation"" (a.k.a., ""server-driven negotiation""). Selection is based on the available representations for a response (the dimensions over which it might vary, such as language, content coding, etc.) compared to various information supplied in the request, including both the explicit negotiation header fields below and implicit characteristics, such as the client's network address or parts of the User-Agent field.",Proactive negotiation has serious disadvantages:,12.1,Proactive Negotiation,2,2,2,,,,,,E3,MAY
A sender of qvalue MUST NOT generate more than three digits after the decimal point.,When a sender is generating a qvalue,The sender MUST NOT generate more than three digits after the decimal point,Sender,MUST NOT,A sender of qvalue MUST NOT generate more than three digits after the decimal point. User configuration of these values ought to be limited in the same fashion.,"The weight is normalized to a real number in the range 0 through 1, where 0.001 is the least preferred and 1 is the most preferred; a value of 0 means ""not acceptable"". If no ""q"" parameter is present, the default weight is 1.",,12.4.2,Quality Values,3,3,1,,,,,,E3,MUST
"Senders using weights SHOULD send ""q"" last (after all media-range parameters).","When a sender is using weights in a media-range (i.e., when weights are being applied to media-range parameters)","The sender SHOULD send the 'q' parameter last, after all media-range parameters",Sender,SHOULD,"Previous specifications allowed additional extension parameters to appear after the weight parameter. The accept extension grammar (accept-params, accept-ext) has been removed because it had a complicated definition, was not being used in practice, and is more easily deployed through new header fields. Senders using weights SHOULD send ""q"" last (after all media-range parameters). Recipients SHOULD process any parameter named ""q"" as weight, regardless of parameter ordering.","Each media-range might be followed by optional applicable media type parameters (e.g., charset), followed by an optional ""q"" parameter for indicating a relative weight (Section 12.4.2).",The example,12.5.1,Accept,3,5,3,,,,,,E3,SHOULD
"Recipients SHOULD process any parameter named ""q"" as weight, regardless of parameter ordering.",Any occurrence of a parameter named 'q',"Recipients SHOULD process the parameter 'q' as weight, regardless of parameter ordering",Recipient,SHOULD,"Previous specifications allowed additional extension parameters to appear after the weight parameter. The accept extension grammar (accept-params, accept-ext) has been removed because it had a complicated definition, was not being used in practice, and is more easily deployed through new header fields. Senders using weights SHOULD send ""q"" last (after all media-range parameters). Recipients SHOULD process any parameter named ""q"" as weight, regardless of parameter ordering.","Each media-range might be followed by optional applicable media type parameters (e.g., charset), followed by an optional ""q"" parameter for indicating a relative weight (Section 12.4.2).",The example,12.5.1,Accept,3,5,4,,,,,,E3,SHOULD
"Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method.","When a recipient cache or origin server has successfully completed its normal request checks, and is just about to process the request content or perform the associated action, except when exclusions apply.",The recipient cache or origin server MUST evaluate the received request preconditions.,"Cache,Origin Server",MUST,"Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method. A server MUST ignore all received preconditions if its response to the same request without those conditions, prior to processing the request content, would have been a status code other than a 2xx (Successful) or 412 (Precondition Failed). In other words, redirects and failures that can be detected before significant processing occurs take precedence over the evaluation of preconditions.",,"A server that is not the origin server for the target resource and cannot act as a cache for requests on the target resource MUST NOT evaluate the conditional request header fields defined by this specification, and it MUST forward them if the request is forwarded, since the generating client intends that they be evaluated by a server that can provide a current representation. Likewise, a server MUST ignore the conditional request header fields defined by this specification when received with a request method that does not involve the selection or modification of a selected representation, such as CONNECT, OPTIONS, or TRACE.",13.2.1,When to Evaluate,3,1,1,,,,,,F2,MUST
"A server that is not the origin server for the target resource and cannot act as a cache for requests on the target resource MUST NOT evaluate the conditional request header fields defined by this specification, and it MUST forward them if the request is forwarded, since the generating client intends that they be evaluated by a server that can provide a current representation.","The server is not the origin server for the target resource and cannot act as a cache for requests on the target resource.,The received request uses a method that does not involve the selection or modification of a selected representation (e.g., CONNECT, OPTIONS, or TRACE).","The server MUST NOT evaluate the conditional request header fields defined by the specification and, if the request is forwarded, it MUST forward these header fields.,The server MUST ignore the conditional request header fields when received with a request method that does not involve the selection or modification of a selected representation.",Server,MUST NOT,"A server that is not the origin server for the target resource and cannot act as a cache for requests on the target resource MUST NOT evaluate the conditional request header fields defined by this specification, and it MUST forward them if the request is forwarded, since the generating client intends that they be evaluated by a server that can provide a current representation. Likewise, a server MUST ignore the conditional request header fields defined by this specification when received with a request method that does not involve the selection or modification of a selected representation, such as CONNECT, OPTIONS, or TRACE.","Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method. A server MUST ignore all received preconditions if its response to the same request without those conditions, prior to processing the request content, would have been a status code other than a 2xx (Successful) or 412 (Precondition Failed). In other words, redirects and failures that can be detected before significant processing occurs take precedence over the evaluation of preconditions.","Note that protocol extensions can modify the conditions under which preconditions are evaluated or the consequences of their evaluation. For example, the immutable cache directive (defined by [RFC8246]) instructs caches to forgo forwarding conditional requests when they hold a fresh response.",13.2.1,When to Evaluate,3,2,1,,,,,,F2,MUST
A recipient cache or origin server MUST evaluate the request preconditions defined by this specification in the following order: 1.,"When a request is received by a recipient cache or origin server that includes conditional request header fields (e.g. If-Match or If-Unmodified-Since).,Specifically, when the recipient is the origin server and the If-Match header is present, and when the recipient is the origin server with If-Match not present but the If-Unmodified-Since header is present.","The recipient cache or origin server MUST evaluate the request preconditions defined by the specification in the prescribed order, beginning with the evaluation of the If-Match precondition (if present) followed by evaluation of the If-Unmodified-Since precondition (if If-Match is not present).","Cache,Origin Server",MUST,"A recipient cache or origin server MUST evaluate the request preconditions defined by this specification in the following order: 1. When recipient is the origin server and If-Match is present, evaluate the If-Match precondition:","When more than one conditional request header field is present in a request, the order in which the fields are evaluated becomes important. In practice, the fields defined in this document are consistently implemented in a single, logical order, since ""lost update"" preconditions have more strict requirements than cache validation, a validated cache is more efficient than a partial response, and entity tags are presumed to be more accurate than date validators.","2. When recipient is the origin server, If-Match is not present, and If-Unmodified-Since is present, evaluate the If-Unmodified-Since precondition:",13.2.2,Precedence of Preconditions,3,2,1,,,,,,F2,MUST
"Since there is no predefined limit to the length of content, recipients MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows.","There is no predefined limit to the length of content, which implies that the content may include very large decimal numerals.",Recipients MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows.,Recipient,MUST,"In the byte-range syntax, first-pos, last-pos, and suffix-length are expressed as decimal number of octets. Since there is no predefined limit to the length of content, recipients MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows.","When a selected representation has zero length, the only satisfiable form of range-spec in a GET request is a suffix-range with a non-zero suffix-length.",,14.1.2,Byte Ranges,3,18,2,,,,,,A5,MUST
A server that does not support any kind of range request for the target resource MAY send,The server does not support any kind of range request for the target resource.,The server MAY send the 'Accept-Ranges: none' header.,Server,MAY,A server that does not support any kind of range request for the target resource MAY send,"Conversely, a client MUST NOT assume that receiving an Accept-Ranges field means that future range requests will return partial responses. The content might change, the server might only support range requests at certain times or under certain conditions, or a different intermediary might process the next request.",Accept-Ranges: none,14.3,Accept-Ranges,2,7,1,,,,,,F3,MAY
"For byte ranges, a sender SHOULD indicate the complete length of the representation from which the range has been extracted, unless the complete length is unknown or difficult to determine.","The sender is transmitting a byte range from a representation,The complete length of the representation is known and not difficult to determine",The sender SHOULD indicate the complete length of the representation from which the range has been extracted,Sender,SHOULD,"For byte ranges, a sender SHOULD indicate the complete length of the representation from which the range has been extracted, unless the complete length is unknown or difficult to determine. An asterisk character (""*"") in place of the complete-length indicates that the representation length was unknown when the header field was generated.","Content-Range might also be sent as a request modifier to request a partial PUT, as described in Section 14.5, based on private agreements between client and origin server. A server MUST ignore a Content-Range header field received in a request with a method for which Content-Range support is not defined.",The following example illustrates when the complete length of the selected representation is known by the sender to be 1234 bytes:,14.4,Content-Range,2,4,1,,,,,,F3,SHOULD
"A server MUST NOT generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses.",A request for a single range from a client that does not request multiple parts,The server MUST NOT generate a multipart response,Server,MUST NOT,"A server MUST NOT generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses. However, a server MAY generate a ""multipart/byteranges"" response with only a single body part if multiple ranges were requested and only one range was found to be satisfiable or only one range remained after coalescing. A client that cannot process a ""multipart/byteranges"" response MUST NOT generate a request that asks for multiple ranges.","When multiple ranges are requested, a server MAY coalesce any of the ranges that overlap, or that are separated by a gap that is smaller than the overhead of sending multiple parts, regardless of the order in which the corresponding range-spec appeared in the received Range header field. Since the typical overhead between each part of a ""multipart/byteranges"" is around 80 bytes, depending on the selected representation's media type and the chosen boundary parameter length, it can be less efficient to transfer many small disjoint parts than it is to transfer the entire selected representation.","A server that generates a multipart response SHOULD send the parts in the same order that the corresponding range-spec appeared in the received Range header field, excluding those ranges that were deemed unsatisfiable or that were coalesced into other ranges. A client that receives a multipart response MUST inspect the Content-Range header field present in each body part in order to determine which range is contained in that body part; a client cannot rely on receiving the same ranges that it requested, nor the same order that it requested.",15.3.7,206 Partial Content,3,18,1,,,,,,F3,MUST
"However, a server MAY generate a ""multipart/byteranges"" response with only a single body part if multiple ranges were requested and only one range was found to be satisfiable or only one range remained after coalescing.",Multiple ranges were requested and either only one range was found to be satisfiable or only one range remained after coalescing,"The server MAY generate a ""multipart/byteranges"" response with only a single body part",Server,MAY,"A server MUST NOT generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses. However, a server MAY generate a ""multipart/byteranges"" response with only a single body part if multiple ranges were requested and only one range was found to be satisfiable or only one range remained after coalescing. A client that cannot process a ""multipart/byteranges"" response MUST NOT generate a request that asks for multiple ranges.","When multiple ranges are requested, a server MAY coalesce any of the ranges that overlap, or that are separated by a gap that is smaller than the overhead of sending multiple parts, regardless of the order in which the corresponding range-spec appeared in the received Range header field. Since the typical overhead between each part of a ""multipart/byteranges"" is around 80 bytes, depending on the selected representation's media type and the chosen boundary parameter length, it can be less efficient to transfer many small disjoint parts than it is to transfer the entire selected representation.","A server that generates a multipart response SHOULD send the parts in the same order that the corresponding range-spec appeared in the received Range header field, excluding those ranges that were deemed unsatisfiable or that were coalesced into other ranges. A client that receives a multipart response MUST inspect the Content-Range header field present in each body part in order to determine which range is contained in that body part; a client cannot rely on receiving the same ranges that it requested, nor the same order that it requested.",15.3.7,206 Partial Content,3,18,2,,,,,,F3,MAY
The server SHOULD generate content containing a list of available representation characteristics and corresponding resource identifiers from which the user or user agent can choose the one most appropriate.,When the target resource does not have a current representation acceptable to the user agent (triggering a 406 Not Acceptable situation and indicating that the server is unwilling to supply a default representation),The server SHOULD generate content containing a list of available representation characteristics and corresponding resource identifiers from which the user or user agent can choose the one most appropriate,Server,SHOULD,"The server SHOULD generate content containing a list of available representation characteristics and corresponding resource identifiers from which the user or user agent can choose the one most appropriate. A user agent MAY automatically select the most appropriate choice from that list. However, this specification does not define any standard for such automatic selection, as described in Section 15.4.1.","The 406 (Not Acceptable) status code indicates that the target resource does not have a current representation that would be acceptable to the user agent, according to the proactive negotiation header fields received in the request (Section 12.1), and the server is unwilling to supply a default representation.",,15.5.7,406 Not Acceptable,3,2,1,,,,,,F4,SHOULD
The server SHOULD generate content that includes enough information for a user to recognize the source of the conflict.,When a conflict occurs—typically resulting in a 409 (Conflict) response—indicating that the request could not be completed due to a conflict with the current state of the target resource.,The server SHOULD generate content that includes enough information for a user to recognize the source of the conflict.,Origin Server,SHOULD,The 409 (Conflict) status code indicates that the request could not be completed due to a conflict with the current state of the target resource. This code is used in situations where the user might be able to resolve the conflict and resubmit the request. The server SHOULD generate content that includes enough information for a user to recognize the source of the conflict.,,"Conflicts are most likely to occur in response to a PUT request. For example, if versioning were being used and the representation being PUT included changes to a resource that conflict with those made by an earlier (third-party) request, the origin server might use a 409 response to indicate that it can't complete the request. In this case, the response representation would likely contain information useful for merging the differences based on the revision history.",15.5.10,409 Conflict,3,1,3,,,,,,F4,SHOULD
"The server MAY terminate the request, if the protocol version in use allows it; otherwise, the server MAY close the connection.","if the protocol version in use allows termination,if the protocol version in use does not allow termination (implied by 'otherwise')","terminate the request,close the connection",Server,MAY,"The 413 (Content Too Large) status code indicates that the server is refusing to process a request because the request content is larger than the server is willing or able to process. The server MAY terminate the request, if the protocol version in use allows it; otherwise, the server MAY close the connection.",,"If the condition is temporary, the server SHOULD generate a Retry-After header field to indicate that it is temporary and after what time the client MAY try again.",15.5.14,413 Content Too Large,3,1,2,,,,,,D2,MAY
"It MUST conform to the field-name syntax defined in Section 5.1, and it SHOULD be restricted to just letters, digits, and hyphen ('-') characters, with the first character being a letter.",When a registration request includes a 'Field name' value.,"The provided field name MUST conform to the field-name syntax defined in Section 5.1.,It SHOULD be restricted to letters, digits, and hyphen ('-') characters, with the first character being a letter.",Sender,"MUST, SHOULD","Field name: The requested field name. It MUST conform to the field-name syntax defined in Section 5.1, and it SHOULD be restricted to just letters, digits, and hyphen ('-') characters, with the first character being a letter.",Registration requests consist of the following information:,"Status: ""permanent"", ""provisional"", ""deprecated"", or ""obsoleted"".",16.3.1,Field Name Registry,3,6,2,,,,,,C6,MUST
A recipient MUST parse an HTTP message as a sequence of octets in an encoding that is a superset of US-ASCII [USASCII].,When a recipient receives an HTTP message to be parsed,The recipient MUST parse the HTTP message as a sequence of octets in an encoding that is a superset of US-ASCII [USASCII],Recipient,MUST,"A recipient MUST parse an HTTP message as a sequence of octets in an encoding that is a superset of US-ASCII [USASCII]. Parsing an HTTP message as a stream of Unicode characters, without regard for the specific encoding, creates security vulnerabilities due to the varying ways that string processing libraries handle invalid multibyte character sequences that contain the octet LF (%x0A). String-based parsers can only be safely used within protocol elements after the element has been extracted from the message, such as within a header field line value after message parsing has delineated the individual field lines.","The normal procedure for parsing an HTTP message is to read the start-line into a structure, read each header field line into a hash table by field name until the empty line, and then use the parsed data to determine if a message body is expected. If a message body has been indicated, then it is read as a stream until an amount of octets equal to the message body length is read or the connection is closed.","Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",2.2,Message Parsing,2,2,1,,,,,,A1,MUST
A sender MUST NOT send whitespace between the start-line and the first header field.,When constructing an HTTP message immediately following the start-line and before the first header field,The sender MUST NOT send any whitespace between the start-line and the first header field,Sender,MUST NOT,A sender MUST NOT send whitespace between the start-line and the first header field.,"In the interest of robustness, a server that is expecting to receive and parse a request-line SHOULD ignore at least one empty line (CRLF) received prior to the request-line.","A recipient that receives whitespace between the start-line and the first header field MUST either reject the message as invalid or consume each whitespace-preceded line without further processing of it (i.e., ignore the entire line, along with any subsequent lines preceded by whitespace, until a properly formed header field is received or the header section is terminated). Rejection or removal of invalid whitespace-preceded lines is necessary to prevent their misinterpretation by downstream recipients that might be vulnerable to request smuggling (Section 11.2) or response splitting (Section 11.1) attacks.",2.2,Message Parsing,2,7,1,,,,,,A3,MUST
"A recipient that receives whitespace between the start-line and the first header field MUST either reject the message as invalid or consume each whitespace-preceded line without further processing of it (i.e., ignore the entire line, along with any subsequent lines preceded by whitespace, until a properly formed header field is received or the header section is terminated).",Whitespace is received between the start-line and the first header field.,"The recipient MUST either reject the message as invalid or consume each whitespace-preceded line without further processing (i.e., ignore the entire line, along with any subsequent lines preceded by whitespace, until a properly formed header field is received or the header section is terminated).",Recipient,MUST,"A recipient that receives whitespace between the start-line and the first header field MUST either reject the message as invalid or consume each whitespace-preceded line without further processing of it (i.e., ignore the entire line, along with any subsequent lines preceded by whitespace, until a properly formed header field is received or the header section is terminated). Rejection or removal of invalid whitespace-preceded lines is necessary to prevent their misinterpretation by downstream recipients that might be vulnerable to request smuggling (Section 11.2) or response splitting (Section 11.1) attacks.",A sender MUST NOT send whitespace between the start-line and the first header field.,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",2.2,Message Parsing,2,8,1,,,,,,A3,MUST
"A server MAY send an HTTP/1.0 response to an HTTP/1.1 request if it is known or suspected that the client incorrectly implements the HTTP specification and is incapable of correctly processing later version responses, such as when a client fails to parse the version number correctly or when an intermediary is known to blindly forward the HTTP-version even when it doesn't conform to the given minor version of the protocol.","The client is known or suspected to incorrectly implement the HTTP specification, such as when it fails to parse the version number correctly or when an intermediary blindly forwards the HTTP-version even if it does not conform to the given minor version of the protocol.,Specific client attributes are detected (e.g., one or more request header fields like User-Agent uniquely match values from a client known to be in error).",The server MAY send an HTTP/1.0 response to an HTTP/1.1 request.,Server,MAY,"A server MAY send an HTTP/1.0 response to an HTTP/1.1 request if it is known or suspected that the client incorrectly implements the HTTP specification and is incapable of correctly processing later version responses, such as when a client fails to parse the version number correctly or when an intermediary is known to blindly forward the HTTP-version even when it doesn't conform to the given minor version of the protocol. Such protocol downgrades SHOULD NOT be performed unless triggered by specific client attributes, such as when one or more of the request header fields (e.g., User-Agent) uniquely match the values sent by a client known to be in error.","Intermediaries that process HTTP messages (i.e., all intermediaries other than those acting as tunnels) MUST send their own HTTP-version in forwarded messages, unless it is purposefully downgraded as a workaround for an upstream issue. In other words, an intermediary is not allowed to blindly forward the start-line without ensuring that the protocol version in that message matches a version to which that intermediary is conformant for both the receiving and sending of messages. Forwarding an HTTP message without rewriting the HTTP-version might result in communication errors when downstream recipients use the message sender's version to determine what features are safe to use for later communication with that sender.",,2.3,HTTP Version,2,5,1,,,,,,A4,MAY
"A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain.","When a received HTTP request contains an invalid request-line (e.g., due to improperly encoded whitespace)",The recipient SHOULD NOT attempt to autocorrect and then process the request without issuing a redirect,Recipient,SHOULD NOT,"Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded. A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain.","No whitespace is allowed in the request-target. Unfortunately, some user agents fail to properly encode or exclude whitespace found in hypertext references, resulting in those disallowed characters being sent as the request-target in a malformed request-line.","A client MUST send a Host header field (Section 7.2 of [HTTP]) in all HTTP/1.1 request messages. If the target URI includes an authority component, then a client MUST send a field value for Host that is identical to that authority component, excluding any userinfo subcomponent and its ""@"" delimiter (Section 4.2 of [HTTP]). If the authority component is missing or undefined for the target URI, then a client MUST send a Host header field with an empty field value.",3.2,Request Target,2,3,2,,,,,,A3,SHOULD
A server MUST accept the absolute-form in requests even though most HTTP/1.1 clients will only send the absolute-form to a proxy.,A request using the absolute-form in its request-target,The server MUST accept such requests that use the absolute-form,Server,MUST,A server MUST accept the absolute-form in requests even though most HTTP/1.1 clients will only send the absolute-form to a proxy.,"When an origin server receives a request with an absolute-form of request-target, the origin server MUST ignore the received Host header field (if any) and instead use the host information of the request-target. Note that if the request-target does not have an authority component, an empty Host header field will be sent in this case.",,3.2.2,absolute-form,3,8,1,,,,,,A3,MUST
"A server MUST send the space that separates the status-code from the reason-phrase even when the reason-phrase is absent (i.e., the status-line would end with the space).",The reason-phrase is absent in the status-line.,"The server MUST send the space that separates the status-code from the reason-phrase, ensuring that the status-line ends with a space.",Server,MUST,"A client SHOULD ignore the reason-phrase content because it is not a reliable channel for information (it might be translated for a given locale, overwritten by intermediaries, or discarded when the message is forwarded via other versions of HTTP). A server MUST send the space that separates the status-code from the reason-phrase even when the reason-phrase is absent (i.e., the status-line would end with the space).","The reason-phrase element exists for the sole purpose of providing a textual description associated with the numeric status code, mostly out of deference to earlier Internet application protocols that were more frequently used with interactive text clients.",,4,Status Line,1,6,2,,,,,,A3,MUST
"A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the ""message/http"" media type.","When a sender is about to generate a message that includes line folding (i.e., any field line value contains a match to the obs-fold rule) and the message is not intended for packaging within the 'message/http' media type.",The sender MUST NOT generate such a message.,Sender,MUST NOT,"A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the ""message/http"" media type.","Historically, HTTP/1.x field values could be extended over multiple lines by preceding each extra line with at least one space or horizontal tab (obs-fold). This specification deprecates such line folding except within the ""message/http"" media type (Section 10.1).","A server that receives an obs-fold in a request message that is not within a ""message/http"" container MUST either reject the message by sending a 400 (Bad Request), preferably with a representation explaining that obsolete line folding is unacceptable, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.",5.2,Obsolete Line Folding,2,2,1,,,,,,C3,MUST
"Regardless, the server MUST close the connection after responding to such a request to avoid the potential attacks.","A request that contains both Content-Length and Transfer-Encoding header fields or is processed based solely on the Transfer-Encoding header field, potentially exposing the connection to vulnerabilities such as request smuggling or response splitting.",The server MUST close the connection after responding to such a request.,Server,MUST,"A server MAY reject a request that contains both Content-Length and Transfer-Encoding or process such a request in accordance with the Transfer-Encoding alone. Regardless, the server MUST close the connection after responding to such a request to avoid the potential attacks.","Early implementations of Transfer-Encoding would occasionally send both a chunked transfer coding for message framing and an estimated Content-Length header field for use by progress bars. This is why Transfer-Encoding is defined as overriding Content-Length, as opposed to them being mutually incompatible. Unfortunately, forwarding such a message can lead to vulnerabilities regarding request smuggling (Section 11.2) or response splitting (Section 11.1) attacks if any downstream recipient fails to parse the message according to this specification, particularly when a downstream recipient only implements HTTP/1.0.","A server or client that receives an HTTP/1.0 message containing a Transfer-Encoding header field MUST treat the message as if the framing is faulty, even if a Content-Length is present, and close the connection after processing the message. The message sender might have retained a portion of the message, in buffer, that could be misinterpreted by further use of the connection.",6.1,Transfer-Encoding,2,14,2,,,,,,D2,MUST
"If the sender closes the connection or the recipient times out before the indicated number of octets are received, the recipient MUST consider the message to be incomplete and close the connection","The sender closes the connection,The recipient times out before the indicated number of octets are received",The recipient MUST consider the message to be incomplete and close the connection,Recipient,MUST,"5. If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value). If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection. If it is in a response message received by a proxy, the proxy MUST close the connection to the server, discard the received response, and send a 502 (Bad Gateway) response to the client. If it is in a response message received by a user agent, the user agent MUST close the connection to the server and discard the received response. 6. If a valid Content-Length header field is present without Transfer-Encoding, its decimal value defines the expected message body length in octets. If the sender closes the connection or the recipient times out before the indicated number of octets are received, the recipient MUST consider the message to be incomplete and close the connection. 7. If this is a request message and none of the above are true, then the message body length is zero (no message body is present). 8. Otherwise, this is a response message without a declared message body length, so the message body length is determined by the number of octets received prior to the server closing the connection.","The length of a message body is determined by one of the following (in order of precedence): 1. Any response to a HEAD request and any response with a 1xx (Informational), 204 (No Content), or 304 (Not Modified) status code is always terminated by the first empty line after the header fields, regardless of the header fields present in the message, and thus cannot contain a message body or trailer section. 2. Any 2xx (Successful) response to a CONNECT request implies that the connection will become a tunnel immediately after the empty line that concludes the header fields. A client MUST ignore any Content-Length or Transfer-Encoding header fields received in such a message. 3. If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length. Such a message might indicate an attempt to perform request smuggling (Section 11.2) or response splitting (Section 11.1) and ought to be handled as an error. An intermediary that chooses to forward the message MUST first remove the received Content-Length field and process the Transfer-Encoding (as described below) prior to forwarding the message downstream. 4. If a Transfer-Encoding header field is present and the chunked transfer coding (Section 7.1) is the final encoding, the message body length is determined by reading and decoding the chunked data until the transfer coding indicates the data is complete.","Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible. The close-delimiting feature exists primarily for backwards compatibility with HTTP/1.0.",6.3,Message Body Length,2,2,8,,,,,,A5,MUST
"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.","When a response message is close-delimited, making it impossible to distinguish a fully received response from one that was partially received due to network failure.",The server SHOULD generate messages using encoding or length-delimiting whenever possible.,Server,SHOULD,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible. The close-delimiting feature exists primarily for backwards compatibility with HTTP/1.0.","5. If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value). If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection. If it is in a response message received by a proxy, the proxy MUST close the connection to the server, discard the received response, and send a 502 (Bad Gateway) response to the client. If it is in a response message received by a user agent, the user agent MUST close the connection to the server and discard the received response. 6. If a valid Content-Length header field is present without Transfer-Encoding, its decimal value defines the expected message body length in octets. If the sender closes the connection or the recipient times out before the indicated number of octets are received, the recipient MUST consider the message to be incomplete and close the connection. 7. If this is a request message and none of the above are true, then the message body length is zero (no message body is present). 8. Otherwise, this is a response message without a declared message body length, so the message body length is determined by the number of octets received prior to the server closing the connection.",A server MAY reject a request that contains a message body but not a Content-Length by responding with 411 (Length Required).,6.3,Message Body Length,2,3,1,,,,,,A5,SHOULD
"Therefore, recipients MUST anticipate potentially large hexadecimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer representation.","When processing a chunked response, the recipient may encounter very large hexadecimal numeral values.",The recipient MUST anticipate potentially large hexadecimal numerals and prevent parsing errors due to integer conversion overflows or precision loss resulting from integer representation.,Recipient,MUST,"HTTP/1.1 does not define any means to limit the size of a chunked response such that an intermediary can be assured of buffering the entire response. Additionally, very large chunk sizes may cause overflows or loss of precision if their values are not represented accurately in a receiving implementation. Therefore, recipients MUST anticipate potentially large hexadecimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer representation.",A recipient MUST be able to parse and decode the chunked transfer coding.,The chunked coding does not define any parameters. Their presence SHOULD be treated as an error.,7.1,Chunked Transfer Coding,2,4,3,,,,,,A5,MUST
Their presence SHOULD be treated as an error.,Parameters are present in the chunked coding (even though chunked coding does not define any parameters),The presence of parameters SHOULD be treated as an error,Recipient,SHOULD,The chunked coding does not define any parameters. Their presence SHOULD be treated as an error.,"HTTP/1.1 does not define any means to limit the size of a chunked response such that an intermediary can be assured of buffering the entire response. Additionally, very large chunk sizes may cause overflows or loss of precision if their values are not represented accurately in a receiving implementation. Therefore, recipients MUST anticipate potentially large hexadecimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer representation.",,7.1,Chunked Transfer Coding,2,5,2,,,,,,A5,SHOULD
A recipient MUST ignore unrecognized chunk extensions.,The presence of unrecognized chunk extensions in the message.,The recipient MUST ignore the unrecognized chunk extensions.,"Recipient,Server",MUST,"A recipient MUST ignore unrecognized chunk extensions. A server ought to limit the total length of chunk extensions received in a request to an amount reasonable for the services provided, in the same way that it applies length limitations and timeouts for other parts of a message, and generate an appropriate 4xx (Client Error) response if that amount is exceeded.","The chunked coding is specific to each connection and is likely to be removed or recoded by each recipient (including intermediaries) before any higher-level application would have a chance to inspect the extensions. Hence, the use of chunk extensions is generally limited to specialized HTTP services such as ""long polling"" (where client and server can have shared expectations regarding the use of chunk extensions) or for padding within an end-to-end secured connection.",,7.1.1,Chunk Extensions,3,3,1,,,,,,A5,MUST
"Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",When transfer codings are registered in the future,"Transfer coding registrations SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities",Recipient,SHOULD NOT,"The TE header field (Section 10.1.4 of [HTTP]) uses a pseudo-parameter named ""q"" as the rank value when multiple transfer codings are acceptable. Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.","Names of transfer codings MUST NOT overlap with names of content codings (Section 8.4.1 of [HTTP]) unless the encoding transformation is identical, as is the case for the compression codings defined in Section 7.2.",Values to be added to this namespace require IETF Review (see Section 4.8 of [RFC8126]) and MUST conform to the purpose of transfer coding defined in this specification.,7.3,Transfer Coding Registry,2,7,2,,,,,,A5,SHOULD
Values to be added to this namespace require IETF Review (see Section 4.8 of [RFC8126]) and MUST conform to the purpose of transfer coding defined in this specification.,A value is being added to the namespace.,The value requires IETF Review (per Section 4.8 of [RFC8126]) and MUST conform to the purpose of transfer coding defined in this specification.,Sender,MUST,Values to be added to this namespace require IETF Review (see Section 4.8 of [RFC8126]) and MUST conform to the purpose of transfer coding defined in this specification.,"The TE header field (Section 10.1.4 of [HTTP]) uses a pseudo-parameter named ""q"" as the rank value when multiple transfer codings are acceptable. Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",Use of program names for the identification of encoding formats is not desirable and is discouraged for future encodings.,7.3,Transfer Coding Registry,2,8,1,,,,,,A5,MUST
"A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.","A server receives an incomplete request message, usually due to a canceled request or a triggered timeout exception.",The server MAY send an error response prior to closing the connection.,Server,MAY,"A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.",,"A client that receives an incomplete response message, which can occur when a connection is closed prematurely or when decoding a supposedly chunked transfer coding fails, MUST record the message as incomplete. Cache requirements for incomplete responses are defined in Section 3.3 of [CACHING].",8,Handling Incomplete Messages,1,1,1,,,,,,D2,MAY
HTTP implementations SHOULD support persistent connections.,,HTTP implementations SHOULD support persistent connections.,Recipient,SHOULD,"HTTP/1.1 defaults to the use of ""persistent connections"", allowing multiple requests and responses to be carried over a single connection. HTTP implementations SHOULD support persistent connections.",,"A recipient determines whether a connection is persistent or not based on the protocol version and Connection header field (Section 7.6.1 of [HTTP]) in the most recently received message, if any:",9.3,Persistence,2,1,2,,,,,,D1,SHOULD
"A server MUST read the entire request message body or close the connection after sending its response; otherwise, the remaining data on a persistent connection would be misinterpreted as the next request.",After the server sends its response on a persistent connection where a request message body may remain unread,The server MUST either read the entire request message body or close the connection after sending its response,Server,MUST,"In order to remain persistent, all messages on a connection need to have a self-defined message length (i.e., one not defined by closure of the connection), as described in Section 6. A server MUST read the entire request message body or close the connection after sending its response; otherwise, the remaining data on a persistent connection would be misinterpreted as the next request. Likewise, a client MUST read the entire response message body if it intends to reuse the same connection for a subsequent request.","A client MAY send additional requests on a persistent connection until it sends or receives a ""close"" connection option or receives an HTTP/1.0 response without a ""keep-alive"" connection option.",A proxy server MUST NOT maintain a persistent connection with an HTTP/1.0 client (see Appendix C.2.2 for information and discussion of the problems with the Keep-Alive header field implemented by many HTTP/1.0 clients).,9.3,Persistence,2,10,2,,,,,,D1,MUST
"A server MAY process a sequence of pipelined requests in parallel if they all have safe methods (Section 9.2.1 of [HTTP]), but it MUST send the corresponding responses in the same order that the requests were received.","A sequence of pipelined requests is being processed in parallel,All the pipelined requests use safe methods",The server MUST send the corresponding responses in the same order that the requests were received,Server,"MUST, MAY","A client that supports persistent connections MAY ""pipeline"" its requests (i.e., send multiple requests without waiting for each response). A server MAY process a sequence of pipelined requests in parallel if they all have safe methods (Section 9.2.1 of [HTTP]), but it MUST send the corresponding responses in the same order that the requests were received.",,"A client that pipelines requests SHOULD retry unanswered requests if the connection closes before it receives all of the corresponding responses. When retrying pipelined requests after a failed connection (a connection not explicitly closed by the server in its last complete response), a client MUST NOT pipeline immediately after connection establishment, since the first remaining request in the prior pipeline might have caused an error response that can be lost again if multiple requests are sent on a prematurely closed connection (see the TCP reset problem described in Section 9.6).",9.3.2,Pipelining,3,1,2,,,,,,D1,MUST
A client or server that wishes to time out SHOULD issue a graceful close on the connection.,A client or server wishes to time out,Issue a graceful close on the connection,"Client,Server",SHOULD,"A client or server that wishes to time out SHOULD issue a graceful close on the connection. Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.",Servers will usually have some timeout value beyond which they will no longer maintain an inactive connection. Proxy servers might make this a higher value since it is likely that the client will be making more connections through the same proxy server. The use of persistent connections places no requirements on the length (or existence) of this timeout for either the client or the server.,"A client, server, or proxy MAY close the transport connection at any time. For example, a client might have started to send a new request at the same time that the server has decided to close the ""idle"" connection. From the server's point of view, the connection is being closed while it was idle, but from the client's point of view, a request is in progress.",9.5,Failures and Timeouts,2,2,1,,,,,,D2,SHOULD
"Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.",An open connection receives a closure signal.,Implementations SHOULD constantly monitor open connections and respond appropriately to the received closure signal.,"Client,Server",SHOULD,"A client or server that wishes to time out SHOULD issue a graceful close on the connection. Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.",Servers will usually have some timeout value beyond which they will no longer maintain an inactive connection. Proxy servers might make this a higher value since it is likely that the client will be making more connections through the same proxy server. The use of persistent connections places no requirements on the length (or existence) of this timeout for either the client or the server.,"A client, server, or proxy MAY close the transport connection at any time. For example, a client might have started to send a new request at the same time that the server has decided to close the ""idle"" connection. From the server's point of view, the connection is being closed while it was idle, but from the client's point of view, a request is in progress.",9.5,Failures and Timeouts,2,2,2,,,,,,D2,SHOULD
"A client, server, or proxy MAY close the transport connection at any time.",No specific trigger condition is defined; the connection may be closed at any time without a precondition.,"A client, server, or proxy MAY close the transport connection.","Client,Server,Proxy",MAY,"A client, server, or proxy MAY close the transport connection at any time. For example, a client might have started to send a new request at the same time that the server has decided to close the ""idle"" connection. From the server's point of view, the connection is being closed while it was idle, but from the client's point of view, a request is in progress.","A client or server that wishes to time out SHOULD issue a graceful close on the connection. Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.","A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry. The latter technique can exacerbate network congestion or server load.",9.5,Failures and Timeouts,2,3,1,,,,,,D2,MAY
"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.","When persistent connections can be maintained (i.e., when it is possible to do so),When the server experiences temporary overload conditions",The server SHOULD sustain persistent connections and allow the underlying transport’s flow-control mechanisms to resolve temporary overloads rather than terminating connections with the expectation that clients will retry.,Server,SHOULD,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry. The latter technique can exacerbate network congestion or server load.","A client, server, or proxy MAY close the transport connection at any time. For example, a client might have started to send a new request at the same time that the server has decided to close the ""idle"" connection. From the server's point of view, the connection is being closed while it was idle, but from the client's point of view, a request is in progress.","A client sending a message body SHOULD monitor the network connection for an error response while it is transmitting the request. If the client sees a response that indicates the server does not wish to receive the message body and is closing the connection, the client SHOULD immediately cease transmitting the body and close its side of the connection.",9.5,Failures and Timeouts,2,4,1,,,,,,D1,SHOULD
"A server that receives a ""close"" connection option MUST initiate closure of the connection (see below) after it sends the final response to the request that contained the ""close"" connection option",The server receives a 'close' connection option in a request.,The server MUST initiate closure of the connection after sending the final response to the request that contained the 'close' connection option.,Server,MUST,"A server that receives a ""close"" connection option MUST initiate closure of the connection (see below) after it sends the final response to the request that contained the ""close"" connection option. The server SHOULD send a ""close"" connection option in its final response on that connection. The server MUST NOT process any further requests received on that connection.","A client that sends a ""close"" connection option MUST NOT send further requests on that connection (after the one containing the ""close"") and MUST close the connection after reading the final response message corresponding to this request.","A server that sends a ""close"" connection option MUST initiate closure of the connection (see below) after it sends the response containing the ""close"" connection option. The server MUST NOT process any further requests received on that connection.",9.6,Tear-down,2,6,1,,,,,,D3,MUST
"The server SHOULD send a ""close"" connection option in its final response on that connection.",The server is sending the final response on a connection where a 'close' connection option has been indicated by the client.,The server SHOULD send a 'close' connection option in its final response on that connection.,Server,SHOULD,"A server that receives a ""close"" connection option MUST initiate closure of the connection (see below) after it sends the final response to the request that contained the ""close"" connection option. The server SHOULD send a ""close"" connection option in its final response on that connection. The server MUST NOT process any further requests received on that connection.","A client that sends a ""close"" connection option MUST NOT send further requests on that connection (after the one containing the ""close"") and MUST close the connection after reading the final response message corresponding to this request.","A server that sends a ""close"" connection option MUST initiate closure of the connection (see below) after it sends the response containing the ""close"" connection option. The server MUST NOT process any further requests received on that connection.",9.6,Tear-down,2,6,2,,,,,,D3,SHOULD
The server MUST NOT process any further requests received on that connection.,"When a connection is subject to a 'close' connection option (either received in a request or initiated in a response), indicating that the connection is in the process of being closed.",The server MUST NOT process any further requests received on that connection.,Server,MUST NOT,"A server that receives a ""close"" connection option MUST initiate closure of the connection (see below) after it sends the final response to the request that contained the ""close"" connection option. The server SHOULD send a ""close"" connection option in its final response on that connection. The server MUST NOT process any further requests received on that connection.","A client that sends a ""close"" connection option MUST NOT send further requests on that connection (after the one containing the ""close"") and MUST close the connection after reading the final response message corresponding to this request.","A server that sends a ""close"" connection option MUST initiate closure of the connection (see below) after it sends the response containing the ""close"" connection option. The server MUST NOT process any further requests received on that connection.",9.6,Tear-down,2,6,3,,,,,,D3,MUST
"A server that sends a ""close"" connection option MUST initiate closure of the connection (see below) after it sends the response containing the ""close"" connection option.",A server sends a 'close' connection option in the response message,The server MUST initiate closure of the connection after it sends the response containing the 'close' connection option,Server,MUST,"A server that sends a ""close"" connection option MUST initiate closure of the connection (see below) after it sends the response containing the ""close"" connection option. The server MUST NOT process any further requests received on that connection.","A server that receives a ""close"" connection option MUST initiate closure of the connection (see below) after it sends the final response to the request that contained the ""close"" connection option. The server SHOULD send a ""close"" connection option in its final response on that connection. The server MUST NOT process any further requests received on that connection.","A client that receives a ""close"" connection option MUST cease sending requests on that connection and close the connection after reading the response message containing the ""close"" connection option; if additional pipelined requests had been sent on the connection, the client SHOULD NOT assume that they will be processed by the server.",9.6,Tear-down,2,7,1,,,,,,D3,MUST
The server MUST NOT process any further requests received on that connection.,The connection has been marked for closure due to the presence of a 'close' connection option (either received in a request or sent in a response).,The server MUST NOT process any further requests received on that connection.,Server,MUST NOT,"A server that sends a ""close"" connection option MUST initiate closure of the connection (see below) after it sends the response containing the ""close"" connection option. The server MUST NOT process any further requests received on that connection.","A server that receives a ""close"" connection option MUST initiate closure of the connection (see below) after it sends the final response to the request that contained the ""close"" connection option. The server SHOULD send a ""close"" connection option in its final response on that connection. The server MUST NOT process any further requests received on that connection.","A client that receives a ""close"" connection option MUST cease sending requests on that connection and close the connection after reading the response message containing the ""close"" connection option; if additional pipelined requests had been sent on the connection, the client SHOULD NOT assume that they will be processed by the server.",9.6,Tear-down,2,7,2,,,,,,D3,MUST
"All HTTP data MUST be sent as TLS ""application data"" but is otherwise treated like a normal connection for HTTP (including potential reuse as a persistent connection).","When HTTP data is transmitted over an established TLS connection, following a completed TLS handshake","HTTP data MUST be sent as TLS ""application data"" while maintaining treatment as a normal HTTP connection, including the potential reuse as a persistent connection",Sender,MUST,"The HTTP client also acts as the TLS client. It initiates a connection to the server on the appropriate port and sends the TLS ClientHello to begin the TLS handshake. When the TLS handshake has finished, the client may then initiate the first HTTP request. All HTTP data MUST be sent as TLS ""application data"" but is otherwise treated like a normal connection for HTTP (including potential reuse as a persistent connection).","Conceptually, HTTP/TLS is simply sending HTTP messages over a connection secured via TLS [TLS13].",,9.7,TLS Connection Initiation,2,2,4,,,,,,D4,MUST
"Servers SHOULD be prepared to receive an incomplete close from the client, since the client can often locate the end of server data.","An incomplete close is initiated by the client (i.e., the client closes the connection without waiting for the server's closure alert, as it can often determine the end of server data)",Servers SHOULD be prepared to receive an incomplete close from the client,Server,SHOULD,"Servers SHOULD be prepared to receive an incomplete close from the client, since the client can often locate the end of server data.","Clients MUST send a closure alert before closing the connection. Clients that do not expect to receive any more data MAY choose not to wait for the server's closure alert and simply close the connection, thus generating an incomplete close on the server side.","Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection. Servers MAY close the connection after sending the closure alert, thus generating an incomplete close on the client side.",9.8,TLS Connection Closure,2,8,1,,,,,,D4,SHOULD
Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection.,Before closing the connection,Servers MUST attempt to initiate an exchange of closure alerts with the client,Server,MUST,"Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection. Servers MAY close the connection after sending the closure alert, thus generating an incomplete close on the client side.","Servers SHOULD be prepared to receive an incomplete close from the client, since the client can often locate the end of server data.",,9.8,TLS Connection Closure,2,9,1,,,,,,D4,MUST
"Servers MAY close the connection after sending the closure alert, thus generating an incomplete close on the client side.",After the server sends the closure alert to the client,"The server MAY close the connection, which may generate an incomplete close on the client side",Server,MAY,"Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection. Servers MAY close the connection after sending the closure alert, thus generating an incomplete close on the client side.","Servers SHOULD be prepared to receive an incomplete close from the client, since the client can often locate the end of server data.",,9.8,TLS Connection Closure,2,9,2,,,,,,D4,MAY
