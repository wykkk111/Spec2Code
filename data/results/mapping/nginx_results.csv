function_id,function_name,sr_content,sr_index,outcome,met_constrains,explanation,status,api_response
429,ngx_stream_variable_status,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function solely formats and returns the status code as a string and does not implement any logic that checks or restricts generation of protocol elements by sender role. There is no logic in the function addressing the RFC requirement that a sender MUST NOT generate protocol elements reserved for other roles. Therefore, none of the specified constraints (e.g., C1, A1) are implemented within this function.",success,
678,ngx_stream_preread,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (c->buffer->last == c->buffer->end) {\n    ngx_log_error(NGX_LOG_ERR, c->log, 0, ""preread buffer full"");\n    return NGX_STREAM_BAD_REQUEST;\n}', 'explanation': 'This segment checks if the buffer is full and, if so, logs an error and returns a bad request, which enforces that the protocol element does not exceed a reasonable size. This aligns with the defensive parsing requirement of the RFC regarding buffer size limits.'}}]","The function implements a defensive mechanism by continuously reading from the connection and checking whether the buffer has been exhausted, which addresses part of the RFC specification concerning defensive parsing of a protocol element. However, the responsibility for parsing the protocol element's ABNF grammar is delegated to ph->handler and is not performed directly in the function. As a result, while the function takes steps for defensive processing (e.g., checking buffer length C1), it only partially fulfills the overall intent of parsing the received protocol element defensively.",success,
680,ngx_stream_validate_host,A recipient that processes such a URI reference MUST reject it as invalid.,226,Fully Matches,"[{'C1': {'code': 'if (host_len == 0) {\n    return NGX_DECLINED;\n}', 'explanation': 'The RFC requires that a URI reference with an empty host identifier be rejected. The function checks if the computed host length is 0 and returns NGX_DECLINED, thereby rejecting an empty host identifier.'}}]","The function validates the host component by parsing and adjusting its length, and it explicitly rejects a host if its final length is 0. This behavior aligns with the RFC requirement that a recipient must reject an 'https' URI with an empty host identifier. Although the function also converts uppercase characters to lowercase and performs other validations, the core RFC constraint from the provided spec is addressed by the check for an empty host.",success,
680,ngx_stream_validate_host,A recipient that processes such a URI reference MUST reject it as invalid.,224,Fully Matches,"[{'C1': {'code': 'if (host_len == 0) {\n    return NGX_DECLINED;\n}', 'explanation': 'This code checks whether the host identifier has zero length and returns NGX_DECLINED, effectively rejecting a URI with an empty host as required by the RFC.'}}]","The function examines the host component by iterating over its characters and adjusts the effective host length accordingly. Critically, it includes a check for an empty host identifier (if host_len equals 0) and returns a rejection value. This directly implements the RFC requirement that a recipient MUST reject a URI reference with an empty host identifier. Thus, the function by itself visibly addresses the specified constraint from the RFC.",success,
706,ngx_stream_proxy_protocol_handler,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (rev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");\n    ngx_stream_finalize_session(s, NGX_STREAM_OK);\n    return;\n}', 'explanation': ""This segment detects a timeout situation and finalizes the session, which is in line with the spec's allowance to close a connection at any time (gracefully closing an idle or timed‐out connection).""}}, {'A1': {'code': 'if (n == -1) {\n    if (err == NGX_EAGAIN) {\n        // ... handling read events and setting a timer\n    }\n    ngx_connection_error(c, err, ""recv() failed"");\n    ngx_stream_finalize_session(s, NGX_STREAM_OK);\n    return;\n}', 'explanation': 'This code handles read failures by logging the error and finalizing the session, effectively closing the connection when a transport error is detected, which is consistent with the spec allowing closure of the transport connection.'}}]","The function attempts to implement the RFC where a client, server, or proxy may close the transport connection at any time. Specifically, it handles timeouts and read errors by finalizing the session, thus closing the connection gracefully. However, while these actions reflect certain aspects of the spec (like allowing a graceful close), the function does not address other aspects of persistent connection management mentioned in the RFC context. Therefore, it only partially matches the spec constraints.",success,
751,ngx_stream_upstream_addr_variable,"In any production that uses the list construct, a sender MUST NOT generate empty list elements.",236,Does Not Match,[],"The RFC specification requires that when generating a comma‐delimited list, no empty list elements are produced. In the function, a for-loop iterates over the upstream state entries. For each iteration, if the peer exists then its address is copied, but regardless of whether the peer exists, the code appends the comma and space separator for all iterations except the last one. This means that if any state[i].peer is NULL, the separator is still output even though no element data was written, which may lead to an empty element in the list. Since the function does not include logic to avoid appending separators when the element is empty, it does not satisfy the spec constraint within its own implementation.",success,
805,ngx_stream_proxy_test_finalize,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'if (pc == NULL\n    || (!c->read->eof && !pc->read->eof)\n    || (!c->read->eof && c->buffered)\n    || (!pc->read->eof && pc->buffered))\n{\n    return NGX_DECLINED;\n}', 'explanation': ""This segment prevents premature finalization when either side is still active or when there's buffered data. In doing so, it helps keep the connection open, which partially reflects the RFC's requirement to sustain persistent connections rather than closing them immediately.""}}, {'A1': {'code': 'if (pscf->half_close) {\n    /* avoid closing live connections until both read ends get EOF */\n    if (!(c->read->eof && pc->read->eof && !c->buffered && !pc->buffered)) {\n         return NGX_DECLINED;\n    }\n}', 'explanation': ""This block delays closing the connection until both ends have reached EOF and no data remains buffered. This aligns with the RFC's notion of not terminating connections prematurely and allowing for continued data flow for as long as possible.""}}]","The function implements logic that prevents finalization (i.e., connection closure) when the connection is still active or has data buffered, and it further delays closure under the half-close configuration. These checks demonstrate an attempt to sustain persistent connections rather than closing them immediately, which partially meets the RFC specification. However, the code does not explicitly handle other aspects such as leveraging the underlying transport's flow-control mechanisms to resolve temporary overloads, hence the overall implementation is only a partial match.",success,
808,ngx_stream_proxy_finalize,Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection.,325,Does Not Match,[],"The provided function does perform connection finalization and even calls an SSL shutdown on the upstream connection if SSL is enabled, but it does not address the requirement that the server must attempt to initiate an exchange of closure alerts with the client before closing the connection. The logic for initiating a closure alert exchange, as required by the HTTP RFC, is absent in the function. Although the function calls ngx_ssl_shutdown when the upstream connection uses SSL, this only applies to the upstream connection and does not represent an attempt to exchange closure alerts with the client-side connection.",success,
1071,ngx_freebsd_sendfile_chain,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'if (!wev->ready) {\n    return in;\n}\n\n... later in the code ...\nif (eagain) {\n    wev->ready = 0;\n    return in;\n}\n\nif (eintr) {\n    send = prev_send + sent;\n    continue;\n}\n', 'explanation': ""This part of the code checks whether the write event is ready and, in the event of a temporary overload (indicated by EAGAIN) or an interrupted system call (EINTR), avoids closing the connection immediately. By returning the current chain without terminating, it implicitly allows the underlying transport's flow-control to eventually resume transmission, supporting the persistent connection requirement.""}}, {'A1': {'code': 'if (ngx_freebsd_use_tcp_nopush\n    && c->tcp_nopush == NGX_TCP_NOPUSH_UNSET)\n{\n    if (ngx_tcp_nopush(c->fd) == -1) {\n        err = ngx_socket_errno;\n        if (err != NGX_EINTR) {\n            wev->error = 1;\n            (void) ngx_connection_error(c, err, ngx_tcp_nopush_n "" failed"");\n            return NGX_CHAIN_ERROR;\n        }\n    } else {\n        c->tcp_nopush = NGX_TCP_NOPUSH_SET;\n        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0, ""tcp_nopush"");\n    }\n}\n', 'explanation': ""This segment attempts to optimize data transmission by setting the TCP_NOPUSH option. Although its primary purpose is performance optimization, handling it in a non-disruptive manner aligns with the RFC's recommendation to use transport-level mechanisms (i.e. underlying flow control) rather than closing the connection. This, however, is part of a broader strategy and does not alone completely cover all aspects of sustaining persistent connections.""}}]","The function implements some mechanisms that avoid abruptly closing the connection when facing temporary overloads or interruptions, such as handling EAGAIN and EINTR, and by setting TCP_NOPUSH when appropriate. These actions indirectly support the RFC requirement of sustaining persistent connections and relying on underlying flow-control. However, not every detail of the RFC (e.g., explicit monitoring of client message body transmission and reacting to server signals to stop transmission) is fully addressed in this function alone, leading to a determination of partial matching.",success,
1339,ngx_http_parse_request_line,All general-purpose servers MUST support the methods GET and HEAD,58,Fully Matches,"[{'C1': {'code': ""case sw_method:\n    if (ch == ' ') {\n        r->method_end = p - 1;\n        m = r->request_start;\n\n        switch (p - m) {\n\n        case 3:\n            if (ngx_str3_cmp(m, 'G', 'E', 'T', ' ')) {\n                r->method = NGX_HTTP_GET;\n                break;\n            }\n            ...\n        case 4:\n            if (m[1] == 'O') {\n                ...\n            } else {\n                if (ngx_str4cmp(m, 'H', 'E', 'A', 'D')) {\n                    r->method = NGX_HTTP_HEAD;\n                    break;\n                }\n            }\n            ...\n        }\n        state = sw_spaces_before_uri;\n        break;\n    }"", 'explanation': ""The function explicitly parses the HTTP request line and checks the method token. It recognizes 'GET' (a three‐character method) and 'HEAD' (a four‐character method) by comparing the incoming token to these values. This directly implements the RFC requirement that all general-purpose servers MUST support GET and HEAD.""}}, {'A1': {'code': 'if (r->http_version == 9 && r->method != NGX_HTTP_GET) {\n    return NGX_HTTP_PARSE_INVALID_09_METHOD;\n}', 'explanation': ""For HTTP/0.9 requests, the code ensures that only the GET method is accepted, reinforcing the requirement to support GET (and implicitly HEAD in later HTTP versions), consistent with the RFC's emphasis on these mandatory methods.""}}]","The HTTP request parser function contains clear logic to recognize and handle the GET and HEAD methods as mandated by the RFC. It uses specific switch-case statements based on the length of the incoming method token and string comparisons to set the appropriate method identifiers. Additionally, it ensures that HTTP/0.9 only accepts GET, further ensuring that mandatory support is in place. These code segments demonstrate that the function itself directly addresses the RFC specification that all general-purpose servers MUST support GET and HEAD.",success,
1339,ngx_http_parse_request_line,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Fully Matches,"[{'C1': {'code': 'case sw_almost_done:\n    r->request_end = p - 1;\n    switch (ch) {\n    case LF:\n        goto done;\n    default:\n        return NGX_HTTP_PARSE_INVALID_REQUEST;\n    }\n\n... \ncase sw_http_09:\n    switch (ch) {\n    case LF:\n        r->http_minor = 9;\n        goto done;\n    case CR:\n        r->http_minor = 9;\n        state = sw_almost_done;\n        break;\n    ...\n    }\n\nand other similar branches, such as in sw_minor_digit and sw_after_slash_in_uri, where a lone LF is accepted (leading directly to goto done) and a CR is handled by transitioning to sw_almost_done which requires that it be followed immediately by LF.', 'explanation': 'The RFC specifies that although CRLF is the standard terminator, a recipient MAY recognize a single LF as a valid line terminator and ignore any preceding CR. The function checks for LF directly in several states and sets the appropriate termination conditions. When a CR is encountered, it enters a state (sw_almost_done) that only accepts an LF immediately afterward—thus rejecting a bare CR. This meets the RFC requirement.'}}]","The function ngx_http_parse_request_line implements line termination processing by checking for both CR and LF. It accepts a lone LF as a valid terminator (as seen in multiple state cases) and ensures that a CR is only accepted when followed immediately by an LF, thereby effectively ignoring the CR if present. This behavior directly addresses the RFC specification regarding line termination and fulfils the provided constraint.",success,
1339,ngx_http_parse_request_line,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Fully Matches,"[{'C1': {'code': ""case sw_start:\n    r->request_start = p;\n\n    if (ch == CR || ch == LF) {\n        break;\n    }\n\n    if ((ch < 'A' || ch > 'Z') && ch != '_' && ch != '-') {\n        return NGX_HTTP_PARSE_INVALID_METHOD;\n    }"", 'explanation': 'This segment shows that the function examines the incoming protocol element (the request line) by checking the first character to decide if it’s a valid HTTP method token, thereby ensuring that it interprets the element as defined by the specification. It performs the required semantic check and rejects the element if it does not conform.'}}, {'A1': {'code': 'done:\n\n    b->pos = p + 1;\n\n    if (r->request_end == NULL) {\n        r->request_end = p;\n    }\n\n    r->http_version = r->http_major * 1000 + r->http_minor;\n    r->state = sw_start;\n\n    if (r->http_version == 9 && r->method != NGX_HTTP_GET) {\n        return NGX_HTTP_PARSE_INVALID_09_METHOD;\n    }\n\n    return NGX_OK;', 'explanation': 'This code finalizes the protocol element interpretation by updating request metadata, adjusting pointers, and allowing for recovery. It shows that once a usable protocol element is determined, even in cases where minor errors (like a bare LF or CR) occur, the function recovers and completes processing as allowed by the HTTP specification.'}}]","The function ngx_http_parse_request_line implements the HTTP RFC requirement by thoroughly inspecting the request line and interpreting each segment (method, URI, HTTP version, etc.) according to defined semantics. It validates each character and context (e.g., method names, spacing, URI scheme, host, port) and returns specific error codes when the element does not meet specifications. Additionally, it incorporates mechanisms to recover a usable protocol element (for example, defaulting to HTTP/0.9 under certain conditions) as permitted by the RFC. All of these checks and recovery tactics demonstrate that the function alone fulfills the conditions (C1) for interpreting a valid protocol element, as well as actions (A1) to recover or appropriately handle invalid constructs.",success,
1339,ngx_http_parse_request_line,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': ""for (p = b->pos; p < b->last; p++) { ... switch (state) { ... if (ch < 'A' || ch > 'Z') ... return NGX_HTTP_PARSE_INVALID_REQUEST; ... } }"", 'explanation': 'The function implements a defensive parsing state machine. It does not assume full adherence to the ABNF grammar and instead checks each incoming character against expected values, returning specific error codes (e.g., NGX_HTTP_PARSE_INVALID_REQUEST, NGX_HTTP_PARSE_INVALID_METHOD) when the input deviates from expected patterns. This meets the spec requirement to parse a received protocol element defensively.'}}, {'A1': {'code': ""if (p - m == 3) { if (ngx_str3_cmp(m, 'G', 'E', 'T', ' ')) { ... } } ...\n\nfor (p = b->pos; p < b->last; p++) {\n    ch = *p;\n    switch (state) {\n        // Multiple states checking method, URI, scheme, version digits, etc.\n    }\n}"", 'explanation': 'The code uses a clear state machine approach that validates each part of the request line (method, URI, schema, version, etc.) against expected character sets, ensuring that any deviation from the expected ABNF is caught immediately. This segmentation and step‐wise validation directly implements the robust, defensive parsing advised by the spec.'}}]","The provided function, ngx_http_parse_request_line, parses the HTTP request line using a detailed state machine. It defensively interprets the incoming data by iterating only within the buffer bounds, checking for conformance to accepted character ranges and patterns, and immediately returning error codes when encountering unexpected characters. This approach directly embodies the RFC's recommendation to parse protocol elements defensively without assuming perfect conformance to the ABNF grammar, thereby fully matching the specified constraints.",success,
1340,ngx_http_parse_header_line,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': ""switch (ch) {\n    case CR:\n        r->header_end = p;\n        state = sw_header_almost_done;\n        break;\n    case LF:\n        r->header_end = p;\n        goto header_done;\n    default:\n        state = sw_name;\n\n        c = lowcase[ch];\n\n        if (c) {\n            hash = ngx_hash(0, c);\n            r->lowcase_header[0] = c;\n            i = 1;\n            break;\n        }\n\n        if (ch == '_') {\n            if (allow_underscores) {\n                hash = ngx_hash(0, ch);\n                r->lowcase_header[0] = ch;\n                i = 1;\n            } else {\n                hash = 0;\n                i = 0;\n                r->invalid_header = 1;\n            }\n            break;\n        }\n\n        if (ch <= 0x20 || ch == 0x7f || ch == ':') {\n            r->header_end = p;\n            return NGX_HTTP_PARSE_INVALID_HEADER;\n        }\n\n        hash = 0;\n        i = 0;\n        r->invalid_header = 1;\n\n        break;\n}"", 'explanation': 'This segment, along with the overall state machine logic, shows that the function is carefully examining each character in the header line. It does not assume perfect input but instead checks for CR, LF, spaces, control characters, and invalid characters, demonstrating defensive parsing as required by the RFC.'}}, {'A1': {'code': ""if (ch == '\\0') {\n    r->header_end = p;\n    return NGX_HTTP_PARSE_INVALID_HEADER;\n}\n\n...\n\ncase sw_value:\n    switch (ch) {\n    case ' ':\n        r->header_end = p;\n        state = sw_space_after_value;\n        break;\n    case CR:\n        r->header_end = p;\n        state = sw_almost_done;\n        break;\n    case LF:\n        r->header_end = p;\n        goto done;\n    case '\\0':\n        r->header_end = p;\n        return NGX_HTTP_PARSE_INVALID_HEADER;\n    }"", 'explanation': ""This part of the code shows that within the header value parsing it similarly validates input by checking for unexpected characters (like '\\0') and managing whitespace appropriately. It returns error codes when invalid input is detected, fulfilling the action of rejecting nonconforming protocol elements.""}}]","The function 'ngx_http_parse_header_line' implements a defensive header parsing routine by carefully processing each part of the header line using a state machine. It checks for control characters, proper delimiters (like ':', CR, and LF), and handles invalid characters by marking the header as invalid or returning a specific error code (NGX_HTTP_PARSE_INVALID_HEADER). This directly aligns with the RFC specification that advises defensive parsing with only marginal assumptions about conformance to the expected grammar and accommodating varying buffer lengths. All the checks and error handling within the function are contained within its logic, ensuring that it alone attempts to meet the RFC's defensive parsing requirements.",success,
1340,ngx_http_parse_header_line,"Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message.",3,Fully Matches,"[{'C1': {'code': ""case '\\0':\n    r->header_end = p;\n    return NGX_HTTP_PARSE_INVALID_HEADER;\n\n// In sw_value\ncase '\\0':\n    r->header_end = p;\n    return NGX_HTTP_PARSE_INVALID_HEADER;\n\n// In sw_space_after_value\ncase '\\0':\n    r->header_end = p;\n    return NGX_HTTP_PARSE_INVALID_HEADER;\n\n// Also handling CR and LF as header terminators in sw_start, sw_space_before_value, and sw_almost_done"", 'explanation': ""The RFC requires that any field value containing CR, LF, or NUL must either be rejected or these characters replaced with SP. This function explicitly rejects a header if a NUL character ('\\0') is encountered (e.g. in state sw_space_before_value, sw_value, and sw_space_after_value). For CR and LF, the state machine treats them as indicators of the header line’s termination rather than incorporating them into the value. This design meets the RFC requirement by ensuring dangerous characters do not appear within processed field values.""}}]","The function implements a state machine for HTTP header parsing that directly checks for and rejects any occurrence of NUL characters in header values, and uses CR and LF only as header line terminators. Since the RFC permits either rejecting the message or replacing the dangerous characters with SP, this approach—rejecting in the case of NUL and delimiting on CR and LF—fully addresses the specified constraint (labeled C1) within the function body.",success,
1340,ngx_http_parse_header_line,A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.,173,Fully Matches,"[{'C1': {'code': 'case sw_almost_done:\n    switch (ch) {\n    case LF:\n        goto done;\n    case CR:\n        break;\n    default:\n        return NGX_HTTP_PARSE_INVALID_HEADER;\n    }\n\ncase sw_header_almost_done:\n    switch (ch) {\n    case LF:\n        goto header_done;\n    default:\n        return NGX_HTTP_PARSE_INVALID_HEADER;\n    }', 'explanation': 'The RFC specifies that a recipient must either treat a bare CR (a CR not immediately followed by LF) as invalid or replace it with a space. In this function, the code in the sw_almost_done and sw_header_almost_done states checks if a CR is properly followed by a LF. If it is not, the function returns NGX_HTTP_PARSE_INVALID_HEADER, thereby considering the header element invalid. This behavior meets the RFC requirement.'}}]","The function ngx_http_parse_header_line implements header parsing with explicit handling for CR and LF sequences. It ensures that if a CR is encountered without an immediate LF, the header is considered invalid (by returning an error). Although it does not perform a literal replacement of a bare CR with a space, the RFC allows either flagging the element as invalid or performing the replacement. Therefore, by choosing to mark the header invalid, the function fully meets the specified RFC constraint.",success,
1340,ngx_http_parse_header_line,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Fully Matches,"[{'C1': {'code': 'case sw_start:\n    ...\n    switch (ch) {\n    case LF:\n        r->header_end = p;\n        goto header_done;\n    ...\n    }\n\ncase sw_value:\n    switch (ch) {\n    ...\n    case LF:\n        r->header_end = p;\n        goto done;\n    ...\n    }', 'explanation': ""This segment shows that the function accepts a lone LF as a valid header line terminator (ignoring any preceding CR if present), which corresponds to the RFC's allowance for recognizing a single LF.""}}, {'A1': {'code': 'case sw_start:\n    switch (ch) {\n    case CR:\n        r->header_end = p;\n        state = sw_header_almost_done;\n        break;\n    ...\n    }\n\ncase sw_header_almost_done:\n    switch (ch) {\n    case LF:\n        goto header_done;\n    default:\n        return NGX_HTTP_PARSE_INVALID_HEADER;\n    }', 'explanation': 'This code enforces that a CR must be immediately followed by LF. If a bare CR (one not followed by LF) is encountered, the header is rejected, thus implementing the spec requirement to treat a bare CR as invalid.'}}]",The function parses HTTP header lines at the octet level and directly includes logic to handle both CR and LF as line terminators. It recognizes a single LF as terminating a header line and ensures that any CR character is valid only if immediately followed by an LF. This behavior directly implements the relevant parts of the HTTP RFC regarding line termination.,success,
1340,ngx_http_parse_header_line,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': ""/* space* before header value */\ncase sw_space_before_value:\n    switch (ch) {\n    case ' ':\n        break;\n    case CR:\n        r->header_start = p;\n        r->header_end = p;\n        state = sw_almost_done;\n        break;\n    case LF:\n        r->header_start = p;\n        r->header_end = p;\n        goto done;\n    default:\n        r->header_start = p;\n        state = sw_value;\n        break;\n    }\n\n/* header value */\ncase sw_value:\n    switch (ch) {\n    case ' ':\n        r->header_end = p;\n        state = sw_space_after_value;\n        break;\n    case CR:\n        r->header_end = p;\n        state = sw_almost_done;\n        break;\n    case LF:\n        r->header_end = p;\n        goto done;\n    case '\\0':\n        r->header_end = p;\n        return NGX_HTTP_PARSE_INVALID_HEADER;\n    }\n\n/* space* after header value */\ncase sw_space_after_value:\n    switch (ch) {\n    case ' ':\n        break;\n    case CR:\n        state = sw_almost_done;\n        break;\n    case LF:\n        goto done;\n    case '\\0':\n        r->header_end = p;\n        return NGX_HTTP_PARSE_INVALID_HEADER;\n    default:\n        state = sw_value;\n        break;\n    }"", 'explanation': 'The function clearly implements logic to skip over any leading whitespace before the header value is set (via sw_space_before_value) as well as ensuring that trailing whitespace is not included (via sw_value and sw_space_after_value). This matches the RFC requirement to exclude such whitespace prior to evaluating the field value.'}}]","By examining the code within the ngx_http_parse_header_line function, it is evident that the parser explicitly handles both leading whitespace (in the sw_space_before_value state) and trailing whitespace (in the sw_value and sw_space_after_value states) before finalizing the header value. This directly addresses the RFC specification that any whitespace allowed in HTTP messages should be excluded prior to header evaluation.",success,
1342,ngx_http_parse_complex_uri,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Fully Matches,"[{'C1': {'code': 'if (r->empty_path_in_uri) {\n    *u++ = \'/\';\n}\n\n... // In sw_usual, sw_slash, sw_dot and sw_dot_dot cases\n\ncase \'/\':\n    state = sw_slash;\n    *u++ = ch;\n    break;\n\ncase \'.\':\n    r->uri_ext = u + 1;\n    *u++ = ch;\n    break;\n\n... // Logic that handles "".."" by backing up the pointer\nu -= 4;\nfor (;;) {\n    if (u < r->uri.data) {\n        return NGX_HTTP_PARSE_INVALID_REQUEST;\n    }\n    if (*u == \'/\') {\n        u++;\n        break;\n    }\n    u--;\n}\n\n// Also, decoding of percent-encoded sequences is implemented\ncase \'%\':\n    quoted_state = state;\n    state = sw_quoted;\n    break;', 'explanation': ""The function implements URI normalization by decoding percent-encoded characters, handling merging of slashes (based on the merge_slashes flag), and resolving relative path segments ('.' and '..'). This corresponds directly to the requirement in the RFC that URIs equivalent after normalization identify the same resource and that an HTTP component may perform normalization.""}}]","The ngx_http_parse_complex_uri function contains explicit logic to normalize the HTTP URI. It decodes percent-encoded sequences, correctly processes path segments including '.', '..', and merges duplicate slashes when the merge_slashes flag is enabled. These behaviors directly address the RFC specification that two HTTP URIs equivalent after normalization are considered to identify the same resource, thereby fully meeting the provided constraint within the function itself.",success,
1343,ngx_http_parse_status_line,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Fully Matches,"[{'C1': {'code': ""case sw_space_after_status:\n    switch (ch) {\n    case ' ':\n        state = sw_status_text;\n        break;\n    case '.':                    /* IIS may send 403.1, 403.2, etc */\n        state = sw_status_text;\n        break;\n    case CR:\n        state = sw_almost_done;\n        break;\n    case LF:\n        goto done;\n    default:\n        return NGX_ERROR;\n    }\n    ....\ncase sw_status_text:\n    switch (ch) {\n    case CR:\n        state = sw_almost_done;\n        break;\n    case LF:\n        goto done;\n    }\n    ....\ncase sw_almost_done:\n    status->end = p - 1;\n    switch (ch) {\n    case LF:\n        goto done;\n    default:\n        return NGX_ERROR;\n    }"", 'explanation': 'The code directly checks for both a bare LF as a valid line terminator (in sw_space_after_status and sw_status_text), and handles CR followed by LF (using sw_almost_done), which fulfills the RFC allowance to treat a single LF as a terminator while ignoring a preceding CR.'}}, {'A1': {'code': 'case sw_almost_done:\n    status->end = p - 1;\n    switch (ch) {\n    case LF:\n        goto done;\n    default:\n        return NGX_ERROR;\n    }', 'explanation': 'This segment ensures that if a CR is encountered (indicating a possible line terminator), it must be immediately followed by an LF; otherwise, the function returns an error. This behavior meets the spec that a bare CR without an LF must render the element invalid.'}}]","The function implements the RFC’s requirements regarding line termination. It properly accepts an LF on its own in certain states and handles CR followed by LF by transitioning to the 'almost_done' state, effectively ignoring the preceding CR. Moreover, if the CR is not followed by an LF, the function returns an error, hence fully addressing the conditions stated in the RFC specification regarding line terminators.",success,
1344,ngx_http_parse_unsafe_uri,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': ""if (len == 0 || p[0] == '?') {\n    goto unsafe;\n}\n\nif (p[0] == '.' && len > 1 && p[1] == '.'\n    && (len == 2 || ngx_path_separator(p[2])))\n{\n    goto unsafe;\n}"", 'explanation': 'This segment shows the function defensively checking the URI for minimal conformance—ensuring that an empty URI, one starting with \'?\' or beginning with a potentially dangerous relative segment ("".."") triggers the unsafe path. This aligns with the requirement to parse the received protocol element defensively.'}}, {'A1': {'code': ""for ( /* void */ ; len; len--) {\n    ch = *p++;\n    if (ch == '%') {\n        quoted = 1;\n        continue;\n    }\n    if (usual[ch >> 5] & (1U << (ch & 0x1f))) {\n        continue;\n    }\n    if (ch == '?') {\n        args->len = len - 1;\n        args->data = p;\n        uri->len -= len;\n        break;\n    }\n    if (ch == '\\0') {\n        goto unsafe;\n    }\n    if (ngx_path_separator(ch) && len > 2) {\n        if (p[0] == '.' && p[1] == '.'\n            && (len == 3 || ngx_path_separator(p[2])))\n        {\n            goto unsafe;\n        }\n    }\n}\n\nif (quoted) {\n    src = uri->data;\n    dst = ngx_pnalloc(r->pool, uri->len);\n    if (dst == NULL) {\n        return NGX_ERROR;\n    }\n    uri->data = dst;\n    ngx_unescape_uri(&dst, &src, uri->len, 0);\n    uri->len = dst - uri->data;\n    // Re-validation after unescaping\n    len = uri->len;\n    p = uri->data;\n    ...\n}"", 'explanation': ""This code iterates over the URI, makes defensive checks on each character (including detecting percent-encoding and unsafe sequences like '/../'), and revalidates the unescaped URI. It addresses the action of carefully parsing the protocol element while expecting non-perfect conformance, thereby implementing a defensive parsing style.""}}]","The function implements defensive parsing per the HTTP RFC by checking for malformed elements (empty string, dangerous relative paths, embedded nulls) and by processing percent-encoded characters cautiously. The logic contained fully addresses the labeled constraints—checking the integrity of the URI and unescaping it when needed—without relying on external dependencies. Thus, within the function's own code, all critical aspects of the specification are visibly addressed.",success,
1346,ngx_http_parse_multi_header_lines,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Partially Matches,"[{'C1': {'code': ""for (start += name->len; start < end && *start == ' '; start++) { /* void */ }\n...\nif (start == end || *start++ != '=') { /* the invalid header value */ goto skip; }\n\nwhile (start < end && *start == ' ') { start++; }"", 'explanation': ""The code explicitly skips whitespace immediately after the header name and after the '=' sign, thereby removing leading whitespace before evaluating the field value. However, it does not remove or trim trailing whitespace from the field value, so it only partially meets the RFC requirement.""}}]","The RFC requires that implementations exclude any whitespace (both leading and trailing) prior to evaluating a field value. This function demonstrates logic to remove leading whitespace by using loops that skip spaces before the field value is processed. Despite addressing the leading whitespace, it does not provide a mechanism to explicitly trim trailing whitespace from the field value. Since only part of the whitespace exclusion requirement is handled within this function, the overall match is considered partial.",success,
1346,ngx_http_parse_multi_header_lines,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,[],"The RFC requires that a recipient must parse for bad whitespace (BWS) and remove it before interpreting the protocol element. In this function, there are segments where whitespace is explicitly skipped using loops (e.g., after matching the header name and after the '=' character). However, the implementation only checks for the space character (' '), and does not account for other forms of whitespace (such as tabs or other OWS characters) that the spec implies might be present. Thus, while the function does attempt to remove whitespace before processing header elements, its approach is limited and does not fully cover the removal of all types of bad whitespace as required by the RFC.",success,
1346,ngx_http_parse_multi_header_lines,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Partially Matches,"[{'C1': {'code': ""for (start += name->len; start < end && *start == ' '; start++) { /* void */ } \n...\nwhile (start < end && *start == ' ') { start++; }"", 'explanation': ""The function includes loops that skip or consume space characters after header name and after the '=' sign, which is an attempt to remove bad whitespace (BWS) as described in the RFC. However, it only checks for the space character (' ') and does not handle all forms of optional or bad whitespace as specified in the RFC.""}}, {'A1': {'code': ""while (start < end && *start == ' ') { start++; }"", 'explanation': 'This loop is used to trim leading spaces before parsing further header values, which is in line with the RFC requirement for removing BWS. Again, the implementation is limited to simple space characters.'}}]","The function attempts to address the RFC requirement regarding BWS by explicitly skipping spaces at strategic points in the header value parsing logic. These segments of code show an effort to remove extra whitespace before interpreting header elements. However, since the RFC refers to BWS (bad whitespace) in a broader sense (which might include additional white space characters like horizontal tabs) and since the function only checks for the space character, it only partially meets the constraint in isolation.",success,
1347,ngx_http_parse_set_cookie_lines,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,"[{'C1': {'code': ""for (start += name->len; start < end && *start == ' '; start++) { /* void */ }\n\nif (start == end || *start++ != '=') { continue; }\n\nwhile (start < end && *start == ' ') { start++; }"", 'explanation': ""The RFC requires that a recipient removes 'bad whitespace' before interpreting protocol elements. The code attempts this by skipping over space characters after the header name and again after the '=' sign. This logic addresses whitespace removal for spaces, but it does not account for other whitespace characters (e.g. tabs) as might be defined in the RFC, hence it only partially meets the specification.""}}]","The function inspects the header value by first advancing the pointer past the header name and then skipping over any spaces before encountering the '=' character, effectively removing leading whitespace. It does a similar stripping of spaces after the '=' sign before extracting the value. This logic clearly attempts to remove extraneous whitespace per the spec, but it is limited to space (' ') characters only, rather than all whitespace defined by HTTP (such as OWS, RWS). Therefore, while it shows an intent to implement the RFC's whitespace removal requirement, it only partially matches the complete requirements of the specification.",success,
1347,ngx_http_parse_set_cookie_lines,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Partially Matches,[],"The RFC requires that any extraneous whitespace be removed from the field value before evaluation. In this function the code attempts to remove leading whitespace in two places – first after confirming the header begins with the expected name (using the loop after 'start += name->len') and then after verifying the '=' character (using the while loop that skips spaces). However, the function does not address trailing whitespace in the cookie value (i.e. whitespace that may appear just before the ';' delimiter), which means it does not fully comply with the specification. As a result, only part of the condition is implemented within the function.",success,
1347,ngx_http_parse_set_cookie_lines,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,[],"The RFC specifies that a recipient MUST interpret a received protocol element based on the defined semantics and attempt to recover from invalid constructs. This function does show some interpretation logic by scanning through a header’s value, matching the expected cookie name, skipping whitespace, checking for an '=' separator, and extracting the value up to a semicolon. In that sense, it partially implements the act of interpreting and recovering a protocol element. However, the function lacks broader error recovery and does not account for extensions or cases where the sender’s implementation might be known to be erroneous. Since it does not fully implement all aspects of the RFC’s semantic interpretation requirements (and no specific labeled conditions or actions like C1, A1 were completely and independently implemented within this function), the overall implementation in this function is only partially matching the RFC’s expectations.",success,
1347,ngx_http_parse_set_cookie_lines,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,[],"The RFC states that the recipient MAY attempt to recover a usable protocol element from an invalid construct. This function implements some basic checking to parse a Set-Cookie header: it skips headers whose value is too short, ignores differences in letter case in the cookie name, and tolerates extra spaces before and after the cookie name and the '=' character. In effect, it tries to extract the value even if there are minor deviations (like extra spaces). However, the function does not implement broader or more robust error recovery strategies that might be expected from the full RFC guidance—it simply continues if the required pattern is not exactly met. Since only a subset of potential error recovery behaviors is directly handled in this function (and some error handling might reside elsewhere in the system), the function partially matches the spec constraints but does not by itself fully implement the recovery behavior suggested in the RFC.",success,
1347,ngx_http_parse_set_cookie_lines,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Partially Matches,"[{'A1': {'code': ""for (start += name->len; start < end && *start == ' '; start++) { /* void */ }\n\nif (start == end || *start++ != '=') {\n    /* the invalid header value */\n    continue;\n}\n\nwhile (start < end && *start == ' ') { start++; }"", 'explanation': ""The RFC specifies that any bad whitespace (BWS) present in the message must be removed before its interpretation. Here the function explicitly skips spaces (i.e. ' ') immediately following the cookie name and after the '=' separator. This directly implements the action of removing the whitespace before further processing, thus partly addressing the RFC requirement.""}}]","The function attempts to comply with the HTTP RFC requirement concerning removal of bad whitespace by skipping over literal space characters at specific points in the Set-Cookie header value. However, it only considers space characters and does so at limited locations (after the cookie name and after the '='). It does not comprehensively handle all forms or locations of BWS as might be required by the full specification. Therefore, while some aspects are addressed, it only partially matches the spec constraints.",success,
1347,ngx_http_parse_set_cookie_lines,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,[],"The provided function demonstrates some aspects of defensive parsing by carefully using pointer arithmetic and boundary comparisons – for example, it checks that pointers remain within the bounds of the header value (using 'start < end') and does not assume that the header is perfectly formatted. This reflects an attempt to parse the cookie header in a defensive manner, in line with the idea that a recipient SHOULD not fully trust the input conformance to a strict ABNF grammar. However, the function does not fully address the overall spectrum of the RFC requirements: it only performs basic checks (e.g., confirming the presence of an '=' character and skipping spaces) and does not include explicit handling of a “reasonable buffer size” or robust validation of the complete ABNF grammar. Moreover, more nuanced aspects of defensive parsing in a full HTTP implementation (e.g., detailed error handling or limitations based on deployment context) are absent. Therefore, while the function shows a limited defensive approach, it only partially implements the full spirit of the specification as outlined in the RFC.",success,
1349,ngx_http_split_args,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided code function, ngx_http_split_args, simply splits a URI at the '?' character into the path and query components without any validation of the URI against the ABNF rules or any mechanism to prevent generating protocol elements that do not match the prescribed grammar. Given the RFC's requirement that a sender MUST NOT generate protocol elements that do not match the grammar, there is no logic in this function that attempts to ensure compliance with that requirement. Therefore, no labeled condition or action (such as a hypothetical C1 or A1 tied to grammar validation) is fully implemented in this function.",success,
1349,ngx_http_split_args,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function merely splits a URI into its path and arguments based on the presence of a '?' character. It does not implement any logic to ensure that protocol elements or syntax alternatives are only generated by participants in the appropriate roles, as required by the HTTP RFC specification (e.g., preventing a sender from generating elements reserved for another role). Since none of the spec constraints (like C1, A1, etc.) are addressed within this function body, it does not visibly implement the specified RFC requirement.",success,
1350,ngx_http_parse_chunked,A recipient MUST parse an HTTP message as a sequence of octets in an encoding that is a superset of US-ASCII [USASCII].,294,Fully Matches,"[{'C1': {'code': ""for (pos = b->pos; pos < b->last; pos++) {\n    ch = *pos;\n    ...\n}\n\nif (ch >= '0' && ch <= '9') { ... }\n\nc = (u_char) (ch | 0x20);\nif (c >= 'a' && c <= 'f') { ... }"", 'explanation': 'The code iterates over the buffer byte‐by‐byte using a pointer (u_char *) and performs comparisons on the individual octets. This demonstrates that it processes the HTTP message as a sequence of raw bytes (octets) and performs lower‐case conversion where needed, avoiding unsafe string‐based parsing. This behavior directly addresses the RFC requirement to parse messages from an encoding that is a superset of US-ASCII.'}}]","The function 'ngx_http_parse_chunked' is designed to parse chunked transfer encoding by iterating over the input buffer as a sequence of octets. It uses low-level byte operations (comparing against '0'-'9', handling CR and LF, and applying bitwise operations) which confirms that it does not rely on any high-level string parsing that might introduce vulnerabilities. Therefore, it fully implements the relevant part of the HTTP RFC that mandates processing the message as a sequence of octets in an encoding that is a superset of US-ASCII.",success,
1350,ngx_http_parse_chunked,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Fully Matches,"[{'C1': {'code': ""case sw_chunk_start:\n    if (ch >= '0' && ch <= '9') {\n        state = sw_chunk_size;\n        ctx->size = ch - '0';\n        break;\n    }\n\n    c = (u_char) (ch | 0x20);\n\n    if (c >= 'a' && c <= 'f') {\n        state = sw_chunk_size;\n        ctx->size = c - 'a' + 10;\n        break;\n    }\n    goto invalid;"", 'explanation': 'This section (and similar blocks throughout the state machine) demonstrates that the function interprets the received protocol element (chunked transfer encoding) strictly according to the RFC: it reads the hex digits that specify the chunk size and properly transitions its internal state based on the RFC semantics.'}}, {'A1': {'code': 'case sw_chunk_extension:\n    switch (ch) {\n    case CR:\n        state = sw_chunk_extension_almost_done;\n        break;\n    case LF:\n        state = sw_chunk_data;\n    }\n    break;\n\n// ...\ncase sw_after_data:\n    switch (ch) {\n    case CR:\n        state = sw_after_data_almost_done;\n        break;\n    case LF:\n        state = sw_chunk_start;\n        break;\n    default:\n        goto invalid;\n    }\n    break;', 'explanation': 'This code addresses the action of attempting to recover or interpret the protocol element (including handling extensions and trailer sections) even when the formatting may vary, as allowed by the RFC (for example, when to accept a lone LF or CRLF in various states).'}}]","The function implements a detailed state machine that parses HTTP chunked transfer encoding. It rigorously checks each byte against expected values (hex digits, CR/LF, and optional chunk extensions/trailer portions) in accordance with the RFC. By examining and processing the various states (sw_chunk_start, sw_chunk_size, sw_chunk_extension, sw_after_data, among others), the function visibly addresses the core requirements stated in the RFC specification: a recipient MUST interpret a received protocol element according to its defined semantics, including handling potential extensions and minor irregularities. Thus, within its own body and independently of external dependencies, the function fully matches the stated spec constraints.",success,
1350,ngx_http_parse_chunked,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Fully Matches,"[{'C1': {'code': 'case sw_chunk_extension_almost_done:\n    if (ch == LF) {\n        state = sw_chunk_data;\n        break;\n    }\n    goto invalid;\n\ncase sw_after_data_almost_done:\n    if (ch == LF) {\n        state = sw_chunk_start;\n        break;\n    }\n    goto invalid;\n\ncase sw_last_chunk_extension_almost_done:\n    if (ch == LF) {\n        if (keep_trailers) {\n            goto done;\n        }\n        state = sw_trailer;\n        break;\n    }\n    goto invalid;\n\ncase sw_trailer_almost_done:\n    if (ch == LF) {\n        goto done;\n    }\n    goto invalid;\n\ncase sw_trailer_header_almost_done:\n    if (ch == LF) {\n        state = sw_trailer;\n        break;\n    }\n    goto invalid;', 'explanation': ""The function verifies that whenever a CR character is encountered, it is immediately followed by an LF character. For example, in the 'sw_chunk_extension_almost_done' and 'sw_after_data_almost_done' states (along with similar checks in trailer-related states), if the character following CR is not LF, the function jumps to the 'invalid' label. This enforces the RFC requirement that a sender MUST NOT generate a bare CR.""}}]","The provided code function for parsing chunked HTTP messages includes several state transitions that specifically check for CR characters and require that they be immediately followed by LF (e.g., transitions in sw_chunk_extension_almost_done, sw_after_data_almost_done, sw_last_chunk_extension_almost_done, and trailer-related states). This clearly shows that the function enforces the RFC constraint against bare CR characters by marking the message as invalid if a CR is not properly paired with an LF. Therefore, within its own logic, the function fully implements the required constraint.",success,
1350,ngx_http_parse_chunked,"Therefore, recipients MUST anticipate potentially large hexadecimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer representation.",305,Partially Matches,"[{'C1': {'code': 'if (ctx->size > NGX_MAX_OFF_T_VALUE / 16) {\n    goto invalid;\n}\n\n... \n\nif (ctx->size > NGX_MAX_OFF_T_VALUE - 5) {\n    goto invalid;\n}', 'explanation': 'The code explicitly checks the current chunk size during hexadecimal conversion to ensure it does not exceed NGX_MAX_OFF_T_VALUE. These checks prevent integer overflow errors when accumulating very large hexadecimal values, directly addressing the requirement to prevent parsing errors due to integer conversion overflows.'}}]","The function implements logic for parsing HTTP chunked transfer encoding and includes checks that prevent integer conversion overflows when processing large hexadecimal numerals, fulfilling the primary part of the RFC requirement. However, the RFC also states that the presence of parameters (chunk extensions) should be treated as an error, yet the function instead enters extension parsing states instead of flagging an error immediately. As a consequence, while the overflow/precision loss aspect is addressed (C1), not all aspects of the spec are singularly enforced within this function. Therefore, the overall outcome is 'Partially Matches'.",success,
1350,ngx_http_parse_chunked,A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance.,187,Partially Matches,"[{'C1': {'code': ""case sw_chunk_start:\n    if (ch >= '0' && ch <= '9') {\n        state = sw_chunk_size;\n        ctx->size = ch - '0';\n        break;\n    }\n    c = (u_char) (ch | 0x20);\n    if (c >= 'a' && c <= 'f') {\n        state = sw_chunk_size;\n        ctx->size = c - 'a' + 10;\n        break;\n    }\n    goto invalid;\n\n... (logic for sw_chunk_size, sw_chunk_extension, sw_chunk_data, and trailer handling)"", 'explanation': 'The function implements a state machine that parses chunks by reading the chunk size in hexadecimal, processing optional chunk extensions, and handling trailing headers. This parsing logic directly addresses the RFC requirement that a recipient MUST be able to parse the chunked transfer coding when the content size is not known in advance.'}}]","The provided function is designed to parse HTTP chunked transfer encoding data as per the RFC. It clearly implements the receipt and framing of a message with unknown content length using a detailed state machine (with states such as sw_chunk_start, sw_chunk_size, sw_chunk_data, etc.). This addresses the recipient-side requirement (labeled here as C1). However, other aspects of the RFC (for example, sender-related restrictions such as ensuring that chunked encoding is applied only once or handling non‐chunked transfer codings) are not implemented within this function, meaning that while key recipient functionality is present, it only partially covers the broader RFC specification.",success,
1350,ngx_http_parse_chunked,"Since there is no predefined limit to the length of content, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer conversion (Section 17.5).",261,Fully Matches,"[{'C1': {'code': 'if (ctx->size > NGX_MAX_OFF_T_VALUE / 16) {\n    goto invalid;\n}\n...\nif (ctx->size > NGX_MAX_OFF_T_VALUE - 5) {\n    goto invalid;\n}', 'explanation': 'The RFC requires that implementations anticipate arbitrarily large numeral values and prevent parsing errors due to integer conversion overflows or precision loss. In the sw_chunk_size state, the code multiplies the accumulator by 16 and adds a new digit, but only after checking that the current value is within a safe range (ctx->size <= NGX_MAX_OFF_T_VALUE / 16). Similarly, before finalizing the state, it checks ctx->size against NGX_MAX_OFF_T_VALUE - 5. These defensive checks effectively implement the RFC requirement by ensuring that no overflow occurs in the conversion process.'}}]","The provided function (ngx_http_parse_chunked) parses HTTP chunked transfer encoding and includes explicit safeguards to prevent integer overflow during the conversion of chunk size values. Although chunk sizes are in hexadecimal rather than decimal, the same principle applies: large numeral values are anticipated and the conversion is guarded against overflow. The checks using NGX_MAX_OFF_T_VALUE ensure that numerical limits are not exceeded, thereby fully satisfying the RFC requirement.",success,
1350,ngx_http_parse_chunked,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Fully Matches,"[{'C1': {'code': 'case LF:\n    state = sw_chunk_data;\n\nand\n\ncase LF:\n    state = sw_chunk_start;\n\n(and similar LF cases in other states)', 'explanation': 'The state machine explicitly accepts a lone LF as a valid line terminator in several transitions (for example in sw_chunk_extension and sw_after_data), which matches the RFC allowance to recognize a single LF and ignore any preceding CR.'}}, {'A1': {'code': 'case sw_chunk_extension_almost_done:\n    if (ch == LF) {\n        state = sw_chunk_data;\n        break;\n    }\n    goto invalid;\n\n(and similar CR-checks in sw_after_data_almost_done and sw_trailer_almost_done)', 'explanation': 'The parser requires that any CR be immediately followed by LF. If not, the state machine transitions to an invalid state. This implements the RFC requirement that a bare CR (CR not immediately followed by LF) must be considered invalid.'}}]","The function implements a state machine for parsing HTTP chunked bodies that clearly distinguishes between CRLF and lone LF line terminations. It accepts a bare LF as a valid terminator in multiple states and mandates that any CR must be immediately followed by LF, marking otherwise as invalid. Thus, the function’s logic directly and visibly addresses the RFC specification regarding line terminators.",success,
1350,ngx_http_parse_chunked,"Since there is no predefined limit to the length of content, recipients MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows.",285,Partially Matches,"[{'C1': {'code': 'if (ctx->size > NGX_MAX_OFF_T_VALUE / 16) {\n    goto invalid;\n}\n...\nif (ctx->size > NGX_MAX_OFF_T_VALUE - 5) {\n    goto invalid;\n}', 'explanation': 'The function performs checks during numeric conversion (while processing hexadecimal digits) to avoid integer overflow. This mirrors the requirement to prevent parsing errors from overly large numerals. However, the RFC specifically mentions large decimal numerals, whereas the function is converting hexadecimal numbers. Thus, the overflow prevention is implemented, but it does not fully address the decimal numeral aspect of the spec.'}}]","The provided function includes logic to check for potential overflow by comparing the accumulated size against NGX_MAX_OFF_T_VALUE which helps prevent integer conversion errors. This partially meets the RFC requirement (labeled C1) concerning large numeric values. However, since the RFC specifies handling large decimal numerals and the function computes chunk sizes in hexadecimal form, the implementation does not fully match the spec's intent within the confines of this function alone.",success,
1350,ngx_http_parse_chunked,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': ""for (pos = b->pos; pos < b->last; pos++) {\n    ch = *pos;\n    switch (state) {\n        case sw_chunk_start:\n            if (ch >= '0' && ch <= '9') { ... } else { goto invalid; }\n            break;\n        // Multiple cases (sw_chunk_size, sw_chunk_extension, etc.) with explicit checks\n        default:\n            goto invalid;\n    }\n}\n\ninvalid:\n    return NGX_ERROR;"", 'explanation': 'The code implements a state machine that defensively parses each byte of the protocol element. It validates expected tokens and immediately aborts if the input does not match expected values, which directly addresses the requirement of not fully relying on conformance to the ABNF grammar.'}}, {'A1': {'code': 'if (ctx->size > NGX_MAX_OFF_T_VALUE / 16) {\n    goto invalid;\n}\n...\nif (ctx->size > NGX_MAX_OFF_T_VALUE - 5) {\n    goto invalid;\n}', 'explanation': 'These checks prevent processing of excessively large chunk sizes by ensuring that the size stays within a reasonable limit, which meets the specification’s emphasis on handling inputs that fit within a reasonable buffer size.'}}]","The function ngx_http_parse_chunked uses a robust state machine to defensively parse incoming chunked HTTP data. It carefully checks each byte against expected tokens and transitions between well-defined states, aborting on unexpected input (thereby not requiring full conformance to an ABNF grammar). Additionally, it includes explicit checks to ensure that the parsed chunk size does not exceed bounds defined by NGX_MAX_OFF_T_VALUE. This directly implements the RFC guideline requiring defensive parsing and input size validation within the function itself.",success,
1350,ngx_http_parse_chunked,A recipient MUST be able to parse and decode the chunked transfer coding.,204,Fully Matches,"[{'C1': {'code': ""case sw_chunk_start:\n    if (ch >= '0' && ch <= '9') {\n        state = sw_chunk_size;\n        ctx->size = ch - '0';\n        break;\n    }\n\n    c = (u_char) (ch | 0x20);\n\n    if (c >= 'a' && c <= 'f') {\n        state = sw_chunk_size;\n        ctx->size = c - 'a' + 10;\n        break;\n    }\n\ncase sw_chunk_size:\n    if (ctx->size > NGX_MAX_OFF_T_VALUE / 16) {\n        goto invalid;\n    }\n\n    if (ch >= '0' && ch <= '9') {\n        ctx->size = ctx->size * 16 + (ch - '0');\n        break;\n    }\n\n    c = (u_char) (ch | 0x20);\n\n    if (c >= 'a' && c <= 'f') {\n        ctx->size = ctx->size * 16 + (c - 'a' + 10);\n        break;\n    }"", 'explanation': ""The code reads the chunk-size from the input by checking characters '0'-'9' and 'a'-'f' and converts them from hexadecimal to an integer. This implements the requirement that the chunk-size field is a string of hex digits.""}}, {'C2': {'code': ""if (ctx->size == 0) {\n    switch (ch) {\n    case CR:\n        state = sw_last_chunk_extension_almost_done;\n        break;\n    case LF:\n        if (keep_trailers) {\n            goto done;\n        }\n        state = sw_trailer;\n        break;\n    case ';':\n    case ' ':\n    case '\\t':\n        state = sw_last_chunk_extension;\n        break;\n    default:\n        goto invalid;\n    }\n\n    break;\n}\n\n...\n\ncase sw_trailer:\n    switch (ch) {\n    case CR:\n        state = sw_trailer_almost_done;\n        break;\n    case LF:\n        goto done;\n    default:\n        state = sw_trailer_header;\n    }\n    break;"", 'explanation': 'When a chunk-size of 0 is encountered, the function enters logic that handles the terminating conditions and the optional trailer section. This conforms to the spec requirement for ending the chunked transfer coding with a chunk of size zero followed by optional trailers and an empty line.'}}, {'A1': {'code': 'if (ctx->size > NGX_MAX_OFF_T_VALUE / 16) {\n    goto invalid;\n}\n\n...\n\nif (ctx->size > NGX_MAX_OFF_T_VALUE - 5) {\n    goto invalid;\n}', 'explanation': 'The function checks for potential integer overflows during the hexadecimal conversion process, ensuring that very large chunk sizes do not cause parsing errors or precision loss in the conversion. This meets the requirement to anticipate large hexadecimal numerals.'}}]","The function implements a state machine to parse the chunked transfer coding as defined by the RFC. It converts the hex-encoded chunk-size (addressing C1), detects the termination using a zero chunk-size and processes subsequent trailer headers (addressing C2), and includes explicit checks to prevent overflows during integer conversion (addressing A1). Thus, the function itself visibly implements all of the key requirements of the RFC specification without relying on external dependencies.",success,
1426,ngx_http_variable_unknown_header,"A recipient MAY combine multiple field lines within a field section that have the same field name into one field line, without changing the semantics of the message, by appending each subsequent field line value to the initial field line value in order, separated by a comma ("","") and optional whitespace (OWS, defined in Section 5.6.3).",231,Fully Matches,"[{'C1': {'code': 'for (i = 0; /* void */ ; i++) { ... if (var->data[n + prefix] != ch) { break; } } ... *ph = &header[i]; ph = &header[i].next;', 'explanation': ""This loop iterates over all header entries, checks for matching field names (ignoring case and substituting '-' with '_'), and chains together all matching header lines, thereby addressing the requirement to consider multiple field lines with the same name.""}}, {'A1': {'code': ""len += header[i].value.len + 2; ... if (h->next == NULL) { break; } *p++ = ','; *p++ = ' ';"", 'explanation': 'When more than one matching header is found, the code calculates the total length by adding 2 for each separator and concatenates the values with a comma and space. This implements the action of appending subsequent header field values together separated by "", "" in the order received.'}}]","The function inspects the list of header entries, identifies all that match the provided field name (after accounting for case insensitivity and '-' to '_' mapping), and, if multiple matches are found, concatenates their values in the order they appear using a comma followed by a space as a separator. This behavior meets the RFC requirement that allows combining multiple field lines without changing semantics and preserves their order. The core logic for both identifying relevant headers (C1) and concatenating them with the required separator (A1) is implemented within this function.",success,
1428,ngx_http_variable_request_line,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Partially Matches,"[{'C1': {'code': 'for (p = s; p < r->header_in->last; p++) {\n    if (*p == CR || *p == LF) {\n        break;\n    }\n}', 'explanation': ""This loop stops scanning on either CR or LF. By doing so, it accepts a bare LF as a line terminator, which is in line with the spec's allowance. However, it does not implement logic to ignore a preceding CR or to replace a bare CR with SP, which are also required by the specification in some scenarios.""}}]","The function extracts the request line by scanning until it encounters either a CR or LF. This approach addresses the part of the RFC that states a recipient may recognize a single LF as a line terminator. However, it does not handle the cases where a CR should be ignored if it immediately precedes an LF, nor does it replace a bare CR with a SP or mark it as invalid. Thus, while some aspects of the spec constraints are visibly addressed, not all are fully implemented within this function.",success,
1461,ngx_http_variable_sent_last_modified,"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.",52,Fully Matches,"[{'C1': {'code': 'if (r->headers_out.last_modified) {\n    v->len = r->headers_out.last_modified->value.len;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n    v->data = r->headers_out.last_modified->value.data;\n    return NGX_OK;\n}\n\nif (r->headers_out.last_modified_time >= 0) {\n    p = ngx_pnalloc(r->pool, sizeof(""Mon, 28 Sep 1970 06:00:00 GMT"") - 1);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    v->len = ngx_http_time(p, r->headers_out.last_modified_time) - p;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n    v->data = p;\n\n    return NGX_OK;\n}', 'explanation': 'This segment checks if a valid last modification date is available either via an existing header (last_modified) or as a timestamp (last_modified_time), which satisfies the condition of having a determinable modification date.'}}, {'A1': {'code': 'v->len = ...;\nv->valid = 1;\nv->no_cacheable = 0;\nv->not_found = 0;\nv->data = ...;\nreturn NGX_OK;', 'explanation': 'Once a valid last modification time is determined, the function sets the appropriate fields in the output variable so that the Last-Modified header is effectively sent as required.'}}]","The function inspects if the last modification date is determinable for the selected representation by checking existing header data or computing it from a timestamp. It then assigns this information to the output variable, thereby ensuring that a Last-Modified header is sent when applicable. This directly implements the RFC requirement that an origin server should send Last-Modified when a last modification date can be reasonably and consistently determined.",success,
1462,ngx_http_variable_sent_connection,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'C1': {'code': '    } else if (r->keepalive) {\n        len = sizeof(""keep-alive"") - 1;\n        p = ""keep-alive"";', 'explanation': ""This segment directly checks if the request has a persistent connection (via r->keepalive) and sets the response header to 'keep-alive', thereby supporting the RFC requirement that HTTP implementations SHOULD support persistent connections.""}}]","The function examines the connection state by checking if the request is a persistent connection (r->keepalive). In that case, it explicitly sets the header to 'keep-alive', which satisfies the persistent connection support required by the spec. Although it also handles other conditions (like 'upgrade' for switching protocols and 'close' otherwise), the relevant logic for persistent connections fully resides within this function's implementation.",success,
1471,ngx_http_variable_request_length,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided code function, ngx_http_variable_request_length, is solely focused on formatting and returning the request length as a string. It does not contain any logic addressing the handling of Content-Location or ensuring that such context information is not used to alter the request semantics as required by the RFC. There is no reference or handling of any constraint related to the Content-Location header within the function, so no spec labeled condition (e.g., C1) or action (e.g., A1) is implemented in this code.",success,
1562,ngx_http_upstream_init_request,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'A1': {'code': '#if (NGX_HTTP_CACHE)\n    if (u->conf->cache) {\n        ngx_int_t  rc;\n\n        rc = ngx_http_upstream_cache(r, u);\n\n        if (rc == NGX_BUSY) {\n            r->write_event_handler = ngx_http_upstream_init_request;\n            return;\n        }\n\n        r->write_event_handler = ngx_http_request_empty_handler;\n\n        if (rc == NGX_ERROR) {\n            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return;\n        }\n\n        if (rc == NGX_OK) {\n            rc = ngx_http_upstream_cache_send(r, u);\n\n            if (rc == NGX_DONE) {\n                return;\n            }\n\n            if (rc == NGX_HTTP_UPSTREAM_INVALID_HEADER) {\n                rc = NGX_DECLINED;\n                r->cached = 0;\n                u->buffer.start = NULL;\n                u->cache_status = NGX_HTTP_CACHE_MISS;\n                u->request_sent = 1;\n            }\n        }\n\n        if (rc != NGX_DECLINED) {\n            ngx_http_finalize_request(r, rc);\n            return;\n        }\n    }\n#endif', 'explanation': ""This code block implements caching functionality by checking if a cache is configured (u->conf->cache) and then invoking caching routines (ngx_http_upstream_cache and ngx_http_upstream_cache_send), which aligns with the spec's allowance for employing a cache. However, it does not check or enforce the condition that a cache cannot be used while acting as a tunnel.""}}]","The RFC states that any client or server MAY employ a cache, which is reflected in the function by the conditional caching logic. However, according to the RFC, a cache cannot be used while acting as a tunnel, and this function does not include any logic to check if the request is operating as a tunnel, resulting in only a partial match to the full specification.",success,
1567,ngx_http_upstream_check_broken_connection,"A client, server, or proxy MAY close the transport connection at any time.",316,Fully Matches,"[{'C1': {'code': 'if (c->error) {\n    ...\n    if (!u->cacheable) {\n        ngx_http_upstream_finalize_request(r, u, NGX_HTTP_CLIENT_CLOSED_REQUEST);\n    }\n    return;\n}\n\n/* Plus similar checks for kqueue, epoll, and QUIC events */', 'explanation': 'This segment (and similar blocks in the function) checks for error conditions on the connection (e.g. c->error, ev->pending_eof) that indicate that the client (or peer) has closed the connection, as allowed by the RFC. It directly implements the condition that the client, server, or proxy may close the transport connection at any time.'}}, {'A1': {'code': 'ngx_http_upstream_finalize_request(r, u, NGX_HTTP_CLIENT_CLOSED_REQUEST);', 'explanation': 'This action finalizes the request when a broken or prematurely closed connection is detected, ensuring that the upstream is appropriately closed in response to the closure of the transport connection.'}}]","The function 'ngx_http_upstream_check_broken_connection' actively monitors the connection for error signals (using various event flags and recv() checks) that indicate the transport connection has been closed. When such an event is detected (whether via a direct error flag, kqueue, epoll, or other mechanisms), it finalizes the request using a specific error code (NGX_HTTP_CLIENT_CLOSED_REQUEST). This behavior fully addresses the RFC specification that a client, server, or proxy MAY close the transport connection at any time by promptly handling and cleaning up the connection upon detection of such closure.",success,
1567,ngx_http_upstream_check_broken_connection,"Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.",315,Fully Matches,"[{'C1': {'code': 'if (c->error) { ... } and the subsequent checks for pending_eof in kqueue/epoll as well as the recv() call with MSG_PEEK', 'explanation': 'The function continually monitors the connection state by checking for error flags, pending EOF conditions, and any abnormal behavior detected through system-specific event mechanisms (kqueue, epoll, recv with MSG_PEEK). This directly implements the monitoring requirement of the RFC.'}}, {'A1': {'code': 'ngx_http_upstream_finalize_request(r, u, NGX_HTTP_CLIENT_CLOSED_REQUEST);', 'explanation': 'Upon detecting that a client has closed its connection (or if an error is detected), the code responds appropriately by finalizing the upstream request, thereby closing the connection and enabling resource reclamation, as required by the spec.'}}]","The function explicitly checks for connection closure signals using multiple event-driven approaches (error flag checks, kqueue and epoll notifications, and recv() with MSG_PEEK) and, on detecting a closure, it immediately finalizes the request. This addresses both the condition (C1: continuous monitoring for closure signals) and the action (A1: responding to closure by gracefully finalizing the connection) specified in the RFC, thereby fully matching the spec constraints within the function body.",success,
1569,ngx_http_upstream_reinit,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The provided function, ngx_http_upstream_reinit, reinitializes header and trailer list structures along with various buffering parameters for the upstream request. However, it does not include any logic that addresses the RFC requirement regarding the merging of trailer fields into the header section. There is no check to ensure that the recipient understands the trailer field definition or that it explicitly permits safe merging. As a result, the code does not visibly implement any of the spec constraints (e.g., C1, A1) related to trailer field merging.",success,
1573,ngx_http_upstream_read_request_handler,"A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.",310,Partially Matches,"[{'C1': {'code': 'if (c->read->timedout) {\n    c->timedout = 1;\n    ngx_http_upstream_finalize_request(r, u, NGX_HTTP_REQUEST_TIME_OUT);\n    return;\n}', 'explanation': ""This code block checks if the connection's read event has timed out. In the case of a timeout (a common condition for an incomplete request), it finalizes the request by sending an error response with the timeout error code prior to returning, thereby addressing the scenario described in the spec. However, the spec also mentions the possibility of a canceled request, which is not explicitly handled here.""}}]","The function inspects the connection for a read timeout event and, upon detecting one, it marks the connection as timed out and finalizes the upstream request with an appropriate timeout error response. This directly implements the part of the specification dealing with incomplete request messages due to a triggered timeout exception. However, since it does not handle other causes of incomplete request messages (such as canceled requests), it only partially matches the full spectrum of the spec requirements.",success,
1574,ngx_http_upstream_process_header,"Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.",315,Partially Matches,"[{'C1': {'code': 'if (n == 0) {\n    ngx_log_error(NGX_LOG_ERR, c->log, 0,\n                  ""upstream prematurely closed connection"");\n}', 'explanation': 'This segment checks the result of the recv() call. When n == 0, it indicates that the upstream closed the connection. This shows that the function is monitoring for a closure signal. However, it does not explicitly perform a graceful close in response, but rather logs the error and moves to error handling which only partially aligns with the RFC requirement.'}}]","The RFC requires implementations to constantly monitor for a received closure signal and respond appropriately (typically with a graceful close to reclaim resources). In this function, monitoring is performed through the continuous loop that reads from the connection and checks for a closure (n == 0). While this satisfies the monitoring part of the specification (labeled as C1), the response is handled by logging an error and calling error routines rather than issuing a graceful close. Therefore, the function only partially matches the RFC requirement.",success,
1574,ngx_http_upstream_process_header,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The provided function strictly handles the process of reading and processing header data from an upstream connection. Although it does allocate separate memory for headers (using ngx_list_init for both headers and trailers), there is no logic that handles the merging of trailer fields into the header section, nor any explicit checks to ensure that such merging is safe and permitted per the RFC requirement. Thus, the function does not implement or address the spec condition regarding merging trailer fields into header sections.",success,
1574,ngx_http_upstream_process_header,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (u->buffer.last == u->buffer.end) {\n    ngx_log_error(NGX_LOG_ERR, c->log, 0,\n                  ""upstream sent too big header"");\n\n    ngx_http_upstream_next(r, u,\n                           NGX_HTTP_UPSTREAM_FT_INVALID_HEADER);\n    return;\n}', 'explanation': 'This segment checks if the header data received exceeds the allocated buffer size (u->conf->buffer_size), thus implementing a defensive mechanism against oversized protocol elements.'}}, {'A1': {'code': 'if (c->read->timedout) {\n    ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_TIMEOUT);\n    return;\n}\n\nif (n == NGX_ERROR || n == 0) {\n    ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_ERROR);\n    return;\n}', 'explanation': 'These code segments handle error conditions (such as timeouts and connection errors) in a way that prevents further processing of potentially invalid data, reflecting a defensive approach.'}}]","The function implements defensive parsing by allocating a fixed buffer size for the upstream header and checking that the header does not exceed this buffer. It also handles error conditions such as timeouts and connection errors, which are in line with defensive programming practices outlined in the HTTP RFC specification. However, the actual parsing of the header content—particularly adherence to its ABNF grammar—is delegated to u->process_header, meaning the function itself only partially addresses all aspects of the spec constraints.",success,
1575,ngx_http_upstream_test_next,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The RFC specifies that a cache may be used by any client or server, except when acting as a tunnel. While the function_body includes logic for handling caching (within the NGX_HTTP_CACHE blocks) by reusing cached data under certain conditions, it contains no logic that detects or prevents the use of the cache when the subsystem is acting as a tunnel. In other words, there is no explicit check to ensure that caching is not used during a tunnel operation. Since the function does not visibly implement the condition that a cache cannot be used while acting as a tunnel, it does not fully meet the spec constraint.",success,
1577,ngx_http_upstream_intercept_errors,The server generating a 401 response MUST send a WWW-Authenticate header field (Section 11.6.1) containing at least one challenge applicable to the target resource.,162,Fully Matches,"[{'C1': {'code': 'if (status == NGX_HTTP_UNAUTHORIZED\n                && u->headers_in.www_authenticate)\n            {\n                h = u->headers_in.www_authenticate;\n                ph = &r->headers_out.www_authenticate;\n\n                while (h) {\n                    ho = ngx_list_push(&r->headers_out.headers);\n\n                    if (ho == NULL) {\n                        ngx_http_upstream_finalize_request(r, u,\n                                               NGX_HTTP_INTERNAL_SERVER_ERROR);\n                        return NGX_OK;\n                    }\n\n                    *ho = *h;\n                    ho->next = NULL;\n\n                    *ph = ho;\n                    ph = &ho->next;\n\n                    h = h->next;\n                }\n            }', 'explanation': 'This segment verifies if the returned status is 401 (Unauthorized) and then copies the WWW-Authenticate header(s) from the upstream input into the outgoing response. This directly implements the spec requirement that a 401 response MUST include a WWW-Authenticate header field with at least one applicable challenge.'}}]","The function explicitly checks whether the response status is 401 and, if so and a WWW-Authenticate header exists from the upstream, it appends the corresponding header(s) to the client response. This directly satisfies the HTTP RFC requirement that a 401 response must include a WWW-Authenticate header containing the necessary challenge, thereby fully matching the specification constraint.",success,
1577,ngx_http_upstream_intercept_errors,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'A1': {'code': '#if (NGX_HTTP_CACHE)\n            if (r->cache) {\n\n                if (u->headers_in.no_cache || u->headers_in.expired) {\n                    u->cacheable = 0;\n                }\n\n                if (u->cacheable) {\n                    time_t  valid;\n\n                    valid = r->cache->valid_sec;\n\n                    if (valid == 0) {\n                        valid = ngx_http_file_cache_valid(u->conf->cache_valid, status);\n                        if (valid) {\n                            r->cache->valid_sec = ngx_time() + valid;\n                        }\n                    }\n\n                    if (valid) {\n                        r->cache->error = status;\n                    }\n                }\n\n                ngx_http_file_cache_free(r->cache, u->pipe->temp_file);\n            }\n#endif', 'explanation': 'This code segment implements caching logic during error interception by checking if a cache exists and managing cacheable status and cache error state. It corresponds to the RFC’s permission for clients or servers to employ caches.'}}]","The RFC specification states that any client or server MAY employ a cache; however, it also stipulates that a cache cannot be used while acting as a tunnel. The provided function includes logic handling a cache when processing error responses (as shown by the caching-related code under the NGX_HTTP_CACHE block), which means it does address the use of a cache. However, there is no check or condition that prevents the use of the cache when the system is operating as a tunnel. Since that crucial portion of the specification isn’t implemented within the function itself, the function only partially matches the RFC specifications.",success,
1577,ngx_http_upstream_intercept_errors,A server generating a 401 (Unauthorized) response MUST send a WWW-Authenticate header field containing at least one challenge.,92,Fully Matches,"[{'C1': {'code': 'if (status == NGX_HTTP_UNAUTHORIZED && u->headers_in.www_authenticate)\n{\n    h = u->headers_in.www_authenticate;\n    ph = &r->headers_out.www_authenticate;\n\n    while (h) {\n        ho = ngx_list_push(&r->headers_out.headers);\n\n        if (ho == NULL) {\n            ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return NGX_OK;\n        }\n\n        *ho = *h;\n        ho->next = NULL;\n\n        *ph = ho;\n        ph = &ho->next;\n\n        h = h->next;\n    }\n}', 'explanation': ""This code block checks if the response status is 401 (Unauthorized) and if a WWW-Authenticate header exists in the upstream response. It then iterates over the linked list of challenges and copies each one into the response's output headers. This behavior meets the RFC specification that a 401 response MUST include at least one WWW-Authenticate challenge.""}}]","The function directly handles the 401 Unauthorized case by verifying the presence of a WWW-Authenticate header in the upstream response and copying it to the outgoing response headers. This implementation ensures that when a 401 error is generated, there is at least one authentication challenge included, thereby fully meeting the specified RFC requirement.",success,
1577,ngx_http_upstream_intercept_errors,A server MAY generate a WWW-Authenticate header field in other response messages to indicate that supplying credentials (or different credentials) might affect the response.,93,Fully Matches,"[{'C1': {'code': 'if (status == NGX_HTTP_UNAUTHORIZED && u->headers_in.www_authenticate)\n{\n    h = u->headers_in.www_authenticate;\n    ph = &r->headers_out.www_authenticate;\n\n    while (h) {\n        ho = ngx_list_push(&r->headers_out.headers);\n        if (ho == NULL) {\n            ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return NGX_OK;\n        }\n\n        *ho = *h;\n        ho->next = NULL;\n        *ph = ho;\n        ph = &ho->next;\n\n        h = h->next;\n    }\n}', 'explanation': 'This segment checks if the response status is 401 (Unauthorized) and if the upstream has provided a WWW-Authenticate header. It then copies the header entries from the upstream response into the outbound response headers, thereby ensuring that the 401 response contains the required WWW-Authenticate challenge as specified by the RFC.'}}]","The function implements the key aspect of the provided RFC specification by handling a 401 Unauthorized response. Specifically, when a WWW-Authenticate header is present, the function copies it to the outgoing response headers. This behavior directly fulfills the RFC requirement that a 401 response MUST include at least one WWW-Authenticate header challenge. All necessary logic to address this condition is contained within the function, so the implementation is self‐contained and fully matches the spec constraints.",success,
1580,ngx_http_upstream_process_trailers,A recipient that retains a received trailer field MUST either store/ forward the trailer field separately from the received header fields or merge the received trailer field into the header section.,206,Fully Matches,"[{'C1': {'code': 'if (!u->conf->pass_trailers) {\n    return NGX_OK;\n}\n\npart = &u->headers_in.trailers.part;\nh = part->elts;\n\nfor (i = 0; /* void */; i++) {\n    if (i >= part->nelts) {\n        if (part->next == NULL) {\n            break;\n        }\n        part = part->next;\n        h = part->elts;\n        i = 0;\n    }\n\n    if (ngx_hash_find(&u->conf->hide_headers_hash, h[i].hash,\n                      h[i].lowcase_key, h[i].key.len))\n    {\n        continue;\n    }\n\n    ho = ngx_list_push(&r->headers_out.trailers);\n    if (ho == NULL) {\n        return NGX_ERROR;\n    }\n\n    *ho = h[i];\n}', 'explanation': 'The function checks if passing of trailer fields is enabled and then iterates over the incoming trailer fields (u->headers_in.trailers). It selectively filters out hidden headers and stores the remaining trailer fields in a separate list (r->headers_out.trailers), thereby implementing the spec requirement to store/forward trailer fields separately from the header section.'}}]","The provided function directly implements the RFC requirement by conditionally processing trailer fields: when trailer forwarding is enabled (via u->conf->pass_trailers), it iterates over the incoming trailer section and stores each allowed trailer field separately in r->headers_out.trailers. This approach fulfills the mandate that a recipient retaining a trailer field must store/forward it separately (instead of merging with the header section), thus fully matching the specification.",success,
1580,ngx_http_upstream_process_trailers,A recipient that removes the chunked coding from a message MAY selectively retain or discard the received trailer fields.,205,Fully Matches,"[{'C1': {'code': 'if (!u->conf->pass_trailers) {\n    return NGX_OK;\n}', 'explanation': ""The function first checks the configuration flag 'pass_trailers' to determine whether trailer fields should be retained or discarded. This directly implements the selective retention/discarding requirement.""}}, {'A1': {'code': 'ho = ngx_list_push(&r->headers_out.trailers);\nif (ho == NULL) {\n    return NGX_ERROR;\n}\n*ho = h[i];', 'explanation': ""For each trailer field that is not filtered out (using ngx_hash_find), the code pushes the trailer header into a separate 'headers_out.trailers' list. This meets the action requirement to store the trailer fields separately from the header fields.""}}]","The function implements the RFC requirement by conditionally processing trailer headers. If the configuration does not require passing trailers, it discards them. If trailers should be retained, it selectively copies each allowed trailer into a separate trailer list. This covers both the condition to selectively retain/discard and the action to store trailer fields separately, thereby satisfying the specified constraints within the function itself.",success,
1580,ngx_http_upstream_process_trailers,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Partially Matches,[],"The RFC requires that a recipient must not merge a trailer field into a header section unless it understands the header field’s definition and the definition explicitly permits safe merging. In the provided function, the decision to pass trailer fields is based solely on a configuration flag (u->conf->pass_trailers) and a check against a hash of headers to potentially hide unwanted ones. Although the function conditionally copies trailer headers (if pass_trailers is true and the header is not in the hide list), it does not verify that the trailer header’s definition is understood or that the safe merging procedure is explicitly allowed. This means the function only partially addresses the constraint because it uses a configuration-driven mechanism rather than assessing each header field definition per the RFC. Therefore, the code only partially matches the intended behavior as specified in the RFC.",success,
1580,ngx_http_upstream_process_trailers,A recipient MUST NOT merge a received trailer field into the header section unless its corresponding header field definition explicitly permits and instructs how the trailer field value can be safely merged.,207,Fully Matches,"[{'C1': {'code': 'if (!u->conf->pass_trailers) {\n    return NGX_OK;\n}\n...\nho = ngx_list_push(&r->headers_out.trailers);\nif (ho == NULL) {\n    return NGX_ERROR;\n}\n*ho = h[i];', 'explanation': 'The function checks whether trailer fields should be processed (via u->conf->pass_trailers) and, if so, iterates over each trailer field and appends it to a separate trailers list (r->headers_out.trailers), rather than merging them into the header section. This behavior conforms to the spec requirement that trailer fields must not be merged into headers unless explicitly allowed.'}}]","The code function visibly implements the spec constraint by keeping trailer fields separate from the main header fields. It specifically avoids merging them into the header section by using a dedicated trailers container and by providing a configuration switch to enable or disable trailer processing. Therefore, the function fully addresses the condition (labeled as C1) from the spec constraints.",success,
1580,ngx_http_upstream_process_trailers,"At the end of a message, a recipient MAY treat the set of received trailer fields as a data structure of name/value pairs, similar to (but separate from) the header fields.",14,Fully Matches,"[{'C1': {'code': 'if (!u->conf->pass_trailers) {\n    return NGX_OK;\n}\n\npart = &u->headers_in.trailers.part;\nh = part->elts;\n\nfor (i = 0; /* void */; i++) {\n    if (i >= part->nelts) {\n        if (part->next == NULL) {\n            break;\n        }\n        part = part->next;\n        h = part->elts;\n        i = 0;\n    }\n    ...', 'explanation': 'The code checks if trailer processing is enabled (pass_trailers) and then iterates over the incoming trailer fields in order. This approach respects the RFC’s treatment of trailers as a set of name/value pairs processed in sequence.'}}, {'A1': {'code': 'ho = ngx_list_push(&r->headers_out.trailers);\nif (ho == NULL) {\n    return NGX_ERROR;\n}\n\n*ho = h[i];', 'explanation': 'Each trailer field (that is not hidden) is appended to a separate output list (headers_out.trailers), effectively treating them as a distinct data structure similarly to header fields, in accordance with the RFC specification.'}}]","The function clearly implements the RFC requirement to treat trailer fields as a separate name/value pair data structure. It first verifies whether trailer processing is enabled, then iterates through received trailers in order, and finally, for each non-hidden trailer header, it appends the field to a separate output list. This directly corresponds to the spec's guidance on handling trailer fields, thus the function fully matches the specified conditions and actions.",success,
1581,ngx_http_upstream_send_response,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Fully Matches,"[{'C1': {'code': 'if (u->upgrade) {\n\n#if (NGX_HTTP_CACHE)\n\n    if (r->cache) {\n        ngx_http_file_cache_free(r->cache, u->pipe->temp_file);\n    }\n\n#endif\n\n    ngx_http_upstream_upgrade(r, u);\n    return;\n}', 'explanation': 'This code branch ensures that when the connection is in upgrade (tunnel) mode, any associated cache is freed. This directly implements the RFC requirement that a cache cannot be used while acting as a tunnel.'}}, {'A1': {'code': '#if (NGX_HTTP_CACHE)\n\n    if (r->cache && r->cache->file.fd != NGX_INVALID_FILE) {\n        ngx_pool_run_cleanup_file(r->pool, r->cache->file.fd);\n        r->cache->file.fd = NGX_INVALID_FILE;\n    }\n    \n    switch (ngx_http_test_predicates(r, u->conf->no_cache)) {\n        case NGX_ERROR:\n            ngx_http_upstream_finalize_request(r, u, NGX_ERROR);\n            return;\n        case NGX_DECLINED:\n            u->cacheable = 0;\n            break;\n        default: /* NGX_OK */\n            if (u->cache_status == NGX_HTTP_CACHE_BYPASS) {\n                if (ngx_http_file_cache_create(r) != NGX_OK) {\n                    ngx_http_upstream_finalize_request(r, u, NGX_ERROR);\n                    return;\n                }\n            }\n            break;\n    }\n    \n    if (u->cacheable) {\n        time_t  now, valid;\n        now = ngx_time();\n        valid = r->cache->valid_sec;\n        if (valid == 0) {\n            valid = ngx_http_file_cache_valid(u->conf->cache_valid, u->headers_in.status_n);\n            if (valid) {\n                r->cache->valid_sec = now + valid;\n            }\n        }\n        if (valid) {\n            r->cache->date = now;\n            r->cache->body_start = (u_short) (u->buffer.pos - u->buffer.start);\n            if (u->headers_in.status_n == NGX_HTTP_OK || u->headers_in.status_n == NGX_HTTP_PARTIAL_CONTENT) {\n                r->cache->last_modified = u->headers_in.last_modified_time;\n                if (u->headers_in.etag) {\n                    r->cache->etag = u->headers_in.etag->value;\n                } else {\n                    ngx_str_null(&r->cache->etag);\n                }\n            } else {\n                r->cache->last_modified = -1;\n                ngx_str_null(&r->cache->etag);\n            }\n            if (ngx_http_file_cache_set_header(r, u->buffer.start) != NGX_OK) {\n                ngx_http_upstream_finalize_request(r, u, NGX_ERROR);\n                return;\n            }\n        } else {\n            u->cacheable = 0;\n        }\n    }\n\n    if (u->cacheable == 0 && r->cache) {\n        ngx_http_file_cache_free(r->cache, u->pipe->temp_file);\n    }\n\n    if (r->header_only && !u->cacheable && !u->store) {\n        ngx_http_upstream_finalize_request(r, u, 0);\n        return;\n    }\n\n#endif', 'explanation': ""This segment demonstrates that when caching is enabled, the function manages cache creation, validation, and header setting. It conditionally creates or frees cache resources based on the response and caching directives, which supports the RFC's provision that a client or server may use a cache.""}}]","The function contains explicit handling of caching behavior. It ensures that if the connection is upgraded (i.e. acting as a tunnel), any cache in use is released (fulfilling the requirement that a cache cannot be used in tunnel mode). Additionally, when caching is applicable, the function implements logic to create, validate, and manage cache content. This demonstrates that the code function, by itself, addresses the RFC which states that any client or server MAY employ a cache but cannot do so in tunnel mode.",success,
1587,ngx_http_upstream_process_upgraded,"Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.",315,Partially Matches,"[{'C1': {'code': 'if ((upstream->read->eof && u->buffer.pos == u->buffer.last)\n    || (downstream->read->eof && u->from_client.pos == u->from_client.last)\n    || (downstream->read->eof && upstream->read->eof))\n{\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                   ""http upstream upgraded done"");\n    ngx_http_upstream_finalize_request(r, u, 0);\n    return;\n}', 'explanation': 'This segment checks for EOF signals (interpreted as closure signals) from both the upstream and downstream connections. It shows that the function is monitoring for potential connection closure events.'}}, {'A1': {'code': 'if (downstream->write->timedout) {\n    c->timedout = 1;\n    ngx_connection_error(c, NGX_ETIMEDOUT, ""client timed out"");\n    ngx_http_upstream_finalize_request(r, u, NGX_HTTP_REQUEST_TIME_OUT);\n    return;\n}\n\nif (upstream->read->timedout || upstream->write->timedout) {\n    ngx_connection_error(c, NGX_ETIMEDOUT, ""upstream timed out"");\n    ngx_http_upstream_finalize_request(r, u, NGX_HTTP_GATEWAY_TIME_OUT);\n    return;\n}', 'explanation': 'These code segments check for timeout conditions on the client and upstream connections and, upon detecting them, promptly finalize the request. This behavior aligns with the RFC’s guideline to respond appropriately (e.g., gracefully closing) when a connection closure or timeout signal is observed.'}}]","The provided function monitors for closure-related events such as timeouts and EOF occurrences on both upstream and downstream connections and responds by finalizing the request, which is a way to reclaim system resources. However, while these checks address key parts of the RFC (monitoring for closure signals and responding), the implementation does not comprehensively cover all potential closure scenarios or a proactive constant monitoring approach solely within this function. Some aspects of persistent connection management and graceful shutdown might be handled at different layers in the overall system. Thus, the implementation partially matches the RFC specification regarding monitoring and handling connection closure signals.",success,
1590,ngx_http_upstream_process_non_buffered_upstream,"A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.",310,Partially Matches,"[{'C1': {'code': 'if (c->read->timedout) {', 'explanation': ""The code checks for a timeout on the connection's read event, which addresses the scenario of a triggered timeout exception leading to an incomplete request.""}}, {'A1': {'code': 'ngx_connection_error(c, NGX_ETIMEDOUT, ""upstream timed out"");\nngx_http_upstream_finalize_request(r, u, NGX_HTTP_GATEWAY_TIME_OUT);', 'explanation': ""Upon detecting a timeout, the function sends an error response prior to closing the connection, aligning with the RFC specification's allowance for sending an error response when a request is incomplete.""}}]","The function inspects the connection to determine if a timeout occurred and, if so, it triggers error handling by logging the timeout error and finalizing the request with an error response. This directly addresses the part of the RFC spec that permits sending an error response upon a timeout exception (an incomplete request scenario). However, it does not cover other scenarios such as a canceled request, hence it only partially matches the overall specification.",success,
1591,ngx_http_upstream_process_non_buffered_request,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Does Not Match,[],"The provided function primarily handles non-buffered request processing by forwarding data between the upstream and downstream connections, managing read/write events, and scheduling timers. There is no explicit logic within the function to sustain persistent connections or to allow the underlying transport’s flow-control mechanisms to resolve temporary overloads rather than closing the connection. While the function does check connection states and sets timers (e.g., for write readiness and read timeout), these actions are part of general I/O event management and do not directly implement the persistent connection sustainability requirement detailed in the spec. Therefore, no specific constraints such as maintaining persistent connections (which would be a condition like C1) or taking advantage of flow control (an action like A1) are visibly addressed solely within this function's code.",success,
1591,ngx_http_upstream_process_non_buffered_request,"Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.",315,Partially Matches,"[{'C1': {'code': 'if (upstream->read->eof || upstream->read->error) {\n    flags = NGX_CLOSE_EVENT;\n}\n...\nif (ngx_handle_read_event(upstream->read, flags) != NGX_OK) {\n    ngx_http_upstream_finalize_request(r, u, NGX_ERROR);\n    return;\n}', 'explanation': 'This segment monitors the upstream connection status by checking for EOF or error conditions, which indicates that a closure signal has been received.'}}, {'A1': {'code': 'if (u->busy_bufs == NULL) {\n    if (u->length == 0\n        || (upstream->read->eof && u->length == -1)) {\n        ngx_http_upstream_finalize_request(r, u, 0);\n        return;\n    }\n\n    if (upstream->read->eof) {\n        ngx_log_error(NGX_LOG_ERR, upstream->log, 0,\n                      ""upstream prematurely closed connection"");\n\n        ngx_http_upstream_finalize_request(r, u, NGX_HTTP_BAD_GATEWAY);\n        return;\n    }\n\n    if (upstream->read->error || u->error) {\n        ngx_http_upstream_finalize_request(r, u, NGX_HTTP_BAD_GATEWAY);\n        return;\n    }\n}', 'explanation': 'This code attempts to respond to a detected closure by finalizing the request, thus initiating a graceful close of the connection when a closure signal is observed.'}}]","The function includes logic that checks for closure signals (EOF or error) on the upstream connection and responds by finalizing the request, which aligns with parts of the RFC requirement for monitoring and handling connection closures. However, the implementation only partially fulfills the overall specification—while it monitors and reacts to closure signals on the upstream side, it does not comprehensively address monitoring and graceful shutdown in all scenarios or for both sides of the connection as described in the RFC. Thus, the function only partially matches the specified constraints.",success,
1594,ngx_http_upstream_non_buffered_filter,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (u->length == 0) {\n    ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n                  ""upstream sent more data than specified in ""Content-Length"" header"");\n    return NGX_OK;\n}', 'explanation': 'This code segment checks if no further data is expected (u->length == 0) but additional data has been received, logging a warning as prescribed by the RFC’s mandate to interpret the protocol element even when it is invalid. It shows an attempt to detect a case where the sender’s behavior is incorrect.'}}, {'A1': {'code': 'if (bytes > u->length) {\n\n    ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n                  ""upstream sent more data than specified in ""Content-Length"" header"");\n\n    cl->buf->last = cl->buf->pos + u->length;\n    u->length = 0;\n\n    return NGX_OK;\n}', 'explanation': 'This segment handles the case in which the incoming data bytes exceed the expected Content-Length. It logs a warning and then adjusts the last pointer of the buffer to recover as much as possible from the invalid input, aligning with the RFC suggestion to attempt recovery from an invalid construct.'}}]","The function implements logic that addresses part of the RFC requirement by checking content length mismatches and logging warnings when the upstream sends more data than declared. It attempts to recover from such errors by adjusting the buffer state. However, because the RFC specification covers a broader range of behaviors and error-handling strategies (and possibly additional conditions/actions), the implementation in this function addresses only a subset of those requirements. Therefore, the match is only partial.",success,
1598,ngx_http_upstream_process_request,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'if (u->cacheable) {\n    if (p->upstream_done) {\n        ngx_http_file_cache_update(r, p->temp_file);\n    } else if (p->upstream_eof) {\n        tf = p->temp_file;\n        if (p->length == -1\n            && (u->headers_in.content_length_n == -1\n                || u->headers_in.content_length_n == tf->offset - (off_t) r->cache->body_start))\n        {\n            ngx_http_file_cache_update(r, tf);\n        } else {\n            ngx_http_file_cache_free(r->cache, tf);\n        }\n    } else if (p->upstream_error) {\n        ngx_http_file_cache_free(r->cache, p->temp_file);\n    }\n}', 'explanation': 'This segment shows that the function uses a cache when the response is cacheable and proper upstream conditions occur. It handles updating or freeing the cache based on the received upstream response, thereby addressing that a client/server MAY employ a cache.'}}]","The provided code function contains logic for managing cache storage—updating or releasing the cache depending on the upstream response statuses—which aligns with the RFC specification that a client/server may use a cache. However, the RFC also requires that the cache cannot be used when acting as a tunnel, and there is no explicit check or logic in the function to disable caching in tunnel mode. Since the function does not address the tunnel condition, only part of the specification is implemented, leading to the 'Partially Matches' judgment.",success,
1602,ngx_http_upstream_next,"A client, server, or proxy MAY close the transport connection at any time.",316,Fully Matches,"[{'C1': {'code': 'if (u->peer.connection) {\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       ""close http upstream connection: %d"",\n                       u->peer.connection->fd);\n#if (NGX_HTTP_SSL)\n    if (u->peer.connection->ssl) {\n        u->peer.connection->ssl->no_wait_shutdown = 1;\n        u->peer.connection->ssl->no_send_shutdown = 1;\n\n        (void) ngx_ssl_shutdown(u->peer.connection);\n    }\n#endif\n\n    if (u->peer.connection->pool) {\n        ngx_destroy_pool(u->peer.connection->pool);\n    }\n\n    ngx_close_connection(u->peer.connection);\n    u->peer.connection = NULL;\n}', 'explanation': 'This segment explicitly checks for an active upstream connection and, after performing necessary SSL shutdown steps (if applicable) and destroying the associated memory pool, it closes the connection. This corresponds to the RFC requirement allowing a client, server, or proxy to close the transport connection, implementing a graceful close.'}}]","The function contains a clear implementation to gracefully close an active connection when certain error or timeout conditions are met. In particular, it manages SSL shutdown (if in use), cleans up resources, and calls the closing function, directly aligning with the RFC specification that a client, server, or proxy may close the connection at any time. All required aspects visible within the function are therefore fully met by the provided code.",success,
1602,ngx_http_upstream_next,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'if (u->cache_status == NGX_HTTP_CACHE_EXPIRED\n    && ((u->conf->cache_use_stale & ft_type) || r->cache->stale_error)) {\n    ngx_int_t  rc;\n\n    rc = u->reinit_request(r);\n\n    if (rc != NGX_OK) {\n        ngx_http_upstream_finalize_request(r, u, rc);\n        return;\n    }\n\n    u->cache_status = NGX_HTTP_CACHE_STALE;\n    rc = ngx_http_upstream_cache_send(r, u);\n\n    if (rc == NGX_DONE) {\n        return;\n    }\n\n    if (rc == NGX_HTTP_UPSTREAM_INVALID_HEADER) {\n        rc = NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    ngx_http_upstream_finalize_request(r, u, rc);\n    return;\n}', 'explanation': 'This portion of the function implements caching behavior by handling stale cache situations, thereby addressing the spec portion that permits a client or server to employ a cache.'}}]","The function includes logic to utilize a cache (as seen in the NGX_HTTP_CACHE block) which addresses the permissive aspect of the spec that a client or server MAY employ a cache. However, the implementation does not include any check or logic to prevent cache usage while acting as a tunnel, as mandated by the spec, meaning that this part of the specification is not addressed within this function's code. As a result, only the cache-employment aspect is visibly handled, leading to a partial match of the overall specification.",success,
1605,ngx_http_upstream_finalize_request,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'if (r->cache) {\n\n    if (u->cacheable) {\n\n        if (rc == NGX_HTTP_BAD_GATEWAY || rc == NGX_HTTP_GATEWAY_TIME_OUT) {\n            time_t  valid;\n\n            valid = ngx_http_file_cache_valid(u->conf->cache_valid, rc);\n\n            if (valid) {\n                r->cache->valid_sec = ngx_time() + valid;\n                r->cache->error = rc;\n            }\n        }\n    }\n\n    ngx_http_file_cache_free(r->cache, u->pipe->temp_file);\n}\n', 'explanation': 'This segment demonstrates that the function will use caching if a cache is present, satisfying the part of the spec stating that a cache may be employed.'}}]","The RFC specification indicates that any client or server MAY employ a cache, but a cache cannot be used while acting as a tunnel. In this function, caching is addressed by checking if a cache exists (r->cache) and handling it accordingly. However, there is no visible logic in the function that verifies or prevents the use of the cache when acting as a tunnel. Since only the permission to employ a cache is implemented (C1) and the critical restriction regarding tunnel mode is not handled, the function only partially meets the RFC's caching constraints.",success,
1605,ngx_http_upstream_finalize_request,"Servers MAY close the connection after sending the closure alert, thus generating an incomplete close on the client side.",326,Fully Matches,"[{'A1': {'code': 'if (u->peer.connection->ssl) {\n\n    /*\n     * We send the ""close notify"" shutdown alert to the upstream only\n     * and do not wait its ""close notify"" shutdown alert.\n     * It is acceptable according to the TLS standard.\n     */\n\n    u->peer.connection->ssl->no_wait_shutdown = 1;\n    (void) ngx_ssl_shutdown(u->peer.connection);\n}', 'explanation': ""This section of the code explicitly sends the TLS 'close notify' alert to the upstream peer and then closes the connection without waiting for a reciprocal alert, thereby implementing the RFC requirement that a server must attempt to initiate an exchange of closure alerts before closing the connection.""}}]","The code function initiates the closure alert exchange as required by the RFC—sending the 'close notify' alert and then closing the connection—which aligns with the spec that states 'Servers MAY close the connection after sending the closure alert' and 'Servers MUST attempt to initiate an exchange of closure alerts.' Thus, within the scope of this function, the relevant constraint is fully implemented.",success,
1609,ngx_http_upstream_process_content_length,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Fully Matches,"[{'C1': {'code': 'if (u->headers_in.content_length) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent duplicate header line: \\""%V: %V\\"", ""\n                  ""previous value: \\""%V: %V\\"""",\n                  &h->key, &h->value,\n                  &u->headers_in.content_length->key,\n                  &u->headers_in.content_length->value);\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': 'This code block checks if a Content-Length header has already been set and, if so, logs an error and returns an error code. This directly implements the RFC requirement that a message must not contain multiple field lines with the same name unless allowed, thereby satisfying the condition.'}}, {'A1': {'code': 'if (u->headers_in.transfer_encoding) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent \\""Content-Length\\"" and ""\n                  ""\\""Transfer-Encoding\\"" headers at the same time"");\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': 'This segment ensures that Content-Length is not processed if Transfer-Encoding is already declared, addressing the RFC’s specification about mutually exclusive handling of these headers.'}}]","The function 'ngx_http_upstream_process_content_length' directly checks for duplicate 'Content-Length' headers by testing if one already exists, and it also verifies that 'Content-Length' and 'Transfer-Encoding' are not present together. These checks are inline with the RFC requirement that a sender must not include multiple field lines with the same name (unless permitted) and that the order and presence of such headers must be preserved. All of this logic is implemented within the function, fulfilling the labeled constraints.",success,
1609,ngx_http_upstream_process_content_length,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'C1': {'code': 'if (u->headers_in.content_length) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent duplicate header line: \\""%V: %V\\"", ""\n                  ""previous value: \\""%V: %V\\"""",\n                  &h->key, &h->value,\n                  &u->headers_in.content_length->key,\n                  &u->headers_in.content_length->value);\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': 'Checks if a Content-Length header has already been set and, if so, logs an error and rejects the header by returning an error code. This prevents forwarding a message with duplicate Content-Length headers.'}}, {'C2': {'code': 'if (u->headers_in.content_length_n == NGX_ERROR) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent invalid \\""Content-Length\\"" header: ""\n                  ""\\""%V: %V\\"""", &h->key, &h->value);\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': 'Converts the Content-Length header value to a number and checks if the conversion fails (indicative of an invalid value). If invalid, it logs an error and returns an error code, thereby preventing forwarding a message with an incorrect Content-Length value.'}}, {'A1': {'code': 'if (u->headers_in.transfer_encoding) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent \\""Content-Length\\"" and ""\n                  ""\\""Transfer-Encoding\\"" headers at the same time"");\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': 'Ensures that if both Content-Length and Transfer-Encoding headers are present, the message is rejected. This check helps to avoid confusion in message framing, in line with security requirements.'}}]","The function attempts to enforce the RFC requirement by rejecting messages with an invalid Content-Length header value. It explicitly checks for duplicate Content-Length headers, verifies that the header value can be parsed as a valid number, and also ensures that both Content-Length and Transfer-Encoding headers are not present simultaneously. However, it does not implement the exception detailed in the RFC where a repeated identical Content-Length value (e.g., a comma-separated list like ""42, 42"") may be accepted or normalized. Because of the absence of logic to handle this exception, the implementation partially meets the overall RFC constraint.",success,
1609,ngx_http_upstream_process_content_length,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'if (u->headers_in.transfer_encoding) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent \\""Content-Length\\"" and \\""Transfer-Encoding\\"" headers at the same time"");\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': 'This code segment checks if the Transfer-Encoding header is present. If so, it logs an error and rejects the Content-Length header, which directly implements the RFC constraint that a sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.'}}]","The function explicitly checks for the presence of a Transfer-Encoding header before processing the Content-Length header. By verifying and rejecting a message that includes both headers, the function fully meets the RFC requirement as specified. No additional constraints/actions were needed from this function beyond this check, so the logic fully addresses the provided specification.",success,
1609,ngx_http_upstream_process_content_length,"If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value).",201,Partially Matches,"[{'C1': {'code': 'if (u->headers_in.content_length) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent duplicate header line: \\""%V: %V\\"", ""\n                  ""previous value: \\""%V: %V\\"""",\n                  &h->key, &h->value,\n                  &u->headers_in.content_length->key,\n                  &u->headers_in.content_length->value);\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': 'This segment checks if a Content-Length header has already been set. If so, it treats the duplicate as an error, which is in line with preventing multiple inconsistent headers.'}}, {'C2': {'code': 'if (u->headers_in.transfer_encoding) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent \\""Content-Length\\"" and \\""Transfer-Encoding\\"" headers at the same time"");\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': 'This segment ensures that if both Transfer-Encoding and Content-Length are present, the function logs an error and returns an invalid header status. This corresponds to the RFC requirement for handling such a case.'}}, {'C3': {'code': 'u->headers_in.content_length_n = ngx_atoof(h->value.data, h->value.len);\n\nif (u->headers_in.content_length_n == NGX_ERROR) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent invalid \\""Content-Length\\"" header: ""\n                  ""\\""%V: %V\\"""", &h->key, &h->value);\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': 'This segment attempts to parse the Content-Length header value. If parsing fails (i.e. returns an error), it treats it as an invalid header. This implements part of the RFC condition handling invalid Content-Length values.'}}]","The function implements several error checks that align with some of the RFC requirements. It checks for duplicate Content-Length headers, for the simultaneous presence of Transfer-Encoding and Content-Length, and for invalid numeric values in the Content-Length header. However, it does not address the exception where an invalid Content-Length header field might be acceptable if it can be parsed as a comma-separated list of identical valid values. Thus, while key error conditions are handled, the special case (comma-separated list parsing) is not implemented, leading to a partial match.",success,
1610,ngx_http_upstream_process_last_modified,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Fully Matches,"[{'C1': {'code': 'if (u->headers_in.last_modified) {\n    ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n                  ""upstream sent duplicate header line: \\""%V: %V\\"", previous value: \\""%V: %V\\"", ignored"",\n                  &h->key, &h->value,\n                  &u->headers_in.last_modified->key,\n                  &u->headers_in.last_modified->value);\n    h->hash = 0;\n    return NGX_OK;\n}', 'explanation': 'This segment checks if a Last-Modified header has already been processed. If so, it logs a warning and marks the duplicate header as invalid, thus ensuring that multiple field lines with the same name are not accepted unless allowed by the specification.'}}, {'A1': {'code': 'h->next = NULL;\nu->headers_in.last_modified = h;', 'explanation': 'This code assigns the header line to the Last-Modified field when one has not already been registered, thereby preserving the order of header reception by relying on the first encountered header and not appending duplicates.'}}]","The function ngx_http_upstream_process_last_modified handles the Last-Modified header by checking if one has already been received. In accordance with the RFC that specifies senders must not generate duplicate headers (unless allowed to combine), the function logs a warning and ignores any further duplicate header lines. By storing the first header and rejecting additional ones, it both prevents multiple occurrences and preserves the order, fully matching the constraints of the specification.",success,
1612,ngx_http_upstream_process_cache_control,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'if (r->cache == NULL) {\n    return NGX_OK;\n}', 'explanation': 'This check ensures that caching logic is only processed when a cache is present, which aligns with the RFC statement that any client or server MAY employ a cache. It handles the option of caching, though it does not decide whether to use a cache or not in every situation.'}}, {'A1': {'code': 'if (ngx_strlcasestrn(start, last, (u_char *) ""no-cache"", 8 - 1) != NULL\n    || ngx_strlcasestrn(start, last, (u_char *) ""no-store"", 8 - 1) != NULL\n    || ngx_strlcasestrn(start, last, (u_char *) ""private"", 7 - 1) != NULL)\n{\n    u->headers_in.no_cache = 1;\n    return NGX_OK;\n}', 'explanation': 'This segment parses Cache-Control header directives (such as ""no-cache"", ""no-store"", and ""private"") to disable caching when these directives are found, thereby adjusting cache usage as per header instructions. This processing is part of the cache control mechanism guided by the RFC.'}}]","The function implements logic to process Cache-Control headers, conditionally configuring cache behavior based on parsed directives. It checks for the presence of a cache before processing and disables caching if directives like 'no-cache', 'no-store', or 'private' are encountered. These aspects partially fulfill the RFC requirement that any client or server MAY employ a cache. However, the RFC also specifies that a cache cannot be used while acting as a tunnel, and no such tunnel-related check is present within this function. Therefore, while part of the caching behavior is handled, the tunnel condition is omitted, leading to a partial match.",success,
1613,ngx_http_upstream_process_expires,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Fully Matches,"[{'C1': {'code': 'if (u->headers_in.expires) {\n    ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n                  ""upstream sent duplicate header line: \\""%V: %V\\"", ""\n                  ""previous value: \\""%V: %V\\"", ignored"",\n                  &h->key, &h->value,\n                  &u->headers_in.expires->key,\n                  &u->headers_in.expires->value);\n    h->hash = 0;\n    return NGX_OK;\n}', 'explanation': 'This segment checks if an Expires header has already been received (i.e. a duplicate exists). According to the RFC specification, aside from allowed duplicate header fields that can be combined via comma separation, duplicate field lines should not be added. This code logs a warning and discards the duplicate by setting its hash to 0.'}}]","The provided function implements duplicate header handling for the 'Expires' field by verifying if an Expires header has already been processed. When a duplicate is detected, it logs the duplicate occurrence and disregards the new header. This behavior aligns with the RFC's condition against generating multiple header lines with the same name unless the field definition allows combining them. The logic directly present in the function fulfills the spec constraint (labeled as C1) regarding duplicate header handling.",success,
1614,ngx_http_upstream_process_accel_expires,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Fully Matches,"[{'C1': {'code': 'if (u->headers_in.x_accel_expires) {\n    ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n                  ""upstream sent duplicate header line: \\""%V: %V\\"", ""\n                  ""previous value: \\""%V: %V\\"", ignored"",\n                  &h->key, &h->value,\n                  &u->headers_in.x_accel_expires->key,\n                  &u->headers_in.x_accel_expires->value);\n    h->hash = 0;\n    return NGX_OK;\n}', 'explanation': 'This code checks for an existing x_accel_expires header. When a duplicate is found, it logs a warning and discards the incoming duplicate header. This behavior directly implements the RFC constraint that a sender must not generate multiple header fields with the same name unless allowed.'}}]","The function explicitly handles the duplicate header scenario by checking if the x_accel_expires header is already present and, if so, logging a warning and ignoring the duplicate. This approach addresses the RFC requirement to prevent multiple field lines with the same name (unless the field allows recombination), and therefore, within its scope, the function fully implements the specified constraint.",success,
1615,ngx_http_upstream_process_limit_rate,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Fully Matches,"[{'C1': {'code': 'if (u->headers_in.x_accel_limit_rate) {\n    ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n                  ""upstream sent duplicate header line: \\""%V: %V\\"", previous value: \\""%V: %V\\"", ignored"",\n                  &h->key, &h->value,\n                  &u->headers_in.x_accel_limit_rate->key,\n                  &u->headers_in.x_accel_limit_rate->value);\n    h->hash = 0;\n    return NGX_OK;\n}', 'explanation': 'This code segment checks whether a duplicate header (x_accel_limit_rate) is received. According to the RFC, duplicate header field lines are disallowed unless the specification permits combining them. Here, the function logs a warning and ignores the duplicate by resetting h->hash, thereby enforcing the constraint.'}}]","The function directly inspects if the header 'x_accel_limit_rate' has already been set. If so, it logs a duplicate header warning and returns without further processing the duplicate. This behavior prevents the appending or recombination of multiple field lines with the same header name, thus fully addressing the specified RFC constraint regarding the prohibition of duplicate header fields in messages.",success,
1616,ngx_http_upstream_process_buffering,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_XA_BUFFERING) {\n    return NGX_OK;\n}', 'explanation': 'This segment honors configuration that determines whether to process the protocol element. It implements the exception clause from the RFC by bypassing interpretation when the sender is known to implement the semantics incorrectly.'}}, {'A1': {'code': ""if (u->conf->change_buffering) {\n\n    if (h->value.len == 2) {\n        c0 = ngx_tolower(h->value.data[0]);\n        c1 = ngx_tolower(h->value.data[1]);\n\n        if (c0 == 'n' && c1 == 'o') {\n            u->buffering = 0;\n        }\n\n    } else if (h->value.len == 3) {\n        c0 = ngx_tolower(h->value.data[0]);\n        c1 = ngx_tolower(h->value.data[1]);\n        c2 = ngx_tolower(h->value.data[2]);\n\n        if (c0 == 'y' && c1 == 'e' && c2 == 's') {\n            u->buffering = 1;\n        }\n    }\n}"", 'explanation': ""This block interprets the received protocol element by checking for 'yes' or 'no' values, thereby implementing a basic interpretation of the header as required by the RFC (i.e., following the defined semantics of the header element).""}}]","The function attempts to implement part of the RFC requirement by interpreting a specific protocol element (the buffering header) according to the expected semantics ('yes' for enabling buffering and 'no' for disabling it) and by deferring processing when configuration indicates known sender misbehavior. However, it handles only specific, narrowly defined cases and does not implement broader error recovery for invalid constructs—hence it only partially matches the complete intent of the RFC specification.",success,
1619,ngx_http_upstream_process_transfer_encoding,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'if (u->headers_in.content_length) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent \\""Content-Length\\"" and \\""Transfer-Encoding\\"" headers at the same time"");\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': 'This code explicitly checks if a Content-Length header is present when a Transfer-Encoding header is being processed. If found, it logs an error and rejects the header, thereby enforcing the RFC rule that a message must not include a Content-Length header when a Transfer-Encoding header is present.'}}]","The function ngx_http_upstream_process_transfer_encoding addresses the specified RFC constraint by checking for the presence of a Content-Length header when a Transfer-Encoding header is processed. Upon detection, the function logs an error and returns an invalid header response. This directly implements the required rule from the RFC, fulfilling the constraint completely.",success,
1619,ngx_http_upstream_process_transfer_encoding,A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance.,187,Fully Matches,"[{'C1': {'code': 'if (h->value.len == 7\n    && ngx_strncasecmp(h->value.data, (u_char *) ""chunked"", 7) == 0)\n{\n    u->headers_in.chunked = 1;\n}', 'explanation': 'This code checks that the Transfer-Encoding header value is exactly ""chunked"" and sets a flag accordingly, thereby addressing the RFC requirement that a recipient must be able to parse chunked transfer coding.'}}, {'A1': {'code': 'if (u->headers_in.transfer_encoding) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent duplicate header line: \\""%V: %V\\"", ""\n                  ""previous value: \\""%V: %V\\"""",\n                  &h->key, &h->value,\n                  &u->headers_in.transfer_encoding->key,\n                  &u->headers_in.transfer_encoding->value);\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': 'This segment ensures that duplicate Transfer-Encoding headers are not processed, which is important to reliably frame the message as mandated by the RFC.'}}, {'A2': {'code': 'if (u->headers_in.content_length) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent \\""Content-Length\\"" and ""\n                  ""\\""Transfer-Encoding\\"" headers at the same time"");\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': 'This code prevents simultaneous specification of Content-Length and Transfer-Encoding headers, avoiding ambiguity in message framing.'}}]","The function processes the Transfer-Encoding header by ensuring that only one instance exists, that it is not combined with a Content-Length header, and that its value is exactly 'chunked'. These checks directly address the requirements outlined in the RFC specification for chunked transfer coding, as implemented within this function's logic. Therefore, the function fully matches the labeled constraints from the spec.",success,
1619,ngx_http_upstream_process_transfer_encoding,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Fully Matches,"[{'C1': {'code': 'if (u->headers_in.transfer_encoding) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent duplicate header line: \\""%V: %V\\"", previous value: \\""%V: %V\\"""",\n                  &h->key, &h->value,\n                  &u->headers_in.transfer_encoding->key,\n                  &u->headers_in.transfer_encoding->value);\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': ""This code checks whether a 'Transfer-Encoding' header has already been set. If it has, it logs an error and returns an error code, thereby disallowing multiple header lines for the same header, which directly addresses the RFC requirement that duplicate field lines (unless allowed by its definition) must not be generated.""}}, {'A1': {'code': 'if (u->headers_in.content_length) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent \\""Content-Length\\"" and \\""Transfer-Encoding\\"" headers at the same time"");\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': ""This snippet detects if both 'Content-Length' and 'Transfer-Encoding' headers are present. Since RFC requirements dictate that these should not appear together, the code logs the error and returns an error code, directly implementing that constraint.""}}]",The function 'ngx_http_upstream_process_transfer_encoding' implements the specified RFC constraints by verifying that duplicate 'Transfer-Encoding' header fields are not accepted (addressing condition C1) and by ensuring that 'Transfer-Encoding' does not appear with a 'Content-Length' header (addressing action A1). The direct checks and error returns within the function indicate that it fully attempts to implement the constraints outlined in the RFC specification.,success,
1620,ngx_http_upstream_process_vary,"A recipient MAY combine multiple field lines within a field section that have the same field name into one field line, without changing the semantics of the message, by appending each subsequent field line value to the initial field line value in order, separated by a comma ("","") and optional whitespace (OWS, defined in Section 5.6.3).",231,Fully Matches,"[{'C1': {'code': ""if (u->headers_in.vary->next) {\n\n    len = 0;\n\n    for (h = u->headers_in.vary; h; h = h->next) {\n        len += h->value.len + 2;\n    }\n\n    len -= 2;\n\n    p = ngx_pnalloc(r->pool, len);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    vary.len = len;\n    vary.data = p;\n\n    for (h = u->headers_in.vary; h; h = h->next) {\n        p = ngx_copy(p, h->value.data, h->value.len);\n\n        if (h->next == NULL) {\n            break;\n        }\n\n        *p++ = ',';\n        *p++ = ' ';\n    }\n}"", 'explanation': ""This block checks if multiple 'vary' header lines exist and then combines them by iterating over the linked list. It calculates the total length required and allocates memory, preserving the order of header lines as required by the specification.""}}, {'A1': {'code': ""*p++ = ',';\n*p++ = ' ';"", 'explanation': ""These lines explicitly insert a comma followed by a space between each concatenated header field value, fulfilling the RFC's action to use a comma and SP as the separator.""}}]","The function implements the RFC by detecting multiple 'vary' header lines, preserving their order, and concatenating their values into a single field line. It uses a loop to combine each header's value and explicitly adds a comma and a space between values, which is exactly the behavior mandated by the spec.",success,
1620,ngx_http_upstream_process_vary,"In any production that uses the list construct, a sender MUST NOT generate empty list elements.",236,Does Not Match,[],"The RFC requires that when constructing comma-delimited lists, empty list elements must not be generated. In the provided function, while a list is constructed by concatenating header values (with comma and space separators), there is no logic to check or avoid empty header values. This means that if any h->value.len is zero, an empty element could be generated, violating the RFC requirement. Therefore, the function’s code does not visibly address this spec constraint.",success,
1623,ngx_http_upstream_copy_content_type,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': ""while (*++p == ' ') { /* void */ }"", 'explanation': 'This loop skips over optional whitespace that appears immediately after a semicolon. In the context of the RFC where any BWS (bad whitespace) may be removed before interpretation, this directly implements that requirement.'}}, {'A1': {'code': 'r->headers_out.content_type_len = last - h->value.data;', 'explanation': ""After detecting a parameter delimiter (';'), the function resets the content_type length to exclude the charset parameter (including any BWS), thereby ensuring that only the intended protocol element is forwarded as specified.""}}]","The RFC specifies that any BWS (bad whitespace) present in a message may be removed prior to interpretation. In this function, the logic immediately after a semicolon (which typically introduces parameters such as the charset) uses a while loop to skip over any whitespace. This removal of whitespace (BWS) before further processing matches the RFC’s requirement, and the subsequent truncation of the header value up to that point confirms that the function is implementing the expected behavior. Thus, the code function visibly handles the removal of BWS as required by the RFC.",success,
1623,ngx_http_upstream_copy_content_type,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,"[{'C1': {'code': ""while (*++p == ' ') { /* void */ }"", 'explanation': ""This loop skips whitespace immediately following a semicolon, which is an attempt to remove bad whitespace before processing the 'charset=' parameter. However, the function does not remove all instances of bad whitespace everywhere in the header, so it only partially implements the RFC requirement.""}}]","The RFC mandates that any bad whitespace must be removed before interpreting protocol elements. In this function, there is an attempt to skip spaces after a semicolon to correctly locate the 'charset=' directive, addressing part of the requirement (C1). However, the function does not comprehensively remove all forms of bad whitespace (for example, before or after other tokens or in different contexts), indicating that while some parts of the spec constraint are visible, the implementation is only partial.",success,
1625,ngx_http_upstream_rewrite_location,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Partially Matches,"[{'A1': {'code': 'if (r->upstream->rewrite_redirect) {\n    rc = r->upstream->rewrite_redirect(r, ho, 0);\n\n    if (rc == NGX_DECLINED) {\n        return NGX_OK;\n    }\n\n    if (rc == NGX_OK) {\n        r->headers_out.location = ho;\n\n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       ""rewritten location: \\""%V\\"""", &ho->value);\n    }\n\n    return rc;\n}\n\nif (ho->value.data[0] != \'/\') {\n    r->headers_out.location = ho;\n}\n\n/*\n * we do not set r->headers_out.location here to avoid handling\n * relative redirects in ngx_http_header_filter()\n */', 'explanation': ""The function attempts to generate a Location header by assigning 'r->headers_out.location = ho' when the rewrite_redirect callback exists and returns NGX_OK, or when the header value is an absolute URI (i.e. not starting with '/'). This reflects the RFC recommendation for generating a Location header, but it leaves relative URIs (starting with '/') to be handled elsewhere.""}}]","The provided function contains logic to set the Location header field in the response under certain conditions. It explicitly assigns the header when a redirect rewrite is performed successfully or when the header value is determined to be an absolute URI. However, it deliberately avoids setting the Location header for relative URIs within this function, deferring that handling to another part of the system. As a result, while the function addresses part of the spec's requirement to generate a Location header (action A1), it does not fully cover all cases as described in the spec context. Thus, it partially matches the RFC constraint.",success,
1625,ngx_http_upstream_rewrite_location,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Partially Matches,"[{'A1': {'code': 'if (r->upstream->rewrite_redirect) {\n    rc = r->upstream->rewrite_redirect(r, ho, 0);\n    \n    if (rc == NGX_OK) {\n        r->headers_out.location = ho;\n        \n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       ""rewritten location: \\""%V\\"""", &ho->value);\n    }\n    \n    return rc;\n}\n\nif (ho->value.data[0] != \'/\') {\n    r->headers_out.location = ho;\n}\n\n/*\n * we do not set r->headers_out.location here to avoid handling\n * relative redirects in ngx_http_header_filter()\n */', 'explanation': ""This segment of the code directly assigns a header value to r->headers_out.location when certain conditions are met. It attempts to generate a Location header field—by rewriting the location via r->upstream->rewrite_redirect if available, or by checking that the header value is not a relative URI (starting with '/')—which partially fulfills the RFC requirement that the server SHOULD generate a Location header field.""}}]","The RFC requirement is that the server should generate a Location header field containing a URI reference. This function does include logic to set r->headers_out.location when a location rewrite is performed or when the provided URI is not relative. However, it intentionally skips setting this header for relative URIs (leaving that handling for another part of the system), meaning that the function only partially covers the RFC spec on its own. Therefore, while it does implement part of the required behavior (action A1), it does not fully address all cases by itself.",success,
1632,ngx_http_upstream_status_variable,"In any production that uses the list construct, a sender MUST NOT generate empty list elements.",236,Fully Matches,"[{'C1': {'code': 'if (state[i].status) {\n            p = ngx_sprintf(p, ""%ui"", state[i].status);\n\n        } else {\n            *p++ = \'-\';\n        }', 'explanation': ""This section ensures that for every list element an actual value is printed. If a status exists, its numeric value is printed; otherwise a '-' is printed. Therefore, no element in the generated comma-delimited list is empty, which fulfills the RFC requirement.""}}]","The function constructs a string list of upstream statuses and deliberately outputs either a numeric status (if the status is present) or a '-' as a placeholder when no status is available. This choice guarantees that every element in the comma-delimited list has content, directly addressing the RFC specification that a sender MUST NOT generate empty list elements. All logic addressing this requirement is contained within the function, without relying on external dependencies.",success,
1639,ngx_http_upstream_trailer_variable,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The provided function simply retrieves a trailer header variable from the upstream request and does not include any logic that checks or enforces the safe merging requirement as described in the RFC specification. There is no visible implementation of conditions such as verifying that the field’s definition explicitly permits safe merging before merging it into the header section. Therefore, the function does not address the relevant RFC constraint.",success,
1652,ngx_http_header_filter,"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.",52,Fully Matches,"[{'C1': {'code': 'if (r->headers_out.last_modified == NULL\n        && r->headers_out.last_modified_time != -1)\n    {\n        b->last = ngx_cpymem(b->last, ""Last-Modified: "", sizeof(""Last-Modified: "") - 1);\n        b->last = ngx_http_time(b->last, r->headers_out.last_modified_time);\n\n        *b->last++ = CR; *b->last++ = LF;\n    }', 'explanation': 'This code segment checks whether a valid last modification date is available (i.e. last_modified_time != -1) and the Last-Modified header has not already been set. If these conditions are met, it writes the Last-Modified header using the formatted time into the response header buffer, directly addressing the RFC requirement to send a Last-Modified header when a consistent modification date is determinable.'}}]","The function ngx_http_header_filter conditionally includes the Last-Modified header in the HTTP response; it first verifies that the last modification date is valid and that the header has not been previously set, then uses ngx_http_time() to format and append the header. Additionally, it nullifies the last_modified values for responses with status codes that should not include the header. This constitutes a full and visible implementation of the RFC requirement as specified.",success,
1652,ngx_http_header_filter,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'C2': {'code': 'if (status == NGX_HTTP_NO_CONTENT) {\n    r->header_only = 1;\n    ngx_str_null(&r->headers_out.content_type);\n    r->headers_out.last_modified_time = -1;\n    r->headers_out.last_modified = NULL;\n    r->headers_out.content_length = NULL;\n    r->headers_out.content_length_n = -1;\n}', 'explanation': 'For a 204 (No Content) response, the code resets the content length fields so that a Content-Length header will not be added later.'}}, {'A1': {'code': 'if (r->headers_out.content_length == NULL\n    && r->headers_out.content_length_n >= 0)\n{\n    b->last = ngx_sprintf(b->last, ""Content-Length: %O"" CRLF, r->headers_out.content_length_n);\n}', 'explanation': 'When a valid non-negative content length is known and no Content-Length header exists, the function appends a Content-Length header, which is the principal action required by the RFC in the absence of Transfer-Encoding.'}}]","The function partially implements the RFC requirement. It clearly attempts to send a Content-Length header (Action A1) when the content size is known, and it specifically disables sending such a header in the case of a 204 (No Content) response (Condition C2). However, the code does not visibly check for other edge cases specified in the RFC—such as omitting the Content-Length header for 1xx responses or for a 2xx response to a CONNECT request (Conditions C1 and C3)—within this function. Therefore, while some of the labeled constraints are addressed, the implementation is only partial.",success,
1652,ngx_http_header_filter,"A sender MUST NOT apply the chunked transfer coding more than once to a message body (i.e., chunking an already chunked message is not allowed).",188,Fully Matches,"[{'C1': {'code': 'if (r->chunked) {\n    len += sizeof(""Transfer-Encoding: chunked"" CRLF) - 1;\n}\n...\nif (r->chunked) {\n    b->last = ngx_cpymem(b->last, ""Transfer-Encoding: chunked"" CRLF,\n                         sizeof(""Transfer-Encoding: chunked"" CRLF) - 1);\n}', 'explanation': 'The RFC requires that the sender must not apply the chunked transfer coding more than once. In this function, the code checks the \'r->chunked\' flag and, if set, adds the ""Transfer-Encoding: chunked"" header exactly once. The header construction is performed only once during output header generation, thereby fulfilling the requirement.'}}]","The function_body explicitly examines the 'r->chunked' flag and, if true, appends the chunked transfer coding header exactly one time. Since the header is built only once (as ensured by the r->header_sent check and the single conditional block for r->chunked), the function prevents multiple applications of chunked encoding. This directly addresses the spec condition that a sender MUST NOT apply the chunked transfer coding more than once. Dependencies outside this function are not considered, and the relevant logic is contained within the function itself.",success,
1652,ngx_http_header_filter,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'if (r->headers_out.content_type.len) {\n    b->last = ngx_cpymem(b->last, ""Content-Type: "", sizeof(""Content-Type: "") - 1);\n    p = b->last;\n    b->last = ngx_copy(b->last, r->headers_out.content_type.data, r->headers_out.content_type.len);\n\n    if (r->headers_out.content_type_len == r->headers_out.content_type.len\n        && r->headers_out.charset.len)\n    {\n        b->last = ngx_cpymem(b->last, ""; charset="", sizeof(""; charset="") - 1);\n        b->last = ngx_copy(b->last, r->headers_out.charset.data, r->headers_out.charset.len);\n\n        r->headers_out.content_type.len = b->last - p;\n        r->headers_out.content_type.data = p;\n    }\n\n    *b->last++ = CR; *b->last++ = LF;\n}', 'explanation': ""This code checks if the content type is specified (i.e. known) and then explicitly generates a 'Content-Type' header, including charset details if available. This fulfills the RFC requirement that a message containing content should include a Content-Type header unless the media type is unknown.""}}]","The function 'ngx_http_header_filter' handles HTTP header generation for the response. In particular, it includes logic that checks if a known Content-Type is set and writes out the corresponding header field. This directly implements the RFC specification, which states that a sender should generate a Content-Type header if the media type is known, and omit it otherwise. All relevant logic for this behavior is contained within the function itself.",success,
1652,ngx_http_header_filter,"A sender SHOULD send a Connection header field (Section 7.6.1 of [HTTP]) containing the ""close"" connection option when it intends to close a connection.",212,Fully Matches,"[{'A1': {'code': 'else {\n    b->last = ngx_cpymem(b->last, ""Connection: close"" CRLF, sizeof(""Connection: close"" CRLF) - 1);\n}', 'explanation': 'This branch directly implements the RFC requirement by adding a ""Connection: close"" header when the connection is not kept alive.'}}]","The function examines whether the connection should be kept alive. In the final else branch, when r->keepalive is false, the code sends a ""Connection: close"" header, thereby fulfilling the RFC's directive to send the close option when intending to close the connection. This logic is self-contained in the function, meeting the spec constraint.",success,
1652,ngx_http_header_filter,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Fully Matches,"[{'C1': {'code': '*b->last++ = CR; *b->last++ = LF;', 'explanation': 'Throughout the function, every time a CR is output (for example, after the status line, header lines, and at the end of the header), it is immediately followed by an LF. This ensures that no bare CR (CR without a following LF) is generated, meeting the RFC requirement.'}}]","The function consistently uses pairs of CR and LF in constructing HTTP response headers (e.g., after the status line and header fields). This explicit pairing demonstrates that the function itself directly addresses the specification that a sender MUST NOT generate a bare CR. Therefore, the function fully implements the constraint as required by the spec.",success,
1652,ngx_http_header_filter,A sender MUST NOT send whitespace between the start-line and the first header field.,295,Fully Matches,"[{'C1': {'code': '/* Write the start-line */\n    b->last = ngx_cpymem(b->last, ""HTTP/1.1 "", sizeof(""HTTP/1.x "") - 1);\n    /* Write the status line and immediately end it with CRLF */\n    if (status_line) {\n        b->last = ngx_copy(b->last, status_line->data, status_line->len);\n    } else {\n        b->last = ngx_sprintf(b->last, ""%03ui "", status);\n    }\n    *b->last++ = CR; *b->last++ = LF;  // End of start-line, no extra whitespace inserted\n', 'explanation': ""The function constructs the HTTP start-line by copying 'HTTP/1.1 ' and the status line, then immediately appends a CRLF. There is no insertion of any additional whitespace or extra empty lines between the start-line and the first header field, thereby conforming to the RFC requirement that a sender must not send whitespace between these sections.""}}]","The function 'ngx_http_header_filter' builds the HTTP response header by writing the status line (start-line) followed by a single CRLF, then proceeds to write the header fields. The absence of any extra whitespace or empty lines between the status line and the first header field shows that it directly implements the relevant part of the HTTP RFC as specified.",success,
1652,ngx_http_header_filter,"A server MUST send the space that separates the status-code from the reason-phrase even when the reason-phrase is absent (i.e., the status-line would end with the space).",300,Fully Matches,"[{'C1': {'code': 'b->last = ngx_sprintf(b->last, ""%03ui "", status);', 'explanation': 'This code segment ensures that even when the reason-phrase is absent (status_line is NULL), the status line is written with the status code formatted with a trailing space, fulfilling the requirement to always send a space between the status-code and the (possibly absent) reason-phrase.'}}]","The function explicitly formats the status line such that a space is always appended after the status code. When the reason-phrase is not provided, the code uses ngx_sprintf with the format string ""%03ui "" which includes a trailing space. This directly implements the RFC requirement that a space separate the status-code from the reason-phrase even if the latter is absent.",success,
1652,ngx_http_header_filter,"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",225,Partially Matches,"[{'C1': {'code': 'if (r->headers_out.location\n        && r->headers_out.location->value.len\n        && r->headers_out.location->value.data[0] == \'/\' \n        && clcf->absolute_redirect) {\n    r->headers_out.location->hash = 0;\n\n    if (clcf->server_name_in_redirect) {\n        cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n        host = cscf->server_name;\n    } else if (r->headers_in.server.len) {\n        host = r->headers_in.server;\n    } else {\n        host.len = NGX_SOCKADDR_STRLEN;\n        host.data = addr;\n\n        if (ngx_connection_local_sockaddr(c, &host, 0) != NGX_OK) {\n            return NGX_ERROR;\n        }\n    }\n    ...\n    if (host.data) {\n        p = b->last + sizeof(""Location: "") - 1;\n        b->last = ngx_cpymem(b->last, ""Location: http"", sizeof(""Location: http"") - 1);\n\n#if (NGX_HTTP_SSL)\n        if (c->ssl) {\n            *b->last++ =\'s\';\n        }\n#endif\n        *b->last++ = \':\'; *b->last++ = \'/\'; *b->last++ = \'/\';\n        b->last = ngx_copy(b->last, host.data, host.len);\n        ...\n    } else {\n        ngx_str_null(&host);\n        port = 0;\n    }', 'explanation': 'This segment shows that when an absolute redirect is to be generated, the code obtains a host identifier from configuration (or falls back to the local socket address). It only generates a Location header if host.data is non-null, thereby indirectly preventing the creation of an https URI with an empty host. However, it does not explicitly verify that the host string is non-empty, relying on the assumption that one of the lookup methods will always supply valid data.'}}]","The function contains logic for constructing an absolute URL in a Location header for redirects. When the redirect URL is built, a host identifier is obtained from several sources, and the code checks whether host.data is valid before inserting it into the URL. This indicates an attempt to enforce that an https URI is not generated with an empty host. However, the check is only for the presence of a pointer (host.data) without explicitly verifying a non-empty host string. Thus, while the code handles the intended behavior partially, it does not fully enforce the RFC requirement as a direct condition.",success,
1652,ngx_http_header_filter,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,61,Fully Matches,"[{'C1': {'code': 'if (r->method == NGX_HTTP_HEAD) {\n    r->header_only = 1;\n}', 'explanation': ""This snippet explicitly checks if the request is a HEAD request and then sets the 'header_only' flag to 1, ensuring that no response body content is sent. This directly implements the RFC requirement that HEAD responses must not include content.""}}]","The function visibly implements the RFC specification for the HEAD method by setting the 'header_only' flag when the method is HEAD. By doing so, it guarantees that only header information is sent in the response and no body content is generated, which fulfills the stated RFC requirement. All the logic to prevent sending of content for HEAD requests is contained within this function.",success,
1652,ngx_http_header_filter,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'A1': {'code': 'else if (r->keepalive) {\n    b->last = ngx_cpymem(b->last, ""Connection: keep-alive"" CRLF,\n                         sizeof(""Connection: keep-alive"" CRLF) - 1);\n\n    if (clcf->keepalive_header) {\n        b->last = ngx_sprintf(b->last, ""Keep-Alive: timeout=%T"" CRLF,\n                              clcf->keepalive_header);\n    }\n} else {\n    b->last = ngx_cpymem(b->last, ""Connection: close"" CRLF,\n                         sizeof(""Connection: close"" CRLF) - 1);\n}', 'explanation': ""The function directly supports persistent connections by checking the 'r->keepalive' flag and adding the appropriate 'Connection: keep-alive' header. This matches the RFC requirement that HTTP implementations SHOULD support persistent connections by default.""}}]","The provided function 'ngx_http_header_filter' constructs the HTTP response header and explicitly includes logic to support persistent connections. It verifies whether the connection should be kept alive (using the 'r->keepalive' flag) and writes the 'Connection: keep-alive' header when applicable. This behavior directly implements the RFC specification regarding persistent connections, and thus the function fully meets the persistent connection support requirement as outlined in the spec.",success,
1652,ngx_http_header_filter,The type/subtype MAY be followed by semicolon-delimited parameters (Section 5.6.6) in the form of name/value pairs.,259,Fully Matches,"[{'C1': {'code': 'if (r->headers_out.content_type.len) {\n    b->last = ngx_cpymem(b->last, ""Content-Type: "", sizeof(""Content-Type: "") - 1);\n    p = b->last;\n    b->last = ngx_copy(b->last, r->headers_out.content_type.data, r->headers_out.content_type.len);\n\n    if (r->headers_out.content_type_len == r->headers_out.content_type.len\n        && r->headers_out.charset.len)\n    {\n        b->last = ngx_cpymem(b->last, ""; charset="", sizeof(""; charset="") - 1);\n        b->last = ngx_copy(b->last, r->headers_out.charset.data, r->headers_out.charset.len);\n\n        /* update r->headers_out.content_type for possible logging */\n        r->headers_out.content_type.len = b->last - p;\n        r->headers_out.content_type.data = p;\n    }\n    *b->last++ = CR; *b->last++ = LF;\n}', 'explanation': 'This code builds the Content-Type header and conditionally appends a semicolon-delimited charset parameter when the entire base type has been specified and a charset exists, directly reflecting the RFC’s requirement that a media type MAY be followed by semicolon-delimited parameters.'}}]","The function constructs HTTP response headers and specifically handles the Content-Type header by checking if a charset parameter is present. When it is, the function appends it using a semicolon delimiter ('; charset='), which aligns with the RFC specification that a media type may include semicolon-delimited parameters. Thus, the key aspect of the RFC regarding media type parameters is implemented directly within this function.",success,
1652,ngx_http_header_filter,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Does Not Match,[],"The RFC specification requires that a sender MUST NOT include a Content-Length header if a Transfer-Encoding header is used. In this function, there is no explicit check or logic to remove or avoid sending the Content-Length header when Transfer-Encoding (specifically chunked encoding) is enabled. The Content-Length header is printed if r->headers_out.content_length is NULL and r->headers_out.content_length_n is non-negative, regardless of whether r->chunked is set. Therefore, the function does not fully implement the specified RFC constraint.",success,
1658,ngx_http_special_response_handler,"A server MUST read the entire request message body or close the connection after sending its response; otherwise, the remaining data on a persistent connection would be misinterpreted as the next request.",312,Fully Matches,"[{'C1': {'code': 'if (ngx_http_discard_request_body(r) != NGX_OK) {\n    r->keepalive = 0;\n}', 'explanation': 'This segment explicitly attempts to read/discard the entire request body. If the discard fails, it disables keepalive to ensure that any remaining data is not misinterpreted as the next request, directly fulfilling the RFC requirement.'}}]","The RFC mandates that the server must read the entire request message body or close the connection after sending its response. In this function, the call to ngx_http_discard_request_body(r) (and the subsequent check that disables keepalive upon failure) directly addresses that requirement. Thus, the function alone visibly attempts to implement the necessary behavior to conform to the specified HTTP RFC.",success,
1658,ngx_http_special_response_handler,HTTP implementations SHOULD support persistent connections.,311,Partially Matches,"[{'C1': {'code': 'if (r->keepalive) {\n    switch (error) {\n        case NGX_HTTP_BAD_REQUEST:\n        case NGX_HTTP_REQUEST_ENTITY_TOO_LARGE:\n        case NGX_HTTP_REQUEST_URI_TOO_LARGE:\n        case NGX_HTTP_TO_HTTPS:\n        case NGX_HTTPS_CERT_ERROR:\n        case NGX_HTTPS_NO_CERT:\n        case NGX_HTTP_INTERNAL_SERVER_ERROR:\n        case NGX_HTTP_NOT_IMPLEMENTED:\n            r->keepalive = 0;\n    }\n}\n\n...\n\nif (ngx_http_discard_request_body(r) != NGX_OK) {\n    r->keepalive = 0;\n}', 'explanation': 'This segment checks if the connection is marked for keepalive and selectively disables it under certain error conditions or if discarding the request body fails. This indicates that the function is aware of the need to maintain persistent connections (a core requirement of HTTP/1.1) and takes action to disable persistent behavior when problematic scenarios occur.'}}]","The RFC specifies that HTTP implementations SHOULD support persistent connections. In the provided function, there is visible logic that inspects the 'keepalive' flag and conditionally disables it based on specific error conditions, as well as ensuring the request body is properly discarded before attempting to maintain the connection. This shows that the function is taking steps to uphold persistent connection support as per the RFC. However, the function does not fully handle all aspects of persistent connection management (for example, it does not parse the protocol version or directly process the Connection header) and likely relies on earlier phases of the HTTP request processing to set the keepalive flag. Therefore, in isolation, the function only partially meets the RFC constraint.",success,
1661,ngx_http_send_error_page,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function ngx_http_send_error_page does not include any explicit logic to enforce or validate that the protocol elements (such as the generated URI or Location header) conform to the ABNF grammar as required by the RFC. There is no code that checks or transforms these generated values to ensure they match the grammar defined by the corresponding ABNF rules (i.e. the spec constraint regarding sender behavior). As such, the function does not visibly address the labeled condition (e.g., C1) stating that a sender MUST NOT generate protocol elements that do not match the grammar.",success,
1661,ngx_http_send_error_page,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The RFC specification requires that a sender must not generate multiple header fields with the same name (unless specifically allowed) and that their order is preserved. In the provided code function, there is no visible logic that checks for or prevents the insertion of duplicate header fields. The function simply pushes a new 'Location' header into the headers list without checking if a header with the same name already exists or handling the field order beyond a simple append. Therefore, the function does not address the labeled spec constraint within its own code.",success,
1661,ngx_http_send_error_page,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function focuses on error page handling, redirection (both internal and external), and header construction. It does not contain any explicit logic that enforces the RFC requirement regarding roles—namely, that within a given message a sender must not generate protocol elements or syntax alternatives reserved for other roles. There is no visible check or mechanism that ensures the function restricts protocol element generation based on participant role. Therefore, no part of the function visibly addresses the specific RFC constraint.",success,
1661,ngx_http_send_error_page,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'location = ngx_list_push(&r->headers_out.headers);\nif (location == NULL) {\n    return NGX_ERROR;\n}\nif (overwrite != NGX_HTTP_MOVED_PERMANENTLY\n    && overwrite != NGX_HTTP_MOVED_TEMPORARILY\n    && overwrite != NGX_HTTP_SEE_OTHER\n    && overwrite != NGX_HTTP_TEMPORARY_REDIRECT\n    && overwrite != NGX_HTTP_PERMANENT_REDIRECT)\n{\n    r->err_status = NGX_HTTP_MOVED_TEMPORARILY;\n}\n\nlocation->hash = 1;\nlocation->next = NULL;\nngx_str_set(&location->key, ""Location"");\nlocation->value = uri;\n\nr->headers_out.location = location;', 'explanation': ""This code segment creates a new header entry, sets its key to 'Location', and assigns it the URI value, which directly implements the spec requirement that the server SHOULD generate a Location header field with a URI reference for the different URI.""}}]","The function_body contains explicit logic to generate and set a Location header when the URI does not indicate an internal redirection (i.e., the URI does not start with '/' or '@'). This directly meets the RFC specification mentioned and fully implements the action constraint that requires a Location header be present in the response.",success,
1661,ngx_http_send_error_page,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,160,Partially Matches,"[{'C1': {'code': 'location = ngx_list_push(&r->headers_out.headers);\n...\nngx_str_set(&location->key, ""Location"");\nlocation->value = uri;', 'explanation': ""The function adds a 'Location' header to the response when the error page URL is not an internal or named redirection. This implements the requirement to include a Location header containing a new URI reference. However, it does not specifically ensure that the URI is the 'preferred permanent' one as described by the 308 specification.""}}]","The function shows logic to generate a 'Location' header by pushing a header element into r->headers_out.headers and setting its key to 'Location' with the computed URI. This addresses part of the RFC specification stated in the spec. However, while the function does generate the header, it leaves some ambiguity regarding whether the URI is the preferred permanent one (e.g., as required for 308 Permanent Redirect). Therefore, only a portion of the requirement is met by this function in isolation.",success,
1661,ngx_http_send_error_page,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'A1': {'code': 'location = ngx_list_push(&r->headers_out.headers);\nif (location == NULL) {\n    return NGX_ERROR;\n}\n\nif (overwrite != NGX_HTTP_MOVED_PERMANENTLY\n    && overwrite != NGX_HTTP_MOVED_TEMPORARILY\n    && overwrite != NGX_HTTP_SEE_OTHER\n    && overwrite != NGX_HTTP_TEMPORARY_REDIRECT\n    && overwrite != NGX_HTTP_PERMANENT_REDIRECT)\n{\n    r->err_status = NGX_HTTP_MOVED_TEMPORARILY;\n}\n\nlocation->hash = 1;\nlocation->next = NULL;\nngx_str_set(&location->key, ""Location"");\nlocation->value = uri;\n\nngx_http_clear_location(r);\n\nr->headers_out.location = location;', 'explanation': ""This code segment explicitly creates and sets a 'Location' header field in the HTTP response with the provided URI. This directly addresses the RFC requirement that the server should generate a Location header field containing a URI reference for the different URI.""}}]","The function 'ngx_http_send_error_page' implements the behavior specified in the RFC by generating a Location header in the HTTP response. The specific code segment shown above allocates a new header element, sets its key to 'Location', assigns it the URI, and attaches it to the response, thereby fully implementing the required action.",success,
1662,ngx_http_send_special_response,"An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",268,Does Not Match,[],"The provided function (ngx_http_send_special_response) is responsible for constructing and sending error response pages, handling content length, content type, and additional padding. There is no logic within this function that addresses or enforces the RFC requirement that an origin server SHOULD NOT rely on private agreements to receive content. In other words, the function does not implement any checks, conditions, or mechanisms related to the concern expressed in the specification. Therefore, it does not visibly address any labeled condition or action from the spec constraints.",success,
1662,ngx_http_send_special_response,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Does Not Match,[],"The RFC requires that the sender must not include a Content-Length header if a Transfer-Encoding header is present. In the provided function, there is no condition that checks whether a Transfer-Encoding header is present. The function calculates a content length (stored in r->headers_out.content_length_n) and then unconditionally clears any existing r->headers_out.content_length header field. There is no logic that ties the removal of the Content-Length header specifically to the presence of a Transfer-Encoding header field. Therefore, the function does not visibly implement the RFC constraint as specified by the HTTP RFC.",success,
1662,ngx_http_send_special_response,An origin server without a clock MUST NOT generate a Last-Modified date for a response unless that date value was assigned to the resource by some other system (presumably one with a clock).,55,Partially Matches,"[{'C1': {'code': 'ngx_http_clear_last_modified(r);', 'explanation': 'This function call explicitly clears any Last-Modified header from the response. By doing so, it prevents the generation of a Last-Modified date if one has not been explicitly set (as would be required if the resource was assigned by another system with a clock), which is in line with the RFC requirement for an origin server without a clock.'}}]","The RFC specification requires that an origin server without a clock MUST NOT generate a Last-Modified date unless it was provided by another system. In the provided function, the call to ngx_http_clear_last_modified(r) fulfills this requirement by ensuring that no Last-Modified header is sent. However, the specification also contains additional context regarding servers with clocks (such as replacing future modification dates with the message origination date), and the function does not address that part. Therefore, while the function addresses the aspect of not generating a Last-Modified header, it does not handle all conditions described in the RFC, leading to a 'Partially Matches' outcome.",success,
1662,ngx_http_send_special_response,"An origin server with a clock (as defined in Section 5.6.7) MUST NOT generate a Last-Modified date that is later than the server's time of message origination (Date, Section 6.6.1).",54,Does Not Match,[],"The provided function does not contain any logic that checks or adjusts the Last-Modified date relative to the server's current time as required by the RFC. Although the function calls ngx_http_clear_last_modified(r) to remove any Last-Modified header (thereby avoiding sending a potentially incorrect header), it does not implement the logic to replace a future Last-Modified value with the message origination date. Since this logic is not visibly present within the function_body itself, the function does not attempt to implement the specified HTTP RFC constraint regarding Last-Modified dates.",success,
1662,ngx_http_send_special_response,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'C1': {'code': 'if (r->headers_out.content_length) {\n    r->headers_out.content_length->hash = 0;\n    r->headers_out.content_length = NULL;\n}', 'explanation': 'This segment ensures that any pre-existing Content-Length header is removed so that an incorrect or previously set Content-Length value is not forwarded. It addresses the RFC requirement by discarding any existing header rather than reusing potentially incorrect data.'}}]","The function recalculates the content length for error responses and explicitly clears any previously set Content-Length header. This approach prevents forwarding an incorrect Content-Length value as mandated by the RFC. However, the function does not explicitly validate the incoming Content-Length for correct formatting (e.g., checking for repeated decimal values) nor does it conditionally reject based on known incorrectness—it simply overrides it. Thus, while it visibly implements part of the RFC requirement (as labeled by C1), the implementation is partial. The logic to remove the header is contained entirely within this function and does not defer to dependencies, meeting the minimal requirement, but it does not cover all nuanced rules described in the broader RFC specification.",success,
1662,ngx_http_send_special_response,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'A1': {'code': 'if (ngx_http_error_pages[err].len) {\n    r->headers_out.content_length_n = ngx_http_error_pages[err].len + len;\n    if (clcf->msie_padding\n        && (r->headers_in.msie || r->headers_in.chrome)\n        && r->http_version >= NGX_HTTP_VERSION_10\n        && err >= NGX_HTTP_OFF_4XX)\n    {\n        r->headers_out.content_length_n += sizeof(ngx_http_msie_padding) - 1;\n        msie_padding = 1;\n    }\n    ...\n} else {\n    r->headers_out.content_length_n = 0;\n}\n\n... \nif (r->headers_out.content_length) {\n    r->headers_out.content_length->hash = 0;\n    r->headers_out.content_length = NULL;\n}\n\nrc = ngx_http_send_header(r);', 'explanation': 'The function computes the total content length (combining the error page length, extra tail data, and optional padding) and assigns the value to the content_length_n field before sending the header. This reflects an attempt to implement the RFC recommendation to include a Content-Length header when the content size is known.'}}]","The provided function shows logic to calculate and set the Content-Length header when producing an error response, which partially implements the RFC requirement of sending a Content-Length header when the content size is known. However, the function does not include handling for the special cases noted in the RFC context (e.g., not sending Content-Length for 1xx, 204, or CONNECT responses) nor does it check for the presence of Transfer-Encoding. Consequently, while some aspects of the RFC are addressed (specifically, including a Content-Length when the size is known), the implementation is only partial with respect to the complete set of conditions and actions specified.",success,
1662,ngx_http_send_special_response,"If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type.",35,Does Not Match,[],"The RFC specification is concerned with handling responses when a Content-Type header is not provided—allowing the recipient to assume a media type of 'application/octet-stream' or inspect the content. In the provided function, however, the error response always sets a Content-Type header to 'text/html' (see the segment where r->headers_out.content_type is set), leaving no logic to implement the fallback behavior required by the RFC if the header is absent. Thus, no part of the function addresses the condition or action described in the RFC specification.",success,
1662,ngx_http_send_special_response,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'if (ngx_http_error_pages[err].len) {\n    r->headers_out.content_length_n = ngx_http_error_pages[err].len + len;\n    ...\n    r->headers_out.content_type_len = sizeof(""text/html"") - 1;\n    ngx_str_set(&r->headers_out.content_type, ""text/html"");\n    r->headers_out.content_type_lowcase = NULL;\n} else {\n    r->headers_out.content_length_n = 0;\n}', 'explanation': 'The code explicitly checks if there is an error page content (i.e. the message contains content) and then sets the Content-Type header field to ""text/html"". This directly addresses the RFC requirement that a sender should generate a Content-Type header if the intended media type of the enclosed representation is known.'}}]","The function inspects whether an error page exists (i.e., content is available) and when it does, it sets the Content-Type header. This matches the RFC specification that a message containing content should include a Content-Type header field when the media type is known. All logic addressing the condition is contained within the function, making the implementation self-sufficient with respect to the specified constraint.",success,
1664,ngx_http_send_refresh,"An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",268,Does Not Match,[],"The provided function, ngx_http_send_refresh, is focused on constructing an HTML response for a client refresh (i.e., generating a meta refresh response) and escaping a location string. There is no logic that addresses the RFC specification constraint regarding how an origin server should not rely on private agreements to receive content. None of the labeled conditions or actions (e.g., C1 or A1) related to that constraint are implemented within this function's code.",success,
1664,ngx_http_send_refresh,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Fully Matches,"[{'C1': {'code': 'if (r->headers_out.content_length) {\n    r->headers_out.content_length->hash = 0;\n    r->headers_out.content_length = NULL;\n}', 'explanation': 'This code snippet ensures that any pre-existing Content-Length header is cleared (i.e. not forwarded) so that an incorrect Content-Length value is not sent. This directly addresses the requirement not to forward a message with a known incorrect Content-Length header.'}}, {'A1': {'code': 'r->headers_out.content_length_n = size;', 'explanation': 'This line sets the correct Content-Length value calculated from the actual response body (size), replacing any prior (possibly incorrect) Content-Length header. It implements the action of using the computed value rather than forwarding an incorrect header.'}}]","The function recalculates the response body's size and assigns it to r->headers_out.content_length_n. Additionally, if a Content-Length header exists, it is explicitly cleared to prevent forwarding a potentially incorrect value. This implementation directly addresses the spec requirement that a sender MUST NOT forward a message with a known incorrect Content-Length header, thereby fully matching the constraint within the function itself.",success,
1664,ngx_http_send_refresh,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function 'ngx_http_send_refresh' does not implement any logic to handle or enforce the HTTP RFC constraint regarding multiple header field lines with the same name or their order. The spec requires that senders avoid generating multiple header lines with the same name (or properly combine them into a comma‐separated list when allowed), and the order must be preserved. This function only operates on a single 'location' header (and later sets it to NULL) without addressing any scenario involving multiple fields or preserving their order. Therefore, no parts of the function contain specific code addressing constraints like C1 or actions like A1 as specified.",success,
1664,ngx_http_send_refresh,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'escape = 2 * ngx_escape_uri(NULL, location, len, NGX_ESCAPE_REFRESH);\n...\nif (escape == 0) {\n    p = ngx_cpymem(p, location, len);\n} else {\n    p = (u_char *) ngx_escape_uri(p, location, len, NGX_ESCAPE_REFRESH);\n}', 'explanation': ""This code segment computes the required escaping for the 'location' value using ngx_escape_uri with the NGX_ESCAPE_REFRESH flag, and conditionally uses the escaped output to generate the refresh content. This demonstrates an attempt to enforce that the generated protocol element (the refresh HTML) conforms to the grammar defined by the corresponding ABNF rules as required by the RFC specification.""}}]","The function_body includes logic to escape and properly embed the URL within a refresh meta tag, thereby addressing the RFC requirement that a sender must not generate protocol elements that do not match the defined ABNF grammar. However, the implementation focuses only on the refresh mechanism and URL escaping, and does not cover the full breadth of protocol element generation. Consequently, it partially meets the specified constraint.",success,
1664,ngx_http_send_refresh,"An origin server with a clock (as defined in Section 5.6.7) MUST NOT generate a Last-Modified date that is later than the server's time of message origination (Date, Section 6.6.1).",54,Does Not Match,[],"The provided function ngx_http_send_refresh is responsible for constructing a refresh HTML response and handling a location header for redirection. It does clear the Last-Modified header by calling ngx_http_clear_last_modified(r), but it does not implement any logic to compare or replace a Last-Modified date based on the server's time of message origination as required by the RFC specification. The spec requires that an origin server MUST NOT generate a Last-Modified date later than the server's Date header value, and if the modification time is in the future, it must be replaced by the Date. This function does not include any code to perform such a check or replacement; it simply clears the header. Therefore, no part of the function visibly addresses the conditions (C1, etc.) or actions (A1, etc.) described in the specification.",success,
1664,ngx_http_send_refresh,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Fully Matches,"[{'A1': {'code': 'r->headers_out.content_length_n = size;', 'explanation': 'The function computes the total size of the response content (including head, potentially escaped location, and tail) and explicitly sets the Content-Length header value. This directly implements the RFC requirement for generating a length‐delimited message when possible.'}}]","The RFC specifies that, because it is impossible to distinguish a fully received close-delimited response from one interrupted by network failure, a server should generate an encoded or length-delimited message whenever possible. In this function, the code calculates the response body's total length (using the computed 'size') and assigns it to 'r->headers_out.content_length_n' before sending the header and body. This ensures that the generated response is length-delimited. All of this logic is contained within 'ngx_http_send_refresh', meaning that the function visibly addresses the RFC requirement by itself.",success,
1664,ngx_http_send_refresh,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Fully Matches,"[{'A1': {'code': 'r->headers_out.content_length_n = size;', 'explanation': 'The function computes the size of the response body (combining fixed header & tail segments and the escaped location string) and then explicitly assigns it to r->headers_out.content_length_n. This directly implements the RFC requirement that if the content size is known and no Transfer-Encoding is used, the Content-Length header field SHOULD be sent.'}}]","The function determines the content length by calculating the sum of the sizes of predefined HTML segments and the processed location string, and then directly sets the content length field (r->headers_out.content_length_n = size). By doing so, it visibly addresses the RFC specification that mandates sending the Content-Length header when the response body length is known. Although other contextual conditions (such as not sending Content-Length for 1xx, 204 responses or 2xx CONNECT responses) are part of the full spec, in this function the response is set to NGX_HTTP_OK (200), making the setting of the Content-Length header fully compliant with the RFC requirement for this case. Dependencies are not taken into account as per instructions, so only the logic within the function is considered, and it meets the requirement.",success,
1664,ngx_http_send_refresh,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Fully Matches,"[{'C1': {'code': 'r->headers_out.location->hash = 0;\n    r->headers_out.location = NULL;', 'explanation': 'This segment removes the Location header from the outgoing response. According to the RFC specification, the sender must not generate protocol elements reserved for other roles. By explicitly clearing the Location header, the function ensures that it does not emit a header element that might only be allowed to be generated in another context.'}}, {'A1': {'code': 'if (r->headers_out.content_length) {\n    r->headers_out.content_length->hash = 0;\n    r->headers_out.content_length = NULL;\n}', 'explanation': 'This code clears the Content-Length header if it exists, which is part of ensuring that protocol elements not permitted for this role are not sent. It complements the removal of headers like Location by ensuring that only the approved message syntax (an HTML refresh page) is generated.'}}]","The function constructs an HTML refresh response intended for a specific role (as used with MSIE) and deliberately clears certain headers (e.g., Location and Content-Length) that are not meant to be generated by the sender in this context. This logic directly addresses the RFC requirement that a sender must not generate protocol elements or syntax alternatives reserved for participants in other roles, thereby making the implementation fully compliant with the specified constraint.",success,
1664,ngx_http_send_refresh,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Does Not Match,[],"The RFC specifies that a sender MUST NOT send a Content-Length header field when a Transfer-Encoding header field is present. In this function, there is no conditional check or logic to verify if the Transfer-Encoding header is present before setting the Content-Length header (through r->headers_out.content_length_n). The function unconditionally calculates and assigns a content length irrespective of any Transfer-Encoding header, and there is no code that prevents sending a Content-Length header when Transfer-Encoding is set. Therefore, the function does not address the specified HTTP RFC constraint.",success,
1664,ngx_http_send_refresh,An origin server without a clock MUST NOT generate a Last-Modified date for a response unless that date value was assigned to the resource by some other system (presumably one with a clock).,55,Partially Matches,"[{'C1': {'code': 'ngx_http_clear_last_modified(r);', 'explanation': 'The function explicitly clears the Last-Modified header, ensuring that no Last-Modified date is generated. This directly addresses the RFC requirement for an origin server without a clock not to generate a Last-Modified date unless that date was externally assigned.'}}]","The function clears the Last-Modified header (as well as related headers such as ETag and Accept-Ranges) before sending the response. This indicates an attempt to satisfy the aspect of the RFC that prevents generating a Last-Modified date for responses from an origin server without a clock. However, it does not include any additional logic related to validating or adjusting a Last-Modified date against the server's current time or handling externally assigned dates. Therefore, while the function implements a part of the specification, its handling is limited to clearing the header, leading to a partial match.",success,
1664,ngx_http_send_refresh,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'r->headers_out.content_type_len = sizeof(""text/html"") - 1;\nngx_str_set(&r->headers_out.content_type, ""text/html"");', 'explanation': ""The function sets the Content-Type header field to 'text/html' when generating the response content. This directly implements the RFC requirement that a message containing content SHOULD include a Content-Type header unless the media type is unknown.""}}]","The code function explicitly sets the Content-Type header before sending the response. By doing so, it addresses the RFC specification stating that a sender that generates a message containing content should generate a Content-Type header field. Although the provided spec context includes a charset parameter, the minimal requirement of including a Content-Type header is met by the function, thereby fully matching the intended constraint.",success,
1686,ngx_http_complex_value_size,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'if (ngx_http_complex_value(r, val, &value) != NGX_OK) {\n    return default_value;\n}', 'explanation': 'This segment checks whether evaluating the complex value was successful. If not, it recovers by returning a default value, thereby attempting to recover a usable protocol element from an invalid construct as the RFC permits.'}}, {'A1': {'code': 'if (size == (size_t) NGX_ERROR) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""invalid size \\""%V\\"""", &value);\n    return default_value;\n}', 'explanation': 'This code path logs an error when parsing the size fails and recovers by returning a default value. It reflects the RFC notion that a recipient MAY attempt recovery, even in the face of an invalid parsed element.'}}]","The function implements error handling logic by checking for NULL values, failure in complex value resolution, and invalid size parsing. In each failure case, it recovers by returning a default value. This approach reflects the RFC's allowance for attempting to recover a usable protocol element from an invalid construct. However, while these recovery mechanisms address some aspects of the specification, the function does not cover all of the protocol's detailed semantics or error handling strategies outlined in the full specification context. Thus, the implementation partially meets the labeled constraints.",success,
1686,ngx_http_complex_value_size,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (val == NULL) {\n    return default_value;\n}\n\nif (val->lengths == NULL) {\n    return val->u.size;\n}\n\nif (ngx_http_complex_value(r, val, &value) != NGX_OK) {\n    return default_value;\n}', 'explanation': 'These checks show that the function is defensive in approach, verifying that input pointers are valid and that the computed value is reliably produced. It falls back to a default value if certain preconditions are not met.'}}, {'A1': {'code': 'size = ngx_parse_size(&value);\n\nif (size == (size_t) NGX_ERROR) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""invalid size \\""%V\\"""", &value);\n    return default_value;\n}', 'explanation': 'This segment logs an error when parsing fails and returns a safe default value, showing an action taken in response to nonconforming input as expected by the RFC.'}}]","The function demonstrates a defensive parsing strategy by checking for null pointers, ensuring results from sub-calls are valid, and using a fallback for parsing errors. These measures align with the RFC’s suggestion to parse protocol elements defensively. However, it does not impose any explicit limits on buffer size or verify that the parsed sizes are within any specific 'reasonable' bound, meaning it only partially satisfies the full breadth of the RFC’s guidelines.",success,
1761,ngx_http_file_cache_new,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The RFC specification requires that while a cache MAY be employed by a client or server, it cannot be used when acting as a tunnel. The provided function solely allocates and initializes a cache structure (e.g., using ngx_pcalloc and ngx_array_init) and assigns it to the request. There is no logic in the function to check whether the request is coming through a tunnel or to disable caching in that case. Since the function does not include any condition or action (e.g., checking for tunnel mode) that directly addresses the spec constraint, it does not visibly implement the specified HTTP RFC constraint.",success,
1762,ngx_http_file_cache_create,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The RFC requires that while a client or server may employ a cache, a cache must not be used while the entity is acting as a tunnel. In the provided function, there is no logic checking if the request is being handled as a tunnel, nor is there any condition that prevents cache operations under tunnel conditions. The function only initializes the cache, adds a cleanup handler, and verifies the existence and correctness of the cache name. Therefore, none of the spec constraints (e.g., ensuring that a cache is not used when acting as a tunnel) are directly addressed within this function.",success,
1765,ngx_http_file_cache_open,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided RFC specification mandates that a cache may be employed unless the entity is acting as a tunnel, but the function_body does not contain any logic checking or handling a scenario where the client or server is acting as a tunnel. None of the code segments reference tunnel-related conditions or actions, and therefore, this function does not visibly implement any of the specified constraints (e.g., checking for a tunnel state). Thus, the function does not meet the requirements of the spec as stated.",success,
1769,ngx_http_file_cache_lock_wait_handler,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided function ngx_http_file_cache_lock_wait_handler handles cache lock waiting events, logs related debug messages, and manages request events after the lock wait, but it does not include any logic addressing the specific RFC specification that 'a cache cannot be used while acting as a tunnel'. There is no check or conditional behavior within the function that detects or prevents usage of the cache during tunnel operations, nor does it relate its operation to this particular requirement. Therefore, within the function body, there is no visible implementation of any labeled constraint from the spec.",success,
1775,ngx_http_file_cache_exists,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided RFC specification states that a cache may be used by any client or server but must not be used while acting as a tunnel. The function ngx_http_file_cache_exists only implements lower-level cache lookup and management logic (e.g., checking for an existing cache node, updating its usage counters, and handling its expiration) and does not include any logic to determine or enforce whether the client or server is acting as a tunnel. Therefore, no part of the function addresses the specific condition or action outlined in the RFC regarding cache usage conflicts with tunnel mode.",success,
1779,ngx_http_file_cache_vary,"A recipient MUST parse and ignore a reasonable number of empty list elements: enough to handle common mistakes by senders that merge values, but not so much that they could be used as a denial-of-service mechanism.",237,Fully Matches,"[{'C1': {'code': ""while (p < last && (*p == ' ' || *p == ',')) { p++; }"", 'explanation': 'This loop explicitly skips over spaces and commas, thereby parsing and ignoring any empty list elements. In doing so, it implements the requirement to ignore empty tokens as specified in the RFC.'}}]","The function processes the vary header string by first converting it to lowercase and then iterating through the string. Before extracting each token (list element), it advances the pointer past any spaces or commas. This mechanism directly causes the function to ignore any empty elements, meeting the RFC directive to parse and ignore a reasonable number of empty list elements. The implementation is contained solely within this function, without reliance on dependencies, and thus fully addresses the specified condition.",success,
1779,ngx_http_file_cache_vary,"In other words, a recipient MUST accept lists that satisfy the following syntax:",238,Partially Matches,"[{'C1': {'code': ""while (p < last && (*p == ' ' || *p == ',')) { p++; }"", 'explanation': 'This loop skips over spaces and commas, which is an attempt to ignore empty elements as required by the RFC.'}}, {'A1': {'code': ""name.data = p;\n\nwhile (p < last && *p != ',' && *p != ' ') { p++; }\n\nname.len = p - name.data;\n\nif (name.len == 0) {\n    break;\n}"", 'explanation': 'This shows that the code extracts tokens from the list and, when encountering an empty token (i.e. a token of length 0), it stops processing further tokens. This is an effort to process list elements but does not fully implement the RFC’s requirement to ignore empty elements throughout.'}}]","The function processes a comma or space‐separated list by lowercasing the value and tokenizing it. It attempts to address the RFC requirement of handling lists with potentially empty elements by skipping initial delimiters. However, the use of a break when an empty token is encountered may cause premature termination rather than simply ignoring an empty element and continuing to process the rest of the list. As a result, while some logic that mirrors the RFC conditions (C1: accepting lists with empty items, and A1: processing non-empty tokens) is present, the approach is only a partial match to the RFC’s intent.",success,
1779,ngx_http_file_cache_vary,"In any production that uses the list construct, a sender MUST NOT generate empty list elements.",236,Partially Matches,"[{'C1': {'code': ""while (p < last && (*p == ' ' || *p == ',')) { p++; }\n\nname.data = p;\n\nwhile (p < last && *p != ',' && *p != ' ') { p++; }\n\nname.len = p - name.data;\n\nif (name.len == 0) {\n    break;\n}"", 'explanation': 'The spec requires that a sender MUST NOT generate empty list elements. Within the function, after skipping commas and whitespace, it picks an element from the input and immediately checks if its length is 0 (i.e. an empty element). If so, it breaks out of the loop, effectively not processing an empty element. This shows an intent to avoid incorporating empty list elements into the MD5 hash. However, the implementation simply stops further processing rather than handling or filtering empty elements while continuing with valid ones, which means it only partially meets the specification.'}}]","The function processes a comma-delimited list by skipping over spaces and commas, then parses each element and checks for an empty element. When an empty element is encountered (name.len == 0), it breaks out of the loop. This behavior is an attempt to ensure no empty list elements are processed (thus not 'generated' in the hash), aligning partially with the spec constraint. However, because it simply stops processing rather than properly filtering or error handling empty elements, the implementation only partially addresses the requirement.",success,
1780,ngx_http_file_cache_vary_header,"In any production that uses the list construct, a sender MUST NOT generate empty list elements.",236,Partially Matches,"[{'C1': {'code': ""while (p < last && (*p == ' ' || *p == ',')) { p++; }\n...\nstart = p;\n...\nwhile (p < last && *p != ',' && *p != ' ') { p++; }\nlen = p - start;\nif (len == 0) { break; }"", 'explanation': 'For header names that require normalization (e.g., Accept-Charset, Accept-Encoding, Accept-Language), the function scans the header value by skipping commas and spaces. It then computes the token length and, if an empty token is detected (len equals 0), the loop is broken rather than processing an empty token. This prevents the generation of an empty list element in the MD5 update process, thereby addressing the constraint from the spec. However, the scenario when the header is not normalized (i.e., for headers other than the listed ones) merely concatenates the raw header value without checks that explicitly exclude empty elements. Hence, the function only partially implements the spec constraint within its normalization branch.'}}]","The RFC requires that senders must not generate empty elements in list constructs. In the normalization branch for certain headers, the function actively avoids processing empty tokens by skipping over separators and checking that each token has a nonzero length before updating the MD5 hash. This logic addresses the constraint for these cases (labeled here as C1). However, since the function does not apply similar scrutiny in the non‐normalization branch (where it simply concatenates header values), it only partially matches the full scope of the spec constraint. Dependencies and overall list production are outside the function, hence only the normalization logic qualifies as implementing the RFC requirement.",success,
1783,ngx_http_file_cache_set_header,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Fully Matches,"[{'C1': {'code': '*p = LF;', 'explanation': 'The RFC requires that the sender must not generate a bare CR (i.e. a CR not immediately followed by LF). In this function, only LF is appended (without any CR), ensuring that it does not generate any bare CR.'}}]","The function exclusively writes LF at the end of the header (via *p = LF;) and does not emit any CR character. This directly prevents the generation of any bare CR and thus satisfies the RFC requirement. All the necessary logic for this rule is present within the function_body, and no additional CR is produced, which means the function fully implements the intended constraint.",success,
1787,ngx_http_cache_send,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The RFC specifies that while a client or server is permitted to employ a cache, it must not do so when acting as a tunnel. In the provided function_body, although cached content is being sent (indicating the use of a cache), there is no logic checking or enforcing that the cache is not used when the connection is acting as a tunnel. No condition (e.g., verifying that the request is not a tunnel) or corresponding actions are implemented within this function. Hence, within the function_body itself, the specified RFC constraint is not addressed.",success,
1802,ngx_http_file_cache_manage_file,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The RFC specification states that any client or server may employ a cache, but a cache cannot be used while acting as a tunnel. The provided function exclusively manages cache files (adding, deleting, sleeping based on loader thresholds) and does not implement any logic to check or restrict cache use in tunnel situations. Thus, within the function_body itself, there is no visible handling of the stated condition from the RFC.",success,
1849,ngx_http_handler,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'C1': {'code': 'if (!r->internal) {\n    switch (r->headers_in.connection_type) {\n    case 0:\n        r->keepalive = (r->http_version > NGX_HTTP_VERSION_10);\n        break;\n\n    case NGX_HTTP_CONNECTION_CLOSE:\n        r->keepalive = 0;\n        break;\n\n    case NGX_HTTP_CONNECTION_KEEP_ALIVE:\n        r->keepalive = 1;\n        break;\n    }\n    ...\n}', 'explanation': 'The code segment checks the HTTP version and the Connection header field to determine whether to enable persistent connections (setting r->keepalive accordingly). This directly addresses the specification requirement that HTTP implementations SHOULD support persistent connections.'}}]","The function implements logic to support persistent connections by assigning r->keepalive based on the HTTP version and Connection header values. This is in alignment with the spec that HTTP/1.1 defaults to persistent connections, thus fully meeting the constraint labeled C1.",success,
1849,ngx_http_handler,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'if (!r->internal) {\n    switch (r->headers_in.connection_type) {\n    case 0:\n        r->keepalive = (r->http_version > NGX_HTTP_VERSION_10);\n        break;\n\n    case NGX_HTTP_CONNECTION_CLOSE:\n        r->keepalive = 0;\n        break;\n\n    case NGX_HTTP_CONNECTION_KEEP_ALIVE:\n        r->keepalive = 1;\n        break;\n    }\n\n    r->lingering_close = (r->headers_in.content_length_n > 0 || r->headers_in.chunked);\n    r->phase_handler = 0;\n}', 'explanation': ""This segment of code checks the Connection header and HTTP version to decide whether to maintain a persistent connection by setting the 'keepalive' flag. This addresses part of the RFC requirement to sustain persistent connections. However, it does not address how the underlying transport's flow-control mechanisms are leveraged to resolve temporary overloads.""}}]","The function implements logic to manage persistent connections by inspecting the HTTP version and the Connection header, which partially meets the RFC guideline that a server SHOULD sustain persistent connections when possible. However, the code does not contain any logic to use the underlying transport's flow-control mechanisms to handle temporary overloads, and therefore it only partially matches the overall specification.",success,
1853,ngx_http_core_find_config_phase,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'if (rc == NGX_DONE) {\n    ngx_http_clear_location(r);\n\n    r->headers_out.location = ngx_list_push(&r->headers_out.headers);\n    if (r->headers_out.location == NULL) {\n        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n        return NGX_OK;\n    }\n\n    r->headers_out.location->hash = 1;\n    r->headers_out.location->next = NULL;\n    ngx_str_set(&r->headers_out.location->key, ""Location"");\n\n    if (r->args.len == 0) {\n        r->headers_out.location->value = clcf->escaped_name;\n    } else {\n        len = clcf->escaped_name.len + 1 + r->args.len;\n        p = ngx_pnalloc(r->pool, len);\n\n        if (p == NULL) {\n            ngx_http_clear_location(r);\n            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return NGX_OK;\n        }\n\n        r->headers_out.location->value.len = len;\n        r->headers_out.location->value.data = p;\n\n        p = ngx_cpymem(p, clcf->escaped_name.data, clcf->escaped_name.len);\n        *p++ = \'?\';\n        ngx_memcpy(p, r->args.data, r->args.len);\n    }\n\n    ngx_http_finalize_request(r, NGX_HTTP_MOVED_PERMANENTLY);\n    return NGX_OK;\n}', 'explanation': ""This code segment explicitly creates and initializes a 'Location' header in the response. By allocating a header node, setting its key to 'Location', and populating its value based on the request and configuration, the function ensures that a URI reference for the different URI is included in the response as required by the RFC.""}}]","Within the function, the RFC specification requirement is implemented by generating a 'Location' header field when a redirect condition arises (i.e., when rc equals NGX_DONE). The code allocates, configures, and appends a Location header to the response, fully addressing the stipulated action in the spec. Although additional aspects of the redirect (such as the exact status code) differ from the 307 Temporary Redirect mentioned in the broader context, the function itself correctly generates the header needed as per the RFC.",success,
1853,ngx_http_core_find_config_phase,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,155,Fully Matches,"[{'A1': {'code': 'if (rc == NGX_DONE) {\n    ngx_http_clear_location(r);\n\n    r->headers_out.location = ngx_list_push(&r->headers_out.headers);\n    if (r->headers_out.location == NULL) {\n        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n        return NGX_OK;\n    }\n\n    r->headers_out.location->hash = 1;\n    r->headers_out.location->next = NULL;\n    ngx_str_set(&r->headers_out.location->key, ""Location"");\n\n    if (r->args.len == 0) {\n        r->headers_out.location->value = clcf->escaped_name;\n\n    } else {\n        len = clcf->escaped_name.len + 1 + r->args.len;\n        p = ngx_pnalloc(r->pool, len);\n\n        if (p == NULL) {\n            ngx_http_clear_location(r);\n            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return NGX_OK;\n        }\n\n        r->headers_out.location->value.len = len;\n        r->headers_out.location->value.data = p;\n\n        p = ngx_cpymem(p, clcf->escaped_name.data, clcf->escaped_name.len);\n        *p++ = \'?\';\n        ngx_memcpy(p, r->args.data, r->args.len);\n    }\n\n    ngx_http_finalize_request(r, NGX_HTTP_MOVED_PERMANENTLY);\n    return NGX_OK;\n}', 'explanation': ""The code block under the condition 'if (rc == NGX_DONE)' constructs a Location header by pushing a new header into the response header list, setting its key to 'Location', and assigning the header value from the escaped URI (with an appended query string if applicable). It then finalizes the request with a 301 (Moved Permanently) status, thereby directly implementing the RFC requirement to generate a Location header in the response.""}}]","The function checks for a specific condition (rc == NGX_DONE) and, when true, it explicitly creates and sets a 'Location' header with the preferred URI reference before finalizing the request as a 301 Moved Permanently. This approach fully addresses the spec requirement that the server SHOULD generate a Location header field under a permanent redirection response, fulfilling the labeled action (A1) directly within the function.",success,
1853,ngx_http_core_find_config_phase,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Does Not Match,[],"The RFC requirement is that responses with status codes 1xx or 204 must not include a Content-Length header. This function does not contain any logic that checks the response status code or that prevents inclusion of a Content-Length header in the response. The function mainly focuses on locating configuration, handling client body size issues, and managing redirection (adding a Location header), but it does not address the requirement regarding the Content-Length header as specified.",success,
1853,ngx_http_core_find_config_phase,"An origin server that wishes to ""hide"" the current existence of a forbidden target resource MAY instead respond with a status code of 404 (Not Found).",163,Partially Matches,"[{'A1': {'code': 'if (!r->internal && clcf->internal) {\n    ngx_http_finalize_request(r, NGX_HTTP_NOT_FOUND);\n    return NGX_OK;\n}', 'explanation': 'This code segment returns a 404 (Not Found) response when the resource is marked as internal (i.e. a hidden or forbidden resource). This aligns with the spec’s suggestion that an origin server MAY respond with 404 to hide the existence of a forbidden resource.'}}]","The provided function contains logic that returns a 404 response for resources marked internal (hidden), which addresses the RFC’s behavior of obscuring forbidden target resources. However, the spec context also mentions handling scenarios involving provided but insufficient authentication credentials, a condition which is not checked or implemented in this function. Since only part of the spec requirement is visibly addressed within the function, the overall match is partial.",success,
1853,ngx_http_core_find_config_phase,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,160,Partially Matches,"[{'C1': {'code': 'if (rc == NGX_DONE) {\n    ngx_http_clear_location(r);\n\n    r->headers_out.location = ngx_list_push(&r->headers_out.headers);\n    if (r->headers_out.location == NULL) {\n        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n        return NGX_OK;\n    }\n\n    r->headers_out.location->hash = 1;\n    r->headers_out.location->next = NULL;\n    ngx_str_set(&r->headers_out.location->key, ""Location"");\n\n    if (r->args.len == 0) {\n        r->headers_out.location->value = clcf->escaped_name;\n    } else {\n        len = clcf->escaped_name.len + 1 + r->args.len;\n        p = ngx_pnalloc(r->pool, len);\n\n        if (p == NULL) {\n            ngx_http_clear_location(r);\n            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return NGX_OK;\n        }\n\n        r->headers_out.location->value.len = len;\n        r->headers_out.location->value.data = p;\n\n        p = ngx_cpymem(p, clcf->escaped_name.data, clcf->escaped_name.len);\n        *p++ = \'?\';\n        ngx_memcpy(p, r->args.data, r->args.len);\n    }', 'explanation': ""This code block detects a condition (rc == NGX_DONE) that triggers a redirect response. Within it, the function allocates and sets the 'Location' header field using the preferred URI (clcf->escaped_name) and appends query parameters if present. This addresses the RFC requirement for generating a Location header field containing a new permanent URI.""}}, {'A1': {'code': 'ngx_http_finalize_request(r, NGX_HTTP_MOVED_PERMANENTLY);', 'explanation': 'After setting the Location header, the request is finalized with a redirection status. However, the spec context calls for a 308 (Permanent Redirect) status code, while the code uses NGX_HTTP_MOVED_PERMANENTLY (typically 301). Thus, the function attempts to implement the permanent redirection behavior, but it does not use the exact status code specified by the RFC.'}}]","The function contains a block that sets a Location header field with a preferred URI by using clcf->escaped_name (and optionally appending query parameters), which aligns with the RFC's guidance that a Location header should be included in a permanent redirection response. However, the function finalizes the request with NGX_HTTP_MOVED_PERMANENTLY (typically a 301 status) rather than using a 308 status code as specified. Therefore, while the location header generation is implemented, the precise status code does not fully conform to the RFC, leading to a 'Partially Matches' judgment.",success,
1853,ngx_http_core_find_config_phase,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'A1': {'code': 'if (rc == NGX_DONE) {\n    ngx_http_clear_location(r);\n\n    r->headers_out.location = ngx_list_push(&r->headers_out.headers);\n    if (r->headers_out.location == NULL) {\n        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n        return NGX_OK;\n    }\n\n    r->headers_out.location->hash = 1;\n    r->headers_out.location->next = NULL;\n    ngx_str_set(&r->headers_out.location->key, ""Location"");\n\n    if (r->args.len == 0) {\n        r->headers_out.location->value = clcf->escaped_name;\n    } else {\n        len = clcf->escaped_name.len + 1 + r->args.len;\n        p = ngx_pnalloc(r->pool, len);\n\n        if (p == NULL) {\n            ngx_http_clear_location(r);\n            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return NGX_OK;\n        }\n\n        r->headers_out.location->value.len = len;\n        r->headers_out.location->value.data = p;\n\n        p = ngx_cpymem(p, clcf->escaped_name.data, clcf->escaped_name.len);\n        *p++ = \'?\';\n        ngx_memcpy(p, r->args.data, r->args.len);\n    }\n\n    ngx_http_finalize_request(r, NGX_HTTP_MOVED_PERMANENTLY);\n    return NGX_OK;\n}', 'explanation': ""This code segment checks a specific condition (rc == NGX_DONE) and then creates a 'Location' header by pushing it to the headers list, setting its key to 'Location', and determining its value from the escaped name (with query parameters if present). This directly implements the spec requirement that a Location header field be generated containing a URI reference to a different URI.""}}]","The function contains explicit logic to generate and set a Location header in the response when redirection is needed (i.e., when rc equals NGX_DONE). It creates the header, assigns a key ('Location'), and sets a URI as the value. Although the response status is set to NGX_HTTP_MOVED_PERMANENTLY rather than the 302 (Found) status code mentioned in the broader context, the core requirement—generating a Location header—is fully addressed within this function. Hence, the code fully matches the spec constraint related to header generation.",success,
1862,ngx_http_update_location_config,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'C1': {'code': 'if (r->keepalive) {\n    if (clcf->keepalive_timeout == 0) {\n        r->keepalive = 0;\n    } else if (r->connection->requests >= clcf->keepalive_requests) {\n        r->keepalive = 0;\n    } else if (ngx_current_msec - r->connection->start_time > clcf->keepalive_time) {\n        r->keepalive = 0;\n    } else if (r->headers_in.msie6 && r->method == NGX_HTTP_POST && (clcf->keepalive_disable & NGX_HTTP_KEEPALIVE_DISABLE_MSIE6)) {\n        r->keepalive = 0;\n    } else if (r->headers_in.safari && (clcf->keepalive_disable & NGX_HTTP_KEEPALIVE_DISABLE_SAFARI)) {\n        r->keepalive = 0;\n    }\n}', 'explanation': 'This code segment inspects the r->keepalive flag and imposes various conditions (such as timeout values, max request count, and client-specific workarounds) to determine whether the connection should stay persistent. This logic directly implements support for persistent connections as specified in the HTTP RFC.'}}]","The function contains logic that directly addresses the spec requirement that HTTP implementations SHOULD support persistent connections. It does so by managing the r->keepalive flag based on various conditions (timeout, request limits, and client-specific behavior) which reflect the criteria for maintaining a persistent connection. Thus, within the function_body, the persistent connection support is fully implemented.",success,
1862,ngx_http_update_location_config,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'if (r->keepalive) {\n    if (clcf->keepalive_timeout == 0) {\n        r->keepalive = 0;\n    } else if (r->connection->requests >= clcf->keepalive_requests) {\n        r->keepalive = 0;\n    } else if (ngx_current_msec - r->connection->start_time > clcf->keepalive_time) {\n        r->keepalive = 0;\n    } else if (r->headers_in.msie6 && r->method == NGX_HTTP_POST && (clcf->keepalive_disable & NGX_HTTP_KEEPALIVE_DISABLE_MSIE6)) {\n        r->keepalive = 0;\n    } else if (r->headers_in.safari && (clcf->keepalive_disable & NGX_HTTP_KEEPALIVE_DISABLE_SAFARI)) {\n        r->keepalive = 0;\n    }\n}', 'explanation': ""This code segment checks and sets the r->keepalive flag based on several conditions (timeouts, request counts, browser-specific cases). By doing so, it attempts to sustain persistent connections when possible in accordance with the RFC's recommendation to maintain persistent connections.""}}]","The function updates connection configuration parameters, notably the keepalive settings, to help determine if a connection can be kept persistent. This partially aligns with the RFC requirement for sustaining persistent connections. However, the RFC also stresses using the underlying transport's flow-control mechanisms to handle temporary overloads rather than terminating connections. No mechanism addressing flow-control resolution is visible within this function. Therefore, while the function includes logic for persistent connection checks, it only partially implements the overall spec constraint.",success,
1869,ngx_http_set_content_type,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'if (r->headers_out.content_type.len) {\n    return NGX_OK;\n}\n\n... (later in function) ...\n\nr->headers_out.content_type = clcf->default_type;', 'explanation': 'The function begins by checking if a Content-Type header is already set and, if not, proceeds to assign one. It either determines the media type from the file extension (if recognized) or falls back to a default type, thereby ensuring a Content-Type header is generated when content is present, in accordance with the RFC.'}}, {'A1': {'code': 'if (r->exten.len) {\n    ...\n    type = ngx_hash_find(&clcf->types_hash, hash,\n                         r->exten.data, r->exten.len);\n\n    if (type) {\n        r->headers_out.content_type_len = type->len;\n        r->headers_out.content_type = *type;\n        return NGX_OK;\n    }\n}\n\nr->headers_out.content_type_len = clcf->default_type.len;\nr->headers_out.content_type = clcf->default_type;', 'explanation': 'This segment shows that when the file extension is provided, the function attempts to look up the associated media type. If the lookup fails (i.e., the media type is unknown), it assigns a default content type. This directly addresses the action of setting a Content-Type header based on known or unknown media types.'}}]","The function implements the RFC specification by ensuring that every generated message with content has a Content-Type header. It first checks if the header is already present; if not, it tries to determine the correct media type using the resource's file extension. Should the media type be unknown, it falls back to a predefined default type. This logic is entirely contained within the function_body, fulfilling the spec requirements.",success,
1871,ngx_http_set_etag,"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.",57,Fully Matches,"[{'C1': {'code': 'if (!clcf->etag) {\n    return NGX_OK;\n}\n\netag = ngx_list_push(&r->headers_out.headers);\nif (etag == NULL) {\n    return NGX_ERROR;\n}', 'explanation': 'This segment checks whether the ETag functionality is enabled and then proceeds to add the ETag header to the outgoing response. It directly addresses the RFC’s recommendation to send an ETag when possible.'}}, {'A1': {'code': 'etag->value.data = ngx_pnalloc(r->pool, NGX_OFF_T_LEN + NGX_TIME_T_LEN + 3);\nif (etag->value.data == NULL) {\n    etag->hash = 0;\n    return NGX_ERROR;\n}\n\netag->value.len = ngx_sprintf(etag->value.data, ""\\""%xT-%xO\\"""",\n                              r->headers_out.last_modified_time,\n                              r->headers_out.content_length_n)\n                  - etag->value.data;', 'explanation': 'This code dynamically allocates space and formats the ETag value based on the last modified time and content length. Generating the ETag value this way allows for consistent change detection, which aligns with the RFC’s guidance.'}}]","The function implements the key aspects of the RFC specification by checking if the ETag header should be set (C1) and by generating the ETag header value derived from the last modified time and content length of the response (A1). This logic clearly demonstrates that the function itself, independent of any dependency, is attempting to implement the RFC's recommendation concerning ETag handling.",success,
1871,ngx_http_set_etag,An origin server without a clock MUST NOT generate a Last-Modified date for a response unless that date value was assigned to the resource by some other system (presumably one with a clock).,55,Does Not Match,[],"The provided function, ngx_http_set_etag, is responsible for setting the ETag header based on the last modified time and content length, rather than generating or validating a Last-Modified date per the RFC specification. There is no logic within this function that handles the condition that an origin server without a clock must not generate a Last-Modified date unless it was assigned by another system. Thus, the function does not visibly address any of the specified RFC constraints (such as C1 or corresponding actions).",success,
1872,ngx_http_weak_etag,"If an origin server provides an entity tag for a representation and the generation of that entity tag does not satisfy all of the characteristics of a strong validator (Section 8.8.1), then the origin server MUST mark the entity tag as weak by prefixing its opaque value with ""W/"" (case-sensitive).",266,Fully Matches,"[{'A1': {'code': 'if (etag->value.len > 2\n    && etag->value.data[0] == \'W\'\n    && etag->value.data[1] == \'/\')\n{\n    return;\n}\n...\n\np = ngx_pnalloc(r->pool, etag->value.len + 2);\nif (p == NULL) {\n    r->headers_out.etag->hash = 0;\n    r->headers_out.etag = NULL;\n    return;\n}\n\nlen = ngx_sprintf(p, ""W/%V"", &etag->value) - p;\n\netag->value.data = p;\netag->value.len = len;', 'explanation': 'This code first checks if the ETag is already marked as weak (i.e. starts with ""W/""). If not and if the ETag is valid (begins with a double-quote), it allocates new memory and prefixes the existing ETag value with ""W/"" using sprintf. This directly implements the RFC requirement that an ETag which does not meet the strong validator criteria MUST be marked as weak by adding the ""W/"" prefix.'}}]","The function 'ngx_http_weak_etag' checks for the existence of an ETag header, verifies if it is already weak, and if not, ensures that the ETag is in a valid format before converting it to a weak ETag by prepending ""W/"". This mirrors the RFC directive to mark non-strong validators as weak by prefixing with ""W/"". All pertinent logic to enforce the action specified in the RFC is contained within the function, fulfilling the requirement.",success,
1872,ngx_http_weak_etag,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function is solely concerned with converting or marking an ETag as weak by prepending the ""W/"" prefix. It does not include any logic that verifies the sender's role or checks whether the protocol elements being generated are limited to a particular role as specified in the RFC. Therefore, none of the labeled conditions or actions (e.g., C1, A1) related to role-based generation of protocol elements are addressed within this function.",success,
1874,ngx_http_send_response,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,160,Fully Matches,"[{'A1': {'code': 'if (status == NGX_HTTP_MOVED_PERMANENTLY\n    || status == NGX_HTTP_MOVED_TEMPORARILY\n    || status == NGX_HTTP_SEE_OTHER\n    || status == NGX_HTTP_TEMPORARY_REDIRECT\n    || status == NGX_HTTP_PERMANENT_REDIRECT)\n{\n    ngx_http_clear_location(r);\n\n    r->headers_out.location = ngx_list_push(&r->headers_out.headers);\n    if (r->headers_out.location == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    r->headers_out.location->hash = 1;\n    r->headers_out.location->next = NULL;\n    ngx_str_set(&r->headers_out.location->key, ""Location"");\n    r->headers_out.location->value = val;\n\n    return status;\n}', 'explanation': 'The code explicitly checks if the response status is one of the redirection types (including the permanent redirect corresponding to RFC 308) and then creates a Location header. This directly implements the RFC specification that the server SHOULD generate a Location header field with a preferred URI reference for the new permanent URI.'}}]","The function clearly implements the key RFC requirement by generating a Location header for redirection responses. Within the function_body, when the status matches any kind of redirect (including permanent redirects), it prepares and assigns the Location header with the calculated value. This visible logic meets the RFC constraint that the server SHOULD provide a preferred URI reference in the Location header, making the implementation fully compliant within the scope of the function.",success,
1874,ngx_http_send_response,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,155,Fully Matches,"[{'A1': {'code': 'if (status == NGX_HTTP_MOVED_PERMANENTLY\n        || status == NGX_HTTP_MOVED_TEMPORARILY\n        || status == NGX_HTTP_SEE_OTHER\n        || status == NGX_HTTP_TEMPORARY_REDIRECT\n        || status == NGX_HTTP_PERMANENT_REDIRECT)\n    {\n        ngx_http_clear_location(r);\n\n        r->headers_out.location = ngx_list_push(&r->headers_out.headers);\n        if (r->headers_out.location == NULL) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        r->headers_out.location->hash = 1;\n        r->headers_out.location->next = NULL;\n        ngx_str_set(&r->headers_out.location->key, ""Location"");\n        r->headers_out.location->value = val;\n\n        return status;\n    }', 'explanation': ""This code segment explicitly checks if the status code corresponds to a redirection (including 301 Moved Permanently) and then creates and sets a 'Location' header field with the provided URI value, thereby fulfilling the RFC requirement that a server SHOULD generate a Location header with a preferred URI reference.""}}]","The function 'ngx_http_send_response' contains logic that specifically handles redirection responses by checking if the status code is one of several redirection codes (including 301 Moved Permanently). When the condition is met, it clears any existing location header, allocates a new entry in the header list, and sets the 'Location' header field to the computed URI. This directly implements the RFC's mandate to generate a Location header for permanent redirection responses. Hence, the code fully matches the RFC specification regarding this requirement.",success,
1874,ngx_http_send_response,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'A1': {'code': 'if (status == NGX_HTTP_MOVED_PERMANENTLY\n    || status == NGX_HTTP_MOVED_TEMPORARILY\n    || status == NGX_HTTP_SEE_OTHER\n    || status == NGX_HTTP_TEMPORARY_REDIRECT\n    || status == NGX_HTTP_PERMANENT_REDIRECT)\n{\n    ngx_http_clear_location(r);\n\n    r->headers_out.location = ngx_list_push(&r->headers_out.headers);\n    if (r->headers_out.location == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    r->headers_out.location->hash = 1;\n    r->headers_out.location->next = NULL;\n    ngx_str_set(&r->headers_out.location->key, ""Location"");\n    r->headers_out.location->value = val;\n\n    return status;\n}', 'explanation': ""This code block checks if the status code corresponds to a redirection (including 302 Found via NGX_HTTP_MOVED_TEMPORARILY) and, if so, explicitly creates a 'Location' header with the URI reference contained in 'val'. This directly implements the RFC requirement to generate a Location header for a temporary redirection.""}}]","The function directly inspects the HTTP status code and, when it matches a redirection status (such as 302, 301, 303, etc.), it creates and sets a Location header in the response. This behavior is consistent with the RFC specification that mandates the inclusion of a Location header with an alternate URI for redirection. The implementation is self-contained within the function, thereby fully meeting the specified RFC requirement.",success,
1874,ngx_http_send_response,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'if (ct) {\n        r->headers_out.content_type_len = ct->len;\n        r->headers_out.content_type = *ct;\n    } else {\n        if (ngx_http_set_content_type(r) != NGX_OK) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n    }', 'explanation': 'This segment ensures that a Content-Type header is generated: if a content type is explicitly provided (ct), it directly sets the header; otherwise, it calls ngx_http_set_content_type to determine it. This directly addresses the RFC requirement for including a Content-Type header when the message contains content.'}}]","The provided function implements the RFC specification requirement within its body by ensuring that any outgoing message with content includes a Content-Type header field. The code checks if a content type string is provided and, if so, sets the header. If not, it utilizes a helper function to set a default. This implementation meets the action specified in the RFC and is therefore considered a full match.",success,
1874,ngx_http_send_response,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'if (status == NGX_HTTP_MOVED_PERMANENTLY\n        || status == NGX_HTTP_MOVED_TEMPORARILY\n        || status == NGX_HTTP_SEE_OTHER\n        || status == NGX_HTTP_TEMPORARY_REDIRECT\n        || status == NGX_HTTP_PERMANENT_REDIRECT)\n{\n    ngx_http_clear_location(r);\n\n    r->headers_out.location = ngx_list_push(&r->headers_out.headers);\n    if (r->headers_out.location == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    r->headers_out.location->hash = 1;\n    r->headers_out.location->next = NULL;\n    ngx_str_set(&r->headers_out.location->key, ""Location"");\n    r->headers_out.location->value = val;\n\n    return status;\n}', 'explanation': ""The function checks if the response status is one of several redirect statuses (including temporary redirect 307) and then explicitly creates and assigns a 'Location' header with a URI value. This directly implements the RFC requirement to generate a Location header field when redirection applies.""}}]","The function visibly addresses the RFC specification by checking for specific redirect statuses and, in those cases, explicitly constructing and setting a 'Location' header in the response. This behavior is fully contained within the function_body and directly implements the requirement from the RFC that the server should provide a Location header field with a URI reference.",success,
1874,ngx_http_send_response,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC requirement states that a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. In the provided function, although the code builds HTTP responses (e.g., setting header values, content types, locations, etc.), there is no explicit logic or checks that validate that these generated protocol elements conform to an ABNF grammar. The function assumes that valid values are supplied or controlled elsewhere and does not independently verify or enforce conformity to the ABNF rules. Thus, the function does not visibly implement the spec constraint.",success,
1874,ngx_http_send_response,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function does not contain explicit logic to enforce the RFC constraint that forbids generating multiple header fields with the same name (except when allowed). While in the redirection branch it calls ngx_http_clear_location(r) before adding a single Location header, this is a narrow case and does not address the overall specification (including the importance of header order and avoiding duplicates) within this function itself. No other code segments in this function ensure that duplicate header fields are not generated or that field ordering is preserved as required by the RFC.",success,
1874,ngx_http_send_response,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (status == NGX_HTTP_MOVED_PERMANENTLY\n        || status == NGX_HTTP_MOVED_TEMPORARILY\n        || status == NGX_HTTP_SEE_OTHER\n        || status == NGX_HTTP_TEMPORARY_REDIRECT\n        || status == NGX_HTTP_PERMANENT_REDIRECT)\n{\n    ngx_http_clear_location(r);\n\n    r->headers_out.location = ngx_list_push(&r->headers_out.headers);\n    if (r->headers_out.location == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    r->headers_out.location->hash = 1;\n    r->headers_out.location->next = NULL;\n    ngx_str_set(&r->headers_out.location->key, ""Location"");\n    r->headers_out.location->value = val;\n\n    return status;\n}', 'explanation': ""This segment ensures that the Location header, which is protocol element applicable exclusively to redirection responses (a role-specific part of HTTP messaging), is only generated when the response status is one of the defined redirection statuses. This matches the RFC specification by not generating protocol elements (like a 'Location' header) in messages that do not require them.""}}]","The function shows an intentional effort to restrict the generation of certain protocol elements, such as generating the 'Location' header only for redirection statuses. This helps ensure that a response message only includes protocol elements appropriate for its role. However, aside from this targeted handling, the function does not comprehensively enforce all possible aspects of the RFC requirement. As such, while it partially implements the specified constraint (C1), it does not cover other role-based checks that might be implicit in the complete RFC requirement.",success,
1874,ngx_http_send_response,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'A1': {'code': 'r->headers_out.content_length_n = val.len;', 'explanation': 'This line sets the Content-Length header based on the known length of the response body (val.len), attempting to implement the part of the spec that requires sending a Content-Length header when the content size is known.'}}]","The HTTP RFC specifies that, aside from cases like responses with status 1xx, 204, or a 2xx CONNECT, a Content-Length header should be sent when the content size is known. In the function, while the Content-Length header is indeed set via 'r->headers_out.content_length_n = val.len;' (addressing sending the Content-Length when known, corresponding to action A1), there is no logic to check or avoid sending this header for responses with status codes 1xx or 204 as required by condition C1 in the specification context. Therefore, the function only partially meets the spec constraints.",success,
1875,ngx_http_send_header,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function ngx_http_send_header does not include any logic that verifies whether the protocol elements it generates conform to the grammar defined by the ABNF rules (as required by the RFC specification). The function primarily checks for conditions such as whether header processing has already occurred or if an error status is set, and then delegates header processing to ngx_http_top_header_filter. There is no code within ngx_http_send_header that validates or enforces the syntax dictated by the ABNF rules. Therefore, it does not visibly address the specified constraint.",success,
1875,ngx_http_send_header,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function does not incorporate any logic that verifies or restricts the generation of protocol elements based on sender roles, as required by the specification. Specifically, the spec mandates that a sender must not generate protocol elements or syntax alternatives that are only allowed for participants in other roles. None of the code segments in the function, such as the checks for r->post_action, r->header_sent, or r->err_status, address or enforce this role-based constraint. Thus, in isolation, the function does not implement any of the conditions or actions from the spec constraints.",success,
1944,ngx_http_init_connection,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'A1': {'code': 'if (hc == NULL) {\n    ngx_http_close_connection(c);\n    return;\n}\n\n... (other error paths where ngx_http_close_connection(c) is called)', 'explanation': 'The function includes several branches where, upon an error (e.g. failure to allocate memory or obtain the local socket address), it calls ngx_http_close_connection(c). This is an instance of initiating a connection close, which is in line with the RFC’s permission that a client, server, or proxy MAY close the transport connection at any time.'}}]","The RFC specification allows a client, server, or proxy to close the transport connection at any time, and the function does exercise connection closure in error cases by calling ngx_http_close_connection. However, aside from these error-related closures, the function itself does not implement active monitoring for an incoming closure signal or a graceful close procedure when the connection is idle – aspects mentioned in the broader RFC context. Therefore, while the function partially meets the specification by providing a mechanism for closing the connection, it does not fully implement the full range of behavior described in the RFC, hence the overall partial match.",success,
1945,ngx_http_wait_request_handler,"Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.",315,Fully Matches,"[{'C1': {'code': 'if (c->close) {\n    ngx_http_close_connection(c);\n    return;\n}\n\n...\n\nif (n == 0) {\n    ngx_log_error(NGX_LOG_INFO, c->log, 0, ""client closed connection"");\n    ngx_http_close_connection(c);\n    return;\n}', 'explanation': 'The function continuously checks for closure signals on the connection. It looks for an explicit close flag (c->close) and detects when the client has closed the connection (recv returns 0), fulfilling the requirement to monitor active connections for closure signals.'}}, {'A1': {'code': 'ngx_http_close_connection(c);', 'explanation': 'Upon detecting a timeout, an explicit close flag, or a closed connection (n == 0), the function promptly closes the connection by calling ngx_http_close_connection, which aligns with the action of closing connections to reclaim system resources.'}}]","The function implements the RFC requirement by proactively monitoring connection states (checking for timeout, explicit c->close, and zero bytes read) and by invoking the connection closure routine when a closure signal is detected. This direct handling within the function fully addresses the spec's mandate for monitoring and responding to closure signals.",success,
1945,ngx_http_wait_request_handler,The server MUST NOT process any further requests received on that connection.,320,Partially Matches,"[{'C1': {'code': 'if (c->close) {\n    ngx_http_close_connection(c);\n    return;\n}', 'explanation': ""This segment checks if the connection has the 'close' flag set and immediately closes the connection, thereby ensuring that no further requests are processed on that connection in accordance with the RFC requirement.""}}]","The function contains logic to handle a connection marked to be closed, which aligns with the part of the specification requiring that the server must not process any further requests on that connection. However, other aspects of the spec—such as sending a 'close' option in the final response and initiating a connection closure after the response—is not addressed within this function. Therefore, only some of the spec constraints are implemented here.",success,
1945,ngx_http_wait_request_handler,A client or server that wishes to time out SHOULD issue a graceful close on the connection.,314,Fully Matches,"[{'C1': {'code': 'if (rev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");\n    ngx_http_close_connection(c);\n    return;\n}', 'explanation': ""This segment checks if the event timed out and, if so, logs the timeout and closes the connection. This directly addresses the spec's condition that a client or server wishing to time out should eventually lead to connection closure.""}}, {'A1': {'code': 'ngx_http_close_connection(c);', 'explanation': 'Invoked in multiple cases (both when rev->timedout and when c->close are true), this call cleanly closes the connection, which aligns with the requirement to issue a graceful close on timeout.'}}]","The function monitors for conditions that indicate the connection should be closed—specifically, if a timeout has occurred or if a closure flag is set. When either is detected, it logs an appropriate message and calls ngx_http_close_connection(c) to close the connection. This handling directly implements the HTTP RFC requirement that a client or server that wishes to time out should issue a graceful close on the connection, fulfilling the labeled constraint.",success,
1945,ngx_http_wait_request_handler,"A client, server, or proxy MAY close the transport connection at any time.",316,Fully Matches,"[{'C1': {'code': 'if (rev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");\n    ngx_http_close_connection(c);\n    return;\n}', 'explanation': ""This block checks if the connection timed out and then closes the connection, which aligns with the spec's allowance for closing the connection when needed.""}}, {'A1': {'code': 'if (c->close) {\n    ngx_http_close_connection(c);\n    return;\n}', 'explanation': ""This segment closes the connection if the 'close' flag is set, demonstrating that the function actively triggers connection closure as allowed by the RFC.""}}, {'C2': {'code': 'if (n == NGX_ERROR) {\n    ngx_http_close_connection(c);\n    return;\n}\n\nif (n == 0) {\n    ngx_log_error(NGX_LOG_INFO, c->log, 0, ""client closed connection"");\n    ngx_http_close_connection(c);\n    return;\n}', 'explanation': 'These conditions handle cases where errors occur or the client has closed the connection, ensuring that the connection is closed in these scenarios as permitted by the RFC.'}}]","The function actively monitors the connection state for various closure triggers such as timeouts, explicit close requests (c->close), errors, and client-initiated shutdowns. Each scenario leads to a call to ngx_http_close_connection(), which implements the RFC specification stating that a client, server, or proxy may close the transport connection at any time. All relevant closure logic is contained within the function, thereby fully meeting the provided spec constraints.",success,
1949,ngx_http_process_request_line,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (r->header_in->pos == r->header_in->end) {\n    rv = ngx_http_alloc_large_header_buffer(r, 1);\n\n    if (rv == NGX_ERROR) {\n        ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n        break;\n    }\n\n    if (rv == NGX_DECLINED) {\n        r->request_line.len = r->header_in->end - r->request_start;\n        r->request_line.data = r->request_start;\n\n        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                      ""client sent too long URI"");\n        ngx_http_finalize_request(r, NGX_HTTP_REQUEST_URI_TOO_LARGE);\n        break;\n    }\n}', 'explanation': 'This code segment defends against oversized request elements by checking whether the current header buffer is exhausted and then attempting to allocate a larger header buffer. If allocation is declined (i.e. the request exceeds what is considered reasonable), it logs an error and finalizes the request, thus enforcing defensive parsing as per the RFC.'}}, {'A1': {'code': 'for ( ;; ) {\n    if (rc == NGX_AGAIN) {\n        n = ngx_http_read_request_header(r);\n        if (n == NGX_AGAIN || n == NGX_ERROR) {\n            break;\n        }\n    }\n\n    rc = ngx_http_parse_request_line(r, r->header_in);\n\n    if (rc == NGX_OK) {\n        // ... parsing succeeded; further processing follows\n    }\n\n    if (rc != NGX_AGAIN) {\n        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                      ngx_http_client_errors[rc - NGX_HTTP_CLIENT_ERROR]);\n        if (rc == NGX_HTTP_PARSE_INVALID_VERSION) {\n            ngx_http_finalize_request(r, NGX_HTTP_VERSION_NOT_SUPPORTED);\n        } else {\n            ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        }\n        break;\n    }\n    \n    // Additional defensive logic may reallocate buffers or break out as needed\n}', 'explanation': 'The loop in the function repeatedly attempts to parse the request line while handling incomplete input (NGX_AGAIN) and various error conditions. It demonstrates a defensive parsing strategy, where errors in format or an invalid protocol element lead to appropriate error responses, as suggested by the RFC.'}}]","The function 'ngx_http_process_request_line' implements a defensive approach to parsing HTTP request lines by continuously reading from the input buffer, checking for incomplete or malformed data, and handling errors such as timeouts or oversized request headers. It explicitly checks for the condition where the received protocol element might exceed a reasonable length and defers to error handling (via buffer reallocation attempts and specific error codes) if necessary. Although some parsing details (e.g. ABNF compliance) are handled in helper functions like 'ngx_http_parse_request_line', the logic within this function clearly attempts to address both the defensive parsing and reasonable buffer-size constraints mandated by the RFC.",success,
1949,ngx_http_process_request_line,"A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain.",298,Fully Matches,"[{'C1': {'code': 'if (rc != NGX_AGAIN) {\n    ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                  ngx_http_client_errors[rc - NGX_HTTP_CLIENT_ERROR]);\n\n    if (rc == NGX_HTTP_PARSE_INVALID_VERSION) {\n        ngx_http_finalize_request(r, NGX_HTTP_VERSION_NOT_SUPPORTED);\n    } else {\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    }\n    break;\n}', 'explanation': 'This segment shows that when the request-line parsing fails (which could be due to disallowed whitespace or other malformed content), the function immediately finalizes the request with an error code rather than attempting any autocorrection. This aligns with the RFC requirement that a recipient SHOULD NOT autocorrect and then process the request.'}}, {'A1': {'code': 'if (rc == NGX_HTTP_PARSE_INVALID_VERSION) {\n    ngx_http_finalize_request(r, NGX_HTTP_VERSION_NOT_SUPPORTED);\n} else {\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n}', 'explanation': 'This portion of the code demonstrates that upon detecting an invalid request-line, the function responds with the appropriate error (400 Bad Request or a version-related error), which satisfies the RFC directive for responding to malformed requests.'}}]","The function processes the HTTP request line and, upon encountering an invalid request-line (which could be due to disallowed whitespace or other malformations), it immediately finalizes the request with an error response rather than attempting any form of autocorrection. This behavior meets the RFC’s requirement that a recipient should not autocorrect a malformed request-line without a redirect. Although the RFC allows for a 301 redirect with proper encoding, opting for a 400 error here is compliant with the specification's alternatives. All logic addressing the spec is contained within this function, thus the implementation fully matches the constraints.",success,
1949,ngx_http_process_request_line,A server that receives a request-target longer than any URI it wishes to parse MUST respond with a 414 (URI Too Long) status code (see Section 15.5.15 of [HTTP]).,179,Fully Matches,"[{'A1': {'code': 'if (r->header_in->pos == r->header_in->end) {\n    rv = ngx_http_alloc_large_header_buffer(r, 1);\n\n    if (rv == NGX_ERROR) {\n        ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n        break;\n    }\n\n    if (rv == NGX_DECLINED) {\n        r->request_line.len = r->header_in->end - r->request_start;\n        r->request_line.data = r->request_start;\n\n        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                      ""client sent too long URI"");\n        ngx_http_finalize_request(r, NGX_HTTP_REQUEST_URI_TOO_LARGE);\n        break;\n    }\n}', 'explanation': 'This segment checks if the request header buffer has been completely read and then attempts to allocate a larger buffer. If the allocation is declined (rv == NGX_DECLINED), it logs an error about a too-long URI and finalizes the request with NGX_HTTP_REQUEST_URI_TOO_LARGE (HTTP 414), thereby directly implementing the RFC requirement.'}}]","The provided function contains explicit logic to detect when the request-target (URI) exceeds the allowed size. When the buffer is full and no larger buffer can be allocated, the function finalizes the request with a 414 (URI Too Long) status code. This behavior directly implements the action specified in the HTTP RFC, fulfilling the requirement as per the given constraints.",success,
1949,ngx_http_process_request_line,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'C1': {'code': 'if (rc != NGX_AGAIN) {\n    ngx_log_error(..., ngx_http_client_errors[rc - NGX_HTTP_CLIENT_ERROR]);\n\n    if (rc == NGX_HTTP_PARSE_INVALID_VERSION) {\n        ngx_http_finalize_request(r, NGX_HTTP_VERSION_NOT_SUPPORTED);\n    } else {\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    }\n    break;\n}', 'explanation': 'The function handles an invalid request-line by finalizing the request with a 400 (Bad Request) error (or version not supported in one branch). This partially addresses the RFC requirement where recipients of an invalid request-line should reject the attempt. However, it does not implement the alternative action of issuing a 301 redirect with a properly encoded request-target.'}}]","The provided function clearly detects errors in the request-line parsing and responds by finalizing the request with a 400 error, which meets part of the specification (responding with a 400 error on an invalid request-line). However, the RFC also permits responding with a 301 redirect along with proper encoding of the request-target when the request-line is invalid due to issues like disallowed whitespace. This function does not implement any logic that would perform a 301 redirect or otherwise correct the request-target. As a result, while the function does address part of the spec by sending a 400 error, it does not cover all parts of the requirement, leading to a 'Partially Matches' judgment.",success,
1949,ngx_http_process_request_line,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",175,Partially Matches,"[{'C1': {'code': 'if (rc != NGX_AGAIN) {\n    ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                  ngx_http_client_errors[rc - NGX_HTTP_CLIENT_ERROR]);\n\n    if (rc == NGX_HTTP_PARSE_INVALID_VERSION) {\n        ngx_http_finalize_request(r, NGX_HTTP_VERSION_NOT_SUPPORTED);\n    } else {\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    }\n    break;\n}', 'explanation': 'This segment checks if the request line cannot be parsed correctly. In the event of a parsing error (i.e. when the incoming octets do not match the expected HTTP-message grammar), the function finalizes the request with a 400 (Bad Request) response (or 505 in the case of an invalid version). This behavior directly reflects the RFC requirement to respond with a 400 and close the connection when the message grammar is not met.'}}]","The function reads and parses the HTTP request line and, upon encountering errors in the request grammar, responds by finalizing the request with a 400 (or appropriate) error code, which matches part of the RFC specification. However, the RFC also requires special handling of whitespace between the start-line and header fields. The code does not visibly implement logic to either reject or strip invalid whitespace-preceded lines as described in the spec context. As a result, while the error handling for malformed request lines is implemented, the additional whitespace handling requirement is not addressed in this function, leading to a partial match.",success,
1950,ngx_http_process_request_uri,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'A1': {'code': 'if (ngx_http_parse_complex_uri(r, cscf->merge_slashes) != NGX_OK) {\n    r->uri.len = 0;\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0, ""client sent invalid request"");\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;\n}', 'explanation': 'This code segment finalizes the request with a 400 Bad Request error when the complex URI cannot be parsed. The RFC spec allows an invalid request-line to be handled with a 400 error, so this logic addresses that part of the requirement.'}}, {'A2': {'code': '#if (NGX_WIN32)\n{\n    u_char  *p, *last;\n\n    p = r->uri.data;\n    last = r->uri.data + r->uri.len;\n\n    while (p < last) {\n        if (*p++ == \':\') {\n            if (p < last && *p == \'$\') {\n                ngx_log_error(NGX_LOG_INFO, r->connection->log, 0, ""client sent unsafe win32 URI"");\n                ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n                return NGX_ERROR;\n            }\n        }\n    }\n    ...\n}\n#endif', 'explanation': 'This Windows-specific block checks for unsafe characters in the URI that could indicate an invalid request. When such a condition is found, the request is rejected with a 400 error. This further supports the RFC guideline of rejecting malformed request-lines.'}}]","The function detects problematic URIs and rejects them with a 400 Bad Request error, which complies with one acceptable approach in the RFC for handling invalid request-lines. However, the RFC also allows for a 301 redirect with proper encoding of the request-target. Since this function does not implement any logic to perform a redirect or re-encode the request-target before processing, it only partially matches the complete specification.",success,
1950,ngx_http_process_request_uri,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function processes and validates an incoming request URI by parsing its components and checking for unsafe constructs (e.g., on Windows). However, it does not include any logic that governs or restricts the generation of protocol elements by a sender based on role permissions as required by the RFC specification. The RFC mandate is aimed at ensuring a sender does not generate syntax alternatives that belong to other roles, but the function is only concerned with parsing and validating incoming data, not with generating protocol elements. Therefore, no part of the function visibly addresses the specified condition or action from the RFC.",success,
1950,ngx_http_process_request_uri,"If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.",202,Partially Matches,"[{'A1': {'code': 'if (ngx_http_parse_complex_uri(r, cscf->merge_slashes) != NGX_OK) {\n    r->uri.len = 0;\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent invalid request"");\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;\n}\n\n// ...\n\nif (*p == \':\') {\n    if (p < last && *p == \'$\') {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent unsafe win32 URI"");\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        return NGX_ERROR;\n    }\n}', 'explanation': 'The function finalizes the request by sending a 400 (Bad Request) status code when it encounters errors during URI parsing or detects an unsafe Win32 URI. This behavior implements part of the RFC requirement that unrecoverable errors in a request message result in a 400 response and connection closure.'}}]","The RFC specification requires that when an unrecoverable error is detected in a request message, the server must respond with a 400 (Bad Request) and close the connection. This function partially meets that requirement by calling ngx_http_finalize_request with NGX_HTTP_BAD_REQUEST in case of URI parsing failures or unsafe URIs. However, the RFC also encompasses other scenarios (such as invalid Content-Length or transfer coding issues) that this function does not address. Since the error handling in this function is limited to URI issues and does not cover all conditions laid out in the RFC spec, the overall implementation is only a partial match.",success,
1950,ngx_http_process_request_uri,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (ngx_http_parse_complex_uri(r, cscf->merge_slashes) != NGX_OK) {\n    r->uri.len = 0;\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent invalid request"");\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;\n}', 'explanation': 'This segment shows that the function verifies the syntax of a complex URI by calling a parser and, if the result isn’t OK, it logs the error and terminates the request. This is a defensive measure in line with a portion of the RFC requirement to parse protocol elements defensively.'}}, {'A1': {'code': 'r->uri.data = ngx_pnalloc(r->pool, r->uri.len);\nif (r->uri.data == NULL) {\n    ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n    return NGX_ERROR;\n}', 'explanation': 'This part performs defensive memory allocation for the URI buffer and properly handles a failure by closing the request and returning an error. It demonstrates one aspect of defensive programming required by the RFC.'}}]","The function attempts to implement defensive parsing of the request URI by calculating lengths dynamically, allocating memory with error checking, and using a helper function to validate complex URIs. It also includes additional defensive checks (such as the Win32-specific validation of unsafe URI characters). However, while it addresses portions of the RFC requirement (such as handling allocation failures and invalid inputs), it does not fully implement checks regarding conformance to an ABNF grammar or enforce a reasonable buffer size directly within this function. As a result, the function only partially matches the defensive parsing expectations described in the RFC.",success,
1951,ngx_http_process_request_headers,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",175,Partially Matches,"[{'A1': {'code': 'if (rc == NGX_HTTP_PARSE_INVALID_HEADER) {\n    ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                  ""client sent invalid header line: \\""%*s\\x%02xd...\\"""",\n                  r->header_end - r->header_name_start,\n                  r->header_name_start, *r->header_end);\n\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    break;\n}', 'explanation': 'This segment detects an invalid header line (i.e. when the received bytes do not match the HTTP-message grammar) and finalizes the request with a 400 (Bad Request) response, thereby closing the connection as required by the spec.'}}]","The function processes incoming HTTP header lines and, upon encountering an invalid header (i.e. a header that does not conform to expected HTTP-message grammar), logs an error and calls ngx_http_finalize_request with NGX_HTTP_BAD_REQUEST (400). This directly addresses the action of responding with a 400 response and closing the connection as stated in the RFC specification. However, the RFC also requires that a recipient receiving whitespace between the start-line and header fields must either reject the message or consume the whitespace lines, but the function does not have explicit logic addressing whitespace-preceded lines. As a result, while the function handles the general invalid header case, it only partially meets the overall RFC requirement.",success,
1951,ngx_http_process_request_headers,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (r->header_in->pos == r->header_in->end) {\n    rv = ngx_http_alloc_large_header_buffer(r, 0);\n\n    if (rv == NGX_ERROR) {\n        ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n        break;\n    }\n\n    if (rv == NGX_DECLINED) {\n        p = r->header_name_start;\n        r->lingering_close = 1;\n\n        if (p == NULL) {\n            ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                          ""client sent too large request"");\n            ngx_http_finalize_request(r, NGX_HTTP_REQUEST_HEADER_TOO_LARGE);\n            break;\n        }\n\n        len = r->header_in->end - p;\n\n        if (len > NGX_MAX_ERROR_STR - 300) {\n            len = NGX_MAX_ERROR_STR - 300;\n        }\n\n        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                      ""client sent too long header line: \\""%*s...\\"""",\n                      len, r->header_name_start);\n\n        ngx_http_finalize_request(r, NGX_HTTP_REQUEST_HEADER_TOO_LARGE);\n        break;\n    }\n}', 'explanation': 'This segment checks for the adequacy of the header buffer and allocates more space or terminates the request if the header is too long, thus defensively handling input that might exceed expected limits.'}}, {'A1': {'code': 'if (rc == NGX_HTTP_PARSE_INVALID_HEADER) {\n    ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                  ""client sent invalid header line: \\""%*s\\x%02xd...\\"""",\n                  r->header_end - r->header_name_start,\n                  r->header_name_start, *r->header_end);\n\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    break;\n}', 'explanation': 'This segment captures and rejects malformed header lines by logging the error and finalizing the request, which exemplifies the defensive parsing of protocol elements that might not strictly conform to the expected ABNF grammar.'}}]","The function implements defensive parsing as required by the RFC by checking for conditions such as a full header buffer, overly long header lines, and invalid header formats. It allocates additional buffer if possible, and when encountering input that does not fit within reasonable limits or does not conform to the expected grammar, it logs the error and terminates the connection. This logic is fully contained within the function, thus fulfilling the defensive parsing criteria described in the spec.",success,
1953,ngx_http_read_request_header,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (n == 0) {\n    ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                  ""client prematurely closed connection"");\n}\n\nif (n == 0 || n == NGX_ERROR) {\n    c->error = 1;\n    c->log->action = ""reading client request headers"";\n\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;\n}', 'explanation': 'The code explicitly checks for a condition where no bytes are received (n == 0), which indicates that the client closed the connection. It then logs an informational message, marks the connection as erroneous, and finalizes the request, which is a response to the possibility described in the spec that the connection might be closed at any time.'}}, {'A1': {'code': 'if (n == NGX_AGAIN) {\n    if (!rev->timer_set) {\n        cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n        ngx_add_timer(rev, cscf->client_header_timeout);\n    }\n\n    if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n        ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n        return NGX_ERROR;\n    }\n\n    return NGX_AGAIN;\n}', 'explanation': ""Though not directly handling 'connection closed' events, this segment attempts to set a timer and manage read events properly. This is an effort toward handling scenarios such as timeouts and indirectly connection closures, aligning with the concept of maintaining persistent connections or handling abrupt closures. However, it does not manage a graceful shutdown explicitly as described in the more complete RFC context.""}}]","The function addresses the possibility that a client may close the connection by checking for a 0-byte read result and then finalizing the request, thereby reclaiming resources. It also sets timers and manages read events as part of processing the request header. However, it only partially covers the broader specifications detailed in the RFC context regarding graceful connection closure and the nuances of persistent connection management. Thus, the implementation in this function only partially matches the full intent of the specification.",success,
1953,ngx_http_read_request_header,"A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.",310,Partially Matches,"[{'C1': {'code': 'if (n == 0) {\n    ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                  ""client prematurely closed connection"");\n}\n\nif (n == 0 || n == NGX_ERROR) {\n    c->error = 1;\n    c->log->action = ""reading client request headers"";\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;\n}', 'explanation': 'These code segments detect an incomplete request (when no data is received or an error occurs) and trigger sending an error response by finalizing the request with a BAD_REQUEST status.'}}]","The provided function checks if the incoming request header is incomplete (n == 0 or an error condition) and responds by setting an error flag and finalizing the request with a HTTP_BAD_REQUEST, thereby sending an error response as permitted by the RFC. However, while this implements the error response for an incomplete request, it does not address other parts of the RFC (such as client handling of incomplete responses), so it only partially matches the full specification.",success,
1954,ngx_http_alloc_large_header_buffer,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (r->state != 0\n        && (size_t) (r->header_in->pos - old) >= cscf->large_client_header_buffers.size)\n    {\n        return NGX_DECLINED;\n    }', 'explanation': 'This segment defensively checks that the length of the header does not exceed the allowed buffer size, aligning with the idea of not assuming a perfect conformance to expected lengths.'}}, {'A1': {'code': 'if (r->header_in->pos - old > b->end - b->start) {\n    ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,\n                  ""too large header to copy"");\n    return NGX_ERROR;\n}', 'explanation': 'Before copying header data to a new buffer, this check ensures that the size of the data being copied fits within the allocated space, thus acting as a defensive measure.'}}]","The function implements parts of the defensive parsing strategy as outlined in the RFC: it checks the header's size against a configured limit and verifies that buffer space is sufficient before copying header data. These measures are in line with the RFC's call for defensive parsing. However, the function only addresses buffer size management and safe memory copying, without fully handling other aspects (such as comprehensive ABNF grammar validation or more nuanced error handling) that might also be expected from a fully defensive parser. Therefore, the function partially meets the RFC requirements.",success,
1956,ngx_http_process_unique_header_line,A server MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message that lacks a Host header field and to any request message that contains more than one Host header field line or a Host header field with an invalid field value.,181,Partially Matches,"[{'C1': {'code': 'if (*ph == NULL) {\n    *ph = h;\n    h->next = NULL;\n    return NGX_OK;\n}\n\nngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n              ""client sent duplicate header line: \\""%V: %V\\"", previous value: \\""%V: %V\\"""",\n              &h->key, &h->value, &(*ph)->key, &(*ph)->value);\n\nngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n\nreturn NGX_ERROR;', 'explanation': 'This code segment detects the occurrence of a duplicate header (by checking if the header pointer has already been assigned) and responds by finalizing the request with a 400 (Bad Request) status, thereby fulfilling the RFC requirement for handling multiple Host header lines. However, it does not address cases where the Host header is missing or contains an invalid field value.'}}]","The function implements logic to detect and handle duplicate header lines by issuing a 400 Bad Request response. This addresses one part of the RFC requirement, specifically the scenario involving a request with more than one Host header line. It does not, however, assess or handle requests that are missing the Host header or present an invalid header field value. Thus, the function only partially matches the overall specification.",success,
1956,ngx_http_process_unique_header_line,"If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.",202,Fully Matches,"[{'A1': {'code': 'ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);', 'explanation': 'When a duplicate header line is detected (an unrecoverable error in the request), the function calls ngx_http_finalize_request with NGX_HTTP_BAD_REQUEST (400), which directly implements the RFC requirement to respond with a 400 status code and then close the connection.'}}]","The function checks for duplicate header lines, and in the case where a duplicate is found, it logs the incident and finalizes the request with a 400 (Bad Request) response. This behavior directly corresponds to the spec's mandate to handle unrecoverable errors in a request by responding with a 400 status code and closing the connection. All of this logic is contained within the function itself, fulfilling the relevant spec constraint.",success,
1956,ngx_http_process_unique_header_line,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'C1': {'code': 'if (*ph == NULL) {\n    *ph = h;\n    h->next = NULL;\n    return NGX_OK;\n}', 'explanation': 'This code checks whether a header field has already been received. If not, it stores the header, thus ensuring that only one instance of a header is accepted.'}}, {'A1': {'code': 'ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n              ""client sent duplicate header line: \\""%V: %V\\"", previous value: \\""%V: %V\\"""",\n              &h->key, &h->value, &(*ph)->key, &(*ph)->value);\n\nngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n\nreturn NGX_ERROR;', 'explanation': 'This code logs the presence of a duplicate header and terminates the request with an error, thereby rejecting multiple header lines for fields expected to be unique.'}}]","The function implements logic to enforce the RFC requirement regarding duplicate header fields by allowing only one header line per field. It stores the header if it's the first occurrence, and if a duplicate is found, it logs an error and rejects the request. However, the function does not account for the exception where a header field's definition allows multiple values to be combined as a comma-separated list. As a result, while the function visibly addresses the unique header requirement, it only partially implements the overall specification.",success,
1957,ngx_http_process_host,A server MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message that lacks a Host header field and to any request message that contains more than one Host header field line or a Host header field with an invalid field value.,181,Partially Matches,"[{'C1': {'code': 'if (r->headers_in.host) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent duplicate host header: \\""%V: %V\\"", previous value: \\""%V: %V\\"""",\n                  &h->key, &h->value, &r->headers_in.host->key, &r->headers_in.host->value);\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;\n}', 'explanation': 'This block detects if a Host header was already set, which handles the condition where more than one Host header field line is present, and responds with a 400 status.'}}, {'A1': {'code': 'rc = ngx_http_validate_host(&host, r->pool, 0);\n\nif (rc == NGX_DECLINED) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent invalid host header"");\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;\n}', 'explanation': 'This segment validates the host header value and, upon detecting an invalid value, finalizes the request with a 400 Bad Request response.'}}]","The function checks for duplicate Host headers and validates the host header value, issuing a 400 Bad Request for duplicates and invalid values. However, it does not address the scenario where the Host header is missing. Since the specification requires a 400 response in all three cases (missing, duplicate, and invalid), the function only partially matches the RFC requirement by handling two out of three situations.",success,
1957,ngx_http_process_host,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'C1': {'code': 'if (r->headers_in.host) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent duplicate host header: ""%V: %V"", ""\n                  ""previous value: ""%V: %V"""",\n                  &h->key, &h->value, &r->headers_in.host->key,\n                  &r->headers_in.host->value);\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;\n}', 'explanation': 'The function explicitly checks if a host header has already been set. If it has, a duplicate is detected and the request is rejected with an error. This enforces the RFC requirement that multiple field lines with the same name (for headers that do not support multiple values) should not be generated. However, it does not cover all aspects of the RFC (such as reordering of header lines or handling comma-separated lists) and is limited to the host header.'}}]","The code function contains clear logic to detect and reject duplicate 'Host' headers by checking if the header has already been set (thereby addressing the part of the RFC that disallows multiple field lines for headers that do not allow comma-separated values). While this meets the specific constraint regarding duplicate header fields, it does not implement additional instructions from the RFC concerning the ordering of header fields or handling allowed multiple values. Thus, the implementation is only partially matching the overall RFC specification.",success,
1957,ngx_http_process_host,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",175,Partially Matches,"[{'A1': {'code': 'if (r->headers_in.host) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent duplicate host header: \\""%V: %V\\"", previous value: \\""%V: %V\\"""",\n                  &h->key, &h->value, &r->headers_in.host->key, &r->headers_in.host->value);\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;\n}\n\nrc = ngx_http_validate_host(&host, r->pool, 0);\n\nif (rc == NGX_DECLINED) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent invalid host header"");\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;\n}', 'explanation': 'The function checks for duplicate and invalid host header cases and in each instance finalizes the request with a 400 (Bad Request) response. This directly addresses the action of responding with 400 in case of a request that does not conform to expected grammar for the host field, as required by the spec.'}}]","The provided function addresses only a subset of the HTTP-message grammar validations by checking the host header. Specifically, it handles cases such as duplicate host headers and host headers failing validation by issuing a 400 response. However, the full RFC requirement encompasses rejecting any message that does not match the HTTP-message grammar (for instance, handling extraneous whitespace between the start-line and headers). Since this function only concerns host header validation and does not cover all aspects of the HTTP message syntax, it only partially implements the spec constraints.",success,
1958,ngx_http_process_connection,HTTP implementations SHOULD support persistent connections.,311,Partially Matches,"[{'C1': {'code': 'if (ngx_strcasestrn(h->value.data, ""close"", 5 - 1)) {\n    r->headers_in.connection_type = NGX_HTTP_CONNECTION_CLOSE;\n}', 'explanation': ""This segment detects if the 'Connection' header includes 'close', which aligns with checking the header field to decide if the connection should not be persistent.""}}, {'A1': {'code': 'else if (ngx_strcasestrn(h->value.data, ""keep-alive"", 10 - 1)) {\n    r->headers_in.connection_type = NGX_HTTP_CONNECTION_KEEP_ALIVE;\n}', 'explanation': ""This segment sets the connection type to keep-alive if the header includes 'keep-alive', demonstrating support for persistent connections.""}}]","The function examines the 'Connection' header to determine whether the connection should be persistent or closed, which partially addresses the RFC requirement that HTTP implementations SHOULD support persistent connections by using the header field. However, it does not handle the default behavior of assuming persistence for HTTP/1.1 in the absence of a Connection header, so the implementation is only partial.",success,
1960,ngx_http_process_request_header,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",175,Partially Matches,"[{'C1': {'code': 'if (r->headers_in.host == NULL && r->http_version > NGX_HTTP_VERSION_10) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n               ""client sent HTTP/1.1 request without \\""Host\\"" header"");\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;\n}', 'explanation': 'This segment checks that an HTTP/1.1 request contains a Host header and issues a 400 Bad Request if it is missing, which aligns with part of the RFC requirement to reject malformed messages.'}}, {'C2': {'code': 'if (r->headers_in.content_length) {\n    r->headers_in.content_length_n = ngx_atoof(r->headers_in.content_length->value.data,\n                                                  r->headers_in.content_length->value.len);\n    if (r->headers_in.content_length_n == NGX_ERROR) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent invalid \\""Content-Length\\"" header"");\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        return NGX_ERROR;\n    }\n}', 'explanation': 'The function validates the Content-Length header; if parsing fails, it returns a 400. This is consistent with handling malformed message grammar per RFC.'}}, {'C3': {'code': 'if (r->headers_in.transfer_encoding) {\n    if (r->http_version < NGX_HTTP_VERSION_11) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent HTTP/1.0 request with \\""Transfer-Encoding\\"" header"");\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        return NGX_ERROR;\n    }\n    if (r->headers_in.transfer_encoding->value.len == 7\n        && ngx_strncasecmp(r->headers_in.transfer_encoding->value.data,\n                           (u_char *) ""chunked"", 7) == 0)\n    {\n        if (r->headers_in.content_length) {\n            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                          ""client sent \\""Content-Length\\"" and \\""Transfer-Encoding\\"" headers at the same time"");\n            ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n            return NGX_ERROR;\n        }\n        r->headers_in.chunked = 1;\n    } else {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent unknown \\""Transfer-Encoding\\"": \\""%V\\"""",\n                      &r->headers_in.transfer_encoding->value);\n        ngx_http_finalize_request(r, NGX_HTTP_NOT_IMPLEMENTED);\n        return NGX_ERROR;\n    }\n}', 'explanation': 'This code validates the Transfer-Encoding header, ensuring that unsupported or conflicting header values lead to an error response. This conditional handling is part of enforcing correct HTTP message grammar.'}}]","The function visibly enforces several aspects of the HTTP RFC by validating critical header fields (Host, Content-Length, Transfer-Encoding) and responding with 400 (or 501) errors when violations are detected. However, the specified RFC also calls for handling cases like extraneous whitespace between the start-line and header fields, which is not addressed in this function. Thus, while the function partially implements the RFC’s error response requirements, it does not cover all the robustness exceptions (such as whitespace handling) mentioned in the specification.",success,
1960,ngx_http_process_request_header,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (r->headers_in.server.len == 0\n        && ngx_http_set_virtual_server(r, &r->headers_in.server)\n           == NGX_ERROR)\n    {\n        return NGX_ERROR;\n    }', 'explanation': ""This code segment defensively checks that the 'server' header element is non-empty and attempts to set a virtual server if it is missing. This is in line with the requirement that protocol elements be parsed defensively.""}}, {'A1': {'code': 'if (r->headers_in.content_length) {\n    r->headers_in.content_length_n =\n                        ngx_atoof(r->headers_in.content_length->value.data,\n                                  r->headers_in.content_length->value.len);\n\n    if (r->headers_in.content_length_n == NGX_ERROR) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent invalid \\""Content-Length\\"" header"");\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        return NGX_ERROR;\n    }\n}', 'explanation': 'This segment demonstrates defensive parsing by converting the Content-Length header and verifying its validity, rejecting invalid values—an example of handling inputs that may not conform perfectly to expected formats.'}}]","The function implements several defensive checks consistent with the RFC’s recommendation to parse protocol elements defensively. It checks for mandatory headers in HTTP/1.1 (e.g., 'Host'), validates header value formats (e.g., Content-Length and Transfer-Encoding), and rejects potentially unsafe combinations or unknown values, which aligns with the spirit of defensive parsing. However, it does not explicitly address aspects such as verifying conformance to ABNF grammar details or checking that protocol elements fit within a reasonable buffer size. Because only some of the defensive measures described in the spec are handled directly within this function’s scope, the implementation is considered a partial match.",success,
1960,ngx_http_process_request_header,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (r->headers_in.host == NULL && r->http_version > NGX_HTTP_VERSION_10) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent HTTP/1.1 request without \\""Host\\"" header"");\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;\n}', 'explanation': 'This segment checks that any HTTP/1.1 request has a Host header as required by the RFC. By enforcing a Host header if missing, it implements a condition where the received header element must be interpreted according to the specification.'}}, {'A1': {'code': 'if (r->headers_in.content_length) {\n    r->headers_in.content_length_n = ngx_atoof(r->headers_in.content_length->value.data,\n                                                  r->headers_in.content_length->value.len);\n    if (r->headers_in.content_length_n == NGX_ERROR) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent invalid \\""Content-Length\\"" header"");\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        return NGX_ERROR;\n    }\n}', 'explanation': 'This code parses and validates the Content-Length header. It ensures that if a Content-Length header is provided, its value is interpreted properly and validated before proceeding.'}}, {'A2': {'code': 'if (r->headers_in.transfer_encoding) {\n    if (r->http_version < NGX_HTTP_VERSION_11) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent HTTP/1.0 request with \\""Transfer-Encoding\\"" header"");\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        return NGX_ERROR;\n    }\n\n    if (r->headers_in.transfer_encoding->value.len == 7 &&\n        ngx_strncasecmp(r->headers_in.transfer_encoding->value.data, (u_char *) ""chunked"", 7) == 0)\n    {\n        if (r->headers_in.content_length) {\n            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                          ""client sent \\""Content-Length\\"" and \\""Transfer-Encoding\\"" headers at the same time"");\n            ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n            return NGX_ERROR;\n        }\n        r->headers_in.chunked = 1;\n    } else {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent unknown \\""Transfer-Encoding\\"": \\""%V\\"""",\n                      &r->headers_in.transfer_encoding->value);\n        ngx_http_finalize_request(r, NGX_HTTP_NOT_IMPLEMENTED);\n        return NGX_ERROR;\n    }\n}', 'explanation': ""This block validates the Transfer-Encoding header. It not only checks that HTTP/1.1 or later is used, but also enforces that if using Transfer-Encoding it must specifically be 'chunked' (and not used alongside Content-Length). This corresponds to an action that interprets and validates protocol element semantics.""}}, {'A3': {'code': 'if (r->method == NGX_HTTP_CONNECT) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent CONNECT method"");\n    ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);\n    return NGX_ERROR;\n}\n\nif (r->method == NGX_HTTP_TRACE) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent TRACE method"");\n    ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);\n    return NGX_ERROR;\n}', 'explanation': 'This segment directly rejects the CONNECT and TRACE methods, aligning with the idea that the recipient must handle protocol elements according to their defined semantics. By finalizing the request with errors, it prevents the processing of methods that may not be safely interpreted.'}}]","The function processes HTTP request headers by validating mandatory and conditional header fields (such as Host, Content-Length, and Transfer-Encoding) and rejects requests that do not meet expected protocol semantics (including disallowed methods such as CONNECT and TRACE). While these checks are concrete implementations for specific header conditions and actions, the overall RFC requirement of interpreting all protocol elements (including recovery from some invalid constructs) is only partially addressed in this function. Therefore, the function only partially matches the full set of constraints implied by the HTTP RFC specification.",success,
1960,ngx_http_process_request_header,A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 (Not Implemented).,195,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.transfer_encoding) {\n    if (r->http_version < NGX_HTTP_VERSION_11) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent HTTP/1.0 request with ""\n                      ""\\""Transfer-Encoding\\"" header"");\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        return NGX_ERROR;\n    }\n\n    if (r->headers_in.transfer_encoding->value.len == 7\n        && ngx_strncasecmp(r->headers_in.transfer_encoding->value.data,\n                           (u_char *) ""chunked"", 7) == 0)\n    {\n        if (r->headers_in.content_length) {\n            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                          ""client sent \\""Content-Length\\"" and ""\n                          ""\\""Transfer-Encoding\\"" headers ""\n                          ""at the same time"");\n            ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n            return NGX_ERROR;\n        }\n\n        r->headers_in.chunked = 1;\n    } else {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent unknown \\""Transfer-Encoding\\"": \\""%V\\"""",\n                      &r->headers_in.transfer_encoding->value);\n        ngx_http_finalize_request(r, NGX_HTTP_NOT_IMPLEMENTED);\n        return NGX_ERROR;\n    }\n}', 'explanation': ""This segment checks if the incoming request's Transfer-Encoding is known. For HTTP/1.1, if the Transfer-Encoding is not 'chunked' (the only expected coding), it finalizes the request with NGX_HTTP_NOT_IMPLEMENTED, which sends a 501 status. This directly reflects the RFC requirement to respond with 501 when a transfer coding is not understood.""}}]","The function examines the Transfer-Encoding header within the request. It first ensures that HTTP/1.1 clients are processed correctly, and if a Transfer-Encoding other than 'chunked' is detected, it logs an error and responds with NGX_HTTP_NOT_IMPLEMENTED (501). This implementation directly addresses the RFC requirement that a request with an unrecognized transfer coding should result in a 501 (Not Implemented) response.",success,
1960,ngx_http_process_request_header,A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 requests (or later minor revisions); such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response.,196,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.transfer_encoding) {\n        if (r->http_version < NGX_HTTP_VERSION_11) {\n            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                          ""client sent HTTP/1.0 request with ""\n                          ""\\""Transfer-Encoding\\"" header"");\n            ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n            return NGX_ERROR;\n        }\n        ...\n    }', 'explanation': 'This block directly addresses the RFC requirement by checking if a request includes a Transfer-Encoding header while the HTTP version is less than 1.1. If true, it logs an error and rejects the request, thereby ensuring that Transfer-Encoding is only accepted if the client knows the server supports HTTP/1.1 or later.'}}, {'A1': {'code': 'if (r->headers_in.transfer_encoding->value.len == 7\n            && ngx_strncasecmp(r->headers_in.transfer_encoding->value.data,\n                               (u_char *) ""chunked"", 7) == 0)\n        {\n            if (r->headers_in.content_length) {\n                ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                              ""client sent \\""Content-Length\\"" and \\""Transfer-Encoding\\"" headers at the same time"");\n                ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n                return NGX_ERROR;\n            }\n\n            r->headers_in.chunked = 1;\n        } else {\n            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                          ""client sent unknown \\""Transfer-Encoding\\"": \\""%V\\"""",\n                          &r->headers_in.transfer_encoding->value);\n            ngx_http_finalize_request(r, NGX_HTTP_NOT_IMPLEMENTED);\n            return NGX_ERROR;\n        }', 'explanation': ""This code implements the RFC action that Transfer-Encoding, notably the 'chunked' type, should override any Content-Length header. If both headers are present, the request is rejected, which adheres to the specification's requirements regarding handling Transfer-Encoding.""}}]","The function visibly implements the specified HTTP RFC constraints by checking if a Transfer-Encoding header is provided in requests with HTTP versions below 1.1 and by ensuring that a request does not contain both Transfer-Encoding and Content-Length headers at the same time. These checks ensure that the client only sends Transfer-Encoding when it is certain the server supports HTTP/1.1 (or later), fully meeting the relevant conditions and actions from the RFC specification.",success,
1960,ngx_http_process_request_header,A server MUST NOT send a response containing Transfer-Encoding unless the corresponding request indicates HTTP/1.1 (or later minor revisions).,197,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.transfer_encoding) {\n    if (r->http_version < NGX_HTTP_VERSION_11) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent HTTP/1.0 request with ""Transfer-Encoding"" header"");\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        return NGX_ERROR;\n    }\n\n    if (r->headers_in.transfer_encoding->value.len == 7\n        && ngx_strncasecmp(r->headers_in.transfer_encoding->value.data,\n                           (u_char *) ""chunked"", 7) == 0)\n    {\n        if (r->headers_in.content_length) {\n            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                          ""client sent \\""Content-Length\\"" and \\""Transfer-Encoding\\"" headers at the same time"");\n            ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n            return NGX_ERROR;\n        }\n\n        r->headers_in.chunked = 1;\n\n    } else {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent unknown \\""Transfer-Encoding\\"": \\""%V\\"""",\n                      &r->headers_in.transfer_encoding->value);\n        ngx_http_finalize_request(r, NGX_HTTP_NOT_IMPLEMENTED);\n        return NGX_ERROR;\n    }\n}', 'explanation': ""This code segment checks for the presence of a Transfer-Encoding header and then validates that the request's HTTP version is at least HTTP/1.1. It rejects requests that include Transfer-Encoding when using HTTP/1.0, thereby ensuring that a response with Transfer-Encoding is only ever generated when the request is compliant with HTTP/1.1 or higher, in line with the RFC specification.""}}]","The function explicitly inspects the request for a Transfer-Encoding header and enforces the HTTP version requirement by rejecting any request that is not HTTP/1.1 or above. This validation directly addresses the RFC mandate that a server must not send a response containing Transfer-Encoding unless the corresponding request indicates HTTP/1.1 or later. All relevant logic to implement this constraint is present within the function_body, thus the implementation fully matches the specification requirement.",success,
1960,ngx_http_process_request_header,A server MAY reject a request that contains both Content-Length and Transfer-Encoding or process such a request in accordance with the Transfer-Encoding alone.,198,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.transfer_encoding) {\n    ...\n    if (r->headers_in.transfer_encoding->value.len == 7\n        && ngx_strncasecmp(r->headers_in.transfer_encoding->value.data,\n                           (u_char *) ""chunked"", 7) == 0)\n    {\n        if (r->headers_in.content_length) {\n            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                          ""client sent \\""Content-Length\\"" and \\""Transfer-Encoding\\"" headers at the same time"");\n            ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n            return NGX_ERROR;\n        }\n        r->headers_in.chunked = 1;\n    } else {\n        ...\n    }\n}', 'explanation': 'This segment checks if both Content-Length and Transfer-Encoding are present. When the Transfer-Encoding header contains the value ""chunked"" and a Content-Length header is also provided, the function logs an error, finalizes the request with a bad request status, and returns an error. This behavior matches the RFC specification that allows a server to reject such requests.'}}, {'C2': {'code': 'if (r->headers_in.transfer_encoding) {\n    if (r->http_version < NGX_HTTP_VERSION_11) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent HTTP/1.0 request with \\""Transfer-Encoding\\"" header"");\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        return NGX_ERROR;\n    }\n    ...\n}', 'explanation': 'This segment handles the scenario where a Transfer-Encoding header is sent in an HTTP/1.0 request. The function treats such a request as faulty by logging an error and rejecting the request, thereby aligning with the RFC directive for HTTP/1.0 messages containing Transfer-Encoding.'}}]","The function visibly implements the RFC's requirements for handling requests that include both Content-Length and Transfer-Encoding headers. It explicitly rejects requests that contain both headers (when the Transfer-Encoding is ""chunked"") and rejects HTTP/1.0 requests containing a Transfer-Encoding header, as mandated by the spec. Thus, the function fulfills the specified conditions (C1 and C2) by itself.",success,
1960,ngx_http_process_request_header,"If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value).",201,Partially Matches,"[{'C5': {'code': 'if (r->headers_in.content_length) {\n    r->headers_in.content_length_n = ngx_atoof(r->headers_in.content_length->value.data,\n                                                  r->headers_in.content_length->value.len);\n    \n    if (r->headers_in.content_length_n == NGX_ERROR) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent invalid \\""Content-Length\\"" header"");\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        return NGX_ERROR;\n    }\n}', 'explanation': 'This segment checks if a Content-Length header is provided and attempts to parse its value using ngx_atoof. If the parsing fails (i.e. the value is invalid), it logs an error and finalizes the request with a 400 Bad Request. This corresponds to the RFC requirement to treat invalid Content-Length values as an unrecoverable error when Transfer-Encoding is not present. However, it does not handle the comma-separated list case mentioned in the spec.'}}, {'C3': {'code': 'if (r->headers_in.transfer_encoding) {\n    if (r->http_version < NGX_HTTP_VERSION_11) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent HTTP/1.0 request with \\""Transfer-Encoding\\"" header"");\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        return NGX_ERROR;\n    }\n\n    if (r->headers_in.transfer_encoding->value.len == 7\n        && ngx_strncasecmp(r->headers_in.transfer_encoding->value.data,\n                           (u_char *) ""chunked"", 7) == 0)\n    {\n        if (r->headers_in.content_length) {\n            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                          ""client sent \\""Content-Length\\"" and \\""Transfer-Encoding\\"" headers at the same time"");\n            ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n            return NGX_ERROR;\n        }\n\n        r->headers_in.chunked = 1;\n    } else {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent unknown \\""Transfer-Encoding\\"": \\""%V\\"""",\n                      &r->headers_in.transfer_encoding->value);\n        ngx_http_finalize_request(r, NGX_HTTP_NOT_IMPLEMENTED);\n        return NGX_ERROR;\n    }\n}', 'explanation': ""This block handles Transfer-Encoding by ensuring that HTTP/1.0 requests do not include this header, verifies that only 'chunked' is accepted, and crucially, errors out if both Transfer-Encoding and Content-Length headers are provided. This aligns with the RFC requirement that such cases are potential indicators of request smuggling and should be treated as errors.""}}]","The function visibly addresses two aspects of the specified RFC. It checks for an invalid Content-Length header (C5) and returns an error if encountered, and it also detects when both Content-Length and Transfer-Encoding headers are present (C3), returning an error in that situation. However, the function does not implement the full logic required for parsing comma-separated lists for Content-Length values when invalid, thereby only partially matching the complete RFC specification.",success,
1960,ngx_http_process_request_header,"If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.",202,Partially Matches,"[{'A1': {'code': 'if (r->headers_in.host == NULL && r->http_version > NGX_HTTP_VERSION_10) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n               ""client sent HTTP/1.1 request without \\""Host\\"" header"");\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;\n}', 'explanation': 'This segment checks for the Host header in HTTP/1.1 requests and finalizes the request with a 400 Bad Request if it is missing. This is an attempt to enforce the spec’s requirement for responding with 400 on an unrecoverable error in a request.'}}, {'A2': {'code': 'if (r->headers_in.content_length) {\n    r->headers_in.content_length_n = ngx_atoof(r->headers_in.content_length->value.data,\n                                                  r->headers_in.content_length->value.len);\n    if (r->headers_in.content_length_n == NGX_ERROR) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent invalid \\""Content-Length\\"" header"");\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        return NGX_ERROR;\n    }\n}', 'explanation': 'This code validates the Content-Length header and, if it is found to be invalid, logs an error and finalizes the request with a 400 Bad Request. This aligns with the RFC requirement for handling unrecoverable errors in request messages.'}}]","The function incorporates checks to validate mandatory headers (such as ensuring a Host header for HTTP/1.1 requests) and to verify the correctness of the Content-Length header. When an error is detected in these cases, it finalizes the request using a 400 Bad Request response, which addresses part of the spec requiring that unrecoverable errors in request messages be met with a 400 response and connection closure. However, the function also responds differently in other error cases (for example, returning NGX_HTTP_NOT_IMPLEMENTED for unknown Transfer-Encoding) and does not cover every aspect of the RFC’s error handling as described in the context. Therefore, it only partially matches the complete set of spec constraints.",success,
1960,ngx_http_process_request_header,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.transfer_encoding) {\n    if (r->http_version < NGX_HTTP_VERSION_11) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent HTTP/1.0 request with ""\n                      ""\\""Transfer-Encoding\\"" header"");\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        return NGX_ERROR;\n    }\n\n    if (r->headers_in.transfer_encoding->value.len == 7\n        && ngx_strncasecmp(r->headers_in.transfer_encoding->value.data,\n                           (u_char *) ""chunked"", 7) == 0)\n    {\n        if (r->headers_in.content_length) {\n            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                          ""client sent \\""Content-Length\\"" and ""\n                          ""\\""Transfer-Encoding\\"" headers at the same time"");\n            ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n            return NGX_ERROR;\n        }\n\n        r->headers_in.chunked = 1;\n\n    } else {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent unknown \\""Transfer-Encoding\\"": \\""%V\\"""",\n                      &r->headers_in.transfer_encoding->value);\n        ngx_http_finalize_request(r, NGX_HTTP_NOT_IMPLEMENTED);\n        return NGX_ERROR;\n    }\n}', 'explanation': 'The function inspects whether a Transfer-Encoding header is present. In the case where it is the valid ""chunked"" transfer encoding, it checks if a Content-Length header has also been provided. If both are present, an error is logged and the request is rejected. This directly enforces the RFC rule that a message with a Transfer-Encoding header MUST NOT include a Content-Length header.'}}]","The provided function contains explicit logic that checks for the presence of a Transfer-Encoding header and, if it matches the known valid ""chunked"" value, ensures that no Content-Length header is simultaneously present. This fulfills the RFC constraint as stated in the specification. All the relevant logic is contained within this function, satisfying the requirement that a sender must not send Content-Length when Transfer-Encoding is present.",success,
1960,ngx_http_process_request_header,"A server or client that receives an HTTP/1.0 message containing a Transfer-Encoding header field MUST treat the message as if the framing is faulty, even if a Content-Length is present, and close the connection after processing the message.",199,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.transfer_encoding) {\n    if (r->http_version < NGX_HTTP_VERSION_11) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent HTTP/1.0 request with ""\n                      ""\\""Transfer-Encoding\\"" header"");\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        return NGX_ERROR;\n    }\n    ...\n}', 'explanation': 'This segment detects when an HTTP/1.0 request (i.e. version less than HTTP/1.1) contains a Transfer-Encoding header. In compliance with the RFC, it logs an error and finalizes the request (which leads to connection closure), thereby treating the message framing as faulty.'}}, {'A1': {'code': 'if (r->headers_in.transfer_encoding->value.len == 7\n    && ngx_strncasecmp(r->headers_in.transfer_encoding->value.data,\n                       (u_char *) ""chunked"", 7) == 0)\n{\n    if (r->headers_in.content_length) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent \\""Content-Length\\"" and \\""Transfer-Encoding\\"" headers at the same time"");\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        return NGX_ERROR;\n    }\n\n    r->headers_in.chunked = 1;\n\n} else {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent unknown \\""Transfer-Encoding\\"": \\""%V\\"""",\n                  &r->headers_in.transfer_encoding->value);\n    ngx_http_finalize_request(r, NGX_HTTP_NOT_IMPLEMENTED);\n    return NGX_ERROR;\n}', 'explanation': 'This portion handles the scenario where both Content-Length and Transfer-Encoding headers are present. It logs the error, finalizes the request, and returns an error, which is consistent with the RFC requirement to reject such messages and close the connection.'}}]","The function explicitly checks if the HTTP message contains a Transfer-Encoding header. For HTTP/1.0 messages (version less than HTTP/1.1), it logs an error and finalizes the request, which indirectly closes the connection. It also handles the case where both Content-Length and Transfer-Encoding headers are present by rejecting the request. Thus, the function's logic, by itself, addresses the core RFC specifications regarding faulty framing and connection closure with Transfer-Encoding in HTTP/1.0.",success,
1961,ngx_http_process_request,"In particular, a request for an ""https"" resource MUST be rejected unless it has been received over a connection that has been secured via a certificate valid for that target URI's origin, as defined by Section 4.2.2.",251,Partially Matches,"[{'C1': {'code': 'if (c->ssl == NULL) {\n    ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                  ""client sent plain HTTP request to HTTPS port"");\n    ngx_http_finalize_request(r, NGX_HTTP_TO_HTTPS);\n    return;\n}', 'explanation': 'This segment checks that the connection is indeed using SSL. It rejects a request on an HTTPS port that is not using an SSL connection.'}}, {'A1': {'code': 'rc = SSL_get_verify_result(c->ssl->connection);\n\nif (rc != X509_V_OK\n    && (sscf->verify != 3 || !ngx_ssl_verify_error_optional(rc)))\n{\n    ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                  ""client SSL certificate verify error: (%l:%s)"",\n                  rc, X509_verify_cert_error_string(rc));\n\n    ngx_ssl_remove_cached_session(c->ssl->session_ctx,\n                       (SSL_get0_session(c->ssl->connection)));\n\n    ngx_http_finalize_request(r, NGX_HTTPS_CERT_ERROR);\n    return;\n}', 'explanation': 'This block verifies the SSL certificate and rejects the request if the certificate verification does not succeed.'}}]","The specified RFC requires that an HTTPS request must be rejected unless the connection has been secured with a certificate valid for the target URI's origin. The function visibly enforces that an SSL connection is present (C1) and performs certificate verification (A1), finalizing the request with an error if these checks fail. However, it does not clearly verify that the certificate is valid for the specific target URI’s origin (for example, by matching the certificate’s subject to the requested host), so while the function implements key security checks against plain HTTP and invalid certificates, it only partially meets the full requirement as stated in the RFC.",success,
1962,ngx_http_validate_host,A recipient that processes such a URI reference MUST reject it as invalid.,224,Fully Matches,"[{'C1': {'code': 'if (host_len == 0) {\n    return NGX_DECLINED;\n}', 'explanation': 'This code checks whether the effective length of the host identifier is zero and rejects it (by returning NGX_DECLINED), which implements the RFC requirement that a URI reference with an empty host identifier must be rejected.'}}]","The function ngx_http_validate_host performs host validation by iterating through the provided host string and finally checking if the length (host_len) is 0. This directly addresses the RFC specification that an HTTP URI with an empty host identifier must be rejected, fulfilling the labeled condition (C1). All logic related to rejecting an empty host is contained within the function itself, thus it fully meets the constraint.",success,
1962,ngx_http_validate_host,A recipient that processes such a URI reference MUST reject it as invalid.,226,Fully Matches,"[{'C1': {'code': 'if (host_len == 0) {\n    return NGX_DECLINED;\n}', 'explanation': 'This code segment directly rejects the host if its length is zero after processing, which implements the RFC requirement that a recipient MUST reject a URI with an empty host identifier.'}}]",The function explicitly validates the host component by checking and rejecting an empty host identifier. This matches the RFC specification stating that a recipient processing an 'https' URI with an empty host must reject it as invalid. All relevant logic for this condition is contained within this function.,success,
1962,ngx_http_validate_host,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Fully Matches,"[{'C1': {'code': 'if (host_len == 0) {\n    return NGX_DECLINED;\n}', 'explanation': ""This code segment ensures that if the host identifier is empty (i.e. its length is 0), the function rejects it. This directly implements the RFC requirement that an 'http' URI must not be generated or accepted with an empty host identifier.""}}]","The function iterates over the provided host string and performs several validations. Crucially, after processing the string, it checks if the computed host length is zero and returns NGX_DECLINED if true. This behavior ensures that an empty host identifier is explicitly rejected, thereby fulfilling the RFC specification that a sender MUST NOT generate an 'http' URI with an empty host identifier.",success,
1968,ngx_http_request_handler,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (c->close) {\n    r->main->count++;\n    ngx_http_terminate_request(r, 0);\n    ngx_http_run_posted_requests(c);\n    return;\n}', 'explanation': ""This code segment checks whether the connection's close flag is set and then terminates the HTTP request. This directly addresses the specification that a client, server, or proxy MAY close the transport connection at any time by responding to a closure signal.""}}]","The function verifies if the connection has been marked for closure (c->close) and, if so, terminates the current request. This logic is in line with the RFC requirement that closing the connection is allowed at any time. However, while it handles the closure case, it does not implement the portions of the RFC related to graceful closure (such as a client or server issuing a graceful timed-out close) entirely within itself. As such, only part of the specification is visibly addressed by this function.",success,
1971,ngx_http_finalize_request,"A client, server, or proxy MAY close the transport connection at any time.",316,Fully Matches,"[{'C1': {'code': 'if (rc == NGX_HTTP_CLIENT_CLOSED_REQUEST || c->error) {\n    ...\n    ngx_http_terminate_request(r, rc);\n    return;\n}', 'explanation': 'This branch checks whether the client has closed the request (or another error has occurred) and then terminates the request, allowing the connection to be closed as per the RFC’s allowance that a client, server, or proxy MAY close the transport connection at any time.'}}, {'A1': {'code': 'if (rc == NGX_DONE) {\n    ngx_http_finalize_connection(r);\n    return;\n}\n...\nif (ngx_http_post_action(r) == NGX_OK) {\n    return;\n}\n...\nngx_http_finalize_connection(r);', 'explanation': 'These code segments demonstrate that when appropriate conditions are met (whether a normal finalization or an error/timeout situation), the function calls ngx_http_finalize_connection. This ensures that the connection is closed gracefully, satisfying the RFC requirement that the transport connection may be closed at any time.'}}]","The function 'ngx_http_finalize_request' includes explicit logic to finalize a request and eventually close the underlying connection. It checks for various conditions, such as when the client has closed the request or when specific error conditions are met, and then calls functions like 'ngx_http_finalize_connection' or 'ngx_http_terminate_request' to close the connection. This behavior addresses the RFC specification that a client, server, or proxy may close the transport connection at any time. All of the relevant logic for closing the connection is implemented within the function itself, thus fully matching the specified constraint.",success,
1971,ngx_http_finalize_request,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Does Not Match,[],"The provided function 'ngx_http_finalize_request' is responsible for cleaning up after an HTTP request, handling errors, and eventually finalizing the connection (often by closing it). It does not contain any explicit logic that attempts to sustain persistent connections or allow flow-control mechanisms to manage temporary overloads. Instead, various conditions in the code lead to terminating or finalizing the connection (for example, via calls to ngx_http_finalize_connection or ngx_http_terminate_request). Therefore, none of the labeled constraints (such as those requiring the server to maintain persistent connections when possible) are implemented within this function itself.",success,
1972,ngx_http_terminate_request,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'A1': {'code': 'if (mr->write_event_handler) {\n    if (mr->blocked) {\n        r = r->connection->data;\n\n        r->connection->error = 1;\n        r->write_event_handler = ngx_http_request_finalizer;\n\n        return;\n    }\n\n    e = ngx_http_ephemeral(mr);\n    mr->posted_requests = NULL;\n    mr->write_event_handler = ngx_http_terminate_handler;\n    (void) ngx_http_post_request(mr, &e->terminal_posted_request);\n    return;\n}\n\nngx_http_close_request(mr, rc);', 'explanation': 'This segment of the code handles the termination of the request. It checks whether there is a pending write event and, if so, determines if the request is blocked. In the blocked case it sets an error flag and a finalizer handler; otherwise, it schedules a termination event. If no write event handler is present, it directly calls ngx_http_close_request. This mechanism represents an attempt at a graceful closure as encouraged by the spec.'}}]","The RFC states that a client, server, or proxy may close the transport connection at any time and that, for graceful shutdown, implementations should monitor and respond appropriately to closure signals. In this function, while there is no logic for constantly monitoring incoming closure signals, the function does perform several steps to gracefully terminate an HTTP request. It marks the request as terminated, runs cleanup handlers, and either arranges for a termination handler to be called or directly closes the request, which aligns with the idea of a graceful termination (A1). However, because it does not implement other aspects such as continuous monitoring or managing persistent connection flow-control in this isolated function, the implementation only partially meets the broader set of requirements described in the spec.",success,
1974,ngx_http_finalize_connection,"A server MUST read the entire request message body or close the connection after sending its response; otherwise, the remaining data on a persistent connection would be misinterpreted as the next request.",312,Fully Matches,"[{'C1': {'code': 'if (r->discard_body) {\n    r->read_event_handler = ngx_http_discarded_request_body_handler;\n    ngx_add_timer(r->connection->read, clcf->lingering_timeout);\n\n    if (r->lingering_time == 0) {\n        r->lingering_time = ngx_time() + (time_t) (clcf->lingering_time / 1000);\n    }\n}', 'explanation': ""This block handles the case where the request body has not been fully read. By setting the read_event_handler to a discard handler and adding a timer, it ensures that the remaining message body is drained (or 'read') asynchronously, thereby satisfying the RFC requirement that the server must read the entire request message body or close the connection.""}}, {'A1': {'code': 'if (r->reading_body) {\n    r->keepalive = 0;\n    r->lingering_close = 1;\n}\n\nif (clcf->lingering_close == NGX_HTTP_LINGERING_ALWAYS\n    || (clcf->lingering_close == NGX_HTTP_LINGERING_ON\n        && (r->lingering_close\n            || r->header_in->pos < r->header_in->last\n            || r->connection->read->ready\n            || r->connection->pipeline)))\n{\n    ngx_http_set_lingering_close(r->connection);\n    return;\n}', 'explanation': 'This segment ensures that when the request body is still being read (or not fully processed), the server disables keepalive and initiates a lingering close. This prevents any unread trailing data from being misinterpreted as part of a subsequent request, which is the essence of the HTTP RFC requirement.'}}]","The function 'ngx_http_finalize_connection' directly addresses the HTTP RFC requirement by checking if the request body has been fully read. When r->discard_body is true, it sets a discard handler with a timer to process the remaining data. Moreover, if the request is still in the process of reading the body (r->reading_body), it disables connection reuse (keepalive) and flags the connection for a lingering close. These measures ensure that any residual data is either consumed correctly or the connection is closed, thereby preventing misinterpretation on persistent connections.",success,
1974,ngx_http_finalize_connection,A client or server that wishes to time out SHOULD issue a graceful close on the connection.,314,Partially Matches,"[{'A1': {'code': 'if (clcf->lingering_close == NGX_HTTP_LINGERING_ALWAYS\n    || (clcf->lingering_close == NGX_HTTP_LINGERING_ON\n        && (r->lingering_close\n            || r->header_in->pos < r->header_in->last\n            || r->connection->read->ready\n            || r->connection->pipeline)))\n{\n    ngx_http_set_lingering_close(r->connection);\n    return;\n}', 'explanation': 'This branch checks several conditions (for example, lingering_close flags and connection readiness) and if met, it initiates a lingering (graceful) close by calling ngx_http_set_lingering_close, which implements the notion of a graceful close as indicated in the RFC spec.'}}]","The RFC mandates that a client or server wishing to time out should issue a graceful close on the connection. Within the function, one branch addresses this by invoking ngx_http_set_lingering_close when certain lingering conditions are met, thereby attempting to gracefully close the connection. However, the function also executes other forms of connection finalization (such as immediate closure via ngx_http_close_request and keepalive handling) without clear explicit handling of all timeout scenarios. In isolation, the function partly implements the graceful close requirement (notably in the A1 branch) but does not cover every possible condition of a timeout as envisioned in the spec. Hence, it partially matches the specified constraint.",success,
1974,ngx_http_finalize_connection,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (r->connection->read->eof) {\n    ngx_http_close_request(r, 0);\n    return;\n}\n...\nngx_http_close_request(r, 0);', 'explanation': 'The function calls ngx_http_close_request in several conditions, thereby actively closing the connection. This meets the spec condition that a client, server, or proxy MAY close the transport connection at any time.'}}, {'A1': {'code': 'if (r->discard_body) {\n    r->read_event_handler = ngx_http_discarded_request_body_handler;\n    ngx_add_timer(r->connection->read, clcf->lingering_timeout);\n\n    if (r->lingering_time == 0) {\n        r->lingering_time = ngx_time() + (time_t) (clcf->lingering_time / 1000);\n    }\n}\n...\nif (clcf->lingering_close == NGX_HTTP_LINGERING_ALWAYS\n    || (clcf->lingering_close == NGX_HTTP_LINGERING_ON\n        && (r->lingering_close\n            || r->header_in->pos < r->header_in->last\n            || r->connection->read->ready\n            || r->connection->pipeline)))\n{\n    ngx_http_set_lingering_close(r->connection);\n    return;\n}', 'explanation': 'The function contains logic to set up a lingering (graceful) close under certain conditions, which aligns with the recommendation for issuing a graceful close when idle or under overload conditions.'}}]","The ngx_http_finalize_connection function includes logic to close HTTP connections using several criteria and even employs a lingering close mechanism for a graceful termination under specific conditions. This addresses the part of the spec that permits a connection to be closed at any time and recommends graceful closing. However, the function does not incorporate explicit monitoring for an incoming closure signal (as suggested in the extended context), meaning that while it handles many close scenarios, it does not implement all aspects of the detailed spec context. Thus, the function only partially matches the provided RFC specification constraints.",success,
1974,ngx_http_finalize_connection,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'if (r->keepalive\n    && clcf->keepalive_min_timeout > 0)\n{\n    ngx_http_set_keepalive(r);\n    return;\n}\n\nif (!ngx_terminate\n     && !ngx_exiting\n     && r->keepalive\n     && clcf->keepalive_timeout > 0)\n{\n    ngx_http_set_keepalive(r);\n    return;\n}', 'explanation': ""The function checks conditions for sustaining a persistent connection by verifying that the request has the 'keepalive' flag set and that appropriate timeout values (keepalive_min_timeout or keepalive_timeout) exist, then calls ngx_http_set_keepalive() to maintain the connection. This addresses the part of the spec that requires the server to sustain persistent connections when possible. However, the code does not explicitly incorporate any mechanism to allow the underlying transport's flow‐control to resolve temporary overloads, as urged by the RFC. Thus, while it attempts to implement persistent connections, it only partially meets the overall RFC specification.""}}]","The target function implements logic to maintain persistent connections—by checking keepalive flags and timeouts and by setting lingering close conditions when appropriate—to keep connections open when possible. This addresses the requirement that the server SHOULD sustain persistent connections. However, the RFC further instructs that, in the face of temporary overload, the server should let the underlying transport's flow‐control mechanisms resolve the issue rather than prematurely terminating the connection. The function does not clearly incorporate logic related to such flow-control mechanisms. Therefore, while some conditions (C1) are addressed, not all the RFC requirements are fully implemented in this function, leading to a 'Partially Matches' judgment.",success,
1974,ngx_http_finalize_connection,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'C1': {'code': 'if (r->keepalive\n        && clcf->keepalive_min_timeout > 0)\n    {\n        ngx_http_set_keepalive(r);\n        return;\n    }\n\n    if (!ngx_terminate\n         && !ngx_exiting\n         && r->keepalive\n         && clcf->keepalive_timeout > 0)\n    {\n        ngx_http_set_keepalive(r);\n        return;\n    }', 'explanation': ""These code segments check the 'r->keepalive' flag and associated keepalive timeouts in the configuration. When conditions are met, the function calls ngx_http_set_keepalive(r), which directly implements support for persistent connections as specified in the HTTP RFC.""}}]","The function ngx_http_finalize_connection inspects the request's state and configuration to determine whether the connection should be maintained (persistent) or closed. By calling ngx_http_set_keepalive when the appropriate conditions (such as r->keepalive being true and valid keepalive timeout values) are met, the function directly addresses the RFC requirement that HTTP implementations SHOULD support persistent connections. Therefore, the code fully matches the spec constraint.",success,
1975,ngx_http_set_write_handler,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Does Not Match,[],"The provided function sets up event handlers and timers for writing over the connection but does not directly implement any logic to sustain persistent connections or to let the transport layer’s flow-control mechanism resolve temporary overloads. Although the function checks for delayed write events and schedules timers, none of these actions directly correspond to the RFC requirement that a server should sustain persistent connections and deliberately avoid terminating connections to force clients to retry. Therefore, this function by itself does not visibly address the specified RFC constraints.",success,
1975,ngx_http_set_write_handler,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'A1': {'code': 'if (ngx_handle_write_event(wev, clcf->send_lowat) != NGX_OK) {\n    ngx_http_close_request(r, 0);\n    return NGX_ERROR;\n}', 'explanation': 'This section of the code responds to a failure in handling the write event by closing the request. This action relates to the RFC clause that a client, server, or proxy MAY close the transport connection at any time. It shows the function’s capability to close a connection (i.e. trigger connection closure) when a write event cannot be properly handled.'}}]","The RFC requires that a connection can be closed at any time and suggests that a graceful close should be issued when a timeout occurs. Within this function, the closing mechanism is visible in the error handling branch where ngx_http_close_request is called. However, the function does not contain additional logic to monitor for a closure signal or implement the full graceful close strategy as described in the RFC context. Therefore, while the code includes an element (A1) addressing connection closure under error conditions, it does not fully implement all suggested aspects of the RFC, resulting in a 'Partially Matches' judgment.",success,
1976,ngx_http_writer,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'A1': {'code': 'if (wev->delayed || r->aio) {\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, wev->log, 0, ""http writer delayed"");\n\n    if (!wev->delayed) {\n        ngx_add_timer(wev, clcf->send_timeout);\n    }\n\n    if (ngx_handle_write_event(wev, clcf->send_lowat) != NGX_OK) {\n        ngx_http_close_request(r, 0);\n    }\n\n    return;\n}\n\n...\n\nif (r->buffered || r->postponed || (r == r->main && c->buffered)) {\n    if (!wev->delayed) {\n        ngx_add_timer(wev, clcf->send_timeout);\n    }\n\n    if (ngx_handle_write_event(wev, clcf->send_lowat) != NGX_OK) {\n        ngx_http_close_request(r, 0);\n    }\n\n    return;\n}', 'explanation': 'The function’s use of timers (ngx_add_timer) and scheduling write events (ngx_handle_write_event) appears aimed at deferring immediate closure of the connection under delayed write conditions. This mechanism is in line with allowing the underlying transport’s flow-control to handle temporary overloads.'}}]","The provided function includes logic to delay writes and schedule timer-based callbacks when the connection is delayed or when the output is buffered. This behavior partially aligns with the RFC requirement to allow the transport’s flow-control to manage temporary overloads instead of immediately closing the connection. However, the function does not comprehensively address all aspects of sustaining persistent connections (e.g., it eventually finalizes or closes the request under timeout conditions), so the approach only partially meets the spec constraints.",success,
1976,ngx_http_writer,"A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.",310,Partially Matches,"[{'C1': {'code': 'if (wev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,\n                  ""client timed out"");\n    c->timedout = 1;\n\n    ngx_http_finalize_request(r, NGX_HTTP_REQUEST_TIME_OUT);\n    return;\n}', 'explanation': ""This segment checks if a write event has timed out, which can indicate an incomplete request (e.g., due to a timeout exception). It then initiates an error response by finalizing the request with the appropriate timeout status, thus addressing part of the spec's requirement to send an error response before closing the connection when facing an incomplete request.""}}]","The provided function handles the timeout case (a common cause of incomplete request messages) by detecting a timed out write event and finalizing the request with an error status. This check implements part of the spec constraint by sending an error response prior to closing the connection. However, the spec mentions broader cases such as canceled requests as well, which are not explicitly handled in this function. Therefore, the function partially matches the specified behavior.",success,
1976,ngx_http_writer,A client or server that wishes to time out SHOULD issue a graceful close on the connection.,314,Partially Matches,"[{'A1': {'code': 'if (wev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,\n                  ""client timed out"");\n    c->timedout = 1;\n\n    ngx_http_finalize_request(r, NGX_HTTP_REQUEST_TIME_OUT);\n    return;\n}', 'explanation': 'This segment checks if the write event has timed out and then finalizes the request (which likely triggers a graceful closure of the connection). This corresponds to the RFC specification that a client or server wishing to time out should issue a graceful close on the connection.'}}]","The provided function does include logic that detects a timeout condition and, in response, finalizes the request by calling ngx_http_finalize_request. This is an attempt to perform a graceful close when a timeout occurs, satisfying the core intent of the RFC specification. However, while the spec also emphasizes continuous monitoring for closure signals and reacting as needed, the function in isolation only addresses the timeout scenario and delegates the actual graceful close handling to ngx_http_finalize_request. Since other aspects of connection closure and monitoring may be handled elsewhere in the system, this function only partially implements the full range of behaviors described in the RFC.",success,
1976,ngx_http_writer,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (wev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,\n                  ""client timed out"");\n    c->timedout = 1;\n\n    ngx_http_finalize_request(r, NGX_HTTP_REQUEST_TIME_OUT);\n    return;\n}', 'explanation': ""This segment handles a timeout event by logging the timeout, marking the connection, and finalizing the request—effectively closing the connection when the client times out, which reflects the spec's allowance that a connection may be closed at any time.""}}]","The RFC states that a client, server, or proxy MAY close the connection at any time. Within the function, the timeout scenario (and certain error conditions) results in the closure of the connection. The logic explicitly checks for the timeout event and then finalizes the request, thereby closing it. However, although this function addresses connection closure under a timeout, it does not comprehensively implement all aspects (such as a fully graceful close in every scenario) recommended by the RFC specification. Therefore, while the function does implement part of the requirement (C1), it does not visibly cover all potential conditions and actions (such as ensuring persistent connections where possible) expected by the spec. This leads to a partial match.",success,
1979,ngx_http_test_reading,"Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.",315,Fully Matches,"[{'C1': {'code': '/* Check for connection closure via various event mechanisms */\n#if (NGX_HAVE_KQUEUE)\n    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {\n        if (!rev->pending_eof) {\n            return;\n        }\n        rev->eof = 1;\n        c->error = 1;\n        err = rev->kq_errno;\n        goto closed;\n    }\n#endif\n\n#if (NGX_HAVE_EPOLLRDHUP)\n    if ((ngx_event_flags & NGX_USE_EPOLL_EVENT) && ngx_use_epoll_rdhup) {\n        socklen_t  len;\n        if (!rev->pending_eof) {\n            return;\n        }\n        rev->eof = 1;\n        c->error = 1;\n        err = 0;\n        len = sizeof(ngx_err_t);\n        if (getsockopt(c->fd, SOL_SOCKET, SO_ERROR, (void *) &err, &len) == -1) {\n            err = ngx_socket_errno;\n        }\n        goto closed;\n    }\n#endif\n\n    n = recv(c->fd, buf, 1, MSG_PEEK);\n    if (n == 0) {\n        rev->eof = 1;\n        c->error = 1;\n        err = 0;\n        goto closed;\n    }', 'explanation': 'This code continuously monitors the connection for a closure signal. It checks for pending EOF using event flags (for kqueue and epoll) and examines the result of a non-destructive read (recv with MSG_PEEK) to detect if the client closed the connection.'}}, {'A1': {'code': 'closed:\n\n    if (err) {\n        rev->error = 1;\n    }\n#if (NGX_HTTP_SSL)\n    if (c->ssl) {\n        c->ssl->no_send_shutdown = 1;\n    }\n#endif\n    ngx_log_error(NGX_LOG_INFO, c->log, err,\n                  ""client prematurely closed connection"");\n\n    ngx_http_finalize_request(r, NGX_HTTP_CLIENT_CLOSED_REQUEST);', 'explanation': 'Upon detecting a closure signal, the function promptly responds by marking the connection as closed (setting eof and error flags) and finalizing the request, thereby reclaiming system resources as required by the RFC.'}}]","The function implements a monitoring mechanism for open connections by checking for closure signals using different approaches (kqueue, epoll, and a peek on recv). It then responds appropriately when a closure is detected (by setting error flags, logging, and finalizing the connection). This directly addresses the spec's requirement to constantly monitor for and respond to connection closures, fulfilling both the monitoring condition (C1) and the closure response action (A1) within the function itself.",success,
1979,ngx_http_test_reading,"A client, server, or proxy MAY close the transport connection at any time.",316,Fully Matches,"[{'C1': {'code': 'n = recv(c->fd, buf, 1, MSG_PEEK);\n\nif (n == 0) {\n    rev->eof = 1;\n    c->error = 1;\n    err = 0;\n\n    goto closed;\n}\n\n... (other branches similarly checking for pending_eof and error conditions)', 'explanation': 'This segment directly detects a closed connection (by testing if recv returns 0) as well as similar checks in kqueue and epoll branches. This implements the condition that a transport connection may be closed at any time by monitoring for closure/EoF signals.'}}, {'A1': {'code': 'closed:\n\nif (err) {\n    rev->error = 1;\n}\n\n#if (NGX_HTTP_SSL)\nif (c->ssl) {\n    c->ssl->no_send_shutdown = 1;\n}\n#endif\n\nngx_log_error(NGX_LOG_INFO, c->log, err,\n              ""client prematurely closed connection"");\n\nngx_http_finalize_request(r, NGX_HTTP_CLIENT_CLOSED_REQUEST);', 'explanation': ""This part of the function takes action upon detection of a closed connection: it flags the error, logs a message indicating the premature closure, and finalizes the HTTP request. This aligns with the RFC's directive regarding connection closure handling.""}}]","The function 'ngx_http_test_reading' actively monitors various event mechanisms (including HTTP/2, HTTP/3, kqueue, and epoll) for signs of connection closure. When the transport is closed (e.g., when recv returns 0 or pending EOF is detected), it sets the appropriate flags, logs the closure, and finalizes the request. These behaviors visibly address the RFC specification that a client, server, or proxy MAY close the transport connection at any time, thereby fully matching the labeled conditions (C1) and actions (A1) within the function itself.",success,
1980,ngx_http_set_keepalive,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'C1': {'code': 'if (clcf->keepalive_min_timeout == 0) {\n    c->idle = 1;\n    ngx_reusable_connection(c, 1);\n}', 'explanation': 'This segment marks the connection as idle and reusable, which is a key mechanism for supporting persistent connections as required by the HTTP RFC.'}}, {'A1': {'code': 'rev->handler = ngx_http_keepalive_handler;', 'explanation': 'Assigning the read event handler to ngx_http_keepalive_handler sets up the mechanism to process subsequent pipelined (or persistent) requests on the same connection.'}}, {'A2': {'code': 'ngx_add_timer(rev, clcf->keepalive_timeout - hc->keepalive_timeout);', 'explanation': 'By adding a timer for the keepalive period, the function manages the lifetime of the persistent connection in accordance with the HTTP spec, ensuring resources are properly managed.'}}]","The function 'ngx_http_set_keepalive' contains dedicated logic for enabling and managing persistent connections. It reassigns event handlers to handle new pipelined requests, marks the connection as idle and reusable, and schedules a timeout timer. These steps directly address the HTTP RFC specification that implementations SHOULD support persistent connections.",success,
1980,ngx_http_set_keepalive,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'if (clcf->keepalive_min_timeout == 0) {\n    c->idle = 1;\n    ngx_reusable_connection(c, 1);\n}\n\nif (clcf->keepalive_min_timeout > 0\n    && clcf->keepalive_timeout > clcf->keepalive_min_timeout)\n{\n    hc->keepalive_timeout = clcf->keepalive_timeout - clcf->keepalive_min_timeout;\n} else {\n    hc->keepalive_timeout = 0;\n}\n\nngx_add_timer(rev, clcf->keepalive_timeout - hc->keepalive_timeout);', 'explanation': ""The code attempts to sustain a persistent connection by marking it as idle and reusable when conditions allow (i.e. when keepalive_min_timeout is zero), and by setting a timer that governs the connection’s idle period. This directly corresponds to the RFC’s requirement that the server should sustain persistent connections when possible. However, no explicit logic is observed regarding the underlying transport's flow-control mechanisms, so only part of the specification is handled.""}}]","The function ngx_http_set_keepalive sets the connection state to idle and reuses the connection by scheduling a timer, thereby implementing the persistent connection aspect of the RFC specification. This shows an attempt to maintain persistent connections when possible. However, the spec also specifies that the server should allow the underlying transport’s flow-control mechanisms to resolve temporary overloads rather than terminate the connection, and this function does not visibly address that part. Thus, the function only partially matches the complete requirements of the RFC.",success,
1981,ngx_http_keepalive_handler,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Fully Matches,"[{'C1': {'code': 'if (!ngx_terminate\n     && !ngx_exiting\n     && rev->timedout\n     && hc->keepalive_timeout > 0)\n{\n    c->idle = 1;\n    ngx_reusable_connection(c, 1);\n\n    ngx_add_timer(rev, hc->keepalive_timeout);\n\n    hc->keepalive_timeout = 0;\n    rev->timedout = 0;\n    return;\n}', 'explanation': 'This block explicitly sets the connection to idle and schedules a timer based on the configured keepalive timeout, thereby sustaining persistent connections as recommended by the RFC.'}}, {'A1': {'code': 'if (n == NGX_AGAIN) {\n    if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n        ngx_http_close_connection(c);\n        return;\n    }\n\n    if (ngx_pfree(c->pool, b->start) == NGX_OK) {\n        b->pos = NULL;\n    }\n\n    return;\n}', 'explanation': 'This segment ensures that when a read would block (indicated by NGX_AGAIN), the function does not immediately terminate the connection. Instead, it registers for further read events, thereby letting the underlying transport’s flow control resolve temporary overloads.'}}]","The function ngx_http_keepalive_handler implements logic to preserve persistent connections by keeping them idle and resetting associated timers. It also handles the non-blocking I/O scenario (NGX_AGAIN) by waiting for further events rather than closing the connection, which is in line with the RFC specification that a server should sustain persistent connections and rely on transport-level flow control. All of this is handled within the function, independent of other system components.",success,
1981,ngx_http_keepalive_handler,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'C1': {'code': 'c->idle = 1;\nngx_reusable_connection(c, 1);\nngx_add_timer(rev, hc->keepalive_timeout);\n...\nif (n == NGX_AGAIN) { … }\n...\nc->data = ngx_http_create_request(c);\nrev->handler = ngx_http_process_request_line;\nngx_http_process_request_line(rev);', 'explanation': ""The function actively manages a keepalive (persistent) connection. It marks the connection as idle, makes it reusable, and establishes a timer based on 'keepalive_timeout'. Later, when data is received, it creates a new request and chains processing of the request line. This ensures that multiple HTTP requests can be carried over a single connection consistent with the HTTP/1.1 persistent connections requirement.""}}]","The HTTP/1.1 specification requires implementations to support persistent connections. This function (ngx_http_keepalive_handler) directly implements keepalive connection handling by setting the connection to idle for reuse, adding a timer for the keepalive timeout, and eventually processing a new HTTP request when data is received. All the key aspects required for persistent connection support are handled within this function, thus it fully meets the spec constraint.",success,
1983,ngx_http_set_lingering_close,Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection.,325,Partially Matches,"[{'C1': {'code': '#if (NGX_HTTP_SSL)\n    if (c->ssl) {\n        ngx_int_t  rc;\n\n        c->ssl->shutdown_without_free = 1;\n\n        rc = ngx_ssl_shutdown(c);\n\n        if (rc == NGX_ERROR) {\n            ngx_http_close_request(r, 0);\n            return;\n        }\n\n        if (rc == NGX_AGAIN) {\n            c->ssl->handler = ngx_http_set_lingering_close;\n            return;\n        }\n    }\n#endif', 'explanation': 'This SSL branch attempts to initiate a proper closure alert exchange by invoking ngx_ssl_shutdown, which is expected to send the necessary SSL/TLS closure alerts. It handles retrying when the closure exchange is incomplete.'}}]","The code function attempts to meet the RFC requirement by initiating an exchange of closure alerts for SSL connections. In the SSL branch, it calls ngx_ssl_shutdown and handles its outcomes, which indicates an attempt to adhere to 'MUST attempt to initiate an exchange of closure alerts' for SSL. However, in non-SSL cases the function directly shuts down the writing side of the socket without explicitly sending closure alerts. Since the RFC requirement applies generally to all server connections, and this function only fully addresses it in the SSL scenario, the implementation in this function is considered a partial match.",success,
1991,ngx_http_free_request,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function ngx_http_free_request primarily handles cleanup operations (e.g., logging, resource deallocation, and socket option configuration) when closing an HTTP request. It does not contain any logic pertaining to generating or validating HTTP protocol elements, nor does it enforce the restriction that a sender must not generate protocol elements or syntax alternatives allowed only for other roles. Therefore, no part of this function fulfills any of the RFC constraint conditions (e.g., C1) or actions (e.g., A1) specified.",success,
1991,ngx_http_free_request,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (r->connection->timedout\n#if (NGX_HTTP_V3)\n    && r->connection->quic == NULL\n#endif\n   )\n{\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (clcf->reset_timedout_connection) {\n        linger.l_onoff = 1;\n        linger.l_linger = 0;\n\n        if (setsockopt(r->connection->fd, SOL_SOCKET, SO_LINGER,\n                       (const void *) &linger, sizeof(struct linger)) == -1)\n        {\n            ngx_log_error(NGX_LOG_ALERT, log, ngx_socket_errno,\n                          ""setsockopt(SO_LINGER) failed"");\n        }\n    }\n}', 'explanation': 'This segment checks if the connection has timed out and, if so, applies a setsockopt SO_LINGER setting to instantly close the connection. This addresses the spec’s requirement that a server may choose to close an idle connection even if a request is in progress.'}}, {'A1': {'code': 'r->connection->destroyed = 1;\n\npool = r->pool;\nr->pool = NULL;\n\nngx_destroy_pool(pool);', 'explanation': 'These lines mark the connection as destroyed and free the allocated memory pool, effectively performing the cleanup associated with closing the request and, by extension, the connection. This matches the action of gracefully ending the connection once it is no longer needed.'}}]","While the spec states that a client, server, or proxy may close the transport connection at any time and recommends a graceful closure in some circumstances, this function only partially addresses that. It cleanly frees allocated resources and, in the case of a timed‑out connection, applies an immediate close via SO_LINGER. However, additional aspects mentioned in the spec such as constant monitoring for closure signals or handling non‑timed‑out graceful closes are not visible within this function. Therefore, only parts of the RFC’s intent are implemented here.",success,
1991,ngx_http_free_request,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The function ngx_http_free_request is responsible for cleaning up and closing an HTTP request rather than generating or verifying protocol elements. The RFC specification requires that a sender must not generate protocol elements that do not match the ABNF grammar, and that it must not generate protocol elements reserved for other roles. There is no code in this function that addresses these requirements; it neither generates protocol elements nor verifies their conformity to the grammar. Therefore, the code function does not visibly address any of the labeled conditions or actions in the spec.",success,
1993,ngx_http_close_connection,Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection.,325,Fully Matches,"[{'C1': {'code': 'if (c->ssl) {\n    if (ngx_ssl_shutdown(c) == NGX_AGAIN) {\n        c->ssl->handler = ngx_http_close_connection;\n        return;\n    }\n}', 'explanation': 'The function checks if the connection is SSL-enabled and then calls ngx_ssl_shutdown, which is responsible for initiating the TLS closure alert exchange. If the shutdown is not complete (returns NGX_AGAIN), it defers final closure by setting c->ssl->handler and returning early. This effectively attempts to exchange closure alerts before closing the connection, fulfilling the RFC requirement.'}}]","The RFC requires that servers attempt to initiate an exchange of closure alerts with the client before closing the connection. In the provided function_body, the SSL block verifies if the connection is secure and initiates the shutdown sequence (which sends the closure alert) via ngx_ssl_shutdown. If the shutdown is pending, it schedules another call by setting the handler. This logic is contained entirely within the function and meets the specification for secure connections. For non-SSL connections, closure alerts are not applicable, so the function’s behavior is appropriate in context. Therefore, the function fully matches the specified RFC constraint.",success,
2024,ngx_http_read_client_request_body_handler,"A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.",310,Partially Matches,"[{'A1': {'code': 'if (r->connection->read->timedout) {\n    r->connection->timedout = 1;\n    ngx_http_finalize_request(r, NGX_HTTP_REQUEST_TIME_OUT);\n    return;\n}', 'explanation': ""This code segment checks for a timeout on the connection's read event and, if true, finalizes the request with a timeout error response. This implements the RFC's allowance for sending an error response when an incomplete request is detected due to a timeout.""}}]","The RFC specifies that a server may send an error response when an incomplete request message is received (e.g., due to a cancellation or timeout). The provided function checks for a timeout condition and sends an error response accordingly. However, it does not explicitly address other scenarios (such as a canceled request) mentioned in the RFC. Thus, while the function does implement part of the requirement, it only partially matches the overall specification.",success,
2024,ngx_http_read_client_request_body_handler,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (r->connection->read->timedout) {\n    r->connection->timedout = 1;\n    ngx_http_finalize_request(r, NGX_HTTP_REQUEST_TIME_OUT);\n    return;\n}', 'explanation': ""This segment checks whether the connection’s read event has timed out and then marks the connection as timed out before finalizing the request with a timeout code. This action directly addresses the RFC’s allowance for closing the transport connection (for example, when a timeout occurs), thereby partially meeting the spec's conditions regarding connection closure.""}}]","The RFC states that a client, server, or proxy may close the transport connection at any time, and further emphasizes that a graceful close is recommended upon timeouts. The code function checks for a timeout condition and immediately finalizes the request if a timeout is detected. However, while it does handle the abrupt closure (by finalizing with a timeout error), it does not incorporate a more graceful shutdown process or persistent connection management as suggested in the broader context of the RFC. Therefore, the function only partially implements the intent of the RFC specification within its limited responsibility.",success,
2025,ngx_http_do_read_client_request_body,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'if (!c->read->ready || rb->rest == 0) {\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n    ngx_add_timer(c->read, clcf->client_body_timeout);\n\n    if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    return NGX_AGAIN;\n}', 'explanation': 'This segment checks whether the read event is not ready or the request body is not fully received and then adds a timer and calls ngx_handle_read_event. By returning NGX_AGAIN (i.e. deferring further processing) instead of terminating the connection outright, it attempts to sustain the connection, as recommended in the spec.'}}, {'A1': {'code': 'if (rb->buf->last == rb->buf->end) {\n    /* update chains */\n\n    rc = ngx_http_request_body_filter(r, NULL);\n\n    if (rc != NGX_OK) {\n        return rc;\n    }\n\n    if (rb->busy != NULL) {\n        if (r->request_body_no_buffering) {\n            if (c->read->timer_set) {\n                ngx_del_timer(c->read);\n            }\n\n            if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            return NGX_AGAIN;\n        }\n\n        if (rb->filter_need_buffering) {\n            clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n            ngx_add_timer(c->read, clcf->client_body_timeout);\n\n            if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            return NGX_AGAIN;\n        }\n\n        ngx_log_error(NGX_LOG_ALERT, c->log, 0,\n                      ""busy buffers after request body flush"");\n\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n    flush = 0;\n    rb->buf->pos = rb->buf->start;\n    rb->buf->last = rb->buf->start;\n}', 'explanation': ""Here, the function handles situations where the request body's input buffer is full and buffering is required. Instead of terminating the connection, it uses event handling and timers to wait for more data. This shows that the server is relying on transport-level flow-control (i.e. postponing action until the channel is ready) rather than immediately closing the connection, aligning with the spec's recommendation.""}}]","The function implements a non‐blocking loop to read the client request body. It preserves the connection by returning NGX_AGAIN and scheduling timers when data is not immediately available, which is consistent with the RFC’s recommendation to sustain persistent connections and rely on underlying transport flow control to handle temporary overloads. However, since the broader handling of persistent connections (beyond reading the request body) may occur elsewhere in the system, this function only partially meets the overall specification.",success,
2025,ngx_http_do_read_client_request_body,"If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.",202,Fully Matches,"[{'C1': {'code': 'if (n == 0 || n == NGX_ERROR) {\n    c->error = 1;\n    return NGX_HTTP_BAD_REQUEST;\n}', 'explanation': ""When an unrecoverable error occurs during the reading of the client request body, this code branch sets the connection's error flag and returns NGX_HTTP_BAD_REQUEST (which corresponds to a 400 status code). This directly implements the RFC requirement to respond with a 400 Bad Request when an unrecoverable error is encountered in a request message.""}}]","The function ngx_http_do_read_client_request_body monitors errors during reading the client request body. In the event that the connection receive call returns 0 (indicating premature closure) or NGX_ERROR, the function sets an error flag on the connection and returns NGX_HTTP_BAD_REQUEST. This immediately satisfies the RFC mandate to respond with a 400 status code for unrecoverable errors in request messages. Although the actual connection closure is not explicitly done within this function, it is implied that returning a 400 error, along with the error flag, will lead to the connection being closed later by the higher-level logic, thus ensuring the RFC behavior is followed.",success,
2030,ngx_http_discard_request_body,"A server MUST read the entire request message body or close the connection after sending its response; otherwise, the remaining data on a persistent connection would be misinterpreted as the next request.",312,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.content_length_n <= 0 && !r->headers_in.chunked) {\n    return NGX_OK;\n}\n\n/* … */\n\nrc = ngx_http_read_discarded_request_body(r);\n\nif (rc == NGX_OK) {\n    r->lingering_close = 0;\n    return NGX_OK;\n}\n\n/* rc >= NGX_HTTP_SPECIAL_RESPONSE case and setting up the discarded request body handler */', 'explanation': 'The RFC requires that a server must either read the entire request message body or close the connection after sending its response. This function implements that behavior by first checking if there is any body data by verifying the content length and chunked encoding. If body data exists, it calls functions (ngx_http_discard_request_body_filter and ngx_http_read_discarded_request_body) to read/discard the remaining request body. When the discard operation is successful (rc == NGX_OK), lingering_close is disabled (set to 0), ensuring that the entire body has been processed. This code segment directly implements the requirement, thus fully meeting the constraint labeled C1.'}}]","The function 'ngx_http_discard_request_body' is designed to ensure that any remaining request body is read (or discarded) before further processing, which directly addresses the RFC requirement. By checking for the presence of a message body and then reading/discarding it via specific function calls, the code prevents leftover data from causing misinterpretation of subsequent requests on persistent connections. The implementation in this function alone meets the labelled condition (C1) from the specification.",success,
2031,ngx_http_discarded_request_body_handler,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (rev->timedout) {\n    c->timedout = 1;\n    c->error = 1;\n    ngx_http_finalize_request(r, NGX_ERROR);\n    return;\n}', 'explanation': 'This code segment checks if the read event is timed out (a potential signal that the peer has closed the connection), which aligns with the RFC specification that a client, server, or proxy may close the connection at any time. It addresses monitoring for a closure signal.'}}, {'A1': {'code': 'if (r->lingering_time) {\n    timer = (ngx_msec_t) r->lingering_time - (ngx_msec_t) ngx_time();\n\n    if ((ngx_msec_int_t) timer <= 0) {\n        r->discard_body = 0;\n        r->lingering_close = 0;\n        ngx_http_finalize_request(r, NGX_ERROR);\n        return;\n    }\n\n} else {\n    timer = 0;\n}\n\nrc = ngx_http_read_discarded_request_body(r);\n\nif (rc == NGX_OK) {\n    r->discard_body = 0;\n    r->lingering_close = 0;\n    r->lingering_time = 0;\n    ngx_http_finalize_request(r, NGX_DONE);\n    return;\n}', 'explanation': 'This segment implements logic for a graceful closing approach by monitoring lingering time, attempting to read and discard the remaining request body, and finalizing the request appropriately. This aligns with the recommendation that connections should be closed gracefully to allow resource reclamation.'}}]","The function addresses part of the RFC specifications by monitoring for closure signals (through the check for a timed-out read event) and by implementing a lingering close mechanism to gracefully handle connection shutdown. However, it does not cover all aspects of the RFC (for example, it does not actively manage flow control or persistent connection behavior), so the match is partial.",success,
2031,ngx_http_discarded_request_body_handler,"A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.",310,Fully Matches,"[{'C1': {'code': 'if (rev->timedout) {\n    c->timedout = 1;\n    c->error = 1;\n    ngx_http_finalize_request(r, NGX_ERROR);\n    return;\n}\n\nif (r->lingering_time) {\n    timer = (ngx_msec_t) r->lingering_time - (ngx_msec_t) ngx_time();\n\n    if ((ngx_msec_int_t) timer <= 0) {\n        r->discard_body = 0;\n        r->lingering_close = 0;\n        ngx_http_finalize_request(r, NGX_ERROR);\n        return;\n    }\n}', 'explanation': ""These code segments detect situations where the request is incomplete, either because the read event timed out or because the lingering period expired, which matches the spec's condition of receiving an incomplete request message.""}}, {'A1': {'code': 'c->error = 1;\nngx_http_finalize_request(r, NGX_ERROR);', 'explanation': 'This code sends an error response (by finalizing the request with an error code) before closing the connection, thus meeting the action of sending an error response when an incomplete request is detected.'}}]","The function explicitly checks if the connection’s read event has timed out and if the lingering time has expired. In both cases, it finalizes the request with an error code, effectively sending an error response prior to closing the connection. This implementation within function_body directly addresses the spec's requirements for handling an incomplete request message.",success,
2033,ngx_http_read_discarded_request_body,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Does Not Match,[],"The provided function 'ngx_http_read_discarded_request_body' is responsible only for reading and discarding the body of a request. It does not contain any explicit logic to sustain persistent connections or to allow the underlying transport's flow-control mechanisms to resolve temporary overloads as required by the RFC specification. There is no evidence within this function of handling conditions such as maintaining a persistent connection in the face of overload or employing flow-control measures, nor is there logic to monitor for an error response during transmission. Hence, none of the spec's conditions or actions (e.g., those that would be labeled as C1, A1, etc.) are implemented within this function.",success,
2033,ngx_http_read_discarded_request_body,"A server MUST read the entire request message body or close the connection after sending its response; otherwise, the remaining data on a persistent connection would be misinterpreted as the next request.",312,Fully Matches,"[{'C1': {'code': 'for ( ;; ) {\n    if (r->headers_in.content_length_n == 0) {\n        break;\n    }\n    ...\n    n = r->connection->recv(r->connection, buffer, size);\n    if (n <= 0) {\n        return n == NGX_ERROR ? (r->connection->error = 1, NGX_OK) : n;\n    }\n    rc = ngx_http_discard_request_body_filter(r, &b);\n    if (rc != NGX_OK) {\n        return rc;\n    }\n}\n\nif (ngx_http_copy_pipelined_header(r, &b) != NGX_OK) {\n    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n}\n\nr->read_event_handler = ngx_http_block_reading;\n\nreturn NGX_OK;', 'explanation': 'The function implements the requirement to fully read the request message body by entering a loop that continues reading chunks from the connection until the remaining content length is reduced to zero. This ensures that the entire message body is consumed, preventing any remaining data on a persistent connection from interfering with subsequent requests.'}}]","The RFC requires that a server must either read the entire request message body or close the connection to avoid misinterpreting any leftover data. This function, by repeatedly reading chunks of the request body in a loop until the content_length_n value is zero, directly addresses this requirement. All logic relevant to this specification is contained within the function itself, fulfilling the RFC constraint.",success,
2035,ngx_http_discard_request_body_filter,"If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.",202,Partially Matches,"[{'A1': {'code': 'if (rc != NGX_OK && rc != NGX_DONE && rc != NGX_AGAIN) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""client sent invalid chunked body"");\n    return NGX_HTTP_BAD_REQUEST;\n}', 'explanation': 'This segment handles the case when an unrecoverable error occurs during chunked transfer parsing by logging the error and returning NGX_HTTP_BAD_REQUEST, which corresponds to sending a 400 Bad Request response as required by the RFC.'}}]","The function partially implements the RFC requirement by addressing the error in a chunked request: it logs the error and returns a 400 status code. However, it does not cover all scenarios described in the RFC spec (for example, handling invalid Content-Length in non-chunked requests or explicitly closing the connection), and some actions (like closing the connection after sending 400) are likely handled elsewhere. Therefore, the code function only partially matches the specifications.",success,
2035,ngx_http_discard_request_body_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The provided function focuses on discarding the request body by adjusting pointers and counts based on whether the request is chunked or not. While it does log an error and return NGX_HTTP_BAD_REQUEST for invalid chunked bodies, it does not perform any explicit validation of the Content-Length header field value against the correct ABNF or verify that the content-length is correct before forwarding the message. Thus, the function does not implement the spec requirement that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",success,
2035,ngx_http_discard_request_body_filter,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",175,Partially Matches,"[{'A1': {'code': 'if (rc != NGX_OK && rc != NGX_DONE && rc != NGX_AGAIN) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""client sent invalid chunked body"");\n    return NGX_HTTP_BAD_REQUEST;\n}', 'explanation': ""This segment detects an invalid chunked body (i.e. when the parsed chunk does not meet expected grammar) and returns a 400 (Bad Request) response. This partially fulfills the spec's requirement of responding with 400 upon receiving a message that does not match the HTTP-message grammar.""}}]","The function includes logic to detect an invalid chunked body and returns a 400 error code, which is in line with the spec’s requirement to send a 400 response when the message does not meet the HTTP-message grammar. However, other aspects of the spec (such as handling of whitespace-preceded lines between the start-line and header fields) are not addressed in this function. Since only part of the spec constraints is handled within the function_body itself, the overall match is considered partial.",success,
2035,ngx_http_discard_request_body_filter,A recipient MUST be able to parse and decode the chunked transfer coding.,204,Partially Matches,"[{'C1': {'code': 'if (r->headers_in.chunked) {\n    ...\n    for ( ;; ) {\n        rc = ngx_http_parse_chunked(r, b, rb->chunked, 0);\n        if (rc == NGX_OK) {\n            size = b->last - b->pos;\n            if ((off_t) size > rb->chunked->size) {\n                b->pos += (size_t) rb->chunked->size;\n                rb->chunked->size = 0;\n            } else {\n                rb->chunked->size -= size;\n                b->pos = b->last;\n            }\n            continue;\n        }\n        if (rc == NGX_DONE) {\n            r->headers_in.content_length_n = 0;\n            break;\n        }\n        if (rc == NGX_AGAIN) {\n            cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n            r->headers_in.content_length_n = ngx_max(rb->chunked->length, (off_t) cscf->large_client_header_buffers.size);\n            break;\n        }\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""client sent invalid chunked body"");\n        return NGX_HTTP_BAD_REQUEST;\n    }\n}', 'explanation': 'The code checks whether the incoming request is chunked, then enters a loop where it calls ngx_http_parse_chunked to process each chunk. It handles success, completion (via NGX_DONE indicating a zero-sized final chunk), and error conditions. This segment attempts to address the RFC requirement to parse chunked transfer coding.'}}]","The function shows visible logic for handling chunked transfer encoding by checking the 'chunked' flag and looping over chunk data. It calls ngx_http_parse_chunked to do the detailed parsing and takes appropriate action upon completion (NGX_DONE) or error. However, aspects of the RFC specification—specifically details related to processing very large hexadecimal numeral values and guarding against integer conversion overflows—are not handled directly in this function's code but presumably deferred to ngx_http_parse_chunked. Thus, while the function implements some key parts of chunked transfer decoding, it only partially meets the full set of requirements as stated in the RFC specification.",success,
2035,ngx_http_discard_request_body_filter,A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance.,187,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.chunked) {\n    ...\n    rc = ngx_http_parse_chunked(r, b, rb->chunked, 0);\n    if (rc == NGX_OK) { ... }\n    if (rc == NGX_DONE) { ... }\n    if (rc == NGX_AGAIN) { ... }\n    ...\n}', 'explanation': 'This block checks if the incoming request uses chunked transfer coding and then enters a loop that repeatedly calls ngx_http_parse_chunked to parse each chunk. This behavior directly implements the RFC requirement that a recipient MUST be able to parse the chunked transfer coding.'}}, {'A1': {'code': 'if (rc != NGX_OK && rc != NGX_DONE && rc != NGX_AGAIN) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""client sent invalid chunked body"");\n    return NGX_HTTP_BAD_REQUEST;\n}', 'explanation': 'This segment handles the error case when the chunked data is invalid, logging an error and returning a 400 status. This defensive measure ensures that improperly formed chunked bodies do not get processed further, aligning with the safe parsing required by the RFC.'}}]","The provided function first checks if the request uses chunked transfer coding. If so, it initializes necessary structures and enters a loop to parse each chunk; if the parsing is complete (NGX_DONE) it resets appropriate length values, and if more data is needed (NGX_AGAIN) it sets up for the subsequent read. In cases of errors during parsing, it logs the issue and returns an HTTP_BAD_REQUEST. These implementations within the function directly satisfy the principal requirement of the RFC specification that a recipient must be able to parse chunked transfer coding. Thus, the code function fully matches the specification by its own internal logic.",success,
2037,ngx_http_test_expect,* A server that receives a 100-continue expectation in an HTTP/1.0 request MUST ignore that expectation.,80,Partially Matches,"[{'C1': {'code': 'if (r->expect_tested\n        || r->headers_in.expect == NULL\n        || r->http_version < NGX_HTTP_VERSION_11\n#if (NGX_HTTP_V2)\n        || r->stream != NULL\n#endif\n#if (NGX_HTTP_V3)\n        || r->connection->quic != NULL\n#endif\n       )\n    {\n        return NGX_OK;\n    }', 'explanation': ""This code checks if the HTTP version is less than HTTP/1.1 (i.e. HTTP/1.0) and immediately returns NGX_OK, thereby ignoring the 'Expect' header, fulfilling the RFC requirement for HTTP/1.0 requests.""}}]","The function properly ignores the 100-continue expectation for HTTP/1.0 by checking if the HTTP version is less than HTTP/1.1 and returning early. When the version is HTTP/1.1, it processes the header and sends a 100 Continue response. However, the function does not handle the additional RFC nuance that a server may omit sending a 100 Continue response if content has already been received or if there is no content. Thus, only part of the spec constraints is implemented in this function.",success,
2037,ngx_http_test_expect,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Fully Matches,"[{'C1': {'code': 'if (r->expect_tested\n    || r->headers_in.expect == NULL\n    || r->http_version < NGX_HTTP_VERSION_11\n#if (NGX_HTTP_V2)\n    || r->stream != NULL\n#endif\n#if (NGX_HTTP_V3)\n    || r->connection->quic != NULL\n#endif\n   )\n{\n    return NGX_OK;\n}\n\nexpect = &r->headers_in.expect->value;\n\nif (expect->len != sizeof(""100-continue"") - 1\n    || ngx_strncasecmp(expect->data, (u_char *) ""100-continue"",\n                           sizeof(""100-continue"") - 1)\n           != 0)\n{\n    return NGX_OK;\n}', 'explanation': ""This segment confirms that the function only acts on a request that properly contains the 'Expect: 100-continue' header and meets HTTP/1.1 requirements, thereby ensuring that no protocol element is generated unless the sender (the server) is in a role allowed to send a 100 Continue response.""}}, {'A1': {'code': 'n = r->connection->send(r->connection,\n                            (u_char *) ""HTTP/1.1 100 Continue"" CRLF CRLF,\n                            sizeof(""HTTP/1.1 100 Continue"" CRLF CRLF) - 1);\n\nif (n == sizeof(""HTTP/1.1 100 Continue"" CRLF CRLF) - 1) {\n    return NGX_OK;\n}\n\nr->connection->error = 1;\n\nreturn NGX_ERROR;', 'explanation': 'This segment implements the action of sending the 100 Continue response. By conditioning the send on strict tests, it ensures that the server only generates the protocol element that belongs to its allowed role.'}}]","The function inspects the incoming request to determine whether it should issue a 100 Continue response. It first checks that the proper conditions are met (e.g., HTTP version 1.1, presence and correct value of the Expect header) and only then sends the 100 Continue response, thereby ensuring that the server does not generate protocol elements that are reserved for a different role. This behavior directly aligns with the RFC requirement that a sender must not generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles.",success,
2037,ngx_http_test_expect,A server MUST NOT send a version to which it is not conformant.,248,Does Not Match,[],"The provided function, ngx_http_test_expect, only handles the processing of the Expect header and sends a hard-coded ""HTTP/1.1 100 Continue"" response when appropriate. It checks that the request is at least HTTP/1.1, but it does not contain any logic to determine or verify server conformance to a particular HTTP version before sending the response. In other words, there is no code that ensures the server is conformant to the response version (i.e., not sending a version to which it is not conformant), as required by the RFC specification. Thus, by itself, this function does not implement the specific RFC constraint.",success,
2037,ngx_http_test_expect,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'if (expect->len != sizeof(""100-continue"") - 1\n    || ngx_strncasecmp(expect->data, (u_char *) ""100-continue"",\n                       sizeof(""100-continue"") - 1) != 0)\n{\n    return NGX_OK;\n}', 'explanation': 'This code verifies that the \'Expect\' header exactly matches the literal ""100-continue"", ensuring that only a correctly formed, grammar-compliant value is processed. This prevents the function from generating protocol elements unless the input matches the expected ABNF rules.'}}, {'A1': {'code': 'n = r->connection->send(r->connection,\n                        (u_char *) ""HTTP/1.1 100 Continue"" CRLF CRLF,\n                        sizeof(""HTTP/1.1 100 Continue"" CRLF CRLF) - 1);', 'explanation': 'Upon verifying that the header conforms, the function sends the ""HTTP/1.1 100 Continue"" response, a protocol element that exactly matches the expected grammar. This action directly implements the requirement not to generate protocol elements differing from those defined by ABNF.'}}]","The function implements the RFC requirement by first validating that the 'Expect' header exactly matches '100-continue', thereby ensuring that no malformed or unintended protocol elements are produced. Only upon successful validation does it send the clearly defined 'HTTP/1.1 100 Continue' response. This logic directly addresses the specification's mandate that a sender MUST NOT generate protocol elements that do not match the grammar.",success,
2037,ngx_http_test_expect,The origin server MUST NOT wait for the content before sending the 100 (Continue) response.,84,Fully Matches,"[{'C1': {'code': 'if (r->expect_tested\n    || r->headers_in.expect == NULL\n    || r->http_version < NGX_HTTP_VERSION_11\n#if (NGX_HTTP_V2)\n    || r->stream != NULL\n#endif\n#if (NGX_HTTP_V3)\n    || r->connection->quic != NULL\n#endif\n   )\n{\n    return NGX_OK;\n}\n\nr->expect_tested = 1;\n\nexpect = &r->headers_in.expect->value;\n\nif (expect->len != sizeof(""100-continue"") - 1\n    || ngx_strncasecmp(expect->data, (u_char *) ""100-continue"",\n                        sizeof(""100-continue"") - 1)\n       != 0)\n{\n    return NGX_OK;\n}', 'explanation': ""This segment checks that the request is HTTP/1.1 or later and that the 'Expect' header is present with the exact value '100-continue', ensuring that only valid requests trigger a 100 Continue response.""}}, {'A1': {'code': 'ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n               ""send 100 Continue"");\n\nn = r->connection->send(r->connection,\n                        (u_char *) ""HTTP/1.1 100 Continue"" CRLF CRLF,\n                        sizeof(""HTTP/1.1 100 Continue"" CRLF CRLF) - 1);\n\nif (n == sizeof(""HTTP/1.1 100 Continue"" CRLF CRLF) - 1) {\n    return NGX_OK;\n}', 'explanation': ""This segment sends the 100 Continue response immediately without waiting for the request content, directly aligning with the spec's requirement that the origin server must not wait for the content before sending the 100 response.""}}]",The function inspects the HTTP request and verifies that it contains an 'Expect: 100-continue' header and that the HTTP version is at least 1.1. It then immediately sends a 100 Continue response via a direct send operation. This logic implemented within the function directly adheres to and fulfills the specification that the origin server must not wait for the request content before sending the 100 Continue response.,success,
2038,ngx_http_request_body_filter,A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance.,187,Partially Matches,[],"The function checks whether the incoming HTTP request has a chunked transfer encoding (by examining r->headers_in.chunked) and then delegates processing to ngx_http_request_body_chunked_filter if true, otherwise to ngx_http_request_body_length_filter. This shows that it distinguishes between chunked and non‐chunked transfer codings, which is one aspect of the RFC's requirement to parse chunked coding. However, the actual parsing logic for handling the chunked transfer coding is not implemented directly in this function but is delegated to another function. In the context of the provided instructions—where only direct logic within the function counts—the implementation only partially addresses the RFC requirement.",success,
2041,ngx_http_request_body_chunked_filter,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (clcf->client_max_body_size\n                    && clcf->client_max_body_size\n                       - r->headers_in.content_length_n < rb->chunked->size)\n                {\n                    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                                  ""client intended to send too large chunked ""\n                                  ""body: %O+%O bytes"",\n                                  r->headers_in.content_length_n,\n                                  rb->chunked->size);\n\n                    r->lingering_close = 1;\n\n                    return NGX_HTTP_REQUEST_ENTITY_TOO_LARGE;\n                }', 'explanation': 'This segment defends against receiving an overly large chunk by checking the configured maximum body size, setting a reasonable limit on the buffer size based on the server configuration.'}}, {'A1': {'code': 'rc = ngx_http_parse_chunked(r, cl->buf, rb->chunked, 0);\n\nif (rc == NGX_OK) {\n    /* handling a successfully parsed chunk */\n    ...\n    continue;\n}\n\nif (rc == NGX_DONE) {\n    /* handling end of chunked body */\n    rb->rest = 0;\n    ...\n    break;\n}\n\nif (rc == NGX_AGAIN) {\n    rb->rest = ngx_max(rb->chunked->length, (off_t) cscf->large_client_header_buffers.size);\n    break;\n}\n\n/* invalid case */\nngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n              ""client sent invalid chunked body"");\n\nreturn NGX_HTTP_BAD_REQUEST;', 'explanation': 'This portion manages various outcomes from parsing the chunked body (OK, DONE, AGAIN, and invalid), showing a defensive reaction to unexpected or nonconforming input as described by the RFC.'}}]","The function implements defensive parsing by validating parsed chunk data, limiting body size based on a configured buffer and by handling different outcomes from the chunk parser (including invalid or incomplete data). This aligns with the RFC's guidance to parse input defensively with only marginal assumptions about its conformity. However, the function delegates detailed ABNF conformance checking to the helper function ngx_http_parse_chunked, rather than implementing it directly, meaning that only parts of the spec requirements are addressed within this function alone, leading to a partial match.",success,
2041,ngx_http_request_body_chunked_filter,A recipient MUST be able to parse and decode the chunked transfer coding.,204,Partially Matches,"[{'C1': {'code': 'rc = ngx_http_parse_chunked(r, cl->buf, rb->chunked, 0);\n\nif (rc == NGX_DONE) {\n    /* a whole response has been parsed successfully */\n    rb->rest = 0;\n    ...\n}', 'explanation': 'This segment shows that the function delegates the parsing of the chunked transfer coding (including interpreting the hex chunk-size and detecting the terminating zero-size chunk) by using ngx_http_parse_chunked and then handling the NGX_DONE condition as the end-of-body indicator.'}}, {'A1': {'code': 'if (clcf->client_max_body_size && clcf->client_max_body_size - r->headers_in.content_length_n < rb->chunked->size) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""client intended to send too large chunked body: %O+%O bytes"",\n                  r->headers_in.content_length_n,\n                  rb->chunked->size);\n    r->lingering_close = 1;\n    return NGX_HTTP_REQUEST_ENTITY_TOO_LARGE;\n}', 'explanation': 'This code checks that the size of the newly parsed chunk does not exceed the allowed client body size, thereby addressing part of the specification’s concerns about handling potentially large hexadecimal numerals (and preventing issues like integer overflows or precision errors) by enforcing a limit.'}}]","The function exhibits logic that decodes chunked transfer coding by invoking ngx_http_parse_chunked and handling its return codes. In doing so, it covers key aspects of the RFC requirement such as processing the hex-encoded chunk-size and recognizing the final zero-length chunk. It also guards against overly large chunk sizes by comparing against a configured maximum body size. However, core details like converting the hexadecimal chunk-size and robust overflow prevention are performed in the delegated function ngx_http_parse_chunked rather than within this function itself. As a result, while the function visibly addresses some labeled conditions and actions of the spec (delegating to and handling the results of parsing), it only partially implements the complete set of requirements on its own.",success,
2041,ngx_http_request_body_chunked_filter,A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance.,187,Fully Matches,"[{'C1': {'code': 'rc = ngx_http_parse_chunked(r, cl->buf, rb->chunked, 0);\nif (rc == NGX_OK) {\n    /* a chunk has been parsed successfully */\n    ...\n}\nif (rc == NGX_DONE) {\n    /* a whole response has been parsed successfully */\n    ...\n}\nif (rc == NGX_AGAIN) {\n    /* set rb->rest, amount of data we want to see next time */\n    ...\n}\n\nngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n              ""client sent invalid chunked body"");\nreturn NGX_HTTP_BAD_REQUEST;', 'explanation': 'The function explicitly parses the incoming chunked encoded request body by repeatedly calling ngx_http_parse_chunked and handling its return values (NGX_OK, NGX_DONE, NGX_AGAIN). It also deals with error reporting for invalid chunked bodies, which shows that it fully implements the recipient requirement to parse the chunked transfer coding as dictated by the RFC.'}}, {'A1': {'code': 'if (b\n    && rb->chunked->size <= 128\n    && cl->buf->last - cl->buf->pos >= rb->chunked->size)\n{\n    r->headers_in.content_length_n += rb->chunked->size;\n    if (rb->chunked->size < 8) {\n        while (rb->chunked->size) {\n            *b->last++ = *cl->buf->pos++;\n            rb->chunked->size--;\n        }\n    } else {\n        ngx_memmove(b->last, cl->buf->pos, rb->chunked->size);\n        b->last += rb->chunked->size;\n        cl->buf->pos += rb->chunked->size;\n        rb->chunked->size = 0;\n    }\n    continue;\n}', 'explanation': 'This segment shows how the function properly frames the message body by adjusting pointers and updating the content length as each chunk is processed. This behavior ensures that dynamically generated content is accurately delimited without a known overall size, matching the RFC’s requirement for framing messages.'}}]","The function 'ngx_http_request_body_chunked_filter' directly implements the logic required by the HTTP RFC for handling chunked transfer coding. It establishes the necessary structures, invokes a dedicated parsing routine, processes each chunk accordingly (including updating content lengths and handling partial data with NGX_AGAIN), and manages error cases (invalid chunked bodies). Thus, within its own logic, it fully addresses both the condition that a recipient must be capable of parsing chunked encoding (C1) and the action of properly framing the message body when the content size is unknown (A1). Dependencies aside, the function effectively meets the spec constraints.",success,
2041,ngx_http_request_body_chunked_filter,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",175,Partially Matches,"[{'A1': {'code': 'if (rc != NGX_OK && rc != NGX_DONE && rc != NGX_AGAIN) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""client sent invalid chunked body"");\n    return NGX_HTTP_BAD_REQUEST;\n}', 'explanation': 'This segment checks the result of the chunked body parsing. When the parser does not return NGX_OK, NGX_DONE or NGX_AGAIN (i.e. the received octets do not match the HTTP-message grammar), the code logs an error and returns a 400 Bad Request. This implements the RFC’s requirement to respond with a 400 error when the request is malformed.'}}]","The function attempts to handle malformed chunked bodies by checking the parser's return code and, if an error is detected, responding with a 400 Bad Request. This corresponds to the RFC's mandate to reject HTTP messages that do not match the grammar. However, the function does not address other parts of the spec context (such as improper whitespace handling between the start-line and headers), meaning that while part of the RFC is implemented within this function, it does not cover all details. Therefore, the match is only partial from the perspective of this isolated function.",success,
2041,ngx_http_request_body_chunked_filter,"If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.",202,Partially Matches,"[{'A1': {'code': 'if (rc != NGX_OK && rc != NGX_DONE && rc != NGX_AGAIN) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""client sent invalid chunked body"");\n    return NGX_HTTP_BAD_REQUEST;\n}', 'explanation': 'When the chunked body parser returns an unexpected value (indicating an unrecoverable error in the request), the code logs an error and returns NGX_HTTP_BAD_REQUEST (which corresponds to a 400 status code). This is an attempt to meet the RFC requirement stating that a 400 response be sent for unrecoverable errors in a request message. However, the function does not explicitly close the connection within its own logic, so only part of the specification is handled here.'}}]","The RFC requires that an unrecoverable error in a request message should result in sending a 400 (Bad Request) response and then closing the connection. In this function, when an invalid chunked body is detected, an error is logged and NGX_HTTP_BAD_REQUEST is returned (matching the 400 response requirement). There is no explicit connection closure in this function; the responsibility for closing the connection may lie in the caller or higher-level logic. Therefore, the function only partially implements the specification by handling the 400 status response without directly managing the connection closure.",success,
2066,ngx_http_destination_charset,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function 'ngx_http_destination_charset' is dedicated to determining and setting the response charset based on headers and configuration. It does not contain any logic that enforces the RFC requirement that a sender must not generate protocol elements or syntax alternatives that are only allowed for participants in other roles. There is no segment within the function that explicitly checks or prevents the generation of such elements based on role, hence it does not implement the noted specification constraints (e.g., C1, A1) within its own scope.",success,
2071,ngx_http_charset_ctx,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The RFC requires that a sender must not forward a message with a Content-Length header value that is known to be incorrect. This function does not verify the correctness of the Content-Length header value nor does it check if the header’s value matches the ABNF form. Instead, it unconditionally clears the Content-Length header (via ngx_http_clear_content_length) when a charset conversion is performed on the main request. This behavior does not constitute a check against or handling of an 'incorrect' Content-Length as specified by the RFC. Therefore, within its own logic, the function does not implement any of the labeled conditions or actions from the specification.",success,
2208,ngx_http_flv_handler,All general-purpose servers MUST support the methods GET and HEAD,58,Fully Matches,"[{'C1': {'code': 'if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {\n    return NGX_HTTP_NOT_ALLOWED;\n}', 'explanation': ""This code segment explicitly checks if the incoming HTTP request's method is either GET or HEAD. If neither of these methods is used, the function immediately returns an HTTP status denying the request, thereby ensuring that only GET and HEAD are accepted, which directly implements the RFC requirement that all general-purpose servers must support the methods GET and HEAD.""}}]","The analyzed function clearly enforces support for the GET and HEAD methods by validating the request method at the very beginning. This behavior directly fulfills the RFC constraint requiring general-purpose servers to support these methods, as the function rejects any request that does not use GET or HEAD. No other spec constraints are applicable within this function, making the match full and clear.",success,
2208,ngx_http_flv_handler,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'A1': {'code': 'r->headers_out.content_length_n = len;', 'explanation': 'The function computes the content length based on the file size (and possible adjustment in case of a start parameter) and then assigns it to the Content-Length header field. This directly attempts to implement the RFC requirement of sending a Content-Length header when the content size is known.'}}]","The RFC requires that, in the absence of Transfer-Encoding and aside from special cases (such as responses with status 1xx, 204, or 2xx for CONNECT requests), an origin server SHOULD send a Content-Length header when the content size is known. The provided function calculates the file size (or an adjusted size when a 'start' parameter is provided) and then sets the Content-Length header via 'r->headers_out.content_length_n = len;'. While the function addresses this part of the RFC (met constraint A1), it does not incorporate logic to omit the Content-Length header for the exceptional status codes specified in the broader context. Thus, in isolation, this function partially matches the RFC specification.",success,
2208,ngx_http_flv_handler,"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.",57,Fully Matches,"[{'A1': {'code': 'if (ngx_http_set_etag(r) != NGX_OK) {\n    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n}', 'explanation': 'This segment directly calls ngx_http_set_etag(r) to generate and set the ETag header as required by the RFC. It ensures that for the selected representation, an ETag is sent for change detection and cache validation.'}}]","The function visibly addresses the RFC requirement by including a call to ngx_http_set_etag, which is responsible for setting the ETag header. This matches the spec's mandate that an origin server SHOULD send an ETag for representations where change detection is possible, thus fully implementing the corresponding action (labeled here as A1) within the function.",success,
2208,ngx_http_flv_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'if (ngx_http_set_content_type(r) != NGX_OK) {\n    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n}', 'explanation': 'This segment ensures that before sending the response the Content-Type header field is set in the outgoing message, thereby fulfilling the RFC requirement that a sender generating a message with content SHOULD include a Content-Type header.'}}]","The function sends an HTTP response containing file content and explicitly calls ngx_http_set_content_type() to generate the Content-Type header. This direct implementation in the function matches the RFC specification, as the condition of including the Content-Type header when content is present is visibly addressed within the function.",success,
2208,ngx_http_flv_handler,"In 200 responses to GET or HEAD, an origin server SHOULD send any available validator fields (Section 8.8) for the selected representation, with both a strong entity tag and a Last-Modified date being preferred.",141,Fully Matches,"[{'C1': {'code': 'r->headers_out.last_modified_time = of.mtime;', 'explanation': ""The code sets the Last-Modified header using the file's modification time, thereby providing one of the preferred validator fields for a 200 GET/HEAD response.""}}, {'A1': {'code': 'if (ngx_http_set_etag(r) != NGX_OK) {\n    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n}', 'explanation': 'The code calls ngx_http_set_etag to establish the entity tag (ETag) header, which is a validator field and is preferred as per the specification.'}}]","The function processes GET/HEAD requests and, prior to sending a 200 response, explicitly sets both the Last-Modified header and attempts to set the ETag header. This direct implementation of validator fields meets the specification's requirement that an origin server SHOULD send available validator fields (with a preference for a strong entity tag and a Last-Modified date) in 200 responses.",success,
2208,ngx_http_flv_handler,"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.",52,Fully Matches,"[{'A1': {'code': 'r->headers_out.last_modified_time = of.mtime;', 'explanation': ""The code retrieves the file’s modification time (of.mtime) after ensuring the requested resource is a file and then assigns it to the response header field 'last_modified_time'. This directly implements the specification requirement to send a Last-Modified header when a last modification date is determinable.""}}]","The provided function checks that the request method is correct and that the resource is a file. It then obtains the file’s information via ngx_open_cached_file, and crucially, sets the last modification time by assigning 'of.mtime' to 'r->headers_out.last_modified_time'. This line of code meets the HTTP RFC spec requirement that an origin server SHOULD send Last-Modified when available, addressing the spec constraint directly within the function logic.",success,
2208,ngx_http_flv_handler,A server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6).,46,Does Not Match,[],"The specified RFC requires that a server MUST NOT send a Content-Length header in any 2xx (Successful) response to a CONNECT request. This function, however, is designed to handle only GET and HEAD requests. It begins by checking if the method is GET or HEAD and returns an error for other methods (e.g., CONNECT). Moreover, when constructing the response, it always sets a Content-Length header (r->headers_out.content_length_n = len) without any conditional logic related to CONNECT requests. Therefore, the function does not contain any logic that directly addresses the requirement for CONNECT requests, and thus it does not attempt to implement the specified RFC constraint.",success,
2208,ngx_http_flv_handler,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Does Not Match,[],"The provided code function is designed for handling FLV responses, ensuring that a Content-Length header is set (r->headers_out.content_length_n = len) for an NGX_HTTP_OK (200) response. It does not include any logic to check if the response status code is 1xx (Informational) or 204 (No Content) and thus does not prevent setting a Content-Length header in those cases. As a result, the function does not attempt to implement the RFC requirement that a server must not send a Content-Length header for 1xx or 204 responses.",success,
2208,ngx_http_flv_handler,"An origin server that wishes to ""hide"" the current existence of a forbidden target resource MAY instead respond with a status code of 404 (Not Found).",163,Does Not Match,[],"The provided code function does not visibly implement the HTTP RFC requirement. The RFC specifies that an origin server may choose to respond with a 404 (Not Found) status to hide the existence of a forbidden resource. In the function, however, when a file access error due to insufficient permissions occurs (for example, NGX_EACCES), the code explicitly sets the status code to NGX_HTTP_FORBIDDEN (403) rather than opting to return a 404. Additionally, the function does not contain any logic that checks for authentication credentials or decides to obscure resource existence based on insufficient credentials. Therefore, none of the labeled conditions or actions (e.g., C1 or A1 related to hiding a forbidden resource) appear in the function’s code, and it does not fulfill the RFC specification by itself.",success,
2222,ngx_http_headers_filter,"Because of the potential for trailer fields to be discarded in transit, a server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive.",12,Partially Matches,"[{'C1': {'code': 'if (conf->trailers) {\n    h = conf->trailers->elts;\n    for (i = 0; i < conf->trailers->nelts; i++) {\n        if (!safe_status && !h[i].always) {\n            continue;\n        }\n\n        r->expect_trailers = 1;\n        break;\n    }\n}', 'explanation': ""This segment shows that the function examines a trailer configuration and conditionally sets a flag (r->expect_trailers) when it deems it 'safe' to add trailer fields (using safe_status or an 'always' flag). This is an attempt to avoid generating trailer fields in response codes considered less safe. However, it does not check whether the client has indicated willingness to accept trailers through the TE header as described in the spec context.""}}]","The RFC instructs that because trailer fields risk being dropped in transit, a server should not send trailer fields that are necessary for the user agent. The code attempts to conditionally enable trailer processing by checking a 'safe' status and configuration flags before setting the flag for expecting trailers. This partially aligns with the intention of not generating essential trailer fields in unsafe circumstances. However, it fails to verify whether the client has explicitly signaled acceptance (via the TE header containing 'trailers') and so does not fully implement the specification’s requirement. Thus, while some logic addressing trailer conditions is present, not all aspects of the spec are handled solely within this function.",success,
2223,ngx_http_trailers_filter,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Fully Matches,"[{'C1': {'code': 'if (!safe_status && !h[i].always) {\n    continue;\n}', 'explanation': ""This block ensures that trailer fields are only processed when either the HTTP status is considered safe or the trailer configuration explicitly marks the field as 'always' allowed. This check implements the RFC requirement of only merging trailer fields when their definitions are understood and explicitly permit safe merging.""}}, {'A1': {'code': 't = ngx_list_push(&r->headers_out.trailers);\nif (t == NULL) {\n    return NGX_ERROR;\n}\nt->key = h[i].key;\nt->value = value;\nt->hash = 1;', 'explanation': 'This segment actually performs the merging of the trailer field into the trailers list, but only after the conditions (i.e., safe status or explicit permission) are met. This is the action that implements the allowed merging behavior as dictated by the RFC.'}}]","The function 'ngx_http_trailers_filter' checks for the presence of trailer configuration and verifies expected conditions such as the request expecting trailers, and that the response status is safe for appending trailers. It then iterates over the list of potential trailer fields and, using a flag (h[i].always), ensures that only those trailer fields which are explicitly allowed (or if the response status is safe) are merged. This logic directly corresponds to the RFC specification that a recipient MUST NOT merge a trailer field unless it understands the field's definition and it explicitly permits safe merging. Therefore, within its own logic, the function fully addresses the specified conditions (C1) and actions (A1) of the RFC.",success,
2223,ngx_http_trailers_filter,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (in == NULL\n    || conf->trailers == NULL\n    || !r->expect_trailers\n    || r->header_only)\n{\n    return ngx_http_next_body_filter(r, in);\n}', 'explanation': 'This block checks for conditions such as whether trailers are expected, if the configuration is in place, or if the request is header‑only. By not processing further when these conditions fail, it prevents generating protocol elements (trailers) for messages where they are not expected. This addresses the part of the RFC that requires a sender not to generate protocol elements reserved for other roles.'}}, {'C2': {'code': 'switch (r->headers_out.status) {\n\ncase NGX_HTTP_OK:\ncase NGX_HTTP_CREATED:\ncase NGX_HTTP_NO_CONTENT:\ncase NGX_HTTP_PARTIAL_CONTENT:\ncase NGX_HTTP_MOVED_PERMANENTLY:\ncase NGX_HTTP_MOVED_TEMPORARILY:\ncase NGX_HTTP_SEE_OTHER:\ncase NGX_HTTP_NOT_MODIFIED:\ncase NGX_HTTP_TEMPORARY_REDIRECT:\ncase NGX_HTTP_PERMANENT_REDIRECT:\n    safe_status = 1;\n    break;\n\ndefault:\n    safe_status = 0;\n    break;\n}\n\n...\n\nif (!safe_status && !h[i].always) {\n    continue;\n}', 'explanation': ""By determining whether the response status is one where trailers are safe (or, alternatively, if the header is explicitly marked with 'always'), this code prevents the generation of trailers in scenarios where it might contravene role-specific protocol rules. This addresses the RFC’s requirement for proper role adherence when emitting protocol elements.""}}]","The function implements checks to ensure that trailers (a form of protocol element) are only added when the message is expected to include them and when the response status is appropriate. These checks partially fulfill the RFC’s requirement that a sender must not generate protocol elements reserved for other roles. However, the function does not address every aspect of the RFC (such as detailed ABNF grammar verification or other syntactic constraints) solely within its code, hence the overall implementation is considered a partial match.",success,
2223,ngx_http_trailers_filter,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function generates HTTP trailer headers based on configuration without performing any explicit validation against the ABNF grammar rules defined in the RFC. Although the function conditionally appends trailer headers (e.g., by checking safe_status and computing header values), there is no logic that verifies whether the generated protocol elements conform to the grammar. In this context, the function does not address the spec constraint that requires the sender to only generate protocol elements matching the defined ABNF rules.",success,
2224,ngx_http_set_expires,"When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.",245,Fully Matches,"[{'C1': {'code': 'if (expires == NGX_HTTP_EXPIRES_EPOCH) {\n    e->value.data = (u_char *) ""Thu, 01 Jan 1970 00:00:01 GMT"";\n    ...\n}\n\nif (expires == NGX_HTTP_EXPIRES_MAX) {\n    e->value.data = (u_char *) ""Thu, 31 Dec 2037 23:55:55 GMT"";\n    ...\n}\n\n(...)\nngx_http_time(e->value.data, expires_time);', 'explanation': ""The function sets the 'Expires' header by explicitly using string literals that are in IMF-fixdate format for special cases (e.g., the epoch and max date cases) and by calling ngx_http_time() to format the general case timestamp. This ensures that any timestamp sent in the HTTP header conforms to the IMF-fixdate format as required by the RFC.""}}]","The provided function implements logic to generate HTTP-date headers in the IMF-fixdate format. Every branch that sets the 'Expires' header uses either an explicit IMF-fixdate string or generates one via ngx_http_time(), thereby fully addressing the spec constraint that timestamps must be produced using the IMF-fixdate format.",success,
2226,ngx_http_parse_expires,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (value->len == 5 && ngx_strncmp(value->data, ""epoch"", 5) == 0) {\n    *expires = NGX_HTTP_EXPIRES_EPOCH;\n    return NGX_OK;\n}\n\nif (value->len == 3 && ngx_strncmp(value->data, ""max"", 3) == 0) {\n    *expires = NGX_HTTP_EXPIRES_MAX;\n    return NGX_OK;\n}\n\nif (value->len == 3 && ngx_strncmp(value->data, ""off"", 3) == 0) {\n    *expires = NGX_HTTP_EXPIRES_OFF;\n    return NGX_OK;\n}\n\n... (handling for \'@\', \'+\', \'-\' cases and daily times)', 'explanation': ""The function inspects the incoming protocol element (the value) and interprets it based on predefined semantics (e.g. literal values 'epoch', 'max', 'off' and adjustments if the string begins with '@', '+', or '-'). This reflects the requirement that a recipient MUST interpret a received protocol element according to defined semantics.""}}, {'A1': {'code': 'if (*expires_time == (time_t) NGX_ERROR) {\n    *err = ""invalid value"";\n    return NGX_ERROR;\n}\n\nif (*expires == NGX_HTTP_EXPIRES_DAILY && *expires_time > 24 * 60 * 60) {\n    *err = ""daily time value must be less than 24 hours"";\n    return NGX_ERROR;\n}', 'explanation': 'The function implements error reporting by checking if the parsed time is valid and, in the case of daily times, ensuring it does not exceed a 24‑hour period. This error handling aligns with a specified action that a protocol element must be either interpreted or flagged as invalid.'}}]","The function attempts to implement part of the HTTP RFC requirement by interpreting the received protocol element according to preset semantics and by performing error checks when invalid values are encountered. However, it only covers specific cases (such as handling literal strings and simple numeric adjustments) and does not account for all possible extension scenarios or more sophisticated error recovery strategies that might be implied by the specification. Thus, the function partially matches the spec constraints.",success,
2226,ngx_http_parse_expires,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (value->len == 5 && ngx_strncmp(value->data, ""epoch"", 5) == 0) { ... }\nif (value->len == 3 && ngx_strncmp(value->data, ""max"", 3) == 0) { ... }\nif (value->len == 3 && ngx_strncmp(value->data, ""off"", 3) == 0) { ... }', 'explanation': 'The function does not assume complete conformance to an ABNF grammar. Instead, it performs defensive parsing by checking the length of the input and comparing against known valid strings, thereby handling potential deviations in the received protocol element.'}}, {'A1': {'code': 'if (*expires_time == (time_t) NGX_ERROR) {\n    *err = ""invalid value"";\n    return NGX_ERROR;\n}', 'explanation': 'When the parsed time value fails (using ngx_parse_time), the function sets an error message and returns an error, demonstrating defensive error handling as suggested by the spec.'}}]","The function contains several defensive measures: it checks the length of the input before string comparisons and handles errors by setting appropriate error messages if parsing fails. These elements address some aspects of the specification that calls for defensive parsing with marginal expectations of perfect ABNF conformance. However, not every possible buffer or length issue is handled explicitly in this function, meaning it only partially matches the overall intentions of the RFC spec constraints.",success,
2245,ngx_http_autoindex_handler,All general-purpose servers MUST support the methods GET and HEAD,58,Fully Matches,"[{'C1': {'code': 'if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {\n    return NGX_DECLINED;\n}', 'explanation': 'This code explicitly checks that the request method is either GET or HEAD. If it is not, the function declines to process it, thereby ensuring that only GET and HEAD requests are handled as mandated by the RFC.'}}]","The function_body verifies that the incoming HTTP request uses either GET or HEAD by checking the bitmask 'r->method' against NGX_HTTP_GET and NGX_HTTP_HEAD. This directly addresses the spec requirement that all general-purpose servers MUST support the methods GET and HEAD. No other extraneous logic is involved, and the implementation is self-contained within the function, so the constraint is fully met.",success,
2245,ngx_http_autoindex_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'switch (format) {\n    case NGX_HTTP_AUTOINDEX_JSON:\n        ngx_str_set(&r->headers_out.content_type, ""application/json"");\n        break;\n    case NGX_HTTP_AUTOINDEX_JSONP:\n        ngx_str_set(&r->headers_out.content_type, ""application/javascript"");\n        break;\n    case NGX_HTTP_AUTOINDEX_XML:\n        ngx_str_set(&r->headers_out.content_type, ""text/xml"");\n        ngx_str_set(&r->headers_out.charset, ""utf-8"");\n        break;\n    default: /* NGX_HTTP_AUTOINDEX_HTML */\n        ngx_str_set(&r->headers_out.content_type, ""text/html"");\n        break;\n}', 'explanation': 'The function always sets the Content-Type header based on the autoindex output format. This directly implements the RFC requirement that a sender generating a message with content SHOULD include a Content-Type header when the media type is known.'}}]","The provided code function generates a Content-Type header unconditionally for known autoindex formats (HTML, JSON, JSONP, or XML) before sending the response. This logic directly corresponds to the RFC specification that a sender with content should generate a Content-Type header. Since the function itself implements this behavior, it fully meets the constraint.",success,
2245,ngx_http_autoindex_handler,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function is focused on generating an autoindex directory listing (in various formats like JSON, JSONP, XML, or HTML) and handling HTTP GET/HEAD requests. It does not incorporate any logic that checks whether protocol elements are only generated by roles permitted to do so or validates that the elements conform strictly to the expected ABNF for a sender's role. There is no code segment addressing the spec constraint that a sender MUST NOT generate protocol elements or syntax alternatives reserved for other roles (e.g., no role verification or filtering is performed within this function). Therefore, the function does not match the specified HTTP RFC requirement regarding role-based generation of protocol elements.",success,
2245,ngx_http_autoindex_handler,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function is responsible for generating directory listings in various formats (HTML, JSON, JSONP, and XML) and setting HTTP headers accordingly. However, it does not contain any explicit logic that verifies or enforces that the generated protocol elements strictly conform to the grammar defined by the corresponding ABNF rules. While it does set content types and null-terminates strings (which are good practices), these actions do not equate to a validation against an ABNF grammar. Therefore, with respect to the specified RFC requirement that a sender MUST NOT generate protocol elements that do not match the grammar, the function does not demonstrably implement any checks or validations by itself, and thus does not match the constraint.",success,
2245,ngx_http_autoindex_handler,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,61,Fully Matches,"[{'C1': {'code': 'rc = ngx_http_send_header(r);\n\n    if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {\n        if (ngx_close_dir(&dir) == NGX_ERROR) {\n            ngx_log_error(NGX_LOG_ALERT, r->connection->log, ngx_errno, ngx_close_dir_n "" \\""%V\\"" failed"", &path);\n        }\n        return rc;\n    }', 'explanation': ""This segment sends the header and then checks the 'r->header_only' flag. In cases where the request is a HEAD request (i.e. header only), the function returns immediately without generating or sending any content. This behavior satisfies the RFC requirement for the HEAD method.""}}]","The function first validates that the HTTP method is either GET or HEAD. It then proceeds to process the request by sending headers using ngx_http_send_header. Importantly, it checks whether r->header_only is true, and if so, returns without further processing (i.e., without sending any response body). This directly implements the specific requirement of the RFC that for HEAD requests no content should be sent.",success,
2249,ngx_http_autoindex_html,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,36,Fully Matches,"[{'C1': {'code': 'static u_char  title[] = ""<html>"" CRLF\n...\nstatic u_char  tail[] = ""</body>"" CRLF\n""</html>"" CRLF\n...\n*b->last++ = CR;\n*b->last++ = LF;', 'explanation': ""The function constructs the HTML response using string literals that include the CRLF sequence (e.g., in the 'title' and 'tail' definitions) and explicitly appends CR followed by LF (as seen in the file listing loop). This demonstrates that it generates only CRLF to represent line breaks between body parts as required by the spec.""}}]","The provided function generates an HTML directory listing and consistently uses CRLF sequences for representing line breaks. The use of CRLF in the static string definitions (such as for the HTML header and trailer) and the explicit addition of CR and LF characters in the loop confirm that the function addresses the RFC requirement that only CRLF be used for line breaks in the message body. Hence, within itself, the function fully meets the specified condition.",success,
2249,ngx_http_autoindex_html,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Fully Matches,"[{'C1': {'code': 'static u_char  title[] = ""<html>"" CRLF\n...\n*b->last++ = CR;\n*b->last++ = LF;\n...', 'explanation': ""The function uses the CRLF macro in static strings (e.g., 'title', 'header', 'tail') and, within the loop, explicitly writes a CR immediately followed by an LF. This ensures that a bare CR (CR not immediately followed by LF) is never generated in the output, which directly addresses the RFC requirement.""}}]","The RFC specifies that a sender must not output a bare CR outside of the content. In this function, every instance of a CR is purposefully paired with an LF, both in the static HTML fragments and when appending data in the loop. By always using CRLF and never outputting a CR on its own, the function visibly implements the required constraint. Dependencies or higher-level message handling are not counted here; only the in-function logic is considered, and it fully meets the constraint labeled C1.",success,
2254,ngx_http_autoindex_json,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,36,Fully Matches,"[{'C1': {'code': 'len = sizeof(""["" CRLF CRLF ""]"") - 1;\n...\n b->last = ngx_cpymem(b->last, CRLF ""]"", sizeof(CRLF ""]"") - 1);', 'explanation': 'The RFC requires that the sender MUST generate only CRLF for line breaks. This function embeds CRLF (via the CRLF macro) throughout its output, such as in the initialization of the length and in subsequent ngx_cpymem calls. This clearly demonstrates that all line breaks within the generated message body are CRLF.'}}]","The function ngx_http_autoindex_json constructs a JSON output where every line break is explicitly implemented using the CRLF macro. Since the RFC specification mandates that only CRLF be used to represent line breaks between body parts, and no other newline formats are present in the function, the code fully meets the required condition (C1). The use of CRLF in every segment – during the initial array boundaries, the insertion between entries, and at the end of the JSON – shows that the function itself adheres to the specification without delegating responsibility to any dependencies.",success,
2254,ngx_http_autoindex_json,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Partially Matches,"[{'C1': {'code': 'len = sizeof(""["" CRLF CRLF ""]"") - 1;\n...\nif (callback) {\n    b->last = ngx_cpymem(b->last, ""/* callback */"" CRLF, sizeof(""/* callback */"" CRLF) - 1);\n    ...\n}\n...\nb->last = ngx_cpymem(b->last, CRLF ""{ \\""name\\"":\\"""", sizeof(CRLF ""{ \\""name\\"":\\"""") - 1);\n...\nb->last = ngx_cpymem(b->last, CRLF ""]"", sizeof(CRLF ""]"") - 1);', 'explanation': 'The code function uses string literals that include the macro CRLF in multiple places when constructing the output buffer. This indicates that the function intends to generate CR characters only as part of proper CRLF sequences. However, there is no explicit validation (e.g. scanning or checking) to ensure that a bare CR is never generated. Instead, it relies on correct usage of the CRLF macro, which partially addresses the requirement of not generating a bare CR.'}}]","The provided function uses CRLF string literals consistently when composing its output (for example, during the creation of JSON entries and additional callback formatting). This suggests an intent to make sure that whenever a CR is output it is immediately followed by an LF. While this method addresses the spirit of the RFC specification regarding CR not appearing bare outside of content, the function does not explicitly perform any checks or transformations to enforce that no bare CR is generated. Therefore, only part of the specification is handled within this function, and it relies on proper definitions of the CRLF macro and correct usage in string literals.",success,
2257,ngx_http_autoindex_jsonp_callback,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (callback->len > 128) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent too long callback name: \\""%V\\"""", callback);\n    return NGX_DECLINED;\n}', 'explanation': 'This segment ensures that the protocol element (the callback parameter) does not exceed a reasonable length (hardcoded as 128), addressing the requirement to handle a received element that fits within a reasonable buffer size.'}}, {'A1': {'code': 'for (i = 0; i < callback->len; i++) {\n    ch = p[i];\n    c = (u_char) (ch | 0x20);\n    if (c >= \'a\' && c <= \'z\') {\n        continue;\n    }\n    if ((ch >= \'0\' && ch <= \'9\') || ch == \'_\' || ch == \'.\') {\n        continue;\n    }\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent invalid callback name: \\""%V\\"""", callback);\n    return NGX_DECLINED;\n}', 'explanation': 'This loop parses each character of the callback parameter defensively, allowing only alphabetic characters (case-insensitively), digits, underscores, and dots. This minimal validation ensures that even if the element does not fully conform to its ABNF grammar, only a safe subset is accepted.'}}]","The function implements defensive parsing of the callback parameter as required by the RFC. It checks that the callback is within a reasonable length (addressing buffer size constraints) and that it contains only allowed characters (addressing marginal grammar conformance expectations). Both key defensive measures are implemented within this function, independent of its dependencies.",success,
2258,ngx_http_autoindex_xml,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Fully Matches,"[{'C1': {'code': 'static u_char  head[] = ""<?xml version=\\""1.0\\""?>"" CRLF ""<list>"" CRLF;\n...\n*b->last++ = CR; *b->last++ = LF;\n...\nb->last = ngx_cpymem(b->last, tail, sizeof(tail) - 1);', 'explanation': 'The function uses CRLF sequences consistently in its output, as seen in the head, tail, and the loop that appends each directory or file entry. Every time a CR (carriage return) is output, it is immediately followed by an LF (line feed), ensuring no bare CR is generated. This behavior directly implements the RFC requirement that a sender must not generate a bare CR.'}}]","The function_body generates XML output for directory listings and consistently uses the CRLF sequence for line terminations. Notably, the code uses CRLF in the static header and tail definitions and appends CRLF after each entry within the loop. These implementations ensure that every CR is paired with an LF, thereby satisfying the RFC constraint that forbids bare CR characters. Dependencies are not relied upon for this logic, as the function itself enforces the correct behavior.",success,
2258,ngx_http_autoindex_xml,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,36,Fully Matches,"[{'C1': {'code': 'static u_char  head[] = ""<?xml version=\\""1.0\\""?>"" CRLF ""<list>"" CRLF;\nstatic u_char  tail[] = ""</list>"" CRLF;\n...\n*b->last = ngx_cpymem(b->last, head, sizeof(head) - 1);\n...\n*b->last++ = CR; *b->last++ = LF;', 'explanation': ""The function consistently uses CRLF as the only line break, both in the XML header, tail, and appended after each entry. This directly addresses the RFC spec constraint that 'a sender MUST generate only CRLF to represent line breaks.'""}}]","The ngx_http_autoindex_xml function builds an XML message body and strictly adheres to the RFC specification regarding line breaks by inserting CRLF in the header, tail, and after each entry's content. The logic within the function satisfies the condition (labeled C1) fully without relying on external dependencies.",success,
2270,ngx_http_stub_status_handler,"Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response (Section 15.4.5 of [HTTP]) to a GET request, neither of which includes a message body, to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET.",192,Does Not Match,[],"The provided function ngx_http_stub_status_handler is responsible for generating a plain text status response (about active connections and other stats) in Nginx. It checks that the request method is GET or HEAD, discards the request body, sets the content type, and outputs content with a content-length header. However, it does not include any logic related to the Transfer-Encoding header as specified by the RFC: it neither sets a Transfer-Encoding header in HEAD or 304 responses, nor does it conditionally omit a message body based on the RFC requirements. Therefore, there is no code segment that fully implements any labeled conditions (C1, C2, etc.) or actions (A1, A2, etc.) from the spec constraints regarding Transfer-Encoding.",success,
2270,ngx_http_stub_status_handler,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Does Not Match,[],"The provided function does not contain any logic to check, conditionally avoid, or remove a Content-Length header when a Transfer-Encoding header is present. Specifically, the RFC requirement states that a sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field. In this function, the Content-Length is always set (r->headers_out.content_length_n = ...), without any condition to verify if a Transfer-Encoding header field exists. Therefore, the code does not implement the necessary check or omission for this RFC constraint.",success,
2270,ngx_http_stub_status_handler,All general-purpose servers MUST support the methods GET and HEAD,58,Fully Matches,"[{'C1': {'code': 'if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {\n        return NGX_HTTP_NOT_ALLOWED;\n    }', 'explanation': ""This code directly checks if the request method is either GET or HEAD and returns a 'Not Allowed' status if it is not. This meets the spec requirement that all general-purpose servers must support the methods GET and HEAD.""}}]","The function_body explicitly validates the request method by checking for NGX_HTTP_GET and NGX_HTTP_HEAD. If the method is not one of these, it returns NGX_HTTP_NOT_ALLOWED, ensuring the server only processes GET and HEAD requests. This logic fully meets the given RFC specification constraint.",success,
2270,ngx_http_stub_status_handler,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'A1': {'code': 'r->headers_out.content_length_n = b->last - b->pos;', 'explanation': ""The function computes the content length from the temporary buffer (b) and explicitly assigns this value to the response header field 'Content-Length'. This directly implements the action required in the RFC to send a Content-Length header when the content size is known and Transfer-Encoding is absent.""}}]","The code function clearly calculates and sets the Content-Length header by determining the size of the response body. This fulfills the core requirement of sending the header when the content size is known (as described in the RFC). However, it does not include any logic to avoid setting the Content-Length header in cases where it should not be sent (e.g., responses with status codes 1xx or 204, or in responses to CONNECT requests). Since these conditions are part of the overall spec but are not handled within this function, the implementation only partially matches the specification.",success,
2270,ngx_http_stub_status_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'r->headers_out.content_type_len = sizeof(""text/plain"") - 1;\nngx_str_set(&r->headers_out.content_type, ""text/plain"");', 'explanation': ""The RFC specifies that a Content-Type header should be generated when content is present. This code explicitly sets the Content-Type to 'text/plain', fulfilling the requirement when the media type is known.""}}]","The function generates a stub status page with content and explicitly sets a Content-Type header field in the outgoing response. This directly addresses the RFC requirement by ensuring that messages with content include the appropriate Content-Type header when the media type is known. All logic related to the RFC condition is implemented within this function, and no dependency is relied upon to satisfy this requirement.",success,
2270,ngx_http_stub_status_handler,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Does Not Match,[],"The RFC specification requires that a server MUST NOT send a Content-Length header field in responses with a status code of 1xx (Informational) or 204 (No Content). However, this function always sets the status to 200 (OK) and explicitly calculates and assigns a Content-Length header (r->headers_out.content_length_n). There is no conditional logic in the function to avoid setting a Content-Length header when the response would be a 1xx or 204 status. Therefore, the function does not implement the specified HTTP RFC constraint regarding the omission of the Content-Length header for 1xx or 204 responses.",success,
2270,ngx_http_stub_status_handler,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The RFC requires that a sender must not forward a message with a Content-Length header value that is known to be incorrect, which entails validating the Content-Length header against the actual message framing or input. In the provided function, the Content-Length is computed from the output buffer (b->last - b->pos) and assigned to r->headers_out.content_length_n, but there is no logic that verifies an existing Content-Length header or compares it against expected values. Therefore, this function does not visibly implement the RFC constraint regarding the correctness of the Content-Length header field.",success,
2270,ngx_http_stub_status_handler,"An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",60,Fully Matches,"[{'C1': {'code': 'if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {\n        return NGX_HTTP_NOT_ALLOWED;\n    }', 'explanation': 'This code segment verifies that the request method is either GET or HEAD. If not, it returns the NGX_HTTP_NOT_ALLOWED code (which corresponds to a 405 status), thereby addressing the condition that if a recognized and implemented method is received but is not allowed for the target resource, the server should respond with a 405.'}}]","The function directly implements the spec requirement by checking the incoming request's method. By allowing only GET and HEAD and immediately returning a 405 (Method Not Allowed) for any other methods, it effectively meets the RFC requirement that if the request method is recognized and implemented but not allowed, a 405 status should be issued. This logic exists solely within the function_body, independent of any external dependencies.",success,
2270,ngx_http_stub_status_handler,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Partially Matches,"[{'A1': {'code': 'r->headers_out.content_length_n = b->last - b->pos;', 'explanation': 'This line computes the length of the response body and sets the Content-Length header, thereby generating a length-delimited message as recommended by the RFC. Additionally, the use of the last_buf flag (b->last_buf = (r == r->main) ? 1 : 0;) helps indicate message completion.'}}]","The RFC indicates that a server SHOULD generate encoding or length-delimited messages whenever possible. In this function, the implementation of a length-delimited response is visible through the explicit calculation and setting of the Content-Length header, which meets part of the specification. However, other aspects of the RFC (such as handling of Transfer-Encoding or detailed error handling for invalid Content-Length in incoming requests) are not addressed in this function. Thus, while the function does address the use of a length-delimited message, it only partially matches the full specification.",success,
2286,ngx_http_empty_gif_handler,"In 200 responses to GET or HEAD, an origin server SHOULD send any available validator fields (Section 8.8) for the selected representation, with both a strong entity tag and a Last-Modified date being preferred.",141,Partially Matches,"[{'C1': {'code': 'r->headers_out.last_modified_time = 23349600;', 'explanation': 'This line sets the Last-Modified header for 200 responses to GET/HEAD, fulfilling the requirement for including a validator field via Last-Modified.'}}]","The function checks if the incoming request method is GET or HEAD and sets a fixed Last-Modified timestamp, which is a validator field as per the RFC specification. However, it does not implement the sending of a strong entity tag, which is also preferred in the specification. Thus, while the function partially addresses the spec by handling the Last-Modified header, it does not fully implement all the validator fields as indicated by the spec.",success,
2286,ngx_http_empty_gif_handler,"However, a server MAY omit header fields for which a value is determined only while generating the content.",269,Does Not Match,[],"The provided function only performs a method check to ensure the request is either GET or HEAD and then prepares an empty GIF response using ngx_http_send_response. It does not incorporate any explicit logic to conditionally omit header fields or content when handling HEAD requests, as the RFC specifies that a HEAD response must not include a message body and may omit header fields determined only at content generation. All the specific behavior regarding omitting content for HEAD requests is left to other parts of the system (e.g., ngx_http_send_response) and is not implemented within this function. Therefore, the function does not visibly address the spec's constraints.",success,
2286,ngx_http_empty_gif_handler,"An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",268,Does Not Match,[],"The provided function does not address the specific RFC requirement. The RFC specifies that an origin server should not rely on private agreements to receive content. However, the function's logic solely handles GET/HEAD requests by returning an empty GIF response and does not contain any logic to check or handle private agreements, incoming content, or request semantics related to content receipt. Therefore, there is no visible code within this function that implements the given spec constraint.",success,
2286,ngx_http_empty_gif_handler,All general-purpose servers MUST support the methods GET and HEAD,58,Fully Matches,"[{'C1': {'code': 'if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {\n    return NGX_HTTP_NOT_ALLOWED;\n}', 'explanation': 'This code segment checks if the HTTP request method is either GET or HEAD, which are the required methods per the RFC. If the method is not GET or HEAD, the function responds with NGX_HTTP_NOT_ALLOWED, fulfilling the requirement that the server must support only GET and HEAD.'}}]","The function explicitly verifies that the request method is either GET or HEAD by using a bitwise check. If the method does not match these, it returns a 'not allowed' response code. This singular check visibly addresses the RFC constraint that all general-purpose servers must support GET and HEAD, hence the function fully implements the specified requirement.",success,
2286,ngx_http_empty_gif_handler,"An origin server MUST NOT send a validator field (Section 8.8), such as an ETag or Last-Modified field, in a successful response to PUT unless the request's representation data was saved without any transformation applied to the content (i.e., the resource's new representation data is identical to the content received in the PUT request) and the validator field value reflects the new representation.",70,Does Not Match,[],"The provided function only handles GET and HEAD requests and unconditionally sets the Last-Modified header. It does not address any logic for handling PUT requests or verifying that a validator (such as Last-Modified) is sent only when the representation is saved without transformation. Therefore, no part of the function implements the specific RFC requirement related to PUT as outlined in the spec.",success,
2286,ngx_http_empty_gif_handler,"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.",52,Fully Matches,"[{'A1': {'code': 'r->headers_out.last_modified_time = 23349600;', 'explanation': 'This line in the function explicitly sets the Last-Modified timestamp in the HTTP response header. Given that the RFC specifies an origin server SHOULD include a Last-Modified header when a last modification date can be determined, the code directly meets this requirement for the selected representation (in this case, the empty GIF).'}}]","The RFC specifies that an origin server should send a Last-Modified header when a last modification date can be determined. In the provided function, the line that assigns a constant value to r->headers_out.last_modified_time directly addresses this requirement. Although the value is hard-coded, for a static resource like an empty GIF this is acceptable. No additional logic is needed within this function, and therefore the function is deemed to fully match the relevant constraint.",success,
2286,ngx_http_empty_gif_handler,"An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",270,Does Not Match,[],"The target function does not contain any logic or code addressing the specified RFC constraint regarding origin servers not relying on private agreements to receive content, nor does it implement the nuanced handling of header fields for HEAD requests as described in the spec context. The function simply checks that the request method is GET or HEAD, sets a static last_modified_time, and sends a GIF response. No part of the function directly implements or enforces the conditions (e.g., C1) or actions (e.g., A1) outlined in the provided RFC specification.",success,
2286,ngx_http_empty_gif_handler,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,44,Does Not Match,[],"The provided function does not include any logic that addresses the RFC constraints regarding the Content-Length header for HEAD or 304 responses. It only handles GET and HEAD methods by returning a static GIF image with a fixed last_modified_time and does not compute or set the Content-Length header to represent the actual length of the content that would be sent in a GET request. Thus, none of the conditions (e.g., C1) or actions (e.g., A1) in the spec constraints related to the proper use of the Content-Length header are directly implemented within this function.",success,
2286,ngx_http_empty_gif_handler,"An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",271,Does Not Match,[],"The provided function, ngx_http_empty_gif_handler, only handles GET and HEAD requests by returning an empty GIF with a 200 OK status. It does not implement any logic that addresses the RFC specification regarding not relying on private agreements to receive content from DELETE requests or any other methods. Since none of the labeled conditions or actions (e.g., C1 for the private agreements requirement) are implemented directly within this function, it does not match the given spec constraints.",success,
2322,ngx_http_auth_request_handler,The server generating a 401 response MUST send a WWW-Authenticate header field (Section 11.6.1) containing at least one challenge applicable to the target resource.,162,Fully Matches,"[{'A1': {'code': 'if (ctx->status == NGX_HTTP_UNAUTHORIZED) {\n    sr = ctx->subrequest;\n\n    h = sr->headers_out.www_authenticate;\n    if (!h && sr->upstream) {\n        h = sr->upstream->headers_in.www_authenticate;\n    }\n\n    ph = &r->headers_out.www_authenticate;\n    while (h) {\n        ho = ngx_list_push(&r->headers_out.headers);\n        if (ho == NULL) {\n            return NGX_ERROR;\n        }\n\n        *ho = *h;\n        ho->next = NULL;\n\n        *ph = ho;\n        ph = &ho->next;\n\n        h = h->next;\n    }\n    return ctx->status;\n}', 'explanation': 'This code block checks if the authentication subrequest resulted in a 401 (Unauthorized) status, and then it retrieves any WWW-Authenticate header from the subrequest (or from the upstream headers if necessary) and copies it to the main response. This directly implements the RFC requirement that a 401 response must include at least one WWW-Authenticate header challenge for the target resource.'}}]","The function clearly inspects the status of the authentication result. When the status is NGX_HTTP_UNAUTHORIZED, the function ensures that the WWW-Authenticate header is present in the response by copying it from the subrequest. This approach fulfills the RFC specification which mandates that a 401 Unauthorized response must send a WWW-Authenticate header with at least one applicable challenge. All the necessary logic to implement this requirement is contained within this function, and thus it fully matches the relevant constraint.",success,
2322,ngx_http_auth_request_handler,A server MAY generate a WWW-Authenticate header field in other response messages to indicate that supplying credentials (or different credentials) might affect the response.,93,Fully Matches,"[{'C1': {'code': 'if (ctx->status == NGX_HTTP_UNAUTHORIZED) {\n    sr = ctx->subrequest;\n    h = sr->headers_out.www_authenticate;\n\n    if (!h && sr->upstream) {\n        h = sr->upstream->headers_in.www_authenticate;\n    }\n    \n    ph = &r->headers_out.www_authenticate;\n\n    while (h) {\n        ho = ngx_list_push(&r->headers_out.headers);\n        if (ho == NULL) {\n            return NGX_ERROR;\n        }\n\n        *ho = *h;\n        ho->next = NULL;\n\n        *ph = ho;\n        ph = &ho->next;\n\n        h = h->next;\n    }\n\n    return ctx->status;\n}', 'explanation': 'This section checks if the authentication subrequest returned a 401 (Unauthorized) status and then retrieves the WWW-Authenticate header from the subrequest (or its upstream) and copies it into the main response. This directly implements the RFC mandate that a 401 response MUST include a WWW-Authenticate header containing at least one challenge.'}}]","The function explicitly handles the case when the authentication subrequest produces a 401 status. In this situation, it looks for and copies the WWW-Authenticate header from the subrequest's response (or from the upstream response if necessary) into the main response's headers. By doing so, the function adheres to the RFC specification requirement for returning a WWW-Authenticate header in 401 responses, thus fully matching the relevant constraints.",success,
2322,ngx_http_auth_request_handler,A server generating a 401 (Unauthorized) response MUST send a WWW-Authenticate header field containing at least one challenge.,92,Fully Matches,"[{'C1': {'code': 'if (ctx->status == NGX_HTTP_UNAUTHORIZED) {\n    sr = ctx->subrequest;\n    h = sr->headers_out.www_authenticate;\n    if (!h && sr->upstream) {\n        h = sr->upstream->headers_in.www_authenticate;\n    }\n    ph = &r->headers_out.www_authenticate;\n    while (h) {\n        ho = ngx_list_push(&r->headers_out.headers);\n        if (ho == NULL) {\n            return NGX_ERROR;\n        }\n        *ho = *h;\n        ho->next = NULL;\n        *ph = ho;\n        ph = &ho->next;\n        h = h->next;\n    }\n    return ctx->status;\n}', 'explanation': 'This block explicitly handles the 401 (Unauthorized) response by checking if the status is NGX_HTTP_UNAUTHORIZED and then proceeds to locate and copy the WWW-Authenticate header from the subrequest. It ensures that when a 401 is returned, a WWW-Authenticate header (the challenge) is present as required by the RFC.'}}]","The function contains logic that targets the 401 status code and, within that branch, seeks out a WWW-Authenticate header from the subrequest response. It then appends this header to the main response, thereby fulfilling the RFC specification that mandates a 401 response to include at least one WWW-Authenticate challenge. All the visible logic related to this requirement is self-contained in the function body, leading to the conclusion that the function fully matches the spec constraints.",success,
2325,ngx_http_auth_request_variable,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,44,Does Not Match,[],"The provided function only logs a debug message, marks the variable as not found, and returns a status code. It does not include any logic related to sending or preventing the sending of a Content-Length header field or handling specific HTTP response status codes as required by the spec constraints. Thus, no labeled conditions or actions (such as C1 or A1) related to the RFC have been implemented within this function.",success,
2335,ngx_http_not_modified_header_filter,"When an origin server receives a request that selects a representation and that request includes an If-Modified-Since header field without an If-None-Match header field, the origin server SHOULD evaluate the If-Modified-Since condition per Section 13.2 prior to performing the method.",109,Partially Matches,"[{'C1': {'code': 'if (r->headers_in.if_modified_since && ngx_http_test_if_modified(r)) {\n    return ngx_http_next_header_filter(r);\n}', 'explanation': 'This code segment attempts to evaluate the If-Modified-Since condition (by calling ngx_http_test_if_modified) when the header is present. However, the RFC requires that this evaluation only occur if the If-Modified-Since header is provided without an If-None-Match header, but the code does not explicitly enforce the absence of the If-None-Match header.'}}]","The function contains logic that checks for the presence of an If-Modified-Since header and evaluates it using ngx_http_test_if_modified, which is in line with part of the RFC requirement (labeled C1). However, since the RFC states that the If-Modified-Since condition should only be evaluated when an If-None-Match header is not present, and the function does not explicitly check for this exclusion, the function only partially meets the specification.",success,
2335,ngx_http_not_modified_header_filter,"When an origin server receives a request that selects a representation and that request includes an If-Unmodified-Since header field without an If-Match header field, the origin server MUST evaluate the If-Unmodified-Since condition per Section 13.2 prior to performing the method.",115,Partially Matches,"[{'C1': {'code': 'if (r->headers_in.if_unmodified_since\n    && !ngx_http_test_if_unmodified(r))\n{\n    return ngx_http_filter_finalize_request(r, NULL,\n                                            NGX_HTTP_PRECONDITION_FAILED);\n}', 'explanation': 'This segment checks for the presence of the If-Unmodified-Since header and evaluates it. If the condition fails, it finalizes the request with a precondition failure. However, according to the RFC, this evaluation should only occur when there is no If-Match header present. The code does not guard against the presence of an If-Match header before evaluating If-Unmodified-Since, and thus does not fully implement the spec requirement.'}}]","The RFC specifies that when a request includes an If-Unmodified-Since header without an If-Match header, the server must evaluate the If-Unmodified-Since condition. This function does evaluate the If-Unmodified-Since condition as seen in the code segment provided. However, it does not check whether the If-Match header is absent before performing this evaluation; it will evaluate the condition even if the If-Match header is present, which deviates from the RFC requirement. Hence, while some of the condition is addressed within this function, it only partially matches the spec.",success,
2335,ngx_http_not_modified_header_filter,An origin server that evaluates an If-Unmodified-Since condition MUST NOT perform the requested method if the condition evaluates to false,116,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.if_unmodified_since\n        && !ngx_http_test_if_unmodified(r))\n    {\n        return ngx_http_filter_finalize_request(r, NULL,\n                                                NGX_HTTP_PRECONDITION_FAILED);\n    }', 'explanation': ""This code segment checks if the request contains an If-Unmodified-Since header and tests it using ngx_http_test_if_unmodified(). If the condition evaluates to false (i.e., the representation has been modified after the specified time), it does not continue processing the method, which satisfies the spec's requirement.""}}, {'A1': {'code': 'return ngx_http_filter_finalize_request(r, NULL, NGX_HTTP_PRECONDITION_FAILED);', 'explanation': 'This action returns a 412 Precondition Failed status code, directly implementing the directive that the requested method must not be performed if the If-Unmodified-Since condition evaluates to false.'}}]","The function directly implements the specific HTTP RFC requirement: evaluating the If-Unmodified-Since header and, if the condition is false, returning a 412 Precondition Failed response. The code segment explicitly checks the condition and finalizes the request without performing the method, thereby fully matching the constraint as defined in the spec.",success,
2335,ngx_http_not_modified_header_filter,"Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code",117,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.if_unmodified_since\n        && !ngx_http_test_if_unmodified(r))\n{\n    return ngx_http_filter_finalize_request(r, NULL,\n                                            NGX_HTTP_PRECONDITION_FAILED);\n}', 'explanation': 'This segment checks whether the If‐Unmodified‐Since condition holds. If the test fails (i.e. the resource has been modified relative to the provided date), it immediately finalizes the request with a 412 Precondition Failed, which is in line with the RFC specification.'}}, {'C2': {'code': 'if (r->headers_in.if_match\n        && !ngx_http_test_if_match(r, r->headers_in.if_match, 0))\n{\n    return ngx_http_filter_finalize_request(r, NULL,\n                                            NGX_HTTP_PRECONDITION_FAILED);\n}', 'explanation': 'Though the RFC excerpt emphasizes the If-Unmodified-Since header, this segment similarly checks the If-Match condition and returns a 412 status if the condition fails, thereby following the precondition failure strategy.'}}]","The function inspects the conditional header fields provided in the request (specifically, If-Unmodified-Since and If-Match) and evaluates them using helper functions. When these conditions are not met, the function finalizes the request with a 412 (Precondition Failed) status, which directly implements the RFC’s guidance. The code thus visibly addresses the required behavior within this function, independent of its dependencies.",success,
2335,ngx_http_not_modified_header_filter,"A server MUST ignore all received preconditions if its response to the same request without those conditions, prior to processing the request content, would have been a status code other than a 2xx (Successful) or 412 (Precondition Failed).",124,Partially Matches,"[{'C1': {'code': 'if (r->headers_out.status != NGX_HTTP_OK || r != r->main || r->disable_not_modified) {\n    return ngx_http_next_header_filter(r);\n}', 'explanation': 'This block attempts to check whether the response is successful (by testing for NGX_HTTP_OK) before evaluating preconditions. It aims to ignore preconditions when the response status is not as expected. However, it only considers NGX_HTTP_OK (HTTP 200) instead of all 2xx status codes (or the 412 case) as specified by the RFC.'}}]","The code function implements conditional request handling by checking headers such as 'If-Unmodified-Since', 'If-Match', 'If-Modified-Since', and 'If-None-Match'. It ignores preconditions if the response status is not NGX_HTTP_OK and bypasses further checks in that case. This behavior partially meets the RFC requirement of ignoring preconditions when the response without them would not be successful (2xx) or 412. However, the implementation only accommodates a 200 OK status rather than any 2xx status or the specific 412 Precondition Failed status. Thus, while aspects of the RFC are addressed, the function does not fully implement the specification.",success,
2335,ngx_http_not_modified_header_filter,An origin server that evaluates an If-Match condition MUST NOT perform the requested method if the condition evaluates to false,99,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.if_match\n        && !ngx_http_test_if_match(r, r->headers_in.if_match, 0))\n    {\n        return ngx_http_filter_finalize_request(r, NULL, NGX_HTTP_PRECONDITION_FAILED);\n    }', 'explanation': 'This segment checks if an If-Match header is present and, using ngx_http_test_if_match, evaluates its condition. If the condition is false, it prevents further processing by finalizing the request with a 412 (Precondition Failed) response, which directly implements the RFC requirement that the method must not be performed when the If-Match condition fails.'}}]","The function contains explicit logic for evaluating the If-Match header. When the test for the condition fails, it returns a 412 response, thereby ensuring that the requested method is not performed as mandated by the RFC. This implementation within the function_body directly satisfies the specified HTTP RFC constraint.",success,
2335,ngx_http_not_modified_header_filter,"When an origin server receives a request that selects a representation and that request includes an If-Match header field, the origin server MUST evaluate the If-Match condition per Section 13.2 prior to performing the method.",98,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.if_match\n        && !ngx_http_test_if_match(r, r->headers_in.if_match, 0))\n    {\n        return ngx_http_filter_finalize_request(r, NULL,\n                                                NGX_HTTP_PRECONDITION_FAILED);\n    }', 'explanation': 'This segment directly checks whether an If-Match header is present and evaluates it using ngx_http_test_if_match, which is in line with the RFC requirement to process the If-Match header prior to performing the method.'}}, {'A1': {'code': 'return ngx_http_filter_finalize_request(r, NULL, NGX_HTTP_PRECONDITION_FAILED);', 'explanation': 'If the evaluation of the If-Match condition returns false, the function immediately finalizes the request with a precondition failed response, implementing the required action upon failing the check.'}}]","The function explicitly handles the If-Match header by first detecting its presence and then evaluating its condition before proceeding with the request. If the condition fails, it returns a precondition failed response. This matches the RFC's mandate to evaluate the If-Match condition (as per Section 13.2) prior to executing any further method actions, thereby fully addressing the specified constraints within the function_body.",success,
2335,ngx_http_not_modified_header_filter,"Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method.",282,Fully Matches,"[{'C1': {'code': 'if (r->headers_out.status != NGX_HTTP_OK\n    || r != r->main\n    || r->disable_not_modified)\n{\n    return ngx_http_next_header_filter(r);\n}', 'explanation': ""This check ensures that preconditions are only evaluated after normal request checks have passed (status is 200 OK, it's the main request, and not disabled), which aligns with the requirement to perform precondition evaluation just before processing the request content.""}}, {'A1': {'code': 'if (r->headers_in.if_unmodified_since\n    && !ngx_http_test_if_unmodified(r))\n{\n    return ngx_http_filter_finalize_request(r, NULL,\n                                            NGX_HTTP_PRECONDITION_FAILED);\n}', 'explanation': ""This segment verifies the 'If-Unmodified-Since' header. If it fails the test, it aborts further processing and returns a 412 (Precondition Failed) response, directly implementing the action required when a precondition is not met.""}}, {'A2': {'code': 'if (r->headers_in.if_match\n    && !ngx_http_test_if_match(r, r->headers_in.if_match, 0))\n{\n    return ngx_http_filter_finalize_request(r, NULL,\n                                            NGX_HTTP_PRECONDITION_FAILED);\n}', 'explanation': ""This part checks the 'If-Match' header. If the header value does not match the current resource state, the function finalizes the request with a precondition failed status, matching the RFC action for failed preconditions.""}}, {'A3': {'code': 'if (r->headers_in.if_modified_since || r->headers_in.if_none_match) {\n\n    if (r->headers_in.if_modified_since\n        && ngx_http_test_if_modified(r))\n    {\n        return ngx_http_next_header_filter(r);\n    }\n\n    if (r->headers_in.if_none_match\n        && !ngx_http_test_if_match(r, r->headers_in.if_none_match, 1))\n    {\n        return ngx_http_next_header_filter(r);\n    }\n\n    /* not modified */\n\n    r->headers_out.status = NGX_HTTP_NOT_MODIFIED;\n    r->headers_out.status_line.len = 0;\n    r->headers_out.content_type.len = 0;\n    ngx_http_clear_content_length(r);\n    ngx_http_clear_accept_ranges(r);\n\n    if (r->headers_out.content_encoding) {\n        r->headers_out.content_encoding->hash = 0;\n        r->headers_out.content_encoding = NULL;\n    }\n\n    return ngx_http_next_header_filter(r);\n}', 'explanation': ""This code block handles both the 'If-Modified-Since' and 'If-None-Match' headers. It checks whether the resource has been modified and, if it hasn’t, adjusts the response to a 304 Not Modified status. This behavior meets the specification for processing conditional requests before any significant content handling.""}}]","The function directly implements the evaluation of conditional request preconditions as required by the RFC. It first verifies that the basic conditions for processing the request (such as normal request checks) are met (C1). It then evaluates specific precondition headers such as If-Unmodified-Since (A1), If-Match (A2), and a combination of If-Modified-Since/If-None-Match (A3), aborting the request with a 412 Precondition Failed or returning a 304 Not Modified status when appropriate. All these checks occur before any processing of the request content, fully addressing the specification's constraints within the function itself.",success,
2335,ngx_http_not_modified_header_filter,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,44,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.if_modified_since || r->headers_in.if_none_match) {\n    if (r->headers_in.if_modified_since && ngx_http_test_if_modified(r)) {\n        return ngx_http_next_header_filter(r);\n    }\n\n    if (r->headers_in.if_none_match && !ngx_http_test_if_match(r, r->headers_in.if_none_match, 1)) {\n        return ngx_http_next_header_filter(r);\n    }\n\n    /* not modified */\n\n    r->headers_out.status = NGX_HTTP_NOT_MODIFIED;\n    r->headers_out.status_line.len = 0;\n    r->headers_out.content_type.len = 0;\n    ngx_http_clear_content_length(r);\n    ngx_http_clear_accept_ranges(r);\n\n    if (r->headers_out.content_encoding) {\n        r->headers_out.content_encoding->hash = 0;\n        r->headers_out.content_encoding = NULL;\n    }\n\n    return ngx_http_next_header_filter(r);\n}', 'explanation': 'This segment checks for conditional GET headers and, if the resource is determined to be not modified, sets the response status to 304. It then clears the Content-Length header via ngx_http_clear_content_length(r), ensuring that no Content-Length is sent unless correctly computed. This behavior fully meets the RFC requirement that a Content-Length header MUST NOT be sent in a 304 response unless its value matches that of a corresponding 200 response.'}}]","The function examines incoming request headers (If-Modified-Since and If-None-Match) to determine if a 304 (Not Modified) response is appropriate. When these conditions are met, it sets the response status to 304 and explicitly clears the Content-Length header before passing control to the next header filter. Since the RFC permits omitting the Content-Length header if its computed value is not available (or to avoid sending an incorrect value), this approach complies fully with the RFC requirements for conditional GET responses.",success,
2335,ngx_http_not_modified_header_filter,"An origin server that evaluates an If-Modified-Since condition SHOULD NOT perform the requested method if the condition evaluates to false; instead, the origin server SHOULD generate a 304 (Not Modified) response, including only those metadata that are useful for identifying or updating a previously cached response.",110,Partially Matches,"[{'A1': {'code': '/* not modified */\n\n    r->headers_out.status = NGX_HTTP_NOT_MODIFIED;\n    r->headers_out.status_line.len = 0;\n    r->headers_out.content_type.len = 0;\n    ngx_http_clear_content_length(r);\n    ngx_http_clear_accept_ranges(r);\n\n    if (r->headers_out.content_encoding) {\n        r->headers_out.content_encoding->hash = 0;\n        r->headers_out.content_encoding = NULL;\n    }\n\n    return ngx_http_next_header_filter(r);', 'explanation': 'This segment generates a 304 (Not Modified) response and clears headers that are not needed in a cached response, which aligns with the RFC requirement to not perform the method when the condition is false and to return limited metadata.'}}]","The function attempts to implement the RFC's behavior regarding the If-Modified-Since handling by generating a 304 response and stripping unnecessary headers when the condition indicates no modification. However, the actual evaluation of the condition (i.e. comparing the selected representation's last modification date with the provided date) is delegated to helper functions (such as ngx_http_test_if_modified) rather than being implemented directly in the function. Since only the visible logic in the function is considered and the evaluation step is not internaly implemented, the function only partially matches the complete set of specified conditions and actions.",success,
2335,ngx_http_not_modified_header_filter,"Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code",100,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.if_unmodified_since\n        && !ngx_http_test_if_unmodified(r))\n    {\n        return ngx_http_filter_finalize_request(r, NULL,\n                                                NGX_HTTP_PRECONDITION_FAILED);\n    }', 'explanation': ""This segment checks the 'If-Unmodified-Since' header condition. When present and the condition test fails, it returns a 412 (Precondition Failed), which complies with the RFC's mandate to indicate a failed precondition.""}}, {'C2': {'code': 'if (r->headers_in.if_match\n        && !ngx_http_test_if_match(r, r->headers_in.if_match, 0))\n    {\n        return ngx_http_filter_finalize_request(r, NULL,\n                                                NGX_HTTP_PRECONDITION_FAILED);\n    }', 'explanation': ""This segment verifies the 'If-Match' header condition. If the header is present but its associated test fails, the function responds with a 412, thereby implementing the conditional check as described in the RFC.""}}]","The function explicitly tests the presence and validity of critical conditional headers ('If-Unmodified-Since' and 'If-Match') and returns a 412 (Precondition Failed) response when these conditions are not met. This follows the RFC specification instruction that the origin server MAY indicate a conditional request has failed by issuing a 412 status code. Therefore, the function visibly addresses the relevant conditions and actions within its own logic.",success,
2335,ngx_http_not_modified_header_filter,"When an origin server receives a request that selects a representation and that request includes an If-None-Match header field, the origin server MUST evaluate the If-None-Match condition per Section 13.2 prior to performing the method.",103,Partially Matches,"[{'C1': {'code': 'if (r->headers_in.if_none_match) { ... }', 'explanation': 'The function checks for the presence of an If-None-Match header (C1) by testing if (r->headers_in.if_none_match) as part of the combined if-modified-since/if-none-match block.'}}, {'A1': {'code': 'if (r->headers_in.if_none_match && !ngx_http_test_if_match(r, r->headers_in.if_none_match, 1)) {\n    return ngx_http_next_header_filter(r);\n}', 'explanation': 'This segment attempts to evaluate the If-None-Match condition (A1) by invoking ngx_http_test_if_match with a flag (likely indicating the evaluation mode for if-none-match). If the test does not pass (i.e. the condition is met for modification), it promptly forwards the request without altering the status.'}}, {'A2': {'code': '/* not modified */\n\nr->headers_out.status = NGX_HTTP_NOT_MODIFIED;\nr->headers_out.status_line.len = 0;\nr->headers_out.content_type.len = 0;\nngx_http_clear_content_length(r);\nngx_http_clear_accept_ranges(r);\n\nif (r->headers_out.content_encoding) {\n    r->headers_out.content_encoding->hash = 0;\n    r->headers_out.content_encoding = NULL;\n}\n\nreturn ngx_http_next_header_filter(r);', 'explanation': 'After the evaluations, if neither the if-modified-since nor if-none-match conditions allowed the request to continue, the code sets the response status to Not Modified. This is in line with the action required when the request’s conditional headers indicate that the representation has not been modified (A2).'}}]","The function_body checks for the presence of an If-None-Match header and then delegates its evaluation to the helper function ngx_http_test_if_match. It also sets an appropriate 304 Not Modified response when the condition indicates that no changes have occurred. However, the detailed evaluation logic required by RFC (for example, handling a value of '*' or comparing a list of entity tags) is not implemented directly in this function but rather offloaded to ngx_http_test_if_match. Therefore, while the function visibly addresses parts of the specification by checking and acting based on the If-None-Match header, it does not implement the full conditional evaluation logic by itself, leading to a Partial Match.",success,
2335,ngx_http_not_modified_header_filter,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Does Not Match,[],"The RFC specification requires that a server MUST NOT send a Content-Length header field in any response with a status code of 1xx or 204. In the provided function, the only logic related to the Content-Length header is the call to ngx_http_clear_content_length(r) which is invoked when a response is being transformed into a 304 (Not Modified) response. This function does not address cases for 1xx or 204 responses—it conditionally processes only successful 200 (OK) responses that then become 304 responses. Thus, the function does not visibly implement the specified RFC constraint.",success,
2336,ngx_http_test_if_unmodified,A recipient MUST ignore the If-Unmodified-Since header field if the resource does not have a modification date available.,113,Fully Matches,"[{'C1': {'code': 'if (r->headers_out.last_modified_time == (time_t) -1) {\n    return 0;\n}', 'explanation': 'This check ensures that if the resource does not have a modification date available, the function immediately returns 0, effectively ignoring the If-Unmodified-Since header as required.'}}, {'C2': {'code': 'iums = ngx_parse_http_time(r->headers_in.if_unmodified_since->value.data,\n                               r->headers_in.if_unmodified_since->value.len);', 'explanation': 'The function parses the header value into a timestamp. If the value is not a valid HTTP-date, the parser is expected to return -1. This -1 value will not satisfy the later comparison, thereby ignoring an invalid If-Unmodified-Since field.'}}, {'A1': {'code': 'if (iums >= r->headers_out.last_modified_time) {\n    return 1;\n}', 'explanation': ""This comparison uses the server’s last_modified_time (the origin server’s clock) to determine if the resource has remained unmodified, thus fulfilling the requirement to interpret the header value in terms of the origin server's clock.""}}]","The function implements the RFC as follows: It first checks if the resource has a valid last modified date (C1). It then parses the If-Unmodified-Since header, where an invalid HTTP-date (resulting in -1) will not pass the subsequent comparison (C2). Finally, the valid parsed timestamp is compared against the server's last modified timestamp (A1), ensuring the header is interpreted in the context of the origin server's clock. This shows that the function fully addresses the specified constraints within its own logic.",success,
2337,ngx_http_test_if_modified,A recipient MUST ignore the If-Modified-Since header field if the resource does not have a modification date available.,107,Partially Matches,"[{'C1': {'code': 'if (r->headers_out.last_modified_time == (time_t) -1) {\n    return 1;\n}', 'explanation': 'This code checks if the resource does not have a modification date available (i.e. last_modified_time equals (time_t)-1), and if so, returns early. This matches the RFC requirement to ignore the If-Modified-Since header when the resource’s modification date is not available.'}}]","The function implements a check for the condition where the resource does not have a modification date available, which is a part of the RFC spec. However, other parts of the spec—such as ignoring the header when the field value is not a valid HTTP-date, has multiple members, or when the request method is neither GET nor HEAD—are not addressed within the function_body. Therefore, only some of the RFC constraints are directly implemented in this function, resulting in a 'Partially Matches' judgment.",success,
2338,ngx_http_test_if_match,"When an origin server receives a request that selects a representation and that request includes an If-Match header field, the origin server MUST evaluate the If-Match condition per Section 13.2 prior to performing the method.",98,Fully Matches,"[{'C1': {'code': ""if (list->len == 1 && list->data[0] == '*') {\n    return 1;\n}"", 'explanation': ""This segment handles the case where the If-Match header value is '*', returning true if a representation exists, consistent with the RFC requirement.""}}, {'C2': {'code': ""start = list->data;\nend = list->data + list->len;\n\nwhile (start < end) {\n\n    if (weak\n        && end - start > 2\n        && start[0] == 'W'\n        && start[1] == '/')\n    {\n        start += 2;\n    }\n\n    if (etag.len > (size_t) (end - start)) {\n        return 0;\n    }\n\n    if (ngx_strncmp(start, etag.data, etag.len) != 0) {\n        goto skip;\n    }\n\n    start += etag.len;\n\n    while (start < end) {\n        ch = *start;\n\n        if (ch == ' ' || ch == '\\t') {\n            start++;\n            continue;\n        }\n\n        break;\n    }\n\n    if (start == end || *start == ',') {\n        return 1;\n    }\n\nskip:\n\n    while (start < end && *start != ',') { start++; }\n    while (start < end) {\n        ch = *start;\n\n        if (ch == ' ' || ch == '\\t' || ch == ',') {\n            start++;\n            continue;\n        }\n\n        break;\n    }\n}\n\nreturn 0;"", 'explanation': 'This code iterates through a list of entity tags and compares each entry against the stored ETag. It returns true if any tag matches, complying with the RFC requirement for a list of entity tags.'}}]","The function implements the evaluation of the If-Match header by first checking if the header value is '*' (returning true if a current representation exists) and then, if provided with a list of tags, iterating over it to find a match with the stored ETag (including weak tag handling if applicable). This logic directly addresses the relevant conditions specified in the RFC.",success,
2368,ngx_http_limit_req_status_variable,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function, ngx_http_limit_req_status_variable, solely handles the setting of a status variable based on the value of r->main->limit_req_status. It does not implement any logic related to handling the Content-Location header or ensuring that context information is not used to alter request semantics, as mandated by the RFC specification. There is no code addressing any condition (e.g., C1) or action (e.g., A1) regarding the prohibition of altering request semantics based on context information within this function.",success,
2400,ngx_http_realip_remote_addr_variable,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function code retrieves and sets the remote address variable based on the request context. There is no logic in this function that handles or refers to Content-Location, or the specific constraints that state an origin server MUST NOT use such context information to alter request semantics. Since the function does not incorporate any mechanism to validate or enforce the RFC requirement related to Content-Location, it does not match any of the spec constraints.",success,
2697,ngx_http_mp4_handler,"In 200 responses to GET or HEAD, an origin server SHOULD send any available validator fields (Section 8.8) for the selected representation, with both a strong entity tag and a Last-Modified date being preferred.",141,Fully Matches,"[{'C1': {'code': 'r->headers_out.last_modified_time = of.mtime;', 'explanation': ""This line sets the Last-Modified header based on the file's modification time, fulfilling the requirement to send a Last-Modified date in 200 responses to GET or HEAD.""}}, {'A1': {'code': 'if (ngx_http_set_etag(r) != NGX_OK) {\n    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n}', 'explanation': 'This code calls ngx_http_set_etag(r) to generate and attach an ETag header to the response, thereby providing the strong entity tag validator as preferred by the spec.'}}]","The function explicitly handles GET and HEAD requests and, before sending a 200 response, it sets the Last-Modified header and calls ngx_http_set_etag to generate an ETag. These implementations directly address the RFC specification requirement that a 200 response SHOULD include available validator fields (with a strong entity tag and a Last-Modified date). Therefore, within this function, both conditions are fully met.",success,
2697,ngx_http_mp4_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'if (ngx_http_set_content_type(r) != NGX_OK) {\n    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n}', 'explanation': 'This code segment calls ngx_http_set_content_type(r) right before sending the response header. This ensures that the Content-Type header field is generated for the response containing content, which directly implements the RFC requirement that a sender SHOULD include a Content-Type header unless the media type is unknown.'}}]","The function is responsible for processing and sending MP4 content and, as part of its response preparation, it explicitly sets the Content-Type header by invoking ngx_http_set_content_type(r). This action satisfies the RFC specification that requires a Content-Type header for messages containing content. No additional logic outside of this function is needed to fulfill this requirement, so the function fully matches the specified constraint.",success,
2697,ngx_http_mp4_handler,"A server MUST NOT generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses.",288,Fully Matches,"[{'C1': {'code': 'if (start >= 0) {\n    r->single_range = 1;\n    ...\n}', 'explanation': ""This block clearly indicates that when a valid 'start' (and optionally 'end') is provided the request is marked as a single range request by setting 'r->single_range = 1'. As a consequence, the function proceeds to generate a response for a single range rather than building a multipart response, which complies with the RFC requirement.""}}]","The RFC specifies that a server MUST NOT generate a multipart response to a request for a single range. In this function, the logic that processes query arguments for 'start' and 'end' leads to setting the 'r->single_range' flag. There is no branch that creates multipart boundaries or a multipart response, and the output is generated using either a single chain ('mp4->out' or a file buffer). Thus, by itself this function visibly enforces that a single range request will not yield a multipart response, thereby fully meeting the specified constraint.",success,
2697,ngx_http_mp4_handler,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'A1': {'code': 'r->headers_out.content_length_n = of.size;\n...\nif (mp4) {\n    r->headers_out.content_length_n = mp4->content_length;\n}', 'explanation': 'The function sets the Content-Length header field (using r->headers_out.content_length_n) when the size of the file is known. This aligns with the part of the RFC that directs an origin server to send a Content-Length header when the content length is known. However, the code does not explicitly check for the exceptional conditions described in the spec context (e.g., responses with status codes 1xx, 204, or 2xx for CONNECT requests) nor does it check for the presence of a Transfer-Encoding header, so only part of the RFC’s requirements are addressed.'}}]","The provided function directs a response with a known file size by setting the Content-Length header. It demonstrates an attempt to implement the RFC when the content size is known. However, it does not contain any logic to avoid sending the Content-Length header in responses where it must not be sent according to the RFC (such as 1xx or 204 responses, or 2xx responses to CONNECT requests) and does not check for the presence of Transfer-Encoding. Therefore, while the function includes some of the intended behavior (action A1), it does not fully implement all the conditions of the spec, leading to a 'Partially Matches' judgment.",success,
2697,ngx_http_mp4_handler,All general-purpose servers MUST support the methods GET and HEAD,58,Fully Matches,"[{'C1': {'code': 'if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {\n    return NGX_HTTP_NOT_ALLOWED;\n}', 'explanation': 'This code snippet explicitly checks that the incoming request method is either GET or HEAD. If not, it returns a 405 (Method Not Allowed) status, thereby ensuring that only GET and HEAD methods are processed, which fulfills the HTTP RFC requirement that all general-purpose servers must support GET and HEAD.'}}]","The function clearly implements the necessary check to support GET and HEAD by verifying the request method and returning an error for any others. This self-contained logic within the function properly addresses the spec constraint, ensuring that only GET and HEAD requests are allowed, which meets the RFC specification.",success,
2697,ngx_http_mp4_handler,"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.",52,Fully Matches,"[{'A1': {'code': 'r->headers_out.last_modified_time = of.mtime;', 'explanation': ""This line assigns the file's modification time (of.mtime) to the HTTP response's Last-Modified header, thereby directly implementing the requirement that an origin server SHOULD send the Last-Modified header when a last modification date is determinable.""}}]","The function sets the Last-Modified header using the file's modification time, as required by the specification. Despite additional logic for handling mp4 file processing and range requests, the pertinent segment that addresses the HTTP RFC requirement is the assignment to r->headers_out.last_modified_time, which is done directly within the function. This demonstrates that the function itself is responsible for sending the Last-Modified header, fully matching the spec's requirement.",success,
2697,ngx_http_mp4_handler,"An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",60,Fully Matches,"[{'C1': {'code': 'if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {\n    return NGX_HTTP_NOT_ALLOWED;\n}', 'explanation': 'This code segment checks the incoming request method and, if it is not GET or HEAD, returns NGX_HTTP_NOT_ALLOWED (HTTP 405). This directly implements the specification that a recognized and implemented method that is not permitted for the target resource should cause the server to respond with a 405 status code.'}}]","The function explicitly verifies that the request method is one of the allowed ones (GET or HEAD) and returns a 405 status code for any other method. This visible check within the function’s code satisfies the relevant part of the HTTP RFC as specified, thereby fully matching the constraint.",success,
2697,ngx_http_mp4_handler,"For byte ranges, a sender SHOULD indicate the complete length of the representation from which the range has been extracted, unless the complete length is unknown or difficult to determine.",287,Partially Matches,[],"The RFC requires that for byte-range responses the sender SHOULD indicate the complete length of the overall representation. In this function the full file size (of.size) is used to set r->headers_out.content_length_n when no range is requested, and when a range is requested via mp4 processing, the resulting content length is taken from mp4->content_length. This indicates that the function is aware of a need to communicate size information. However, the function does not explicitly add a Content-Range header containing both the actual byte range and the complete representation length as specified by the RFC. Therefore, while the file’s complete length is used in some cases, the logic does not fully implement the RFC’s requirement for byte-range responses, and as such only partially matches the spec constraints.",success,
2697,ngx_http_mp4_handler,"An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",268,Fully Matches,"[{'C1': {'code': 'if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {\n    return NGX_HTTP_NOT_ALLOWED;\n}\n\nrc = ngx_http_discard_request_body(r);\nif (rc != NGX_OK) {\n    return rc;\n}', 'explanation': 'The RFC specifies that an origin server SHOULD NOT rely on private agreements to receive content. Here, the function first limits processing to GET and HEAD requests and then explicitly discards any request body using ngx_http_discard_request_body(). This ensures that the server does not expect or process any content (possibly originating from private agreements), thereby adhering to the specification.'}}]","The function enforces that only GET (or HEAD) requests are handled and any incoming content is explicitly discarded, which means it does not rely on or process private agreements or content sent in GET requests. This logic directly addresses the RFC requirement and shows that the code function implements the labeled condition (C1) from the specification.",success,
2701,ngx_http_mp4_read_atom,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (atom_size < sizeof(ngx_mp4_atom_header_t)) {\n    if (atom_size == 1) {\n        if (ngx_http_mp4_read(mp4, sizeof(ngx_mp4_atom_header64_t)) != NGX_OK) {\n            return NGX_ERROR;\n        }\n        /* 64-bit atom size */\n        atom_header = mp4->buffer_pos;\n        atom_size = ngx_mp4_get_64value(atom_header + 8);\n        atom_header_size = sizeof(ngx_mp4_atom_header64_t);\n        if (atom_size < sizeof(ngx_mp4_atom_header64_t)) {\n            ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n                          ""\\""%s\\"" mp4 atom is too small:%uL"",\n                          mp4->file.name.data, atom_size);\n            return NGX_ERROR;\n        }\n    } else {\n        ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n                      ""\\""%s\\"" mp4 atom is too small:%uL"",\n                      mp4->file.name.data, atom_size);\n        return NGX_ERROR;\n    }\n}', 'explanation': 'This segment ensures defensive parsing by validating that the received atom has at least the minimal header size required. It checks the atom size and handles both 32-bit and 64-bit cases, returning an error if the size is smaller than expected.'}}, {'A1': {'code': 'if (atom_size > (uint64_t) (NGX_MAX_OFF_T_VALUE - mp4->offset) || mp4->offset + (off_t) atom_size > end) {\n    ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n                  ""\\""%s\\"" mp4 atom too large:%uL"",\n                  mp4->file.name.data, atom_size);\n    return NGX_ERROR;\n}', 'explanation': 'This segment checks that the computed atom size does not exceed the remaining buffer/file bounds, preventing potential buffer overflow or processing of unreasonably large protocol elements. It directly reflects the RFC recommendation to only have marginal expectations about element format and size.'}}]","The function 'ngx_http_mp4_read_atom' implements defensive parsing measures that align with the HTTP RFC guidance. It cautiously validates the size of protocol elements (in this case, MP4 atoms) to ensure that they fit within a reasonable buffer size, and it handles cases where the element might not conform to predefined size expectations. The checks for minimal header sizes, differentiated handling of 32-bit and 64-bit atom headers, and verification against overflow conditions show that the function is designed to be robust against malformed or unexpected input, fulfilling the spirit of the RFC's suggestion.",success,
2714,ngx_http_mp4_read_tkhd_atom,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (ngx_mp4_atom_data_size(ngx_mp4_tkhd_atom_t) > atom_data_size) {\n    ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n                  ""\\""%s\\"" mp4 tkhd atom too small"", mp4->file.name.data);\n    return NGX_ERROR;\n}\n\n... (and similar check for version 1 below)\n\nif (ngx_mp4_atom_data_size(ngx_mp4_tkhd64_atom_t) > atom_data_size) {\n    ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n                  ""\\""%s\\"" mp4 tkhd atom too small"", mp4->file.name.data);\n    return NGX_ERROR;\n}', 'explanation': ""The function performs defensive parsing by verifying that the provided atom_data_size is large enough before attempting to parse the atom. This aligns with the spec's requirement to safely handle protocol elements with only marginal assumptions regarding their conformance and size.""}}]","The function demonstrates a defensive approach by checking that the provided data buffer is sufficient for reading the MP4 'tkhd' atom, including separate checks for both 32‐bit (version 0) and 64‐bit (version 1) durations. This defensive boundary checking fulfills part of the RFC requirement to parse protocol elements cautiously. However, the code does not attempt to enforce or validate the full ABNF grammar or address further potential deviations in format beyond ensuring minimum size. Therefore, while the function partially matches the RFC's expectations for defensive parsing, it does not fully address all aspects outlined in the specification.",success,
2736,ngx_http_mp4_read_stts_atom,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (ngx_mp4_atom_data_size(ngx_mp4_stts_atom_t) > atom_data_size) {\n    ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n                  ""\\""%s\\"" mp4 stts atom too small"", mp4->file.name.data);\n    return NGX_ERROR;\n}', 'explanation': 'This code performs a defensive check to ensure that the available data is large enough to hold at least the header of the stts atom. It ensures that the function does not overread if the input does not conform to expected minimum size.'}}, {'C2': {'code': 'if (ngx_mp4_atom_data_size(ngx_mp4_stts_atom_t) + entries * sizeof(ngx_mp4_stts_entry_t) > atom_data_size) {\n    ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n                  ""\\""%s\\"" mp4 stts atom too small"", mp4->file.name.data);\n    return NGX_ERROR;\n}', 'explanation': 'This code further defends against malformed input by validating that the total size required for the header and all the time-to-sample entries does not exceed the available atom_data_size. This aligns with the defensive parsing expectation of handling only marginally conforming input.'}}]","The function ngx_http_mp4_read_stts_atom implements defensive parsing by validating that the provided buffer contains at least the minimal expected data for both the atom header and its subsequent entries. These checks (labeled here as C1 and C2) ensure the function does not operate on malformed or undersized protocol elements, thereby addressing the RFC specification's requirement to parse protocol elements defensively with only marginal conformance expectations.",success,
2741,ngx_http_mp4_read_stss_atom,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (ngx_mp4_atom_data_size(ngx_http_mp4_stss_atom_t) > atom_data_size) {\n    ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n                  ""\\""%s\\"" mp4 stss atom too small"", mp4->file.name.data);\n    return NGX_ERROR;\n}\n\n...\n\nif (ngx_mp4_atom_data_size(ngx_http_mp4_stss_atom_t) + entries * sizeof(uint32_t) > atom_data_size)\n{\n    ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n                  ""\\""%s\\"" mp4 stss atom too small"", mp4->file.name.data);\n    return NGX_ERROR;\n}', 'explanation': ""The function implements defensive parsing by checking that the provided atom data size is large enough to contain both the atom header and the expected table of sync sample entries. These validations ensure that the element does not exceed a 'reasonable buffer size' before parsing further, thereby directly addressing the defensive parsing requirement of the spec.""}}]","The function ngx_http_mp4_read_stss_atom exhibits defensive parsing techniques by verifying the atom's header and total byte sizes before proceeding. It checks that the provided atom data size is sufficient for both the header and the dynamically computed payload (sync sample entries), logging errors and halting execution if the size does not meet expectations. This logic directly implements the spec's guidance of parsing protocol elements defensively, with only marginal assumptions about their conformance or size. Thus, the code fully meets the condition described in the RFC specification.",success,
2749,ngx_http_mp4_read_stsc_atom,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (ngx_mp4_atom_data_size(ngx_mp4_stsc_atom_t) > atom_data_size) {\n    ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n                  ""\\""%s\\"" mp4 stsc atom too small"", mp4->file.name.data);\n    return NGX_ERROR;\n}\n\nentries = ngx_mp4_get_32value(stsc_atom->entries);\n\nif (ngx_mp4_atom_data_size(ngx_mp4_stsc_atom_t)\n    + entries * sizeof(ngx_mp4_stsc_entry_t) > atom_data_size)\n{\n    ngx_log_error(NGX_LOG_ERR, mp4->file.log, 0,\n                  ""\\""%s\\"" mp4 stsc atom too small"", mp4->file.name.data);\n    return NGX_ERROR;\n}', 'explanation': ""These segments perform defensive buffer size checks before processing the atom. This aligns with the specification requirement to parse defensively, ensuring that the atom's reported size and the computed size based on entries do not exceed the available data. However, no explicit grammar (ABNF) parsing is done.""}}]","The function implements defensive parsing by verifying that the MP4 atom's data size is at least as large as expected, protecting against buffer underflow or malformed data. This defensive check partially matches the RFC's requirement to parse protocol elements defensively (as outlined in the condition regarding reasonable buffer sizes). However, the function does not attempt to validate conformity to an ABNF grammar, and thus only partially fulfills the overall specification.",success,
2770,ngx_http_chunked_header_filter,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'A1': {'code': 'if (r->http_version >= NGX_HTTP_VERSION_11\n            && clcf->chunked_transfer_encoding)\n        {\n            if (r->expect_trailers) {\n                ngx_http_clear_content_length(r);\n            }\n\n            r->chunked = 1;\n\n            ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_chunked_filter_ctx_t));\n            if (ctx == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_http_set_ctx(r, ctx, ngx_http_chunked_filter_module);\n        }', 'explanation': 'This segment enables chunked transfer encoding when the HTTP version is at least 1.1 and chunked encoding is configured. By doing so, it allows the server to send responses without a known content-length, which is a mechanism that supports keeping connections persistent when possible.'}}, {'C1': {'code': 'else if (r->headers_out.content_length_n == -1) {\n            r->keepalive = 0;\n        }', 'explanation': 'This branch disables the keepalive (i.e. persistent connection) when the content length is unknown and chunked transfer encoding cannot be applied. It reflects a decision to avoid sustaining a persistent connection when the conditions for doing so are not met.'}}]","The RFC requires that a server should sustain persistent connections when possible and use flow-control rather than terminating connections unnecessarily. Within the function, the code checks for conditions (such as unknown content length) and then attempts to use chunked transfer encoding if the request qualifies (HTTP/1.1 and configured support). This mechanism indirectly supports persistent connections by allowing data to be sent without closing the connection. Conversely, if chunked encoding is not an option, the function disables keepalive (persistent connection) by setting r->keepalive to 0. Although the function does not implement the full range of RFC-prescribed behaviors (for example, monitoring the network during message body transmission or handling flow-control directly), it visibly addresses the persistence aspect. Thus, while some of the constraints (e.g., sustaining persistent connections via chunked encoding) are implemented, other parts such as explicit management of flow-control are not, leading to a 'Partially Matches' outcome.",success,
2770,ngx_http_chunked_header_filter,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Partially Matches,"[{'C1': {'code': 'if (r->headers_out.status == NGX_HTTP_NOT_MODIFIED\n    || r->headers_out.status == NGX_HTTP_NO_CONTENT\n    || r->headers_out.status < NGX_HTTP_OK\n    || r != r->main\n    || r->method == NGX_HTTP_HEAD)\n{\n    return ngx_http_next_header_filter(r);\n}', 'explanation': 'This early return block checks if the response status indicates an informational (1xx) or No Content (204) response (among additional cases) and then bypasses further modifications. This is an implicit way to avoid altering headers (including the Content-Length header) for these responses, partially addressing the spec requirement.'}}]","The code function checks for response statuses that should not have a Content-Length header (namely informational responses indicated by status < NGX_HTTP_OK and 204 responses) by returning early. However, it does not explicitly clear or remove the Content-Length header for these cases (except in one branch for expect_trailers), and it also groups additional unrelated conditions (304, non-main requests, HEAD method). Thus, while it partially addresses the RFC constraint by avoiding further processing for 1xx and 204 responses, it does not completely implement all aspects of the spec regarding the Content-Length header.",success,
2770,ngx_http_chunked_header_filter,HTTP implementations SHOULD support persistent connections.,311,Partially Matches,"[{'C1': {'code': 'if (r->http_version >= NGX_HTTP_VERSION_11\n            && clcf->chunked_transfer_encoding)\n        {\n            if (r->expect_trailers) {\n                ngx_http_clear_content_length(r);\n            }\n\n            r->chunked = 1;\n\n            ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_chunked_filter_ctx_t));\n            if (ctx == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_http_set_ctx(r, ctx, ngx_http_chunked_filter_module);\n\n        } else if (r->headers_out.content_length_n == -1) {\n            r->keepalive = 0;\n        }', 'explanation': 'The function checks if the request is HTTP/1.1 and if chunked transfer encoding is enabled; if so, it enables chunked encoding (r->chunked = 1) to thereby support persistent connections when the content length is undefined. In the alternative case when content length is unknown and chunked encoding is not enabled, it disables keepalive (persistent connection) by setting r->keepalive = 0. This partially addresses the requirement that HTTP implementations SHOULD support persistent connections.'}}]","The provided function contains logic that deals with the response's transfer encoding based on the HTTP version and content length. In cases where the HTTP version is 1.1 and chunked transfer encoding is supported, it enables chunked processing which facilitates persistent connections. However, the function does not directly handle all aspects of persistent connection support, such as specifically examining the Connection header field, so it only partially meets the spec constraint.",success,
2770,ngx_http_chunked_header_filter,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The RFC specification prohibits merging trailer fields into the header unless the recipient understands and permits such merging. In the function_body, while there is a check for the presence of trailers (using r->expect_trailers) and some adjustments (like clearing the content-length header and enabling chunked encoding), there is no logic that verifies whether the trailer fields are known or safely mergeable. The function does not implement the safety check or merge behavior mandated by the spec, and thus it does not address the labeled constraint.",success,
2770,ngx_http_chunked_header_filter,A server MAY send a Content-Length header field in a response to a HEAD request (Section 9.3.2); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a response if the same request had used the GET method.,43,Partially Matches,"[{'C1': {'code': 'if (r->headers_out.status == NGX_HTTP_NOT_MODIFIED\n        || r->headers_out.status == NGX_HTTP_NO_CONTENT\n        || r->headers_out.status < NGX_HTTP_OK\n        || r != r->main\n        || r->method == NGX_HTTP_HEAD)\n{\n    return ngx_http_next_header_filter(r);\n}', 'explanation': 'This code segment bypasses further header modifications when the response status is 304 (Not Modified), 204 (No Content), any status below 200, when the request is not the main request, or when the HTTP method is HEAD. This helps ensure that Content-Length is not inadvertently set for HEAD responses, partially addressing the RFC requirement on Content-Length for HEAD requests.'}}]","The function examines several conditions (e.g., HEAD method, 304 status) and exits early to avoid adding chunked encoding or making changes that could lead to the inappropriate inclusion of a Content-Length header. However, it does not verify or enforce that, if present, the Content-Length header value equals the decimal number of octets that would have been sent in a GET response. Therefore, while it takes steps to avoid sending an inappropriate Content-Length (by excluding HEAD, 304, etc.), it does not fully implement the RFC requirement regarding the exact Content-Length value. As such, only part of the specification logic is handled within this function.",success,
2770,ngx_http_chunked_header_filter,A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content).,193,Fully Matches,"[{'C1': {'code': 'if (r->headers_out.status == NGX_HTTP_NOT_MODIFIED\n        || r->headers_out.status == NGX_HTTP_NO_CONTENT\n        || r->headers_out.status < NGX_HTTP_OK\n        || r != r->main\n        || r->method == NGX_HTTP_HEAD)\n{\n    return ngx_http_next_header_filter(r);\n}', 'explanation': 'This block checks if the response status is 1xx (via r->headers_out.status < NGX_HTTP_OK) or specifically 204 (NGX_HTTP_NO_CONTENT), among other conditions, and immediately returns without setting chunked transfer encoding. This prevents a Transfer-Encoding header from being included in responses where it is disallowed by the RFC.'}}]","The provided function correctly implements the RFC requirement by not adding the Transfer-Encoding header for status codes 1xx and 204. It does so by checking if r->headers_out.status indicates a 1xx or 204 response (as well as other conditions like HEAD requests or non-main requests) and, in those cases, it bypasses the chunked encoding logic. Therefore, the function fully addresses the specified RFC constraint within its own code.",success,
2770,ngx_http_chunked_header_filter,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,61,Partially Matches,"[{'C1': {'code': 'if (r->headers_out.status == NGX_HTTP_NOT_MODIFIED\n    || r->headers_out.status == NGX_HTTP_NO_CONTENT\n    || r->headers_out.status < NGX_HTTP_OK\n    || r != r->main\n    || r->method == NGX_HTTP_HEAD)\n{\n    return ngx_http_next_header_filter(r);\n}', 'explanation': 'This segment explicitly checks if the request method is HEAD and immediately returns, thereby bypassing any further header modifications or chunked encoding logic. This action helps enforce the RFC requirement that a HEAD request must not result in the response body being generated.'}}]","The function includes logic that detects when the request is a HEAD request (r->method == NGX_HTTP_HEAD) and skips any additional processing related to content transmission (such as applying chunked transfer encoding). This behavior partially meets the RFC specification that requires a HEAD response to not include a message body. However, the function delegates further handling to the next header filter (ngx_http_next_header_filter), rather than explicitly clearing or preventing the response content, which means that while it addresses the condition of HEAD requests, it does so indirectly. Hence, the implementation in this function is considered a partial match to the specification.",success,
2770,ngx_http_chunked_header_filter,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Partially Matches,"[{'C1': {'code': 'if (r->headers_out.content_length_n == -1 || r->expect_trailers) {\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n    if (r->http_version >= NGX_HTTP_VERSION_11 && clcf->chunked_transfer_encoding) {\n        if (r->expect_trailers) {\n            ngx_http_clear_content_length(r);\n        }\n        r->chunked = 1;\n        ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_chunked_filter_ctx_t));\n        if (ctx == NULL) {\n            return NGX_ERROR;\n        }\n        ngx_http_set_ctx(r, ctx, ngx_http_chunked_filter_module);\n    } else if (r->headers_out.content_length_n == -1) {\n        r->keepalive = 0;\n    }\n}', 'explanation': 'This code checks if the response lacks a Content-Length header or has expectations for trailers, and then attempts to use chunked transfer encoding if HTTP/1.1 is used and the configuration permits it. This aligns with the RFC’s recommendation to use an encoding (here, chunked) when a message’s length is not otherwise known.'}}]","The function implements part of the RFC's recommendations by ensuring that when no valid Content-Length header is present, the response is framed using chunked transfer encoding (if supported) or by disabling keepalive to force connection closure. However, it does not fully address all aspects of the spec (for example, detailed handling of invalid Content-Length values and related error scenarios), so while it visibly covers the alternative framing via chunked encoding, the implementation is only a partial match to the RFC constraints.",success,
2772,ngx_http_chunked_create_trailers,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Fully Matches,"[{'C1': {'code': '*b->last++ = CR; *b->last++ = LF;', 'explanation': ""The function explicitly outputs CR followed immediately by LF in multiple places (e.g., at the beginning when writing CRLF, after the chunk size '0', and after each header line). This ensures that no bare CR (CR not immediately followed by LF) is ever generated, which fully complies with the RFC requirement.""}}]","The function constructs the HTTP chunked transfer trailers by appending CRLF sequences at all required boundaries. Every instance of a CR output is directly and immediately followed by an LF, as exhibited by the repeated use of '*b->last++ = CR; *b->last++ = LF;' in the function. Thus, the function fully addresses the RFC spec that mandates a sender must not generate a bare CR.",success,
2772,ngx_http_chunked_create_trailers,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,36,Fully Matches,"[{'C1': {'code': 'if (len == 0) {\n    b->pos = (u_char *) CRLF ""0"" CRLF CRLF;\n    b->last = b->pos + sizeof(CRLF ""0"" CRLF CRLF) - 1;\n    return cl;\n}\n...\n*b->last++ = CR; *b->last++ = LF;\n*b->last++ = \'0\';\n*b->last++ = CR; *b->last++ = LF;\n...\n*b->last++ = CR; *b->last++ = LF;', 'explanation': 'The function constructs the message body by explicitly inserting CR and LF characters to form the line break sequences. It uses constructs such as CRLF in string literals and explicit assignments (e.g., *b->last++ = CR; *b->last++ = LF;) ensuring that only CRLF is used to mark line breaks, fully satisfying the RFC specification requirement.'}}]","The provided function ngx_http_chunked_create_trailers() clearly implements the RFC requirement that the message body must use only CRLF to represent line breaks between body parts. By using CRLF in both its literal buffer initialization and through explicit character assignments, the function satisfies condition C1 as specified in the RFC. No other newline characters are used in the function, indicating full adherence to the requirement within this code segment.",success,
2772,ngx_http_chunked_create_trailers,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The RFC specification requires that a recipient must not merge a trailer field into a header section unless the definition explicitly permits safe merging. The provided function simply creates a separate trailer block for HTTP chunked responses by iterating over the trailer headers and copying them into a buffer. It neither checks whether a header field’s definition permits merging nor attempts to merge trailer fields into the header section. Therefore, no parts of the function address the spec condition concerning safe merging of trailer fields.",success,
2806,ngx_http_gzip_header_filter,"If one or more encodings have been applied to a representation, the sender that applied the encodings MUST generate a Content-Encoding header field that lists the content codings in the order in which they were applied.",37,Fully Matches,"[{'A1': {'code': 'h = ngx_list_push(&r->headers_out.headers);\nif (h == NULL) {\n    return NGX_ERROR;\n}\n\nh->hash = 1;\nngx_str_set(&h->key, ""Content-Encoding"");\nngx_str_set(&h->value, ""gzip"");\nr->headers_out.content_encoding = h;', 'explanation': ""This segment directly creates and attaches a 'Content-Encoding' header with the value 'gzip', thus fulfilling the RFC requirement to generate a Content-Encoding header field listing the applied encoding. It directly implements the specification by adding the header when gzip encoding is applied.""}}]","The function checks whether gzip encoding should be applied and, when applicable, it creates the Content-Encoding header with the appropriate value. This behavior directly aligns with the RFC requirement that if any encoding is applied to a representation, the header must list the encoding(s) in the order applied. Since only gzip encoding is applied here, setting the header with 'gzip' fully meets the constraint.",success,
2806,ngx_http_gzip_header_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'ngx_http_clear_content_length(r);', 'explanation': 'The function explicitly calls ngx_http_clear_content_length(r) which removes the Content-Length header from the message. This prevents forwarding a Content-Length header that might be incorrect, addressing the core action of the spec which requires that a sender MUST NOT forward a message with a Content-Length header that is known to be incorrect.'}}]","The provided function takes steps to ensure that no Content-Length header is forwarded by clearing it, which aligns with part of the specification (action A1). However, the function does not include logic to validate the Content-Length header against the ABNF or handle the special case of duplicate Content-Length values as described in the spec context. Therefore, while it partially implements the spec by removing the header, it does not cover all aspects of the RFC requirement.",success,
2806,ngx_http_gzip_header_filter,"Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",308,Does Not Match,[],"The function ngx_http_gzip_header_filter does not address any logic related to the RFC specification constraint regarding the prohibition of defining parameters called 'q' (case-insensitively) for transfer codings. The code solely focuses on processing gzip-related header filtering (setting 'Content-Encoding' to 'gzip', testing content type, etc.) and does not inspect, modify, or reject any transfer coding parameters. Thus, no part of this function implements the condition which prevents the ambiguity with a 'q' parameter as described in the RFC context.",success,
2806,ngx_http_gzip_header_filter,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Does Not Match,[],"The provided code function is focused on modifying headers for gzip encoding on responses with statuses NGX_HTTP_OK, NGX_HTTP_FORBIDDEN, and NGX_HTTP_NOT_FOUND, and it clears the Content-Length header unconditionally within that narrow context using ngx_http_clear_content_length(r). However, the RFC constraint requires that a server MUST NOT send a Content-Length header in responses with a status code of 1xx or 204. There is no logic in this function to check for 1xx or 204 status codes or to enforce clearing/omitting the Content-Length header specifically for those cases. Therefore, within the function_body itself, the necessary conditions (e.g., C1) are not addressed.",success,
2850,ngx_http_dav_put_handler,"If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server MUST send either a 200 (OK) or a 204 (No Content) response to indicate successful completion of the request.",66,Fully Matches,"[{'C1': {'code': 'if (ngx_file_info(path.data, &fi) == NGX_FILE_ERROR) {\n    status = NGX_HTTP_CREATED;\n} else {\n    status = NGX_HTTP_NO_CONTENT;\n    if (ngx_is_dir(&fi)) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, NGX_EISDIR,\n                      \'""%s"" could not be created\', path.data);\n        ...\n        ngx_http_finalize_request(r, NGX_HTTP_CONFLICT);\n        return;\n    }\n}', 'explanation': 'This segment determines whether the target resource exists. If it exists (i.e. a current representation is present) then the status is set to NGX_HTTP_NO_CONTENT (i.e. 204), which aligns with the RFC that a modified representation must return either 200 or 204.'}}, {'A1': {'code': 'r->headers_out.status = status;\nr->header_only = 1;\nngx_http_finalize_request(r, ngx_http_send_header(r));', 'explanation': 'This segment sends the appropriate response based on the operation outcome. For an existing resource modification the function returns 204 (No Content), fulfilling the RFC requirement of returning a 200 or 204 status.'}}]","The function inspects whether the resource exists by checking file information and then sets the response status appropriately. In the case that a current representation exists and is successfully modified, it returns a 204 (No Content) response, and in the case that no current representation exists (i.e. creation) it returns a 201 (Created) response. This behavior fully addresses the RFC requirements as specified by the conditions (C1) and actions (A1) directly within the function_body.",success,
2850,ngx_http_dav_put_handler,"An origin server MUST NOT send a validator field (Section 8.8), such as an ETag or Last-Modified field, in a successful response to PUT unless the request's representation data was saved without any transformation applied to the content (i.e., the resource's new representation data is identical to the content received in the PUT request) and the validator field value reflects the new representation.",70,Does Not Match,[],"The provided function implements the basic handling of a PUT request (e.g., processing the request body, renaming the temporary file, and finalizing the request with appropriate status codes) but does not address the specific RFC requirement regarding validator fields. There is no logic in the function that checks whether the representation was saved without any transformation or that conditionally adds (or omits) validator fields (such as ETag or Last-Modified) based on that condition. Thus, the function does not visibly address any of the labeled conditions or actions specified in the RFC.",success,
2850,ngx_http_dav_put_handler,A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content).,193,Does Not Match,[],"The RFC requires that the server must not send a Transfer-Encoding header in responses with a 1xx or 204 status. Although this function sets the status code (e.g., NGX_HTTP_NO_CONTENT for 204) and prepares the response, there is no visible handling or removal of the Transfer-Encoding header within this function. The function does not include any logic to detect or clear a Transfer-Encoding header, meaning it does not directly implement the constraint specified by the RFC.",success,
2850,ngx_http_dav_put_handler,"If the target resource does not have a current representation and the PUT successfully creates one, then the origin server MUST inform the user agent by sending a 201 (Created) response.",65,Fully Matches,"[{'C1': {'code': 'if (ngx_file_info(path.data, &fi) == NGX_FILE_ERROR) {\n    status = NGX_HTTP_CREATED;\n}', 'explanation': 'This segment checks whether the target resource exists (i.e. has a current representation). When the file lookup fails, it sets the status to 201 (Created) as required by the RFC if a new resource is created.'}}, {'A1': {'code': 'r->headers_out.status = status;\nr->header_only = 1;\nngx_http_finalize_request(r, ngx_http_send_header(r));', 'explanation': 'This segment sends the appropriate response status code (201 for creation or 204 for modification) back to the client, fulfilling the action of informing the user agent with a 201 response if a new resource was created.'}}]","The function distinguishes between the two cases of PUT requests: one where the target resource does not exist (and thus sets the status to 201 Created) and one where it does exist (using 204 No Content). This behavior directly addresses the RFC requirement that a successful creation must be acknowledged with a 201 response. Therefore, the code function fully meets the specified constraint by its internal logic without relying on dependencies.",success,
2850,ngx_http_dav_put_handler,An origin server without a clock MUST NOT generate a Date header field.,17,Does Not Match,[],"The RFC specification requires that an origin server without a clock must not generate a Date header field, and that a server with a clock must generate one in certain response types. In the provided function, there is no logic that generates or suppresses a Date header field based on whether the server has a clock. The function merely checks if an incoming Date header exists and, if so, parses it to pass along in a file operation. There is no visible implementation within this function that generates a Date header in the response or enforces the restriction for servers without clocks. Therefore, the code does not address the specified HTTP RFC constraints.",success,
2850,ngx_http_dav_put_handler,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Fully Matches,"[{'C1': {'code': 'if (status == NGX_HTTP_CREATED) {\n    if (ngx_http_dav_location(r) != NGX_OK) {\n        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n        return;\n    }\n    r->headers_out.content_length_n = 0;\n}\n\nr->headers_out.status = status;\nr->header_only = 1;\n\nngx_http_finalize_request(r, ngx_http_send_header(r));', 'explanation': 'The RFC requires that a server MUST NOT send a Content-Length header field in any response with a status code of 1xx or 204. In this function the response status is either NGX_HTTP_CREATED (201) or NGX_HTTP_NO_CONTENT (204). When the status is 201, the function explicitly sets the Content-Length to 0, which is allowed. When the status is 204, the function does not set the Content-Length header field (by omission), thereby ensuring that a 204 response will not include a Content-Length header, satisfying the RFC requirement.'}}]","The function distinguishes its responses based on whether the target file exists. It explicitly sets a Content-Length header (with a value of 0) only for a 201 (Created) response and omits setting this header for a 204 (No Content) response. Since the RFC mandates not sending the Content-Length header on 204 or 1xx responses, this function correctly implements that constraint for its 204 response. There is no possibility of a 1xx response within this handler, so the intended behavior fully complies with the spec.",success,
2852,ngx_http_dav_delete_handler,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (r->headers_in.content_length_n > 0 || r->headers_in.chunked) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""DELETE with body is unsupported"");\n    return NGX_HTTP_UNSUPPORTED_MEDIA_TYPE;\n}', 'explanation': ""This segment checks that a DELETE request must not contain a body, thereby interpreting the protocol element based on the RFC's requirement to handle extensions or non‐standard usages (i.e. the presence of a body).""}}, {'A1': {'code': 'depth = ngx_http_dav_depth(r, NGX_HTTP_DAV_INFINITY_DEPTH);\nif (depth != NGX_HTTP_DAV_INFINITY_DEPTH) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""\\""Depth\\"" header must be infinity"");\n    return NGX_HTTP_BAD_REQUEST;\n}\n\n... (and similarly for non-directory resources)\ndepth = ngx_http_dav_depth(r, 0);\nif (depth != 0 && depth != NGX_HTTP_DAV_INFINITY_DEPTH) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""\\""Depth\\"" header must be 0 or infinity"");\n    return NGX_HTTP_BAD_REQUEST;\n}', 'explanation': ""These code sections interpret the 'Depth' header provided with DELETE requests. Depending on whether the target is a directory or a file, the code validates the header accordingly, which is an action required by the RFC to correctly interpret received protocol elements.""}}]","The provided function implements certain aspects of the HTTP RFC by ensuring that parts of the protocol—specifically, restrictions on having a DELETE body and the proper interpretation and enforcement of the 'Depth' header—are validated within the function. However, while these segments address some of the conditions and actions expected as part of the RFC's semantics, the function does not cover the full breadth of protocol element interpretation nor handle all possible extensions or error recovery as described in the RFC specification. As such, the implementation only partially matches the spec constraints.",success,
2869,ngx_http_dav_depth,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (depth == NULL) {\n    return dflt;\n}\n\nif (depth->value.len == 1) {\n\n    if (depth->value.data[0] == \'0\') {\n        return 0;\n    }\n\n    if (depth->value.data[0] == \'1\') {\n        return 1;\n    }\n\n} else {\n\n    if (depth->value.len == sizeof(""infinity"") - 1\n        && ngx_strcmp(depth->value.data, ""infinity"") == 0)\n    {\n        return NGX_HTTP_DAV_INFINITY_DEPTH;\n    }\n}', 'explanation': ""This segment implements a defensive parsing mechanism by checking for a NULL header, validating the length of the header value, and only accepting specific valid values ('0', '1', or exactly 'infinity'). It reflects an attempt to conform to a robust parsing strategy as suggested by the spec.""}}, {'A1': {'code': 'ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n              ""client sent invalid \\""Depth\\"" header: \\""%V\\"""",\n              &depth->value);', 'explanation': ""This code logs an error when the Depth header value doesn't match expected formats, thereby handling unexpected or malformed protocol elements defensively.""}}]","The function implements part of the specified RFC requirement by defensively parsing the 'Depth' header: it checks for NULL, validates the length to ensure the value fits within a narrow set of expected sizes, and only accepts well-defined values ('0', '1', or 'infinity'). It also logs an error in cases of unexpected input. However, while it addresses defensive parsing for this particular header, it does so in a narrowly defined context and does not cover all possible aspects of the broader protocol element parsing expectations outlined in the RFC. Thus, it only partially matches the overall specification.",success,
2869,ngx_http_dav_depth,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'if (depth == NULL) {\n    return dflt;\n}', 'explanation': 'The function recovers a usable Depth value by returning a default when the Depth header is absent. This partially fulfills the RFC allowance to recover from an invalid construct. However, for a header present with an invalid value, the function logs an error and returns an invalid constant instead of attempting further recovery.'}}]","The RFC specifies that a recipient MAY attempt to recover a usable protocol element from an invalid construct. In this function, if the Depth header is missing, the default value is returned, which is an attempt at recovery. Additionally, valid representations for '0', '1', and 'infinity' are supported. However, if the header value does not match these expected values, the function does not try to recover; instead, it logs an error and returns an error marker. This means that while the function implements some recovery logic, it does not fully address recovery for all invalid constructs as suggested by the RFC.",success,
2869,ngx_http_dav_depth,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (depth == NULL) {\n    return dflt;\n}\n\nif (depth->value.len == 1) {\n\n    if (depth->value.data[0] == \'0\') {\n        return 0;\n    }\n\n    if (depth->value.data[0] == \'1\') {\n        return 1;\n    }\n\n} else {\n\n    if (depth->value.len == sizeof(""infinity"") - 1\n        && ngx_strcmp(depth->value.data, ""infinity"") == 0)\n    {\n        return NGX_HTTP_DAV_INFINITY_DEPTH;\n    }\n}\n\nngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n              ""client sent invalid \\""Depth\\"" header: \\""%V\\"""",\n              &depth->value);\n\nreturn NGX_HTTP_DAV_INVALID_DEPTH;', 'explanation': ""The function checks if the request includes a Depth header and, if present, it interprets it according to a limited set of semantics ('0', '1', or 'infinity') and logs an error if the value is outside these expected values. This addresses the requirement to interpret a received protocol element according to the defined semantics.""}}]","The code function shows logic that interprets the Depth header by examining its value and returning an appropriate constant for valid inputs. It also handles the absence of the header and invalid values by logging an error. However, the RFC specification indicates that a recipient MUST interpret the protocol element according to all semantics defined (including extensions) and might attempt to recover from invalid constructs when appropriate. Since the function only covers a subset of the possible valid inputs and does not implement broader error recovery mechanisms or extensions handling, it only partially matches the overall RFC requirements based solely on the visible logic within the function.",success,
2871,ngx_http_dav_location,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,155,Fully Matches,"[{'C1': {'code': 'r->headers_out.location = ngx_list_push(&r->headers_out.headers);\nif (r->headers_out.location == NULL) {\n    return NGX_ERROR;\n}\n\nr->headers_out.location->hash = 1;\nr->headers_out.location->next = NULL;\nngx_str_set(&r->headers_out.location->key, ""Location"");', 'explanation': ""This segment of code creates a new header in the response and explicitly assigns the key 'Location', thereby fulfilling the requirement that the server should include a Location header field.""}}, {'A1': {'code': 'escape = 2 * ngx_escape_uri(NULL, r->uri.data, r->uri.len, NGX_ESCAPE_URI);\n\nif (escape) {\n    len = r->uri.len + escape;\n\n    p = ngx_pnalloc(r->pool, len);\n    if (p == NULL) {\n        ngx_http_clear_location(r);\n        return NGX_ERROR;\n    }\n\n    r->headers_out.location->value.len = len;\n    r->headers_out.location->value.data = p;\n\n    ngx_escape_uri(p, r->uri.data, r->uri.len, NGX_ESCAPE_URI);\n\n} else {\n    r->headers_out.location->value = r->uri;\n}', 'explanation': 'This portion of the function computes whether any URI escaping is necessary, allocates memory accordingly, escapes the URI if needed, and assigns it as the value of the Location header. This ensures that the generated header contains a valid URI, as required by the RFC.'}}]","The function solely deals with setting up and populating the Location header field in the HTTP response. It first allocates a header structure and sets the key to 'Location' and then ensures that the URI, after being escaped as necessary, becomes the header value. This directly implements the RFC specification that requires the server to generate a Location header containing the new permanent URI.",success,
2871,ngx_http_dav_location,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,160,Fully Matches,"[{'C1': {'code': 'r->headers_out.location = ngx_list_push(&r->headers_out.headers);\nif (r->headers_out.location == NULL) {\n    return NGX_ERROR;\n}\n\nr->headers_out.location->hash = 1;\nr->headers_out.location->next = NULL;\nngx_str_set(&r->headers_out.location->key, ""Location"");', 'explanation': ""This segment allocates a new header entry and explicitly sets its key to 'Location', thereby creating the Location header field required by the RFC.""}}, {'A1': {'code': 'escape = 2 * ngx_escape_uri(NULL, r->uri.data, r->uri.len, NGX_ESCAPE_URI);\n\nif (escape) {\n    len = r->uri.len + escape;\n    p = ngx_pnalloc(r->pool, len);\n    if (p == NULL) {\n        ngx_http_clear_location(r);\n        return NGX_ERROR;\n    }\n    r->headers_out.location->value.len = len;\n    r->headers_out.location->value.data = p;\n    ngx_escape_uri(p, r->uri.data, r->uri.len, NGX_ESCAPE_URI);\n} else {\n    r->headers_out.location->value = r->uri;\n}', 'explanation': 'This segment sets the value of the Location header to a properly escaped URI derived from r->uri, fulfilling the action requirement to include a preferred URI reference in the response.'}}]","The function creates and populates a Location header field in the response. It allocates memory for the header, sets the header key to 'Location', and assigns an escaped URI (or the original URI if no escaping is needed) as its value. This directly addresses the RFC requirement that the server SHOULD generate a Location header containing a preferred URI reference for the new permanent URI.",success,
2880,ngx_http_random_index_handler,All general-purpose servers MUST support the methods GET and HEAD,58,Partially Matches,"[{'C1': {'code': 'if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD|NGX_HTTP_POST))) {\n    return NGX_DECLINED;\n}', 'explanation': ""This segment checks that the request method is one of GET, HEAD, or POST. By explicitly including NGX_HTTP_GET and NGX_HTTP_HEAD, the function shows that it supports these methods. However, it also allows POST and does not differentiate HEAD from GET (e.g., to suppress a message body), nor does it handle unrecognized methods with 501 or disallowed methods with 405 as suggested by the RFC. This means that while the function addresses the basic requirement of accepting GET and HEAD, it does not fully implement all facets of the HTTP RFC's method handling requirements.""}}]","The provided function contains a check for allowed methods which includes both GET and HEAD, thereby partially implementing the RFC requirement that all general-purpose servers MUST support these methods. However, because the function also permits POST without special handling for HEAD (such as omitting the response body) and does not implement RFC-recommended responses (like 501 for unrecognized methods or 405 for methods that are recognized but not allowed), its implementation only partially matches the specified RFC.",success,
2897,ngx_http_range_header_filter,"However, a server MAY generate a ""multipart/byteranges"" response with only a single body part if multiple ranges were requested and only one range was found to be satisfiable or only one range remained after coalescing.",289,Fully Matches,"[{'A1': {'code': '    switch (ngx_http_range_parse(r, ctx, ranges)) {\n    case NGX_OK:\n        ngx_http_set_ctx(r, ctx, ngx_http_range_body_filter_module);\n\n        r->headers_out.status = NGX_HTTP_PARTIAL_CONTENT;\n        r->headers_out.status_line.len = 0;\n\n        if (ctx->ranges.nelts == 1) {\n            return ngx_http_range_singlepart_header(r, ctx);\n        }\n\n        return ngx_http_range_multipart_header(r, ctx);', 'explanation': ""The RFC stipulates that although multiple ranges may be requested, if only one range remains after evaluating and possibly coalescing them, the server MAY generate a response with a single body part rather than a multipart response. The code implements this by checking if 'ctx->ranges.nelts' equals 1. If so, it invokes 'ngx_http_range_singlepart_header', ensuring a single-part response is generated, which is in full agreement with the specification.""}}]","The function inspects the request's Range header and performs range parsing. After processing, it distinguishes between a single satisfiable range and multiple ranges. When only one range remains (either inherently or after coalescing), it returns a single-part header response rather than constructing a multipart response. This behavior directly implements the RFC requirement that a server MAY generate a 'multipart/byteranges' response with only a single body part under these conditions.",success,
2897,ngx_http_range_header_filter,"If all of the preconditions are true, the server supports the Range header field for the target resource, the received Range field-value contains a valid ranges-specifier with a range-unit supported for that target resource, and that ranges-specifier is satisfiable with respect to the selected representation, the server SHOULD send a 206 (Partial Content) response with content containing one or more partial representations that correspond to the satisfiable range-spec(s) requested.",131,Fully Matches,"[{'C1': {'code': 'if (r->http_version < NGX_HTTP_VERSION_10\n        || r->headers_out.status != NGX_HTTP_OK\n        || (r != r->main && !r->subrequest_ranges)\n        || r->headers_out.content_length_n == -1\n        || !r->allow_ranges) {\n        return ngx_http_next_header_filter(r);\n    }', 'explanation': 'This segment verifies basic preconditions required by the RFC – ensuring an appropriate HTTP version, a 200 OK status, that the request is the main one (or properly marked for subrequests), that a content-length exists, and that range requests are allowed. This corresponds to the first set of conditions expected by the specification.'}}, {'C2': {'code': 'if (r->headers_in.range == NULL\n        || r->headers_in.range->value.len < 7\n        || ngx_strncasecmp(r->headers_in.range->value.data,\n                           (u_char *) ""bytes="", 6) != 0) {\n        goto next_filter;\n    }', 'explanation': 'This block checks that a Range header exists and that its value starts with the expected ""bytes="" prefix, thus confirming that the header contains a valid range-specifier with a supported unit.'}}, {'C3': {'code': 'if (r->headers_in.if_range) {\n    if_range = &r->headers_in.if_range->value;\n\n    if (if_range->len >= 2 && if_range->data[if_range->len - 1] == \'""\') {\n        if (r->headers_out.etag == NULL) {\n            goto next_filter;\n        }\n\n        etag = &r->headers_out.etag->value;\n\n        if (if_range->len != etag->len\n            || ngx_strncmp(if_range->data, etag->data, etag->len) != 0) {\n            goto next_filter;\n        }\n        goto parse;\n    }\n\n    if (r->headers_out.last_modified_time == (time_t) -1) {\n        goto next_filter;\n    }\n\n    if_range_time = ngx_parse_http_time(if_range->data, if_range->len);\n\n    if (if_range_time != r->headers_out.last_modified_time) {\n        goto next_filter;\n    }\n}', 'explanation': 'This portion handles the If-Range header checks by comparing either the ETag or the last modified time, ensuring that the condition specified in the RFC is met before applying the range processing.'}}, {'A1': {'code': 'switch (ngx_http_range_parse(r, ctx, ranges)) {\n\n    case NGX_OK:\n        ngx_http_set_ctx(r, ctx, ngx_http_range_body_filter_module);\n\n        r->headers_out.status = NGX_HTTP_PARTIAL_CONTENT;\n        r->headers_out.status_line.len = 0;\n\n        if (ctx->ranges.nelts == 1) {\n            return ngx_http_range_singlepart_header(r, ctx);\n        }\n\n        return ngx_http_range_multipart_header(r, ctx);\n\n    case NGX_HTTP_RANGE_NOT_SATISFIABLE:\n        return ngx_http_range_not_satisfiable(r);\n\n    case NGX_ERROR:\n        return NGX_ERROR;\n\n    default: /* NGX_DECLINED */\n        break;\n}', 'explanation': 'After successfully parsing the range header, this switch-case sets the response status to 206 (Partial Content) and calls the appropriate function to generate either a single-part or a multipart header, fully implementing the RFC’s action of returning partial representations when satisfiable.'}}, {'A2': {'code': 'r->headers_out.accept_ranges = ngx_list_push(&r->headers_out.headers);\nif (r->headers_out.accept_ranges == NULL) {\n    return NGX_ERROR;\n}\nr->headers_out.accept_ranges->hash = 1;\nr->headers_out.accept_ranges->next = NULL;\nngx_str_set(&r->headers_out.accept_ranges->key, ""Accept-Ranges"");\nngx_str_set(&r->headers_out.accept_ranges->value, ""bytes"");', 'explanation': 'When the range request is not processed (for example, if the Range header is missing or invalid), this fragment ensures that the Accept-Ranges header is set. This informs the client that the resource supports range requests, aligning with part of the RFC’s intent.'}}]","The function inspects various preconditions such as HTTP version, response status, content length, and range support (C1). It then validates the Range header to ensure that it adheres to the expected format (C2) and, if present, correctly processes the If-Range header by comparing it to either the ETag or last modified timestamp (C3). Upon successful validation and parsing of the Range header, it sets the response status to 206 (Partial Content) and selects the appropriate header-building function to return a partial response (A1). Additionally, if the range request is bypassed, it still advertises support for byte ranges by setting the Accept-Ranges header (A2). All these conditions and actions contained directly within the function align with the specified RFC requirements, thus the code fully implements the spec constraints as required.",success,
2897,ngx_http_range_header_filter,A recipient of an If-Range header field MUST ignore the Range header field if the If-Range condition evaluates to false.,122,Fully Matches,"[{'C1': {'code': 'if (if_range->len >= 2 && if_range->data[if_range->len - 1] == \'""\') {\n    if (r->headers_out.etag == NULL) {\n        goto next_filter;\n    }\n    etag = &r->headers_out.etag->value;\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   ""http ir:%V etag:%V"", if_range, etag);\n    if (if_range->len != etag->len\n        || ngx_strncmp(if_range->data, etag->data, etag->len) != 0)\n    {\n        goto next_filter;\n    }\n    goto parse;\n}', 'explanation': ""This segment performs the strong comparison of the If-Range header interpreted as an entity-tag against the response's ETag. If they do not match—i.e. if the comparison evaluates to false—it jumps to next_filter, thereby ignoring the Range header as required by the spec.""}}, {'C2': {'code': 'if (r->headers_in.if_range) {\n    ...\n    if (r->headers_out.last_modified_time == (time_t) -1) {\n        goto next_filter;\n    }\n    if_range_time = ngx_parse_http_time(if_range->data, if_range->len);\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   ""http ir:%T lm:%T"",\n                   if_range_time, r->headers_out.last_modified_time);\n    if (if_range_time != r->headers_out.last_modified_time) {\n        goto next_filter;\n    }\n}\n', 'explanation': ""This code handles the case when the If-Range header is an HTTP-date (not an entity-tag). It parses the date and compares it with the response's last_modified_time. If they do not exactly match, it jumps to next_filter, effectively ignoring the Range header per the RFC.""}}, {'A1': {'code': 'goto next_filter;\n...\nnext_filter:\n\nr->headers_out.accept_ranges = ngx_list_push(&r->headers_out.headers);\nif (r->headers_out.accept_ranges == NULL) {\n    return NGX_ERROR;\n}\nr->headers_out.accept_ranges->hash = 1;\nr->headers_out.accept_ranges->next = NULL;\nngx_str_set(&r->headers_out.accept_ranges->key, ""Accept-Ranges"");\nngx_str_set(&r->headers_out.accept_ranges->value, ""bytes"");\n\nreturn ngx_http_next_header_filter(r);', 'explanation': ""Whenever the If-Range condition fails (either due to entity-tag mismatch or HTTP-date inequality), the function jumps to 'next_filter'. Here, it does not process the Range header and instead sets the Accept-Ranges header before moving on, which aligns with the RFC requirement to ignore the Range header when the If-Range condition evaluates to false.""}}]","The function first checks if an If-Range header is present and determines its validator type. If the header represents an entity-tag, it performs a strong comparison with the current ETag. For an HTTP-date validator, it parses the date and compares it with the resource's last_modified_time. In both cases, if there is a mismatch (i.e., the condition evaluates to false), the function jumps to the next_filter label, thereby bypassing range parsing and effectively ignoring the Range header field as mandated by the RFC. Thus, the code within this function fully addresses the specified RFC requirements.",success,
2897,ngx_http_range_header_filter,An origin server MUST ignore an If-Range header field received in a request for a target resource that does not support Range requests.,120,Fully Matches,"[{'C1': {'code': 'if (r->http_version < NGX_HTTP_VERSION_10\n    || r->headers_out.status != NGX_HTTP_OK\n    || (r != r->main && !r->subrequest_ranges)\n    || r->headers_out.content_length_n == -1\n    || !r->allow_ranges)\n{\n    return ngx_http_next_header_filter(r);\n}', 'explanation': 'This check ensures that if the target resource does not support range requests (i.e. !r->allow_ranges is true), the function bypasses further processing, effectively ignoring any If-Range header in the request as mandated by the RFC.'}}, {'A1': {'code': 'if (r->headers_in.range == NULL\n    || r->headers_in.range->value.len < 7\n    || ngx_strncasecmp(r->headers_in.range->value.data, (u_char *) ""bytes="", 6) != 0)\n{\n    goto next_filter;\n}', 'explanation': 'This segment reinforces that if there is no Range header, the If-Range header is not processed, in accordance with the RFC requirement for ignoring If-Range when ranges are not applicable.'}}]","The function checks early whether the response is eligible for range processing by verifying conditions such as the HTTP version, status code, and especially whether the resource supports Range requests (via the r->allow_ranges flag). If the resource does not support ranges, the function bypasses further processing, thereby ignoring the If-Range header as required by the RFC. Additional checks ensure that if no Range header is provided, the If-Range header is ignored. These implementations within the function_body fully address the specified conditions and actions of the RFC.",success,
2897,ngx_http_range_header_filter,"A server MUST NOT generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses.",288,Fully Matches,"[{'C1': {'code': 'if (ctx->ranges.nelts == 1) {\n    return ngx_http_range_singlepart_header(r, ctx);\n}\n\nreturn ngx_http_range_multipart_header(r, ctx);', 'explanation': 'This segment ensures that when exactly one range is present, the function returns a single-part header response instead of a multipart response. This directly enforces the RFC requirement that a server MUST NOT generate a multipart response for a single range request.'}}]","The function inspects the number of satisfiable ranges (ctx->ranges.nelts) after parsing and distinguishes between a single range and multiple ranges. If only one range is found, it calls ngx_http_range_singlepart_header to create a non-multipart response. This addresses the key RFC specification, fulfilling the requirement within the function itself without relying on dependencies.",success,
2897,ngx_http_range_header_filter,"If all of the preconditions are true, the server supports the Range header field for the target resource, the received Range field-value contains a valid ranges-specifier, and either the range-unit is not supported for that target resource or the ranges-specifier is unsatisfiable with respect to the selected representation, the server SHOULD send a 416 (Range Not Satisfiable) response.",132,Partially Matches,"[{'A1': {'code': '    switch (ngx_http_range_parse(r, ctx, ranges)) {\n\n    case NGX_OK:\n        ngx_http_set_ctx(r, ctx, ngx_http_range_body_filter_module);\n\n        r->headers_out.status = NGX_HTTP_PARTIAL_CONTENT;\n        r->headers_out.status_line.len = 0;\n\n        if (ctx->ranges.nelts == 1) {\n            return ngx_http_range_singlepart_header(r, ctx);\n        }\n\n        return ngx_http_range_multipart_header(r, ctx);\n\n    case NGX_HTTP_RANGE_NOT_SATISFIABLE:\n        return ngx_http_range_not_satisfiable(r);', 'explanation': 'This segment of code detects when the range specifier is unsatisfiable (or the range-unit is not supported, via logic within ngx_http_range_parse) and returns a 416 response (handled in ngx_http_range_not_satisfiable). This directly addresses the RFC requirement to send a 416 (Range Not Satisfiable) response in this case.'}}]","The function inspects several preconditions (HTTP version, response status, content length, allow_ranges flag, etc.) and then processes the Range header when present. It delegates the parsing of the range to ngx_http_range_parse, and in the event that the returned value is NGX_HTTP_RANGE_NOT_SATISFIABLE, it explicitly calls ngx_http_range_not_satisfiable(r) to generate a 416 response. This satisfies one of the key actions (A1) from the RFC. However, while some precondition checks are performed, the function does not explicitly separate checks for a supported range-unit versus an unsatisfiable ranges-specifier (these details seem to be abstracted into the parser). As a result, only some of the labeled spec conditions and actions are visibly implemented in this function, leading to a 'Partially Matches' judgment.",success,
2897,ngx_http_range_header_filter,An origin server without a clock MUST NOT generate a Last-Modified date for a response unless that date value was assigned to the resource by some other system (presumably one with a clock).,55,Does Not Match,[],"The code function is focused on processing and filtering HTTP Range headers, including handling the If-Range header and comparing it with the resource's ETag or Last-Modified time. It does not contain any logic that generates a Last-Modified date or conditions related to an origin server without a clock as specified. Thus, no part of the function visibly implements the constraint about not generating a Last-Modified date unless the value was assigned externally.",success,
2897,ngx_http_range_header_filter,A server MUST ignore an If-Range header field received in a request that does not contain a Range header field.,119,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.range == NULL\n        || r->headers_in.range->value.len < 7\n        || ngx_strncasecmp(r->headers_in.range->value.data,\n                           (u_char *) ""bytes="", 6) != 0)\n{\n    goto next_filter;\n}', 'explanation': ""This code checks for the presence of a valid Range header. If the Range header is missing or invalid, the function bypasses any processing of the If-Range header (by jumping to 'next_filter'), thereby effectively ignoring the If-Range header in accordance with the RFC specification.""}}]","The function correctly implements the RFC requirement by ensuring that if a Range header is not present, the If-Range header is ignored. All the necessary logic to enforce this is contained within the function itself, fulfilling the spec constraint.",success,
2897,ngx_http_range_header_filter,A server that receives an If-Range header field on a Range request MUST evaluate the condition per Section 13.2 prior to performing the method.,121,Fully Matches,"[{'C1': {'code': 'if (if_range->len >= 2 && if_range->data[if_range->len - 1] == \'""\') {\n    if (r->headers_out.etag == NULL) {\n        goto next_filter;\n    }\n    etag = &r->headers_out.etag->value;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   ""http ir:%V etag:%V"", if_range, etag);\n\n    if (if_range->len != etag->len\n        || ngx_strncmp(if_range->data, etag->data, etag->len) != 0)\n    {\n        goto next_filter;\n    }\n\n    goto parse;\n}', 'explanation': ""This section of the code handles the case when the If-Range header contains an entity tag (identified by ending with a double quote). It compares the provided tag with the response's ETag. If they match, it continues with range processing, which fulfills the RFC requirement to evaluate the condition.""}}, {'C2': {'code': 'if (r->headers_out.last_modified_time == (time_t) -1) {\n    goto next_filter;\n}\n\nif_range_time = ngx_parse_http_time(if_range->data, if_range->len);\n\nngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n               ""http ir:%T lm:%T"",\n               if_range_time, r->headers_out.last_modified_time);\n\nif (if_range_time != r->headers_out.last_modified_time) {\n    goto next_filter;\n}', 'explanation': ""This segment covers evaluation when the If-Range header is a HTTP-date. After ensuring that a Last-Modified value is available, it parses the date from the If-Range header and compares it to the response's Last-Modified time. If they match exactly, the condition is true. This aligns with the RFC requirement for date validation.""}}]","The function 'ngx_http_range_header_filter' inspects the presence of an If-Range header in a Range request and performs the necessary validations as described in the RFC. It distinguishes between cases where the header contains an entity tag (by checking for a trailing double quote) and where it provides an HTTP-date. In the entity tag case (C1), the function compares the provided tag against the response's ETag. In the HTTP-date case (C2), it parses and compares the date against the Last-Modified time. These checks ensure that the condition mandated by the RFC is evaluated before any range processing is performed. All logic is self-contained within the function, thereby fully matching the specified constraints.",success,
2897,ngx_http_range_header_filter,"Otherwise, the recipient SHOULD process the Range header field as requested.",123,Fully Matches,"[{'C1': {'code': 'if (if_range->len >= 2 && if_range->data[if_range->len - 1] == \'""\') {\n    if (r->headers_out.etag == NULL) {\n        goto next_filter;\n    }\n\n    etag = &r->headers_out.etag->value;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   ""http ir:%V etag:%V"", if_range, etag);\n\n    if (if_range->len != etag->len\n        || ngx_strncmp(if_range->data, etag->data, etag->len) != 0)\n    {\n        goto next_filter;\n    }\n\n    goto parse;\n}', 'explanation': 'This segment implements the strong entity-tag comparison required by the RFC. It checks that the If-Range header, when formatted as an entity-tag, exactly matches the ETag from the response. If not, the range header is ignored.'}}, {'C2': {'code': 'if (r->headers_in.if_range) {\n    ...\n    if (r->headers_out.last_modified_time == (time_t) -1) {\n        goto next_filter;\n    }\n\n    if_range_time = ngx_parse_http_time(if_range->data, if_range->len);\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   ""http ir:%T lm:%T"",\n                   if_range_time, r->headers_out.last_modified_time);\n\n    if (if_range_time != r->headers_out.last_modified_time) {\n        goto next_filter;\n    }\n}', 'explanation': ""This code deals with the scenario when the If-Range header contains an HTTP-date. It parses the date and compares it with the resource's last modified time. A mismatch causes the Range header to be ignored, as specified by the RFC.""}}, {'A1': {'code': 'parse:\n\nctx = ngx_pcalloc(r->pool, sizeof(ngx_http_range_filter_ctx_t));\nif (ctx == NULL) {\n    return NGX_ERROR;\n}\n\nctx->offset = r->headers_out.content_offset;\n\nranges = r->single_range ? 1 : clcf->max_ranges;\n\nswitch (ngx_http_range_parse(r, ctx, ranges)) {\n\ncase NGX_OK:\n    ngx_http_set_ctx(r, ctx, ngx_http_range_body_filter_module);\n\n    r->headers_out.status = NGX_HTTP_PARTIAL_CONTENT;\n    r->headers_out.status_line.len = 0;\n\n    if (ctx->ranges.nelts == 1) {\n        return ngx_http_range_singlepart_header(r, ctx);\n    }\n\n    return ngx_http_range_multipart_header(r, ctx);\n\ncase NGX_HTTP_RANGE_NOT_SATISFIABLE:\n    return ngx_http_range_not_satisfiable(r);\n\ncase NGX_ERROR:\n    return NGX_ERROR;\n\ndefault: /* NGX_DECLINED */\n    break;\n}', 'explanation': 'When the If-Range conditions are met, the function proceeds to parse the Range header. It sets up the context, processes the range(s), and ultimately sets the response to partial content, fulfilling the action indicated by the spec.'}}]","The function ngx_http_range_header_filter contains explicit logic for handling an If-Range header. It conducts a strong comparison when the header is formatted as an ETag (C1) and uses the HTTP-date comparison when applicable (C2). If either comparison fails, the Range header is ignored. When the conditions are met, the function processes the Range header as requested and sets the appropriate HTTP status (A1). This behavior directly implements the relevant RFC specification regarding the handling of the Range header in the presence of an If-Range header.",success,
2897,ngx_http_range_header_filter,A server MAY ignore the Range header field.,126,Fully Matches,"[{'C1': {'code': 'if (r->http_version < NGX_HTTP_VERSION_10\n    || r->headers_out.status != NGX_HTTP_OK\n    || (r != r->main && !r->subrequest_ranges)\n    || r->headers_out.content_length_n == -1\n    || !r->allow_ranges)\n{\n    return ngx_http_next_header_filter(r);\n}', 'explanation': 'This segment checks various conditions (HTTP version, status, content length, and a flag indicating if range operations are allowed) and promptly bypasses range handling by calling the next header filter, effectively ignoring the Range header when conditions are not met.'}}, {'A1': {'code': 'r->headers_out.accept_ranges = ngx_list_push(&r->headers_out.headers);\nif (r->headers_out.accept_ranges == NULL) {\n    return NGX_ERROR;\n}\nr->headers_out.accept_ranges->hash = 1;\nr->headers_out.accept_ranges->next = NULL;\nngx_str_set(&r->headers_out.accept_ranges->key, ""Accept-Ranges"");\nngx_str_set(&r->headers_out.accept_ranges->value, ""bytes"");', 'explanation': ""This segment adds the 'Accept-Ranges: bytes' header to the outgoing response, which is consistent with the behavior required by the RFC (i.e. supporting byte ranges or effectively ignoring the Range header if no proper subrange processing is possible).""}}]","The function inspects the request for conditions under which range processing is meaningful. If the conditions are not met (for example, the HTTP version is too old, the status is not OK, or there is no valid content length), it does not attempt to process the Range header and instead delegates processing to the next header filter. Additionally, it sets the 'Accept-Ranges: bytes' header when appropriate. These implementations within the function clearly show the intent to either process or ignore the Range header in accordance with the specification that 'A server MAY ignore the Range header field.' Hence, the function fully meets the constraints as required by the spec.",success,
2897,ngx_http_range_header_filter,"Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method.",282,Partially Matches,"[{'C1': {'code': 'if (r->http_version < NGX_HTTP_VERSION_10\n    || r->headers_out.status != NGX_HTTP_OK\n    || (r != r->main && !r->subrequest_ranges)\n    || r->headers_out.content_length_n == -1\n    || !r->allow_ranges)\n{\n    return ngx_http_next_header_filter(r);\n}', 'explanation': ""This segment ensures that range processing (which involves evaluating the 'If-Range' precondition) is only attempted after the request has passed normal checks (e.g., HTTP version, response status, and presence of proper content length). This corresponds to the spec’s directive to evaluate preconditions only after the normal request checks have succeeded.""}}, {'A1': {'code': 'if (r->headers_in.if_range) {\n    if_range = &r->headers_in.if_range->value;\n\n    if (if_range->len >= 2 && if_range->data[if_range->len - 1] == \'""\') {\n\n        if (r->headers_out.etag == NULL) {\n            goto next_filter;\n        }\n\n        etag = &r->headers_out.etag->value;\n\n        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       ""http ir:%V etag:%V"", if_range, etag);\n\n        if (if_range->len != etag->len\n            || ngx_strncmp(if_range->data, etag->data, etag->len) != 0)\n        {\n            goto next_filter;\n        }\n\n        goto parse;\n    }\n\n    if (r->headers_out.last_modified_time == (time_t) -1) {\n        goto next_filter;\n    }\n\n    if_range_time = ngx_parse_http_time(if_range->data, if_range->len);\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   ""http ir:%T lm:%T"",\n                   if_range_time, r->headers_out.last_modified_time);\n\n    if (if_range_time != r->headers_out.last_modified_time) {\n        goto next_filter;\n    }\n}', 'explanation': ""This block directly implements the evaluation of the 'If-Range' header: if the header appears to be an ETag (ends with a double-quote), it compares it to the response's ETag; otherwise it parses and compares the modification time. This conditional checking is in line with the RFC requirement regarding processing preconditions just before handling the content.""}}]","The function 'ngx_http_range_header_filter' contains logic that partially implements the HTTP RFC's requirements for processing request preconditions. It first checks that normal request conditions are met (e.g. valid HTTP version, status code OK, valid content length, and allowance for ranges), which aligns with the spec’s requirement to perform normal checks before evaluating preconditions (labeled here as C1). It then proceeds to evaluate the 'If-Range' header against either an ETag or a Last-Modified time (labeled here as A1). However, only the logic related to range processing preconditions is addressed. Other preconditions mentioned in the full RFC context are either handled elsewhere or not visible in this function, so the match is partial.",success,
2897,ngx_http_range_header_filter,An origin server MUST ignore a Range header field that contains a range unit it does not understand.,128,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.range == NULL\n    || r->headers_in.range->value.len < 7\n    || ngx_strncasecmp(r->headers_in.range->value.data, (u_char *) ""bytes="", 6) != 0)\n{\n    goto next_filter;\n}', 'explanation': ""This code checks whether the Range header exists, ensures that its length is at least 7 characters, and confirms that it begins with 'bytes='. If the header does not meet these criteria (i.e., it contains a range unit that is not recognized), the function bypasses any range processing, thereby ignoring the header as required by the RFC.""}}]","The function implements the RFC specification by verifying that the Range header contains a known range unit ('bytes='). If the header does not meet this condition, it is effectively ignored, which fully addresses the constraint stated in the specification.",success,
2898,ngx_http_range_parse,"If all of the preconditions are true, the server supports the Range header field for the target resource, the received Range field-value contains a valid ranges-specifier, and either the range-unit is not supported for that target resource or the ranges-specifier is unsatisfiable with respect to the selected representation, the server SHOULD send a 416 (Range Not Satisfiable) response.",132,Partially Matches,"[{'C1': {'code': ""if (*p < '0' || *p > '9') {\n    return NGX_HTTP_RANGE_NOT_SATISFIABLE;\n}\n\nwhile (*p >= '0' && *p <= '9') {\n    if (start >= cutoff && (start > cutoff || *p - '0' > cutlim)) {\n        return NGX_HTTP_RANGE_NOT_SATISFIABLE;\n    }\n    start = start * 10 + (*p++ - '0');\n}\n\n...\n\nif (ctx->ranges.nelts == 0) {\n    return NGX_HTTP_RANGE_NOT_SATISFIABLE;\n}"", 'explanation': ""This segment checks that the Range header value contains expected numeric digits and that the computed start/end values are within bounds. It returns NGX_HTTP_RANGE_NOT_SATISFIABLE when the ranges-specifier is invalid or unsatisfiable, addressing the RFC's requirement to respond with 416 for invalid ranges.""}}, {'A1': {'code': 'return NGX_HTTP_RANGE_NOT_SATISFIABLE;', 'explanation': 'Throughout the function, when certain error conditions are met (e.g., malformed range, overflow, or unsatisfiability), the function returns NGX_HTTP_RANGE_NOT_SATISFIABLE, thereby attempting to implement the action of sending a 416 (Range Not Satisfiable) response as required.'}}]","The function parses the Range header, validates the range-specifier, and returns a ""416 (Range Not Satisfiable)"" result when the range is malformed or unsatisfiable, which corresponds to the RFC requirement for such cases. However, while it handles many error cases on the rangespec and returns the appropriate status code, it does not fully cover all preconditions noted in the spec (e.g., verifying support for the range-unit or handling partial range responses in all scenarios). Therefore, the implementation only partially matches the RFC's requirements.",success,
2899,ngx_http_range_singlepart_header,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The RFC specifies that a sender must not forward a message with a Content-Length header field value known to be incorrect, including considerations such as repeated values or non-matching ABNF. In the function_body, while there is logic to remove any existing Content-Length header (e.g., by setting r->headers_out.content_length->hash = 0 and r->headers_out.content_length = NULL), there is no explicit verification of the Content-Length value against the RFC requirements. The function recalculates a new content length for the Content-Range header, but it does not check for incorrect or repeated Content-Length values as described in the RFC. Therefore, no specific labeled condition or action (for example, a condition to detect an incorrect Content-Length value or an action to reject/replace it) is fully implemented within this function.",success,
2899,ngx_http_range_singlepart_header,"If a single part is being transferred, the server generating the 206 response MUST generate a Content-Range header field, describing what range of the selected representation is enclosed, and a content consisting of the range.",146,Fully Matches,"[{'C1': {'code': 'if (r != r->main) {\n    return ngx_http_next_header_filter(r);\n}', 'explanation': 'Ensures that the header generation process applies only to the main request, which is consistent with handling a single-part 206 response.'}}, {'A1': {'code': 'ngx_str_set(&content_range->key, ""Content-Range"");\n\ncontent_range->value.data = ngx_pnalloc(r->pool,\n                                    sizeof(""bytes -/"") - 1 + 3 * NGX_OFF_T_LEN);\nif (content_range->value.data == NULL) {\n    content_range->hash = 0;\n    r->headers_out.content_range = NULL;\n    return NGX_ERROR;\n}\n\n/* ""Content-Range: bytes SSSS-EEEE/TTTT"" header */\n\nrange = ctx->ranges.elts;\n\ncontent_range->value.len = ngx_sprintf(content_range->value.data,\n                                       ""bytes %O-%O/%O"",\n                                       range->start, range->end - 1,\n                                       r->headers_out.content_length_n)\n                           - content_range->value.data;', 'explanation': 'Allocates and initializes the Content-Range header field with the correct format and values, fulfilling the requirement to describe the transferred range.'}}, {'A2': {'code': 'r->headers_out.content_length_n = range->end - range->start;\nr->headers_out.content_offset = range->start;', 'explanation': 'Adjusts the content length and sets the content offset based on the range values, ensuring the content is correctly represented as the transferred range.'}}]","The function 'ngx_http_range_singlepart_header' directly implements the necessary logic for a single-part 206 response by generating a Content-Range header with the appropriate format and range details, as specified in the HTTP RFC. It also updates the content length and offset accordingly. All these operations are performed within the function, thereby fully matching the specifications provided.",success,
2899,ngx_http_range_singlepart_header,"For byte ranges, a sender SHOULD indicate the complete length of the representation from which the range has been extracted, unless the complete length is unknown or difficult to determine.",287,Partially Matches,"[{'C1': {'code': 'content_range->value.len = ngx_sprintf(content_range->value.data,\n                                           ""bytes %O-%O/%O"",\n                                           range->start, range->end - 1,\n                                           r->headers_out.content_length_n)\n                               - content_range->value.data;', 'explanation': ""This code constructs the Content-Range header in the format 'bytes START-END/TOTAL', thereby including the complete representation length if known. It meets the RFC’s requirement to include the complete length in the header when available.""}}]","The function attempts to implement the RFC requirement for byte ranges by generating a 'Content-Range' header that provides the range and the complete length (using r->headers_out.content_length_n). However, it does not handle the scenario where the complete length is unknown (which should use an asterisk ""*"") nor does it address other aspects (such as ignoring Content-Range for methods where it is undefined) solely within this function. Because only part of the requirement is implemented directly in this function, the overall match is partial.",success,
2900,ngx_http_range_multipart_header,"If multiple parts are being transferred, the server generating the 206 response MUST generate ""multipart/byteranges"" content, as defined in Section 14.6, and a Content-Type header field containing the ""multipart/byteranges"" media type and its required boundary parameter.",147,Fully Matches,"[{'C1': {'code': 'r->headers_out.content_type.data = ngx_pnalloc(r->pool, sizeof(""Content-Type: multipart/byteranges; boundary="") - 1 + NGX_ATOMIC_T_LEN); […]\nr->headers_out.content_type.len = ngx_sprintf(r->headers_out.content_type.data, ""multipart/byteranges; boundary=%0muA"", boundary) - r->headers_out.content_type.data;', 'explanation': ""This segment allocates and sets the overall Content-Type header to 'multipart/byteranges' with the required boundary parameter, directly implementing the RFC requirement for multiple range responses.""}}, {'A1': {'code': 'ctx->boundary_header.data = ngx_pnalloc(r->pool, size); […]\nctx->boundary_header.len = ngx_sprintf(ctx->boundary_header.data, CRLF ""--%0muA"" CRLF ""Content-Type: %V; charset=%V"" CRLF ""Content-Range: bytes "", boundary, &r->headers_out.content_type, &r->headers_out.charset) - ctx->boundary_header.data; […]\nfor (i = 0; i < ctx->ranges.nelts; i++) {\n    range[i].content_range.data = ngx_pnalloc(r->pool, 3 * NGX_OFF_T_LEN + 2 + 4);\n    range[i].content_range.len = ngx_sprintf(range[i].content_range.data, ""%O-%O/%O"" CRLF CRLF, range[i].start, range[i].end - 1, r->headers_out.content_length_n)\n                                 - range[i].content_range.data;\n    […]\n}', 'explanation': 'This code builds each body part by constructing an individual header section that includes the Content-Range. It also creates the boundary separator that prefixes each part. This meets the RFC requirement that each body part in a multipart response must have its own Content-Range header and related boundary formatting.'}}]","The function 'ngx_http_range_multipart_header' directly implements the multipart/byteranges response as specified by the RFC. It allocates and formats a boundary header containing a CRLF, boundary marker, Content-Type, and a preliminary Content-Range field; sets the overall Content-Type header with the 'multipart/byteranges' media type and the boundary parameter; and for each range, it creates a specific Content-Range header. This in-function logic fulfills both the condition (C1) of generating the multipart response header correctly and the associated action (A1) of including and formatting individual Content-Range headers for each body part, thereby fully matching the RFC's requirements.",success,
2900,ngx_http_range_multipart_header,"For byte ranges, a sender SHOULD indicate the complete length of the representation from which the range has been extracted, unless the complete length is unknown or difficult to determine.",287,Fully Matches,"[{'C1': {'code': 'range[i].content_range.len = ngx_sprintf(range[i].content_range.data,\n                                               ""%O-%O/%O"" CRLF CRLF,\n                                               range[i].start, range[i].end - 1,\n                                               r->headers_out.content_length_n)\n                                     - range[i].content_range.data;', 'explanation': ""This code segment builds the Content-Range header for each byte range and includes a numeric value (r->headers_out.content_length_n) after the '/' character. This reflects the RFC requirement for a sender to indicate the complete length of the representation when it is known.""}}]","The function constructs multipart range response headers by embedding headers such as ""Content-Range: bytes ..."" which include the complete length value. This directly addresses the spec requirement that, for byte ranges, a sender SHOULD indicate the complete length of the representation (unless unknown). All of the logic needed to output the complete representation length is present in this function, so it fully matches the relevant RFC constraint.",success,
2900,ngx_http_range_multipart_header,"If the selected representation would have had a Content-Type header field in a 200 (OK) response, the server SHOULD generate that same Content-Type header field in the header area of each body part.",150,Fully Matches,"[{'A1': {'code': 'if (r->headers_out.content_type_len == r->headers_out.content_type.len && r->headers_out.charset.len) {\n    ctx->boundary_header.len = ngx_sprintf(ctx->boundary_header.data,\n                                       CRLF ""--%0muA"" CRLF\n                                       ""Content-Type: %V; charset=%V"" CRLF\n                                       ""Content-Range: bytes "",\n                                       boundary,\n                                       &r->headers_out.content_type,\n                                       &r->headers_out.charset)\n                           - ctx->boundary_header.data;\n} else if (r->headers_out.content_type.len) {\n    ctx->boundary_header.len = ngx_sprintf(ctx->boundary_header.data,\n                                       CRLF ""--%0muA"" CRLF\n                                       ""Content-Type: %V"" CRLF\n                                       ""Content-Range: bytes "",\n                                       boundary,\n                                       &r->headers_out.content_type)\n                           - ctx->boundary_header.data;\n}', 'explanation': 'This code checks if a Content-Type header would have been sent in a 200 OK response, and if so, it generates a corresponding Content-Type header within the boundary header for each body part of the multipart/byteranges response. This directly addresses the spec requirement to include the same Content-Type header field in each body part.'}}]","The function explicitly constructs the multipart response headers by including a Content-Type header in each body part when the original response had one. The implementation uses conditional logic to format the header with or without the charset, ensuring that the header field is replicated. Thus, the function fully implements the corresponding action of the RFC specification.",success,
2900,ngx_http_range_multipart_header,"To avoid confusion with single-part responses, a server MUST NOT generate a Content-Range header field in the HTTP header section of a multiple part response (this field will be sent in each part instead).",148,Fully Matches,"[{'C1': {'code': 'if (r->headers_out.content_range) {\n        r->headers_out.content_range->hash = 0;\n        r->headers_out.content_range = NULL;\n    }', 'explanation': 'This code segment explicitly removes any global Content-Range header from the HTTP response, ensuring that it is not present in the header section for multipart responses, as required by the RFC.'}}, {'A1': {'code': 'range[i].content_range.len = ngx_sprintf(range[i].content_range.data,\n                                               ""%O-%O/%O"" CRLF CRLF,\n                                               range[i].start, range[i].end - 1,\n                                               r->headers_out.content_length_n)\n                                     - range[i].content_range.data;', 'explanation': 'This segment generates a per-part Content-Range header for each body part, aligning with the requirement that each part of a multipart response should include its own Content-Range header.'}}]","The function constructs a multipart response by creating a boundary header that includes the 'Content-Range: bytes ' field within each part, while also setting the overall Content-Type header to 'multipart/byteranges'. Importantly, it removes any global Content-Range header from the HTTP header (as shown in the code removing r->headers_out.content_range), thereby directly addressing the RFC requirement to avoid confusion with single-part responses. Thus, within its scope, the function fully implements the specified conditions and actions from the spec.",success,
2900,ngx_http_range_multipart_header,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,36,Fully Matches,"[{'C1': {'code': 'ngx_sprintf(ctx->boundary_header.data, CRLF ""--%0muA"" CRLF ""Content-Type: %V; charset=%V"" CRLF ""Content-Range: bytes "", boundary, &r->headers_out.content_type, &r->headers_out.charset)\n\nngx_sprintf(ctx->boundary_header.data, CRLF ""--%0muA"" CRLF ""Content-Type: %V"" CRLF ""Content-Range: bytes "", boundary, &r->headers_out.content_type)\n\nngx_sprintf(ctx->boundary_header.data, CRLF ""--%0muA"" CRLF ""Content-Range: bytes "", boundary)', 'explanation': 'The function explicitly uses the CRLF sequence in all its formatted strings for the multipart boundary header. This matches the RFC requirement that only CRLF may be used to represent line breaks between body parts.'}}]","The code function generates the multipart boundary header and range part strings using CRLF for all line breaks. By consistently employing CRLF in its output (as shown in its ngx_sprintf calls), it directly adheres to the RFC specification that mandates exclusively CRLF as the line break representation within the message body.",success,
2900,ngx_http_range_multipart_header,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'C1': {'code': 'if (r->headers_out.content_length) {\n    r->headers_out.content_length->hash = 0;\n    r->headers_out.content_length = NULL;\n}\n\nif (r->headers_out.content_range) {\n    r->headers_out.content_range->hash = 0;\n    r->headers_out.content_range = NULL;\n}', 'explanation': 'This code block clears preexisting Content-Length and Content-Range headers so that the response does not output multiple field lines with the same name. It implements, by itself, the RFC requirement to avoid generating duplicate header fields.'}}]","The function assembles a multipart byteranges response and specifically ensures that existing Content-Length and Content-Range headers are removed before sending the response. This action directly addresses the RFC requirement (labeled as C1) that a sender MUST NOT generate multiple header field lines with the same name. However, the function does not handle other facets of the RFC such as managing the order of multiple header lines (when allowed) or handling cases where the specification permits a comma‐separated list. As such, it partially meets the constraints specified in the RFC.",success,
2900,ngx_http_range_multipart_header,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'if (r->headers_out.content_type.len) {\n    ctx->boundary_header.len = ngx_sprintf(ctx->boundary_header.data,\n                                       CRLF ""--%0muA"" CRLF\n                                       ""Content-Type: %V"" CRLF\n                                       ""Content-Range: bytes "",\n                                       boundary,\n                                       &r->headers_out.content_type)\n                               - ctx->boundary_header.data;\n}\n...\n\nr->headers_out.content_type.data = ngx_pnalloc(r->pool,\n                    sizeof(""Content-Type: multipart/byteranges; boundary="") - 1\n                    + NGX_ATOMIC_T_LEN);\nif (r->headers_out.content_type.data == NULL) {\n    return NGX_ERROR;\n}\n\nr->headers_out.content_type.len = ngx_sprintf(r->headers_out.content_type.data,\n                                       ""multipart/byteranges; boundary=%0muA"",\n                                       boundary)\n                           - r->headers_out.content_type.data;\n\nr->headers_out.content_type_len = r->headers_out.content_type.len;', 'explanation': ""The function explicitly checks if a known Content-Type is available (and further adds charset if available) in the boundary header, and then it allocates and sets the final Content-Type header to 'multipart/byteranges; boundary=...'. This matches the RFC specification that a Content-Type header must be generated when the media type is known.""}}]","The function ngx_http_range_multipart_header constructs a proper Content-Type header for a multipart/byteranges response by verifying the presence of a known media type and including the charset when available. This logic directly addresses the specification requirement that a sender generating a message with content should include a Content-Type header unless the media type is unknown. All relevant actions are handled within this function itself, thereby fully matching the spec constraints.",success,
2900,ngx_http_range_multipart_header,"Within the header area of each body part in the multipart content, the server MUST generate a Content-Range header field corresponding to the range being enclosed in that body part.",149,Fully Matches,"[{'C1': {'code': 'CRLF ""--%0muA"" CRLF\n""Content-Type: %V; charset=%V"" CRLF\n""Content-Range: bytes ""\n\nand\n\nCRLF ""--%0muA"" CRLF\n""Content-Type: %V"" CRLF\n""Content-Range: bytes ""', 'explanation': ""These sprintf calls construct the header for each body part in the multipart response. They embed the literal 'Content-Range: bytes ' string in the boundary header, thereby addressing the requirement to generate a Content-Range header field corresponding to the enclosed range.""}}, {'A1': {'code': 'range[i].content_range.len = ngx_sprintf(range[i].content_range.data,\n                                               ""%O-%O/%O"" CRLF CRLF,\n                                               range[i].start, range[i].end - 1,\n                                               r->headers_out.content_length_n)\n                                     - range[i].content_range.data;', 'explanation': 'This code allocates and formats the specific byte range (start-end/total) for each part. It appends the CRLF terminators, effectively finalizing the Content-Range header field for that body part.'}}]","The function 'ngx_http_range_multipart_header' sets the overall Content-Type header to 'multipart/byteranges' with the required boundary parameter and constructs the header sections for each body part. This includes embedding the 'Content-Range: bytes ' literal in the boundary header and then, for each range, appending the formatted range details. Thus, the function fully implements the RFC requirement to generate a Content-Range header field in the header area of each multipart body part.",success,
2900,ngx_http_range_multipart_header,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The provided function is concerned with constructing a multipart/byteranges response by calculating and assigning a new content length (via r->headers_out.content_length_n) and by removing the original Content-Length and Content-Range header fields. However, it does not include any logic to validate or verify that an incoming Content-Length header field is correct or adheres to the ABNF specified by the RFC. In other words, there is no code that checks if the Content-Length is known to be incorrect or that handles the exception for a repeated decimal value. Since the spec requires that a sender MUST NOT forward a message with a Content-Length header field value which is known to be incorrect, and this function does not address that condition within its implementation, it does not meet the given spec constraints.",success,
2902,ngx_http_range_not_satisfiable,"A server generating a 416 (Range Not Satisfiable) response to a byte-range request SHOULD send a Content-Range header field with an unsatisfied-range value, as in the following example:",137,Fully Matches,"[{'C1': {'code': 'r->headers_out.status = NGX_HTTP_RANGE_NOT_SATISFIABLE;', 'explanation': 'This line sets the status code to 416 (Range Not Satisfiable), satisfying the RFC requirement for generating such a response.'}}, {'A1': {'code': 'ngx_str_set(&content_range->key, ""Content-Range"");\n\n...\n\ncontent_range->value.len = ngx_sprintf(content_range->value.data, ""bytes */%O"", r->headers_out.content_length_n) - content_range->value.data;', 'explanation': ""These code segments create and set the Content-Range header with the unsatisfied-range value (i.e. 'bytes */<length>'), directly implementing the RFC recommendation.""}}]","The function explicitly sets the response status to 416 and constructs a valid Content-Range header with the unsatisfied range format ('bytes */<complete-length>'). This is in full accordance with the specified HTTP RFC requirements, and the implementation is self-contained within the function.",success,
2902,ngx_http_range_not_satisfiable,"A server MUST NOT generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses.",288,Does Not Match,[],"The provided function, ngx_http_range_not_satisfiable, solely handles the generation of a 416 Range Not Satisfiable response with a single 'Content-Range' header. It does not check for or implement any logic regarding multiple ranges or the prevention of a multipart response, as specified in the RFC requirement. As such, there is no code within this function that addresses the condition that a server MUST NOT generate a multipart response for a single range, and therefore it does not fulfill the spec constraint.",success,
2902,ngx_http_range_not_satisfiable,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'A1': {'code': 'ngx_http_clear_content_length(r);', 'explanation': 'This call explicitly clears any Content-Length header from the response before sending it. By doing so, the function ensures that no Content-Length header is sent, which is compliant with the RFC requirement that a Content-Length header MUST NOT be present if a Transfer-Encoding header field exists.'}}]","The function ngx_http_range_not_satisfiable constructs a Content-Range header for a 416 (Range Not Satisfiable) response and ends by calling ngx_http_clear_content_length(r). This final step removes any Content-Length header that may have been set earlier, thus satisfying the RFC constraint that a sender must not send a Content-Length header field if a Transfer-Encoding header field is present. Although the function does not explicitly check for the presence of a Transfer-Encoding header, it unconditionally clears the Content-Length header, which fully implements the required behavior within this function’s scope.",success,
2902,ngx_http_range_not_satisfiable,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Fully Matches,"[{'A1': {'code': 'ngx_http_clear_content_length(r);', 'explanation': 'According to the RFC, a server must not send a Content-Length header in cases where it is not allowed. In this function, regardless of the fact that the status code here is 416 (Range Not Satisfiable), the call to ngx_http_clear_content_length(r) ensures that any previously set Content-Length header is removed. This direct removal fulfills the action of not sending a Content-Length header as mandated by the spec.'}}]","The provided function is responsible for issuing a 416 (Range Not Satisfiable) response and attaches a Content-Range header, as required by the HTTP specification for such responses. Even though the RFC requirement explicitly mentions responses with status codes 1xx or 204, the broader principle is to avoid sending a Content-Length header when not appropriate. The function achieves this by calling ngx_http_clear_content_length(r), which clears any Content-Length header that might have been set earlier. This logic is self-contained within the function, and therefore it fully addresses the specified constraint.",success,
2902,ngx_http_range_not_satisfiable,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'C1': {'code': 'if (r->headers_out.content_range) {\n    r->headers_out.content_range->hash = 0;\n}\nr->headers_out.content_range = content_range;', 'explanation': 'This code checks if a Content-Range header already exists. If it does, it disables the previous header (by setting its hash to 0) and then assigns the newly created header to r->headers_out.content_range. In effect, this prevents the generation of multiple Content-Range header lines, addressing the RFC requirement that a sender MUST NOT generate multiple header fields with the same name unless they are allowed to be merged.'}}]","The function partially implements the RFC requirement by ensuring that only one Content-Range header is active. By checking for an existing Content-Range header and invalidating it before setting a new one, the function avoids generating multiple header lines for 'Content-Range'. However, it does not address other aspects of the specification—such as preserving the order of header field lines when multiple fields might be concatenated—and thus only partially meets the overall RFC constraints.",success,
2902,ngx_http_range_not_satisfiable,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'ngx_str_set(&content_range->key, ""Content-Range"");\n\ncontent_range->value.len = ngx_sprintf(content_range->value.data, ""bytes */%O"", r->headers_out.content_length_n) - content_range->value.data;', 'explanation': ""This code explicitly constructs the 'Content-Range' header using a fixed literal 'bytes */' combined with the content length, ensuring that the generated header value conforms to the ABNF grammar specified by the HTTP RFC.""}}]","The function sets the HTTP status and constructs the 'Content-Range' header in a manner that adheres to the specified HTTP grammar. By explicitly formatting the header with the correct literal and numerical content, it ensures that only valid protocol elements are generated. Thus, within the confines of this function, the RFC requirement is fully met.",success,
2902,ngx_http_range_not_satisfiable,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Fully Matches,"[{'A1': {'code': 'ngx_http_clear_content_length(r);', 'explanation': 'This function call explicitly clears any Content-Length header that might have been set, ensuring that an incorrect Content-Length value is not forwarded. This directly implements the RFC requirement that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.'}}]","The function constructs a 'Content-Range' header for a 416 (Range Not Satisfiable) response and then calls ngx_http_clear_content_length(r) to remove any existing Content-Length header. By doing so, it prevents the propagation of an incorrect Content-Length value as required by the RFC. This logic, contained entirely within the function_body, directly addresses the specification without relying on external dependencies.",success,
2902,ngx_http_range_not_satisfiable,"For byte ranges, a sender SHOULD indicate the complete length of the representation from which the range has been extracted, unless the complete length is unknown or difficult to determine.",287,Fully Matches,"[{'C1': {'code': 'content_range->value.len = ngx_sprintf(content_range->value.data,\n                                           ""bytes */%O"",\n                                           r->headers_out.content_length_n) - content_range->value.data;', 'explanation': 'This code constructs the Content-Range header in the format ""bytes */<complete length>"" using r->headers_out.content_length_n, thereby indicating the complete length of the representation as required by the RFC.'}}]","The function solely generates an HTTP 416 (Range Not Satisfiable) response and explicitly builds a 'Content-Range' header that includes the total length of the representation. This directly addresses the RFC specification which advises that a sender SHOULD indicate the complete length (when known) in the Content-Range header. All relevant logic is implemented directly within this function, satisfying the spec constraint.",success,
2902,ngx_http_range_not_satisfiable,A server that generates a 416 response to a byte-range request SHOULD generate a Content-Range header field specifying the current length of the selected representation (Section 14.4).,166,Fully Matches,"[{'C1': {'code': 'r->headers_out.status = NGX_HTTP_RANGE_NOT_SATISFIABLE;\n\ncontent_range = ngx_list_push(&r->headers_out.headers);\nif (content_range == NULL) {\n    return NGX_ERROR;\n}\n\nif (r->headers_out.content_range) {\n    r->headers_out.content_range->hash = 0;\n}\n\nr->headers_out.content_range = content_range;\n\ncontent_range->hash = 1;\ncontent_range->next = NULL;\nngx_str_set(&content_range->key, ""Content-Range"");', 'explanation': ""This part of the code sets the response status to 416 and ensures that a 'Content-Range' header is created and attached to the response, directly addressing the RFC requirement to generate the header when responding with a 416 status.""}}, {'A1': {'code': 'content_range->value.data = ngx_pnalloc(r->pool,\n                                  sizeof(""bytes */"") - 1 + NGX_OFF_T_LEN);\nif (content_range->value.data == NULL) {\n    content_range->hash = 0;\n    r->headers_out.content_range = NULL;\n    return NGX_ERROR;\n}\n\ncontent_range->value.len = ngx_sprintf(content_range->value.data,\n                                       ""bytes */%O"",\n                                       r->headers_out.content_length_n)\n                           - content_range->value.data;', 'explanation': ""This segment allocates memory for and sets the 'Content-Range' header's value to a string in the format 'bytes */<representation length>', thereby embedding the current length of the representation as required by the RFC.""}}]","The function 'ngx_http_range_not_satisfiable' explicitly sets the HTTP status to 416 and constructs a 'Content-Range' header that includes the current representation length. Both the creation of the header (C1) and the correct formatting of its value (A1) are handled entirely within this function, fulfilling the specified RFC requirement.",success,
2902,ngx_http_range_not_satisfiable,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,[],"The function implements the mechanics required for sending a 416 (Range Not Satisfiable) response by setting the proper status code, constructing the Content-Range header with the 'bytes */<length>' syntax, and clearing the Content-Length header. These actions align with the HTTP RFC’s expectations for forming a well‐formed response to an unsatisfiable range request. However, the RFC constraint specifically notes that a sender must not generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles, meaning that role‐based restrictions should be enforced. In this function, no explicit check or mechanism ensures that only protocol elements permitted for the sender’s role are generated. There is no visible logic addressing role verification or guarding against generating elements reserved for other roles. As a result, while some parts of the RFC (such as correct header formation and status code setting) are handled, the function does not fully implement the RFC constraint regarding role-based generation of protocol elements. Therefore, the implementation in this function partially matches the specification.",success,
2903,ngx_http_range_body_filter,A server MAY ignore the Range header field.,126,Partially Matches,"[{'C1': {'code': 'if (ctx == NULL) {\n    return ngx_http_next_body_filter(r, in);\n}', 'explanation': 'This segment shows that if no range‐processing context is found (for example, when the Range header is not applicable or provided), the function simply passes processing to the next filter – effectively ignoring range handling. This aligns with the RFC’s allowance that a server MAY ignore the Range header field.'}}]","The provided function includes logic that, when no range context exists, bypasses any range processing (thereby 'ignoring' the Range header field), which partially meets the specification. However, the function does not check the request method (e.g., ensuring that only GET requests are processed for range handling) nor does it fully implement all aspects of the RFC concerning range handling. The absence of an explicit method check means that some parts of the specification (for instance, ignoring ranges on unsupported methods) are not handled within this function. Overall, while some of the RFC’s intent (ignoring the Range header under certain conditions) is reflected, not all labeled conditions and actions are addressed in the code function itself.",success,
2903,ngx_http_range_body_filter,"A server MUST NOT generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses.",288,Fully Matches,"[{'C1': {'code': 'if (ctx->ranges.nelts == 1) {\n    return ngx_http_range_singlepart_body(r, ctx, in);\n}', 'explanation': 'This code snippet explicitly checks if there is only one range requested and calls the single-part body filter to ensure a multipart response is not generated, which fulfills the RFC requirement.'}}]","The function directly addresses the RFC requirement that a server MUST NOT generate a multipart response to a request for a single range. It does so by checking if the ranges count is one and then routing the response to singlepart handling, thereby ensuring compliance with the spec. All logic addressing this spec constraint is contained within the function_body, and thus it fully meets the condition.",success,
2905,ngx_http_range_singlepart_body,"A server MUST NOT generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses.",288,Fully Matches,"[{'C1': {'code': 'range = ctx->ranges.elts;\n...\nif (range->start > start) {\n    if (buf->in_file) {\n        buf->file_pos += range->start - start;\n    }\n\n    if (ngx_buf_in_memory(buf)) {\n        buf->pos += (size_t) (range->start - start);\n    }\n}\n\nif (range->end <= last) {\n    if (buf->in_file) {\n        buf->file_last -= last - range->end;\n    }\n\n    if (ngx_buf_in_memory(buf)) {\n        buf->last -= (size_t) (last - range->end);\n    }\n\n    buf->last_buf = (r == r->main) ? 1 : 0;\n    buf->last_in_chain = 1;\n\n    tl = ngx_alloc_chain_link(r->pool);\n    if (tl == NULL) {\n        return NGX_ERROR;\n    }\n\n    tl->buf = buf;\n    tl->next = NULL;\n\n    *ll = tl;\n    ll = &tl->next;\n}', 'explanation': ""The RFC requires that a single range must not be returned as a multipart response. This function, by its design (processing a single 'range' from ctx->ranges.elts and adjusting buffer pointers accordingly), produces a single-part body response. There is no logic to generate multipart boundaries or segments, which directly complies with the constraint.""}}]",The function 'ngx_http_range_singlepart_body' examines each buffer in the input chain and adjusts it based on the start and end values of a single range (obtained from ctx->ranges.elts). It thereby constructs an output chain that represents only one contiguous part. This is fully aligned with the RFC specification that instructs a server to not generate a multipart response for a single range. All logic necessary to ensure that only one part is output—without any multipart boundaries—is contained within this function.,success,
2906,ngx_http_range_multipart_body,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,36,Partially Matches,"[{'C1': {'code': 'b->last = ngx_cpymem(b->pos, ctx->boundary_header.data,\n                         sizeof(CRLF ""--"") - 1 + NGX_ATOMIC_T_LEN);\n*b->last++ = \'-\'; *b->last++ = \'-\';\n*b->last++ = CR; *b->last++ = LF;', 'explanation': 'The RFC requires that only CRLF be used to represent line breaks. In the final boundary creation section, the code appends CR followed by LF, which shows an attempt to adhere to that requirement. Additionally, the boundary header (from ctx->boundary_header.data) is expected to include CRLF sequences as per multipart standards. However, not every possible aspect (such as verification across all parts or ensuring no other line break formats are ever generated) is enforced solely in this function.'}}]","The analyzed function constructs multipart message bodies by preparing separate chain links for the boundary header, content range header, and the actual content of each range. In its final boundary segment, it explicitly appends CR and LF to enforce CRLF as the line break sequence, thereby attempting to comply with the RFC specification that mandates only CRLF be used between body parts. However, while the function makes visible efforts to use CRLF for line termination (i.e. meeting a condition like C1), not all nuances or all conditions/actions inferred from the spec are fully implemented within this isolated code segment. As a result, the function's implementation partially matches the RFC requirements as seen in its visible logic.",success,
2906,ngx_http_range_multipart_body,"Within the header area of each body part in the multipart content, the server MUST generate a Content-Range header field corresponding to the range being enclosed in that body part.",149,Fully Matches,"[{'C1': {'code': 'b = ngx_calloc_buf(r->pool);\nif (b == NULL) { return NGX_ERROR; }\n...\n/* ""SSSS-EEEE/TTTT"" CRLF CRLF */\n\nb = ngx_calloc_buf(r->pool);\nif (b == NULL) { return NGX_ERROR; }\n\nb->temporary = 1;\nb->pos = range[i].content_range.data;\nb->last = range[i].content_range.data + range[i].content_range.len;\n\nrcl = ngx_alloc_chain_link(r->pool);\nif (rcl == NULL) { return NGX_ERROR; }\n\nrcl->buf = b;', 'explanation': ""This segment allocates a buffer and assigns the pre-formatted Content-Range header (from range[i].content_range) for each body part, directly meeting the RFC's condition that each multipart section include a Content-Range header.""}}, {'A1': {'code': 'b = ngx_calloc_buf(r->pool);\nif (b == NULL) { return NGX_ERROR; }\n\nb->memory = 1;\nb->pos = ctx->boundary_header.data;\nb->last = ctx->boundary_header.data + ctx->boundary_header.len;\n\nhcl = ngx_alloc_chain_link(r->pool);\nif (hcl == NULL) { return NGX_ERROR; }\n\nhcl->buf = b;', 'explanation': 'This code creates the boundary header for each part, as well as the final closing boundary. It uses ctx->boundary_header to generate the boundary lines, satisfying the RFC requirement for multipart boundaries in a 206 response.'}}]","The function iterates over each requested range and constructs three chain links per range: one for the boundary header (which includes the Content-Type information), one for the Content-Range header (fulfilling the need to have a Content-Range header in each body part), and one for the actual range data. Additionally, it appends the final boundary at the end. Thus, the function visibly implements the RFC requirement for embedding a Content-Range header in each multipart body part and the necessary boundaries, fully addressing the conditions depicted in the specification.",success,
2906,ngx_http_range_multipart_body,"To avoid confusion with single-part responses, a server MUST NOT generate a Content-Range header field in the HTTP header section of a multiple part response (this field will be sent in each part instead).",148,Fully Matches,"[{'C1': {'code': '/* For each range, the function creates a boundary header and a Content-Range header as part of the body part */\n\nb = ngx_calloc_buf(r->pool);\nif (b == NULL) {\n    return NGX_ERROR;\n}\n\nb->memory = 1;\nb->pos = ctx->boundary_header.data;\nb->last = ctx->boundary_header.data + ctx->boundary_header.len;\n\nhcl = ngx_alloc_chain_link(r->pool);\nif (hcl == NULL) {\n    return NGX_ERROR;\n}\nhcl->buf = b;\n\n/* ""SSSS-EEEE/TTTT"" CRLF CRLF - the individual Content-Range header for the part */\n\nb = ngx_calloc_buf(r->pool);\nif (b == NULL) {\n    return NGX_ERROR;\n}\n\nb->temporary = 1;\nb->pos = range[i].content_range.data;\nb->last = range[i].content_range.data + range[i].content_range.len;\nrcl = ngx_alloc_chain_link(r->pool);\nif (rcl == NULL) {\n    return NGX_ERROR;\n}\nrcl->buf = b;', 'explanation': 'The function builds the multipart response by creating, for each range, a boundary header that includes the Content-Range header inside the body part, rather than in the overall HTTP header. This directly implements the RFC requirement that a server MUST NOT generate a Content-Range header field in the global header section of a multipart response.'}}]","The function iterates over the range segments and for each one it allocates buffers for both the multipart boundary header and the corresponding Content-Range header, embedding them within each part of the response body. No Content-Range header is generated in the global HTTP header, which meets the RFC specification. Therefore, analyzing the code in isolation confirms that it fully implements the necessary behavior as required by the spec constraints.",success,
2983,ngx_http_proxy_handler,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': '#if (NGX_HTTP_CACHE)\n    pmcf = ngx_http_get_module_main_conf(r, ngx_http_proxy_module);\n\n    u->caches = &pmcf->caches;\n    u->create_key = ngx_http_proxy_create_key;\n#endif', 'explanation': 'This code conditionally sets up caching by accessing the cache configuration and key creation routines when caching is enabled. It demonstrates that a cache may be employed as suggested by the RFC. However, it does not include logic to handle the scenario where the proxy is acting as a tunnel.'}}]","The RFC states that any client or server MAY employ a cache and that a cache cannot be used while acting as a tunnel. In the function, caching is conditionally initialized (under NGX_HTTP_CACHE) which aligns with the first part of the spec. There is, however, no visible check or restriction in the function to prevent the cache from being used while acting as a tunnel. Thus, only part of the specification is addressed by the code in isolation.",success,
2984,ngx_http_proxy_eval,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'if (proxy.len > 7\n        && ngx_strncasecmp(proxy.data, (u_char *) ""http://"", 7) == 0)\n    {\n        add = 7;\n        port = 80;\n    }\n#if (NGX_HTTP_SSL)\n    } else if (proxy.len > 8\n               && ngx_strncasecmp(proxy.data, (u_char *) ""https://"", 8) == 0)\n    {\n        add = 8;\n        port = 443;\n        r->upstream->ssl = 1;\n#endif\n    }\n    ...\n    u->resolved->port = (in_port_t) (url.no_port ? port : url.port);', 'explanation': ""The function sets a default port based on the URL scheme (80 for 'http://' and 443 for 'https://') and later checks if a port was provided using the 'url.no_port' flag. If no port is provided, it assigns the default port. This directly implements the RFC clause that if a port is not provided, the recipient may use the protocol's default port.""}}]",The function clearly demonstrates the handling of default port values. It first determines the appropriate default port based on the protocol (HTTP or HTTPS) and then uses this default when no explicit port is provided in the URL. This matches the RFC specification which allows the assumption of a default port when none is present.,success,
2986,ngx_http_proxy_create_request,A sender MUST NOT send whitespace between the start-line and the first header field.,295,Fully Matches,"[{'C1': {'code': 'if (plcf->http_version == NGX_HTTP_VERSION_11) {\n    b->last = ngx_cpymem(b->last, ngx_http_proxy_version_11,\n                         sizeof(ngx_http_proxy_version_11) - 1);\n} else {\n    b->last = ngx_cpymem(b->last, ngx_http_proxy_version,\n                         sizeof(ngx_http_proxy_version) - 1);\n}\n\n/* add ""\\r\\n"" at the header end */\n*b->last++ = CR; *b->last++ = LF;', 'explanation': 'The function builds the HTTP request by writing the request-line (which includes the HTTP version string that is expected to already contain the terminating CRLF) and then immediately appending header fields without inserting any additional whitespace or empty lines between them. This construction inherently ensures that no extraneous whitespace is sent between the start-line and the first header field, which is in full compliance with the RFC specification.'}}]","The code in ngx_http_proxy_create_request constructs an HTTP request from its component parts. It writes the method, URI, and HTTP version (with an expected embedded CRLF) and then appends header fields directly using formatted copying and script engines. There is no extra blank line or inserted whitespace between the request-line and the header fields, thereby fully implementing the requirement that a sender MUST NOT send whitespace between the start-line and the first header field within this function.",success,
2986,ngx_http_proxy_create_request,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Fully Matches,"[{'C1': {'code': '                *b->last++ = CR; *b->last++ = LF;\n                ...\n                *e.pos++ = CR; *e.pos++ = LF;\n                ...\n                /* add ""\\r\\n"" at the header end */\n                *b->last++ = CR; *b->last++ = LF;', 'explanation': 'Throughout the function, every time a carriage return (CR) is inserted into the output buffer, it is immediately followed by a line feed (LF). This can be seen in the segments that append CRLF pairs for terminating lines in the HTTP request and headers, ensuring that no bare CR is generated.'}}]","The RFC requires that a sender MUST NOT generate a bare CR in protocol elements. The function explicitly appends CR followed by LF in all its line terminations (e.g., after the request line and each header line), ensuring compliance with this requirement. There is no logic in the function that allows a CR to be written without an immediately following LF, which means the constraint is fully addressed solely within the function.",success,
2986,ngx_http_proxy_create_request,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC requires that a sender must not generate protocol elements or syntax alternatives that are only allowed for participants in other roles. In the function, we see that the request is built by copying the method, URI, and headers from various sources and using filtering (e.g., the use of ngx_hash_find to skip certain headers), but there is no explicit logic that distinguishes whether the headers or protocol elements being generated are reserved for a particular role. The function does not enforce a check to disallow generation of elements that are not permitted for the sender's role. Thus, within this function alone, there is no visible implementation that meets the spec constraint (labeled as for example C1) regarding role-based generation of protocol elements.",success,
2995,ngx_http_proxy_process_status_line,"A sender SHOULD send a Connection header field (Section 7.6.1 of [HTTP]) containing the ""close"" connection option when it intends to close a connection.",212,Fully Matches,"[{'A1': {'code': 'if (rc == NGX_ERROR) {\n    ...\n    u->headers_in.connection_close = 1;\n    return NGX_OK;\n}\n\n...\n\nif (ctx->status.http_version < NGX_HTTP_VERSION_11) {\n    u->headers_in.connection_close = 1;\n}', 'explanation': ""The code explicitly sets 'u->headers_in.connection_close = 1' in two scenarios: once when an error occurs (implying a fallback to HTTP/0.9 behavior where closing the connection is expected) and once when the parsed HTTP version is less than HTTP/1.1. Both cases indicate that the sender intends to close the connection by sending the 'Connection: close' header, thereby directly addressing the requirement from the HTTP RFC.""}}]","In isolation, this function explicitly handles the sending of a close signal by setting the connection_close flag in relevant conditions. The first instance is in the error-handling branch, while the second is when the HTTP-version is less than 1.1. Both implementations directly correspond to the RFC requirement to include the 'Connection: close' header when the sender intends to close the connection, which means the function fully implements the specified behavior.",success,
2995,ngx_http_proxy_process_status_line,A recipient MAY employ such workarounds while remaining conformant to this protocol if the workarounds are limited to the implementations at fault.,216,Partially Matches,"[{'A1': {'code': 'if (rc == NGX_ERROR) {\n\n#if (NGX_HTTP_CACHE)\n    if (r->cache) {\n        r->http_version = NGX_HTTP_VERSION_9;\n        return NGX_OK;\n    }\n#endif\n\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent no valid HTTP/1.0 header"");\n\n    r->http_version = NGX_HTTP_VERSION_9;\n    u->state->status = NGX_HTTP_OK;\n    u->headers_in.connection_close = 1;\n\n    return NGX_OK;\n}', 'explanation': ""When the parsing of the upstream response's status line fails (NGX_ERROR), the code applies a workaround by setting the HTTP version to 0.9 and marking the connection to be closed. This reflects the RFC's allowance for recipients to employ limited workarounds in the face of implementations at fault. This behavior corresponds to one of the specified actions (A1) in the constraints.""}}]","The function addresses the RFC's guideline by implementing a fallback mechanism if an invalid status line is encountered. It explicitly sets the HTTP version to 0.9 and forces the connection to close, thereby limiting the workaround to the part of the implementation that is at fault. However, this only covers one specific aspect of the RFC suggestion (i.e. handling invalid headers) and does not cover any additional conditions or actions, resulting in a partial match overall.",success,
2995,ngx_http_proxy_process_status_line,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Fully Matches,"[{'C1': {'code': 'if (rc == NGX_ERROR) {\n\n#if (NGX_HTTP_CACHE)\n    if (r->cache) {\n        r->http_version = NGX_HTTP_VERSION_9;\n        return NGX_OK;\n    }\n#endif\n\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent no valid HTTP/1.0 header"");\n\n    r->http_version = NGX_HTTP_VERSION_9;\n    u->state->status = NGX_HTTP_OK;\n    u->headers_in.connection_close = 1;\n\n    return NGX_OK;\n}', 'explanation': 'This block demonstrates recovery from an invalid HTTP status line by setting the HTTP version to 0.9 (a fallback) and a default OK status, thereby attempting to recover a usable protocol element as allowed by the RFC specification.'}}, {'A1': {'code': 'if (ctx->status.http_version < NGX_HTTP_VERSION_11) {\n    u->headers_in.connection_close = 1;\n}', 'explanation': 'This code ensures that if the response uses an HTTP version below 1.1, the connection is marked for closure, which aligns with the semantics defined in the HTTP protocol.'}}]","The function processes the HTTP status line obtained from the upstream response. In the event of a parsing error, it explicitly recovers by falling back to an older HTTP version (HTTP/0.9) and setting a default OK status, which directly reflects the RFC's permissive handling of invalid constructs. Additionally, it adjusts connection handling based on the HTTP version, thereby visibly addressing the spec constraints within the function’s logic.",success,
2995,ngx_http_proxy_process_status_line,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (rc == NGX_ERROR) {\n#if (NGX_HTTP_CACHE)\n    if (r->cache) {\n        r->http_version = NGX_HTTP_VERSION_9;\n        return NGX_OK;\n    }\n#endif\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent no valid HTTP/1.0 header"");\n    r->http_version = NGX_HTTP_VERSION_9;\n    u->state->status = NGX_HTTP_OK;\n    u->headers_in.connection_close = 1;\n    return NGX_OK;\n}', 'explanation': 'This segment detects a parsing error of the upstream status line and recovers by assigning HTTP version 0.9 and default status. This is a measure toward interpreting a received protocol element in a way that remains usable, which partially fulfills the RFC requirement of interpreting elements according to the defined semantics, and recovering from invalid constructs.'}}]","The RFC mandates that a recipient interpret a received protocol element by applying the semantics defined (including any allowed recoveries), unless configured otherwise due to known sender issues. The provided code function attempts to parse the HTTP status line and, upon encountering an error, falls back to using HTTP/0.9 by setting the relevant fields. This recovery mechanism is in line with the notion of recovering a usable protocol element from an invalid construct. However, the function does not cover other potential configurations or verifications (for example, checking for sender mis-implementation based on experience or configuration) as might be implied by the RFC context, hence it only partially matches the constraints as defined.",success,
2995,ngx_http_proxy_process_status_line,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'rc = ngx_http_parse_status_line(r, &u->buffer, &ctx->status);\nif (rc == NGX_ERROR) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent no valid HTTP/1.0 header"");\n\n#if (NGX_HTTP_CACHE)\n    if (r->cache) {\n        r->http_version = NGX_HTTP_VERSION_9;\n        return NGX_OK;\n    }\n#endif\n\n    r->http_version = NGX_HTTP_VERSION_9;\n    u->state->status = NGX_HTTP_OK;\n    u->headers_in.connection_close = 1;\n\n    return NGX_OK;\n}', 'explanation': ""The function calls a parsing routine and then checks the return code. If parsing fails, it logs an error and safely falls back to an HTTP/0.9 behavior. This demonstrates a defensive parsing strategy in line with the RFC's recommendation of parsing with only marginal expectations regarding full ABNF conformity.""}}, {'A1': {'code': 'if (rc == NGX_ERROR) {\n    ...\n    r->http_version = NGX_HTTP_VERSION_9;\n    u->state->status = NGX_HTTP_OK;\n    u->headers_in.connection_close = 1;\n\n    return NGX_OK;\n}', 'explanation': 'On detecting a parsing error, the function deliberately sets default HTTP version values and appropriate connection flags to handle the malformed or unexpected protocol element, which is a defensive action.'}}]","The function implements a defensive parsing approach by verifying the result of the status line parser and handling errors robustly. It checks whether the received element conforms (even if only marginally) to expected grammar, and in case of failure, it falls back to a safe interpretation (HTTP/0.9) and flags the connection for closure. Although this demonstrates a defensive strategy, the function defers some aspects (like detailed buffer size checking) to the external parser, hence only partially matching the overall spec requirements.",success,
2997,ngx_http_proxy_process_header,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'C1': {'code': '            if (u->headers_in.status_n == NGX_HTTP_NO_CONTENT\n                || u->headers_in.status_n == NGX_HTTP_NOT_MODIFIED\n                || ctx->head\n                || (!u->headers_in.chunked\n                    && u->headers_in.content_length_n == 0))\n            {\n                u->keepalive = !u->headers_in.connection_close;\n            }\n\n            if (u->headers_in.status_n == NGX_HTTP_SWITCHING_PROTOCOLS) {\n                u->keepalive = 0;\n\n                if (r->headers_in.upgrade) {\n                    u->upgrade = 1;\n                }\n            }', 'explanation': ""This code block explicitly sets the upstream connection's 'keepalive' flag based on the response conditions. When the response is one that should not include a body (such as 204 No Content, 304 Not Modified, HEAD requests, or when content length is zero), it checks if the connection is not explicitly closed and then enables keepalive. This implements persistent connection support as dictated by HTTP/1.1, which defaults to persistent connections.""}}]","The function analyzes the header from the upstream response and, based on specific conditions, determines whether to maintain the connection (i.e., set persistent connection via the 'keepalive' flag). By checking for conditions that would allow a persistent connection (unless a 'Connection: close' is indicated) and ensuring that protocol nuances like switching protocols are correctly handled, the function visibly addresses the requirement in the spec that HTTP implementations SHOULD support persistent connections.",success,
2998,ngx_http_proxy_input_filter_init,HTTP implementations SHOULD support persistent connections.,311,Partially Matches,"[{'C1': {'code': 'u->keepalive = !u->headers_in.connection_close;', 'explanation': 'This segment sets the keepalive flag based on the connection_close value from the headers, which is used to decide if the connection should be persistent for certain responses (e.g., for 204, 304, or HEAD responses). It shows an attempt to support persistent connections as required by HTTP/1.1, though only in specific branches.'}}]","The function implements part of the persistent connection behavior by setting u->keepalive when the response qualifies (such as in cases with no content, or for HEAD requests) based on the connection_close header field. While this demonstrates an effort to support persistent connections per the HTTP/1.1 specification, the function does not address all aspects of persistent connection logic (such as handling the protocol version or other Connection header details) entirely within its own code. Thus, it only partially matches the spec constraint.",success,
2998,ngx_http_proxy_input_filter_init,A recipient MUST be able to parse and decode the chunked transfer coding.,204,Partially Matches,[],"The function distinguishes between different response types and, in the case of a chunked response, it sets filter function pointers (ngx_http_proxy_chunked_filter and ngx_http_proxy_non_buffered_chunked_filter) to handle chunked transfer coding. However, the function itself does not implement the actual parsing and decoding of the chunk-size field (e.g. reading hexadecimal values, checking for zero-size chunks, handling potential overflows or precision loss), which is required by the RFC. Since the actual chunked decoding logic is delegated to other functions and is not implemented within this function’s code, the function only partially meets the RFC requirement.",success,
2998,ngx_http_proxy_input_filter_init,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The provided function initializes filters based on attributes of the HTTP response (e.g., status code, chunked encoding, or a non-zero content-length) but does not include any logic to verify or validate that the Content-Length header field value is correct as required by the RFC. There is no check to reject a message with an incorrect Content-Length value, nor is there any handling of multiple comma-separated values or the exception noted in the spec. As such, no labeled condition or action (e.g., C1, A1) addressing the RFC requirement is implemented within this function.",success,
2998,ngx_http_proxy_input_filter_init,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Partially Matches,"[{'C1': {'code': 'if (u->headers_in.status_n == NGX_HTTP_NO_CONTENT\n        || u->headers_in.status_n == NGX_HTTP_NOT_MODIFIED\n        || ctx->head)\n{\n    u->pipe->length = 0;\n    u->length = 0;\n    u->keepalive = !u->headers_in.connection_close;\n}', 'explanation': 'The code explicitly handles the case when the upstream status is NGX_HTTP_NO_CONTENT (which corresponds to status 204) by setting both u->pipe->length and u->length to zero, effectively preventing a Content-Length from being sent. However, while the RFC specifies that Content-Length must not be sent for any 1xx (Informational) or 204 (No Content) responses, this function does not explicitly check for 1xx status codes. It instead groups 204, 304 (Not Modified), and HEAD responses (via ctx->head) together, thereby not fully covering the 1xx case.'}}]","The function attempts to implement the RFC by configuring the message length based on the response status. It correctly removes the Content-Length for 204 responses (NGX_HTTP_NO_CONTENT) by setting the length values to zero. However, it does not check or handle responses with a status code in the 1xx range, as required by the specification. Furthermore, it additionally groups 304 and HEAD responses into the same branch, which goes beyond the RFC requirement. Because it only partially covers the specified condition, the outcome is 'Partially Matches'.",success,
2998,ngx_http_proxy_input_filter_init,A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance.,187,Partially Matches,"[{'C1': {'code': 'else if (u->headers_in.chunked) {\n    /* chunked */\n\n    u->pipe->input_filter = ngx_http_proxy_chunked_filter;\n    u->pipe->length = 3; /* ""0"" LF LF */\n\n    u->input_filter = ngx_http_proxy_non_buffered_chunked_filter;\n    u->length = 1;\n}', 'explanation': 'This code branch directly handles the parsing of chunked transfer coding by setting the input filters (ngx_http_proxy_chunked_filter and ngx_http_proxy_non_buffered_chunked_filter), which addresses the requirement (C1) that a recipient must be able to parse chunked coding as per HTTP RFC.'}}]","The function contains a dedicated branch for processing responses that use chunked transfer coding (when u->headers_in.chunked is true). It sets up the necessary filters and length parameters to handle chunked data framing. However, other aspects of the spec (for example, ensuring that chunking is applied only once or handling other transfer codings) are not managed within this function. As a result, while the chunked parsing requirement is clearly implemented, only part of the complete spec constraints is addressed within this function.",success,
2998,ngx_http_proxy_input_filter_init,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'A1': {'code': 'u->keepalive = !u->headers_in.connection_close;', 'explanation': ""In the branches handling responses with no content or empty bodies, the code sets the keepalive flag based on the 'connection_close' header. This shows an attempt to sustain persistent connections as advised by the RFC when possible.""}}]","The RFC requires that a server should sustain persistent connections when possible and use underlying transport flow-control mechanisms to handle temporary overloads rather than closing connections. In this function, only a portion of that requirement is implemented: the keepalive flag is conditionally set by checking the 'connection_close' header in certain cases (e.g., no content responses and empty bodies), which is a partial implementation for sustaining persistent connections. There is no logic in this function that manages flow-control mechanisms or overload conditions. Thus, while the function addresses sustaining persistent connections in some branches, it does not fully implement all aspects of the RFC specification.",success,
2999,ngx_http_proxy_copy_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'C1': {'code': 'if (p->length == 0) {\n    ngx_log_error(NGX_LOG_WARN, p->log, 0,\n                  ""upstream sent more data than specified in ""\n                  ""\\""Content-Length\\"" header"");\n\n    r = p->input_ctx;\n    r->upstream->keepalive = 0;\n    p->upstream_done = 1;\n\n    return NGX_OK;\n}', 'explanation': 'This block checks whether no expected data length remains (i.e. all data as per Content-Length already received) and upon receiving extra data it logs an error, disables upstream keepalive, and stops further forwarding. This addresses the RFC requirement to not forward a message when its Content-Length is known to be incorrect.'}}, {'A1': {'code': 'if (b->last - b->pos > p->length) {\n\n    ngx_log_error(NGX_LOG_WARN, p->log, 0,\n                  ""upstream sent more data than specified in ""\n                  ""\\""Content-Length\\"" header"");\n\n    b->last = b->pos + p->length;\n    p->upstream_done = 1;\n\n    return NGX_OK;\n}', 'explanation': 'This segment handles the scenario where the current buffer contains more bytes than expected. By truncating the buffer (resetting b->last) and marking the upstream as done, it prevents the extra data from being forwarded, thus partially satisfying the RFC action.'}}]","The function detects when the amount of data received exceeds the specified Content-Length. In these cases, it logs warnings, disables keepalive on the connection, truncates the data, and ceases further processing—thereby avoiding the forwarding of extra (and hence incorrect) data. However, it does not account for all conditions specified by the RFC (for example, handling repeated identical Content-Length values as a comma-separated list), so only part of the requirement is implemented in this function by itself.",success,
3000,ngx_http_proxy_chunked_filter,A recipient MUST be able to parse and decode the chunked transfer coding.,204,Partially Matches,"[{'C1': {'code': 'rc = ngx_http_parse_chunked(r, buf, &ctx->chunked, plcf->upstream.pass_trailers);', 'explanation': 'This call initiates the parsing of the chunk-size field (expressed in hexadecimal) from the incoming buffer, which is part of decoding the chunked transfer coding as required by the spec.'}}, {'A1': {'code': 'if (rc == NGX_DONE) {\\n    if (plcf->upstream.pass_trailers) {\\n        rc = ngx_http_proxy_process_trailer(r, buf);\\n        if (rc == NGX_ERROR) {\\n            return NGX_ERROR;\\n        }\\n        if (rc == NGX_AGAIN) {\\n            p->length = 1;\\n            break;\\n        }\\n    }\\n    /* a whole response has been parsed successfully */\\n    p->length = 0;\\n    r->upstream->keepalive = !r->upstream->headers_in.connection_close;\\n    if (buf->pos != buf->last) {\\n        ngx_log_error(NGX_LOG_WARN, p->log, 0,\\n                      ""upstream sent data after final chunk"");\\n        r->upstream->keepalive = 0;\\n    }\\n    break;\\n}', 'explanation': 'This segment handles the detection of the final chunk (indicated by NGX_DONE) and processes trailers, aligning with the spec that the transfer coding is complete when a zero-length chunk is received and possibly followed by trailers.'}}]","The function attempts to parse and decode a chunked transfer coding by repeatedly invoking the ngx_http_parse_chunked routine to process the hexadecimal chunk sizes and by handling chunk trailers via ngx_http_proxy_process_trailer. This addresses key aspects of the RFC such as the parsing of the hex chunk-size and the handling of a final chunk and its trailers. However, the function does not directly implement checks to guard against issues like integer conversion overflows or large hexadecimal numerals; such protections appear to be delegated to the helper functions it calls. Thus, while the function visibly addresses some conditions (like correctly processing chunks and trailers), it only partially meets all aspects of the spec constraints as detailed in the RFC.",success,
3000,ngx_http_proxy_chunked_filter,A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance.,187,Fully Matches,"[{'C1': {'code': 'rc = ngx_http_parse_chunked(r, buf, &ctx->chunked, plcf->upstream.pass_trailers);', 'explanation': 'This call to ngx_http_parse_chunked is the core logic that implements parsing of the chunked transfer coding, fulfilling the RFC requirement that a recipient MUST be able to parse chunked messages.'}}]","The function explicitly and visibly processes incoming data buffers using a loop that calls ngx_http_parse_chunked, handles parsed chunks by advancing the buffer positions, and manages trailers when present. These behaviors directly address the specification requirement to correctly parse chunked transfer coding, and therefore the function meets the constraint (labeled C1) from the RFC.",success,
3001,ngx_http_proxy_non_buffered_copy_filter,HTTP implementations SHOULD support persistent connections.,311,Partially Matches,"[{'A1': {'code': 'if (u->length == 0) {\n    u->keepalive = !u->headers_in.connection_close;\n}', 'explanation': ""This code segment checks if the expected content-length has been fully received and then sets the upstream keepalive flag based on the state of 'u->headers_in.connection_close'. In doing so, it attempts to support persistent connections by leaving the connection open (if the 'Connection: close' header is not present), which aligns with the HTTP/1.1 spec that persistent connections SHOULD be supported.""}}]","The provided function primarily deals with handling data buffering and copying while monitoring the remaining content-length. When all data has been received (u->length becomes 0), it sets the u->keepalive flag to !u->headers_in.connection_close, which is the only logic in the function that directly addresses the support of persistent connections as specified in the RFC. Although this connection persistence support is included, the function does not cover additional aspects of connection management required for full HTTP/1.1 compliance by itself. Therefore, only a part of the persistent connection requirement is handled in this function.",success,
3001,ngx_http_proxy_non_buffered_copy_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'C1': {'code': 'if (u->length == 0) {\n    ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n                  ""upstream sent more data than specified in \\""Content-Length\\"" header"");\n    u->keepalive = 0;\n    return NGX_OK;\n}\n\n...\n\nif (bytes > u->length) {\n    ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n                  ""upstream sent more data than specified in \\""Content-Length\\"" header"");\n\n    cl->buf->last = cl->buf->pos + u->length;\n    u->length = 0;\n\n    return NGX_OK;\n}', 'explanation': 'The function checks if more data is received than what the Content-Length header specifies. In both cases—when no more data should be received (u->length == 0) and when the current chunk exceeds the expected length (bytes > u->length)—it logs a warning and disables keepalive, effectively preventing potential further message forwarding. This addresses the requirement to not forward a message once an incorrect Content-Length is detected. However, it does not handle certain exceptional cases (e.g., comma-separated repeated values), so only part of the overall spec is implemented in this function.'}}]","The RFC states that a sender MUST NOT forward a message with an incorrect Content-Length value. This function visibly detects cases where the upstream data exceeds the declared Content-Length by logging an error and disabling keepalive, which prevents connection reuse and further forwarding. Nonetheless, it does not process or adjust repeated/comma-separated Content-Length values nor does it strictly reject the message outright, meaning that while it implements part of the spec (detecting and mitigating errors in Content-Length), it does not fully cover all scenarios dictated by the RFC. Therefore, the implementation is classified as a partial match.",success,
3002,ngx_http_proxy_non_buffered_chunked_filter,A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance.,187,Fully Matches,"[{'C1': {'code': 'rc = ngx_http_parse_chunked(r, buf, &ctx->chunked, plcf->upstream.pass_trailers);\nif (rc == NGX_OK) {\n    /* a chunk has been parsed successfully */\n    ...\n    continue;\n}\nif (rc == NGX_DONE) {\n    ...\n    break;\n}\nif (rc == NGX_AGAIN) {\n    break;\n}\n/* invalid response */\nngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n              ""upstream sent invalid chunked response"");\nreturn NGX_ERROR;', 'explanation': 'This portion of the code repeatedly calls the chunked parser, handling various return codes (NGX_OK, NGX_DONE, NGX_AGAIN) to correctly parse the incoming chunked transfer coding. This directly addresses the requirement that a recipient must be able to parse chunked transfer coding when the content size is not known in advance.'}}, {'A1': {'code': 'if (ctx->trailers) {\n    rc = ngx_http_proxy_process_trailer(r, buf);\n    if (rc == NGX_ERROR) {\n        return NGX_ERROR;\n    }\n    if (rc == NGX_OK) {\n        /* a whole response has been parsed successfully */\n        r->upstream->keepalive = !u->headers_in.connection_close;\n        u->length = 0;\n        if (buf->pos != buf->last) {\n            ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n                          ""upstream sent data after trailers"");\n            u->keepalive = 0;\n        }\n    }\n    return NGX_OK;\n}', 'explanation': ""This segment checks for the presence of trailers and processes them accordingly. It ensures that if trailers are present (as required in the spec), they are parsed correctly, further confirming the function's compliance with the framing requirements for messages with undetermined content length.""}}]","The function implements the core logic needed to parse chunked transfer coding as specified by the RFC. It repeatedly invokes a parser for chunked data, handles various conditions such as complete chunks, partial data, and trailer sections, and adjusts internal state (e.g., buffer positions, connection keepalive) accordingly. This direct handling within the function_body covers the essential recipient behavior required by the specification.",success,
3002,ngx_http_proxy_non_buffered_chunked_filter,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Fully Matches,"[{'C1': {'code': 'rc = ngx_http_parse_chunked(r, buf, &ctx->chunked, plcf->upstream.pass_trailers);\nif (rc == NGX_OK) {\n    /* a chunk has been parsed successfully */\n    ...\n    continue;\n}\n\nif (rc == NGX_DONE) {\n    if (plcf->upstream.pass_trailers) {\n        rc = ngx_http_proxy_process_trailer(r, buf);\n        ...\n    }\n    /* a whole response has been parsed successfully */\n    ...\n    break;\n}\n\nif (rc == NGX_AGAIN) {\n    break;\n}\n\n/* invalid response */\nngx_log_error(NGX_LOG_ERR, r->connection->log, 0, ""upstream sent invalid chunked response"");\nreturn NGX_ERROR;', 'explanation': 'This segment shows that the function attempts to interpret the received chunked data according to the defined RFC semantics. It parses valid chunks, handles completions and trailers, and logs errors for invalid constructs, thereby directly addressing the requirement that a recipient must interpret a received protocol element based on defined semantics.'}}, {'A1': {'code': 'if (ctx->trailers) {\n    rc = ngx_http_proxy_process_trailer(r, buf);\n\n    if (rc == NGX_ERROR) {\n        return NGX_ERROR;\n    }\n\n    if (rc == NGX_OK) {\n        /* a whole response has been parsed successfully */\n        r->upstream->keepalive = !u->headers_in.connection_close;\n        u->length = 0;\n\n        if (buf->pos != buf->last) {\n            ngx_log_error(NGX_LOG_WARN, r->connection->log, 0, ""upstream sent data after trailers"");\n            u->keepalive = 0;\n        }\n    }\n\n    return NGX_OK;\n}', 'explanation': 'This code handles the processing of trailers—a protocol extension—and makes decisions (such as managing keepalive connections) based on whether the trailers have been fully and correctly received. This aligns with the action required to process protocol elements including extensions as described by the specification.'}}]","The function implements complete logic to parse chunked HTTP responses and process trailers. It interprets the received protocol element by handling valid chunks, dealing with extension trailer processing, and appropriately logging or terminating the connection when necessary. This direct handling of various response states meets the RFC's requirement that a recipient must interpret protocol elements according to the specification's semantics, including any extensions, without relying on external dependencies.",success,
3002,ngx_http_proxy_non_buffered_chunked_filter,A recipient MUST be able to parse and decode the chunked transfer coding.,204,Partially Matches,"[{'C1': {'code': 'rc = ngx_http_parse_chunked(r, buf, &ctx->chunked, plcf->upstream.pass_trailers);', 'explanation': 'The function repeatedly calls ngx_http_parse_chunked to decode the chunked transfer coding, which is the core requirement of having a recipient able to parse and decode the chunked encoding. However, the low‐level details (such as hex conversion and overflow checks) are handled in the called function rather than being implemented in this function directly.'}}, {'A1': {'code': 'if (rc == NGX_DONE) {\n    if (plcf->upstream.pass_trailers) {\n        rc = ngx_http_proxy_process_trailer(r, buf);\n        if (rc == NGX_ERROR) {\n            return NGX_ERROR;\n        }\n        if (rc == NGX_AGAIN) {\n            u->length = 1;\n            break;\n        }\n    }\n    u->keepalive = !u->headers_in.connection_close;\n    u->length = 0;\n    if (buf->pos != buf->last) {\n        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,\n                      ""upstream sent data after final chunk"");\n        u->keepalive = 0;\n    }\n    break;\n}', 'explanation': 'This branch of the code handles the final chunk (when rc == NGX_DONE), processing trailers and finalizing the connection, as required for completion of chunked transfer coding.'}}]","The function attempts to satisfy the RFC requirement by parsing and decoding the chunked transfer coding through its loop that calls ngx_http_parse_chunked and handling the final chunk and trailer sections. While it clearly addresses the basic decoding and trailer processing actions (C1 and A1), the detailed aspects of handling large hexadecimal chunk sizes and preventing integer conversion overflows are offloaded to the helper function ngx_http_parse_chunked, and thus not directly visible in this function. Consequently, the implementation only partially meets the spec constraints within the function_body itself.",success,
3002,ngx_http_proxy_non_buffered_chunked_filter,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'A1': {'code': 'r->upstream->keepalive = !u->headers_in.connection_close;\n...\n...\n\nu->keepalive = !u->headers_in.connection_close;', 'explanation': ""The function explicitly sets the keepalive flag on the upstream connection based on the absence of the 'Connection: close' directive. This directly implements the requirement to support persistent connections as mandated by HTTP/1.1, ensuring that if no closing signal is received, the connection remains persistent.""}}]","The provided code function, while primarily handling chunked transfer encoding, includes explicit logic to determine if the connection should be kept alive. The lines setting r->upstream->keepalive and u->keepalive based on the status of the connection_close header directly address the HTTP/1.1 requirement to support persistent connections. Since this logic is implemented within the function itself and fulfills the spec constraint, the outcome is reported as Fully Matches.",success,
3003,ngx_http_proxy_process_trailer,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The provided function processes trailer fields by reading and storing them into a separate trailers list, but it does not include any logic to verify whether the header field is understood or permitted to be merged into the header section as required by the RFC specification. In other words, it simply parses and stores trailer fields without checking or enforcing the condition that a recipient must not merge a trailer field unless it explicitly permits safe merging. Therefore, the function does not implement the constraint described in the RFC.",success,
3003,ngx_http_proxy_process_trailer,"At the end of a message, a recipient MAY treat the set of received trailer fields as a data structure of name/value pairs, similar to (but separate from) the header fields.",14,Fully Matches,"[{'C1': {'code': 'for ( ;; ) {\n    rc = ngx_http_parse_header_line(r, b, 1);\n    if (rc == NGX_OK) {\n        h = ngx_list_push(&r->upstream->headers_in.trailers);\n        ...\n    }\n    if (rc == NGX_HTTP_PARSE_HEADER_DONE) {\n        ...\n    }\n    ...\n}', 'explanation': ""This loop parses trailer header lines from the buffer and pushes each parsed header into 'r->upstream->headers_in.trailers', thereby treating the trailer fields as a separate name/value mapping as specified by the RFC.""}}, {'A1': {'code': 'h = ngx_list_push(&r->upstream->headers_in.trailers);', 'explanation': 'The use of ngx_list_push() appends each trailer header in the order received, which ensures that multiple trailer field lines (even those with the same name) are handled as a list-based field. This complies with the requirement to process trailers in order and treat duplicate fields as list members.'}}]","The function 'ngx_http_proxy_process_trailer' allocates a temporary buffer, iteratively parses trailer header lines using ngx_http_parse_header_line, and appends each parsed trailer into a separate trailer list (r->upstream->headers_in.trailers). By doing so, it directly implements the RFC requirement of treating the set of trailer fields as an independent data structure of name/value pairs and preserves their order, including handling multiple instances of the same trailer header appropriately.",success,
3003,ngx_http_proxy_process_trailer,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'len = ngx_min(buf->last - buf->pos, b->end - b->last);\nif (b->last == b->end) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent too big trailers"");\n    return NGX_ERROR;\n}', 'explanation': 'This segment ensures that the copied data does not exceed the bounds of the allocated temporary buffer (configured via plcf->upstream.buffer_size). It defensively limits the buffer usage, addressing the requirement to only expect protocol elements to fit within a reasonable buffer size.'}}, {'A1': {'code': 'rc = ngx_http_parse_header_line(r, b, 1);\nif (rc == NGX_HTTP_PARSE_INVALID_HEADER) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent invalid trailer: ""%*s\\x%02xd..."""",\n                  r->header_end - r->header_name_start,\n                  r->header_name_start, *r->header_end);\n    return NGX_ERROR;\n}', 'explanation': ""This code calls a header parsing function and then handles non-conformance by logging the error and returning an error state. This reflects a defensive parsing strategy, accepting only marginally valid protocol elements in line with the RFC's guidance.""}}]","The function ngx_http_proxy_process_trailer implements a defensive parsing approach by first allocating a buffer of limited size and then carefully ensuring that any data copied into it does not exceed its boundaries. It processes the input trailer by reading each header line using a parsing function and explicitly handles cases where parsing is incomplete, successful, or invalid by returning error states or success as appropriate. This internal logic directly supports the RFC's specification to parse protocol elements defensively with only minimal expectations of conformity.",success,
3009,ngx_http_proxy_add_x_forwarded_for_variable,"A recipient MAY combine multiple field lines within a field section that have the same field name into one field line, without changing the semantics of the message, by appending each subsequent field line value to the initial field line value in order, separated by a comma ("","") and optional whitespace (OWS, defined in Section 5.6.3).",231,Fully Matches,"[{'C1': {'code': ""for (h = xfwd; h; h = h->next) {\n    p = ngx_copy(p, h->value.data, h->value.len);\n    *p++ = ','; *p++ = ' ';\n}\nngx_memcpy(p, r->connection->addr_text.data, r->connection->addr_text.len);"", 'explanation': 'The code iterates over all x_forwarded_for header lines and appends each header value in order, separating them with a comma and space ("", ""), exactly as required by the RFC specification. The order of field lines is preserved and the use of "", "" ensures consistency as described in the spec context.'}}]","The function visible within this code successfully addresses the RFC requirement by combining multiple field lines with the same header name into one line. It does so by iterating over each header, appending each value with a comma and space, and then appending the connection address. No dependencies or external logic are implicated, so the logic within the function fully implements the specified constraint.",success,
3017,ngx_http_proxy_parse_cookie,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': ""while (start < last && *start == ' ') { start++; }\n...\nwhile (name.len && name.data[name.len - 1] == ' ') { name.len--; }"", 'explanation': 'This segment trims leading and trailing whitespace from the cookie name. It is a direct implementation of removing BWS (bad whitespace) as specified in the RFC context.'}}, {'A1': {'code': ""if (p < last) {\n    p++;\n    while (p < last && *p == ' ') { p++; }\n    val.data = p;\n    val.len = last - val.data;\n    while (val.len && val.data[val.len - 1] == ' ') { val.len--; }\n}"", 'explanation': ""This segment handles the cookie value by advancing past the '=' character and then trimming leading and trailing whitespace. This meets the action requirement to remove BWS from the cookie value.""}}]","The function parses cookie header strings by splitting them on semicolons and trimming whitespace from both the name and value portions. These measures correspond directly to the RFC's requirement to remove any Bad Whitespace (BWS) before further processing, demonstrating that the function itself implements the specified BWS removal behavior.",success,
3017,ngx_http_proxy_parse_cookie,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,"[{'C1': {'code': ""while (start < last && *start == ' ') { start++; }\n...\nwhile (name.len && name.data[name.len - 1] == ' ') { name.len--; }\n...\nwhile (p < last && *p == ' ') { p++; }\n...\nwhile (val.len && val.data[val.len - 1] == ' ') { val.len--; }"", 'explanation': ""The function explicitly trims leading and trailing space characters when parsing cookie attribute names and values. This demonstrates an effort to remove the bad whitespace as required by the spec. However, the code only accounts for the ASCII space ' ' rather than all possible whitespace characters (such as tabs) defined as OWS/RWS in the RFC.""}}]","The function attempts to implement the RFC requirement by removing extraneous whitespace before interpreting cookie attributes. Its use of loops to skip leading spaces and trim trailing spaces partially meets the spec constraint of eliminating bad whitespace. However, because it exclusively targets the space character and does not handle other forms of whitespace or the full semantic distinctions (OWS, RWS, BWS) provided in the specification context, the implementation is only a partial match.",success,
3017,ngx_http_proxy_parse_cookie,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': ""while (start < last && *start == ' ') { start++; }\n...\nwhile (name.len && name.data[name.len - 1] == ' ') { name.len--; }\n...\nwhile (p < last && *p == ' ') { p++; }\n...\nwhile (val.len && val.data[val.len - 1] == ' ') { val.len--; }"", 'explanation': 'The code explicitly removes leading spaces before parsing the key and value, and trims trailing spaces after extraction. This directly addresses the RFC requirement to exclude extraneous whitespace from the field value prior to its evaluation.'}}]","The function implements the required whitespace exclusion by stripping spaces from both the beginning and end of the HTTP header field components (cookie name and value). Although it only checks for the space character, within the context of cookie parsing this fulfills the specification requirement to remove unwanted whitespace before evaluation. All trimming operations are performed inside the function, so this implementation fully matches the spec constraint as stated.",success,
3030,ngx_http_proxy_init_headers,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'C1': {'code': 'while (h->key.len) {\n    src = headers_merged.elts;\n    for (i = 0; i < headers_merged.nelts; i++) {\n        if (ngx_strcasecmp(h->key.data, src[i].key.data) == 0) {\n            goto next;\n        }\n    }\n\n    s = ngx_array_push(&headers_merged);\n    if (s == NULL) {\n        return NGX_ERROR;\n    }\n\n    *s = *h;\n\nnext:\n    h++;\n}', 'explanation': 'This segment merges default headers and explicitly avoids appending a default header if one with the same name (case‑insensitively) is already present. This is an effort by the function to obey the RFC requirement that a sender MUST NOT generate duplicate field lines for a header, although it only checks default headers and does not prevent duplicates that might already exist in headers_source.'}}]","The function demonstrates an attempt to enforce the RFC's rule by not adding duplicate default header fields if one with the same name is already present in the merged header array. However, because it does not check for duplicate headers originating from headers_source (which may already include multiple entries for the same header name), the implementation only partially meets the specified RFC constraint. No additional logic is observed within the function for handling the exception that allows multiple values to be merged, nor is there a mechanism to enforce ordering as required for proxy behavior; hence, the overall match is partial.",success,
3041,ngx_http_proxy_set_vars,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Does Not Match,[],"The RFC specification requires that a sender MUST NOT generate an 'http' URI with an empty host identifier. In the function, the host is directly assigned to v->host_header without checking if u->host is empty, and no validation is performed to ensure that the host identifier is non-empty. Therefore, the function does not address the constraint (labeled here as C1) that ensures a non-empty host, so it does not meet the spec.",success,
3041,ngx_http_proxy_set_vars,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'if (u->no_port || u->port == u->default_port) {\n\n    v->host_header = u->host;\n\n    if (u->default_port == 80) {\n        ngx_str_set(&v->port, ""80"");\n    } else {\n        ngx_str_set(&v->port, ""443"");\n    }\n\n} else {\n    v->host_header.len = u->host.len + 1 + u->port_text.len;\n    v->host_header.data = u->host.data;\n    v->port = u->port_text;\n}', 'explanation': 'This section checks whether a port was provided (using the u->no_port flag or comparing u->port with u->default_port), and if not, it assigns the default port based on u->default_port (either 80 or 443). This implementation directly addresses the RFC requirement that if a port is not provided, it should be interpreted as having been received on the default port.'}}]","The function ngx_http_proxy_set_vars incorporates explicit logic for handling when a port is not provided by checking the u->no_port flag and comparing the provided port to the default. Upon detecting that no explicit port was given, it assigns a default port value appropriate for the protocol (80 for HTTP and 443 otherwise). This behavior fully meets the RFC specification regarding default port interpretation, and no other spec constraint is expected to be handled by this function alone.",success,
3046,ngx_http_gzip_static_handler,"In 200 responses to GET or HEAD, an origin server SHOULD send any available validator fields (Section 8.8) for the selected representation, with both a strong entity tag and a Last-Modified date being preferred.",141,Fully Matches,"[{'C1': {'code': 'if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {\n        return NGX_DECLINED;\n    }', 'explanation': 'This segment verifies the HTTP method is GET or HEAD, ensuring the function only processes requests that require validator fields according to the RFC.'}}, {'A1': {'code': 'r->headers_out.last_modified_time = of.mtime;\nif (ngx_http_set_etag(r) != NGX_OK) {\n    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n}', 'explanation': 'This segment sets the Last-Modified time and calls ngx_http_set_etag to set the ETag header, thereby providing the available validator fields as preferred by the RFC.'}}]","The function first checks that the request method is GET or HEAD and then goes on to set a 200 response while explicitly assigning the Last-Modified header and invoking the helper to set the ETag header. These actions directly implement the specification's recommendation to send any available validator fields in 200 responses, thereby fully matching the given HTTP RFC requirements within this function.",success,
3046,ngx_http_gzip_static_handler,"An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",270,Does Not Match,[],"The provided function is designed to serve static gzipped files for GET and HEAD requests. While it does handle HEAD requests by sending headers and, in the case of a HEAD request (as seen with the check on r->header_only), not sending a body, it does not directly implement any logic related to the specific RFC requirement regarding not relying on private agreements to receive content. There is also no explicit handling that ensures the server sends the same header fields for HEAD as it would for GET beyond the usual header-setting logic. Therefore, none of the labeled conditions or actions from the RFC spec (e.g., C1, A1) are visibly addressed in the function_body itself.",success,
3046,ngx_http_gzip_static_handler,"If one or more encodings have been applied to a representation, the sender that applied the encodings MUST generate a Content-Encoding header field that lists the content codings in the order in which they were applied.",37,Fully Matches,"[{'C1': {'code': 'h = ngx_list_push(&r->headers_out.headers);\nif (h == NULL) {\n    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n}\n\nh->hash = 1;\nh->next = NULL;\nngx_str_set(&h->key, ""Content-Encoding"");\nngx_str_set(&h->value, ""gzip"");\nr->headers_out.content_encoding = h;', 'explanation': ""This segment explicitly creates and sets the Content-Encoding header with the value 'gzip'. Since the RFC requires that if one or more encodings are applied the header must list the applied codings (in the order they were applied), and in this context only a single encoding (gzip) is applied, the code meets the specification.""}}]","The function identifies a GET/HEAD request, verifies the static gzip configuration and maps a corresponding .gz file. It then sends a response while explicitly creating a 'Content-Encoding' header with the value 'gzip'. Since only one encoding is applied here, the requirement to list applied content codings in order is inherently satisfied. Therefore, within its scope the function fully meets the RFC specification.",success,
3046,ngx_http_gzip_static_handler,"An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",268,Fully Matches,"[{'C1': {'code': 'rc = ngx_http_discard_request_body(r);', 'explanation': 'The function explicitly discards the request body for GET (and HEAD) requests. By doing so, it does not process or rely on any provided content, thereby avoiding any dependence on private agreements for receiving content. This aligns with the RFC specification stating that an origin server SHOULD NOT rely on private agreements to receive content.'}}]","The primary concern in the spec is that content in a GET request should not be processed based on any private agreements. This function first restricts the method to GET and HEAD and, if necessary, discards any request body using ngx_http_discard_request_body(r). By doing so, it fully addresses the condition set out in the spec. All logic that enforces this behavior is self-contained within the function, which means that it visibly conforms to the requirement.",success,
3046,ngx_http_gzip_static_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,"[{'A1': {'code': 'if (ngx_http_set_content_type(r) != NGX_OK) {\n    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n}', 'explanation': 'This code segment calls ngx_http_set_content_type(r) before sending the response. It attempts to set the Content-Type header field as specified by the RFC requirement for messages containing content. However, it does so unconditionally without checking if the media type is unknown, which is an aspect of the specification.'}}]","The RFC requires that a sender should generate a Content-Type header when sending a message with content, unless the intended media type of the enclosed representation is unknown. In this function, the call to ngx_http_set_content_type(r) is the visible implementation that addresses this requirement. However, there is no clear logic within this function to handle the exceptional case where the media type might be unknown. As a result, while the function does attempt to implement the generation of the Content-Type header (meeting part of the RFC specification), it does not fully address the conditional logic the RFC describes, leading to a 'Partially Matches' outcome.",success,
3062,ngx_http_upstream_free_keepalive_peer,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'if (!u->keepalive) {\n    goto invalid;\n}\n...\nitem->connection = c;\nc->idle = 1;', 'explanation': 'The function checks whether keepalive is enabled and, if so, caches the connection (marking it as idle) for reuse. This implements the intent of sustaining persistent connections.'}}, {'A1': {'code': 'if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n    goto invalid;\n}', 'explanation': 'By ensuring that the read event handler is set correctly and only proceeding if the event handling succeeds, the function hints at leveraging underlying transport mechanisms. However, this is only part of addressing the flow‐control aspect mentioned in the spec.'}}]","The RFC requires that a server sustain persistent connections and use underlying transport flow control rather than prematurely terminating connections. This code function implements logic for reusing valid keepalive connections by checking for errors and caching connections marked as idle. It also calls ngx_handle_read_event to try to ensure that the connection’s readiness is properly managed. Nonetheless, it does not explicitly implement all aspects of flow-control resolution nor does it monitor for errors during message body transmission as described in the full spec context. Therefore, while it visibly addresses part of the requirements (persistent connection reuse and basic event handling), it only partially matches the overall specification.",success,
3062,ngx_http_upstream_free_keepalive_peer,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'C1': {'code': 'if (!u->keepalive) {\n    goto invalid;\n}', 'explanation': 'This code explicitly checks whether the upstream configuration supports keepalive connections, thereby ensuring that only persistent (keepalive) connections are used as per the HTTP persistent connection requirement.'}}, {'A1': {'code': 'ngx_queue_insert_head(&kp->conf->cache, q);\n\nitem->connection = c;\n\nc->idle = 1;', 'explanation': 'This segment recycles a valid connection by caching it for later reuse. By reusing open connections (i.e., keeping them idle and ready), the function implements the persistent connection mechanism mandated by the HTTP spec.'}}]","The function 'ngx_http_upstream_free_keepalive_peer' checks for various error conditions and validates that a connection qualifies for keepalive reuse (for example, by checking if the keepalive flag is enabled in the upstream configuration and ensuring the connection hasn’t exceeded configured request/time limits). When the connection is valid, it is inserted into a keepalive cache, effectively enabling persistent connections. This logic directly addresses the specification requirement that HTTP implementations should support persistent connections.",success,
3065,ngx_http_upstream_keepalive_close,Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection.,325,Does Not Match,[],"The RFC requires that the server must attempt to initiate an exchange of closure alerts with the client before closing the connection. In the provided function, when an SSL connection is present, the code explicitly sets 'no_send_shutdown' (and 'no_wait_shutdown') to 1, which disables sending a shutdown (closure alert) message. Although the function calls 'ngx_ssl_shutdown', the disabling flags prevent the initiation of a closure alert exchange. As such, the function does not address the spec constraint within its own logic.",success,
3082,ngx_http_scgi_handler,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': '#if (NGX_HTTP_CACHE)\n    smcf = ngx_http_get_module_main_conf(r, ngx_http_scgi_module);\n\n    u->caches = &smcf->caches;\n    u->create_key = ngx_http_scgi_create_key;\n#endif', 'explanation': 'This portion of the code sets up caching for the upstream if caching support is enabled, addressing the part of the RFC that allows a cache to be employed.'}}]","The provided function attempts to implement a caching mechanism, which corresponds to the RFC allowance that any client or server MAY use a cache, as evidenced by the caching-related block. However, the RFC also specifies that a cache cannot be used while acting as a tunnel, and there is no logic in this function that explicitly checks for or disables cache usage in tunnel mode. Therefore, while the caching allowance is implemented, the tunnel condition is not addressed within the function, resulting in a partial match with the RFC.",success,
3092,ngx_http_scgi_process_header,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'for ( ;; ) {\n    rc = ngx_http_parse_header_line(r, &r->upstream->buffer, 1);\n    if (rc == NGX_OK) {\n        // process a header line and add it to r->upstream->headers_in.headers\n        ...\n    }\n\n    if (rc == NGX_HTTP_PARSE_HEADER_DONE) {\n        // complete header processing, including interpreting status from headers\n        ...\n    }\n    ...\n}', 'explanation': 'This segment shows that the function is continuously parsing received header lines and interpreting their contents (including status codes) as specified by the protocol. It is directly handling protocol element interpretation in its own body, which addresses a core requirement from the spec.'}}, {'A1': {'code': 'if (rc == NGX_HTTP_PARSE_INVALID_HEADER) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent invalid header: \\""%*s\\x%02xd...\\"""",\n                  r->header_end - r->header_name_start,\n                  r->header_name_start, *r->header_end);\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': ""When an invalid header construct is encountered, this piece of code logs an error and returns an error status. This reflects the spec's note that a recipient MAY attempt to recover or take specific actions in response to invalid constructs, though here the recovery is limited to error reporting.""}}]","The function implements part of the RFC requirement by actively parsing and interpreting protocol header elements, including processing individual header lines to extract status information. It also handles error conditions when an invalid header is detected. However, it does not implement logic (such as checking experience or configuration) to determine if the sender’s implementation is incorrect before deciding to ignore or correct problematic header fields, which limits the function’s fulfillment of the complete specification. Therefore, the code only partially matches the RFC constraints as expressed.",success,
3092,ngx_http_scgi_process_header,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (rc == NGX_HTTP_PARSE_INVALID_HEADER) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent invalid header: ""%*s\\x%02xd..."""",\n                  r->header_end - r->header_name_start, r->header_name_start, *r->header_end);\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': 'This segment shows that the function detects invalid header syntax and handles it by logging an error and returning an error code. This defensive check corresponds to the RFC’s suggestion to parse protocol elements defensively with minimal expectations regarding full ABNF compliance.'}}]","The function attempts to parse SCGI headers by repeatedly calling a helper to process header lines, and it checks the outcomes of these parse attempts. In doing so, it defensively handles errors (e.g. by detecting invalid headers and logging an error) which partially meets the RFC requirement for defensive parsing. However, the function does not incorporate explicit checks for buffer size or enforce a 'reasonable' length limit within its own logic; it relies on external functions and upstream expectations for that behavior. As a result, only part of the specification—namely, the defensive parsing aspect—is visibly implemented in the function, leading to a 'Partially Matches' outcome.",success,
3093,ngx_http_scgi_input_filter_init,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,61,Fully Matches,"[{'A1': {'code': 'else if (r->method == NGX_HTTP_HEAD) {\n    u->pipe->length = -1;\n    u->length = -1;\n}', 'explanation': 'This code segment directly checks for the HEAD method and sets the content length values to -1, which in the context of this function ensures that no response body (content) is processed. This behavior aligns with the RFC requirement that a HEAD request must not include content.'}}]","The provided function inspects the incoming request's method. In the else-if branch, it checks if the method is HEAD, and if so, it sets both u->pipe->length and u->length to -1. This effectively implements the RFC-specified behavior where a HEAD request should follow the same processing as a GET request but must not return a response body. Thus, within its scope, the function clearly implements the spec's constraint regarding the HEAD method.",success,
3093,ngx_http_scgi_input_filter_init,"However, a server MAY omit header fields for which a value is determined only while generating the content.",269,Fully Matches,"[{'C1': {'code': 'if (u->headers_in.status_n == NGX_HTTP_NO_CONTENT\n        || u->headers_in.status_n == NGX_HTTP_NOT_MODIFIED)\n    {\n        u->pipe->length = 0;\n        u->length = 0;\n    }', 'explanation': 'This segment handles responses (such as 204 No Content or 304 Not Modified) that should not have a body. By setting both u->pipe->length and u->length to 0, the function ensures that any header fields whose values are determined during content generation can be omitted, as allowed by the RFC.'}}, {'A1': {'code': 'else if (r->method == NGX_HTTP_HEAD) {\n        u->pipe->length = -1;\n        u->length = -1;\n    }', 'explanation': 'This segment directly implements the HEAD method requirement. In a HEAD request, no response content should be sent. By setting lengths to -1, the function avoids relying on content length that is determined during content generation, thereby aligning with the RFC’s suggestion to possibly omit such header fields.'}}]","The function clearly distinguishes between responses that have content and those that do not. It specifically checks if the response status indicates no content or if the request is a HEAD request, and sets the content length values accordingly. This behavior adheres to the RFC specification which permits the omission of header fields that are computed during content generation, particularly when handling HEAD requests.",success,
3097,ngx_http_scgi_create_loc_conf,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided function only initializes configuration parameters for upstream connections including caching-related fields (e.g., conf->upstream.cache and related settings) when compiled with NGX_HTTP_CACHE. However, it does not contain any logic that implements the specific RFC requirement that a cache cannot be used while acting as a tunnel, nor does it address conditions or actions regarding cache usage. Thus, within this function, there is no visible implementation directly corresponding to the spec constraints.",success,
3128,ngx_http_ssi_header_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'ngx_http_clear_content_length(r);', 'explanation': ""This call is used in the function when processing the main request, which clears the Content-Length header field. In doing so, the function avoids forwarding a Content-Length header that might be incorrect. This directly relates to the spec's requirement that a sender MUST NOT forward a message having a Content-Length value that is known or likely to be incorrect. However, the function does not validate the header value itself nor handle scenarios like duplicate comma‐separated values, and it only performs this action unconditionally in the main branch.""}}]","The provided function makes an effort to comply with the HTTP RFC in that it clears the Content-Length header (via ngx_http_clear_content_length(r)) when processing the main request, thereby preventing the forwarding of a potentially invalid Content-Length. However, it does not perform any checks to ascertain if the header was actually incorrect or deal with other aspects such as duplicate values. As such, while the function does implement part of the spec’s action (A1) by removing the Content-Length header, it does not fully implement the entire RFC requirement, leading to a partial match.",success,
3142,ngx_http_ssi_stub_output,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'if (!r->header_sent) {\n    r->headers_out.content_type_len = r->parent->headers_out.content_type_len;\n    r->headers_out.content_type = r->parent->headers_out.content_type;\n\n    if (ngx_http_send_header(r) == NGX_ERROR) {\n        return NGX_ERROR;\n    }\n}', 'explanation': ""This code block ensures that when the message is being sent and headers have not yet been emitted, the Content-Type header is explicitly copied from the parent's configuration and sent. This directly implements the RFC requirement that a message with content should include a Content-Type header, provided the media type is known.""}}]","The function 'ngx_http_ssi_stub_output' contains logic that, prior to transmitting the output, checks if the HTTP headers have already been sent. If not, it sets the Content-Type header by copying it from its parent's headers and then sends the header. This directly addresses the core requirement from the RFC specification regarding the inclusion of a Content-Type header in messages that contain content. Even though it does not explicitly handle the case where the media type is unknown (by, for example, deciding not to set the header), relying on the parent's already-determined Content-Type is a valid strategy and thus fully implements the intended behavior as per the spec.",success,
3186,ngx_http_memcached_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,"[{'A1': {'code': 'if (ngx_http_set_content_type(r) != NGX_OK) {\n    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n}', 'explanation': 'This code invokes the function to set the Content-Type header field, thereby attempting to generate the header as specified by the RFC. However, it does not check whether the media type is unknown before generating the header, which is a conditional aspect of the RFC.'}}]","The function attempts to implement the RFC requirement by generating a Content-Type header via a call to ngx_http_set_content_type(r). This matches the intended action if the media type is known. However, there is no conditional logic to handle the case where the intended media type is unknown. Since only part of the specification is directly addressed in the function, the overall match is classified as 'Partially Matches.'",success,
3186,ngx_http_memcached_handler,All general-purpose servers MUST support the methods GET and HEAD,58,Fully Matches,"[{'C1': {'code': 'if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {\n    return NGX_HTTP_NOT_ALLOWED;\n}', 'explanation': ""This code snippet directly checks that the request method is either GET or HEAD and returns a 'Not Allowed' response if it is not. This ensures that the server supports GET and HEAD as required by the RFC.""}}]","The function explicitly validates that only GET and HEAD methods are handled by using a bitwise check against these methods. If the method doesn't match, it returns NGX_HTTP_NOT_ALLOWED, directly implementing the RFC's requirement that all general-purpose servers must support GET and HEAD. No additional conditions from the spec are applicable here within the function, so it fully meets the relevant constraint.",success,
3186,ngx_http_memcached_handler,"An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",60,Fully Matches,"[{'C1': {'code': 'if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {\n    return NGX_HTTP_NOT_ALLOWED;\n}', 'explanation': 'This code segment checks whether the incoming request method is not GET or HEAD. Since GET and HEAD are the only supported methods in this handler (as per the sr_context stating these methods are mandatory), any other method is treated as not allowed and the function returns a 405 status code (NGX_HTTP_NOT_ALLOWED), fulfilling the RFC requirement for handling recognized but not allowed methods.'}}]","The function explicitly permits only GET and HEAD requests. For any incoming request with a method outside of these two, it immediately returns a 405 (Method Not Allowed), which directly addresses the RFC specification stating that a recognized and implemented method that is not allowed should result in a 405 response. All relevant logic is contained within this function, ensuring that the behavior complies with the specification provided.",success,
3187,ngx_http_memcached_create_request,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Fully Matches,"[{'C1': {'code': '*b->last++ = CR; *b->last++ = LF;', 'explanation': 'The function explicitly writes a CR followed immediately by an LF at the end of the request. This ensures that a CR is never generated without an immediately following LF, which matches the RFC requirement that a sender MUST NOT generate a bare CR.'}}]","The function creates the memcached GET command by first assembling the key (with proper URI escaping to handle unsafe characters) and then appending the command terminator using '*b->last++ = CR; *b->last++ = LF;'. This guarantees there is no instance of a bare CR within the protocol element. In this way, the function visibly addresses the RFC constraint regarding bare CR characters, fulfilling the requirement by itself.",success,
3189,ngx_http_memcached_reinit_request,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,44,Does Not Match,[],"The function ngx_http_memcached_reinit_request only returns NGX_OK without any logic regarding the setting or checking of the Content-Length header field as specified in the RFC. There is no handling of any conditions or actions such as those pertaining to status codes (e.g., 304, 1xx, 204, CONNECT) or the decimal value of Content-Length. Therefore, this function does not attempt to implement any of the specified constraints by itself.",success,
3190,ngx_http_memcached_process_header,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Does Not Match,[],"The provided function always parses and sets a Content-Length value (via 'u->headers_in.content_length_n = ngx_atoof(...)') for responses that it processes, and it explicitly sets the status code to 200 (or 404 in the 'END' case). There is no conditional check to omit the Content-Length header for status codes 1xx or 204. Consequently, the function does not implement the requirement stated in the HTTP RFC spec for these status codes.",success,
3190,ngx_http_memcached_process_header,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (ngx_strncmp(p, ""VALUE "", sizeof(""VALUE "") - 1) == 0) {\n    p += sizeof(""VALUE "") - 1;\n    if (ngx_strncmp(p, ctx->key.data, ctx->key.len) != 0) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""memcached sent invalid key in response \\""%V\\"" for key \\""%V\\"""",\n                      &line, &ctx->key);\n\n        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n    }\n    p += ctx->key.len;\n    if (*p++ != \' \') {\n        goto no_valid;\n    }\n    /* further parsing follows ... */\n}', 'explanation': ""This segment checks that the response begins with the expected 'VALUE ' prefix and validates that the returned key matches the expected key. In doing so, it is interpreting the protocol element in accordance with the semantics defined by the specification.""}}, {'A1': {'code': 'if (flags & mlcf->gzip_flag) {\n    h = ngx_list_push(&r->headers_out.headers);\n    if (h == NULL) {\n        return NGX_ERROR;\n    }\n\n    h->hash = 1;\n    h->next = NULL;\n    ngx_str_set(&h->key, ""Content-Encoding"");\n    ngx_str_set(&h->value, ""gzip"");\n    r->headers_out.content_encoding = h;\n}', 'explanation': ""When a gzip flag is detected in the response, this piece of code adds a 'Content-Encoding: gzip' header. This shows an attempt to extend the protocol semantics by handling additional content codings as allowed by the specification.""}}]","The function processes a memcached response header by interpreting its structure and content in a way that aligns with the RFC’s requirement to interpret received protocol elements according to defined semantics. It validates the response format (e.g., checking for CR before LF and verifying the key) and even handles an extension (gzip content encoding). However, if the protocol element is not perfectly formed (for example, missing a carriage return or an invalid format), the function does not attempt to recover a usable construct; it immediately logs an error and returns an error code. Therefore, while the function implements key aspects of the specification’s interpretation requirement (C1 and an extension via A1), its error handling does not fully embrace the 'attempt to recover' guideline mentioned in the RFC context. This leads to a partial rather than a full match.",success,
3190,ngx_http_memcached_process_header,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (line.len == 0 || *(p - 1) != CR) {\n    goto no_valid;\n}', 'explanation': 'This code checks that the received protocol element (the header line) is not empty and ends with CR before the LF, showing an attempt to defensively verify minimal protocol formatting as per the RFC.'}}, {'A1': {'code': 'ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n              ""memcached sent invalid response: \\""%V\\"""", &line);\n\nreturn NGX_HTTP_UPSTREAM_INVALID_HEADER;', 'explanation': 'This segment logs an error and returns an error code when the input does not meet expected formatting, demonstrating defensive error handling as recommended by the RFC.'}}]","The function implements defensive parsing by scanning for a terminating LF, verifying that the header line ends with a CR, and by logging errors and returning error codes when the protocol element does not conform to expectations. These checks correspond to a minimal defensive parsing approach (C1 and A1). However, while it guards against certain malformed inputs, it does not fully address all aspects of the RFC—such as enforcing a reasonable buffer size or fully validating against the ABNF grammar—thus the function only partially meets the defensive parsing spec.",success,
3190,ngx_http_memcached_process_header,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specifies that within a message the sender MUST NOT generate protocol elements or syntax alternatives that are reserved for other roles. The provided function is dedicated to processing and validating the memcached response header (e.g., checking for a proper ""VALUE "" prefix, verifying the key, parsing flags and length, and handling the ""END"" response) and does not generate protocol elements based on the sender’s role. It performs syntax checks on an incoming message but does not implement logic ensuring that it refrains from generating elements that are only allowed for other roles. As such, there is no visible code within this function that addresses the RFC’s role-based sender constraints.",success,
3190,ngx_http_memcached_process_header,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Does Not Match,[],"The RFC specifies that a sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field. In the provided function, there is logic to parse and process a Content-Length value from a memcached response. However, the function does not include any condition or check for the presence of a Transfer-Encoding header field, nor does it attempt to prevent sending a Content-Length header when Transfer-Encoding is present. Therefore, this function does not fulfill the RFC's requirement within its own code.",success,
3190,ngx_http_memcached_process_header,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Does Not Match,[],"The RFC states that although the line terminator is CRLF, a recipient MAY recognize a single LF as a valid terminator and ignore any preceding CR. However, in this function the code explicitly requires that the character preceding LF must be CR (as seen in the check: if (line.len == 0 || *(p - 1) != CR)), and if not, it treats the line as invalid. This means the function does not implement the flexibility provided by the RFC for accepting a bare LF as a terminator, and no alternative logic (like ignoring a lone CR) is present within the function. Thus, in isolation, the function does not fully address the RFC constraints.",success,
3190,ngx_http_memcached_process_header,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'C1': {'code': 'start = p;\np = line.data + line.len;\n\nu->headers_in.content_length_n = ngx_atoof(start, p - start);\nif (u->headers_in.content_length_n == NGX_ERROR) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""memcached sent invalid length in response \\""%V\\"" for key \\""%V\\"""",\n                  &line, &ctx->key);\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': 'This segment converts the string value to a numeric Content-Length. If the conversion fails (indicating that the Content-Length header value is incorrect), the function logs an error and returns an error status, thereby not forwarding the message. This directly addresses the RFC requirement to not forward messages with known incorrect Content-Length headers.'}}]","The function examines the memcached response and validates the Content-Length value by attempting to convert it into a number. If the conversion fails, it treats the Content-Length as incorrect and aborts further processing by returning an error, which prevents the forwarding of a message with an invalid header field. However, while it rejects clearly invalid values, it does not implement the additional nuance of handling duplicate (comma-separated) Content-Length values as allowed by the exception in the RFC. Thus, the function partially matches the RFC constraint as it covers the basic check to reject incorrect values but does not fully incorporate all exception handling detailed in the RFC.",success,
3190,ngx_http_memcached_process_header,"If one or more encodings have been applied to a representation, the sender that applied the encodings MUST generate a Content-Encoding header field that lists the content codings in the order in which they were applied.",37,Partially Matches,"[{'A1': {'code': 'if (flags & mlcf->gzip_flag) {\n            h = ngx_list_push(&r->headers_out.headers);\n            if (h == NULL) {\n                return NGX_ERROR;\n            }\n\n            h->hash = 1;\n            h->next = NULL;\n            ngx_str_set(&h->key, ""Content-Encoding"");\n            ngx_str_set(&h->value, ""gzip"");\n            r->headers_out.content_encoding = h;\n        }', 'explanation': ""This code block checks if the gzip encoding flag is present and, if so, creates a Content-Encoding header with the value 'gzip'. This partially implements the RFC requirement which mandates that a Content-Encoding header be generated if one or more encodings have been applied. However, it only handles a single encoding (gzip) and does not address the ordering of multiple encodings or filter out the reserved 'identity' coding.""}}]","The function contains logic to detect if a gzip encoding has been applied (by checking the flag) and then sets the appropriate Content-Encoding header. This addresses part of the RFC requirement. However, it does not have any mechanism to handle multiple encodings or maintain the specific order of applied encodings, nor does it account for the 'identity' value. Thus, the implementation only partially meets the specified RFC constraints by handling a specific case rather than the general requirement.",success,
3191,ngx_http_memcached_filter_init,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Partially Matches,"[{'A1': {'code': 'if (u->headers_in.status_n != 404) {\n    u->length = u->headers_in.content_length_n + NGX_HTTP_MEMCACHED_END;\n    ctx->rest = NGX_HTTP_MEMCACHED_END;\n} else {\n    u->length = 0;\n}', 'explanation': ""This code branch sets a defined message length when the response status is not 404 by adding a terminating constant (NGX_HTTP_MEMCACHED_END) to the Content-Length header value. This indicates an attempt to generate a length-delimited message, which is in line with the RFC's recommendation that a server SHOULD generate encoding or length-delimited messages whenever possible. However, the function does not handle the full range of conditions specified in the RFC (such as checking Transfer-Encoding, handling invalid Content-Length headers or network interruptions), so only part of the specification is addressed within this function.""}}]","The function implements a mechanism to set the message length for a non-error (non-404) response, thereby enabling length-delimited message framing as encouraged by the RFC. Despite this, it does not cover additional requirements such as handling missing or invalid Transfer-Encoding and Content-Length headers, or differentiating between complete and incomplete transmissions. Thus, while some aspects of the specification are visible in the function, it only partially matches the full constraints and actions detailed in the RFC.",success,
3192,ngx_http_memcached_filter,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The provided function is a memcached filter that validates an expected string pattern in the trailer of a memcached response and logs an error if the received trailer does not match the expected pattern. However, it does not implement any logic related to merging trailer fields into header sections or verifying that trailer field definitions explicitly permit safe merging as required by the specified HTTP RFC. The function does not contain code that checks whether the recipient understands the corresponding header definitions or defines how trailer field values can be safely merged. Therefore, no spec constraints (e.g., C1, A1) are addressed within this function.",success,
3206,ngx_http_auth_basic_handler,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Does Not Match,[],"The RFC specification relates to parsing HTTP messages, particularly how CR and LF are handled as line terminators. Although the code does check for CR and LF characters, it does so in the context of reading and parsing a user credentials file for basic authentication. There is no logic here that implements HTTP message parsing as required by the RFC — for example, to recognize a single LF as a line terminator and ignore any preceding CR in the HTTP start-line or header fields. Thus, within the scope of this function, none of the labeled conditions or actions from the spec constraints are visibly implemented.",success,
3208,ngx_http_auth_basic_set_realm,"Upon receipt of a request for a protected resource that omits credentials, contains invalid credentials (e.g., a bad password) or partial credentials (e.g., when the authentication scheme requires more than one round trip), an origin server SHOULD send a 401 (Unauthorized) response that contains a WWW-Authenticate header field with at least one (possibly new) challenge applicable to the requested resource.",91,Partially Matches,"[{'A1': {'code': 'r->headers_out.www_authenticate = ngx_list_push(&r->headers_out.headers);\n...\nngx_str_set(&r->headers_out.www_authenticate->key, ""WWW-Authenticate"");\n...\nreturn NGX_HTTP_UNAUTHORIZED;', 'explanation': 'The function constructs a \'WWW-Authenticate\' header with the challenge \'Basic realm=""<realm>""\' and returns a 401 (Unauthorized) response code. This directly implements the action of sending a challenge header as specified by the RFC.'}}]","The HTTP spec requires that when credentials are missing, invalid, or partial, the server responds with a 401 response and includes a 'WWW-Authenticate' header containing a challenge. This function sets the header with the provided realm and returns a 401 status, thereby addressing the transmission of the challenge (Action A1). However, it does not evaluate whether credentials are missing or invalid (the condition triggering this response), which likely occurs in other parts of the system. Thus, while the function implements the action of sending the appropriate challenge header, it does not cover all of the specified conditions by itself, resulting in a partial match.",success,
3208,ngx_http_auth_basic_set_realm,The server generating a 401 response MUST send a WWW-Authenticate header field (Section 11.6.1) containing at least one challenge applicable to the target resource.,162,Fully Matches,"[{'C1': {'code': 'r->headers_out.www_authenticate = ngx_list_push(&r->headers_out.headers);\n...\nngx_str_set(&r->headers_out.www_authenticate->key, ""WWW-Authenticate"");\n\nbasic = ngx_pnalloc(r->pool, len);\n...\np = ngx_cpymem(basic, ""Basic realm=\\"""", sizeof(""Basic realm=\\"""") - 1);\np = ngx_cpymem(p, realm->data, realm->len);\n*p = \'""\';\n\nr->headers_out.www_authenticate->value.data = basic;\nr->headers_out.www_authenticate->value.len = len;', 'explanation': 'The function explicitly creates and sets the WWW-Authenticate header with a challenge in the form \'Basic realm=""<realm>""\', which complies with the RFC requirement to include at least one authentication challenge.'}}, {'A1': {'code': 'return NGX_HTTP_UNAUTHORIZED;', 'explanation': 'By returning NGX_HTTP_UNAUTHORIZED, the function ensures that a 401 Unauthorized status code is sent, fulfilling the status code requirement of the spec.'}}]",The function constructs the WWW-Authenticate header with the proper challenge and returns the 401 Unauthorized response. This demonstrates that it fully addresses the RFC specification by implementing both the inclusion of the WWW-Authenticate header (C1) and the correct HTTP status code (A1) solely within the function's logic.,success,
3208,ngx_http_auth_basic_set_realm,"For historical reasons, a sender MUST only generate the quoted-string syntax.",277,Fully Matches,"[{'C1': {'code': 'p = ngx_cpymem(basic, ""Basic realm=\\"""", sizeof(""Basic realm=\\"""") - 1);\np = ngx_cpymem(p, realm->data, realm->len);\n*p = \'""\';', 'explanation': 'The function constructs the WWW-Authenticate header by explicitly using a quoted-string syntax for the realm value. It copies \'Basic realm=""\' into the output buffer, appends the realm data, and then appends the closing quote, thereby ensuring that only the quoted-string syntax is used, as required by the RFC.'}}]","The provided code function explicitly builds the authentication header value in the format 'Basic realm=""<realm>""'. This directly enforces the RFC's mandate that the sender MUST only generate the quoted-string syntax. No alternative representations (such as a token format) are generated within this function, meaning it fully addresses the provided spec constraint.",success,
3208,ngx_http_auth_basic_set_realm,A server generating a 401 (Unauthorized) response MUST send a WWW-Authenticate header field containing at least one challenge.,92,Fully Matches,"[{'C1': {'code': 'r->headers_out.www_authenticate = ngx_list_push(&r->headers_out.headers);\n...\nngx_str_set(&r->headers_out.www_authenticate->key, ""WWW-Authenticate"");\n r->headers_out.www_authenticate->value.data = basic;\n r->headers_out.www_authenticate->value.len = len;\n return NGX_HTTP_UNAUTHORIZED;', 'explanation': 'This function explicitly creates a WWW-Authenticate header containing a \'Basic\' authentication challenge by formatting the header value as ""Basic realm=\\""<realm>\\"""" and then returns a 401 (Unauthorized) status. This directly implements the RFC requirement that a 401 response MUST include a WWW-Authenticate header with at least one challenge.'}}]","The code function allocates and sets a WWW-Authenticate header with a valid Basic authentication challenge and then returns the 401 Unauthorized status. All the necessary steps (allocating the header, setting its key and value properly, and ensuring it is included in the response) are performed within the function, thereby fully addressing the specified RFC requirement.",success,
3208,ngx_http_auth_basic_set_realm,A server MAY generate a WWW-Authenticate header field in other response messages to indicate that supplying credentials (or different credentials) might affect the response.,93,Fully Matches,"[{'C1': {'code': 'r->headers_out.www_authenticate = ngx_list_push(&r->headers_out.headers);\n...\nngx_str_set(&r->headers_out.www_authenticate->key, ""WWW-Authenticate"");\n...\nngx_cpymem(basic, ""Basic realm=\\"""", sizeof(""Basic realm=\\"""") - 1);\nngx_cpymem(p, realm->data, realm->len);\n*p = \'""\';', 'explanation': 'This code segment creates and initializes the \'WWW-Authenticate\' header, setting it to a challenge of the form ""Basic realm=\\""<realm>\\"""". This meets the requirement that a server must include at least one challenge in 401 Unauthorized responses.'}}, {'A1': {'code': 'return NGX_HTTP_UNAUTHORIZED;', 'explanation': ""By returning NGX_HTTP_UNAUTHORIZED, the function ensures that the response status is 401, which in combination with the constructed WWW-Authenticate header fulfills the spec's mandate for generating a challenge in unauthorized responses.""}}]","The function body independently implements the necessary steps to comply with the RFC specification. It constructs the 'WWW-Authenticate' header field with a valid challenge (Basic realm) and returns a 401 Unauthorized status code, directly addressing the conditions and actions specified in the RFC and its context.",success,
3239,ngx_http_uwsgi_process_header,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (u->headers_in.status) {\n    status_line = &u->headers_in.status->value;\n\n    status = ngx_atoi(status_line->data, 3);\n    if (status == NGX_ERROR) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""upstream sent invalid status \\""%V\\"""",\n                      status_line);\n        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n    }\n\n    u->headers_in.status_n = status;\n\n    if (status_line->len > 3) {\n        u->headers_in.status_line = *status_line;\n    }\n}', 'explanation': 'This segment reads the received status header and interprets its semantics (by parsing as a numeric code and setting status values), which partially implements the RFC mandate to interpret protocol elements as defined by the specification.'}}]","The function processes header lines by parsing and acting upon them (e.g., extracting header names/values, looking up registered header handlers, and interpreting the status header). This corresponds partly to the RFC requirement that a recipient must interpret received protocol elements according to their defined semantics. However, the code does not cover additional aspects mentioned in the spec such as handling extensions to the protocol or recovering from invalid constructs beyond simply returning an error. Moreover, there is no logic to decide based on experience or configuration whether the sender misimplemented semantics. Thus, while the function visibly implements parts of the specified requirement (e.g., condition C1), it does not fully cover all the facets of the RFC, resulting in a 'Partially Matches' outcome.",success,
3239,ngx_http_uwsgi_process_header,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'rc = ngx_http_parse_header_line(r, &r->upstream->buffer, 1);\nif (rc == NGX_HTTP_PARSE_INVALID_HEADER) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent invalid header: ""%*s\\x%02xd..."""",\n                  r->header_end - r->header_name_start,\n                  r->header_name_start, *r->header_end);\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': 'This code segment calls a dedicated header line parser and immediately handles parsing errors by logging them and returning an error code. This is an attempt to defensively parse the incoming header, as called for by the RFC, with the assumption that the buffer may only marginally conform to expectations.'}}, {'A1': {'code': 'status = ngx_atoi(status_line->data, 3);\nif (status == NGX_ERROR) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent invalid status ""%V"""", status_line);\n    return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n}', 'explanation': 'This segment converts the status from the header and, if invalid, logs an error and returns an error value. It reflects the defensive behavior of handling irregular protocol elements.'}}]","The provided function implements part of the RFC's requirements by defensively parsing header lines and performing error handling on abnormal or malformed protocol elements. It uses a helper (ngx_http_parse_header_line) to process the header, and various error checks (such as malformed status conversion) to decide whether to accept the data. While these actions address the spirit of the RFC by not assuming the protocol element will completely conform to the ABNF grammar and by safeguarding against overruns or misinterpretations, some aspects such as ensuring the element fits into a 'reasonable buffer size' are not explicitly verified within this function (they are likely managed by lower-level routines or the caller). As such, the function partially matches the RFC's specification.",success,
3240,ngx_http_uwsgi_input_filter_init,"However, a server MAY omit header fields for which a value is determined only while generating the content.",269,Partially Matches,"[{'C1': {'code': 'else if (r->method == NGX_HTTP_HEAD) {\n    u->pipe->length = -1;\n    u->length = -1;\n}', 'explanation': 'This branch of the code specifically checks if the request method is HEAD and then sets the content length fields to -1. This indicates that no content is to be sent in response, which aligns with the requirement of a HEAD request where the server must not send content. It partially meets the RFC guideline regarding content omission.'}}]","The function distinguishes responses based on the HTTP status and the request method. For HEAD requests, it opts to indicate that no content should be returned by setting the length fields to -1, and for responses with status 'No Content' or 'Not Modified', it sets them to 0. This shows an attempt to conform to the RFC requirement that a HEAD request should not deliver content. However, the RFC also mentions that a server may omit header fields whose values are determined during content generation, and this function does not directly address the omission of such header fields—it only sets content lengths. Since the function only partially implements the full behavior mandated by the RFC (handling the HEAD method appropriately but not explicitly handling header omission), it is categorized as 'Partially Matches'.",success,
3240,ngx_http_uwsgi_input_filter_init,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,61,Fully Matches,"[{'C1': {'code': 'else if (r->method == NGX_HTTP_HEAD)', 'explanation': 'The code explicitly checks if the request method is HEAD, which is the precondition for applying HEAD-specific behavior as per the specification.'}}, {'A1': {'code': 'u->pipe->length = -1;\n        u->length = -1;', 'explanation': ""For HEAD requests, the function sets both 'u->pipe->length' and 'u->length' to -1. This indicates that no message body will be generated, thereby ensuring that the server does not send content in the response in accordance with the RFC.""}}]","The function inspects the request method and, when it detects a HEAD request, it sets the values controlling content delivery to -1. This effectively prevents any response body from being sent. By doing so, the code directly implements the requirement stated in the RFC that a HEAD method must not deliver content. Additionally, it handles cases where certain HTTP status codes (NO CONTENT and NOT MODIFIED) also require no content to be sent. Therefore, the logic within this function successfully addresses the key condition and action from the spec.",success,
3245,ngx_http_uwsgi_merge_loc_conf,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': '#if (NGX_HTTP_CACHE)\n    if (conf->upstream.store > 0) {\n        conf->upstream.cache = 0;\n    }\n\n    if (conf->upstream.cache > 0) {\n        conf->upstream.store = 0;\n    }\n    ...\n    if (conf->upstream.cache == NGX_CONF_UNSET) {\n        ngx_conf_merge_value(conf->upstream.cache, prev->upstream.cache, 0);\n        conf->upstream.cache_zone = prev->upstream.cache_zone;\n        conf->upstream.cache_value = prev->upstream.cache_value;\n    }\n    ...\n    ngx_conf_merge_ptr_value(conf->upstream.cache_bypass,\n                             prev->upstream.cache_bypass, NULL);\n    ngx_conf_merge_ptr_value(conf->upstream.no_cache,\n                             prev->upstream.no_cache, NULL);\n    ngx_conf_merge_ptr_value(conf->upstream.cache_valid,\n                             prev->upstream.cache_valid, NULL);', 'explanation': 'This segment handles merging and interdependency of cache configuration, which aligns with the spec statement that a cache may be employed. However, while it manages the enabling/disabling of caching (and mutual exclusivity with upstream storage), it does not enforce the additional requirement that a cache must not be used while acting as a tunnel.'}}]","The function contains detailed logic for merging cache-related configuration parameters (e.g., ensuring mutual exclusion between 'store' and 'cache', merging various cache settings), which partially addresses the RFC specification that caches may be employed. However, there is no visible logic within this function that checks or enforces that a cache cannot be used while acting as a tunnel. Hence, only part of the spec is implemented in this function, and the overall outcome is 'Partially Matches'.",success,
3261,ngx_http_static_handler,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,160,Partially Matches,"[{'A1': {'code': 'if (of.is_dir) {\n\n    ngx_http_clear_location(r);\n\n    r->headers_out.location = ngx_list_push(&r->headers_out.headers);\n    if (r->headers_out.location == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    escape = 2 * ngx_escape_uri(NULL, r->uri.data, r->uri.len, NGX_ESCAPE_URI);\n\n    if (!clcf->alias && r->args.len == 0 && escape == 0) {\n        len = r->uri.len + 1;\n        location = path.data + root;\n\n        *last = \'/\';\n\n    } else {\n        len = r->uri.len + escape + 1;\n\n        if (r->args.len) {\n            len += r->args.len + 1;\n        }\n\n        location = ngx_pnalloc(r->pool, len);\n        if (location == NULL) {\n            ngx_http_clear_location(r);\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        if (escape) {\n            last = (u_char *) ngx_escape_uri(location, r->uri.data,\n                                             r->uri.len, NGX_ESCAPE_URI);\n\n        } else {\n            last = ngx_copy(location, r->uri.data, r->uri.len);\n        }\n\n        *last = \'/\';\n\n        if (r->args.len) {\n            *++last = \'?\';\n            ngx_memcpy(++last, r->args.data, r->args.len);\n        }\n    }\n\n    r->headers_out.location->hash = 1;\n    r->headers_out.location->next = NULL;\n    ngx_str_set(&r->headers_out.location->key, ""Location"");\n    r->headers_out.location->value.len = len;\n    r->headers_out.location->value.data = location;\n\n    return NGX_HTTP_MOVED_PERMANENTLY;\n}', 'explanation': 'This code block detects that the requested resource is a directory and creates a Location header (by appending a trailing slash and optionally handling escape sequences) to indicate the new permanent URI. This aligns with the RFC requirement that the server SHOULD generate a Location header field with the preferred permanent URI.'}}]","The function includes logic to generate a Location header when the requested URI lacks a trailing slash (i.e., when it is a directory), which addresses the RFC requirement to provide a preferred permanent URI. However, while the RFC specifies a 308 Permanent Redirect status code, the code returns NGX_HTTP_MOVED_PERMANENTLY (typically a 301), meaning that although part of the requirement (Location header generation) is met, the status code does not match the spec exactly. Thus, the implementation partially matches the RFC.",success,
3261,ngx_http_static_handler,"In 200 responses to GET or HEAD, an origin server SHOULD send any available validator fields (Section 8.8) for the selected representation, with both a strong entity tag and a Last-Modified date being preferred.",141,Fully Matches,"[{'C1': {'code': 'r->headers_out.last_modified_time = of.mtime;', 'explanation': ""This line sets the Last-Modified header based on the file's modification time (of.mtime), directly addressing the requirement to include a Last-Modified date in 200 responses for GET or HEAD.""}}, {'A1': {'code': 'if (ngx_http_set_etag(r) != NGX_OK) {\n    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n}', 'explanation': 'This segment invokes ngx_http_set_etag(r) to set the validator field for the ETag, fulfilling the requirement to include a strong entity tag in 200 responses.'}}]","The function explicitly implements the validator fields required by the RFC for 200 responses to GET or HEAD. It sets the Last-Modified header and calls a function to generate the ETag, thereby fully matching the specification requirements.",success,
3261,ngx_http_static_handler,"An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",60,Fully Matches,"[{'C1': {'code': 'if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD|NGX_HTTP_POST))) {\n    return NGX_HTTP_NOT_ALLOWED;\n}', 'explanation': 'This code segment checks if the incoming request method is among GET, HEAD, or POST. If it is not, the function returns NGX_HTTP_NOT_ALLOWED (405), thereby addressing the constraint that for a recognized and implemented method that is not allowed, the server must respond with a 405.'}}, {'A1': {'code': 'if (r->method == NGX_HTTP_POST) {\n    return NGX_HTTP_NOT_ALLOWED;\n}', 'explanation': 'Later in the function, after handling allowed methods for static files, the code explicitly checks if the request method is POST and returns NGX_HTTP_NOT_ALLOWED (405) when POST is not permitted for the target resource, which aligns with the RFC requirement.'}}]","The function implements the logic for handling HTTP methods by checking if the method is one of GET, HEAD, or POST and returning 405 if it is not. Additionally, it explicitly returns 405 for POST requests when operating on static files. These implementations directly satisfy the RFC requirement that for a recognized and implemented method that is not allowed on the target resource, the server should return a 405 (Method Not Allowed) status code.",success,
3261,ngx_http_static_handler,"An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",268,Does Not Match,[],"The provided code function does not implement any logic that addresses the specific RFC requirement stating that 'an origin server SHOULD NOT rely on private agreements to receive content.' Instead, the function merely handles static file serving for GET and HEAD requests, discards any request body, and explicitly disallows POST requests. There is no code in this function that checks for or relates to private agreements for receiving content, so it does not visibly address the labeled condition or action corresponding to the RFC specification.",success,
3261,ngx_http_static_handler,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'if (of.is_dir) {\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, log, 0, ""http dir"");\n\n    ngx_http_clear_location(r);\n\n    r->headers_out.location = ngx_list_push(&r->headers_out.headers);\n    if (r->headers_out.location == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    escape = 2 * ngx_escape_uri(NULL, r->uri.data, r->uri.len, NGX_ESCAPE_URI);\n\n    if (!clcf->alias && r->args.len == 0 && escape == 0) {\n        len = r->uri.len + 1;\n        location = path.data + root;\n\n        *last = \'/\';\n    } else {\n        len = r->uri.len + escape + 1;\n\n        if (r->args.len) {\n            len += r->args.len + 1;\n        }\n\n        location = ngx_pnalloc(r->pool, len);\n        if (location == NULL) {\n            ngx_http_clear_location(r);\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        if (escape) {\n            last = (u_char *) ngx_escape_uri(location, r->uri.data, r->uri.len, NGX_ESCAPE_URI);\n        } else {\n            last = ngx_copy(location, r->uri.data, r->uri.len);\n        }\n\n        *last = \'/\';\n\n        if (r->args.len) {\n            *++last = \'?\';\n            ngx_memcpy(++last, r->args.data, r->args.len);\n        }\n    }\n\n    r->headers_out.location->hash = 1;\n    r->headers_out.location->next = NULL;\n    ngx_str_set(&r->headers_out.location->key, ""Location"");\n    r->headers_out.location->value.len = len;\n    r->headers_out.location->value.data = location;\n\n    return NGX_HTTP_MOVED_PERMANENTLY;\n}', 'explanation': 'This code block detects when the target is a directory and then builds and sets the Location header field with the new URI reference (including handling of trailing slashes and query parameters). This directly implements the RFC requirement to include a Location header for redirection.'}}]","The function implements logic to generate a Location header when the requested URI corresponds to a directory. By allocating and setting a header with the new URI (either by appending a trailing slash or constructing the complete redirect URI with query parameters), the function visibly satisfies the RFC requirement. All the relevant logic is contained within this function, making the implementation self‐contained and compliant.",success,
3261,ngx_http_static_handler,All general-purpose servers MUST support the methods GET and HEAD,58,Fully Matches,"[{'C1': {'code': 'if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD|NGX_HTTP_POST))) {\n    return NGX_HTTP_NOT_ALLOWED;\n}', 'explanation': 'This check ensures that the function will only handle GET, HEAD, and POST methods. Since the RFC mandates that GET and HEAD be supported, the function clearly distinguishes these methods by allowing them to proceed into further processing. Although POST is also allowed in the initial check, it is explicitly rejected later, ensuring that only GET and HEAD are effectively served.'}}, {'A1': {'code': 'if (r->method == NGX_HTTP_POST) {\n    return NGX_HTTP_NOT_ALLOWED;\n}', 'explanation': 'This code segment confirms that POST, although recognized in the initial check, is not processed for static file delivery. This aligns with the RFC requirement that only GET and HEAD must be supported, enforcing that unsupported methods receive the 405 (Method Not Allowed) status.'}}]","The function’s implementation shows a clear attempt to support the RFC by ensuring that GET and HEAD methods are handled properly. It first filters the incoming request to accept only GET, HEAD, and POST. Then it explicitly rejects POST requests when it becomes clear that a static file is being requested, thus effectively supporting only GET and HEAD as required by the RFC. All logic to decide method support is implemented within the function itself, meeting the spec constraints.",success,
3261,ngx_http_static_handler,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,155,Fully Matches,"[{'C1': {'code': 'if (of.is_dir) {\n    ngx_http_clear_location(r);\n    r->headers_out.location = ngx_list_push(&r->headers_out.headers);\n    if (r->headers_out.location == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n    \n    escape = 2 * ngx_escape_uri(NULL, r->uri.data, r->uri.len, NGX_ESCAPE_URI);\n    \n    if (!clcf->alias && r->args.len == 0 && escape == 0) {\n        len = r->uri.len + 1;\n        location = path.data + root;\n        *last = \'/\';\n    } else {\n        len = r->uri.len + escape + 1;\n        if (r->args.len) {\n            len += r->args.len + 1;\n        }\n        location = ngx_pnalloc(r->pool, len);\n        if (location == NULL) {\n            ngx_http_clear_location(r);\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n        if (escape) {\n            last = (u_char *) ngx_escape_uri(location, r->uri.data, r->uri.len, NGX_ESCAPE_URI);\n        } else {\n            last = ngx_copy(location, r->uri.data, r->uri.len);\n        }\n        *last = \'/\';\n        if (r->args.len) {\n            *++last = \'?\';\n            ngx_memcpy(++last, r->args.data, r->args.len);\n        }\n    }\n    r->headers_out.location->hash = 1;\n    r->headers_out.location->next = NULL;\n    ngx_str_set(&r->headers_out.location->key, ""Location"");\n    r->headers_out.location->value.len = len;\n    r->headers_out.location->value.data = location;\n    \n    return NGX_HTTP_MOVED_PERMANENTLY;\n}', 'explanation': ""The code explicitly checks if the targeted resource is a directory and then creates a Location header field with the new URI (by appending a trailing '/') before returning the 301 status code (NGX_HTTP_MOVED_PERMANENTLY). This directly corresponds to the RFC requirement that the server SHOULD generate a Location header field with a new permanent URI.""}}]","The function contains explicit logic for generating the Location header in the response when dealing with directory requests. This involves creating the header, appropriately constructing the URI (with considerations for escaping and query parameters), and returning a 301 Moved Permanently status. Thus, within its own code, the function fully implements the spec requirement as outlined by the RFC.",success,
3261,ngx_http_static_handler,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'A1': {'code': 'if (of.is_dir) {\n    ngx_http_clear_location(r);\n    r->headers_out.location = ngx_list_push(&r->headers_out.headers);\n    if (r->headers_out.location == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n    \n    escape = 2 * ngx_escape_uri(NULL, r->uri.data, r->uri.len, NGX_ESCAPE_URI);\n    \n    if (!clcf->alias && r->args.len == 0 && escape == 0) {\n        len = r->uri.len + 1;\n        location = path.data + root;\n        *last = \'/\';\n    } else {\n        len = r->uri.len + escape + 1;\n        if (r->args.len) {\n            len += r->args.len + 1;\n        }\n        location = ngx_pnalloc(r->pool, len);\n        if (location == NULL) {\n            ngx_http_clear_location(r);\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n        if (escape) {\n            last = (u_char *) ngx_escape_uri(location, r->uri.data, r->uri.len, NGX_ESCAPE_URI);\n        } else {\n            last = ngx_copy(location, r->uri.data, r->uri.len);\n        }\n        *last = \'/\';\n        if (r->args.len) {\n            *++last = \'?\';\n            ngx_memcpy(++last, r->args.data, r->args.len);\n        }\n    }\n    r->headers_out.location->hash = 1;\n    r->headers_out.location->next = NULL;\n    ngx_str_set(&r->headers_out.location->key, ""Location"");\n    r->headers_out.location->value.len = len;\n    r->headers_out.location->value.data = location;\n    return NGX_HTTP_MOVED_PERMANENTLY;\n}', 'explanation': ""The code segment checks whether the requested URI is a directory. When it is, the function constructs a new URI reference by appending a '/' (and, if needed, query parameters) to the original URI, assigns it to the 'Location' header, and returns a redirection status code. This directly implements the RFC requirement for generating a Location header with the new URI as specified.""}}]","The function includes explicit logic to generate a Location header for directory requests, as required by the HTTP redirection specification. It builds the URI for redirection by appending a trailing slash and handling query parameters, and subsequently sets this URI in the response header. Although the function returns NGX_HTTP_MOVED_PERMANENTLY (a 301 code) instead of a 302 code mentioned in the spec context, the key requirement of producing a Location header is fully addressed within this function.",success,
3330,ngx_http_index_error,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function ngx_http_index_error only handles error conditions (such as forbidden access and file not found) by logging an error and returning appropriate HTTP status codes. It does not check or enforce any protocol element generation rules related to roles, as required by the spec constraint stating that a sender MUST NOT generate protocol elements that are only allowed for other roles. Therefore, no parts of this function visibly address any of the labeled spec constraints.",success,
3330,ngx_http_index_error,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function ngx_http_index_error only logs error messages and returns HTTP status codes based on error conditions. It does not include any logic to verify or enforce that protocol elements conform to the ABNF grammar specified by the RFC (i.e., it does not implement a check against generating protocol elements that do not match the grammar). Thus, there is no visible implementation within this function that addresses the spec constraint regarding grammar compliance.",success,
3344,ngx_http_slice_header_filter,The recipient of an invalid Content-Range MUST NOT attempt to recombine the received content with a stored representation.,136,Fully Matches,"[{'C1': {'code': 'if (ngx_http_slice_parse_content_range(r, &cr) != NGX_OK) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""invalid range in slice response"");\n    return NGX_ERROR;\n}\n\nif (cr.complete_length == -1) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""no complete length in slice response"");\n    return NGX_ERROR;\n}', 'explanation': 'These code segments ensure that if the Content-Range is invalid (either it fails parsing or the complete length is missing), the function immediately returns an error. This prevents any further processing, thereby not attempting to recombine invalid content with a stored representation in compliance with the spec.'}}, {'A1': {'code': 'return NGX_ERROR;', 'explanation': 'Upon detecting an invalid Content-Range, the function returns an error rather than proceeding with any content recombination logic. This aligns with the requirement that the recipient MUST NOT recombine the received content when the Content-Range is invalid.'}}]",The function explicitly checks the validity of the Content-Range header by parsing it and verifying key fields. If the Content-Range is found to be invalid—such as when parsing fails or when the complete_length is absent—it logs the error and returns an error without further processing. This behavior directly addresses the specified RFC requirement that a recipient of an invalid Content-Range MUST NOT attempt to recombine the received content with a stored representation.,success,
3344,ngx_http_slice_header_filter,"For byte ranges, a sender SHOULD indicate the complete length of the representation from which the range has been extracted, unless the complete length is unknown or difficult to determine.",287,Fully Matches,"[{'C1': {'code': 'if (cr.complete_length == -1) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""no complete length in slice response"");\n    return NGX_ERROR;\n}', 'explanation': 'The function checks whether the complete length is present (i.e. not -1). This enforces the RFC requirement that a sender SHOULD indicate the complete length of the representation when known.'}}, {'A1': {'code': 'r->headers_out.content_length_n = cr.complete_length;', 'explanation': ""The function assigns the complete length from the Content-Range to the response's content_length header, which directly complies with the RFC instruction to indicate the complete length.""}}]","The function_body explicitly validates the existence of a complete length in the parsed Content-Range (C1) and then sets it in the response header (A1). This direct handling within the function fulfills the RFC requirement regarding byte ranges, where the complete length of the representation must be provided when known.",success,
3348,ngx_http_slice_get_start,"A server that supports range requests MAY ignore or reject a Range header field that contains an invalid ranges-specifier (Section 14.1.1), a ranges-specifier with more than two overlapping ranges, or a set of many small ranges that are not listed in ascending order, since these are indications of either a broken client or a deliberate denial-of-service attack (Section 17.15).",129,Partially Matches,"[{'C1': {'code': 'if (h == NULL\n        || h->value.len < 7\n        || ngx_strncasecmp(h->value.data, (u_char *) ""bytes="", 6) != 0)\n    {\n        return 0;\n    }', 'explanation': 'This code validates that the incoming Range header is at least 7 characters long and starts with ""bytes="", thereby ensuring that range requests with an invalid ranges-specifier (in terms of header format) are rejected.'}}, {'A1': {'code': ""if (ngx_strchr(p, ',')) {\n        return 0;\n    }"", 'explanation': 'By checking for a comma in the range specification, the function rejects requests that contain multiple ranges. This implements the RFC guideline to ignore/reject range headers that include multiple (or potentially overlapping) ranges, a common indication of problematic or malicious requests.'}}]","The function parses the Range header to extract a single starting byte offset. It returns 0 (effectively ignoring the header) if the header is absent, does not have the required ""bytes="" prefix, or contains indicators of multiple or otherwise invalid ranges (e.g. a comma or negative start value). This behavior addresses some portions of the RFC specification—namely, rejecting clearly invalid or multi-range requests. However, it does not implement logic for more complex validations (such as checking for overlapping ranges or ensuring that many small ranges are in ascending order), so the function only partially matches the complete set of requirements outlined in the RFC.",success,
3348,ngx_http_slice_get_start,A server MUST ignore an If-Range header field received in a request that does not contain a Range header field.,119,Partially Matches,[],"The RFC requires that a server ignore an If-Range header only when there is no Range header present. In the provided function, the very first check is “if (r->headers_in.if_range) { return 0; }” which causes an immediate return (i.e., ignores the header) regardless of whether a valid Range header is present or not. This means that even if both Range and If-Range headers are included, the function unconditionally bypasses further processing, thereby not fully implementing the RFC requirement. As a result, while the function does address the If-Range header check, it does so in an over-simplified manner that does not conform completely to the RFC constraints.",success,
3348,ngx_http_slice_get_start,An origin server MUST ignore an If-Range header field received in a request for a target resource that does not support Range requests.,120,Fully Matches,"[{'A1': {'code': 'if (r->headers_in.if_range) {\n    return 0;\n}', 'explanation': 'This code segment shows that if the request contains an If-Range header, the function immediately returns 0, effectively ignoring the header. This behavior matches the RFC requirement that an origin server MUST ignore an If-Range header field if the target resource does not support Range requests (or if the Range header is not present).'}}]","The function begins by checking for the presence of an If-Range header. If it exists, it returns 0 without processing any further range data. This logic fully implements the specification that requires the server to ignore the If-Range header in contexts where the target resource does not support Range requests, or when the Range header is absent. Therefore, the function visibly addresses the relevant spec constraint.",success,
3348,ngx_http_slice_get_start,A recipient of an If-Range header field MUST ignore the Range header field if the If-Range condition evaluates to false.,122,Partially Matches,"[{'A1': {'code': 'if (r->headers_in.if_range) {\n    return 0;\n}', 'explanation': 'This code segment forces the function to ignore the Range header by returning 0 when an If-Range header is present. It corresponds to the action of ignoring the Range header field when the If-Range condition is (or should be) false. However, it does not perform any validation (e.g. strong comparison of entity-tags) required by the RFC to determine if the condition is actually false.'}}]","The RFC requires that if the If-Range condition evaluates to false (after comparing the provided validator with the current ETag), the Range header must be ignored. In this function, the presence of the If-Range header causes an immediate return of 0, effectively ignoring the Range header without any condition evaluation. Therefore, while the function does implement the action of ignoring the Range header field when an If-Range header is present, it omits the critical evaluation step mandated by the RFC, resulting in a partial match.",success,
3348,ngx_http_slice_get_start,A server MAY ignore the Range header field.,126,Partially Matches,"[{'C1': {'code': 'if (r->headers_in.if_range) {\n    return 0;\n}', 'explanation': 'This check immediately ignores the Range header if an If-Range header is present, which is one scenario where the specification allows the server to ignore Range processing.'}}, {'A1': {'code': 'if (h == NULL\n    || h->value.len < 7\n    || ngx_strncasecmp(h->value.data, (u_char *) ""bytes="", 6) != 0)\n{\n    return 0;\n}', 'explanation': 'This segment ensures that the Range header exists and starts with the valid ""bytes="" prefix; if not, the function ignores the header (returns 0), aligning with the RFC\'s permissive requirement to ignore the field.'}}, {'A2': {'code': ""if (ngx_strchr(p, ',')) {\n    return 0;\n}"", 'explanation': 'This check detects if multiple ranges are being requested (by searching for a comma) and ignores such requests by returning 0, which is consistent with the possibility of ignoring complex range requests.'}}, {'A3': {'code': ""while (*p == ' ') { p++; }\n\nif (*p == '-') {\n    return 0;\n}"", 'explanation': ""This code skips any leading spaces then checks if the range begins with a '-' indicating a suffix-range request; if so, it returns 0 to ignore a type of range not handled here.""}}]","The function attempts to implement a subset of range processing logic by validating the Range header and only extracting a starting offset for a valid single-range request. It ignores the header in several cases (if an If-Range header is present, if the header is missing or malformed, if multiple ranges are specified, or if a suffix range is indicated). However, it does not check that the request method is GET—which is a key part of the RFC context—nor does it fully manage all aspects of byte range handling. Thus, while portions of the RFC's allowance to ignore or process the Range header are implemented within this function, the implementation is only partial.",success,
3348,ngx_http_slice_get_start,"Otherwise, the recipient SHOULD process the Range header field as requested.",123,Does Not Match,[],"The RFC requires that when an If-Range header is provided, the recipient must evaluate the condition (by comparing entity-tags or dates) and only ignore the Range header if the condition is false. In the provided function, if the If-Range header is present (r->headers_in.if_range), the function immediately returns 0 without performing any comparison or evaluation. This logic neither fulfills the condition checking nor the proper processing of the Range header when the If-Range condition is true. Therefore, the code does not implement any part of the RFC specification as required.",success,
3363,ngx_http_try_files,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided code function, ngx_http_try_files, is concerned with processing configuration directives (specifically for the try_files directive) and preparing file paths and error codes. There is no logic within this function that validates or ensures that any generated HTTP protocol elements strictly follow an ABNF-defined grammar. Thus, the function does not address the spec requirement that a sender MUST NOT generate protocol elements that do not match the ABNF grammar, and no code segment within this function corresponds to any labeled condition or action related to that requirement.",success,
3392,ngx_http_addition_header_filter,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Does Not Match,[],"The provided function explicitly checks that the response status is NGX_HTTP_OK (200) and returns immediately for any other status, which means it does not operate on 1xx or 204 responses. Although it calls ngx_http_clear_content_length(r) to clear the Content-Length header, this logic is applied only for 200 (OK) responses rather than addressing the RFC requirement to not send a Content-Length header in responses with a status code of 1xx or 204. Thus, the function does not visibly address the specific RFC constraint within its own code logic.",success,
3392,ngx_http_addition_header_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Fully Matches,"[{'A1': {'code': 'ngx_http_clear_content_length(r);', 'explanation': 'This call explicitly clears the Content-Length header from the response. Given that the RFC requires that a sender MUST NOT forward a message with a Content-Length header that is known to be incorrect, removing the header when additional content is added ensures that the message is not forwarded with a potentially wrong Content-Length value.'}}]","The function checks if additional content is to be inserted (via 'conf->before_body' or 'conf->after_body') and, if so, it clears the Content-Length header by calling ngx_http_clear_content_length(r). This directly addresses the RFC mandate to not forward a message with an incorrect Content-Length header value. Although it does not verify or re-calculate the Content-Length, removing it avoids the risk of forwarding an invalid header. Therefore, this function fully meets the relevant constraint (action A1) based solely on its internal logic.",success,
3420,ngx_http_fastcgi_handler,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': '#if (NGX_HTTP_CACHE)\n    fmcf = ngx_http_get_module_main_conf(r, ngx_http_fastcgi_module);\n\n    u->caches = &fmcf->caches;\n    u->create_key = ngx_http_fastcgi_create_key;\n#endif', 'explanation': 'This code block sets up caching support and assigns a cache structure to the upstream object when caching is enabled. It implements the part of the RFC that allows a client or server to employ a cache.'}}]","The RFC specifies that any client or server may employ a cache, but a cache cannot be used while acting as a tunnel. The provided function configures caching support (as seen in the NGX_HTTP_CACHE block), fulfilling the part of the spec that permits caching. However, there is no code to check or enforce that a cache is disabled when acting as a tunnel. Since only part of the specification is visibly handled in the function, the overall match is deemed partial.",success,
3422,ngx_http_fastcgi_create_request,"A recipient MAY combine multiple field lines within a field section that have the same field name into one field line, without changing the semantics of the message, by appending each subsequent field line value to the initial field line value in order, separated by a comma ("","") and optional whitespace (OWS, defined in Section 5.6.3).",231,Fully Matches,"[{'A1': {'code': 'if (header[i].next) {\n    if (header[i].key.len == sizeof(""Cookie"") - 1\n        && ngx_strncasecmp(header[i].key.data, (u_char *) ""Cookie"",\n                           sizeof(""Cookie"") - 1) == 0)\n    {\n        sep = \';\';\n    } else {\n        sep = \',\';\n    }\n    for (hn = header[i].next; hn; hn = hn->next) {\n        *b->last++ = sep;\n        *b->last++ = \' \';\n        b->last = ngx_copy(b->last, hn->value.data, hn->value.len);\n    }', 'explanation': 'This segment directly implements the RFC by appending subsequent field line values of the same header field using a separator. For most headers, the separator is a comma followed by a space (i.e., "", ""), thereby conforming to the specification that requires multiple field lines to be combined in order using a comma and optional whitespace.'}}]","The function clearly includes logic to merge multiple header field lines (accessed via the header[i].next pointer) by appending each additional header value with a comma and a space, except for cookies where a semicolon is used. This implementation addresses the RFC's requirement that a recipient MAY combine multiple field lines into one without changing the message semantics, thus fully meeting the spec constraint.",success,
3435,ngx_http_fastcgi_input_filter_init,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,61,Partially Matches,"[{'C1': {'code': 'else if (r->method == NGX_HTTP_HEAD) {\n        f->rest = -2;\n    }', 'explanation': 'This code branch specifically checks for HEAD requests and assigns a special flag value (-2) to f->rest, which indicates that no response content should be processed. This behavior is an attempt to implement the part of the specification that states the response MUST NOT include content for a HEAD request.'}}]","The provided function contains logic handling HEAD requests by setting f->rest to -2, thereby suppressing the processing of response content. This addresses the basic requirement of the HEAD method not sending content. However, the specification also requires that a HEAD response contain the same header fields as a GET response (with minor acceptable omissions), and this aspect is not evident in the code snippet. As such, while the function partially addresses the specification by handling the no-content constraint for HEAD requests, it does not fully implement or demonstrate all aspects of the RFC related to the HEAD method.",success,
3436,ngx_http_fastcgi_input_filter,HTTP implementations SHOULD support persistent connections.,311,Partially Matches,"[{'C1': {'code': 'if (!flcf->keep_conn) {\n    p->upstream_done = 1;\n}\n...\nif (f->pos + f->padding == f->last) {\n    p->upstream_done = 1;\n    r->upstream->keepalive = 1;\n    break;\n}\n...\nif (flcf->keep_conn) {\n    /* set p->length, minimal amount of data we want to see */\n    if (f->state < ngx_http_fastcgi_st_data) {\n        p->length = 1;\n    } else if (f->state == ngx_http_fastcgi_st_padding) {\n        p->length = f->padding;\n    } else {\n        p->length = f->length;\n    }\n}', 'explanation': 'The function examines a configuration flag (flcf->keep_conn) to decide whether to maintain a persistent connection. It sets r->upstream->keepalive to 1 when the conditions are met (e.g., at the end of a correctly terminated FastCGI record). This indicates an attempt to support persistent HTTP connections, though the overall implementation is distributed and not entirely self-contained in this function.'}}]","The function contains logic for handling persistent connections by checking a configuration parameter (flcf->keep_conn) and setting the connection's keepalive flag accordingly. While it provides mechanisms to support persistent connections (e.g., by not marking the connection as done when keep_conn is true), other aspects required for complete compliance with the RFC may be implemented elsewhere. Therefore, the function's logic partially meets the RFC's requirement to support persistent connections.",success,
3438,ngx_http_fastcgi_process_record,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Does Not Match,[],"The provided function is a FastCGI record processor that parses individual bytes to validate a FastCGI protocol record (e.g., checking version, type, request ID, and content length). While it performs validation on header fields and logs errors, none of its logic addresses the HTTP RFC requirement that a recipient MUST interpret a received protocol element according to the semantics defined by the specification and potentially recover from invalid constructs. In this function, no explicit error recovery mechanism or semantic interpretation matching the labeled conditions (C1, C2, …) or actions (A1, A2, …) from the HTTP RFC is implemented. It simply verifies fields and returns an error when a protocol violation is detected. Thus, the function does not visibly address the specified constraints within its own logic.",success,
3438,ngx_http_fastcgi_process_record,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'case ngx_http_fastcgi_st_version:\n    if (ch != 1) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""upstream sent unsupported FastCGI protocol version: %d"", ch);\n        return NGX_ERROR;\n    }', 'explanation': 'This segment demonstrates a defensive parsing step by checking the protocol version and returning an error if the value is unexpected.'}}, {'A1': {'code': 'switch (state) {\n    ...\n    case ngx_http_fastcgi_st_type:\n        switch (ch) {\n        case NGX_HTTP_FASTCGI_STDOUT:\n        case NGX_HTTP_FASTCGI_STDERR:\n        case NGX_HTTP_FASTCGI_END_REQUEST:\n            f->type = (ngx_uint_t) ch;\n            break;\n        default:\n            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                          ""upstream sent invalid FastCGI record type: %d"", ch);\n            return NGX_ERROR;\n        }\n        state = ngx_http_fastcgi_st_request_id_hi;\n        break;', 'explanation': 'This code defensively examines the record type and takes appropriate error action when an unexpected type is encountered.'}}]","The function implements a state machine that defensively parses a FastCGI record by validating each protocol element (e.g., version, record type, request id, content length, etc.). It explicitly checks for unexpected values and logs errors accordingly. This demonstrates an attempt to defensively parse the input, as suggested by the RFC specification. However, the implementation is relatively strict—it expects exact values rather than adopting a more permissive, marginal expectation approach—and does not include explicit handling for overall buffer size limits. Thus, while parts of the RFC’s intended defensive parsing strategy are addressed within this function, the implementation only partially meets the full spirit of the specification.",success,
3507,ngx_http_xslt_header_filter,"Since the goal of a 304 response is to minimize information transfer when the recipient already has one or more cached representations, a sender SHOULD NOT generate representation metadata other than the above listed fields unless said metadata exists for the purpose of guiding cache updates (e.g., Last-Modified might be useful if the response does not have an ETag field).",158,Fully Matches,"[{'C1': {'code': 'if (r->headers_out.status == NGX_HTTP_NOT_MODIFIED) {\n    return ngx_http_next_header_filter(r);\n}', 'explanation': 'This code segment checks if the response status is 304 (Not Modified) and, if so, bypasses any additional header modifications or metadata generation. This behavior ensures that no extra representation metadata is produced, meeting the RFC requirement that a 304 response SHOULD NOT include additional metadata.'}}]","The function directly addresses the RFC specification by verifying if the response status is 304 and, in that case, immediately returning control to the next header filter without adding any extra metadata. This ensures that the goal of minimizing information transfer for 304 responses is met solely within this function.",success,
3509,ngx_http_xslt_send,An origin server without a clock MUST NOT generate a Last-Modified date for a response unless that date value was assigned to the resource by some other system (presumably one with a clock).,55,Partially Matches,"[{'C1': {'code': 'if (!conf->last_modified) {\n    ngx_http_clear_last_modified(r);\n    ngx_http_clear_etag(r);\n} else {\n    ngx_http_weak_etag(r);\n}', 'explanation': 'This segment checks the configuration flag (conf->last_modified) and, if false (implying the server may lack a clock), it clears the Last-Modified header. This addresses the RFC requirement that an origin server without a clock MUST NOT generate a Last-Modified date. However, the code does not handle the related conditions for servers with a clock.'}}]","The function includes conditional logic to clear the Last-Modified header when a configuration flag (likely indicating that the server does not have a clock) is false. This shows an attempt to comply with the RFC stipulation for an origin server without a clock. However, the function does not implement checks for ensuring that a server with a clock does not generate a Last-Modified date that is in the future relative to its message origination time. Thus, while it partially addresses the RFC, it does not encompass all aspects of the specified constraint.",success,
3509,ngx_http_xslt_send,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'A1': {'code': 'if (r == r->main) {\n    r->headers_out.content_length_n = b->last - b->pos;\n\n    if (r->headers_out.content_length) {\n        r->headers_out.content_length->hash = 0;\n        r->headers_out.content_length = NULL;\n    }\n}', 'explanation': 'This code segment sets the Content-Length header when the content size is known, which directly addresses the RFC requirement to send a Content-Length header in the absence of Transfer-Encoding. However, it does so unconditionally for main requests without checking for the response status codes (e.g. 1xx, 204) or CONNECT requests, which are mandated by the RFC to omit this header.'}}]","The function attempts to implement the part of the RFC that requires sending a Content-Length header when the content size is known (A1). It computes the content length based on the buffer size and assigns it to r->headers_out.content_length_n. However, it does not incorporate logic to prevent a Content-Length header from being sent in responses with status codes 1xx, 204, or in CONNECT responses as required by the RFC. Thus, only a subset of the expected behaviors is handled in this function.",success,
3509,ngx_http_xslt_send,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'C1': {'code': 'if (r == r->main) {\n    r->headers_out.content_length_n = b->last - b->pos;\n\n    if (r->headers_out.content_length) {\n        r->headers_out.content_length->hash = 0;\n        r->headers_out.content_length = NULL;\n    }\n}', 'explanation': 'The code recalculates the Content-Length based on the buffer size and clears any existing Content-Length header, which partially addresses the requirement to avoid forwarding a message with an incorrect Content-Length value. However, it does not verify against the ABNF or handle situations such as comma-separated duplicate values as described in the RFC.'}}]","The function attempts to implement part of the RFC requirement by ensuring a correct Content-Length is set and any previous header is removed. This prevents forwarding a possibly incorrect Content-Length header. Nonetheless, the implementation does not fully cover all aspects of the RFC specification, such as validation against the ABNF-formatted content or handling duplicate comma-separated values, so it only partially matches the spec constraints.",success,
3509,ngx_http_xslt_send,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The function ngx_http_xslt_send does not implement any logic related to the RFC specification regarding the prohibition of generating multiple header fields with the same name, nor does it handle the order of header fields as required. The code mainly focuses on buffer handling, content-length setting, memory cleanup, and forwarding to subsequent filters. There is no visible implementation within this function that addresses the condition (C1) or the action (A1) related to handling multiple header field lines or preserving their order.",success,
3514,ngx_http_xslt_apply_stylesheet,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'if (r == r->main) {\n    type = ngx_http_xslt_content_type(sheet[i - 1].stylesheet);\n} else {\n    type = NULL;\n}\n...\nif (r != r->main) {\n    return b;\n}\n\nb->last_buf = 1;\n\nif (type) {\n    len = ngx_strlen(type);\n    r->headers_out.content_type_len = len;\n    r->headers_out.content_type.len = len;\n    r->headers_out.content_type.data = type;\n\n} else if (doc_type == XML_HTML_DOCUMENT_NODE) {\n    r->headers_out.content_type_len = sizeof(""text/html"") - 1;\n    ngx_str_set(&r->headers_out.content_type, ""text/html"");\n}', 'explanation': ""This section of the function checks if a media type ('type') is provided via the stylesheet. If available, it explicitly sets the Content-Type header. If not, and the document is an HTML document, it defaults the Content-Type to 'text/html'. This fulfills the RFC requirement: a message containing content should include a Content-Type header when the media type is known.""}}]","The function implements the RFC requirement by examining the provided media type from the stylesheet and setting the appropriate Content-Type header in the output. When a valid type is available, it is used; otherwise, if the document is HTML, it defaults to 'text/html'. This logic completes the constraint within the function itself without relying on external dependencies.",success,
3514,ngx_http_xslt_apply_stylesheet,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function focuses on processing an XML document through XSLT transformations and setting up content type and charset headers. It does not implement any logic that verifies or restricts the generation of protocol elements based on sender roles as mandated by the HTTP RFC specification. There is no check or logic that prevents the function from generating protocol elements that are only allowed for other roles, making it not address the RFC spec requirement.",success,
3553,ngx_http_image_header_filter,"In order to avoid confusion with issues related to media types, servers that fail a request with a 415 status for reasons unrelated to content codings MUST NOT include the Accept-Encoding header field.",95,Does Not Match,[],"The provided function does not implement any logic addressing the HTTP RFC requirement concerning the Accept-Encoding header field. The RFC specifies that for a 415 status due to reasons unrelated to content codings, the Accept-Encoding header field must not be included, and conversely, that in cases of unsupported content coding, the header should be included. However, the code function only checks the response's content type and size, returning NGX_HTTP_UNSUPPORTED_MEDIA_TYPE in one case, but it does not inspect or modify the Accept-Encoding header field at any point. Since there is no code in this function that conditionally manipulates the Accept-Encoding header (neither setting nor omitting it based on the content coding error), it does not meet any of the specified constraints.",success,
3553,ngx_http_image_header_filter,"A server MUST NOT generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses.",288,Does Not Match,[],"The RFC specifies that a server must not generate a multipart response for a request for a single range. The provided function does not inspect the request's Range header nor does it implement logic to decide between single or multiple ranges. While the function sets r->allow_ranges to 0 (thus disabling range support) and explicitly logs an error if the content type is 'multipart/x-mixed-replace', it does not implement the RFC’s requirements regarding handling of multiple range requests and the conditions for generating (or not) a multipart response. Therefore, this function does not visibly address the specific RFC constraint within its own logic.",success,
3554,ngx_http_image_body_filter,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'ct = &ngx_http_image_types[ctx->type - 1];\n    r->headers_out.content_type_len = ct->len;\n    r->headers_out.content_type = *ct;\n    r->headers_out.content_type_lowcase = NULL;', 'explanation': 'The function checks if the image type is known (i.e. ctx->type != NGX_HTTP_IMAGE_NONE) and then explicitly sets the Content-Type header in the outgoing response. This directly implements the requirement from the RFC specification that a sender should generate a Content-Type header unless the media type is unknown.'}}]","Within the function, once a valid image type is determined, the code assigns the appropriate Content-Type header, fulfilling the RFC requirement. The logic clearly sets the content type header if the media type is known, and for unsupported media types, the function finalizes the request with an error. This shows that the implementation in the function_body is fully addressing the specified behavior in the RFC.",success,
3560,ngx_http_image_process,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided code function is focused on image processing (resizing, rotation, JSON response, etc.) and does not include any logic that pertains to handling or ignoring context information such as the Content-Location header. The RFC specification states that an origin server MUST NOT use context information (like that provided in the Content-Location header) to alter the request semantics. There is no code in the function that examines or acts upon such context information; it does not check for Content-Location or otherwise attempt to enforce this requirement. Therefore, none of the spec constraints (e.g., C1, A1, etc.) have been implemented within this function.",success,
3561,ngx_http_image_json,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that a sender must not generate protocol elements or syntax alternatives that are only allowed for other roles. In the function, while the code sets allowed HTTP headers (e.g., status and Content-Type) and calls ngx_http_clean_header (presumably to remove unwanted header elements), it does not include any explicit checks or logic dedicated to determining or enforcing the sender’s role versus the roles that may generate other protocol elements. No part of the function explicitly validates that only role‑appropriate protocol elements are produced. Consequently, the function does not visibly implement the mentioned constraint solely within its own logic.",success,
3561,ngx_http_image_json,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC specification requires that a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. In the provided function, the JSON response is created using hardcoded strings and simple formatted printing (e.g., using ngx_sprintf) without any logic to check or validate the output against an ABNF grammar. While the function calls ngx_http_clean_header and sets header values, it does not contain any explicit verification or enforcement ensuring that the generated protocol elements adhere to the ABNF rules. The reliance on such external functions does not count toward the function's own implementation of the requirement. Therefore, the function does not visibly address the labeled spec constraint.",success,
3561,ngx_http_image_json,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,36,Fully Matches,"[{'C1': {'code': 'if (ctx == NULL) {\n    b->pos = (u_char *) ""{}"" CRLF;\n    b->last = b->pos + sizeof(""{}"" CRLF) - 1;\n    ...\n}\n...\n b->last = ngx_sprintf(b->pos,\n                      ""{ \\""img\\"" : { \\""width\\"": %uz, \\""height\\"": %uz, \\""type\\"": \\""%s\\"" } }"" CRLF,\n                      ctx->width, ctx->height,\n                      ngx_http_image_types[ctx->type - 1].data + 6);', 'explanation': 'Both branches of the function explicitly append CRLF (via the CRLF macro) to the JSON output. This ensures that only CRLF is used for line breaks in the generated message body, directly aligning with the RFC requirement.'}}]","The RFC specifies that a sender MUST generate only CRLF to represent line breaks between body parts. In the provided function, regardless of whether the JSON response is a simple empty JSON or one containing image data, the output string is constructed by appending a CRLF literal. This shows that the function itself enforces the use of CRLF exclusively for its line breaks, thereby fully matching the specified RFC condition within the function's own logic.",success,
3561,ngx_http_image_json,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'r->headers_out.content_type_len = sizeof(""application/json"") - 1;\nngx_str_set(&r->headers_out.content_type, ""application/json"");', 'explanation': ""The function explicitly sets the Content-Type header to 'application/json' when generating the message content, which directly addresses the RFC requirement to include a Content-Type header when content is present and the media type is known.""}}]","The RFC states that a sender generating a message with content should include a Content-Type header unless the media type is unknown. This function always sets the header to 'application/json', therefore visibly addressing this requirement within its code. All logic relevant to this RFC requirement is implemented directly in the function_body.",success,
3564,ngx_http_image_length,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Partially Matches,"[{'A1': {'code': 'r->headers_out.content_length_n = b->last - b->pos;\n\nif (r->headers_out.content_length) {\n    r->headers_out.content_length->hash = 0;\n}\n\nr->headers_out.content_length = NULL;', 'explanation': 'The function computes the message body length by subtracting b->pos from b->last and stores it in the numeric content_length field. It then disables any existing content_length header by resetting its hash and pointer. This is an effort to produce a valid, length-delimited response, which aligns with the RFC’s recommendation that a server SHOULD generate encoding or length-delimited messages whenever possible. However, it does not implement the other parts of the RFC specification (such as error handling for invalid Content-Length fields or other framing conditions), so only part of the behavior is handled.'}}]","While the RFC requires that a server produce a valid length-delimited message to distinguish between a complete response and a prematurely terminated one, this function solely calculates and sets the content length based on an in-memory buffer. It also clears any redundant header so that only the computed numeric value is used. Though this corresponds to the action (A1) of ensuring responses are length-delimited, it does not implement the full array of response framing or error handling logic described in the RFC. Therefore, the code function partially matches the specified RFC requirements by handling only a subset of the needed behavior.",success,
3564,ngx_http_image_length,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The function calculates a new content_length value based on the buffer (b->last - b->pos) and then disables any existing content_length header by clearing its hash and setting the pointer to NULL. However, it does not perform any validation or checking against an incorrect or malformed Content-Length header value as required by the RFC specification. There is no logic in this function that verifies if the Content-Length header is known to be incorrect or if it complies with the ABNF rules, and it does not handle the case of duplicated comma-separated values. Therefore, it does not visibly implement any of the spec constraints (e.g., C1 or A1) by itself.",success,
3617,ngx_http_grpc_create_request,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Fully Matches,"[{'C1': {'code': 'if (r->method == NGX_HTTP_GET) {\n    *b->last++ = ngx_http_v2_indexed(NGX_HTTP_V2_METHOD_GET_INDEX);\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""grpc header: "":method: GET"""");\n} else if (r->method == NGX_HTTP_POST) {\n    *b->last++ = ngx_http_v2_indexed(NGX_HTTP_V2_METHOD_POST_INDEX);\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""grpc header: "":method: POST"""");\n} else {\n    *b->last++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_METHOD_INDEX);\n    b->last = ngx_http_v2_write_value(b->last, r->method_name.data, r->method_name.len, tmp);\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""grpc header: "":method: %V"""", &r->method_name);\n}\n\n#if (NGX_HTTP_SSL)\n    if (u->ssl) {\n        *b->last++ = ngx_http_v2_indexed(NGX_HTTP_V2_SCHEME_HTTPS_INDEX);\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""grpc header: "":scheme: https"""");\n    } else\n#endif\n    {\n        *b->last++ = ngx_http_v2_indexed(NGX_HTTP_V2_SCHEME_HTTP_INDEX);\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""grpc header: "":scheme: http"""");\n    }\n\nif (r->valid_unparsed_uri) {\n    if (r->unparsed_uri.len == 1 && r->unparsed_uri.data[0] == \'/\') {\n        *b->last++ = ngx_http_v2_indexed(NGX_HTTP_V2_PATH_ROOT_INDEX);\n    } else {\n        *b->last++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_PATH_INDEX);\n        b->last = ngx_http_v2_write_value(b->last, r->unparsed_uri.data, r->unparsed_uri.len, tmp);\n    }\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""grpc header: "":path: %V"""", &r->unparsed_uri);\n} else if (escape || r->args.len > 0) {\n    // ... (constructs the path using uri and args)\n} else {\n    *b->last++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_PATH_INDEX);\n    b->last = ngx_http_v2_write_value(b->last, r->uri.data, r->uri.len, tmp);\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""grpc header: "":path: %V"""", &r->uri);\n}\n\nif (!glcf->host_set) {\n    *b->last++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_AUTHORITY_INDEX);\n    b->last = ngx_http_v2_write_value(b->last, ctx->host.data, ctx->host.len, tmp);\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""grpc header: "":authority: %V"""", &ctx->host);\n}', 'explanation': 'This segment shows that the function explicitly constructs only the pseudo-header fields permitted for a client request such as :method, :scheme, :path, and :authority. It does not generate any protocol element that belongs exclusively to another role (for example, a server’s :status header). This conforms to the RFC requirement that a sender must not generate protocol elements or syntax alternatives exclusive to other roles.'}}]","The function 'ngx_http_grpc_create_request' builds a gRPC request over HTTP/2 by selectively forming only those pseudo-headers that are valid for a client. It explicitly checks the request method to generate the :method header, determines the scheme based on whether SSL is being used, and constructs the :path and :authority headers accordingly. By doing so, it avoids producing any headers that are reserved for another role (such as server-specific headers), thereby complying with the specification that a sender must not generate protocol elements only meant for participants in other roles. All of the logic to generate these headers is implemented directly in the function, satisfying the requirement fully.",success,
3627,ngx_http_grpc_process_header,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Fully Matches,"[{'C1': {'code': 'if (ctx->name.len && ctx->name.data[0] == \':\') {\n    if (ctx->name.len != sizeof("":status"") - 1 || ngx_strncmp(ctx->name.data, "":status"", sizeof("":status"") - 1) != 0) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""upstream sent invalid header \\""%V: %V\\"""",\n                      &ctx->name, &ctx->value);\n        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n    }\n    if (ctx->status) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""upstream sent duplicate :status header"");\n        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n    }\n    ...\n}', 'explanation': ""This segment of code inspects the pseudo header (':status') which is critical for HTTP/2 semantics. It validates its existence, its format (ensuring exactly 3 digits), and uniqueness. This ensures that the protocol element is interpreted exactly as defined by the RFC, and if not, the sender is considered to be implementing the protocol incorrectly.""}}, {'A1': {'code': 'if (ctx->type != NGX_HTTP_V2_HEADERS_FRAME\n    && ctx->type != NGX_HTTP_V2_CONTINUATION_FRAME)\n{\n    /* priority, unknown frames */\n    if (b->last - b->pos < (ssize_t) ctx->rest) {\n        ctx->rest -= b->last - b->pos;\n        b->pos = b->last;\n        return NGX_AGAIN;\n    }\n    b->pos += ctx->rest;\n    ctx->rest = 0;\n    ctx->state = ngx_http_grpc_st_start;\n\n    continue;\n}', 'explanation': 'This code snippet deals with frames that are not header-related (i.e. unrecognized or unsupported in the header block). By discarding or skipping over such frames, it follows the RFC requirement that implementations must ignore extensions or unknown protocol elements unless they disrupt security, thereby adhering to the recovery mechanism stipulated.'}}]","The function 'ngx_http_grpc_process_header' parses incoming gRPC header frames over HTTP/2 and validates them against expected semantics. It explicitly checks for key protocol elements—most notably the mandatory ':status' pseudo header—and rejects duplicate or malformed occurrences. Additionally, the function contains logic to discard or safely skip unknown or out-of-context frames (such as unexpected DATA, CONTINUATION, or PUSH_PROMISE frames) in accordance with the RFC’s directives. This clearly shows that the function, by itself, implements the core requirement that a recipient must interpret a received protocol element based on the defined semantics unless evidence indicates a sender’s implementation error.",success,
3627,ngx_http_grpc_process_header,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (ctx->state < ngx_http_grpc_st_payload) {\n    rc = ngx_http_grpc_parse_frame(r, ctx, b);\n\n    if (rc == NGX_AGAIN) {\n        if (!ctx->parsing_headers) {\n            b->pos = b->start;\n            b->last = b->pos;\n        }\n        return NGX_AGAIN;\n    }\n\n    if (rc == NGX_ERROR) {\n        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n    }\n\n    /* Additional defensive checks on frame type and stream id follow ... */\n}\n\n... \n\nif (b->last - b->pos < (ssize_t) ctx->rest) {\n    ctx->rest -= b->last - b->pos;\n    b->pos = b->last;\n    return NGX_AGAIN;\n}\n\nb->pos += ctx->rest;\nctx->rest = 0;\nctx->state = ngx_http_grpc_st_start;', 'explanation': 'This segment demonstrates that the function parses the gRPC frame in a defensive manner, checking for insufficient data, unexpected frame types, and invalid stream identifiers. When the data is incomplete, it returns NGX_AGAIN, and in error cases it promptly returns an error code, which aligns with the RFC’s recommendation for defensive parsing.'}}, {'A1': {'code': 'if (ctx->name.len && ctx->name.data[0] == \':\') {\n    if (ctx->name.len != sizeof("":status"") - 1\n        || ngx_strncmp(ctx->name.data, "":status"",\n                       sizeof("":status"") - 1) != 0)\n    {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""upstream sent invalid header \\""%V: %V\\"""",\n                      &ctx->name, &ctx->value);\n        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n    }\n\n    if (ctx->status) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""upstream sent duplicate :status header"");\n        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n    }\n\n    status_line = &ctx->value;\n\n    if (status_line->len != 3) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""upstream sent invalid :status \\""%V\\"""",\n                      status_line);\n        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n    }\n\n    status = ngx_atoi(status_line->data, 3);\n\n    if (status == NGX_ERROR) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""upstream sent invalid :status \\""%V\\"""",\n                      status_line);\n        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n    }\n\n    if (status < NGX_HTTP_OK) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""upstream sent unexpected :status \\""%V\\"""",\n                      status_line);\n        return NGX_HTTP_UPSTREAM_INVALID_HEADER;\n    }\n\n    u->headers_in.status_n = status;\n\n    if (u->state && u->state->status == 0) {\n        u->state->status = status;\n    }\n\n    ctx->status = 1;\n    continue;\n}', 'explanation': 'This code validates the :status header rigorously by checking whether the header name exactly matches "":status"", ensuring the header value is exactly 3 characters long, converting it to an integer, and ensuring it is within the expected range. Such verifications are in line with the RFC\'s requirements for defensive parsing in uncertain conditions.'}}]","The function 'ngx_http_grpc_process_header' implements a defensive parsing strategy as recommended by the RFC. It performs multiple validity checks on the incoming gRPC/HTTP2 frames, including verifying frame types, data completeness, and specific header constraints such as the :status header. All of these actions are contained within the function and ensure that even if the protocol element does not strictly conform to its expected grammar, the function handles it gracefully by returning error codes or deferring parsing (via NGX_AGAIN) until more data is available. This internal logic clearly addresses the spec constraints regarding defensive parsing of a protocol element.",success,
3628,ngx_http_grpc_filter_init,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'if (ctx->end_stream) {\n    if (ctx->length > 0) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""upstream prematurely closed stream"");\n        return NGX_ERROR;\n    }\n\n    u->length = 0;\n    ctx->done = 1;\n}', 'explanation': 'This code block checks if the stream has ended and the computed Content-Length (ctx->length) is non-zero, which suggests a mismatch between the actual message framing and the Content-Length header. In this case, the function logs an error and returns NGX_ERROR, thereby preventing the forwarding of a message with an incorrect Content-Length. This partially meets the RFC requirement that a sender MUST NOT forward a message with a known incorrect Content-Length header field value.'}}]","The RFC requires that a sender must not forward a message when the Content-Length header field is known to be incorrect. The function attempts to enforce this by checking if the stream has ended while a non-zero Content-Length is still expected, and it then returns an error to prevent further processing. However, the complete set of checks described in the RFC—such as validating the Content-Length formatting (e.g., handling comma‐separated lists of identical numbers) or other parsing concerns—are not handled by this function. Therefore, while some aspects of the RFC (specifically the action of not forwarding when an inconsistency is detected) are present, the implementation within this function is only partial in its adherence to the full specification.",success,
3628,ngx_http_grpc_filter_init,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,61,Partially Matches,"[{'C1': {'code': 'if (u->headers_in.status_n == NGX_HTTP_NO_CONTENT\n    || u->headers_in.status_n == NGX_HTTP_NOT_MODIFIED\n    || r->method == NGX_HTTP_HEAD)\n{\n    ctx->length = 0;\n}', 'explanation': 'This code block checks if the request method is HEAD (as well as cases for HTTP 204 and 304) and sets the content length to 0. This implements the RFC requirement that a HEAD response must not send content. However, while this ensures no body is sent, the function does not explicitly handle other header similarities between GET and HEAD responses, hence the implementation is partial.'}}]","The function explicitly checks for the HEAD method and, in that case, sets the content length to zero, blocking any response body from being sent. This addresses the core requirement of the RFC that a HEAD response must not include response content. Nonetheless, the RFC also notes that header fields should mirror those that would be sent on a GET response, a detail which is not handled within this function. Therefore, the implementation in this function only partially covers the RFC specification.",success,
3629,ngx_http_grpc_filter,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (ctx->state < ngx_http_grpc_st_payload) {\n    rc = ngx_http_grpc_parse_frame(r, ctx, b);\n    if (rc == NGX_AGAIN) {\n        ...\n    } else if (rc == NGX_ERROR) {\n        return NGX_ERROR;\n    }\n    ...\n}\n\n/* Additional parsing logic for various frame types */', 'explanation': 'The function explicitly inspects and parses different HTTP/2 (gRPC) frames (DATA, HEADERS, SETTINGS, PING, etc.) and applies error checking, which reflects an attempt to interpret the received protocol elements according to the semantics defined by the specification. This corresponds to the requirement in C1 that the recipient must interpret the elements per spec.'}}, {'A1': {'code': 'if (ctx->flags & NGX_HTTP_V2_PADDED_FLAG) {\n    if (ctx->rest == 0) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""upstream sent too short http2 frame"");\n        return NGX_ERROR;\n    }\n    ...\n    if (ctx->padding > ctx->rest) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""upstream sent http2 frame with too long padding: %d in frame %uz"",\n                      ctx->padding, ctx->rest);\n        return NGX_ERROR;\n    }\n    continue;\n}', 'explanation': 'The code validates padding lengths within a frame and ensures that any deviation (e.g. too long padding) leads to an error. This demonstrates an active attempt to enforce correct protocol semantics by rejecting frames whose structure does not comply with the specification.'}}]","The function implements a frame processor for gRPC over HTTP/2 by parsing various frame types and checking for errors such as unexpected frame order, invalid padding, stream control violations, and content length mismatches. These checks reflect an attempt to apply the semantics defined in the RFC (i.e. interpreting and validating received protocol elements). However, while several conditions (e.g. C1) and actions (e.g. A1) are visibly addressed in the code, not all aspects of the RFC (such as comprehensive error recovery strategies or configuration‐based deviation handling) are implemented solely in this function. As a result, the implementation partially matches the specified constraints.",success,
3629,ngx_http_grpc_filter,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (b->last - b->pos < (ssize_t) ctx->rest) {\n    ctx->rest -= b->last - b->pos;\n    b->pos = b->last;\n    return NGX_AGAIN;\n}\n\n...\n\nif (b->last - b->pos < (ssize_t) ctx->rest - ctx->padding) {\n    ctx->rest -= b->last - b->pos;\n    b->pos = b->last;\n    buf->last = b->pos;\n    return NGX_AGAIN;\n}', 'explanation': 'These checks ensure that before any part of a frame (or its padding) is processed, the code verifies there are sufficient bytes available in the buffer. This is a core aspect of defensive parsing as prescribed by the RFC.'}}, {'A1': {'code': 'ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n              ""upstream sent too short http2 frame"");\nreturn NGX_ERROR;\n\n...\n\nngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n              ""upstream sent invalid trailer"");\nreturn NGX_ERROR;', 'explanation': 'The function logs errors and returns error codes when encountering frames that do not meet expected minimal lengths or when unexpected protocol elements are encountered. This behavior aligns with the action of robustly handling nonconforming protocol input.'}}]","The function is designed to process gRPC HTTP/2 frames in a defensive manner. It systematically checks that the buffer contains the required amount of data before parsing each component (such as frame payloads and padding), and it logs errors and returns failure codes when anomalies are detected. These measures directly address the RFC's recommendation that a recipient should parse a received protocol element defensively, expecting only marginal conformance to the expected grammar and buffer size limitations. As such, the code function by itself visibly implements the necessary defensive parsing logic.",success,
3630,ngx_http_grpc_parse_frame,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Does Not Match,[],"The provided function performs basic parsing of a gRPC frame header by reading bytes into its fields (length, type, flags, stream ID) and includes a check for oversized frames. However, it does not implement any logic that interprets the protocol element according to the full semantics defined by the RFC specification. In other words, while it parses the header, it does not address the requirement stated in the spec (e.g., interpreting the received element, handling extensions, or recovering from invalid constructs) solely within its own logic. Therefore, no specific condition (C1, C2, etc.) or action (A1, A2, etc.) is fully implemented inside this function.",success,
3630,ngx_http_grpc_parse_frame,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (ctx->rest > NGX_HTTP_V2_DEFAULT_FRAME_SIZE) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent too large http2 frame: %uz"",\n                  ctx->rest);\n    return NGX_ERROR;\n}', 'explanation': 'This code segment checks that the parsed frame length does not exceed a predefined default frame size, which is a defensive measure to avoid processing oversized or malformed protocol elements.'}}]","The function implements a basic state-machine parser for GRPC frames and defensively checks one key aspect of the specification by validating the frame's length against a reasonable maximum (NGX_HTTP_V2_DEFAULT_FRAME_SIZE). This corresponds to the principle of marginal expectations on the data's conformity and buffer size. However, defensive parsing demands broader checks (e.g., validating overall structure and conformance to an ABNF grammar) and other robustness measures which are not present in this function. Therefore, while a part of the spec (labelled as C1) is implemented within the function, not all elements of the RFC requirement are addressed solely by this function, resulting in a 'Partially Matches' outcome.",success,
3631,ngx_http_grpc_parse_header,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (ctx->rest < min) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent headers frame with invalid length: %uz"",\n                  ctx->rest);\n    return NGX_ERROR;\n}', 'explanation': ""This check ensures that the incoming frame meets a minimum expected length based on its flags. It defends against malformed input by not assuming that the frame conforms to the protocol's ABNF grammar or a particular buffer size.""}}, {'A1': {'code': 'if (ctx->padding > ctx->rest) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent http2 frame with too long padding: %d in frame %uz"",\n                  ctx->padding, ctx->rest);\n    return NGX_ERROR;\n}', 'explanation': 'This code ensures that the declared padding does not exceed the remaining data in the frame. It is an additional defensive measure that handles variable lengths and abnormal conditions, as suggested by the spec.'}}]","The function implements defensive parsing logic by verifying that certain minimal length conditions are met and by checking that the framing parameters such as padding are within allowed boundaries. This reflects the RFC's advice to parse protocol elements defensively, with only marginal assumptions about their correctness or conformity to an ABNF grammar. All validations are performed within this function without relying on external dependencies, which means it fully addresses the defensive parsing requirements of the spec.",success,
3631,ngx_http_grpc_parse_header,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (ctx->rest < min) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent headers frame ""\n                  ""with invalid length: %uz"",\n                  ctx->rest);\n    return NGX_ERROR;\n}', 'explanation': 'This segment checks that the frame length is at least the minimum required by the protocol (depending on PADDED and PRIORITY flags), thereby enforcing correct interpretation of the protocol element as required.'}}, {'A1': {'code': 'if (ctx->padding > ctx->rest) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent http2 frame with too long ""\n                  ""padding: %d in frame %uz"",\n                  ctx->padding, ctx->rest);\n    return NGX_ERROR;\n}', 'explanation': 'This code verifies that the padding field is within bounds. It actively logs an error and returns an error code if the padding is longer than the remaining frame length, which aligns with the action of reacting when a protocol element is determined to be invalid.'}}]","The function implements logic to parse a GRPC HTTP/2 header frame by checking the validity of frame length, handling various frame flags (PADDED, PRIORITY, etc.), and ensuring that fields such as padding do not exceed the expected length. These checks partially meet the RFC directive to interpret received protocol elements according to prescribed semantics. However, while it does perform critical validations and error logging, additional layers of recovery or handling of misbehaving senders (as hinted by the full text of the RFC and its extensions) are not fully implemented in this function itself. Consequently, the implementation in this function is considered to only partially match the overall RFC constraints.",success,
3633,ngx_http_grpc_parse_fragment,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (b->last - b->pos < (ssize_t) ctx->rest - ctx->padding) {\n    last = b->last;\n} else {\n    last = b->pos + ctx->rest - ctx->padding;\n}\n\n...\nif (ctx->field_length == 0) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent zero http2 header name length"");\n    return NGX_ERROR;\n}\n\n...\nif (ctx->field_rest == 0) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent too large http2 header value length"");\n    return NGX_ERROR;\n}\n', 'explanation': 'This code carefully checks that the input data fits within the expected buffer boundaries and uses a state machine to validate various parts (like header name and value lengths), returning errors when protocol elements do not conform to expected ranges. This defensive parsing is exactly in line with the spec requirement.'}}, {'A1': {'code': 'switch (state) {\n    case sw_start:\n        ...\n        if ((ch & 0x80) == 0x80) {\n            index = ch & ~0x80;\n            if (index == 0 || index > 61) {\n                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                              ""upstream sent invalid http2 table index: %ui"", index);\n                return NGX_ERROR;\n            }\n            ...\n        }\n        ...\n        case sw_name_length:\n            ctx->field_huffman = ch & 0x80 ? 1 : 0;\n            ctx->field_length = ch & ~0x80;\n            if (ctx->field_length == 0x7f) {\n                state = sw_name_length_2;\n                break;\n            }\n            if (ctx->field_length == 0) {\n                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                              ""upstream sent zero http2 header name length"");\n                return NGX_ERROR;\n            }\n            state = sw_name;\n            break;\n    ...\n}', 'explanation': 'The function implements a detailed, multi-step state machine for parsing header fragments, including validation of both static and dynamic components of HTTP/2 header encoding. It logs errors and aborts on invalid inputs, demonstrating a defensive parsing strategy by itself.'}}]","The function 'ngx_http_grpc_parse_fragment' is responsible for parsing gRPC header fragments in a defensive manner. It checks that it does not read beyond the provided buffer and validates various protocol elements (such as header index, header name length, and header value length) against expected limits. Error conditions are detected and reported with relevant log messages, fulfilling the requirements described in the spec to parse with only marginal expectations of conformity and to be defensive. As a result, the function visibly addresses the spec constraints (here labeled as C1 and A1) entirely within its own implementation.",success,
3633,ngx_http_grpc_parse_fragment,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (ctx->field_length == 0) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent zero http2 header name length"");\n    return NGX_ERROR;\n}\n\n...\n\nif (ngx_http_grpc_validate_header_name(r, &ctx->name) != NGX_OK) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent invalid header: \\""%V: %V\\"""",\n                  &ctx->name, &ctx->value);\n    return NGX_ERROR;\n}\n\nif (ngx_http_grpc_validate_header_value(r, &ctx->value) != NGX_OK) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent invalid header: \\""%V: %V\\"""",\n                  &ctx->name, &ctx->value);\n    return NGX_ERROR;\n}', 'explanation': 'The code verifies the integrity of header components by checking header name length, ensuring header indexes fall within valid ranges, and finally validating header name and value via dedicated validation functions. This represents an attempt to enforce that protocol elements adhere to the HTTP/2 header grammar defined by ABNF rules as required by the spec.'}}]","The function implements parsing for gRPC header fragments and embeds various checks (for header field lengths, valid indices, and proper encoding) that help ensure incoming header data conforms to the HTTP protocol grammar. Although the RFC requirement targets senders not to generate invalid protocol elements, this parser function performs its own validation to reject headers that are not formed according to standards. Since the function only handles parsing/validation rather than header generation, it only partially addresses the spec constraint in its scope.",success,
3633,ngx_http_grpc_parse_fragment,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (index == 0 || index > 61) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent invalid http2 table index: %ui"", index);\n    return NGX_ERROR;\n}', 'explanation': 'The function verifies that any header table index received is within the allowed bounds. This check is an example of interpreting the protocol element according to defined semantics, ensuring that invalid table indexes are rejected.'}}, {'A1': {'code': 'if (ctx->field_length == 0) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent zero http2 header name length"");\n    return NGX_ERROR;\n}', 'explanation': 'The function enforces that a header name must have a non-zero length by logging an error and returning an error condition. This is part of ensuring that header fields are semantically valid as required by the spec.'}}]","The function implements a considerable portion of header parsing by decoding header fragments, validating header indexes and lengths, and performing error logging when encountering protocol violations. These measures practice checking and interpreting received protocol elements in line with the RFC's semantics. However, while these validations address some of the conditions (for example, checking header indexes and non‐zero header names), the function does not fully implement every aspect of interpreting and recovering from all invalid constructs as suggested by the full specification. Therefore, the code function only partially meets the spec constraints when considered in isolation.",success,
3636,ngx_http_grpc_validate_header_value,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': ""for (i = 0; i < s->len; i++) {\n    ch = s->data[i];\n\n    if (ch == '\\0' || ch == CR || ch == LF) {\n        return NGX_ERROR;\n    }\n}"", 'explanation': 'This loop defensively scans the header value checking for NUL, CR, and LF characters, which is one aspect of parsing protocol elements defensively.'}}]","The RFC expects a recipient to parse protocol elements defensively with limited assumptions about their compliance with the ABNF grammar and reasonable lengths. The provided function implements a defensive check by iterating through the header value and rejecting those that contain prohibited control characters (NUL, CR, LF). However, it does not address other aspects, such as ensuring the header truly conforms to its ABNF grammar or managing buffer size expectations. Thus, the function partially matches the intended RFC defensive parsing requirements by only handling a subset of the expected conditions.",success,
3636,ngx_http_grpc_validate_header_value,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': ""if (ch == '\\0' || ch == CR || ch == LF) {\n    return NGX_ERROR;\n}"", 'explanation': 'This segment detects disallowed characters (null, CR, LF) in the header value, which aligns with a typical constraint (C1) of preventing invalid constructs in header fields. However, rather than attempting to recover a usable header element (as the RFC permits), it simply returns an error.'}}]","The provided function examines each character of the header value and returns an error if any prohibited characters are found, thereby enforcing a validation against invalid constructs. This behavior partially matches the relevant RFC requirement: while the RFC allows a recipient to attempt recovery from invalid constructs, the function does not attempt any recovery—it merely performs a strict check and exits with an error. Since the recovery aspect is not addressed within the function itself, it only partially fulfills the RFC's guidance.",success,
3636,ngx_http_grpc_validate_header_value,"A recipient SHOULD treat other allowed octets in field content (i.e., obs-text) as opaque data.",235,Partially Matches,"[{'C1': {'code': ""if (ch == '\\0' || ch == CR || ch == LF) {\n    return NGX_ERROR;\n}"", 'explanation': 'This segment iterates over each character in the header value and immediately rejects (returns an error) if a NUL (\\0), carriage return (CR), or line feed (LF) character is encountered. This directly implements the part of the RFC that indicates such characters are dangerous or invalid in header fields.'}}]","The function checks for CR, LF, and NUL characters in the header value and rejects the header if any are found, which satisfies the spec requirement regarding dangerous characters. However, the RFC also specifies treating other allowed octets (obs-text) as opaque data and issues related to leading/trailing whitespace handling, but this function does not address those aspects. Therefore, the implementation only partially matches the outlined spec constraints.",success,
3636,ngx_http_grpc_validate_header_value,"Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message.",3,Fully Matches,"[{'C1': {'code': ""if (ch == '\\0' || ch == CR || ch == LF) {\n    return NGX_ERROR;\n}"", 'explanation': 'This code explicitly checks for NUL, CR, or LF characters in a header field value and rejects the message (by returning NGX_ERROR) if any are found, which fulfills the requirement that such characters must cause the message to be rejected or replaced.'}}]","The function iterates over each character in the header field value and checks for the presence of the dangerous characters (NUL, CR, and LF). Upon encountering any, it rejects the message by returning an error. This behavior directly and fully implements the spec constraint that field values containing these characters must be rejected (or replaced with SP, with rejection being an acceptable alternative), thereby fully matching the RFC specification.",success,
3636,ngx_http_grpc_validate_header_value,A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.,173,Fully Matches,"[{'C1': {'code': ""for (i = 0; i < s->len; i++) {\n    ch = s->data[i];\n\n    if (ch == '\\0' || ch == CR || ch == LF) {\n        return NGX_ERROR;\n    }\n}\n\nreturn NGX_OK;"", 'explanation': 'The RFC specifies that any header element containing a bare CR must be considered invalid (or, alternatively, the CR should be replaced with a SP). This function iterates over each character of a header value and returns an error (NGX_ERROR) if it encounters a CR (as well as LF and the null character). By doing so, it directly implements the required behavior of invalidating header values containing a bare CR.'}}]","The function 'ngx_http_grpc_validate_header_value' explicitly validates the header value by scanning each character and returning an error if a CR (or LF or null) is found, thereby treating the element as invalid. This directly fulfills the RFC requirement that a bare CR should result in the element being considered invalid (one acceptable interpretation of the spec). All logic addressing the relevant spec constraint is contained within this function, so it fully matches the specified constraint.",success,
3637,ngx_http_grpc_parse_rst_stream,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (state == sw_start) {\n    if (ctx->rest != 4) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""upstream sent rst stream frame ""\n                      ""with invalid length: %uz"",\n                      ctx->rest);\n        return NGX_ERROR;\n    }\n}', 'explanation': 'This segment checks that the received protocol element (the RST_STREAM frame) has exactly 4 bytes as expected. It enforces the specification requirement that a recipient must validate the semantic structure of the protocol element.'}}, {'A1': {'code': 'for (p = b->pos; p < last; p++) {\n    ch = *p;\n    switch (state) {\n    case sw_start:\n        ctx->error = (ngx_uint_t) ch << 24;\n        state = sw_error_2;\n        break;\n    case sw_error_2:\n        ctx->error |= ch << 16;\n        state = sw_error_3;\n        break;\n    case sw_error_3:\n        ctx->error |= ch << 8;\n        state = sw_error_4;\n        break;\n    case sw_error_4:\n        ctx->error |= ch;\n        state = sw_start;\n\n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       ""grpc error: %ui"", ctx->error);\n        break;\n    }\n}', 'explanation': 'This state-machine loop processes each byte of the protocol element and reassembles the error code, reflecting an interpretation of the received data structure as defined by the RFC. It also ensures that the parsed protocol element is properly processed before moving on.'}}]","The function is responsible for parsing a gRPC RST_STREAM frame by first checking that the frame length is exactly 4 bytes and then processing the four bytes via a state machine to construct an error code. These two main segments directly address two aspects of the RFC requirement: validating the structure of a protocol element and interpreting its contents according to the defined semantics. However, the function does not incorporate additional logic such as sophisticated error recovery or adjustments based on prior knowledge of sender misbehavior (which the RFC context hints at might be needed in some cases). Consequently, while the function visibly implements key aspects (C1 and A1) of the specification for interpreting a protocol element, it does not fully address all potential extensions or error recovery mechanisms that might be implied by the broader RFC context, yielding a partial match.",success,
3637,ngx_http_grpc_parse_rst_stream,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (ctx->rest != 4) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent rst stream frame with invalid length: %uz"",\n                  ctx->rest);\n    return NGX_ERROR;\n}', 'explanation': ""This segment defensively checks that the length of the frame is exactly 4 bytes, logging an error and aborting if not. This aligns with the RFC's recommendation for defensive parsing, ensuring that only protocol elements that reasonably fit the expected length are processed.""}}, {'A1': {'code': 'if (b->last - b->pos < (ssize_t) ctx->rest) {\n    last = b->last;\n} else {\n    last = b->pos + ctx->rest;\n}', 'explanation': 'This code determines the boundary for reading from the buffer based on the available data, thereby preventing buffer over-read and handling the case when the received data is less than expected. This is another example of defensive parsing behavior.'}}]","The function ngx_http_grpc_parse_rst_stream implements defensive parsing by first checking if the available buffer contains enough bytes and by validating that the frame length conforms to the expected 4 bytes. It then processes the frame byte-by-byte, updating the state machine accordingly. These behaviors demonstrate an attempt to parse the protocol element defensively as recommended by the RFC. However, the function only addresses these specific conditions (buffer length check and fixed-length validation) and does not encompass the full breadth of the RFC's expectations regarding ABNF conformity or variable element lengths. Hence, it partially matches the spec's requirements.",success,
3638,ngx_http_grpc_parse_goaway,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (b->last - b->pos < (ssize_t) ctx->rest) {\n        last = b->last;\n\n    } else {\n        last = b->pos + ctx->rest;\n    }', 'explanation': 'This segment calculates the available bytes in the buffer and adjusts the parsing limit accordingly, representing a defensive check against over-read. It partially implements the idea of expecting only a reasonable buffer size.'}}, {'A1': {'code': 'if (ctx->rest < 8) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent goaway frame with invalid length: %uz"",\n                  ctx->rest);\n    return NGX_ERROR;\n}', 'explanation': 'By ensuring that the remaining length (ctx->rest) is at least 8 bytes before proceeding, this code enforces a basic validity check for the protocol element, aligning with defensive parsing expectations.'}}]","The function implements part of the RFC specification by performing defensive parsing: it verifies that the available data fits within the expected bounds and checks for a minimum length requirement to avoid buffer overflow or underflow issues. However, it does not attempt to validate the full ABNF grammar of the protocol element, thus only partially addressing the overall RFC requirement.",success,
3640,ngx_http_grpc_parse_settings,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (b->last - b->pos < (ssize_t) ctx->rest) {\n    last = b->last;\n} else {\n    last = b->pos + ctx->rest;\n}', 'explanation': ""This code checks whether the buffer has at least as many bytes available as expected by 'ctx->rest', thereby ensuring that the parser does not read beyond the provided buffer. This is a defensive parsing measure in line with the specification.""}}, {'A1': {'code': 'if (ctx->rest % 6 != 0) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent settings frame with invalid length: %uz"",\n                  ctx->rest);\n    return NGX_ERROR;\n}', 'explanation': ""This snippet validates that the settings frame length is a multiple of 6 bytes (the expected size for each setting), defensively checking the protocol element's conformance to expected size constraints.""}}, {'A2': {'code': 'if (ctx->stream_id) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent settings frame with non-zero stream id: %ui"",\n                  ctx->stream_id);\n    return NGX_ERROR;\n}', 'explanation': 'This code ensures that a settings frame is only accepted on stream id 0. This defensive check is critical as per protocol expectations.'}}, {'A3': {'code': 'if (ctx->flags & NGX_HTTP_V2_ACK_FLAG) {\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   ""grpc settings ack"");\n\n    if (ctx->rest != 0) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""upstream sent settings frame with ack flag and non-zero length: %uz"",\n                      ctx->rest);\n        return NGX_ERROR;\n    }\n\n    ctx->state = ngx_http_grpc_st_start;\n\n    return NGX_OK;\n}', 'explanation': 'Here the function defensively handles the case where an ACK flag is set by making sure that no payload is present. This matches the defensive parsing required by the spec.'}}]","The function implements defensive parsing by verifying that the provided buffer is of an adequate size before parsing, checking that the length of the settings frame conforms to expectations (multiple of 6), and ensuring protocol-specific values (like stream id and ACK flag conditions) are valid. These checks directly address the RFC's requirement to parse received protocol elements defensively, thereby fully matching the specified constraints within the function body.",success,
3640,ngx_http_grpc_parse_settings,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (ctx->rest % 6 != 0) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent settings frame with invalid length: %uz"",\n                  ctx->rest);\n    return NGX_ERROR;\n}', 'explanation': ""This code segment validates that the length of the received settings frame is a multiple of 6, which is required by the protocol. This check is a direct attempt to interpret the frame according to the spec's semantics, as a recipient must validate that the received protocol element conforms to the expected structure.""}}, {'A1': {'code': 'if (ctx->flags & NGX_HTTP_V2_ACK_FLAG) {\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   ""grpc settings ack"");\n\n    if (ctx->rest != 0) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""upstream sent settings frame with ack flag and non-zero length: %uz"",\n                      ctx->rest);\n        return NGX_ERROR;\n    }\n\n    ctx->state = ngx_http_grpc_st_start;\n    return NGX_OK;\n}', 'explanation': 'This segment handles frames flagged as ACK. It ensures that if the ACK flag is set, the remainder of the frame length is zero, which is consistent with the protocol requirement that an ACK contains no payload. This represents an action dictated by the spec that the recipient must properly respond to the ACK condition.'}}]","The function attempts to implement parts of the HTTP RFC's requirements by validating settings frames. It checks critical frame properties such as ensuring a valid length (multiples of 6 bytes) and proper handling of ACK frames, as evidenced by logging errors and returning error codes for invalid constructs. However, while these segments directly address some of the mandated semantics (as per labeled conditions and actions), not all aspects of the RFC (such as comprehensive error recovery or interpretation of all protocol element extensions) are handled solely within this function. Thus, the implementation is considered partial.",success,
3640,ngx_http_grpc_parse_settings,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,[],"The provided code function is a parser for gRPC settings frames and includes several checks that enforce certain grammatical constraints (for example, ensuring that the frame length is a multiple of 6, verifying that an ACK frame has a length of 0, and that the stream ID is 0 for non-ACK frames). These checks are in the spirit of verifying the protocol‐specific grammar. However, the RFC specification states that a sender MUST NOT generate protocol elements that do not match the ABNF grammar. Since this function is concerned with parsing (i.e. receiving) settings rather than generating them, and because the function only implements a subset of the full grammar validation without covering all aspects of protocol element generation and roles, it only partially addresses the referenced constraint. Therefore, while the function does attempt to enforce some grammatical rules, it does not fully implement all the requirements associated with the constraint (e.g., it does not cover generator responsibilities or all nuances of the ABNF rules).",success,
3641,ngx_http_grpc_parse_ping,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Fully Matches,"[{'C1': {'code': 'if (ctx->stream_id) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent ping frame with non-zero stream id: %ui"",\n                  ctx->stream_id);\n    return NGX_ERROR;\n}', 'explanation': 'This block ensures that the ping frame is only accepted when the stream identifier is zero, which aligns with interpreting the ping frame per the RFC semantics.'}}, {'C2': {'code': 'if (ctx->rest != 8) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent ping frame with invalid length: %uz"",\n                  ctx->rest);\n    return NGX_ERROR;\n}', 'explanation': 'The code verifies that the length of the ping frame is exactly 8 bytes, as required by the specification for proper interpretation of the protocol element.'}}, {'C3': {'code': 'if (ctx->flags & NGX_HTTP_V2_ACK_FLAG) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent ping frame with ack flag"");\n    return NGX_ERROR;\n}', 'explanation': 'By checking and rejecting ping frames that have the ACK flag set, the function is strictly interpreting the protocol element in accordance with the RFC.'}}, {'A1': {'code': 'for (p = b->pos; p < last; p++) {\n    ch = *p;\n    if (state < sw_data_8) {\n        ctx->ping_data[state] = ch;\n        state++;\n    } else {\n        ctx->ping_data[7] = ch;\n        state = sw_start;\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       ""grpc ping"");\n    }\n}', 'explanation': 'This loop processes the 8-byte payload of the ping frame, adhering to the semantics defined by the protocol for correctly interpreting and handling the data field of the ping frame.'}}]","The function 'ngx_http_grpc_parse_ping' individually implements key aspects of the protocol's requirements by validating critical fields (such as stream id, frame length, and flags) and by processing the payload correctly. These checks ensure that the received ping frame is interpreted according to the semantics specified in the RFC. Each check corresponds directly to a protocol constraint (labeled here as C1, C2, and C3) and the payload processing matches the appropriate action (A1), demonstrating that the function fully matches the specified requirements.",success,
3641,ngx_http_grpc_parse_ping,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (b->last - b->pos < (ssize_t) ctx->rest) {\n    last = b->last;\n} else {\n    last = b->pos + ctx->rest;\n}', 'explanation': 'This code ensures that the parsing does not advance past the available buffer, thereby defensively handling a potentially undersized input buffer.'}}, {'C2': {'code': 'if (ctx->rest != 8) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent ping frame with invalid length: %uz"",\n                  ctx->rest);\n    return NGX_ERROR;\n}', 'explanation': 'This check enforces that the ping frame adheres to the expected fixed length (8 bytes), which is a basic validation of the protocol element’s structure.'}}, {'A1': {'code': 'if (ctx->stream_id) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent ping frame with non-zero stream id: %ui"",\n                  ctx->stream_id);\n    return NGX_ERROR;\n}\n\nif (ctx->flags & NGX_HTTP_V2_ACK_FLAG) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent ping frame with ack flag"");\n    return NGX_ERROR;\n}', 'explanation': 'This segment defensively checks for protocol rule violations by ensuring that the stream id is zero and the ack flag is not set, which is consistent with a correct ping frame.'}}, {'A2': {'code': 'if (ctx->free == NULL && ctx->pings++ > 1000) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""upstream sent too many ping frames"");\n    return NGX_ERROR;\n}', 'explanation': 'This code imposes a limit on the number of ping frames processed, serving as a defensive measure to avoid overwhelming the recipient.'}}]","The function shows defensive parsing techniques by checking that the buffer is large enough for the expected data (C1), validating that the ping frame has the precise length required (C2), and enforcing protocol-specific rules such as a zero stream id and absence of an ack flag (A1). It also incorporates a rate-limiting mechanism on the number of pings (A2). However, while these checks address several aspects of defensively parsing a protocol element as recommended in the RFC, the function does not encompass a complete ABNF grammar validation or handle all possible variations in element length specified by the HTTP guidelines. Thus, the implementation partially matches the overall defensive parsing approach described in the RFC specification.",success,
3642,ngx_http_grpc_send_settings_ack,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function simply constructs and sends a gRPC SETTINGS ACK frame. It creates the frame by setting the type, flags, and zeroing out other fields but does not perform any checks or include any logic that confirms the sender’s role is permitted to generate this frame. In other words, there is no conditional logic within the function to ensure that protocol elements which may be reserved for other roles are not generated. Therefore, the function’s implementation does not visibly address the RFC constraint that prohibits a sender from generating protocol elements reserved for other roles.",success,
3642,ngx_http_grpc_send_settings_ack,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'f->length_0 = 0;\n    f->length_1 = 0;\n    f->length_2 = 0;\n    f->type = NGX_HTTP_V2_SETTINGS_FRAME;\n    f->flags = NGX_HTTP_V2_ACK_FLAG;\n    f->stream_id_0 = 0;\n    f->stream_id_1 = 0;\n    f->stream_id_2 = 0;\n    f->stream_id_3 = 0;', 'explanation': 'The RFC requires that a sender must generate protocol elements that strictly conform to the ABNF grammar. In this function, a SETTINGS ACK frame is constructed by explicitly setting all fields (length, type, flags, stream identifier) in accordance with the defined HTTP/2 frame format. By initializing the frame with known valid constants (e.g., NGX_HTTP_V2_SETTINGS_FRAME and NGX_HTTP_V2_ACK_FLAG) and zero values where applicable, the function ensures that the generated frame adheres to the expected grammar.'}}]","The provided code function is responsible for constructing a gRPC SETTINGS acknowledgment frame. It directly assigns all fields of the frame to values that match the HTTP/2 frame's grammar as defined in the ABNF rules. Since the function sets each required field with predetermined, valid values (thereby not introducing any non-conforming protocol elements), it fully implements the specified RFC constraint as an isolated unit without relying on external dependencies.",success,
3644,ngx_http_grpc_send_window_update,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function constructs WINDOW_UPDATE frames, but it does not implement any checks or logic to ensure that protocol elements are generated only by the sender in its allowed role. In other words, while the spec requires that a sender must not generate protocol elements or syntax alternatives reserved for other roles, this function does not contain any conditional logic or role-based verification to address that requirement. It simply creates and sends frames without enforcing the role-based restriction, and therefore no labeled constraint from the spec (e.g., C1, A1) is met within this function.",success,
3652,ngx_http_grpc_internal_trailers_variable,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The provided function only checks for the presence of the substring ""trailers"" in the TE header field and sets a variable accordingly. It does not implement any logic related to merging trailer fields into the header section or verifying that such merging is safe as required by the HTTP RFC. None of the core conditions (e.g., ensuring safe merging per the header field definition) or actions required by the spec are addressed within this function.",success,
3677,ngx_http_userid_get_uid,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'cookie = ngx_http_parse_multi_header_lines(r, r->headers_in.cookie,\n                                           &conf->name, &ctx->cookie);\nif (cookie == NULL) {\n    return ctx;\n}', 'explanation': 'The function extracts and attempts to interpret a protocol element (the userid cookie) from the HTTP headers. This reflects an effort to follow the specification’s mandate to interpret a received protocol element using defined semantics.'}}, {'A1': {'code': 'if (ctx->cookie.len < 22) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""client sent too short userid cookie \\""%V\\"""",\n                  &cookie->value);\n    return ctx;\n}\n\n...\n\nif (ngx_decode_base64(&dst, &src) == NGX_ERROR) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""client sent invalid userid cookie \\""%V\\"""",\n                  &cookie->value);\n    return ctx;\n}', 'explanation': 'These code segments show that when the protocol element (the cookie) is invalid (too short or fails base64 decoding), the function logs an error and continues by returning the context. This approach indicates an attempt to recover from an invalid construct, which is in line with the RFC’s allowance to attempt recovery.'}}]","The function implements a partial interpretation of the RFC specification by extracting the userid cookie and decoding it, while logging errors and returning the current context if issues are encountered. This demonstrates that the function attempts to recover a usable protocol element in cases of invalid input. However, the overall handling does not incorporate all possible extensions or a more comprehensive interpretation as mandated by the spec, so the match is only partial.",success,
3677,ngx_http_userid_get_uid,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Fully Matches,"[{'C1': {'code': 'if (ctx->cookie.len < 22) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""client sent too short userid cookie ""%V"""",\n                  &cookie->value);\n    return ctx;\n}', 'explanation': 'This segment checks if the cookie is too short and, instead of rejecting the request outright, logs an error and returns a context. This follows the RFC guideline that a recipient MAY attempt to recover a usable protocol element from an invalid construct.'}}, {'A1': {'code': 'if (ngx_decode_base64(&dst, &src) == NGX_ERROR) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""client sent invalid userid cookie ""%V"""",\n                  &cookie->value);\n    return ctx;\n}', 'explanation': ""This block attempts to decode the cookie using base64. If decoding fails, it logs an error and returns the context, thereby recovering from the error in the cookie construct in accordance with the RFC's recommendations.""}}]","The function inspects the received cookie header and attempts error recovery when the input is invalid: it verifies the cookie's length and its base64 decoding. In both cases of invalid input, it logs an error and returns the context without aborting further processing. This behavior directly corresponds to the RFC specification that a recipient MAY recover a usable protocol element from an invalid construct, thus fully matching the recovery conditions specified.",success,
3677,ngx_http_userid_get_uid,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (ctx->cookie.len < 22) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""client sent too short userid cookie \\""%V\\"""",\n                  &cookie->value);\n    return ctx;\n}', 'explanation': 'This code checks if the received cookie is below a minimal length (22 characters), rejecting values that are too short. This is a defensive measure ensuring that the input fits within expected buffer sizes.'}}, {'A1': {'code': 'if (ngx_decode_base64(&dst, &src) == NGX_ERROR) {\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""client sent invalid userid cookie \\""%V\\"""",\n                  &cookie->value);\n    return ctx;\n}', 'explanation': 'Here the function attempts base64 decoding of the cookie value and logs an error if the decode fails. This is an instance of validating input content, a defensive approach consistent with the RFC’s recommendation to be cautious even if the input only marginally conforms to expected formats.'}}]","The function demonstrates defensive parsing by checking the minimal length of the cookie and by verifying whether base64 decoding succeeds, which aligns with parts of the RFC specification about defensiveness in parsing protocol elements. However, it does not perform a full validation against an ABNF grammar or a wider variety of possible input anomalies, thus only partially matching the requirements set forth in the spec.",success,
3678,ngx_http_userid_set_uid,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function constructs a Set-Cookie header (and optionally a P3P header) without any explicit checks to restrict generation based on the sender’s role. The RFC spec requires that a sender must not generate protocol elements that are only allowed to be generated by participants in other roles. There is no logic within the function to verify whether the protocol element (here, the cookie and P3P headers) is permitted for the sender’s role. Therefore, in the context of the spec, the function does not visibly address the condition or action corresponding to that requirement.",success,
3678,ngx_http_userid_set_uid,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,[],"The RFC requires that a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. In this function, the cookie header (and the P3P header) is assembled by concatenating fixed substrings (which are known to be syntactically correct) along with configurable values (such as the domain, path, and expires attributes). While the use of constant strings (e.g., ""; secure"", ""; httponly"", ""; samesite=strict"") suggests an attempt to adhere to a standard format, the function does not perform any active validation or enforcement to ensure that the configurable values actually follow the ABNF grammar. Consequently, while there is an implicit assumption that the fixed parts are correct, the dynamic input is inserted without verification. Therefore, the function partially addresses the RFC requirement but does not robustly implement the need to only generate protocol elements that match the grammar.",success,
3688,ngx_http_userid_path,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function only performs a memory allocation and string concatenation operation by prepending '; path=' to the given path string. It does not incorporate any logic to enforce or check that protocol elements are generated by the correct role or to ensure that only the allowed syntax alternatives are produced as mandated by the RFC specification. There is no conditional check or validation pertaining to the role of the sender, nor enforcement of grammar rules specific to HTTP as specified by the RFC. Therefore, the function does not address the spec constraints.",success,
3741,ngx_http_v3_send_settings,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'cc = ngx_http_v3_get_uni_stream(c, NGX_HTTP_V3_STREAM_CONTROL);', 'explanation': ""This code retrieves a unidirectional control stream before sending a SETTINGS frame. By doing so, it indicates the assumption that only an entity authorized to send control frames (i.e. the proper sender role) will proceed. However, it does not include explicit logic to verify or enforce that no protocol elements disallowed for the sender's role are generated.""}}]","The function constructs and sends an HTTP/3 SETTINGS frame by encoding expected fields and using an already-obtained unidirectional control stream. This indirectly addresses the RFC requirement that a sender must not generate protocol elements reserved for other roles by relying on the control stream retrieval. However, there is no explicit checking within the function to enforce that only allowed protocol elements are produced. Thus, while the function does implement part of the requirement, it does so only indirectly and does not fully enforce all aspects of the spec on its own.",success,
3741,ngx_http_v3_send_settings,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'p = (u_char *) ngx_http_v3_encode_varlen_int(buf, NGX_HTTP_V3_FRAME_SETTINGS);\n p = (u_char *) ngx_http_v3_encode_varlen_int(p, n);\n p = (u_char *) ngx_http_v3_encode_varlen_int(p, NGX_HTTP_V3_PARAM_MAX_TABLE_CAPACITY);\n p = (u_char *) ngx_http_v3_encode_varlen_int(p, h3scf->max_table_capacity);\n p = (u_char *) ngx_http_v3_encode_varlen_int(p, NGX_HTTP_V3_PARAM_BLOCKED_STREAMS);\n p = (u_char *) ngx_http_v3_encode_varlen_int(p, h3scf->max_blocked_streams);', 'explanation': 'This segment constructs the SETTINGS frame by encoding fields using ngx_http_v3_encode_varlen_int, ensuring that each protocol element conforms to the ABNF rules. By strictly assembling the frame with the proper type, length and parameter encodings, the function adheres to the RFC requirement that a sender must only generate protocol elements that match the defined grammar.'}}]","The function ngx_http_v3_send_settings builds an HTTP/3 SETTINGS frame by encoding necessary parameters (such as frame type, payload length, and specific settings values) with routines that ensure the produced elements conform to the grammar defined by the ABNF rules. This direct implementation of encoding logic satisfies the requirement that a sender must not generate invalid protocol elements.",success,
3753,ngx_http_v3_encode_prefix_int,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function implements an integer encoding algorithm (using a prefix scheme) and does not contain any logic that checks or restricts the generation of protocol elements based on sender roles, as required by the RFC specification. There is no inspection of the role or any enforcement mechanism that prevents the sender from generating protocol elements or syntax alternatives disallowed for its role. Therefore, none of the labeled constraints (e.g., C1 or A1) related to role-based message generation are addressed within this function.",success,
3754,ngx_http_v3_encode_field_section_prefix,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function focuses solely on encoding integer prefixes into a message buffer and does not incorporate any logic related to sender roles or preventing the generation of protocol elements that should only be created by other roles. There is no conditional check or validation within the function_body to ensure that the sender is not generating elements reserved for other participants. Thus, none of the labeled constraints from the spec (e.g., conditions about role-based generation of syntax elements) are visibly addressed by this code function.",success,
3755,ngx_http_v3_encode_field_ri,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function simply encodes an indexed field line by setting the prefix byte based on the 'dynamic' flag and encoding an integer using a helper function. It does not include any logic that checks or enforces that protocol elements are only generated by appropriate roles. In other words, no part of the function enforces the condition that a sender must not generate protocol elements or syntax alternatives that are reserved for other roles. Therefore, the function does not visibly address the specified RFC constraint.",success,
3756,ngx_http_v3_encode_field_lri,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'ngx_http_v3_encode_field_lri' solely focuses on encoding a literal header field line with a name reference and does not contain any logic to enforce role-based restrictions as outlined in the RFC specification. There is no check in the function to ensure that only protocol elements allowed by the sender’s role are generated; it simply encodes header fields (potentially even those that may be inappropriate for the current sender role). Thus, no part of the logic in this function directly addresses the constraint that a sender MUST NOT generate protocol elements or syntax alternatives that are reserved for other roles.",success,
3756,ngx_http_v3_encode_field_lri,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (p == NULL) {\n    return ngx_http_v3_encode_prefix_int(NULL, index, 4)\n           + ngx_http_v3_encode_prefix_int(NULL, len, 7)\n           + len;\n}\n\n*p = dynamic ? 0x40 : 0x50;\np = (u_char *) ngx_http_v3_encode_prefix_int(p, index, 4);\n\np1 = p;\n*p = 0;\np = (u_char *) ngx_http_v3_encode_prefix_int(p, len, 7);\n\nif (data) {\n    p2 = p;\n    hlen = ngx_http_huff_encode(data, len, p, 0);\n\n    if (hlen) {\n        p = p1;\n        *p = 0x80;\n        p = (u_char *) ngx_http_v3_encode_prefix_int(p, hlen, 7);\n\n        if (p != p2) {\n            ngx_memmove(p, p2, hlen);\n        }\n\n        p += hlen;\n\n    } else {\n        p = ngx_cpymem(p, data, len);\n    }\n}', 'explanation': 'The function constructs a protocol element by encoding prefix integers and optionally applying Huffman encoding. This approach is in line with producing the correct binary sequences based on fixed bit patterns (e.g., 0x40, 0x50, 0x80) and lengths. It implicitly relies on helper functions to format the data according to the protocol’s ABNF grammar. However, there is no explicit validation against the ABNF rules within this function itself.'}}]","The RFC requires that a sender must not generate protocol elements that fall outside the grammar defined by the ABNF rules. This function generates header field representations by explicitly writing bit patterns and using helper functions (e.g., for prefix integer encoding and Huffman encoding) designed to produce outputs that conform to the intended grammar. While the method of assembling the binary representation appears to be done carefully, the function itself does not include explicit checks or validations that the generated sequence conforms to the ABNF grammar. In other words, it is assumed that the helper functions and the controlled use of bit manipulation guarantee conformance. Hence, the function partially meets the constraint — it is intended to produce grammatically valid output but does not by itself verify that every element matches the ABNF specification.",success,
3758,ngx_http_v3_encode_field_l,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function strictly performs header field encoding (including prefix integer encoding and Huffman encoding for both the name and the value) without any logic to verify or restrict the generation of protocol elements based on the sender's role. The RFC specification requires that within a given message the sender MUST NOT generate protocol elements that are reserved for other roles. However, the function does not incorporate any checks or conditional logic to enforce or even consider this requirement. Instead, it simply encodes the header fields regardless of role appropriateness, meaning that any enforcement of role-based restrictions would have to be handled elsewhere in the system. Thus, no part of the function addresses the specified RFC constraint.",success,
3760,ngx_http_v3_encode_field_pbi,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function simply encodes a field value by setting a fixed prefix (0x10) and then delegating to ngx_http_v3_encode_prefix_int. There is no logic implemented in the function to verify whether the generation of a particular protocol element is permitted based on the sender's role or any contextual checks as required by the spec. Consequently, the function does not visibly address the RFC requirement that a sender must not generate protocol elements or syntax alternatives reserved for other roles.",success,
3761,ngx_http_v3_encode_field_lpbi,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, ngx_http_v3_encode_field_lpbi, is focused solely on encoding a literal field line with a post-base name reference. It handles the integer prefix encoding and optionally applies Huffman encoding to the provided data. However, none of its internal logic checks or implements the requirement that a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles, as stated in the RFC specification. There is no validation against roles or restrictions on generating elements based on the sender’s role within the function. Therefore, the function does not visibly address the relevant condition or action from the spec constraints.",success,
3787,ngx_http_v3_parse_prefix_int,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (b->pos == b->last) {\n    return NGX_AGAIN;\n}', 'explanation': 'This check ensures that the function does not read past the available buffer, thereby handling incomplete data defensively. It reflects a defensive parsing strategy, expecting only marginal conformance in the input.'}}, {'A1': {'code': 'if (st->shift == 56\n    && ((ch & 0x80) || (st->value & 0xc000000000000000)))\n{\n    ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                  ""client exceeded integer size limit"");\n    return NGX_HTTP_V3_ERR_EXCESSIVE_LOAD;\n}', 'explanation': 'This segment prevents parsing from continuing if the integer exceeds the safe size limit, which is a defensive measure to handle unexpectedly large or malformed protocol elements.'}}]","The function implements parts of the RFC's requirement to parse protocol elements defensively. It checks for buffer exhaustion (by verifying if b->pos == b->last) and guards against integer overflow by enforcing an upper bound on the parsed value. However, since only some defensive measures are directly implemented in this function (and not the complete spectrum of defensive parsing as described in the RFC spec context), the overall matching is classified as 'Partially Matches'.",success,
3788,ngx_http_v3_parse_headers,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (st->length == 0) {\n    return NGX_HTTP_V3_ERR_FRAME_ERROR;\n}', 'explanation': 'The function ensures that a header frame with a zero length is immediately rejected. This shows that the code is taking steps to interpret the received protocol element correctly according to the specification by enforcing a non‐zero length requirement.'}}, {'A1': {'code': 'if (st->prefix.insert_count > 0) {\n    if (ngx_http_v3_send_ack_section(c, c->quic->id) != NGX_OK) {\n        return NGX_ERROR;\n    }\n    ngx_http_v3_ack_insert_count(c, st->prefix.insert_count);\n}', 'explanation': 'This segment handles the acknowledgement of header field replication, thereby attempting to recover a usable protocol element from a valid construct, consistent with error recovery or interpretation as prescribed by the spec.'}}]","The function implements logic that parses header frames by reading variable‐length integers for both type and length, rejecting frames not expected or with invalid lengths, and performing additional processing (e.g., sending acknowledgements) when valid headers are received. This shows an effort to interpret the protocol element according to the semantics defined in the RFC. However, not all aspects of the RFC (such as sophisticated error recovery or further interpretation based on extended semantics) are handled entirely within this function, which is why it only partially matches the overall constraints.",success,
3788,ngx_http_v3_parse_headers,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (st->length == 0) {\n    return NGX_HTTP_V3_ERR_FRAME_ERROR;\n}', 'explanation': 'This check ensures that header frames with zero length are rejected, which is a defensive measure to guard against malformed input.'}}, {'A1': {'code': 'rc = ngx_http_v3_parse_varlen_int(c, &st->vlint, b);\nif (rc != NGX_DONE) {\n    return rc;\n}\nst->type = st->vlint.value;\n\nif (ngx_http_v3_is_v2_frame(st->type)\n    || st->type == NGX_HTTP_V3_FRAME_DATA\n    || st->type == NGX_HTTP_V3_FRAME_GOAWAY\n    || st->type == NGX_HTTP_V3_FRAME_SETTINGS\n    || st->type == NGX_HTTP_V3_FRAME_MAX_PUSH_ID\n    || st->type == NGX_HTTP_V3_FRAME_CANCEL_PUSH\n    || st->type == NGX_HTTP_V3_FRAME_PUSH_PROMISE)\n{\n    return NGX_HTTP_V3_ERR_FRAME_UNEXPECTED;\n}', 'explanation': 'The function first reads and validates the frame type before further processing, which is part of a defensive parsing strategy assuming only marginal conformance to expected formats.'}}]","The HTTP/3 header parsing function employs several defensive parsing techniques by explicitly checking for invalid conditions (such as a zero length for header frames) and by validating frame types before further processing. It calls helper functions to safely process variable-length integers and skip unexpected frames. However, while these checks align with the spirit of defensive parsing as dictated by the RFC—ensuring some basic validity while not fully relying on perfect conformance—they do not cover every aspect mentioned (for instance, comprehensive ABNF grammar handling or complete safeguards against excessively large buffers). Therefore, the code function only partially matches the full set of constraints described in the spec.",success,
3791,ngx_http_v3_parse_literal,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (n > cscf->large_client_header_buffers.size) {\n    ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                  ""client sent too large field line"");\n    return NGX_HTTP_V3_ERR_EXCESSIVE_LOAD;\n}', 'explanation': 'This segment ensures that the length of the incoming field does not exceed a pre-configured buffer size, which is a core part of defensive parsing by preventing excessively large inputs.'}}, {'A1': {'code': 'if (st->huffman) {\n    if (ngx_http_huff_decode(&st->huffstate, &ch, 1, &st->last,\n                                 st->length == 1, c->log) != NGX_OK) {\n        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                      ""client sent invalid encoded field line"");\n        return NGX_ERROR;\n    }\n} else {\n    *st->last++ = ch;\n}', 'explanation': 'This section handles input that may be Huffman-encoded. It decodes the input and checks for errors, demonstrating defensive measures against improperly formatted or non-conforming data.'}}]","The function incorporates defensive parsing elements by checking that the protocol element's size is within a 'reasonable' limit and by validating the Huffman encoding if applicable. These measures align with the spec's recommendation to parse defensively with minimal assumptions about conformance to an ABNF grammar. However, the function does not address all aspects of ABNF grammar validation, meaning it only partially implements the full spectrum of defensive parsing behaviors suggested by the HTTP RFC specification.",success,
3798,ngx_http_v3_parse_control,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (st->state == sw_first_type\n    && st->type != NGX_HTTP_V3_FRAME_SETTINGS)\n{\n    return NGX_HTTP_V3_ERR_MISSING_SETTINGS;\n}', 'explanation': 'The function enforces that the first frame on the control stream must be SETTINGS. This check (in the sw_first_type state) implements a key part of the RFC requirement by immediately returning an error if the first frame does not have the expected type.'}}, {'A1': {'code': 'case sw_settings:\n\n    ngx_http_v3_parse_start_local(b, &loc, st->length);\n\n    rc = ngx_http_v3_parse_settings(c, &st->settings, &loc);\n\n    ngx_http_v3_parse_end_local(b, &loc, &st->length);\n\n    if (st->length == 0 && rc == NGX_AGAIN) {\n        return NGX_HTTP_V3_ERR_SETTINGS_ERROR;\n    }\n\n    if (rc != NGX_DONE) {\n        return rc;\n    }\n\n    if (st->length == 0) {\n        st->state = sw_type;\n    }\n    break;', 'explanation': 'When a SETTINGS frame is identified, the function transitions to parsing the settings. This segment attempts to recover or process the protocol element by parsing its internals, which is in line with the RFC mandate to interpret according to semantics defined by the specification.'}}]","The function implements some of the key aspects expected by the RFC. It enforces that the first frame received on the control stream must be SETTINGS (C1) and, when a SETTINGS frame is encountered, it properly parses its values (A1). However, while it demonstrates handling of specific frame types and error conditions, it does not fully cover every potential interpretation or recovery mechanism outlined in the RFC. Thus, only some of the labeled conditions/actions are visibly addressed within this function, yielding a 'Partially Matches' judgment.",success,
3798,ngx_http_v3_parse_control,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'rc = ngx_http_v3_parse_varlen_int(c, &st->vlint, b);\nif (rc != NGX_DONE) {\n    return rc;\n}\n...\nif (st->state == sw_first_type && st->type != NGX_HTTP_V3_FRAME_SETTINGS) {\n    return NGX_HTTP_V3_ERR_MISSING_SETTINGS;\n}\n', 'explanation': 'The function employs a state machine and calls helper functions to parse variable-length integers from the buffer, returning early if expected conditions are not met. This defensive checking (e.g., verifying return values, ensuring the first frame is a SETTINGS frame) shows an attempt to parse the protocol element with only marginal assumptions regarding buffer content and grammar conformance, thus partially addressing the RFC recommendation.'}}]","The function implements a defensive parsing approach by using a state machine and by validating critical aspects of the input (such as the first frame type and proper variable-length integer parsing) before proceeding. However, much of the detailed handling (buffer size considerations, comprehensive grammar adherence) is encapsulated in sub-calls (e.g., ngx_http_v3_parse_varlen_int, ngx_http_v3_parse_settings) and not fully performed within this function itself. Therefore, while the function visibly attempts to implement parts of the defensive parsing as specified, it only partially matches the entire set of expectations provided by the spec.",success,
3801,ngx_http_v3_parse_field_inr,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (b->pos == b->last) {\n    return NGX_AGAIN;\n}\n\nch = *b->pos;\n\nst->dynamic = (ch & 0x40) ? 0 : 1;', 'explanation': 'This segment reads a byte from the input buffer and determines (via bit‐masking) whether the header field should be handled as dynamic or static. This is an example of interpreting the protocol element according to its defined semantics, which is part of the RFC requirement.'}}, {'A1': {'code': 'if (b->pos == b->last) {\n    return NGX_AGAIN;\n}', 'explanation': ""By returning NGX_AGAIN when the buffer is exhausted, the function shows an attempt to recover from incomplete input rather than failing immediately, aligning with the specification's note that a recipient may attempt to recover a usable protocol element from an invalid construct.""}}]","The function ngx_http_v3_parse_field_inr implements a state‐machine approach to parse a header field by interpreting individual bits and prefixes from the input buffer. This directly demonstrates an effort to interpret the received protocol element per its defined semantics (C1). In addition, the function returns NGX_AGAIN when more data is needed, which is an error‐handling/recovery action (A1) in line with the spec's suggestion that a recipient MAY attempt to recover from an incomplete or invalid construct. However, while these aspects of the RFC are visible in the function, not all of the RFC’s requirements (such as checking for sender misimplementation based on configuration or experience) are handled within this function. Therefore, the function only partially matches the overall spec constraints.",success,
3802,ngx_http_v3_parse_field_iln,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (b->pos == b->last) {\n    return NGX_AGAIN;\n}\n\n/* ... later ... */\nif (b->pos == b->last) {\n    return NGX_AGAIN;\n}', 'explanation': 'The function checks if the buffer pointer has reached the end (b->pos == b->last) before attempting to read further. This defensive check is in line with the RFC suggestion of marginal expectations and defensive parsing of protocol elements.'}}, {'A1': {'code': 'rc = ngx_http_v3_parse_prefix_int(c, &st->pint, 5, b);\nif (rc != NGX_DONE) {\n    return rc;\n}\n\nst->literal.length = st->pint.value;\nif (st->literal.length == 0) {\n    return NGX_ERROR;\n}', 'explanation': 'This segment performs the parsing of the field length and explicitly checks that the parsed length is non-zero, rejecting empty header names. This demonstrates an effort to validate and handle unexpected or malformed input, adhering to a defensive parsing approach.'}}]","The function implements defensive parsing strategies by checking buffer boundaries (e.g. verifying that b->pos is not equal to b->last before reading) and validating parsed lengths (rejecting a literal length of zero). These measures indicate that the function is attempting to uphold the RFC's recommendation to be defensive in parsing and to not rely heavily on the input's strict conformance to the ABNF grammar. However, while these aspects mirror the spirit of the RFC, the function does not address all possible expectations regarding the notion of a 'reasonable buffer size' or full grammar validation solely within its logic. Thus, it only partially matches the specified constraints.",success,
3804,ngx_http_v3_parse_data,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'rc = ngx_http_v3_parse_varlen_int(c, &st->vlint, b);\nif (rc != NGX_DONE) {\n    return rc;\n}\nst->type = st->vlint.value;', 'explanation': 'This segment shows that the function is attempting to parse the protocol element (the frame type) in a guarded manner. It defers further processing until a complete variable‐length integer is available, which is a defensive approach in parsing.'}}, {'A1': {'code': 'if (ngx_http_v3_is_v2_frame(st->type)\n    || st->type == NGX_HTTP_V3_FRAME_GOAWAY\n    || st->type == NGX_HTTP_V3_FRAME_SETTINGS\n    || st->type == NGX_HTTP_V3_FRAME_MAX_PUSH_ID\n    || st->type == NGX_HTTP_V3_FRAME_CANCEL_PUSH\n    || st->type == NGX_HTTP_V3_FRAME_PUSH_PROMISE)\n{\n    return NGX_HTTP_V3_ERR_FRAME_UNEXPECTED;\n}', 'explanation': 'This code defensively checks for unexpected frame types and returns an error if the frame type is not expected under the current context. It is an example of handling protocol elements defensively based on their type.'}}]","The function uses a state machine to parse various parts of an HTTP/3 data frame (type, length, and optionally skipping payload) and includes checks for unexpected or unsupported frame types, returning early when issues occur. This indicates an intent to parse incoming protocol elements defensively, in line with the RFC guidance. However, while it uses lower‐level parsing routines (which likely handle incomplete or over‐sized buffers) and performs error checking, it does not directly enforce explicit constraints on reasonable buffer sizes itself. Thus, some aspects of the RFC (such as explicit length limitations) are not fully visible in this function, leading to a partial match.",success,
3804,ngx_http_v3_parse_data,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'case sw_type:\n\n    rc = ngx_http_v3_parse_varlen_int(c, &st->vlint, b);\n    if (rc != NGX_DONE) {\n        return rc;\n    }\n\n    st->type = st->vlint.value;\n\n    if (st->type == NGX_HTTP_V3_FRAME_HEADERS) {\n        /* trailers */\n        goto done;\n    }\n\n    if (ngx_http_v3_is_v2_frame(st->type)\n        || st->type == NGX_HTTP_V3_FRAME_GOAWAY\n        || st->type == NGX_HTTP_V3_FRAME_SETTINGS\n        || st->type == NGX_HTTP_V3_FRAME_MAX_PUSH_ID\n        || st->type == NGX_HTTP_V3_FRAME_CANCEL_PUSH\n        || st->type == NGX_HTTP_V3_FRAME_PUSH_PROMISE)\n    {\n        return NGX_HTTP_V3_ERR_FRAME_UNEXPECTED;\n    }', 'explanation': 'This segment attempts to interpret the incoming protocol element by reading its type and then, based on known conditions for unexpected frame types, it returns an error. This aligns partially with the requirement that the recipient must interpret received protocol elements per the RFC, although the function does not cover all possible semantics and recovery actions described in the spec.'}}]","The function implements a state machine to parse HTTP/3 frame data by decoding variable-length integers for frame type and length, then applying specific checks on the frame type (for example, rejecting certain frames that are not expected). This indicates an attempt to interpret protocol elements as required by the RFC. However, since it only covers a subset of frame types and lacks mechanisms (such as configuration‐ or experience-based determinations) for handling extensions or recovering from invalid constructs, the implementation only partially meets the RFC's mandate.",success,
3835,ngx_http_v3_init_request_stream,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'C1': {'code': 'if (n >= clcf->keepalive_requests * 2) {\n    ngx_http_v3_finalize_connection(c, NGX_HTTP_V3_ERR_EXCESSIVE_LOAD,\n                                    ""too many requests per connection"");\n    ngx_http_close_connection(c);\n    return;\n}\n\n...\n\nngx_reusable_connection(c, 1);', 'explanation': ""This code segment demonstrates persistent connection support by tracking the number of requests (using n derived from the connection's id) and marking the connection as reusable with ngx_reusable_connection(c, 1). The function allows multiple requests over the same connection and applies a limit (via the keepalive_requests setting), which is in line with the HTTP requirement to support persistent connections.""}}]",The function 'ngx_http_v3_init_request_stream' implements logic to support persistent connections by monitoring the number of requests per connection and reusing the connection (via ngx_reusable_connection). It establishes conditions under which a connection remains open or is gracefully shutdown (using goaway and timer mechanisms). This behavior aligns with the RFC specification that HTTP implementations SHOULD support persistent connections.,success,
3835,ngx_http_v3_init_request_stream,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (h3c->goaway) {\n    c->close = 1;\n    ngx_http_close_connection(c);\n    return;\n}', 'explanation': ""This code checks if the session's goaway flag is set and then immediately closes the connection, thereby implementing a condition under which a client/server can close the transport connection per the RFC's permission for early closure.""}}, {'A1': {'code': 'if (n >= clcf->keepalive_requests * 2) {\n    ngx_http_v3_finalize_connection(c, NGX_HTTP_V3_ERR_EXCESSIVE_LOAD,\n                                        ""too many requests per connection"");\n    ngx_http_close_connection(c);\n    return;\n}\n\n...\n\nif (n + 1 == clcf->keepalive_requests\n    || ngx_current_msec - c->start_time > clcf->keepalive_time)\n{\n    h3c->goaway = 1;\n\n    if (!h3c->hq) {\n        if (ngx_http_v3_send_goaway(c, h3c->next_request_id) != NGX_OK) {\n            ngx_http_close_connection(c);\n            return;\n        }\n    }\n\n    ngx_http_v3_shutdown_connection(c, NGX_HTTP_V3_ERR_NO_ERROR,\n                                    ""reached maximum number of requests"");\n}', 'explanation': 'These segments show that the function actively terminates the connection under certain conditions (excessive requests or timing out of keepalive), which is in spirit with allowing a graceful or forced close as the RFC permits.'}}]","The RFC specifies that a client, server, or proxy may close the transport connection at any time and recommends a graceful shutdown when a timeout or error occurs. The function implements logic to close the connection in response to internal conditions such as receiving a goaway signal, exceeding the maximum number of requests, or encountering an error during shutdown signaling. While these code segments cover certain explicit cases for connection termination, they represent only a subset of the overall connection management strategies suggested in the RFC context. Therefore, the implementation in this function partially matches the specified RFC requirements.",success,
3836,ngx_http_v3_wait_request_handler,"A client, server, or proxy MAY close the transport connection at any time.",316,Fully Matches,"[{'C1': {'code': 'if (rev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");\n    c->timedout = 1;\n    ngx_http_close_connection(c);\n    return;\n}', 'explanation': 'This part of the function detects a timeout condition on the connection and then gracefully closes the connection, which is in line with the RFC allowing the connection to be closed at any time when certain conditions (like inactivity or timeout) are met.'}}, {'A1': {'code': 'if (c->close) {\n    ngx_http_close_connection(c);\n    return;\n}', 'explanation': ""This segment checks if the connection has been flagged for closure and immediately closes it, directly implementing the RFC's permission for a client, server, or proxy to close the transport connection at any time.""}}]","The function actively monitors the connection for closure signals such as timeouts (rev->timedout) and an explicit close flag (c->close). Upon detecting either, it invokes the connection-closing routine, thereby ensuring that resources are reclaimed promptly and aligning with the RFC's requirements. As all necessary conditions and actions related to closing the transport connection are handled within this function, it fully matches the spec constraints.",success,
3836,ngx_http_v3_wait_request_handler,A client or server that wishes to time out SHOULD issue a graceful close on the connection.,314,Fully Matches,"[{'C1': {'code': 'if (rev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");\n    c->timedout = 1;\n    ngx_http_close_connection(c);\n    return;\n}', 'explanation': 'This block checks whether the event has timed out and, if so, logs the timeout, sets the timeout flag, and calls ngx_http_close_connection(c) to gracefully close the connection as required by the spec.'}}, {'A1': {'code': 'ngx_http_close_connection(c);', 'explanation': 'Multiple instances in the function (e.g., on timeout, on error, on client close) call ngx_http_close_connection(c), which implements the graceful closure of the connection per the RFC recommendation.'}}]","The function ngx_http_v3_wait_request_handler directly monitors the connection for a timeout event (rev->timedout). Upon detecting a timeout, it logs the event and invokes ngx_http_close_connection(c) to gracefully close the connection. This behavior fully addresses the spec requirement that a client or server that wishes to time out should issue a graceful close on the connection. Therefore, the function fully matches the spec constraint by handling timeouts and gracefully closing the connection.",success,
3841,ngx_http_v3_process_request,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (rev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");\n    c->timedout = 1;\n    ngx_http_close_request(r, NGX_HTTP_REQUEST_TIME_OUT);\n    return;\n}\n...\nif (n == 0 || n == NGX_ERROR) {\n    c->error = 1;\n    c->log->action = ""reading client request"";\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    break;\n}', 'explanation': 'This segment shows that the function is reading the client request in a defensive manner by checking for timeouts and connection errors. It does not assume that the incoming headers conform to any strict ABNF grammar, instead it handles incomplete data, timeouts, and premature connection (n==0) gracefully.'}}, {'A1': {'code': 'if (ngx_http_v3_check_flood(c) != NGX_OK) {\n    ngx_http_close_request(r, NGX_HTTP_CLOSE);\n    break;\n}', 'explanation': 'This code acts defensively by validating that the amount of data received does not exceed a reasonable limit, protecting against header floods even though the RFC does not define a strict buffer size. This aligns with the RFC guidance of defensive parsing.'}}]","The function 'ngx_http_v3_process_request' implements a defensive parsing mechanism that adheres to the HTTP RFC’s recommendations. It handles various error conditions (timeouts, read errors, premature closes) and integrates a check against potential flood attacks. These measures ensure that the function only marginally assumes conformance to the expected protocol grammar and treats the received data cautiously, fulfilling both the defensive condition (C1) and corresponding action (A1) as outlined in the specification.",success,
3841,ngx_http_v3_process_request,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (rev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");\n    c->timedout = 1;\n    ngx_http_close_request(r, NGX_HTTP_REQUEST_TIME_OUT);\n    return;\n}', 'explanation': 'This segment checks if the connection has timed out and then gracefully closes the request, addressing the aspect of the spec that allows the client, server, or proxy to close the transport connection (and the recommendation for gracefully closing a connection that times out).'}}]","The provided function implements logic to detect a timeout condition (via rev->timedout) and responds by logging the event and invoking a connection closure through ngx_http_close_request. This addresses one part of the RFC specification regarding the allowance of a transport connection to be closed (in this case, due to a timeout). However, the spec also mentions continuous monitoring for closure signals and handling cases where a connection might be closed while a request is in progress, which this function does not explicitly cover within its own code (such as listening for or gracefully reacting to incoming shutdown signals from the peer). As a result, while the function demonstrates a mechanism for closing the connection on a timeout, it only partially implements the full breadth of the spec constraints on connection closure.",success,
3841,ngx_http_v3_process_request,"A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.",310,Fully Matches,"[{'C1': {'code': 'if (rev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");\n    c->timedout = 1;\n    ngx_http_close_request(r, NGX_HTTP_REQUEST_TIME_OUT);\n    return;\n}', 'explanation': 'This code segment detects if the request is incomplete due to a timeout and initiates the closing of the request, aligning with the condition of an incomplete message.'}}, {'A1': {'code': 'if (n == 0 || n == NGX_ERROR) {\n    c->error = 1;\n    c->log->action = ""reading client request"";\n\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    break;\n}', 'explanation': 'This segment handles the scenario where the request is incomplete (due to premature connection closure or read error) by sending an error response (finalizing the request with NGX_HTTP_BAD_REQUEST) prior to closing the connection.'}}]","The function explicitly checks for scenarios where the request is incomplete, such as when a timeout occurs or when the client prematurely closes the connection. In these cases, it sends an error response (using ngx_http_close_request and ngx_http_finalize_request) before closing the connection, which directly corresponds to the behavior described in the RFC specification.",success,
3841,ngx_http_v3_process_request,"If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.",202,Partially Matches,"[{'A1': {'code': 'if (n == 0 || n == NGX_ERROR) {\n    c->error = 1;\n    c->log->action = ""reading client request"";\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    break;\n}\n\n...\n\nif (rc > 0) {\n    ngx_quic_reset_stream(c, rc);\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, ""client sent invalid header"");\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    break;\n}\n\nif (rc == NGX_BUSY) {\n    if (rev->error) {\n        ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n        break;\n    }\n    ...\n}', 'explanation': 'The code function directly handles unrecoverable errors by finalizing the request with NGX_HTTP_BAD_REQUEST (which corresponds to a 400 Bad Request response) when header parsing or I/O errors occur. This logic attempts to comply with the RFC requirement to respond with a 400 status code on unrecoverable request errors.'}}]","The function includes logic that finalizes the request with a 400 (Bad Request) status code when it detects unrecoverable errors (such as I/O errors or invalid headers) in a request message. This indicates an attempt to satisfy the RFC requirement. However, the implementation does not cover all aspects of the RFC (e.g., specific conditions regarding Transfer-Encoding and Content-Length headers) within this function itself, hence it is only a partial match in addressing the specified RFC.",success,
3841,ngx_http_v3_process_request,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'C1': {'code': 'if (rc > 0) {\n    ngx_quic_reset_stream(c, rc);\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""client sent invalid header"");\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    break;\n}', 'explanation': 'This code segment detects an invalid header (which may include an invalid request-line) and responds with a 400 Bad Request error, which is one of the acceptable responses per the RFC. However, the RFC also permits a 301 redirect with proper encoding, which is not implemented in this function.'}}]","The function attempts to handle malformed requests by finalizing the request with a 400 error when header parsing fails. This aligns with one acceptable behavior (responding with 400) outlined in the RFC. However, the function does not implement the alternative of issuing a 301 (Moved Permanently) redirect with a properly encoded request-target, nor does it explicitly enforce that no whitespace is allowed in the request-target. Since only part of the specification is addressed within this function, it is considered a partial match.",success,
3841,ngx_http_v3_process_request,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",175,Partially Matches,"[{'A1': {'code': 'if (rc > 0) {\n    ngx_quic_reset_stream(c, rc);\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, ""client sent invalid header"");\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    break;\n}\n\nif (n == 0 || n == NGX_ERROR) {\n    c->error = 1;\n    c->log->action = ""reading client request"";\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    break;\n}', 'explanation': 'This segment checks if the header parsing failed (indicating the incoming octets do not match the HTTP-message grammar) and then finalizes the request by responding with a 400 (Bad Request) status, thus closing the connection. This implements the key action specified by the RFC for handling invalid requests.'}}]","The function demonstrates error handling for invalid HTTP header segments by invoking a 400 response when the parsing function returns a failure indication. This fulfills the action requirement of responding with a 400 (Bad Request) and closing the connection in the case of invalid input. However, the RFC also describes the need to reject or ignore lines with preceding whitespace before a valid header, which is not explicitly handled within this function (it is likely delegated to lower-level parsing logic). Therefore, while the function does address the critical error response requirement (A1), it only partially meets the full range of robustness exceptions detailed in the RFC specification.",success,
3841,ngx_http_v3_process_request,"A server MUST NOT apply a request to the target resource until it receives the entire request header section, since later header field lines might include conditionals, authentication credentials, or deliberately misleading duplicate header fields that could impact request processing.",233,Fully Matches,"[{'C1': {'code': 'if (rc == NGX_DONE) {\n    if (ngx_http_v3_process_request_header(r) != NGX_OK) {\n        break;\n    }\n    ngx_http_process_request(r);\n    break;\n}', 'explanation': 'The code enters a loop to continuously read the header data and invokes the header parser (ngx_http_v3_parse_headers). It only proceeds to process the request (via ngx_http_process_request) when the parser returns NGX_DONE, indicating the complete header section has been received. This directly implements the RFC requirement by ensuring that the request is not applied until all header lines are received.'}}]","The function reads the header data in a loop and waits until the header parser signals that the header section is completely received (NGX_DONE). Only then does it call the function to process the request. This logic directly ensures that a request is not applied to the target resource until the complete header section is received, meeting the specified HTTP RFC requirement.",success,
3841,ngx_http_v3_process_request,A client or server that wishes to time out SHOULD issue a graceful close on the connection.,314,Partially Matches,"[{'A1': {'code': 'if (rev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");\n    c->timedout = 1;\n    ngx_http_close_request(r, NGX_HTTP_REQUEST_TIME_OUT);\n    return;\n}', 'explanation': 'This segment checks if the connection has timed out and then calls ngx_http_close_request to close the connection, which is indicative of attempting a graceful close on timeout as specified.'}}]","The provided function monitors the connection event for a timeout (rev->timedout) and, upon detection, it logs the timeout event and initiates connection closure via ngx_http_close_request. This directly aligns with the provided specification's instruction to issue a graceful close when a timeout occurs. However, while this code addresses the timeout-based closure requirement, it does not handle monitoring for or responding to other closure signals that may be part of the full RFC context. Therefore, the implementation only partially matches the overall spec constraints related to graceful connection closure.",success,
3842,ngx_http_v3_process_header,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'if (r->invalid_header) {\n    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n\n    if (cscf->ignore_invalid_headers) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent invalid header: \\""%V\\"""", name);\n\n        return NGX_OK;\n    }\n}', 'explanation': 'The RFC states that a recipient MAY attempt to recover a usable protocol element from an invalid construct. In this function, if an invalid header is detected (via r->invalid_header), the code checks a configuration flag (ignore_invalid_headers) and chooses to ignore the header rather than immediately rejecting the request. This demonstrates an attempt at recovering from an invalid header construct.'}}]","The function partially addresses the recovery behavior outlined in the RFC by recovering from invalid headers when configured to ignore them. While it does include an error/recovery branch under the condition of an invalid header (C1), other invalid header cases—such as those caught by ngx_http_v3_validate_header—result in immediate request termination. Thus, the function only partly implements the RFC's suggestion to attempt recovery from invalid constructs within the confines of its internal logic.",success,
3842,ngx_http_v3_process_header,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': ""if (name->len && name->data[0] == ':') {\n    return ngx_http_v3_process_pseudo_header(r, name, value);\n}"", 'explanation': ""This segment shows that the function distinguishes pseudo-headers (which start with ':') and processes them separately, indicating an interpretation of protocol elements as prescribed by the RFC.""}}, {'A1': {'code': 'if (r->invalid_header) {\n    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n    if (cscf->ignore_invalid_headers) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent invalid header: ""%V"""", name);\n        return NGX_OK;\n    }\n}', 'explanation': ""This code block addresses error handling by optionally ignoring invalid headers based on configuration, which aligns with the RFC's allowance for attempting to recover a usable protocol element from an invalid construct.""}}]","The function attempts to implement aspects of the RFC by interpreting protocol elements based on header content (e.g., distinguishing pseudo-headers) and managing error recovery (e.g., checking header size, validating headers, and optionally ignoring invalid headers). However, not all possible conditions and actions implied by the specification (such as comprehensive error recovery mechanisms or handling all header types in a fully defined manner) are covered solely within this function, leading to a partial match.",success,
3842,ngx_http_v3_process_header,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",175,Partially Matches,"[{'A1': {'code': 'if (ngx_http_v3_validate_header(r, name, value) != NGX_OK) {\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;\n}', 'explanation': ""This segment checks whether a header does not match the HTTP-message grammar. When the validation function returns NGX_OK, processing continues normally; otherwise, the request is finalized with a 400 (Bad Request) response and the connection is closed, which aligns with the RFC's directive for handling malformed header messages.""}}, {'A2': {'code': 'if (len > r->v3_parse->header_limit) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent too large header"");\n    ngx_http_finalize_request(r, NGX_HTTP_REQUEST_HEADER_TOO_LARGE);\n    return NGX_ERROR;\n}', 'explanation': 'This segment enforces a size limit on header content. If the combined length of header name and value exceeds a preset limit the header is rejected by finalizing the request, which is a robustness measure that is in the same spirit as handling violations of the HTTP-message grammar.'}}]","The RFC requires that if a server receives a message that does not match the HTTP-message grammar (aside from the allowed robustness exceptions), it should respond with a 400 (Bad Request) and close the connection. The function attempts to implement this by validating headers and finalizing the request with an error when headers are invalid or too large. However, the RFC also mentions specific handling for whitespace‐preceded lines (to prevent request smuggling or response splitting) which is not visibly addressed in this function. As a result, while the function does cover key error conditions (responding with 400 or a similar error code when detecting invalid or oversized headers), it does not fully implement all the robustness exception details described in the spec. Thus, the implementation partially matches the RFC requirements.",success,
3842,ngx_http_v3_process_header,"At a minimum, a recipient MUST be able to parse and process protocol element lengths that are at least as long as the values that it generates for those same protocol elements in other messages.",218,Partially Matches,"[{'C1': {'code': 'len = name->len + value->len;\n\nif (len > r->v3_parse->header_limit) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent too large header"");\n    ngx_http_finalize_request(r, NGX_HTTP_REQUEST_HEADER_TOO_LARGE);\n    return NGX_ERROR;\n}\n\nr->v3_parse->header_limit -= len;', 'explanation': 'This segment computes the total length of the header element (name and value) and compares it against a preset header_limit. By rejecting headers that exceed this limit, the function partially implements the requirement that a recipient must process protocol element lengths that are at least as long as those it generates. However, it does so based on a fixed limit rather than dynamically ensuring the limit is at least as high as the generated lengths.'}}]","The function includes logic to check and reduce the header limit when processing incoming header fields, which is an attempt to handle protocol element lengths as described by the RFC. Nonetheless, it only partially meets the spec requirement because it enforces a static boundary rather than directly ensuring that the recipient can parse headers as long as the ones it sends.",success,
3842,ngx_http_v3_process_header,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'len = name->len + value->len;\n\nif (len > r->v3_parse->header_limit) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent too large header"");\n    ngx_http_finalize_request(r, NGX_HTTP_REQUEST_HEADER_TOO_LARGE);\n    return NGX_ERROR;\n}\n\nr->v3_parse->header_limit -= len;', 'explanation': ""This segment defensively checks that the total length of the header (name plus value) does not exceed a preset header_limit. It protects against overly large inputs, aligning with the RFC's emphasis on fitting within a reasonable buffer size.""}}, {'A1': {'code': 'if (ngx_http_v3_validate_header(r, name, value) != NGX_OK) {\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;\n}', 'explanation': 'This segment calls a validation function that checks conformity of the header element to expected syntax. By handling failures with an error response, it implements the RFC directive to parse protocol elements defensively with only marginal expectations that they conform.'}}]","The function 'ngx_http_v3_process_header' implements defensive parsing as prescribed by the RFC by first checking that header lengths do not exceed a reasonable limit and then validating header contents. These two primary code segments address the conditions of ensuring the protocol element fits within a reasonable buffer size and that the header is parsed even with only marginal grammar conformance. Therefore, the function fully matches the specified requirements.",success,
3844,ngx_http_v3_validate_header,A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.,173,Fully Matches,"[{'C1': {'code': 'for (i = 0; i != value->len; i++) {\n    ch = value->data[i];\n\n    if (ch == \'\\0\' || ch == LF || ch == CR) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent header \\""%V\\"" with invalid value: \\""%V\\"""", name, value);\n        return NGX_ERROR;\n    }\n}', 'explanation': 'The RFC requires that a bare CR in an element must cause the recipient to consider the element invalid (or replace with SP). This code examines each character in the header value and immediately treats any occurrence of CR (as well as LF and a null character) as invalid by logging an error and returning NGX_ERROR. Similarly, the header name loop also invalidates characters (including bare CR since CR is <= 0x20), thereby satisfying the condition.'}}]","The function inspects both the header name and value. In the header value check, it explicitly tests for a bare CR (as well as LF and a null character) and considers the entire header element invalid when such a character is found, which is in line with the RFC requirement. Although the RFC allows either marking the element invalid or replacing the CR with a space, the function correctly chooses to invalidate the header, fully addressing the specified constraint.",success,
3844,ngx_http_v3_validate_header,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Fully Matches,"[{'C1': {'code': 'for (i = 0; i != value->len; i++) {\n    ch = value->data[i];\n\n    if (ch == \'\\0\' || ch == LF || ch == CR) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent header \\""%V\\"" with invalid value: \\""%V\\"""", name, value);\n\n        return NGX_ERROR;\n    }\n}\n\n// And in the header name loop:\nfor (i = (name->data[0] == \':\'); i != name->len; i++) {\n    ch = name->data[i];\n\n    if ((ch >= \'a\' && ch <= \'z\')\n        || (ch == \'-\')\n        || (ch >= \'0\' && ch <= \'9\')\n        || (ch == \'_\' && cscf->underscores_in_headers))\n    {\n        continue;\n    }\n\n    if (ch <= 0x20 || ch == 0x7f || ch == \':\'\n        || (ch >= \'A\' && ch <= \'Z\'))\n    {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent invalid header name: \\""%V\\"""", name);\n\n        return NGX_ERROR;\n    }\n\n    r->invalid_header = 1;\n}', 'explanation': 'The RFC requires that a header element MUST not include any bare CR characters. In both header name and value validation loops, the code checks for CR (and LF) and rejects the header by returning NGX_ERROR when found. Although the RFC offers an alternative (to replace a bare CR with SP), the code opts to treat the presence of CR as an invalid element which is compliant with the recipient requirement to consider the element invalid.'}}]","The function ngx_http_v3_validate_header explicitly checks both the header name and header value for the presence of control characters including CR and LF. In the header value loop, it directly tests for '\r' (CR) and '\n' (LF) and rejects the header by logging an error and returning an error value. Similarly, in the header name loop, characters less than or equal to 0x20 (which includes CR) cause an error. This behavior is in line with the RFC specification stating that a sender must not generate a bare CR and that a recipient must treat such elements as invalid. Therefore, the function fully addresses the RFC constraint directly within its own logic.",success,
3844,ngx_http_v3_validate_header,"Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message.",3,Fully Matches,"[{'C1': {'code': 'for (i = 0; i != value->len; i++) {\n    ch = value->data[i];\n\n    if (ch == \'\\0\' || ch == LF || ch == CR) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent header \\""%V\\"" with invalid value: \\""%V\\"""", name, value);\n\n        return NGX_ERROR;\n    }\n}', 'explanation': ""This segment iterates over each character in the header field's value and checks if it contains any of the forbidden characters (CR, LF, or NUL). On encountering any of these, it logs an error and rejects the header. According to the RFC, a recipient MUST either reject the message or replace these characters with a SP. Here, the function opts to reject, which is a valid implementation of the requirement.""}}]","The code function directly implements the RFC requirement regarding field values that include CR, LF, or NUL characters by scanning the header value and rejecting it if any of those characters are found. Since the RFC permits either rejecting the message or replacing these characters with a SP, the function's rejection mechanism fully meets the specification constraint.",success,
3845,ngx_http_v3_process_pseudo_header,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'if (name->len == 7 && ngx_strncmp(name->data, "":method"", 7) == 0) {\n    if (value->len == 0) { ... }\n    ...\n    for (i = 0; i < value->len; i++) {\n        ch = value->data[i];\n        if ((ch < \'A\' || ch > \'Z\') && ch != \'_\' && ch != \'-\') {\n            ngx_log_error(..., ""client sent invalid method: \\""%V\\"""", value);\n            goto failed;\n        }\n    }\n    ...\n}\n\nif (name->len == 7 && ngx_strncmp(name->data, "":scheme"", 7) == 0) {\n    if (value->len == 0) { ... }\n    for (i = 0; i < value->len; i++) {\n        ch = value->data[i];\n        c = (u_char) (ch | 0x20);\n        if (c >= \'a\' && c <= \'z\') {\n            continue;\n        }\n        if (((ch >= \'0\' && ch <= \'9\') || ch == \'+\' || ch == \'-\' || ch == \'.\') && i > 0) {\n            continue;\n        }\n        ngx_log_error(..., ""client sent invalid \\"":scheme\\"" header: \\""%V\\"""", value);\n        goto failed;\n    }\n    r->schema = *value;\n}\n\nif (name->len == 5 && ngx_strncmp(name->data, "":path"", 5) == 0) {\n    if (value->len == 0) { ... }\n    r->uri_start = value->data;\n    r->uri_end = value->data + value->len;\n    if (ngx_http_parse_uri(r) != NGX_OK) {\n        ngx_log_error(..., ""client sent invalid \\"":path\\"" header: \\""%V\\"""", value);\n        goto failed;\n    }\n}\n\nif (name->len == 10 && ngx_strncmp(name->data, "":authority"", 10) == 0) {\n    r->host_start = value->data;\n    r->host_end = value->data + value->len;\n}\n\nif (r->request_line.len) {\n    ngx_log_error(..., ""client sent out of order pseudo-headers"");\n    goto failed;\n}\n\nngx_log_error(..., ""client sent unknown pseudo-header \\""%V\\"""", name);\n\nfailed:\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;', 'explanation': 'This code fragment validates that key pseudo-headers (:method, :scheme, :path, and :authority) conform to the expected grammar as defined by the ABNF rules. It checks for duplicates, empty values, character restrictions, and even message order. Thus, it enforces that only protocol elements matching the ABNF grammar are processed.'}}]","The function ngx_http_v3_process_pseudo_header directly implements checks that ensure all pseudo-header values conform to a strict grammar—rejecting out-of-order headers, duplicates, and headers with invalid characters (as in :method and :scheme), as well as verifying valid URIs for :path via ngx_http_parse_uri. These validations ensure that the implementation complies with the specification that a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules, thereby fully matching the provided requirement.",success,
3845,ngx_http_v3_process_pseudo_header,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",175,Partially Matches,"[{'A1': {'code': 'failed:\n\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;', 'explanation': 'The function detects several error conditions (e.g., pseudo-header out of order, duplicate headers, empty values, unknown headers, invalid characters in :method and :scheme) and then executes the error handling code which finalizes the request with a 400 Bad Request response. This behavior directly implements the action of responding with 400 and closing the connection when the message does not conform to the HTTP-message grammar.'}}]","The function ngx_http_v3_process_pseudo_header() performs validations on pseudo-headers by checking their order, duplicate occurrences, empty values, and character validity. In any violation, it executes a goto failed block that finalizes the request with a 400 Bad Request response. This matches part of the RFC specification regarding the robustness requirements for malformed HTTP messages. However, the function does not address some aspects mentioned in the spec context – for example, it does not explicitly handle cases such as consuming or rejecting lines solely containing whitespace between the start-line and headers. As a result, while the code implements the 400 response for various pseudo-header errors (fulfilling action A1), it only partially covers the full set of conditions specified by the RFC.",success,
3846,ngx_http_v3_init_pseudo_headers,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (r->method_name.len == 0) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent no "":method"" header"");\n    goto failed;\n}\n\nif (r->schema.len == 0) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent no "":scheme"" header"");\n    goto failed;\n}\n\nif (r->uri_start == NULL) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent no "":path"" header"");\n    goto failed;\n}', 'explanation': ""The function verifies that the required pseudo headers (:method, :scheme, and :path) are present. If any are missing, it logs an error and stops processing the request. This check prevents the generation of a request-line when the mandatory protocol elements are absent, which partially addresses the spec's requirement that a sender must not generate protocol elements that they are not allowed to produce.""}}]","The provided function partially implements the RFC constraint by ensuring that the essential pseudo headers are present before constructing the HTTP/3 request-line. However, while it prevents the generation of a malformed request-line (which could incorporate elements reserved for other roles), it does not comprehensively enforce all role-based restrictions or check for disallowed protocol elements. As such, only part of the constraint (e.g., checking key pseudo headers) is handled within this function.",success,
3846,ngx_http_v3_init_pseudo_headers,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",175,Partially Matches,"[{'C1': {'code': 'if (r->method_name.len == 0) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent no "":method"" header"");\n    goto failed;\n}\n\nif (r->schema.len == 0) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent no "":scheme"" header"");\n    goto failed;\n}\n\nif (r->uri_start == NULL) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent no "":path"" header"");\n    goto failed;\n}', 'explanation': 'The function checks for the presence of required pseudo-header fields (:method, :scheme, :path). When any of these are missing, it logs an error and jumps to a failure path.'}}, {'A1': {'code': 'failed:\n\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;', 'explanation': 'On detecting a malformed message (missing required fields), the function finalizes the request with a 400 (Bad Request) response, thus performing the action specified by the RFC.'}}]","The RFC requires that when a server receives a message that does not match the HTTP-message grammar, a 400 response should be sent and the connection closed. This function implements part of that requirement by checking for the absence of essential pseudo-header fields (:method, :scheme, and :path) and finalizing the request with a 400 error if any are missing. However, it does not address other aspects of the HTTP-message grammar violations (such as handling of whitespace‐preceded lines), so it only partially matches the full specification.",success,
3846,ngx_http_v3_init_pseudo_headers,"If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.",202,Partially Matches,"[{'A1': {'code': 'failed:\n\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;', 'explanation': 'When a required pseudo-header (such as "":method"", "":scheme"", or "":path"") is missing, the function jumps to the \'failed\' label where it finalizes the request with NGX_HTTP_BAD_REQUEST (i.e. 400). This fulfills the spec action that if an unrecoverable error is detected in a request message, the server must respond with a 400 status code and close the connection.'}}]","The provided function checks for the presence of necessary pseudo-headers and, if any are missing, logs an error and finalizes the request with a 400 response. This directly addresses the specific RFC requirement regarding unrecoverable errors in request messages. However, the overall RFC includes additional conditions (e.g., handling invalid Content-Length values or transfer encoding issues) that are not addressed in this function. Therefore, the code only partially matches the full specification.",success,
3848,ngx_http_v3_process_request_header,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'C1': {'code': 'if (r->headers_in.content_length) {\n    r->headers_in.content_length_n = ngx_atoof(r->headers_in.content_length->value.data,\n                                                  r->headers_in.content_length->value.len);\n    if (r->headers_in.content_length_n == NGX_ERROR) {\n        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                      ""client sent invalid \\""Content-Length\\"" header"");\n        goto failed;\n    }\n}', 'explanation': 'This segment converts the Content-Length header value to a numeric value and, if the conversion fails (NGX_ERROR), it rejects the message. This logic directly addresses the RFC requirement to not forward a message with a known incorrect Content-Length header value. However, it does not handle the special case mentioned in the RFC, where a Content-Length header composed of repeated, identical numbers (e.g., ""42, 42"") may be tolerated or adjusted. Hence, while the function performs a basic check, it only partially meets the full spec.'}}]","The function attempts to implement the RFC constraint by validating the Content-Length header field. It checks for conversion errors and rejects the request if an error is detected. However, it does not implement the nuanced exception regarding a comma‐separated list of identical Content-Length values. Thus, the implementation within this function only partially fulfills the RFC specification.",success,
3848,ngx_http_v3_process_request_header,"If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.",202,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.server.len == 0) {\n    ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                  ""client sent neither "":authority"" nor ""Host"" header"");\n    goto failed;\n}\n\nif (r->headers_in.host) {\n    if (r->headers_in.host->value.len != r->headers_in.server.len\n        || ngx_memcmp(r->headers_in.host->value.data,\n                      r->headers_in.server.data,\n                      r->headers_in.server.len) != 0) {\n        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                      ""client sent "":authority"" and ""Host"" headers with different values"");\n        goto failed;\n    }\n}\n\nif (r->headers_in.content_length) {\n    r->headers_in.content_length_n = ngx_atoof(r->headers_in.content_length->value.data,\n                                               r->headers_in.content_length->value.len);\n    if (r->headers_in.content_length_n == NGX_ERROR) {\n        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                      ""client sent invalid ""Content-Length"" header"");\n        goto failed;\n    }\n}\n\nfailed:\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;', 'explanation': 'The function detects multiple error conditions in the request (missing Host header, mismatched header values, invalid Content-Length) and if any are true, jumps to the failed section where it finalizes the request with a 400 Bad Request, thus addressing the spec requirement for unrecoverable errors.'}}, {'A1': {'code': 'ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);', 'explanation': 'This line actively sends a 400 Bad Request response and closes the connection, directly implementing the action mandated by the RFC for unrecoverable request errors.'}}]","The function checks for critical errors in a request message (missing or inconsistent authority headers and invalid Content-Length values) and, upon detecting any such error, immediately finalizes the request by calling ngx_http_finalize_request with NGX_HTTP_BAD_REQUEST (400). This behavior satisfies the RFC requirement that unrecoverable errors in a request result in a 400 Bad Request response and a closed connection.",success,
3848,ngx_http_v3_process_request_header,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (r->headers_in.server.len == 0) {\n    ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                  ""client sent neither "":authority"" nor ""Host"" header"");\n    goto failed;\n}\n\nif (r->headers_in.host) {\n    if (r->headers_in.host->value.len != r->headers_in.server.len\n        || ngx_memcmp(r->headers_in.host->value.data,\n                      r->headers_in.server.data,\n                      r->headers_in.server.len) != 0)\n    {\n        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                      ""client sent "":authority"" and ""Host"" headers with different values"");\n        goto failed;\n    }\n}', 'explanation': ""The function ensures that the client does not send conflicting or missing pseudo header values by checking that the ':authority' (mapped to 'server') header exists and agrees with the 'Host' header. This enforces part of the role-based header generation requirement.""}}, {'A1': {'code': 'if (r->method == NGX_HTTP_CONNECT) {\n    ngx_log_error(NGX_LOG_INFO, c->log, 0, ""client sent CONNECT method"");\n    ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);\n    return NGX_ERROR;\n}\n\nif (r->method == NGX_HTTP_TRACE) {\n    ngx_log_error(NGX_LOG_INFO, c->log, 0, ""client sent TRACE method"");\n    ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);\n    return NGX_ERROR;\n}', 'explanation': 'By explicitly rejecting methods (CONNECT and TRACE) that are not permitted in this context, the function partly enforces the sender’s adherence to role-specific protocol elements.'}}]","The RFC specification requires that a sender must only generate protocol elements appropriate for its role. Within the function, there are explicit checks that validate header consistency (e.g., ensuring that the ':authority' and 'Host' headers match) and reject disallowed methods, which partially implement the constraint. However, while these checks address key aspects of the RFC (such as preventing inappropriate header generation and ensuring method restrictions), they do not cover every aspect of protocol element generation defined by the RFC. Thus, the function partially matches the specification by handling some, but not all, of the required conditions and actions.",success,
3854,ngx_http_v3_read_client_request_body_handler,"A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.",310,Fully Matches,"[{'C1': {'code': 'if (r->connection->read->timedout) { ... }', 'explanation': ""This condition checks whether the client's connection has timed out, which is one of the scenarios (triggered timeout exception) leading to an incomplete request message.""}}, {'A1': {'code': 'ngx_http_finalize_request(r, NGX_HTTP_REQUEST_TIME_OUT);', 'explanation': 'This line sends an error response (HTTP 408 Request Timeout) before closing the connection, fulfilling the action of sending an error response for an incomplete request.'}}]","The function checks if the connection read has timed out (C1), which is one common reason for an incomplete request as per the RFC specification. Upon detecting the timeout, it immediately finalizes the request with an error response (A1). This implementation directly addresses the specified scenario in the RFC where the server MAY send an error response prior to closing the connection. All relevant conditions and actions are handled within the function itself.",success,
3854,ngx_http_v3_read_client_request_body_handler,"If the sender closes the connection or the recipient times out before the indicated number of octets are received, the recipient MUST consider the message to be incomplete and close the connection",303,Partially Matches,"[{'A1': {'code': 'if (r->connection->read->timedout) {\n    r->connection->timedout = 1;\n    ngx_http_finalize_request(r, NGX_HTTP_REQUEST_TIME_OUT);\n    return;\n}', 'explanation': 'This code segment checks if the connection read event has timed out and, if so, marks the connection as timed out and finalizes the request with a timeout response. This addresses the part of the specification that requires closing the connection when a timeout occurs.'}}]","The RFC specifies that if the sender closes the connection or if the recipient times out before receiving the expected number of octets, the message is incomplete and the connection must be closed. In this function, only the timeout scenario is directly handled by checking r->connection->read->timedout and finalizing the request with NGX_HTTP_REQUEST_TIME_OUT. There is no logic to handle the case where the sender closes the connection before receiving the full body. Therefore, the function partially matches the spec constraints by addressing only the timeout aspect.",success,
3854,ngx_http_v3_read_client_request_body_handler,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (r->connection->read->timedout) {\n    r->connection->timedout = 1;\n    ngx_http_finalize_request(r, NGX_HTTP_REQUEST_TIME_OUT);\n    return;\n}', 'explanation': ""This segment checks whether the connection's read event has timed out and then finalizes the request accordingly. It implements the monitoring and handling of a closure signal due to timeout as described in the spec context.""}}]","The function contains logic that partially addresses the spec requirement regarding connection closure. Specifically, it monitors for a timeout (C1) and initiates closure via a graceful finalize call. However, it does not comprehensively cover all aspects of the spec, such as handling new requests during connection closure or other scenarios of transport connection termination noted in the RFC. Only the timeout-close mechanism is directly implemented in this function.",success,
3856,ngx_http_v3_do_read_client_request_body,"If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.",202,Partially Matches,"[{'A1': {'code': 'if (n == NGX_ERROR) {\n    c->error = 1;\n    return NGX_HTTP_BAD_REQUEST;\n}', 'explanation': 'This code branch handles an unrecoverable error when receiving data by returning NGX_HTTP_BAD_REQUEST (which corresponds to a 400 status code). This aligns with the spec mandate to respond with a 400 when an unrecoverable error occurs in a request message. However, the code does not explicitly close the connection afterward; that responsibility appears to be deferred to the caller or another part of the system.'}}]","The provided function does include logic that returns a 400 (Bad Request) status code upon detecting an error (via the NGX_ERROR return from the recv function). This partially implements the specified RFC behavior for handling unrecoverable errors in a request message. Nonetheless, the implementation lacks explicit logic to close the connection within the function, and other error checks (e.g. for invalid header combinations) present in the extended spec are not handled here. Therefore, while the function visibly addresses part of the constraint (responding with a 400 status), it does not fully implement all aspects (such as explicit connection closure) as required by the spec.",success,
3858,ngx_http_v3_request_body_filter,"If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.",202,Partially Matches,"[{'A1': {'code': 'if (rc > 0) {\n    ngx_quic_reset_stream(r->connection, rc);\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""client sent invalid body"");\n    return NGX_HTTP_BAD_REQUEST;\n}\n\n...\nif (st->length > 0) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client prematurely closed stream"");\n    r->connection->error = 1;\n    return NGX_HTTP_BAD_REQUEST;\n}\n\n...\nelse if (r->headers_in.content_length_n != rb->received) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent less body data than expected: %O out of %O bytes of request body received"",\n                  rb->received, r->headers_in.content_length_n);\n    return NGX_HTTP_BAD_REQUEST;\n}', 'explanation': ""The function checks for several unrecoverable error conditions in the request (invalid body, premature stream closure, and mismatched Content-Length) and returns NGX_HTTP_BAD_REQUEST (HTTP 400), which meets part of the specification. Additionally, setting 'r->connection->error = 1' hints that the connection will eventually be closed. However, explicit connection closure is handled elsewhere, so the implementation only partially meets the spec by returning 400 in error cases within this function.""}}]","The provided function includes logic to detect unrecoverable error conditions in a request message and responds by returning NGX_HTTP_BAD_REQUEST (HTTP 400) in multiple cases. This behavior addresses the specification requirement for responding with 400. The function also sets an error flag (r->connection->error = 1) when a client prematurely closes the stream, which hints at connection closure. However, the function does not directly perform the connection closure, implying that this behavior might be handled in another part of the system. Therefore, while the function visibly implements the error response part (returning a 400 status), it only partially matches the complete specification requirement that includes both responding with 400 and closing the connection.",success,
3858,ngx_http_v3_request_body_filter,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (st->length == 0) {\n    p = cl->buf->pos;\n\n    rc = ngx_http_v3_parse_data(r->connection, st, cl->buf);\n\n    r->request_length += cl->buf->pos - p;\n    h3c->total_bytes += cl->buf->pos - p;\n\n    if (ngx_http_v3_check_flood(r->connection) != NGX_OK) {\n        return NGX_HTTP_CLOSE;\n    }\n\n    if (rc == NGX_AGAIN) {\n        continue;\n    }\n\n    if (rc == NGX_DONE) {\n        last = 1;\n        goto done;\n    }\n\n    if (rc > 0) {\n        ngx_quic_reset_stream(r->connection, rc);\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      ""client sent invalid body"");\n        return NGX_HTTP_BAD_REQUEST;\n    }\n\n    if (rc == NGX_ERROR) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n}', 'explanation': 'This segment shows the function defensively parsing the received protocol element by calling a dedicated parser function and verifying the result. It proceeds cautiously, handling cases such as incomplete data (NGX_AGAIN), completion (NGX_DONE), invalid input, and internal errors, which aligns with the requirement of only marginal expectations regarding conformance.'}}, {'A1': {'code': 'if (max != -1 && (uint64_t) (max - rb->received) < st->length) {\n    if (r->headers_in.content_length_n != -1) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client intended to send body data larger than declared"");\n\n        return NGX_HTTP_BAD_REQUEST;\n    }\n\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""client intended to send too large body: %O+%ui bytes"",\n                  rb->received, st->length);\n\n    return NGX_HTTP_REQUEST_ENTITY_TOO_LARGE;\n}', 'explanation': ""This code validates that the incoming request body does not exceed a configured maximum buffer size or declared content-length. By performing this check, the function ensures that it processes elements only if they fit into a 'reasonable' buffer size, thereby implementing a defensive strategy as required.""}}]","The function processes the HTTP body by repeatedly parsing data and monitoring the amount received. It applies defensive programming techniques by calling a specialized parser and checking for potential issues (such as flood conditions, incomplete data, or overruns beyond a set limit). These measures show that the function alone attempts to implement the RFC's requirements for defensive parsing with marginal expectations regarding protocol elements’ conformance and buffer size constraints.",success,
3865,ngx_http_v3_check_flood,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'A1': {'code': 'if (h3c->total_bytes / 8 > h3c->payload_bytes + 1048576) {\n    ngx_log_error(NGX_LOG_INFO, c->log, 0, ""http3 flood detected"");\n\n    ngx_http_v3_finalize_connection(c, NGX_HTTP_V3_ERR_NO_ERROR,\n                                        ""HTTP/3 flood detected"");\n    return NGX_ERROR;\n}', 'explanation': 'This code segment detects a flood condition and proceeds to close the connection via a call to ngx_http_v3_finalize_connection. This demonstrates that the function takes action to close the transport connection under a specific condition, aligning with the RFC statement that a client, server, or proxy may close the connection at any time.'}}]","The RFC specifies that a client, server, or proxy has the discretion to close the transport connection at any time, and the provided function exhibits such behavior by finalizing the connection when a flood condition is detected. However, while it meets the part of the specification that allows connection closure, it does not implement other aspects of the spec context, such as monitoring idle connections for graceful closures. As only a subset of the spec's considerations is addressed within this function, its implementation is considered a partial match.",success,
3865,ngx_http_v3_check_flood,"The server MAY terminate the request, if the protocol version in use allows it; otherwise, the server MAY close the connection.",292,Does Not Match,[],"The provided function solely implements a flood detection mechanism by comparing bytes counters and unconditionally finalizes the connection upon detecting a suspected flood. It does not include any logic that checks the protocol version to decide between terminating the request or closing the connection, nor does it handle the generation of a Retry-After header for temporary conditions, as specified in the RFC context. Therefore, the function does not visibly implement any of the labeled conditions or actions (e.g., handling protocol version checks or retry logic) as required by the RFC specification.",success,
3869,ngx_http_v3_ref_insert,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that within a message a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. The provided function, ngx_http_v3_ref_insert, focuses solely on looking up and validating static and dynamic table indices and then inserting header field references through ngx_http_v3_insert. There is no explicit logic in the function that verifies the sender's role or prevents generation of protocol elements that are reserved for another role. Although the function performs range checks (e.g., validating the dynamic table index), these checks do not directly ensure conformity to the RFC constraint regarding protocol element generation by the appropriate role. Since the function does not independently implement any logic corresponding to the labeled condition in the RFC spec, it does not visibly address the requirement.",success,
3893,ngx_http_v3_header_filter,An origin server SHOULD NOT generate a Server header field containing needlessly fine-grained detail and SHOULD limit the addition of subproducts by third parties.,90,Partially Matches,"[{'C1': {'code': 'if (r->headers_out.server == NULL) {\n    if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_ON) {\n        n = sizeof(NGINX_VER) - 1;\n    } else if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_BUILD) {\n        n = sizeof(NGINX_VER_BUILD) - 1;\n    } else {\n        n = sizeof(""nginx"") - 1;\n    }\n    len += ngx_http_v3_encode_field_lri(NULL, 0,\n                                        NGX_HTTP_V3_HEADER_SERVER,\n                                        NULL, n);\n    ...\n}\n\n... later ...\n\nif (r->headers_out.server == NULL) {\n    if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_ON) {\n        p = (u_char *) NGINX_VER;\n        n = sizeof(NGINX_VER) - 1;\n    } else if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_BUILD) {\n        p = (u_char *) NGINX_VER_BUILD;\n        n = sizeof(NGINX_VER_BUILD) - 1;\n    } else {\n        p = (u_char *) ""nginx"";\n        n = sizeof(""nginx"") - 1;\n    }\n    b->last = (u_char *) ngx_http_v3_encode_field_lri(b->last, 0,\n                                                 NGX_HTTP_V3_HEADER_SERVER,\n                                                 p, n);\n}', 'explanation': 'This segment checks if the Server header is absent and then selects the value based on the configuration parameter \'server_tokens\'. In cases where \'server_tokens\' is disabled (using the minimal string ""nginx""), it meets the RFC requirement to avoid fine-grained detail. However, when tokens are enabled (\'ON\' or \'BUILD\'), the output includes detailed version information, which may not comply with the RFC recommendation to limit the amount of fine-grained detail.'}}]","The function contains logic to generate the Server header and chooses the output based on a configuration value. While it provides a minimal header when configured appropriately (thus implementing the RFC's intent in that case), it also allows outputting more detailed server information if the configuration is set otherwise. Therefore, the function only partially matches the RFC specification, as it does not enforce the limitation of fine-grained detail under all circumstances.",success,
3893,ngx_http_v3_header_filter,"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",225,Fully Matches,"[{'C1': {'code': 'if (r->headers_out.location && r->headers_out.location->value.len) {\n    if (r->headers_out.location->value.data[0] == \'/\' && clcf->absolute_redirect) {\n        if (clcf->server_name_in_redirect) {\n            cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n            host = cscf->server_name;\n        } else if (r->headers_in.server.len) {\n            host = r->headers_in.server;\n        } else {\n            host.len = NGX_SOCKADDR_STRLEN;\n            host.data = addr;\n            if (ngx_connection_local_sockaddr(c, &host, 0) != NGX_OK) {\n                return NGX_ERROR;\n            }\n        }\n        port = ngx_inet_get_port(c->local_sockaddr);\n        location.len = sizeof(""https://"") - 1 + host.len + r->headers_out.location->value.len;\n        if (clcf->port_in_redirect) {\n            port = (port == 443) ? 0 : port;\n        } else {\n            port = 0;\n        }\n        if (port) {\n            location.len += sizeof("":65535"") - 1;\n        }\n        location.data = ngx_pnalloc(r->pool, location.len);\n        if (location.data == NULL) {\n            return NGX_ERROR;\n        }\n        p = ngx_cpymem(location.data, ""https://"", sizeof(""https://"") - 1);\n        p = ngx_cpymem(p, host.data, host.len);\n        if (port) {\n            p = ngx_sprintf(p, "":%ui"", port);\n        }\n        p = ngx_cpymem(p, r->headers_out.location->value.data, r->headers_out.location->value.len);\n        r->headers_out.location->value.len = p - location.data;\n        r->headers_out.location->value.data = location.data;\n        ngx_str_set(&r->headers_out.location->key, ""Location"");\n    }\n    r->headers_out.location->hash = 0;\n    len += ngx_http_v3_encode_field_lri(NULL, 0, NGX_HTTP_V3_HEADER_LOCATION, NULL, r->headers_out.location->value.len);\n}', 'explanation': ""This segment ensures that when generating an https URI (in this case for the Location header), the function obtains a valid host identifier either from the server name configuration, the incoming header, or as a fallback using the connection's local socket address. In doing so, it prevents generating a URI with an empty host.""}}]","The function explicitly handles the generation of an HTTPS URI in the case of a relative Location header. It ensures a host is provided by first attempting to use the configured server name, then falling back to the value from the incoming headers, and finally using the connection's local socket address if necessary. This logic prevents the creation of an HTTPS URI with an empty host identifier, thereby fully meeting the RFC requirement.",success,
3893,ngx_http_v3_header_filter,A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content).,193,Does Not Match,[],"The provided function does not contain any explicit logic addressing the RFC constraint that a Transfer-Encoding header field MUST NOT be sent in responses with status codes 1xx or 204. While the function handles some header modifications (e.g., setting header_only and clearing content_length for 204 responses), it does not inspect, remove, or otherwise prevent a Transfer-Encoding header from being sent. Therefore, within this function's code, there is no visible implementation that enforces the specified RFC requirement.",success,
3893,ngx_http_v3_header_filter,The type/subtype MAY be followed by semicolon-delimited parameters (Section 5.6.6) in the form of name/value pairs.,259,Partially Matches,"[{'C1': {'code': 'if (r->headers_out.content_type.len) {\n    n = r->headers_out.content_type.len;\n\n    if (r->headers_out.content_type_len == r->headers_out.content_type.len\n        && r->headers_out.charset.len)\n    {\n        n += sizeof(""; charset="") - 1 + r->headers_out.charset.len;\n    }\n    ...\n}\n\n...\n\nif (r->headers_out.content_type.len) {\n    if (r->headers_out.content_type_len == r->headers_out.content_type.len\n        && r->headers_out.charset.len)\n    {\n        n = r->headers_out.content_type.len + sizeof(""; charset="") - 1 + r->headers_out.charset.len;\n        p = ngx_pnalloc(r->pool, n);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        p = ngx_cpymem(p, r->headers_out.content_type.data, r->headers_out.content_type.len);\n        p = ngx_cpymem(p, ""; charset="", sizeof(""; charset="") - 1);\n        p = ngx_cpymem(p, r->headers_out.charset.data, r->headers_out.charset.len);\n\n        r->headers_out.content_type.len = n;\n        r->headers_out.content_type.data = p - n;\n    }\n    ...\n}', 'explanation': 'The code for processing the content-type header checks if a charset parameter exists and, if so, appends a semicolon-delimited charset parameter (e.g., ""; charset=utf-8""). This addresses the RFC specification that the type/subtype MAY be followed by semicolon-delimited parameters. However, it only handles the addition of a charset parameter and does not accommodate other potential parameters or further normalization (such as case-insensitivity handling), resulting in a partial match.'}}]","The function implements header filtering for HTTP/3 and includes logic that appends a charset parameter to the media type when needed, thereby partially addressing the RFC requirement regarding semicolon-delimited parameters. Although this logic handles the addition of a single parameter, it does not fully address all potential aspects of media type parameter processing as described in the spec.",success,
3893,ngx_http_v3_header_filter,An origin server MAY generate a Server header field in its responses.,89,Fully Matches,"[{'A1': {'code': 'if (r->headers_out.server == NULL) {\n    if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_ON) {\n        n = sizeof(NGINX_VER) - 1;\n    } else if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_BUILD) {\n        n = sizeof(NGINX_VER_BUILD) - 1;\n    } else {\n        n = sizeof(""nginx"") - 1;\n    }\n    len += ngx_http_v3_encode_field_lri(NULL, 0, NGX_HTTP_V3_HEADER_SERVER, NULL, n);\n}\n\n... \n\nif (r->headers_out.server == NULL) {\n    if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_ON) {\n        p = (u_char *) NGINX_VER;\n        n = sizeof(NGINX_VER) - 1;\n    } else if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_BUILD) {\n        p = (u_char *) NGINX_VER_BUILD;\n        n = sizeof(NGINX_VER_BUILD) - 1;\n    } else {\n        p = (u_char *) ""nginx"";\n        n = sizeof(""nginx"") - 1;\n    }\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0, ""http3 output header: \\""server: %*s\\"""", n, p);\n    b->last = (u_char *) ngx_http_v3_encode_field_lri(b->last, 0, NGX_HTTP_V3_HEADER_SERVER, p, n);\n}', 'explanation': 'The function explicitly checks if the Server header is missing (r->headers_out.server == NULL) and, based on server_tokens configuration, generates and encodes the Server header using an appropriate value. This aligns with the RFC specification that permits an origin server to generate a Server header field.'}}]","The provided function contains explicit logic to determine if the Server header is absent and then to generate it with appropriate server tokens based on configuration. This directly addresses the RFC specification that an origin server MAY generate a Server header field. Since the implementation for generating the Server header is fully contained within the function, the code fully matches the spec constraint.",success,
3893,ngx_http_v3_header_filter,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,61,Fully Matches,"[{'C1': {'code': 'if (r->method == NGX_HTTP_HEAD) {\n    r->header_only = 1;\n}', 'explanation': 'This code explicitly checks if the request method is HEAD and sets the header_only flag accordingly, ensuring that no response body will be sent.'}}, {'A1': {'code': 'if (r->header_only) {\n    b->last_buf = 1;\n}\n\nif (r->headers_out.content_length_n >= 0 && !r->header_only && !r->expect_trailers) {\n    // Creating DATA frame with content\n    ...\n}', 'explanation': 'By setting b->last_buf when header_only is true and conditionally adding a DATA frame only if header_only is false, the function adheres to the RFC requirement that HEAD responses must not send content.'}}]","The provided function implements the RFC requirement for the HEAD method by ensuring that when a request is made with the HEAD method, the header_only flag is set. This flag prevents the inclusion of a response body (DATA frame), and only header fields are encoded and sent. The logic within the function explicitly handles the HEAD method and omits content, thereby fully matching the specified RFC constraints.",success,
3893,ngx_http_v3_header_filter,"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.",52,Fully Matches,"[{'C1': {'code': 'if (r->headers_out.last_modified == NULL && r->headers_out.last_modified_time != -1) {\n    len += ngx_http_v3_encode_field_lri(NULL, 0,\n                              NGX_HTTP_V3_HEADER_LAST_MODIFIED, NULL,\n                              sizeof(""Mon, 28 Sep 1970 06:00:00 GMT"") - 1);\n}\n\n...\n\nif (r->headers_out.last_modified == NULL && r->headers_out.last_modified_time != -1) {\n    n = sizeof(""Mon, 28 Sep 1970 06:00:00 GMT"") - 1;\n\n    p = ngx_pnalloc(r->pool, n);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_http_time(p, r->headers_out.last_modified_time);\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                   ""http3 output header: \\""last-modified: %*s\\"""", n, p);\n\n    b->last = (u_char *) ngx_http_v3_encode_field_lri(b->last, 0,\n                                          NGX_HTTP_V3_HEADER_LAST_MODIFIED,\n                                          p, n);\n}', 'explanation': 'These code segments check whether the Last-Modified header is unset and a valid last modification time exists (i.e., last_modified_time != -1). When those conditions are met, they compute the header length, allocate space, format the time using ngx_http_time, and then encode the Last-Modified header. This directly implements the RFC requirement that the origin server SHOULD send a Last-Modified header when a last modification date is determinable.'}}]","The function ngx_http_v3_header_filter contains dedicated logic to determine if the Last-Modified header should be sent by checking if the header is not already set and if a valid last modification time exists. It then formats and encodes the header accordingly. This directly addresses the RFC requirement for sending the Last-Modified header, and thus the function fully implements the corresponding constraint.",success,
3893,ngx_http_v3_header_filter,"Note that the coding named ""identity"" is reserved for its special role in Accept-Encoding and thus SHOULD NOT be included.",38,Does Not Match,[],"The provided HTTP RFC specification discusses the Content-Encoding header (specifically for gzip encodings) and states that the coding named 'identity' MUST NOT be included. In the function, there is no visible logic that handles the Content-Encoding header or checks for the 'identity' coding. Instead, the function is focused on encoding other headers (status, server, date, content-type, content-length, last-modified, location, and vary) for HTTP/3 responses. Since none of the code in the function addresses the specifics of the Content-Encoding requirement or the exclusion of the 'identity' coding, this function does not attempt to implement the specified HTTP RFC constraints within its own logic.",success,
3893,ngx_http_v3_header_filter,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,"[{'C1': {'code': 'if (r->headers_out.content_type.len) {\n    if (r->headers_out.content_type_len == r->headers_out.content_type.len\n        && r->headers_out.charset.len)\n    {\n        n = r->headers_out.content_type.len + sizeof(""; charset="") - 1 + r->headers_out.charset.len;\n    }\n    ...\n    b->last = (u_char *) ngx_http_v3_encode_field_lri(b->last, 0,\n                                NGX_HTTP_V3_HEADER_CONTENT_TYPE_TEXT_PLAIN,\n                                r->headers_out.content_type.data,\n                                r->headers_out.content_type.len);\n}\n\n... \nif (r->headers_out.content_type.len) {\n    /* update and log content-type header for HTTP/3 */\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                   ""http3 output header: \\""content-type: %V\\"""",\n                   &r->headers_out.content_type);\n    b->last = (u_char *) ngx_http_v3_encode_field_lri(b->last, 0,\n                                NGX_HTTP_V3_HEADER_CONTENT_TYPE_TEXT_PLAIN,\n                                r->headers_out.content_type.data,\n                                r->headers_out.content_type.len);\n}', 'explanation': 'The function encodes and emits the Content-Type header when r->headers_out.content_type is set. This shows an attempt to meet the RFC requirement that a message with content should include a Content-Type header. However, the function does not insert a default Content-Type header if it is not already provided, leaving the implementation only partial.'}}]","The RFC mandates that if a message contains content, the sender SHOULD generate a Content-Type header unless the media type is unknown. In the provided function, the Content-Type header is encoded and sent only if the r->headers_out.content_type field is already populated. There is no additional logic to generate a Content-Type header by default when it is missing, which means the function only partially fulfills the specification's intention. The implementation within function_body addresses the condition when the header is available, but does not guarantee its generation when absent.",success,
3893,ngx_http_v3_header_filter,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Fully Matches,"[{'C1': {'code': 'if (r->headers_out.location && r->headers_out.location->value.len) {\n    if (r->headers_out.location->value.data[0] == \'/\' && clcf->absolute_redirect) {\n        if (clcf->server_name_in_redirect) {\n            cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n            host = cscf->server_name;\n        } else if (r->headers_in.server.len) {\n            host = r->headers_in.server;\n        } else {\n            host.len = NGX_SOCKADDR_STRLEN;\n            host.data = addr;\n            if (ngx_connection_local_sockaddr(c, &host, 0) != NGX_OK) {\n                return NGX_ERROR;\n            }\n        }\n        ...\n        p = ngx_cpymem(location.data, ""https://"", sizeof(""https://"") - 1);\n        p = ngx_cpymem(p, host.data, host.len);\n        ...\n    }\n    ...\n}', 'explanation': ""This code block explicitly handles the generation of a Location URI. When the location value is relative (starts with '/') and an absolute redirect is required, it selects a host from three sources (server configuration, request header, or the connection’s local socket address). This guarantees that a host identifier is always provided, thereby ensuring that the function never generates an http URI with an empty host identifier as mandated by the specification.""}}]","The function ngx_http_v3_header_filter contains logic in its processing of the Location header that ensures a host identifier is always included when constructing an absolute URI. It first checks for a relative path and then uses configuration or connection-derived data to supply a valid host. This directly implements the spec constraint which requires that a sender MUST NOT generate an ""http"" URI (or in this case, a similar URI for redirection) with an empty host identifier.",success,
3893,ngx_http_v3_header_filter,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Partially Matches,"[{'C1': {'code': 'if (r->headers_out.status == NGX_HTTP_NO_CONTENT) {\n        r->header_only = 1;\n        ngx_str_null(&r->headers_out.content_type);\n        r->headers_out.last_modified_time = -1;\n        r->headers_out.last_modified = NULL;\n        r->headers_out.content_length = NULL;\n        r->headers_out.content_length_n = -1;\n    }', 'explanation': 'This block explicitly clears the Content-Length header fields for responses with status 204 (No Content), thereby ensuring that a Content-Length header is not sent. However, the RFC also requires that no Content-Length header be sent with any 1xx (Informational) responses, and there is no corresponding logic in the function for handling 1xx responses.'}}]","The function meets part of the RFC by handling the 204 (No Content) case, but it does not address the 1xx (Informational) case. Since the specification mandates that Content-Length must not be sent for both status code ranges, the function only partially matches the requirements.",success,
3897,ngx_http_v3_create_trailers,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Fully Matches,"[{'C1': {'code': 'hl = ngx_chain_get_free_buf(r->pool, &ctx->free);\nif (hl == NULL) {\n    return NULL;\n}\n...\n// Encode the frame type for trailer fields\nb->last = (u_char *) ngx_http_v3_encode_varlen_int(p, NGX_HTTP_V3_FRAME_HEADERS);\nb->last = (u_char *) ngx_http_v3_encode_varlen_int(b->last, n);\n\nhl->next = cl;\n\nreturn hl;', 'explanation': 'The RFC states that a recipient MUST NOT merge trailer fields into the header section unless it explicitly understands and permits merging. In this function the trailer fields (from r->headers_out.trailers) are iterated over and encoded into their own dedicated frame (using the frame type NGX_HTTP_V3_FRAME_HEADERS). This separation demonstrates that the code intentionally avoids merging trailer fields into the header section and instead creates a separate trailer block as required by the RFC.'}}]","The function ngx_http_v3_create_trailers iterates over the trailer header list, computes the necessary length for encoding them, and then constructs a separate HTTP/3 frame containing these trailer fields. By encoding the trailer fields separately—most notably by writing the frame type (NGX_HTTP_V3_FRAME_HEADERS) and length into a separate chain buffer—the function ensures that trailer fields are not merged into the header section without explicit permission. This behavior directly addresses the RFC requirement and thus fully matches the specified constraint.",success,
3904,ngx_http_v2_get_indexed_header,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (index == 0) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent invalid hpack table index 0"");\n    return NGX_ERROR;\n}', 'explanation': 'This code checks for an invalid index of 0, which is a defensive measure to ensure that the received protocol element conforms to minimal expectations.'}}, {'A1': {'code': 'if (index < h2c->hpack.added - h2c->hpack.deleted) {\n    // ... code copying header name and value with careful handling of ring-buffer wrap-around\n}\n\nngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n              ""client sent out of bound hpack table index: %ui"", index);\n\nreturn NGX_ERROR;', 'explanation': 'This segment handles valid indexes by copying header parts from storage with a mechanism to account for wrap-around, and it logs and returns an error if the index is out of bounds. This is an example of defensive parsing to ensure that the protocol element is within expected limits.'}}]","The function implements some defensive parsing aspects required by the RFC specification—it verifies that the index is non‐zero, checks for out-of-bound conditions, and carefully copies header fields accounting for ring-buffer wrapping. However, it does not fully validate the received header element against its ABNF grammar or enforce overall reasonable buffer limits explicitly within this function. As such, while it addresses certain defensive measures directly in the code (C1 and A1), it only partially matches the full spectrum of defensive parsing as outlined in the spec.",success,
3904,ngx_http_v2_get_indexed_header,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (index == 0) { ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0, ""client sent invalid hpack table index 0""); return NGX_ERROR; } ... if (index < NGX_HTTP_V2_STATIC_TABLE_ENTRIES) { h2c->state.header = ngx_http_v2_static_table[index]; return NGX_OK; } ... // Dynamic table lookup and index validation\n', 'explanation': 'The function checks the validity of the received header index and selects between entries in the static and dynamic HPACK tables. This reflects an interpretation of the received protocol element by mapping the index to its corresponding header, which is in the spirit of the requirement to interpret according to defined semantics. However, the function does not implement additional recovery mechanisms or sender-specific exception handling as hinted in the spec context.'}}]","The provided code function processes an incoming header element by validating the index and retrieving the corresponding header from either a static or dynamic table. This indicates an attempt to interpret the protocol element as specified in the RFC. Error conditions are handled by logging and returning errors for invalid index values, which shows that the function distinguishes between correctly and incorrectly implemented sender behavior. Nonetheless, it does not include broader error recovery or additional mechanisms (such as configuration‐ or experience-based adjustments) that the RFC context describes. Therefore, while some aspects of the RFC are addressed within this function, it only partially matches the full scope of the specification.",success,
3904,ngx_http_v2_get_indexed_header,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function ngx_http_v2_get_indexed_header is responsible for fetching an indexed header from the HPACK table and handling error conditions such as invalid or out-of-bound indices. Although it performs checks (e.g., validating that the index is non-zero and within bounds), it does not implement any logic to verify or enforce that the sender is not generating protocol elements or syntax alternatives that are reserved for other roles. There is no code that distinguishes or restricts protocol elements based on the sender's role, which is the core requirement of the provided RFC specification. Thus, the function does not visibly address the specified constraint.",success,
3906,ngx_http_v2_add_header,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function ngx_http_v2_add_header primarily handles the addition of header entries to the HPACK table for HTTP/2. It manages memory allocation, header copying, and table resizing. However, there is no code that enforces or checks that a sender is not generating protocol elements or syntax alternatives that are only allowed for other roles as specified in the RFC. Consequently, there is no logic within the function addressing the spec constraint regarding role-based generation of protocol elements.",success,
3906,ngx_http_v2_add_header,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC requires that a sender must not generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. However, the function ngx_http_v2_add_header only copies and stores header names and values into an HPACK table without any validation checks against the ABNF grammar. There is no visible logic within the function that ensures generated protocol elements conform to the ABNF rules, meaning that none of the labeled conditions (e.g., C1) or actions (e.g., A1) are addressed. Therefore, the function does not implement the specified RFC constraint.",success,
3909,ngx_http_v2_table_size,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (size > NGX_HTTP_V2_TABLE_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent invalid table size update: %uz"", size);\n    return NGX_ERROR;\n}', 'explanation': ""This segment defensively checks that the received table size does not exceed a predefined maximum (i.e. a reasonable buffer size), which is in the spirit of the RFC's guidance to not overly trust protocol elements. It specifically ensures that value overrun issues are avoided.""}}]","The RFC requires that a recipient parses incoming protocol elements defensively, making only marginal assumptions about the element's conformity and size. The provided function implements a defensive check by verifying that the 'size' parameter does not exceed an acceptable maximum (NGX_HTTP_V2_TABLE_SIZE) and logs an error if it does. However, because the RFC also mentions the conservative acceptance of grammar (ABNF) which is not applicable or checked in this numeric context, the function addresses only the size/buffer aspect of the specification. Thus, although it implements a key defensive check regarding buffer size, it does not encompass all aspects of the RFC's guidance, leading to a 'Partially Matches' outcome.",success,
3909,ngx_http_v2_table_size,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Fully Matches,"[{'C1': {'code': 'if (size > NGX_HTTP_V2_TABLE_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent invalid table size update: %uz"", size);\n    return NGX_ERROR;\n}', 'explanation': 'This segment validates that the new table size does not exceed the maximum allowed. It rejects the update if the sender’s provided value is too high, thereby interpreting the received protocol element in accordance with the specification.'}}, {'A1': {'code': 'needed = h2c->hpack.size - size;\n\nwhile (needed > (ssize_t) h2c->hpack.free) {\n    entry = h2c->hpack.entries[h2c->hpack.deleted++ % h2c->hpack.allocated];\n    h2c->hpack.free += 32 + entry->name.len + entry->value.len;\n}\n\nh2c->hpack.size = size;\nh2c->hpack.free -= needed;', 'explanation': 'This part of the code adjusts the internal HPACK dynamic table by removing entries until enough space is freed, then applies the new table size. This implements the action required for properly interpreting and managing a received protocol element.'}}]","The function implements the RFC requirement by first validating the received table size (C1) and then adjusting the internal dynamic table state (A1) based solely on its internal logic. These code segments demonstrate that the function directly addresses the constraint to interpret a protocol element according to the defined semantics, making it a full match.",success,
3979,ngx_http_v2_read_handler,"A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.",310,Fully Matches,"[{'C1': {'code': 'if (rev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");\n    ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n    return;\n}\n...\nif (n == 0 && (h2c->state.incomplete || h2c->processing)) {\n    ngx_log_error(NGX_LOG_INFO, c->log, 0, ""client prematurely closed connection"");\n}\n\nif (n == 0 || n == NGX_ERROR) {\n    c->error = 1;\n    ngx_http_v2_finalize_connection(h2c, 0);\n    return;\n}', 'explanation': 'These code segments detect when the client’s request is incomplete due to timeout (rev->timedout) or premature closure (n == 0 with an incomplete state), which aligns with the condition in the spec of receiving an incomplete request message.'}}, {'A1': {'code': 'ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n...\nngx_http_v2_finalize_connection(h2c, 0);', 'explanation': 'By finalizing the connection with an error code (or no error, depending on context), the function attempts to send an error response prior to closing the connection, which complies with the spec’s allowance to send an error response on incomplete requests.'}}]","The function explicitly checks for scenarios where the request may be incomplete—whether due to a timeout (rev->timedout) or a prematurely closed connection (n == 0 with an incomplete state). In both cases, it finalizes the connection by calling ngx_http_v2_finalize_connection with an appropriate error status. This behavior directly addresses the HTTP RFC requirement that a server, upon receiving an incomplete request message, may send an error response before closing the connection. All relevant logic is self-contained within the function_body, thereby fully matching the specified constraint.",success,
3979,ngx_http_v2_read_handler,"Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.",315,Fully Matches,"[{'C1': {'code': 'if (c->close) {\n    c->close = 0;\n\n    if (c->error) {\n        ngx_http_v2_finalize_connection(h2c, 0);\n        return;\n    }\n\n    if (!h2c->processing) {\n        ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_NO_ERROR);\n        return;\n    }\n\n    if (!h2c->goaway) {\n        h2c->goaway = 1;\n\n        if (ngx_http_v2_send_goaway(h2c, NGX_HTTP_V2_NO_ERROR) == NGX_ERROR) {\n            ngx_http_v2_finalize_connection(h2c, 0);\n            return;\n        }\n\n        if (ngx_http_v2_send_output_queue(h2c) == NGX_ERROR) {\n            ngx_http_v2_finalize_connection(h2c, 0);\n            return;\n        }\n    }\n\n    h2c->blocked = 0;\n\n    return;\n}', 'explanation': ""This segment monitors the connection for a closure signal via the c->close flag. Once the flag is detected, the function responds appropriately by resetting the flag and finalizing the connection, which aligns with the RFC's requirement for prompt closure handling.""}}, {'A1': {'code': 'if (rev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");\n    ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n    return;\n}', 'explanation': 'This segment handles the case when the connection event times out. It finalizes the connection if a timeout is detected, which is consistent with implementing a response to connection closure conditions.'}}]","The function actively monitors the connection state by checking both for a timeout (rev->timedout) and an explicit closure signal (c->close). When either condition occurs, it triggers a call to finalize the connection, thereby reclaiming system resources as recommended by the RFC. Since these checks and corresponding graceful closure actions occur within this function, it fully meets the specified RFC requirements.",success,
3979,ngx_http_v2_read_handler,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'h2c->blocked = 1;\n...\n/* after processing and output handling */\n\nh2c->blocked = 0;', 'explanation': ""The function marks the connection state as 'blocked' during processing and then unblocks it at the end, which is an indication of managing an ongoing persistent connection rather than immediately tearing it down. This behavior hints at sustaining the connection rather than closing it prematurely.""}}, {'A1': {'code': 'if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n    ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_INTERNAL_ERROR);\n    return;\n}', 'explanation': 'By re-arming the read event with ngx_handle_read_event, the function leverages the underlying transport mechanism to resume processing when the connection is ready, rather than forcefully closing the connection. This reflects the RFC’s recommendation that the server allow flow control to manage temporary overloads.'}}]","The provided function demonstrates some efforts to sustain a persistent HTTP/2 connection by managing a blocked state and re-arming read events, which allows the underlying transport and flow-control mechanisms to continue operation. However, the function also finalizes connections in several error conditions and timeouts without additional nuanced handling for temporary overloads. As a result, while portions of the RFC requirement are addressed, the implementation does not fully encapsulate the intent of allowing temporary overload conditions to resolve safely. Thus, the match is only partial.",success,
3979,ngx_http_v2_read_handler,The server MUST NOT process any further requests received on that connection.,320,Fully Matches,"[{'C1': {'code': 'if (c->close) {\n    c->close = 0;\n\n    if (c->error) {\n        ngx_http_v2_finalize_connection(h2c, 0);\n        return;\n    }\n\n    if (!h2c->processing) {\n        ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_NO_ERROR);\n        return;\n    }\n\n    if (!h2c->goaway) {\n        h2c->goaway = 1;\n\n        if (ngx_http_v2_send_goaway(h2c, NGX_HTTP_V2_NO_ERROR) == NGX_ERROR) {\n            ngx_http_v2_finalize_connection(h2c, 0);\n            return;\n        }\n\n        if (ngx_http_v2_send_output_queue(h2c) == NGX_ERROR) {\n            ngx_http_v2_finalize_connection(h2c, 0);\n            return;\n        }\n    }\n\n    h2c->blocked = 0;\n\n    return;\n}', 'explanation': 'This segment checks if the connection is flagged to close (c->close) and immediately finalizes the connection, thereby preventing any subsequent requests from being processed as mandated by the specification.'}}]","The function contains explicit logic that, upon detecting a connection close flag, ceases further request processing by finalizing the connection. This behavior directly addresses the RFC requirement that the server must not process any further requests on that connection. All relevant actions for this constraint are implemented within this function without reliance on external dependencies.",success,
3979,ngx_http_v2_read_handler,"A client, server, or proxy MAY close the transport connection at any time.",316,Fully Matches,"[{'C1': {'code': 'if (rev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");\n    ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n    return;\n}', 'explanation': ""This segment detects a timeout event on the connection (a possible closure initiated by the client) and immediately finalizes the connection, which aligns with the spec's allowance for closing the transport connection at any time.""}}, {'A1': {'code': 'if (c->close) {\n    c->close = 0;\n\n    if (c->error) {\n        ngx_http_v2_finalize_connection(h2c, 0);\n        return;\n    }\n\n    if (!h2c->processing) {\n        ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_NO_ERROR);\n        return;\n    }\n\n    if (!h2c->goaway) {\n        h2c->goaway = 1;\n\n        if (ngx_http_v2_send_goaway(h2c, NGX_HTTP_V2_NO_ERROR) == NGX_ERROR) {\n            ngx_http_v2_finalize_connection(h2c, 0);\n            return;\n        }\n\n        if (ngx_http_v2_send_output_queue(h2c) == NGX_ERROR) {\n            ngx_http_v2_finalize_connection(h2c, 0);\n            return;\n        }\n    }\n\n    h2c->blocked = 0;\n\n    return;\n}', 'explanation': 'This block checks if the connection has been flagged for closure (c->close) and then proceeds to gracefully shut down the connection. It conditionally sends a GOAWAY signal and finalizes the connection based on the state, implementing a graceful close behavior as recommended by the RFC.'}}]","The function monitors for connection timeout and explicit close signals (via rev->timedout and c->close, respectively), both of which allow the transport connection to be closed at any time. The code then takes appropriate action by finalizing the connection or sending a GOAWAY frame when necessary. This behavior directly implements the spec constraint from the HTTP RFC, where a client, server, or proxy MAY close the transport connection at any time. All of this logic is implemented within the function, meaning it fully addresses the relevant conditions and actions as required.",success,
3979,ngx_http_v2_read_handler,A client or server that wishes to time out SHOULD issue a graceful close on the connection.,314,Partially Matches,"[{'A1': {'code': 'if (!h2c->goaway) {\n    h2c->goaway = 1;\n\n    if (ngx_http_v2_send_goaway(h2c, NGX_HTTP_V2_NO_ERROR)\n        == NGX_ERROR)\n    {\n        ngx_http_v2_finalize_connection(h2c, 0);\n        return;\n    }\n\n    if (ngx_http_v2_send_output_queue(h2c) == NGX_ERROR) {\n        ngx_http_v2_finalize_connection(h2c, 0);\n        return;\n    }\n}', 'explanation': ""This code segment, executed when the connection is closing (c->close is true) and the connection is not actively processing, sends a GOAWAY frame with NGX_HTTP_V2_NO_ERROR. This corresponds to issuing a graceful close as recommended by the RFC. However, the function's handling of timeouts (rev->timedout) calls ngx_http_v2_finalize_connection with NGX_HTTP_V2_PROTOCOL_ERROR, which is not the graceful closure indicated by the spec.""}}]","The RFC specifies that a client or server wishing to time out SHOULD issue a graceful close on the connection. In this function, when the connection detects a close condition (c->close), it attempts to perform a graceful shutdown by sending a GOAWAY frame (with NGX_HTTP_V2_NO_ERROR) which meets the spec's intent. However, in the case of a timeout (rev->timedout), the function logs the timeout and finalizes the connection using a protocol error code, which does not represent a graceful close. As a result, while the function does implement graceful closure in one branch, it does not consistently apply it for all timeout situations. Therefore, it only partially matches the specification.",success,
3981,ngx_http_v2_write_handler,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (wev->timedout) {\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, ""http2 write event timed out"");\n    c->error = 1;\n    c->timedout = 1;\n    ngx_http_v2_finalize_connection(h2c, 0);\n    return;\n}', 'explanation': 'This block detects a timeout event and then finalizes (i.e. closes) the connection. This corresponds to the spec allowance that a client, server, or proxy may close the transport connection at any time, especially in the case of connection inactivity or timeout.'}}, {'A1': {'code': 'c->error = 1;\nc->timedout = 1;\nngx_http_v2_finalize_connection(h2c, 0);', 'explanation': 'By marking the connection with an error and invoking a finalization function, the code attempts a graceful closure which is recommended by the spec context when a timeout occurs.'}}]","The function implements a mechanism to close the connection when a write event times out by logging the event, marking the error state, and finalizing the connection. This behavior partially meets the RFC specification that permits the closure of a transport connection (and suggests a graceful close on timeout). However, since the RFC context also refers to handling of idle connections and flow-control situations that are not explicitly covered in this function, only a subset of the spec constraints is addressed here.",success,
3981,ngx_http_v2_write_handler,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'if (h2c->last_out == NULL && !c->buffered) {\n\n    if (wev->timer_set) {\n        ngx_del_timer(wev);\n    }\n\n    ngx_http_v2_handle_connection(h2c);\n    return;\n}', 'explanation': 'This segment shows that when there is no pending output and the connection isn’t buffered, the handler does not prematurely close the connection but continues processing. This behavior supports the RFC’s suggestion to sustain persistent connections whenever possible.'}}, {'A1': {'code': 'if (rc == NGX_AGAIN) {\n    return;\n}', 'explanation': 'By simply returning when ngx_http_v2_send_output_queue returns NGX_AGAIN, the function defers further action. This allows the underlying transport’s flow‐control mechanisms (and event loop) to eventually clear the temporary overload rather than immediately terminating the connection.'}}]","The function incorporates logic to continue processing the connection when no data remains buffered (C1) and to defer connection termination when encountering a temporary inability to send (NGX_AGAIN, A1). Thus, it does attempt to sustain persistent connections and let flow-control mechanisms cope with temporary overloads. However, it finalizes the connection in timeout or error conditions without explicitly handling all aspects of the RFC’s requirements. As a result, although the function handles some core elements in its write event logic, it only partially matches the spec constraints.",success,
3981,ngx_http_v2_write_handler,A client or server that wishes to time out SHOULD issue a graceful close on the connection.,314,Partially Matches,"[{'A1': {'code': 'if (wev->timedout) {\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, ""http2 write event timed out"");\n    c->error = 1;\n    c->timedout = 1;\n    ngx_http_v2_finalize_connection(h2c, 0);\n    return;\n}', 'explanation': ""When the write event times out (wev->timedout is true), the function logs the timeout, marks the connection as errored/timedout, and then calls ngx_http_v2_finalize_connection. This indicates that on timeout, a closure is initiated in a presumably graceful manner, directly addressing the spec's requirement to issue a graceful close on timeout.""}}]","The function monitors for a timeout on the write event, and when a timeout is detected, it finalizes the connection. This directly corresponds to the RFC specification that recommends a graceful closure when a client or server wishes to time out. However, the RFC also mentions that implementations should constantly monitor for an incoming closure signal and respond appropriately. Since this function does not address monitoring for a received closure signal and solely focuses on the timeout-triggered path, it only partially matches the overall spec requirements.",success,
3982,ngx_http_v2_send_output_queue,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'A1': {'code': 'if (!wev->ready) {\n    ngx_add_timer(wev, clcf->send_timeout);\n    return NGX_AGAIN;\n}', 'explanation': 'This code checks if the write event is not ready and, rather than closing the connection, arranges a timer callback. This behavior reflects an attempt to let the underlying transport mechanisms (i.e. flow control via events) handle temporary overloads instead of terminating the connection.'}}, {'A2': {'code': 'if (ngx_handle_write_event(wev, clcf->send_lowat) != NGX_OK) {\n    goto error;\n}', 'explanation': 'Here the function delegates management of the write event (including low watermark handling) to ngx_handle_write_event, which again signals reliance on transport-level flow control to handle overload conditions.'}}]","The function implements parts of the RFC requirement by avoiding immediate connection termination when the output cannot be sent. It schedules a timer and defers sending (returning NGX_AGAIN) to allow the underlying transport to manage temporary overloads. However, it does not fully cover all aspects specified in the RFC context (for example, comprehensive maintenance of persistent connections in all scenarios or monitoring a message body transmission for premature closure). Thus, the function partially matches the spec constraints.",success,
3983,ngx_http_v2_handle_connection,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'if (!c->read->timer_set) {\n    ngx_add_timer(c->read, clcf->keepalive_timeout);\n}\n\nngx_reusable_connection(c, 1);', 'explanation': 'This segment sets a keepalive timer and marks the connection as reusable, which aligns with sustaining persistent connections as recommended by the spec.'}}, {'A1': {'code': 'if (c->buffered) {\n    h2c->blocked = 1;\n\n    rc = ngx_http_v2_send_output_queue(h2c);\n\n    h2c->blocked = 0;\n\n    if (rc == NGX_ERROR) {\n        ngx_http_close_connection(c);\n        return;\n    }\n\n    if (rc == NGX_AGAIN) {\n        return;\n    }\n    \n    /* rc == NGX_OK */\n}', 'explanation': 'This code attempts to process pending output without closing the connection immediately when temporary overload (NGX_AGAIN) occurs, thereby favoring underlying flow-control mechanisms to resolve the situation.'}}]","The function includes logic that supports persistent connections (by marking the connection as reusable and setting a keepalive timer) and handles temporary overloads by returning when output processing indicates a temporary state (NGX_AGAIN) rather than forcefully closing the connection. However, not all aspects of the RFC—such as detailed error monitoring during message body transmission—are managed within this function alone, so the implementation only partially matches the specified RFC constraints.",success,
3983,ngx_http_v2_handle_connection,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (c->error) {\n    ngx_http_close_connection(c);\n    return;\n}', 'explanation': 'This segment closes the connection immediately when an error is detected, which implements the RFC’s allowance that a client, server, or proxy MAY close the transport connection at any time.'}}, {'A1': {'code': 'if (h2c->goaway) {\n    ngx_http_v2_lingering_close(c);\n    return;\n}', 'explanation': 'This code calls a lingering close when the goaway flag is set, thereby performing a graceful shutdown as recommended for timing out idle connections.'}}]","The function provides logic that enables connection closure in specific conditions such as when an error occurs or when a go-away signal has been set, which corresponds to permission in the RFC for closing a connection at any time. However, while it addresses these connection closure actions, it does not cover all possible scenarios described in the RFC (for example, it does not fully implement the monitoring for receipt of closure signals in every situation). Consequently, the function is considered to partially match the specification.",success,
3984,ngx_http_v2_lingering_close,Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection.,325,Partially Matches,"[{'A1': {'code': 'if (c->ssl) {\n    ngx_int_t  rc;\n\n    rc = ngx_ssl_shutdown(c);\n\n    if (rc == NGX_ERROR) {\n        ngx_http_close_connection(c);\n        return;\n    }\n\n    if (rc == NGX_AGAIN) {\n        c->ssl->handler = ngx_http_v2_lingering_close;\n        return;\n    }\n}', 'explanation': 'This code block for SSL connections calls ngx_ssl_shutdown, which is typically responsible for sending a closure alert (close_notify) to initiate the TLS shutdown exchange. This action meets the RFC requirement for initiating an exchange of closure alerts, but only for SSL-enabled connections.'}}]","The RFC requires servers to attempt a closure alert exchange with the client before closing the connection. In this function, the SSL branch explicitly calls ngx_ssl_shutdown to carry out that exchange. However, for non-SSL connections, the function does not include any logic to initiate a closure alert exchange; it proceeds with lingering close and socket shutdown. Thus, while the function addresses the closure alert requirement for SSL connections, it does not handle it for all cases, and therefore only partially meets the spec's overall requirement.",success,
3985,ngx_http_v2_lingering_close_handler,A client or server that wishes to time out SHOULD issue a graceful close on the connection.,314,Fully Matches,"[{'C1': {'code': 'if (rev->timedout || c->close) {\n    ngx_http_close_connection(c);\n    return;\n}\n...\nif ((ngx_msec_int_t) timer <= 0) {\n    ngx_http_close_connection(c);\n    return;\n}', 'explanation': 'The function continuously checks for a closure signal by monitoring the connection event (rev->timedout) and a flag on the connection (c->close), as well as by comparing the lingering time remaining (timer) to decide if the connection should be closed. This directly implements the requirement that, upon timing out or receiving a closure signal, a graceful close should be issued.'}}, {'A1': {'code': 'ngx_http_close_connection(c);', 'explanation': 'This call is used in multiple parts of the function (when a timeout is detected, when the lingering period has expired, or upon receiving an error/EOF from the read), effectively performing the graceful close action as required by the spec.'}}]","The provided function implements the mechanism for graceful connection closure as outlined in the spec. It monitors the connection for timeout events (rev->timedout, c->close) and the lapsing of the lingering period, and when such conditions occur, it calls ngx_http_close_connection(c) to close the connection. This addresses both the monitoring condition and the required graceful shutdown action, fulfilling the spec constraints entirely within the function.",success,
3985,ngx_http_v2_lingering_close_handler,"A client, server, or proxy MAY close the transport connection at any time.",316,Fully Matches,"[{'C1': {'code': 'if (rev->timedout || c->close) {\n    ngx_http_close_connection(c);\n    return;\n}', 'explanation': 'This segment checks if the event has timed out or if the connection has been flagged to close, then immediately closes the connection, fulfilling the specification that a client, server, or proxy MAY close the transport connection at any time.'}}, {'A1': {'code': 'timer = (ngx_msec_t) h2c->lingering_time - (ngx_msec_t) ngx_time();\nif ((ngx_msec_int_t) timer <= 0) {\n    ngx_http_close_connection(c);\n    return;\n}', 'explanation': ""This part computes a lingering timer and closes the connection when the lingering time has expired, implementing a graceful close mechanism in line with the spec's recommendation for timely resource recovery.""}}]","The function implements a lingering close handler that continuously monitors the connection. It closes the connection upon a timeout, an explicit close flag, or when the lingering period expires. These operations directly address the RFC stipulation that a client, server, or proxy may close the transport connection at any time, and they implement a graceful close as advised in the specification context.",success,
3989,ngx_http_v2_state_head,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (end - pos < NGX_HTTP_V2_FRAME_HEADER_SIZE) {\n    return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_head);\n}', 'explanation': ""This check ensures that the function only proceeds if the incoming buffer has at least the minimum required size for the HTTP/2 frame header. This is a defensive programming measure aligned with the RFC's guidance to verify a reasonable buffer size.""}}, {'A1': {'code': 'if (type >= NGX_HTTP_V2_FRAME_STATES) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent frame with unknown type %ui"", type);\n    return ngx_http_v2_state_skip(h2c, pos, end);\n}', 'explanation': 'This code segment logs an error and skips processing when an unknown frame type is encountered, providing a defensive means of handling unexpected protocol elements.'}}]","The function implements defensive parsing by first checking whether the buffer contains enough data to parse a frame header (C1) and then by detecting unexpected frame types (A1). These measures align with the RFC's recommendation to parse protocol elements defensively, assuming only marginal conformance to strict grammar rules. However, it does not address all aspects of the RFC (such as full ABNF grammar validation), so the implementation only partially matches the overall specification.",success,
3989,ngx_http_v2_state_head,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'head = ngx_http_v2_parse_uint32(pos);\nh2c->state.length = ngx_http_v2_parse_length(head);\nh2c->state.flags = pos[4];\nh2c->state.sid = ngx_http_v2_parse_sid(&pos[5]);\n\ntype = ngx_http_v2_parse_type(head);', 'explanation': 'This segment extracts and interprets the various components of the received HTTP/2 frame header (length, flags, stream ID, type), which corresponds to interpreting a received protocol element as mandated by the spec.'}}, {'A1': {'code': 'if (end - pos < NGX_HTTP_V2_FRAME_HEADER_SIZE) {\n    return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_head);\n}\n...\nif (type >= NGX_HTTP_V2_FRAME_STATES) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent frame with unknown type %ui"", type);\n    return ngx_http_v2_state_skip(h2c, pos, end);\n}', 'explanation': ""These checks implement error handling and recovery: if there isn’t enough data for a complete header, the state is saved for later processing; if the frame type is unrecognized, the frame is skipped. This follows the spec's recommendation to attempt recovery from invalid constructs.""}}]","The function visibly parses an HTTP/2 frame header and handles error conditions by saving the state when insufficient data is available and by skipping frames with an unknown type. This demonstrates an attempt to interpret and recover a protocol element per the RFC requirement. However, it only partially covers the full scope of the RFC (e.g., handling of extensions or further interpretation logic) and thus is assessed as partially matching.",success,
3990,ngx_http_v2_state_data,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (h2c->state.sid == 0) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent DATA frame with incorrect identifier"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'This segment ensures that a DATA frame is not accepted when sent with stream identifier 0, which is indicative of a protocol element being generated by a role (client) that is not allowed to produce it. This check directly addresses the spec requirement that a sender must not generate protocol elements reserved for other roles.'}}]","The function contains several validation checks on incoming DATA frames (e.g., padded-data validation, flow control, and identification of streams). In particular, the check for a DATA frame with a stream id of 0 (shown above) implements a key aspect of the spec constraint by rejecting frames that are incorrectly generated by the sender. However, while this check demonstrates an attempt to enforce role-specific protocol element generation, the function does not directly address all possible alternatives or syntactical variations that may violate the spec. Therefore, the implementation is only partially matching the overall spec constraint.",success,
3990,ngx_http_v2_state_data,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (h2c->state.flags & NGX_HTTP_V2_PADDED_FLAG) {\n    if (h2c->state.length == 0) {\n        ngx_log_error(..., ""client sent padded DATA frame with incorrect length: 0"");\n        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n    }\n    ...\n    h2c->state.padding = *pos++;\n    if (h2c->state.padding >= size) {\n        ngx_log_error(..., ""client sent padded DATA frame with incorrect length: %uz, padding: %uz"", size, h2c->state.padding);\n        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n    }\n    h2c->state.length -= 1 + h2c->state.padding;\n}', 'explanation': 'This code segment checks the integrity of a padded DATA frame by validating that the length is correct and the padding is not longer than the frame. In doing so, it attempts to ensure that the frame conforms to the expected grammar as per the RFC requirement.'}}, {'C2': {'code': 'if (h2c->state.sid == 0) {\n    ngx_log_error(..., ""client sent DATA frame with incorrect identifier"");\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'This segment verifies that the DATA frame has a valid non-zero stream identifier, which is a requirement derived from the protocol grammar. This helps ensure that only correctly formed protocol elements are processed.'}}]","The function performs several validation checks on received DATA frames (such as validating padded frames and ensuring a non-zero stream identifier) which help enforce that incoming protocol elements follow the expected grammar. However, while these checks partially address the RFC requirement that a sender must not generate protocol elements that do not match the ABNF rules, they do so only for certain aspects of the frame (e.g. padding and identifier) and do not encompass all grammar-related rules. As a result, the function partially matches the RFC specification in isolation.",success,
3992,ngx_http_v2_state_read_data,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (stream == NULL) {\n    return ngx_http_v2_state_skip_padded(h2c, pos, end);\n}\n\nif (r->headers_in.content_length_n < 0 && !r->headers_in.chunked) {\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0,\n                   ""skipping http2 DATA frame"");\n\n    return ngx_http_v2_state_skip_padded(h2c, pos, end);\n}', 'explanation': 'This segment implements a defensive check by verifying that the stream pointer is valid and that the headers reflect a valid content length or chunked transfer; if not, it elects to skip further processing of the DATA frame.'}}, {'A1': {'code': 'if (size > (size_t) (buf->end - buf->last)) {\n    ngx_log_error(NGX_LOG_ALERT, h2c->connection->log, 0,\n                  ""http2 preread buffer overflow"");\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);\n}', 'explanation': 'This segment explicitly checks that the incoming data does not exceed the allocated buffer space, thereby implementing a defensive measure to avoid buffer overflow.'}}]","The function contains several defensive programming constructs (such as checking for a null stream, validating content length, and ensuring that data does not overflow a buffer) which address some aspects of the RFC specification's requirement to ""parse a received protocol element defensively"". However, while it handles reasonable length expectations and basic validation, it does not implement comprehensive parsing against the ABNF grammar. Moreover, some actions (like detailed grammar validation) might be delegated to other functions. Therefore, the code function only partially meets the overall defensive parsing requirements as specified in the RFC.",success,
3994,ngx_http_v2_state_headers,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (h2c->state.length < size) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent HEADERS frame with incorrect length %uz"",\n                  h2c->state.length);\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This segment shows a defensive check on the frame length by ensuring that the available length is not less than the expected header fields (e.g. padded or priority specific fields), which aligns with the requirement to parse protocol elements defensively.'}}, {'A1': {'code': 'if (padded) {\n    h2c->state.padding = *pos++;\n\n    if (h2c->state.padding > h2c->state.length) {\n        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                      ""client sent padded HEADERS frame ""\n                      ""with incorrect length: %uz, padding: %uz"",\n                      h2c->state.length, h2c->state.padding);\n\n        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n    }\n\n    h2c->state.length -= h2c->state.padding;\n}', 'explanation': 'This code displays a defensive measure by verifying that the padding amount specified does not exceed the remaining frame length. It checks the validity of the padded data, which is in line with the defensive parsing philosophy.'}}]","The function implements several defensive checks that partially address the RFC's requirement for a recipient to parse a received protocol element defensively. It ensures that the header frame meets minimal length requirements and carefully validates padding when specified. However, while it does include these defensive mechanisms, not every aspect of the spec (such as comprehensive validation against an ABNF grammar or more elaborate buffer size considerations) is handled solely within this function. Hence, the implementation only partially matches the spec constraints.",success,
3994,ngx_http_v2_state_headers,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (h2c->state.length < size) {\n    ngx_log_error(..., ""client sent HEADERS frame with incorrect length %uz"", h2c->state.length);\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}\n\nif (h2c->state.length == size) {\n    ngx_log_error(..., ""client sent HEADERS frame with empty header block"");\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}\n\n... (further validation of stream id and dependency)\nif (h2c->state.sid % 2 == 0 || h2c->state.sid <= h2c->last_sid) {\n    ngx_log_error(..., ""client sent HEADERS frame with incorrect identifier %ui, the last was %ui"", h2c->state.sid, h2c->last_sid);\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}\n\nif (depend == h2c->state.sid) {\n    ngx_log_error(..., ""client sent HEADERS frame for stream %ui with incorrect dependency"", h2c->state.sid);\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'The function verifies that the received HEADERS frame has sufficient length, is non‐empty, and respects protocol rules (e.g. stream identifier validity and dependency checks), which is central to interpreting a protocol element as required by the RFC.'}}, {'A1': {'code': 'if (padded) {\n    h2c->state.padding = *pos++;\n    if (h2c->state.padding > h2c->state.length) {\n        ngx_log_error(..., ""client sent padded HEADERS frame with incorrect length: %uz, padding: %uz"", h2c->state.length, h2c->state.padding);\n        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n    }\n    h2c->state.length -= h2c->state.padding;\n}', 'explanation': 'This segment handles the optional padding by reading the padding byte and ensuring that the declared padding does not exceed the remaining frame length, fulfilling a specific error-handling action mandated by the protocol.'}}]","The function attempts to implement key aspects of the RFC requirement that a recipient must parse and interpret received protocol elements. It includes validations for frame length (including handling of padded frames), stream identifier correctness, and dependency processing. When errors are detected (for example, an incorrect length or invalid dependency), it responds with the proper error code. However, while these checks demonstrate that some conditions (such as proper interpretation and error signaling) are being addressed, not every possible extension or implementation nuance of the entire RFC specification is handled entirely within this function. Therefore, only a subset of the spec constraints is met in this isolated code, leading to a 'Partially Matches' outcome.",success,
3996,ngx_http_v2_state_header_block,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'if (end - pos < 1) {\n    return ngx_http_v2_state_headers_save(h2c, pos, end,\n                                              ngx_http_v2_state_header_block);\n}\n\n...\n\nif (value < 0) {\n    if (value == NGX_AGAIN) {\n        return ngx_http_v2_state_headers_save(h2c, pos, end,\n                                               ngx_http_v2_state_header_block);\n    }\n    ...\n}\n', 'explanation': 'According to the RFC, unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct. In this function, when there is not enough data (end - pos < 1) or when the parsing returns NGX_AGAIN, the function saves state to allow for further processing/recovery. This demonstrates the recovery attempt for incomplete or possibly invalid header blocks.'}}]","The function implements recovery mechanisms in several parts of its logic by saving state when headers are incomplete or when an expected integer value cannot be fully parsed (indicated by NGX_AGAIN). These code segments reflect the specification's guideline that a recipient MAY attempt to recover from an invalid construct. However, the function does not cover all potential error handling or recovery scenarios outlined in the broader HTTP RFC context, and some error paths directly result in connection errors rather than recovery. Therefore, the function only partially matches the conditions and actions stipulated in the RFC specification.",success,
3996,ngx_http_v2_state_header_block,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC requirement states that a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. This function, however, is handling the parsing and validation of header blocks received from a client (or from the communication stream) by checking for correct value lengths, proper flag settings, and logging protocol errors. It is not involved in the generation of protocol elements. Therefore, while it performs error detection and validation, it does not attempt to implement the sender-side constraint specified in the RFC.",success,
3996,ngx_http_v2_state_header_block,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (end - pos < 1) {\n    return ngx_http_v2_state_headers_save(h2c, pos, end, ngx_http_v2_state_header_block);\n}\n\nif (!(h2c->state.flags & NGX_HTTP_V2_END_HEADERS_FLAG)\n    && h2c->state.length < NGX_HTTP_V2_INT_OCTETS)\n{\n    return ngx_http_v2_handle_continuation(h2c, pos, end, ngx_http_v2_state_header_block);\n}\n\nch = *pos;\n\nif (ch >= (1 << 7)) {\n    /* indexed header field */\n    indexed = 1;\n    prefix = ngx_http_v2_prefix(7);\n\n} else if (ch >= (1 << 6)) {\n    /* literal header field with incremental indexing */\n    h2c->state.index = 1;\n    prefix = ngx_http_v2_prefix(6);\n\n} else if (ch >= (1 << 5)) {\n    /* dynamic table size update */\n    size_update = 1;\n    prefix = ngx_http_v2_prefix(5);\n\n} else if (ch >= (1 << 4)) {\n    /* literal header field never indexed */\n    prefix = ngx_http_v2_prefix(4);\n\n} else {\n    /* literal header field without indexing */\n    prefix = ngx_http_v2_prefix(4);\n}\n\nvalue = ngx_http_v2_parse_int(h2c, &pos, end, prefix);', 'explanation': 'This segment shows that the function examines the received header block (the protocol element) and chooses how to decode it (indexed, literal with/without indexing, or dynamic table size update) based on the semantics defined in the protocol. This reflects the requirement to interpret the protocol element according to the specification.'}}, {'A1': {'code': 'if (value < 0) {\n    if (value == NGX_AGAIN) {\n        return ngx_http_v2_state_headers_save(h2c, pos, end, ngx_http_v2_state_header_block);\n    }\n\n    if (value == NGX_DECLINED) {\n        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                      ""client sent header block with too long %s value"",\n                      size_update ? ""size update"" : ""header index"");\n\n        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_COMP_ERROR);\n    }\n\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent header block with incorrect length"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This code handles cases when the parsed integer (integral part of the header block) is invalid. It attempts to either defer processing (in case of incomplete input) or rejects the header block with an appropriate error if it is determined that the sender has not correctly followed the protocol. This addresses the RFC requirement that, when faced with an invalid construct, the recipient MAY attempt to recover or otherwise react according to the defined semantics.'}}]","The function 'ngx_http_v2_state_header_block' shows logic for interpreting the received header block by checking available data, deciding on the type of header representation, and invoking appropriate parsing and recovery routines based solely on its internal logic. It handles conditions of insufficient data by saving state, decodes the header block based on bit patterns, and checks for parsing errors to either attempt recovery or return a connection error. However, while it addresses key aspects of interpreting protocol semantics and recovering from certain errors (as required by the RFC), the implementation only partially covers the overall requirements—especially regarding the broader spectrum of extensions and additional configuration‐based error handling referenced in the spec context. Thus, the function partially matches the provided HTTP RFC specification.",success,
3996,ngx_http_v2_state_header_block,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (end - pos < 1) {\n    return ngx_http_v2_state_headers_save(h2c, pos, end,\n                                              ngx_http_v2_state_header_block);\n}', 'explanation': 'This check verifies that the input buffer has at least one byte available before proceeding, demonstrating a defensive approach to parsing based on the assumption that the input may not fully conform to expectations.'}}, {'A1': {'code': 'if (!(h2c->state.flags & NGX_HTTP_V2_END_HEADERS_FLAG)\n    && h2c->state.length < NGX_HTTP_V2_INT_OCTETS)\n{\n    return ngx_http_v2_handle_continuation(h2c, pos, end,\n                                               ngx_http_v2_state_header_block);\n}', 'explanation': 'This segment handles the possibility of an incomplete header block by invoking a continuation routine when there are insufficient bytes to complete the integer decoding. It demonstrates an attempt to process the header block defensively.'}}]","The function exhibits defensive parsing measures by checking available buffer length and handling continuation for incomplete data. These steps align with the RFC's recommendation to parse received protocol elements defensively. However, while the code does incorporate some checks to mitigate malformed or incomplete input, it does not fully implement all aspects suggested by the RFC—such as comprehensively validating conformance to the ABNF grammar or dynamically scaling buffer expectations. Thus, considering only the logic within this function, it only partially meets the spec constraints.",success,
3997,ngx_http_v2_state_field_len,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (h2c->state.length < 1) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent header block with incorrect length"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}\n\nlen = ngx_http_v2_parse_int(h2c, &pos, end, ngx_http_v2_prefix(7));\n\nif (len < 0) {\n    if (len == NGX_AGAIN) {\n        return ngx_http_v2_state_headers_save(h2c, pos, end,\n                                              ngx_http_v2_state_field_len);\n    }\n\n    if (len == NGX_DECLINED) {\n        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                    ""client sent header field with too long length value"");\n\n        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_COMP_ERROR);\n    }\n\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent header block with incorrect length"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This segment directly interprets the received header block length from the protocol element and validates it against expected constraints, implementing the requirement to interpret the protocol element per the specification.'}}, {'A1': {'code': 'if (end - pos < 1) {\n    return ngx_http_v2_state_headers_save(h2c, pos, end,\n                                              ngx_http_v2_state_field_len);\n}\n\nif (len == NGX_AGAIN) {\n    return ngx_http_v2_state_headers_save(h2c, pos, end,\n                                          ngx_http_v2_state_field_len);\n}', 'explanation': ""These code paths attempt recovery by saving the current state when insufficient data is available or when the integer parsing indicates that further data is needed. This reflects the spec's allowance for attempting to recover a usable protocol element even if it is invalid or incomplete.""}}]","The function shows visible attempts to implement parts of the HTTP/2 header processing as dictated by the RFC. It validates the header field length, interprets protocol elements, and includes recovery logic for incomplete or invalid constructs. However, while it addresses key aspects (interpreting protocol elements as required by C1 and attempting recovery as described by A1), it does not cover every possible condition or action implied in the full spec. Hence, the function only partially matches the RFC constraints when judged in isolation.",success,
3997,ngx_http_v2_state_field_len,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (h2c->state.length < 1) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent header block with incorrect length"");\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}\n\nif (end - pos < 1) {\n    return ngx_http_v2_state_headers_save(h2c, pos, end,\n                                          ngx_http_v2_state_field_len);\n}', 'explanation': 'The code checks that the remaining header block ‘length’ and available buffer bytes are sufficient. This defensive validation ensures the parser does not assume perfect conformance with the ABNF grammar and that the data fits in a reasonable buffer.'}}, {'A1': {'code': 'if ((size_t) len > cscf->large_client_header_buffers.size) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent too large header field"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_ENHANCE_YOUR_CALM);\n}', 'explanation': 'This segment compares the parsed header field length with a locally configured maximum buffer size. This serves to enforce a reasonable limit on the protocol element size, in line with the defensive parsing directive of the spec.'}}]","The function implements defensive parsing by checking the validity of the header block length and ensuring that the data available in the buffer meets a minimum requirement before proceeding. It also validates that the header field length does not exceed a server-configured maximum, thus guarding against excessively large protocol elements. These measures align with the RFC specification's recommendation to parse protocol elements defensively with only marginal assumptions about their conformance and size.",success,
3999,ngx_http_v2_state_field_huff,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'size = end - pos;\n\nif (size > h2c->state.field_rest) {\n    size = h2c->state.field_rest;\n}\n\nif (size > h2c->state.length) {\n    size = h2c->state.length;\n}', 'explanation': 'This segment defensively calculates the available data length and limits it to the remaining field length and total expected length. This check helps ensure that the parser does not exceed predefined buffers when processing the protocol element.'}}, {'A1': {'code': 'if (ngx_http_huff_decode(&h2c->state.field_state, pos, size,\n                         &h2c->state.field_end,\n                         h2c->state.field_rest == 0,\n                         h2c->connection->log)\n        != NGX_OK)\n{\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent invalid encoded header field"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_COMP_ERROR);\n}', 'explanation': 'Here the function invokes a Huffman decode and immediately handles a failure by logging the error and returning a specific connection error. This demonstrates a defensive approach in parsing the header field as required.'}}]","The function implements several defensive checks in processing a received protocol element by limiting the input size and handling decode errors appropriately. However, while these mechanisms address aspects of defensive parsing as suggested by the spec (e.g., ensuring data does not overflow the provided buffers and error handling when data does not meet expected encoding), the code does not fully cover all potential concerns mentioned in the spec context (such as comprehensive ABNF parsing or verifying lengths against universally defined limits). As a result, the function partially matches the intent of the spec constraints.",success,
3999,ngx_http_v2_state_field_huff,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': ""if (h2c->state.field_rest == 0) {\n    *h2c->state.field_end = '\\0';\n    return ngx_http_v2_state_process_header(h2c, pos, end);\n}"", 'explanation': 'This section detects the completion of the header field (i.e. when no more encoded data remains) and attempts to recover the usable header element by null‐terminating it and passing it to the header processing routine. It is an instance of attempting to recover a protocol element despite potential irregularities.'}}, {'A1': {'code': 'if (ngx_http_huff_decode(&h2c->state.field_state, pos, size,\n                             &h2c->state.field_end,\n                             h2c->state.field_rest == 0,\n                             h2c->connection->log) != NGX_OK)\n{\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent invalid encoded header field"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_COMP_ERROR);\n}', 'explanation': 'This block detects an invalid encoding (an invalid construct) and logs an error before returning an error state, thus addressing the relevant RFC stance on error handling while leaving the decision for recovery to the application.'}}]","The function demonstrates visible logic that addresses parts of the RFC specification regarding error recovery and processing of header fields. It checks for field size constraints, processes header field data by saving state for incomplete headers, null‐terminates once the field is complete, and logs errors if the Huffman decoding fails. However, while these sections indicate an attempt to implement recovery (and handle error cases), not all aspects of RFC error recovery are fully implemented within this function alone – some error handling or recovery continuation is delegated to other functions (such as continuation handling). Thus, the function only partially meets the overall RFC requirements in isolation.",success,
3999,ngx_http_v2_state_field_huff,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (ngx_http_huff_decode(&h2c->state.field_state, pos, size,\n                             &h2c->state.field_end,\n                             h2c->state.field_rest == 0,\n                             h2c->connection->log)\n        != NGX_OK)\n    {\n        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                      ""client sent invalid encoded header field"");\n        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_COMP_ERROR);\n    }', 'explanation': 'This segment shows that the function attempts to interpret the received protocol element by decoding a Huffman‐encoded header field. It validates the decoded output and handles the error by logging and returning a connection error if the decoding fails, in line with the requirement to process the element according to its defined semantics.'}}, {'A1': {'code': 'if (h2c->state.field_rest == 0) {\n        *h2c->state.field_end = \'\\0\';\n        return ngx_http_v2_state_process_header(h2c, pos, end);\n    }\n\n    if (h2c->state.length) {\n        return ngx_http_v2_state_headers_save(h2c, pos, end,\n                                              ngx_http_v2_state_field_huff);\n    }\n\n    if (h2c->state.flags & NGX_HTTP_V2_END_HEADERS_FLAG) {\n        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                      ""client sent header field with incorrect length"");\n        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n    }\n\n    return ngx_http_v2_handle_continuation(h2c, pos, end,\n                                           ngx_http_v2_state_field_huff);', 'explanation': 'This code handles cases where the header field might span multiple frames or be incomplete, attempting to recover a usable protocol element. It continues header processing by either saving the incomplete header state or handling continuation frames, which is in the spirit of recovering protocol elements as allowed by the HTTP RFC.'}}]","The function focuses on decoding a Huffman‐encoded header field and managing associated state and error conditions. By doing so, it addresses aspects of the RFC that require the recipient to interpret received protocol elements and attempt recovery in the face of errors or incomplete constructs. However, because it deals only with a specific aspect (Huffman decoding and immediate error handling) and delegates broader error recovery and additional header processing to other parts of the system, the function only partially matches the full intent of the RFC specification.",success,
4001,ngx_http_v2_state_field_raw,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'size = end - pos;\n\n    if (size > h2c->state.field_rest) {\n        size = h2c->state.field_rest;\n    }\n\n    if (size > h2c->state.length) {\n        size = h2c->state.length;\n    }', 'explanation': 'This segment implements defensive parsing by comparing the size of the available input with the expected remaining field size and total allowed length, ensuring that the function does not read beyond the provided boundaries. It addresses the spirit of defensive parsing required by the RFC, though aspects like detailed ABNF validation or dynamically enforcing reasonable buffer sizes are not explicitly handled in this function.'}}]","The function demonstrates defensive parsing by carefully limiting the number of bytes it processes based on internal state (field_rest and length). This approach aligns with the RFC's recommendation that elements may only marginally be expected to adhere to a particular grammar and buffer size. However, since the function does not cover thorough grammar checks or a more flexible interpretation of what is 'reasonable' in different contexts, it only partially meets the specified constraint.",success,
4001,ngx_http_v2_state_field_raw,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': ""if (h2c->state.field_rest == 0) {\n    *h2c->state.field_end = '\\0';\n    return ngx_http_v2_state_process_header(h2c, pos, end);\n}"", 'explanation': 'This branch indicates that when all expected header field data has been received, the code finalizes the field (by appending a null terminator) and calls a header-processing routine. This reflects an attempt to interpret the received protocol element according to the RFC’s semantics.'}}, {'A1': {'code': 'if (h2c->state.flags & NGX_HTTP_V2_END_HEADERS_FLAG) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent header field with incorrect length"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This block demonstrates error handling for a scenario where the header field length appears incorrect. It reflects the requirement that the recipient must determine (through its checking logic) if the sender has not adhered to the implied semantics, thereby enforcing the RFC’s mandate.'}}]","The function reads raw header field data and makes decisions based on the remaining expected length and overall header length. It finalizes the header data when complete and delegates further processing, while also implementing an error branch to handle cases where the header field length does not fit expectations. Although these parts indicate an attempt to interpret protocol elements per the RFC, many aspects of full semantic interpretation likely reside in the callee functions (such as ngx_http_v2_state_process_header) or elsewhere. Thus, this function in isolation only partially meets the overall constraints outlined in the spec.",success,
4003,ngx_http_v2_state_field_skip,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'A1': {'code': 'if (h2c->state.field_rest == 0) {\n    return ngx_http_v2_state_process_header(h2c, pos, end);\n}\n\nif (h2c->state.length) {\n    return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_field_skip);\n}\n\nif (h2c->state.flags & NGX_HTTP_V2_END_HEADERS_FLAG) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent header field with incorrect length"");\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}\n\nreturn ngx_http_v2_handle_continuation(h2c, pos, end, ngx_http_v2_state_field_skip);', 'explanation': ""This function adjusts the current state of header processing by consuming the available field bytes and then, depending on the remaining length, either processes the header if complete, saves the state for later recovery, or handles the continuation of the header field. These mechanisms are an attempt to recover a usable protocol element from an invalid construct, which aligns with the RFC's allowance (MAY attempt recovery).""}}]","The RFC specifies that a recipient MAY attempt to recover a usable protocol element even from an invalid construct. The code function implements several recovery mechanisms: it computes the amount of data to skip, tries to process the header if all field bytes have been consumed, saves the current state if more data is expected, and handles continuations or error conditions when necessary. However, while the function visibly implements these recovery tactics (action A1), it does not address all potential error handling or protocol interpretation issues solely within its own logic. Hence, it partially matches the RFC constraints by providing in-function recovery mechanisms, though some aspects of correct protocol interpretation may be handled elsewhere.",success,
4003,ngx_http_v2_state_field_skip,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'size = end - pos;\n\nif (size > h2c->state.field_rest) {\n    size = h2c->state.field_rest;\n}\n\nif (size > h2c->state.length) {\n    size = h2c->state.length;\n}', 'explanation': 'This part of the code defensively limits the amount of data processed by ensuring that the size does not exceed the accumulated field remainder or the overall frame length. It reflects an attempt to satisfy the requirement of parsing protocol elements defensively and handling reasonable buffer sizes.'}}]","The function includes checks that prevent overruns of the buffer by comparing the available size with state-tracking variables (field_rest and length). These measures align with one aspect of the RFC requirement to parse protocol elements defensively. However, the function does not encompass all aspects of the specification—such as detailed handling of ABNF grammar conformance—directly in its logic. Therefore, while it visibly addresses defensive parsing for buffer length, it only partially implements the full intent of the RFC spec constraints.",success,
4003,ngx_http_v2_state_field_skip,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'size = end - pos;\n\nif (size > h2c->state.field_rest) {\n    size = h2c->state.field_rest;\n}\n\nif (size > h2c->state.length) {\n    size = h2c->state.length;\n}\n\nh2c->state.length -= size;\nh2c->state.field_rest -= size;\n\npos += size;\n\nif (h2c->state.field_rest == 0) {\n    return ngx_http_v2_state_process_header(h2c, pos, end);\n}', 'explanation': 'This segment shows the function interpreting the received header field data (a protocol element) by tracking and deducting lengths and then processing the header when fully received, in line with the RFC mandate to interpret protocol elements according to its semantics.'}}, {'A1': {'code': 'if (h2c->state.length) {\n    return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_field_skip);\n}\n\nif (h2c->state.flags & NGX_HTTP_V2_END_HEADERS_FLAG) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent header field with incorrect length"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}\n\nreturn ngx_http_v2_handle_continuation(h2c, pos, end, ngx_http_v2_state_field_skip);', 'explanation': 'This code attempts recovery from an incomplete or malformed header field by saving state or handling continuation, and in one branch logging an error and returning a connection error if the header length is determined to be incorrect. This reflects the RFC’s allowance for recovering from an invalid construct.'}}]","The function contains visible logic for processing a protocol header field element by tracking the amount of data remaining and handling it accordingly. It calls a dedicated processing function when the header field is complete, and it also implements handling for incomplete data via state saving and continuation. Additionally, it performs error logging and returns a connection error if a header field’s length is detected as incorrect. Although these behaviors address key parts of the RFC requirement to interpret and, where possible, recover from invalid constructs, the implementation does not cover all possible facets (for example, detailed checking of sender behavior is likely handled elsewhere), and so it only partially matches the RFC’s constraints.",success,
4005,ngx_http_v2_state_process_header,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (header->name.len == 0) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent zero header name length"");\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'This segment defensively checks that the header name is non-empty, aligning with the expectation to not assume that incoming protocol elements adhere to the ABNF grammar.'}}, {'A1': {'code': 'if (len > h2c->state.header_limit) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent too large header"");\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_ENHANCE_YOUR_CALM);\n}\n\nh2c->state.header_limit -= len;', 'explanation': 'This code verifies that the combined length of the header name and value does not exceed a predefined limit, thus performing a defensive check against overly large protocol elements.'}}]","The function implements partial defensive parsing as required by the spec. It includes checks for header name length and overall header length against a limit, which addresses the defensive handling of protocol elements. However, while these measures reflect a defensive approach, the function does not cover all aspects of parsing (such as complete ABNF validation), hence it only partially meets the specified constraints.",success,
4007,ngx_http_v2_state_header_complete,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function focuses on handling header state transitions in an HTTP/2 connection (e.g., managing header blocks, continuation frames, and finalization of header processing). There is no visible logic within this function that verifies the sender's role or checks that protocol elements strictly adhere to the allowed set for that role, as demanded by the RFC specification (e.g., ensuring that elements generated by a sender are not those that only participants in other roles may generate). Thus, none of the conditions (C1, etc.) or actions (A1, etc.) related to role-specific protocol element generation are implemented within this function.",success,
4011,ngx_http_v2_state_priority,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (h2c->state.length != NGX_HTTP_V2_PRIORITY_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent PRIORITY frame with incorrect length %uz"",\n                  h2c->state.length);\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This check ensures that the received protocol element exactly matches the expected frame size. It is a defensive validation that rejects frames not conforming to the length specified by the protocol, aligning with the RFC requirement to guard against unexpected frame sizes.'}}, {'A1': {'code': 'if (end - pos < NGX_HTTP_V2_PRIORITY_SIZE) {\n    return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_priority);\n}', 'explanation': 'This segment confirms that the available buffer has sufficient data before continuing parsing. It implements a defensive strategy by pausing processing until the required amount of data is present, which directly meets the specification’s call for handling elements that might not completely fit within a reasonable buffer size.'}}]","The function demonstrates defensive parsing by verifying the length of the received PRIORITY frame and ensuring that the buffer contains sufficient data to parse the expected number of bytes. These checks directly implement the RFC's guidance to defensively handle protocol elements, thereby fully addressing the relevant spec constraints within the function itself.",success,
4011,ngx_http_v2_state_priority,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (h2c->state.length != NGX_HTTP_V2_PRIORITY_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent PRIORITY frame with incorrect length %uz"",\n                  h2c->state.length);\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': ""This block enforces that the received PRIORITY frame has the correct length. It directly checks the frame size and, if it doesn't match the expected NGX_HTTP_V2_PRIORITY_SIZE, logs the error and returns a connection error as specified in the RFC.""}}, {'A1': {'code': 'if (h2c->state.sid == 0) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent PRIORITY frame with incorrect identifier"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'This segment prevents processing a PRIORITY frame when the stream identifier is 0, which is not allowed per HTTP/2 RFC. It implements an action of rejecting and erroring out when a basic protocol invariant is not met.'}}, {'C2': {'code': 'if (depend == h2c->state.sid) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent PRIORITY frame for stream %ui with incorrect dependency"",\n                  h2c->state.sid);\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'This block checks that the PRIORITY frame does not create a cyclic dependency by ensuring that the dependency is not the same as the stream identifier. This is in line with the RFC requirement to interpret protocol elements correctly and detect logical errors.'}}, {'A2': {'code': 'if (--h2c->priority_limit == 0) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent too many PRIORITY frames"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_ENHANCE_YOUR_CALM);\n}', 'explanation': 'This code enforces a limit on the number of PRIORITY frames that can be processed, returning an error if the limit is exceeded. It is an action taken based on operational limits which, while not explicitly mandated by the RFC text provided, interprets the protocol element in a defensive manner.'}}]","The function attempts to implement aspects of the HTTP/2 RFC regarding the handling of PRIORITY frames by validating frame length, checking for invalid stream identifiers, validating dependencies, and enforcing operational limits. These checks serve to interpret the received protocol element according to the defined semantics. However, other aspects of the RFC—such as comprehensive error recovery strategies—are not fully addressed within this single function. Therefore, while the function visibly implements several key conditions and actions (labeled here as C1, C2, A1, and A2), it does not cover every possible semantic extension described in the full specification, resulting in a partial match.",success,
4011,ngx_http_v2_state_priority,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (h2c->state.length != NGX_HTTP_V2_PRIORITY_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent PRIORITY frame with incorrect length %uz"",\n                  h2c->state.length);\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This check enforces that the PRIORITY frame has the exact length as defined by the ABNF (NGX_HTTP_V2_PRIORITY_SIZE). In this way it validates that the incoming frame conforms to the expected grammar.'}}, {'A1': {'code': 'if (h2c->state.sid == 0) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent PRIORITY frame with incorrect identifier"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}\n\nif (depend == h2c->state.sid) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent PRIORITY frame for stream %ui with incorrect dependency"", h2c->state.sid);\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'These validations check that the stream identifier is valid and that the dependency does not refer to the same stream, which are part of enforcing the correct syntax as per the ABNF grammar. They ensure that invalid or misconfigured frames are not further processed.'}}]","The RFC requires that a sender must not generate protocol elements that do not match the grammar defined by ABNF rules. Although this function is on the receiver side (processing a PRIORITY frame sent by a client) rather than generating frames, it does implement checks that verify certain grammatical properties (such as frame length, valid stream identifier, and proper dependency relations). Thus, within its scope it partially addresses the specification. However, since the requirement specifically targets generation (and no code here is responsible for generating protocol elements), the function only partially matches the intended RFC requirement.",success,
4012,ngx_http_v2_state_rst_stream,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (h2c->state.length != NGX_HTTP_V2_RST_STREAM_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent RST_STREAM frame with incorrect length %uz"",\n                  h2c->state.length);\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This block validates that the frame length strictly matches the expected size as defined by the ABNF rules. It enforces the grammar for the RST_STREAM frame by rejecting frames with an incorrect length.'}}, {'C2': {'code': 'if (h2c->state.sid == 0) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent RST_STREAM frame with incorrect identifier"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'This segment checks that the stream identifier is non-zero, enforcing the constraint that protocol elements (here, the stream id) must conform to the ABNF grammar which does not allow a zero stream id in this context.'}}]","The function implements checks for key components of the ABNF grammar for the RST_STREAM frame by verifying the frame length and stream identifier. These validations are directly in line with the specification that 'a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.' While the function inspects these specific aspects, it does not necessarily cover all potential grammar rules elsewhere in the protocol, hence the partial match.",success,
4012,ngx_http_v2_state_rst_stream,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (h2c->state.length != NGX_HTTP_V2_RST_STREAM_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent RST_STREAM frame with incorrect length %uz"",\n                  h2c->state.length);\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This code segment validates that the frame has the exact required length. By rejecting frames with an unexpected length, it prevents clients from sending malformed protocol elements.'}}, {'C2': {'code': 'if (h2c->state.sid == 0) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent RST_STREAM frame with incorrect identifier"");\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'This segment ensures that a stream frame is not sent with a stream identifier of 0, enforcing that only permitted roles generate certain protocol elements. This validation helps prevent a client from sending a frame that ought to be reserved (or generated) for a different role.'}}]","The function implements key checks by validating that the RST_STREAM frame has the proper length and a non-zero stream identifier. These validations correspond to parts of the RFC requirement that the sender must not generate protocol elements or syntax alternatives that are only allowed for other roles. However, while these checks address important aspects of the protocol constraints, they cover only part of the overall requirements. Other aspects of the RFC are either handled elsewhere or not explicitly checked in this function, leading to a 'Partially Matches' judgment.",success,
4013,ngx_http_v2_state_settings,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (h2c->state.sid) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent SETTINGS frame with incorrect identifier"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'This block checks that the SETTINGS frame does not include an identifier (sid) when it is not allowed. It enforces the frame format (i.e. the ABNF grammar) by rejecting frames that include disallowed elements.'}}, {'A1': {'code': 'if (h2c->state.flags == NGX_HTTP_V2_ACK_FLAG) {\n\n    if (h2c->state.length != 0) {\n        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                      ""client sent SETTINGS frame with the ACK flag ""\n                      ""and nonzero length"");\n\n        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n    }\n\n    h2c->settings_ack = 1;\n\n    return ngx_http_v2_state_complete(h2c, pos, end);\n}', 'explanation': 'This segment validates the use of the ACK flag. It ensures that when the ACK flag is set, the SETTINGS frame has a length of zero; otherwise, it is rejected. This is a measure to guarantee that the generated protocol element adheres to the grammar rules.'}}, {'A2': {'code': 'if (h2c->state.length % NGX_HTTP_V2_SETTINGS_PARAM_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent SETTINGS frame with incorrect length %uz"",\n                  h2c->state.length);\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This check ensures that the SETTINGS frame length is a multiple of the expected parameter size, thereby verifying that the frame complies with the structure defined in the grammar.'}}]","The function implements several validations that ensure incoming SETTINGS frames conform to expected message structure rules. Specifically, it checks for disallowed identifiers, improper use of the ACK flag, and incorrect frame lengths. While these validations enforce key aspects of the ABNF-defined grammar, the function does not encompass all potential grammar validations for protocol element generation. As such, the function partially matches the RFC requirement that a sender must not generate protocol elements that do not match the ABNF grammar.",success,
4013,ngx_http_v2_state_settings,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (h2c->state.sid) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent SETTINGS frame with incorrect identifier"");\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'This segment checks that the SETTINGS frame arrives on stream 0, as required by the RFC specification. Interpreting a nonzero stream identifier as an error corresponds to the requirement to follow the defined semantics.'}}, {'A1': {'code': 'if (h2c->state.flags == NGX_HTTP_V2_ACK_FLAG) {\n    if (h2c->state.length != 0) {\n        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                      ""client sent SETTINGS frame with the ACK flag and nonzero length"");\n        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n    }\n    h2c->settings_ack = 1;\n    return ngx_http_v2_state_complete(h2c, pos, end);\n}', 'explanation': 'This block implements the action required for handling ACK SETTINGS frames by ensuring that when the ACK flag is set, the frame length is zero. If not, an error is generated. This confirms compliance with the protocol semantics as per the RFC.'}}]","The function enforces several critical aspects of the HTTP/2 SETTINGS frame as specified in the RFC. It checks that SETTINGS frames are received with stream identifier zero (C1) and properly handles SETTINGS frames when the ACK flag is present by verifying that the frame's length is zero (A1). However, while these checks address key conditions, the function does not encapsulate the entire spectrum of interpretation and recovery mandates outlined in the specification. Therefore, within its isolated scope, the function partially matches the constraints by directly addressing some, but not all, elements required by the RFC.",success,
4013,ngx_http_v2_state_settings,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (h2c->state.sid) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent SETTINGS frame with incorrect identifier"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': ""This check defensively validates that the SETTINGS frame does not have an unexpected stream identifier, aligning with the requirement to not assume full compliance with the protocol element's format.""}}, {'C2': {'code': 'if (h2c->state.flags == NGX_HTTP_V2_ACK_FLAG) {\n\n    if (h2c->state.length != 0) {\n        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                      ""client sent SETTINGS frame with the ACK flag ""\n                      ""and nonzero length"");\n\n        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n    }\n\n    h2c->settings_ack = 1;\n\n    return ngx_http_v2_state_complete(h2c, pos, end);\n}', 'explanation': ""This code ensures that when the ACK flag is present, the length of the SETTINGS frame is exactly zero. It demonstrates a defensive check for an unexpected frame format, thus partially addressing the RFC's expectation of handling elements that may not fully conform to expected structure.""}}, {'C3': {'code': 'if (h2c->state.length % NGX_HTTP_V2_SETTINGS_PARAM_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent SETTINGS frame with incorrect length %uz"",\n                  h2c->state.length);\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': ""This check confirms that the received SETTINGS frame's length is a multiple of the expected parameter size, thereby catching framing errors. This defensive measure directly correlates with the need to handle nonconformant protocol elements.""}}]","The function implements several defensive parsing checks in line with the HTTP RFC’s recommendation to not assume full conformance of protocol elements. It validates critical aspects of the SETTINGS frame (e.g., valid stream identifier, proper length when ACK is set, and correct length multiples), and logs errors with appropriate error responses. However, while these checks guard against obvious framing errors, the function does not itself verify the complete ABNF grammar or assess whether data fits within a 'reasonable buffer size'—these aspects might be handled elsewhere. Thus, the function partially meets the RFC's defensive parsing requirements.",success,
4013,ngx_http_v2_state_settings,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Fully Matches,"[{'C1': {'code': 'if (h2c->state.sid) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent SETTINGS frame with incorrect identifier"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'This segment verifies that the SETTINGS frame is only sent on the correct stream (stream 0), ensuring that the client does not generate protocol elements (i.e. SETTINGS frames with nonzero identifiers) that are meant to be generated by participants in the proper role. This directly implements the spec requirement regarding role-specific protocol element generation.'}}, {'A1': {'code': 'if (h2c->state.flags == NGX_HTTP_V2_ACK_FLAG) {\n\n    if (h2c->state.length != 0) {\n        ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                      ""client sent SETTINGS frame with the ACK flag ""\n                      ""and nonzero length"");\n\n        return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n    }\n\n    h2c->settings_ack = 1;\n\n    return ngx_http_v2_state_complete(h2c, pos, end);\n}', 'explanation': 'This block ensures that when an ACK flag is present in the SETTINGS frame, the frame’s length is zero, which is a requirement of the HTTP/2 SETTINGS frame grammar. This safeguards the protocol from receiving invalid syntax elements.'}}]","The function 'ngx_http_v2_state_settings' implements key checks to ensure compliance with the HTTP RFC requirements for message generation. It prevents a client from sending SETTINGS frames on a non-zero stream (thereby enforcing role restrictions) and validates that a SETTINGS frame with the ACK flag has a zero length, conforming to the required grammar. These implementations cover the labeled constraints (C1 for role-based protocol element validation and A1 for correct usage of the ACK flag), and therefore, the function fully matches the specified constraints.",success,
4015,ngx_http_v2_state_push_promise,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Fully Matches,"[{'C1': {'code': 'ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent PUSH_PROMISE frame"");', 'explanation': 'This log call explicitly detects that the client, which is not permitted to generate PUSH_PROMISE frames, has sent one, thereby addressing the requirement that a sender must not generate protocol elements reserved for other roles.'}}, {'A1': {'code': 'return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);', 'explanation': 'This return statement generates a connection error in response to the protocol violation, enforcing the action to treat such forbidden behavior as a protocol error.'}}]","The function is designed to handle the case when a client sends a PUSH_PROMISE frame—an element that should only be generated by servers. It visibly addresses the RFC's stipulation that a sender must not generate protocol elements reserved for other roles by logging the violation (C1) and then returning a protocol error (A1). Since the check and error handling occur entirely within this function, it fully meets the applicable constraints specified in the RFC.",success,
4015,ngx_http_v2_state_push_promise,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n              ""client sent PUSH_PROMISE frame"");', 'explanation': 'This log line indicates that a PUSH_PROMISE frame – which a client should not generate according to the spec – was received. It marks the recognition of an invalid protocol element according to role expectations.'}}, {'A1': {'code': 'return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);', 'explanation': 'By returning a protocol error, the function actively rejects the invalid (client‐generated) PUSH_PROMISE frame, enforcing that such elements must not be produced.'}}]","The function, when invoked, logs the presence of a PUSH_PROMISE frame coming from the client and immediately returns a protocol error. This behavior addresses the RFC's requirement that a sender must not generate protocol elements that are not allowed (i.e. elements that fall outside the permitted ABNF grammar for that sender’s role). However, the function does not perform any explicit grammar validation against ABNF rules within its own logic; it simply flags the receipt of a prohibited frame type. Thus, while it does implement a reactive enforcement (rejecting the invalid element), the overall implementation only partially meets the spec constraint when considered in isolation from its dependencies.",success,
4016,ngx_http_v2_state_ping,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (h2c->state.length != NGX_HTTP_V2_PING_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent PING frame with incorrect length %uz"",\n                  h2c->state.length);\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This check ensures that the received protocol element (PING frame) conforms to the expected fixed size. It defensively verifies that the element meets its expected length, guarding against malformed input.'}}, {'C2': {'code': 'if (end - pos < NGX_HTTP_V2_PING_SIZE) {\n    return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_ping);\n}', 'explanation': 'This condition confirms there is a sufficient buffer available to fully parse the protocol element. It prevents overruns and incomplete reads, thereby implementing defensive parsing as recommended.'}}]","The function implements defensive parsing by verifying the length of the received protocol element and ensuring an adequate buffer size before proceeding with further processing. These checks directly correspond to the RFC’s advice to be cautious and make only marginal assumptions about the conformance of the received element. All related logic resides within the function itself, meeting the spec constraints.",success,
4016,ngx_http_v2_state_ping,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Fully Matches,"[{'C1': {'code': 'if (h2c->state.length != NGX_HTTP_V2_PING_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent PING frame with incorrect length %uz"",\n                  h2c->state.length);\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This segment verifies that the received PING frame has exactly the expected length (NGX_HTTP_V2_PING_SIZE), in accordance with the RFC requirement that the protocol element (PING frame) must be interpreted based on a fixed, defined payload length.'}}, {'A1': {'code': 'if (h2c->state.sid) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent PING frame with incorrect identifier"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'This part ensures that the stream identifier is zero (as required by the HTTP/2 specification for PING frames), and treats a non-zero identifier as a protocol error. It directly implements the action of enforcing the semantics defined by the spec.'}}, {'A2': {'code': 'if (h2c->state.flags & NGX_HTTP_V2_ACK_FLAG) {\n    return ngx_http_v2_state_skip(h2c, pos, end);\n}\n\nframe = ngx_http_v2_get_frame(h2c, NGX_HTTP_V2_PING_SIZE,\n                              NGX_HTTP_V2_PING_FRAME,\n                              NGX_HTTP_V2_ACK_FLAG, 0);\nif (frame == NULL) {\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);\n}\n\nbuf = frame->first->buf;\n\nbuf->last = ngx_cpymem(buf->last, pos, NGX_HTTP_V2_PING_SIZE);\n\nngx_http_v2_queue_blocked_frame(h2c, frame);\n\nreturn ngx_http_v2_state_complete(h2c, pos + NGX_HTTP_V2_PING_SIZE, end);', 'explanation': 'This sequence handles the case when a valid PING frame is received without the ACK flag: it prepares a response PING (by setting the ACK flag and copying the payload) per the RFC semantics. It also cleanly defers processing if the ACK flag is present (by skipping further handling), which is consistent with the RFC user-agent recovering strategies.'}}]","The function ngx_http_v2_state_ping directly implements the core requirements of processing a PING frame as set forth by the HTTP/2 specification. It enforces the correct frame length (C1), validates that the stream identifier is zero (A1), and appropriately handles both ACK and non-ACK cases by either responding with an ACK frame or skipping further processing (A2). Each of these code segments clearly reflects the semantics and error handling mandated by the RFC for interpreting a received protocol element.",success,
4016,ngx_http_v2_state_ping,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Fully Matches,"[{'C1': {'code': 'if (h2c->state.sid) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent PING frame with incorrect identifier"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'This segment checks that the client does not send a PING frame with a nonzero stream identifier. According to the RFC, a sender must not generate protocol elements (in this case, a PING frame with a stream association) that are only allowed by participants in the proper role. This check ensures the sender is not generating an element (a PING with an associated stream id) that violates its allowed role.'}}, {'A1': {'code': 'frame = ngx_http_v2_get_frame(h2c, NGX_HTTP_V2_PING_SIZE,\n                              NGX_HTTP_V2_PING_FRAME,\n                              NGX_HTTP_V2_ACK_FLAG, 0);\nif (frame == NULL) {\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);\n}\n\nbuf = frame->first->buf;\n\nbuf->last = ngx_cpymem(buf->last, pos, NGX_HTTP_V2_PING_SIZE);\n\nngx_http_v2_queue_blocked_frame(h2c, frame);', 'explanation': 'This code creates and queues a response PING frame with the ACK flag. It implements the action of generating the proper protocol element (PING ACK) that is allowed for the server role. This response generation is consistent with the requirements that a sender (server) correctly reflects its role by generating elements (in this case, the ACK) that are not permitted from the client.'}}]","The function processes an incoming PING frame and implements both error-checking and response generation in line with the RFC specification. It verifies that a client does not send a PING frame with a nonzero stream ID (addressing the constraint that senders must not generate protocol elements reserved for other roles), and when valid, it generates a PING ACK response, thereby conforming to the protocol actions required by the RFC. All logic to handle these constraints is found directly in the function_body, hence it fully meets the specified requirements.",success,
4016,ngx_http_v2_state_ping,"At a minimum, a recipient MUST be able to parse and process protocol element lengths that are at least as long as the values that it generates for those same protocol elements in other messages.",218,Fully Matches,"[{'C1': {'code': 'if (h2c->state.length != NGX_HTTP_V2_PING_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent PING frame with incorrect length %uz"",\n                  h2c->state.length);\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This code segment verifies that the received PING frame has a length equal to NGX_HTTP_V2_PING_SIZE, which is the expected length produced by the implementation. By enforcing this equality, the implementation ensures that the recipient can parse and process protocol elements that are at least as long as those generated, directly addressing the RFC requirement.'}}]","The function ngx_http_v2_state_ping checks that the incoming PING frame has the exact expected length. This directly meets the RFC specification which mandates that a recipient must be capable of parsing protocol elements at least as long as the ones it sends. Since a PING frame is generated with a constant length (NGX_HTTP_V2_PING_SIZE), the function's verification ensures compliance by rejecting frames with incorrect lengths.",success,
4016,ngx_http_v2_state_ping,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'if (h2c->state.length != NGX_HTTP_V2_PING_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent PING frame with incorrect length %uz"",\n                  h2c->state.length);\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': ""This code ensures that the payload length of the received PING frame exactly matches the required size (NGX_HTTP_V2_PING_SIZE) as defined by the protocol's ABNF grammar.""}}, {'C2': {'code': 'if (h2c->state.sid) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent PING frame with incorrect identifier"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'This segment verifies that the stream identifier is zero (as required for PING frames by the ABNF rules) and rejects the message if not, thereby preventing generation of protocol elements with an incorrect identifier.'}}, {'A1': {'code': 'frame = ngx_http_v2_get_frame(h2c, NGX_HTTP_V2_PING_SIZE,\n                                  NGX_HTTP_V2_PING_FRAME,\n                                  NGX_HTTP_V2_ACK_FLAG, 0);\nif (frame == NULL) {\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);\n}\n\nbuf = frame->first->buf;\n\nbuf->last = ngx_cpymem(buf->last, pos, NGX_HTTP_V2_PING_SIZE);\n\nngx_http_v2_queue_blocked_frame(h2c, frame);', 'explanation': 'This code constructs a properly formatted PING ACK frame (by using the ACK flag and correct payload size) and queues it to be sent, ensuring that only protocol messages conforming to the ABNF grammar are generated.'}}]","The function validates incoming PING frames by checking essential grammar rules: it ensures the payload length is exactly the expected size and the stream identifier is zero. Upon receiving a valid non-ACK PING frame, it constructs a corresponding ACK frame with the correct parameters. Each of these steps addresses the requirements stated in the RFC that a sender must only generate protocol elements that conform to the predefined ABNF rules.",success,
4017,ngx_http_v2_state_goaway,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (h2c->state.length < NGX_HTTP_V2_GOAWAY_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent GOAWAY frame with incorrect length %uz"", h2c->state.length);\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This code verifies that the protocol element’s length is at least as large as the minimum expected (NGX_HTTP_V2_GOAWAY_SIZE), ensuring defensive parsing by not assuming correct length.'}}, {'C2': {'code': 'if (end - pos < NGX_HTTP_V2_GOAWAY_SIZE) {\n    return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_goaway);\n}', 'explanation': 'This check ensures that the available buffer contains enough data to parse the expected portion of the protocol element, thereby avoiding assumptions of a well-formed or complete element.'}}]","The function implements defensive parsing of a received GOAWAY frame by validating that the frame has at least the minimum expected size and that the supplied buffer has enough data. Additionally, error logging and early exits (using connection error functions) further show that the function does not assume full conformance to the expected ABNF grammar, which aligns with the RFC specification. Thus, the function’s internal logic addresses all the defensive parsing requirements specified.",success,
4017,ngx_http_v2_state_goaway,"At a minimum, a recipient MUST be able to parse and process protocol element lengths that are at least as long as the values that it generates for those same protocol elements in other messages.",218,Partially Matches,"[{'C1': {'code': 'if (h2c->state.length < NGX_HTTP_V2_GOAWAY_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent GOAWAY frame with incorrect length %uz"", h2c->state.length);\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This code segment checks that the received GOAWAY frame has a length that is not less than the expected minimum (NGX_HTTP_V2_GOAWAY_SIZE). In doing so, it attempts to enforce the RFC requirement that a recipient must be able to parse and process protocol element lengths that are at least as long as the ones it generates. However, the function does not implement any logic for handling cases where the lengths exceed that minimum or dynamically adapting to different expected lengths.'}}]","The function contains a check that rejects GOAWAY frames if their length is smaller than a defined minimum, which aligns with the requirement that recipients handle protocol element lengths at least as long as those they produce. This check is the only visible component addressing the specification. Since no other aspects of the RFC (for example, handling frames with longer-than-expected elements) are implemented within this function, it only partially meets the overall specification.",success,
4017,ngx_http_v2_state_goaway,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (h2c->state.length < NGX_HTTP_V2_GOAWAY_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent GOAWAY frame with incorrect length %uz"", h2c->state.length);\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This segment checks that the received protocol element (GOAWAY frame) meets the minimum length requirement, matching a key aspect of interpreting the element per defined semantics.'}}, {'C2': {'code': 'if (h2c->state.sid) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent GOAWAY frame with incorrect identifier"");\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'This part ensures that the stream identifier is 0, as required by the GOAWAY frame semantics, thereby addressing a necessary validation condition.'}}, {'A1': {'code': 'if (end - pos < NGX_HTTP_V2_GOAWAY_SIZE) {\n    return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_goaway);\n}', 'explanation': 'This code attempts to recover from a situation where the complete frame is not yet available, aligning with the RFC allowance to try to salvage a usable protocol element from an invalid construct.'}}]","The function implements several key checks mandated by the RFC: it validates that the received GOAWAY frame meets the minimum length (C1) and that the frame identifier is correctly set (C2). Additionally, it contains a recovery mechanism (A1) to handle cases when the full frame is not available. However, not all possible semantic checks or extended error handling strategies described in the RFC are implemented within this function alone, hence the overall partial match.",success,
4017,ngx_http_v2_state_goaway,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'if (h2c->state.length < NGX_HTTP_V2_GOAWAY_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent GOAWAY frame ""\n                  ""with incorrect length %uz"", h2c->state.length);\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This segment checks that the length of the GOAWAY frame matches the expected size defined by the HTTP/2 grammar, ensuring that only frames conforming to the expected length are accepted.'}}, {'C2': {'code': 'if (h2c->state.sid) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent GOAWAY frame with incorrect identifier"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': ""This segment verifies that the stream identifier is zero—as required by the GOAWAY frame's specification in HTTP/2—thereby preventing the generation or acceptance of improperly formed protocol elements.""}}]","The function ngx_http_v2_state_goaway implements the RFC requirement by validating the grammatical correctness of a GOAWAY frame. It checks that the frame length is exactly NGX_HTTP_V2_GOAWAY_SIZE (addressing the condition that protocol elements must match the ABNF grammar) and ensures that the stream identifier is zero. These checks ensure that any protocol element originating from the sender (in this case, the client) is compliant with the HTTP/2 ABNF rules, thereby fully addressing the specified RFC constraint within the scope of this function.",success,
4018,ngx_http_v2_state_window_update,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Fully Matches,"[{'C1': {'code': 'if (h2c->state.length != NGX_HTTP_V2_WINDOW_UPDATE_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent WINDOW_UPDATE frame with incorrect length %uz"", h2c->state.length);\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This segment validates that the received WINDOW_UPDATE frame has the exact expected length, which is a fundamental part of interpreting the protocol element correctly as required by the spec.'}}, {'C2': {'code': 'if (window == 0) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent WINDOW_UPDATE frame with incorrect window increment 0"");\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'This code ensures that the window update value is not zero, adhering to the spec rule that a protocol element must carry a valid (non-zero) semantics.'}}, {'A1': {'code': 'if (end - pos < NGX_HTTP_V2_WINDOW_UPDATE_SIZE) {\n    return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_window_update);\n}\n\nwindow = ngx_http_v2_parse_window(pos);\n\npos += NGX_HTTP_V2_WINDOW_UPDATE_SIZE;\n\n...\n\nif (h2c->state.sid) {\n    ...\n    stream->send_window += window;\n    ...\n} else {\n    ...\n    h2c->send_window += window;\n    ...\n}', 'explanation': 'This portion of the function carries out the core action of the protocol element interpretation—updating the stream or connection flow control window based on the frame’s contents. It also handles cases where more data is needed (using state_save) and dispatches events, fulfilling the action required by the spec.'}}]","The function ngx_http_v2_state_window_update demonstrates a comprehensive implementation of the necessary processing for a WINDOW_UPDATE frame as defined in the HTTP protocol specification. It checks that the frame length is exactly as expected (C1), validates that the window increment is non-zero (C2), and then processes the update to either the stream's or connection's window (A1). It also includes provisions for error handling and state-saving to potentially recover a usable protocol element. All these visible code segments indicate that the function alone attempts to implement the specified semantics, thereby fully matching the provided spec constraints.",success,
4018,ngx_http_v2_state_window_update,"At a minimum, a recipient MUST be able to parse and process protocol element lengths that are at least as long as the values that it generates for those same protocol elements in other messages.",218,Fully Matches,"[{'C1': {'code': 'if (h2c->state.length != NGX_HTTP_V2_WINDOW_UPDATE_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent WINDOW_UPDATE frame with incorrect length %uz"", h2c->state.length);\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}\n\nif (end - pos < NGX_HTTP_V2_WINDOW_UPDATE_SIZE) {\n    return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_window_update);\n}', 'explanation': ""This code checks that the incoming WINDOW_UPDATE frame's length matches the expected constant NGX_HTTP_V2_WINDOW_UPDATE_SIZE. This ensures that the recipient is able to parse and process protocol element lengths at least as long as the values it generates, which meets the RFC requirement.""}}]","The function specifically enforces the expected length for a WINDOW_UPDATE frame by comparing the received length to a predefined constant and by validating that enough data is available for processing. This directly implements the RFC mandate that a recipient must handle protocol elements with lengths at least as long as what it produces, thereby fully addressing the constraint contained in the specification.",success,
4018,ngx_http_v2_state_window_update,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (h2c->state.length != NGX_HTTP_V2_WINDOW_UPDATE_SIZE) {\n    ngx_log_error(... ""client sent WINDOW_UPDATE frame with incorrect length %uz"", h2c->state.length);\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This segment checks that the received WINDOW_UPDATE frame has the expected fixed length. It prevents processing frames with an unexpected size, which is one way to enforce correct protocol syntax.'}}, {'A1': {'code': 'if (window == 0) {\n    ngx_log_error(... ""client sent WINDOW_UPDATE frame with incorrect window increment 0"");\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': 'This segment ensures that the client does not send a WINDOW_UPDATE frame with a zero window increment; a zero increment is invalid according to HTTP/2 flow-control rules. This check helps to enforce that only valid frame parameters are processed.'}}]","The function validates an incoming WINDOW_UPDATE frame by checking its length and ensuring that the window increment is nonzero, along with additional flow-control validations for both stream-specific and connection-level window updates. These checks are in line with enforcing correct protocol element formatting and preventing invalid or out‐of‐role elements. However, the RFC requirement specifically states that a sender MUST NOT generate protocol elements or syntax alternatives that are reserved for other roles. While the function does validate frame parameters to catch violations (such as incorrect length or wrong window increments), it does not explicitly check or enforce that the protocol elements being received are only generated by a sender fully entitled to them. Thus, only part of the RFC’s constraint is visibly implemented within this function.",success,
4018,ngx_http_v2_state_window_update,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (h2c->state.length != NGX_HTTP_V2_WINDOW_UPDATE_SIZE) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent WINDOW_UPDATE frame with incorrect length %uz"", h2c->state.length);\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR);\n}', 'explanation': 'This segment defensively checks that the received frame length exactly matches the expected WINDOW_UPDATE frame size. It does not assume that the received element fully conforms to the expected grammar, aligning with the RFC recommendation for defensive parsing.'}}, {'C2': {'code': 'if (end - pos < NGX_HTTP_V2_WINDOW_UPDATE_SIZE) {\n    return ngx_http_v2_state_save(h2c, pos, end,\n                                  ngx_http_v2_state_window_update);\n}', 'explanation': 'This code checks that there is sufficient data (buffer) available to parse the complete WINDOW_UPDATE frame. It ensures that the parser does not overrun the available buffer, addressing the RFC concern regarding buffer size.'}}, {'A1': {'code': 'if (window == 0) {\n    ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0,\n                  ""client sent WINDOW_UPDATE frame with incorrect window increment 0"");\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR);\n}', 'explanation': ""This segment enforces protocol semantics by validating the window increment value and taking appropriate error handling actions when the value is invalid, fulfilling the RFC's expectation of handling malformed protocol elements.""}}]","The function ngx_http_v2_state_window_update implements defensive parsing in accordance with the HTTP RFC. It does not assume that the incoming protocol element perfectly matches its ABNF grammar and verifies that the frame's length and buffer availability meet expectations. Additionally, it validates protocol-specific fields (such as ensuring that the window increment is non-zero) and logs and handles errors accordingly. All of these measures demonstrate that the function is fully matching the defensive parsing requirements specified by the RFC.",success,
4021,ngx_http_v2_state_complete,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (pos > end) {\n    ngx_log_error(NGX_LOG_ALERT, h2c->connection->log, 0,\n                  ""receive buffer overrun"");\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);\n}', 'explanation': ""This code segment performs a defensive check to ensure that the pointer 'pos' does not exceed 'end', thereby guarding against buffer overruns. This aligns with the RFC's recommendation to parse protocol elements defensively.""}}]","The RFC specification calls for defensive parsing with minimal assumptions about protocol conformance and buffer size. In the provided function, the defensive check (C1) is implemented via 'if (pos > end)' to catch potential buffer overruns, which addresses one aspect of the requirement. However, the function does not implement any additional logic regarding the conformity to the ABNF grammar or dynamic assessment of what constitutes a 'reasonable' buffer size. Because only part of the spec constraint is addressed directly within the function, the overall matching judgment is 'Partially Matches'.",success,
4025,ngx_http_v2_state_save,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'size = end - pos;\n\nif (size > NGX_HTTP_V2_STATE_BUFFER_SIZE) {\n    ngx_log_error(NGX_LOG_ALERT, h2c->connection->log, 0,\n                  ""state buffer overflow: %uz bytes required"", size);\n\n    return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR);\n}', 'explanation': 'This segment checks that the size of the received element does not exceed a predefined maximum buffer size, addressing the defensive parsing requirement that protocol elements fit within a reasonable buffer size.'}}, {'A1': {'code': 'ngx_memcpy(h2c->state.buffer, pos, size);\n\nh2c->state.buffer_used = size;\nh2c->state.handler = handler;\nh2c->state.incomplete = 1;', 'explanation': 'These lines implement the action of saving the state after verifying the buffer size, which completes the defensive approach by handling the correctly sized protocol element.'}}]","The function implements a defensive check by comparing the size of the incoming protocol element against a fixed buffer size constant and logging an error if it exceeds this size. This aligns with the RFC guideline to expect only marginal conformance in input size. However, while it protects against buffer overflow, it does not perform further defensive parsing such as validating the ABNF grammar of the element. Therefore, the function only partially matches the complete defensive parsing strategy described in the RFC specification.",success,
4029,ngx_http_v2_parse_int,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (h2c->state.length == 0) {\n    return NGX_ERROR;\n}\n...\nif ((size_t) (p - start) > h2c->state.length) {\n    return NGX_ERROR;\n}\n\nh2c->state.length -= p - start;', 'explanation': 'This code checks the remaining length (via h2c->state.length) both before and during the parsing process, ensuring that the received protocol element does not exceed the expected buffer size. This is a defensive parsing measure as the RFC mandates.'}}, {'A1': {'code': 'if (end - start > NGX_HTTP_V2_INT_OCTETS) {\n    end = start + NGX_HTTP_V2_INT_OCTETS;\n}\n\nfor (shift = 0; p != end; shift += 7) {\n    octet = *p++;\n    value += (octet & 0x7f) << shift;\n    if (octet < 128) {\n        ...\n        return value;\n    }\n}\n\nif ((size_t) (end - start) >= h2c->state.length) {\n    return NGX_ERROR;\n}\n\nif (end == start + NGX_HTTP_V2_INT_OCTETS) {\n    return NGX_DECLINED;\n}\n\nreturn NGX_AGAIN;', 'explanation': 'By bounding the read to NGX_HTTP_V2_INT_OCTETS and carefully verifying that the parsed sequence fits within the expected buffer, the function ensures that the protocol element adheres to a reasonable size limit. This implements the RFC’s action for defensively handling variable-length elements.'}}]","The function ngx_http_v2_parse_int implements a defensive parsing strategy by checking the available buffer length and by limiting the maximum number of octets processed. It returns error conditions when the input does not meet expected boundaries. This directly addresses the RFC’s recommendation that a recipient should parse protocol elements defensively, with only marginal expectations about conformity and buffer size.",success,
4033,ngx_http_v2_send_window_update,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function constructs and sends a WINDOW_UPDATE frame as part of the HTTP/2 protocol but does not contain any logic that verifies or restricts the generation of protocol elements based on sender roles. The RFC specification requires that a sender must not generate protocol elements that are exclusively allowed for participants in other roles, yet this function does not perform any checks to enforce such constraint within its own logic. Hence, no labeled condition (e.g., C1) or action (e.g., A1) from the spec constraints is visibly implemented within the function_body.",success,
4036,ngx_http_v2_get_frame,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function constructs an HTTP/2 frame by allocating or reusing a frame, writing header fields, and managing memory. However, it does not contain any logic that checks or restricts the generation of protocol elements based on the sender's role. Specifically, there is no code that verifies that only allowed protocol elements for the current role are produced, as mandated by the RFC specification. Therefore, the function fails to visibly address the condition that a sender MUST NOT generate protocol elements or syntax alternatives reserved for other roles.",success,
4041,ngx_http_v2_validate_header,"Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message.",3,Fully Matches,"[{'C1': {'code': 'for (i = 0; i != header->value.len; i++) {\n    ch = header->value.data[i];\n    if (ch == \'\\0\' || ch == LF || ch == CR) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent header \\""%V\\"" with invalid value: \\""%V\\"""",\n                      &header->name, &header->value);\n        return NGX_ERROR;\n    }\n}', 'explanation': 'This code segment iterates over each character in the header value, checks for any CR, LF, or NUL characters, and rejects the message by returning an error if any are found. This directly implements the RFC requirement that field values containing these dangerous characters must cause the message to be rejected (or have those characters replaced).'}}]","The function clearly implements the RFC specification by validating header field values. It scans each character in the header value for CR, LF, or NUL characters and, upon finding any, logs an error and rejects the message. This satisfies the RFC constraint that such characters are not allowed and that the message must be either rejected or sanitized. Since the function addresses the key condition solely within its body, it is deemed to Fully Match the requirement.",success,
4041,ngx_http_v2_validate_header,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Partially Matches,"[{'C1': {'code': 'for (i = 0; i != header->value.len; i++) {\n    ch = header->value.data[i];\n\n    if (ch == \'\\0\' || ch == LF || ch == CR) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent header \\""%V\\"" with \n                      invalid value: \\""%V\\"""",\n                      &header->name, &header->value);\n\n        return NGX_ERROR;\n    }\n}', 'explanation': 'This code explicitly checks each character in the header value and rejects the header if it includes a CR (as well as LF and the null character). This enforces that protocol elements (in this case, headers) do not contain a bare CR. However, it does not differentiate between a bare CR and a CR followed immediately by LF, thereby applying a stricter rule than the RFC, which permits CR only as part of a CRLF sequence.'}}]","The function attempts to enforce the RFC requirement by scanning header values for any occurrence of a CR character and rejecting the header if one is found. This validation meets the intent of preventing a sender from including a bare CR in protocol elements. However, it does not account for the possibility of a valid CRLF sequence, as it flags any CR regardless of context. Since the RFC requires that only bare CRs (and not those correctly followed by LF) be rejected, the function only partially matches the specification.",success,
4041,ngx_http_v2_validate_header,A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.,173,Fully Matches,"[{'C1': {'code': 'for (i = 0; i != header->value.len; i++) {\n    ch = header->value.data[i];\n\n    if (ch == \'\\0\' || ch == LF || ch == CR) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent header \\""%V\\"" with invalid value: \\""%V\\"""",\n                      &header->name, &header->value);\n        return NGX_ERROR;\n    }\n}', 'explanation': 'The RFC states that a header element containing a bare CR should be considered invalid or have the CR replaced by SP. This code explicitly checks for the presence of a carriage return (CR) in the header value and immediately treats the header as invalid by returning an error, which complies with the requirement.'}}]","The function ngx_http_v2_validate_header inspects both header names and header values for invalid characters. In the header value validation loop, it explicitly checks for a CR (as well as LF and null characters) and returns an error if found, thereby treating the header as invalid. This behavior directly fulfills the RFC mandate that a recipient should consider an element with a bare CR as invalid (or perform replacement with SP, with invalidation being an acceptable alternative). As such, the function fully addresses the particular constraint provided in the spec.",success,
4043,ngx_http_v2_parse_path,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'C1': {'code': 'if (r->unparsed_uri.len) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent duplicate :path header"");\n    return NGX_DECLINED;\n}', 'explanation': 'This segment verifies that a :path header is not being duplicated, which addresses the RFC requirement that a sender MUST NOT generate multiple field lines with the same name when such combination is not allowed.'}}, {'A1': {'code': 'if (value->len == 0) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent empty :path header"");\n    return NGX_DECLINED;\n}', 'explanation': ""This check ensures that the :path header is not empty, thereby validating the header content as per the RFC's expectations for a field's valid value.""}}]","The function partially implements the RFC requirements for header validation by directly checking for duplicate :path headers and for empty values. These checks correspond to conditions about not having multiple header lines with the same name (unless allowed) and ensuring header validity. However, aspects such as preserving the order of header fields or handling other headers are not addressed within this function, thus it only partially matches the overall HTTP RFC specifications outlined.",success,
4043,ngx_http_v2_parse_path,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (r->unparsed_uri.len) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent duplicate :path header"");\n\n    return NGX_DECLINED;\n}', 'explanation': 'This segment checks for a duplicate :path header, ensuring that a header the client is not expected to repeat is not regenerated, which is in line with the idea that certain protocol elements should only be generated by specific roles.'}}, {'C2': {'code': 'if (value->len == 0) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent empty :path header"");\n\n    return NGX_DECLINED;\n}', 'explanation': 'This segment makes sure that an empty :path header is not accepted, thereby preventing a client from sending a malformed or inappropriate protocol element.'}}]","The function validates the :path header by checking for duplicate and empty headers and by further validating the URI syntax. These checks address some of the protocol constraints implied by the RFC requirement that a sender (client) must not generate protocol elements that are only allowed to be generated by a different role. However, the function does not address all potential protocol elements or syntax alternatives that the RFC governs. It only covers basic validation within its scope, so it partially matches the RFC specification.",success,
4044,ngx_http_v2_parse_method,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (value->len == 0) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent empty :method header"");\n    return NGX_DECLINED;\n}\n\n... \n\n/* Check each character against allowed grammar */\n p = r->method_name.data;\n do {\n     if ((*p < \'A\' || *p > \'Z\') && *p != \'_\' && *p != \'-\') {\n         ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                       ""client sent invalid method: \\""%V\\"""",\n                       &r->method_name);\n         return NGX_DECLINED;\n     }\n     p++;\n } while (--len);', 'explanation': 'This segment enforces the syntactic validity of the :method header by ensuring it is non-empty and that its characters conform to the allowed set. This corresponds to a part of the specification requiring adherence to the defined grammar.'}}]","The function implements checks to ensure that the HTTP method header is non-empty, non-duplicated, and composed only of valid characters. This addresses the syntactic aspect of the RFC requirement (i.e. matching the grammar defined by the ABNF rules). However, the specification also prohibits a sender from generating protocol elements that are only allowed by participants in other roles, and this role-based enforcement is not evident in the function. Therefore, the function only partially matches the RFC specification constraints.",success,
4044,ngx_http_v2_parse_method,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'do {\n    if ((*p < \'A\' || *p > \'Z\') && *p != \'_\' && *p != \'-\') {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent invalid method: \\""%V\\"""",\n                      &r->method_name);\n        return NGX_DECLINED;\n    }\n    p++;\n} while (--len);', 'explanation': ""This segment validates that each character in the method string is within the allowed set (between 'A' and 'Z', or '_' or '-'), thus ensuring that the generated protocol element (i.e. the :method header value) conforms to the ABNF grammar. By rejecting values that include invalid characters, it enforces the RFC requirement that a sender MUST NOT generate protocol elements that do not match the defined grammar.""}}]","The function ngx_http_v2_parse_method checks the method header against a set of known valid methods and, if its value is not recognized, it iterates over each character to ensure it adheres to the allowed character set (A-Z, '_' and '-'). This directly enforces the RFC requirement regarding conformity to the ABNF grammar, thereby fully matching the stated specification constraint.",success,
4044,ngx_http_v2_parse_method,All general-purpose servers MUST support the methods GET and HEAD,58,Fully Matches,"[{'C1': {'code': 'static const struct {\n    u_char       len;\n    const u_char method[11];\n    uint32_t     value;\n} tests[] = {\n    { 3, ""GET"",       NGX_HTTP_GET },\n    { 4, ""POST"",      NGX_HTTP_POST },\n    { 4, ""HEAD"",      NGX_HTTP_HEAD },\n    { 7, ""OPTIONS"",   NGX_HTTP_OPTIONS },\n    { 8, ""PROPFIND"",  NGX_HTTP_PROPFIND },\n    { 3, ""PUT"",       NGX_HTTP_PUT },\n    { 5, ""MKCOL"",     NGX_HTTP_MKCOL },\n    { 6, ""DELETE"",    NGX_HTTP_DELETE },\n    { 4, ""COPY"",      NGX_HTTP_COPY },\n    { 4, ""MOVE"",      NGX_HTTP_MOVE },\n    { 9, ""PROPPATCH"", NGX_HTTP_PROPPATCH },\n    { 4, ""LOCK"",      NGX_HTTP_LOCK },\n    { 6, ""UNLOCK"",    NGX_HTTP_UNLOCK },\n    { 5, ""PATCH"",     NGX_HTTP_PATCH },\n    { 5, ""TRACE"",     NGX_HTTP_TRACE },\n    { 7, ""CONNECT"",   NGX_HTTP_CONNECT }\n};', 'explanation': ""The code explicitly lists HTTP methods to parse, including both 'GET' and 'HEAD'. This ensures that if a client sends either of these methods, they are recognized and mapped to their respective internal values, thereby fulfilling the RFC requirement that all general-purpose servers MUST support GET and HEAD.""}}]","The function ngx_http_v2_parse_method is designed to parse the HTTP :method header by comparing it against an array of recognized methods. The tests array clearly contains 'GET' and 'HEAD' among a set of other methods. This directly supports the RFC mandate that all general-purpose servers must support these two methods. All logic to recognize and validate these methods is contained within this function, making it self-sufficient in fulfilling the specified requirement.",success,
4047,ngx_http_v2_parse_scheme,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'C1': {'code': 'if (r->schema.len) {\n    ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                  ""client sent duplicate :scheme header"");\n    return NGX_DECLINED;\n}', 'explanation': 'This code segment checks whether the :scheme header has already been set (i.e. a duplicate field line is present) and rejects the request if it has. This addresses the RFC requirement that a sender MUST NOT generate multiple field lines with the same name when not allowed.'}}]","The function visibly implements logic to reject duplicate :scheme header fields, which corresponds to part of the HTTP RFC requirement regarding duplicate fields (condition C1). However, the RFC also covers aspects such as merging with a comma-separated list and preserving the order of field lines when multiple values are allowed. These additional aspects are not addressed in this function. Therefore, while the function partially matches the spec by handling duplicate headers for :scheme, it does not fully implement the complete set of constraints described in the RFC.",success,
4049,ngx_http_v2_construct_request_line,"A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain.",298,Does Not Match,[],"The provided function constructs an HTTP/2.0 request line from the provided method name, scheme, and unparsed URI. While it verifies that these fields are not empty and finalizes with a 400 error if any are missing, it does not implement the specific RFC requirements detailed in the spec. In particular, the spec mandates that recipients SHOULD NOT attempt to autocorrect an invalid request-line (especially one containing disallowed whitespace in the request-target), and should instead issue a redirect (301) or an error (400) when such cases occur. The function does not check for or handle whitespace in the request-target, nor does it provide logic to return a 301 redirect when a correction might be needed. As a result, the function does not visibly address the labeled conditions/actions specified by the RFC.",success,
4049,ngx_http_v2_construct_request_line,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function only constructs an HTTP/2 request line by concatenating the method, URI, and a fixed HTTP version string, and it performs basic checks to ensure that required fields are present. It does not contain any logic that specifically checks or restricts the generation of protocol elements based on the sender's role as required by the RFC. In other words, it does not ensure that protocol elements or syntax alternatives that are reserved for other roles are not generated, which is the central requirement of the provided RFC specification.",success,
4049,ngx_http_v2_construct_request_line,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",175,Partially Matches,"[{'C1': {'code': 'if (r->method_name.len == 0\n    || r->schema.len == 0\n    || r->unparsed_uri.len == 0)\n{\n    if (r->method_name.len == 0) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent no :method header"");\n    } else if (r->schema.len == 0) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent no :scheme header"");\n    } else {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client sent no :path header"");\n    }\n\n    ngx_http_finalize_request(r, NGX_HTTP_BAD_REQUEST);\n    return NGX_ERROR;\n}', 'explanation': 'This segment checks for missing required pseudo-header fields (:method, :scheme, :path) which is one indication of a malformed HTTP/2 request. It then finalizes the request with a 400 Bad Request response, partially addressing the robustness exception described in the spec.'}}]","The function partially implements the HTTP RFC robustness requirement by detecting when a request lacks required pseudo-header fields and then responding with a 400 Bad Request. However, it does not address other aspects of the HTTP-message grammar violations mentioned in the RFC (such as handling whitespace-preceded lines), meaning that only a portion of the spec constraints is handled within this function.",success,
4058,ngx_http_v2_filter_request_body,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (r->headers_in.content_length_n != -1) {\n    if (rb->received > r->headers_in.content_length_n) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client intended to send body data larger than declared"");\n        return NGX_HTTP_BAD_REQUEST;\n    }\n}', 'explanation': 'This segment defensively checks that the accumulated body size does not exceed the declared Content-Length. It is a defensive measure ensuring that the request does not contain more data than expected.'}}, {'A1': {'code': 'if (clcf->client_max_body_size\n    && rb->received > clcf->client_max_body_size)\n{\n    ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                  ""client intended to send too large chunked body: %O bytes"", rb->received);\n    return NGX_HTTP_REQUEST_ENTITY_TOO_LARGE;\n}', 'explanation': 'This segment ensures that, when no fixed Content-Length is provided, the body received does not exceed a configured maximum size. It acts defensively by checking against a reasonable limit before processing too much data.'}}]","The function implements defensive checks on the body size by comparing the received data against either the declared Content-Length or a configured maximum (client_max_body_size). These checks reflect a defensive parsing strategy by limiting data to a 'reasonable' size as suggested in the RFC. However, the RFC also notes that the recipient should tolerate marginal non-conformance to the ABNF grammar. This function does not include explicit grammar parsing and therefore only partially matches the RFC. It addresses the defensive size checks (conditions C1 and action A1) but does not implement other potential aspects of defensive parsing, such as verification against an ABNF grammar, meaning the overall implementation in function_body only partially meets the overall spec.",success,
4058,ngx_http_v2_filter_request_body,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Fully Matches,"[{'C1': {'code': 'if (r->headers_in.content_length_n != -1) {\n    if (rb->received > r->headers_in.content_length_n) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client intended to send body data larger than declared"");\n\n        return NGX_HTTP_BAD_REQUEST;\n    }\n}\n...\nif (!rb->rest) {\n    if (r->headers_in.content_length_n != -1 && r->headers_in.content_length_n != rb->received) {\n        ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                      ""client prematurely closed stream: only %O out of %O bytes of request body received"",\n                      rb->received, r->headers_in.content_length_n);\n\n        return NGX_HTTP_BAD_REQUEST;\n    }\n    b->last_buf = 1;\n    rb->last_sent = 1;\n}', 'explanation': 'The code explicitly validates the received body length against the declared Content-Length. It rejects messages that exceed the declared length as well as those that do not match upon complete reception. This ensures that messages with an incorrect Content-Length header are not forwarded, fulfilling the spec requirement.'}}]","The function 'ngx_http_v2_filter_request_body' implements RFC requirements by checking whether the received request body size matches the Content-Length header value. If the body is larger than declared or if the complete body does not match the declared Content-Length when reading is finished, the function returns an HTTP error (NGX_HTTP_BAD_REQUEST). This behavior effectively prevents forwarding messages with incorrect Content-Length values, thereby fully addressing the specified constraint.",success,
4059,ngx_http_v2_read_client_request_body_handler,"If the sender closes the connection or the recipient times out before the indicated number of octets are received, the recipient MUST consider the message to be incomplete and close the connection",303,Fully Matches,"[{'C1': {'code': 'if (fc->read->timedout) {\n    ngx_log_error(NGX_LOG_INFO, fc->log, NGX_ETIMEDOUT, ""client timed out"");\n    fc->timedout = 1;\n    r->stream->skip_data = 1;\n    ngx_http_finalize_request(r, NGX_HTTP_REQUEST_TIME_OUT);\n    return;\n}\n\nif (fc->error) {\n    ngx_log_error(NGX_LOG_INFO, fc->log, 0, ""client prematurely closed stream"");\n    r->stream->skip_data = 1;\n    ngx_http_finalize_request(r, NGX_HTTP_CLIENT_CLOSED_REQUEST);\n    return;\n}', 'explanation': 'These code segments explicitly check for a client timeout or an error (prematurely closed connection) and then finalize the request, effectively closing the connection. This behavior aligns with the RFC requirement to consider the message incomplete and close the connection when the sender closes the connection or when a timeout occurs before the expected number of octets are received.'}}]","The function directly addresses the specified HTTP RFC requirement by checking for timeout and premature close conditions. When either condition is met, the function finalizes the request (i.e., closes the connection) which satisfies the constraint described in the RFC specification. No other dependencies are needed to fulfill this specific requirement within the function itself.",success,
4065,ngx_http_v2_close_stream_handler,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (ev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, fc->log, NGX_ETIMEDOUT, ""client timed out"");\n    fc->timedout = 1;\n    ngx_http_v2_close_stream(r->stream, NGX_HTTP_REQUEST_TIME_OUT);\n    return;\n}', 'explanation': 'This code segment checks whether a timeout has occurred (a potential signal to close the connection), which aligns with the context where a client or server might decide to close the connection due to idleness or timeout conditions.'}}, {'A1': {'code': 'ngx_http_v2_close_stream(r->stream, 0);', 'explanation': 'This segment explicitly calls the close stream function to close the connection when no timeout is detected, manifesting the RFC allowance that the connection MAY be closed at any time.'}}]","The function monitors for a timeout event and accordingly closes the HTTP/2 stream. It implements the aspect of the specification that permits a client, server, or proxy to close the connection at any time—especially handling the timeout case by logging an error and marking the connection as timed out before closing the stream. However, while it addresses the closure mechanism, it does not elaborate on a full graceful close or the complete set of recommended conditions from the broader context, thus it only partially matches the provided specification actions and conditions.",success,
4065,ngx_http_v2_close_stream_handler,A client or server that wishes to time out SHOULD issue a graceful close on the connection.,314,Fully Matches,"[{'C1': {'code': 'if (ev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, fc->log, NGX_ETIMEDOUT, ""client timed out"");\n    fc->timedout = 1;\n    ...\n}', 'explanation': 'This code checks whether the event has timed out (the condition that a client or server wishing to time out should be detected), thus meeting the condition aspect of the spec.'}}, {'A1': {'code': 'ngx_http_v2_close_stream(r->stream, NGX_HTTP_REQUEST_TIME_OUT);', 'explanation': 'When a timeout is detected, the function issues a graceful close of the stream by calling ngx_http_v2_close_stream with a timeout-specific parameter, thereby implementing the RFC requirement for graceful closure.'}}]","The function clearly monitors for a timeout (as indicated by ev->timedout) and responds appropriately by initiating a graceful close of the HTTP/2 stream. This aligns with the RFC specification that requires clients or servers that wish to time out to issue a graceful connection close. Both the conditional check for timeout (C1) and the corresponding graceful closure action (A1) are directly implemented within the function, fulfilling the requirement by itself.",success,
4067,ngx_http_v2_handle_connection_handler,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Does Not Match,[],"The provided function does not include any visible logic that directly implements the RFC's requirement regarding sustaining persistent connections and relying on the underlying transport's flow-control mechanisms. The function primarily handles error checking, dispatching to read handlers, and output queue processing, but it does not explicitly address maintaining persistent connections under temporary overload conditions. Therefore, no spec constraints (e.g., C1, A1) related to sustaining persistent connections are fulfilled within this function.",success,
4068,ngx_http_v2_idle_handler,"A client, server, or proxy MAY close the transport connection at any time.",316,Fully Matches,"[{'C1': {'code': 'if (rev->timedout || c->close) {\n    ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_NO_ERROR);\n    return;\n}', 'explanation': ""This segment checks if the connection has timed out or is marked for closing and then gracefully finalizes the connection. It directly addresses the spec's allowance that a client, server, or proxy may close the transport connection at any time.""}}, {'A1': {'code': '#if (NGX_HAVE_KQUEUE)\n\nif (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {\n    if (rev->pending_eof) {\n        c->log->handler = NULL;\n        ngx_log_error(NGX_LOG_INFO, c->log, rev->kq_errno,\n                      ""kevent() reported that client %V closed ""\n                      ""idle connection"", &c->addr_text);\n#if (NGX_HTTP_SSL)\n        if (c->ssl) {\n            c->ssl->no_send_shutdown = 1;\n        }\n#endif\n        ngx_http_close_connection(c);\n        return;\n    }\n}\n\n#endif', 'explanation': ""This portion detects if a closure has been signalled by the kernel (using kevent's pending_eof) and responds by closing the connection immediately. This is inline with the spec's notion that a connection may be closed at any time and that implementations should promptly handle such closure signals.""}}]","The function ngx_http_v2_idle_handler contains explicit logic to check for connection timeout and closure signals, and it proceeds to finalize or close the connection when required. Both branches, one handling internal timeout/close flags and the other handling external closure signals (from kevent), demonstrate that the function itself directly implements the spec requirement that a client, server, or proxy MAY close the transport connection at any time.",success,
4068,ngx_http_v2_idle_handler,A client or server that wishes to time out SHOULD issue a graceful close on the connection.,314,Fully Matches,"[{'C1': {'code': 'if (rev->timedout || c->close) {\n    ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_NO_ERROR);\n    return;\n}', 'explanation': 'This block detects when the event has timed out (or the connection is marked to close) and calls ngx_http_v2_finalize_connection, which initiates a graceful shutdown of the connection as required by the RFC.'}}, {'A1': {'code': 'ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_NO_ERROR);', 'explanation': 'This function call is used to finalize (i.e. gracefully close) the connection when a timeout occurs, directly implementing the action of issuing a graceful close.'}}]","The function monitors for a timeout or closure signal (as per condition C1) and then initiates a graceful shutdown of the connection by calling ngx_http_v2_finalize_connection (action A1). This clearly implements the specified RFC requirement that a client or server wishing to time out should issue a graceful close on the connection. All relevant logic is contained within this function, independent of external dependencies.",success,
4068,ngx_http_v2_idle_handler,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'A1': {'code': 'c->destroyed = 0;\nngx_reusable_connection(c, 0);', 'explanation': ""These lines reset the connection's destroyed flag and mark it as reusable, which is an attempt to sustain persistent connections as recommended by the spec.""}}]","The function implements part of the spec by maintaining the connection for reuse if no timeout or explicit close flag is set. This matches the aspect of sustaining persistent connections (A1). However, it does not explicitly incorporate mechanisms that defer connection termination in favor of allowing the transport's flow-control to manage temporary overloads. Moreover, some actions, such as handling client request bodies and monitoring for flow control conditions, appear to be delegated elsewhere or not implemented in this function. Therefore, while it partially matches the spec, not all labeled conditions/actions are fully addressed within this function alone.",success,
4118,ngx_http_v2_header_filter,The type/subtype MAY be followed by semicolon-delimited parameters (Section 5.6.6) in the form of name/value pairs.,259,Partially Matches,"[{'C1': {'code': 'if (r->headers_out.content_type.len) {\n    ...\n    if (r->headers_out.content_type_len == r->headers_out.content_type.len\n        && r->headers_out.charset.len)\n    {\n        len += sizeof(""; charset="") - 1 + r->headers_out.charset.len;\n    }\n    ...\n}\n\n...\n\nif (r->headers_out.content_type.len) {\n    *pos++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_CONTENT_TYPE_INDEX);\n\n    if (r->headers_out.content_type_len == r->headers_out.content_type.len\n        && r->headers_out.charset.len)\n    {\n        len = r->headers_out.content_type.len + sizeof(""; charset="") - 1\n              + r->headers_out.charset.len;\n\n        p = ngx_pnalloc(r->pool, len);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        p = ngx_cpymem(p, r->headers_out.content_type.data,\n                       r->headers_out.content_type.len);\n\n        p = ngx_cpymem(p, ""; charset="", sizeof(""; charset="") - 1);\n\n        p = ngx_cpymem(p, r->headers_out.charset.data,\n                       r->headers_out.charset.len);\n\n        r->headers_out.content_type.len = len;\n        r->headers_out.content_type.data = p - len;\n    }\n    ...\n}', 'explanation': ""This code segment checks if the content type does not already include parameters and, if a charset is provided, appends '; charset=' followed by the charset value. This is an implementation of allowing a media type (type/subtype) to have semicolon-delimited parameters as specified.""}}]","The provided function implements header filtering for HTTP/2 and includes logic to modify the Content-Type header by appending a charset parameter when appropriate. This is in line with the RFC requirement that a media type (type/subtype) may be followed by semicolon-delimited parameters. However, the code only handles the specific case of a 'charset' parameter and does not provide a generalized framework for all possible semicolon-delimited name/value pairs. Thus, while it visibly addresses part of the RFC specification regarding parameters, it only partially matches the full specification.",success,
4118,ngx_http_v2_header_filter,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Fully Matches,"[{'C1': {'code': 'case NGX_HTTP_NO_CONTENT:\n    r->header_only = 1;\n\n    ngx_str_null(&r->headers_out.content_type);\n\n    r->headers_out.content_length = NULL;\n    r->headers_out.content_length_n = -1;\n\n    r->headers_out.last_modified_time = -1;\n    r->headers_out.last_modified = NULL;', 'explanation': ""In the case of a 204 (No Content) response, the code explicitly resets the Content-Length information by setting 'r->headers_out.content_length' to NULL and 'r->headers_out.content_length_n' to -1. This prevents the Content-Length header from being output, which satisfies the RFC's instruction not to send a Content-Length header for this status.""}}, {'A1': {'code': 'if (r->headers_out.content_length == NULL\n    && r->headers_out.content_length_n >= 0)\n{\n    len += 1 + ngx_http_v2_integer_octets(NGX_OFF_T_LEN) + NGX_OFF_T_LEN;\n}\n\n...\n\nif (r->headers_out.content_length == NULL\n    && r->headers_out.content_length_n >= 0)\n{\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n                   ""http2 output header: \\""content-length: %O\\"""",\n                   r->headers_out.content_length_n);\n\n    *pos++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_CONTENT_LENGTH_INDEX);\n\n    p = pos;\n    pos = ngx_sprintf(pos + 1, ""%O"", r->headers_out.content_length_n);\n    *p = NGX_HTTP_V2_ENCODE_RAW | (u_char) (pos - p - 1);\n}', 'explanation': 'When there is no existing Content-Length header and the content length is known (i.e. content_length_n is non-negative), the function calculates the header size and then writes the Content-Length header into the output. This meets the RFC requirement to send a Content-Length header field when the content size is known (in the absence of Transfer-Encoding, as is typical in HTTP/2).'}}]","The function includes explicit checks and actions to handle the Content-Length header in accordance with the HTTP RFC. It avoids sending a Content-Length header for responses where it is forbidden (such as a 204 No Content response) and adds the header when the content length is known. Thus, the code function visibly implements the relevant spec constraints.",success,
4118,ngx_http_v2_header_filter,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Partially Matches,"[{'C1': {'code': 'case NGX_HTTP_NO_CONTENT:\n    r->header_only = 1;\n\n    ngx_str_null(&r->headers_out.content_type);\n\n    r->headers_out.content_length = NULL;\n    r->headers_out.content_length_n = -1;\n\n    r->headers_out.last_modified_time = -1;\n    r->headers_out.last_modified = NULL;\n\n    status = ngx_http_v2_indexed(NGX_HTTP_V2_STATUS_204_INDEX);', 'explanation': 'For HTTP 204 (No Content) responses, this code explicitly clears the Content-Length header fields by setting r->headers_out.content_length to NULL and r->headers_out.content_length_n to -1, ensuring that the Content-Length header is not sent. This addresses part of the RFC requirement. However, the RFC also requires that Content-Length is not sent for 1xx responses, and this function does not contain explicit logic to handle 1xx status codes.'}}]","The RFC states that a server MUST NOT send a Content-Length header field in any response with a status code of 1xx or 204. The function clearly implements the behavior for a 204 response by nullifying the Content-Length header. However, the function does not contain explicit logic for responses with 1xx status codes. Since only one aspect (204 responses) is directly addressed within the function, the implementation is considered a partial match to the RFC specification.",success,
4118,ngx_http_v2_header_filter,"Note that the coding named ""identity"" is reserved for its special role in Accept-Encoding and thus SHOULD NOT be included.",38,Does Not Match,[],"The RFC specification requires that when one or more content codings (such as gzip) have been applied, the resulting Content-Encoding header should list the applied encodings in order and must not include the reserved ""identity"" coding. In the provided function, while there is logic related to gzip (e.g., handling r->gzip_vary and writing out a ""Vary: Accept-Encoding"" header), there is no visible implementation addressing the ordering of content codings or filtering out the ""identity"" coding. The function mainly translates various response headers into HTTP/2 header frames rather than implementing the Content-Encoding header rules specified by the RFC. Therefore, the code function does not address the constraint specified in the RFC.",success,
4118,ngx_http_v2_header_filter,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'if (r->headers_out.content_type.len) {\n    *pos++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_CONTENT_TYPE_INDEX);\n\n    if (r->headers_out.content_type_len == r->headers_out.content_type.len\n        && r->headers_out.charset.len)\n    {\n        len = r->headers_out.content_type.len + sizeof(""; charset="") - 1\n              + r->headers_out.charset.len;\n\n        p = ngx_pnalloc(r->pool, len);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        p = ngx_cpymem(p, r->headers_out.content_type.data,\n                       r->headers_out.content_type.len);\n\n        p = ngx_cpymem(p, ""; charset="", sizeof(""; charset="") - 1);\n\n        p = ngx_cpymem(p, r->headers_out.charset.data,\n                       r->headers_out.charset.len);\n\n        r->headers_out.content_type.len = len;\n        r->headers_out.content_type.data = p - len;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n                   ""http2 output header: \\""content-type: %V\\"""",\n                   &r->headers_out.content_type);\n\n    pos = ngx_http_v2_write_value(pos, r->headers_out.content_type.data,\n                                  r->headers_out.content_type.len, tmp);\n}', 'explanation': 'This segment checks if a Content-Type value exists and then writes it into the HTTP/2 header block. According to the RFC, if the sender knows the intended media type, a Content-Type header SHOULD be generated. The logic here ensures that when r->headers_out.content_type.len is nonzero the header is output, fulfilling the RFC requirement.'}}]","The function 'ngx_http_v2_header_filter' is responsible for encoding and sending HTTP/2 response headers. In doing so, it checks whether a Content-Type header has been set (i.e. the media type is known) and writes it out using the appropriate HTTP/2 header encoding functions. This behavior conforms with the RFC requirement that a sender SHOULD generate a Content-Type header field in messages containing content, unless the media type is unknown. Since the function only outputs the Content-Type header if it is set (and does nothing when it is absent), it is in agreement with the RFC, fully matching the specified constraint.",success,
4118,ngx_http_v2_header_filter,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,61,Fully Matches,"[{'C1': {'code': 'if (r->method == NGX_HTTP_HEAD) {\n    r->header_only = 1;\n}', 'explanation': ""This code checks if the HTTP method is HEAD and sets the 'header_only' flag to ensure that no content will be sent in the response.""}}, {'A1': {'code': 'fin = r->header_only || (r->headers_out.content_length_n == 0 && !r->expect_trailers);', 'explanation': ""This calculation uses the 'header_only' flag (set for HEAD requests) to finalize the header frame without including any message body, directly addressing the requirement that no content is sent.""}}]","The function explicitly handles the HEAD method by checking if the request method is NGX_HTTP_HEAD and setting the r->header_only flag. It then uses this flag when determining the finalization of the header frame (the 'fin' flag), ensuring that no body or content is sent. This directly implements the requirement from the HTTP RFC that the HEAD method must not return a message body, thereby fully matching the specification constraints within this function.",success,
4118,ngx_http_v2_header_filter,A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content).,193,Does Not Match,[],"The RFC specification requires that a server must not send a Transfer-Encoding header field in any response with a status code of 1xx or 204. Although the function handles status 204 (e.g., by setting r->header_only and nulling some related headers), there is no logic in the function_body that checks for or removes a Transfer-Encoding header field. As a result, the function does not visibly implement the requirement regarding the Transfer-Encoding header for these specific status codes.",success,
4118,ngx_http_v2_header_filter,"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",225,Fully Matches,"[{'C1': {'code': 'if (r->headers_out.location && r->headers_out.location->value.len) {\n    if (r->headers_out.location->value.data[0] == \'/\' && clcf->absolute_redirect) {\n        if (clcf->server_name_in_redirect) {\n            cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n            host = cscf->server_name;\n        } else if (r->headers_in.server.len) {\n            host = r->headers_in.server;\n        } else {\n            host.len = NGX_SOCKADDR_STRLEN;\n            host.data = addr;\n            if (ngx_connection_local_sockaddr(fc, &host, 0) != NGX_OK) {\n                return NGX_ERROR;\n            }\n        }\n        ...\n        p = ngx_cpymem(location.data, ""http"", sizeof(""http"") - 1);\n#if (NGX_HTTP_SSL)\n        if (fc->ssl) {\n            *p++ = \'s\';\n        }\n#endif\n        *p++ = \':\'; *p++ = \'/\'; *p++ = \'/\';\n        p = ngx_cpymem(p, host.data, host.len);\n        ...\n    }\n}', 'explanation': ""When constructing an absolute URI for a redirect (i.e. when the location value starts with '/' and absolute_redirect is enabled), the code explicitly selects a host identifier from one of three available sources (server configuration, request header, or the connection’s local socket). This ensures that when an HTTPS URI is generated (when fc->ssl is true), it will include a non‐empty host identifier, in compliance with the RFC requirement.""}}]","The function contains explicit logic in the branch dealing with the 'Location' header: when a relative path is detected and an absolute redirect is requested, it retrieves a host value from either the server configuration, the incoming headers, or as a fallback from the local socket address. It then constructs the URI by prepending the appropriate scheme (adding 's' for HTTPS) and the '://', followed by the host. This effectively prevents the generation of an 'https' URI with an empty host identifier, thereby satisfying the RFC specification.",success,
4118,ngx_http_v2_header_filter,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Fully Matches,"[{'C1': {'code': '    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n                   ""http2 output header: "":status: %03ui"""",\n                   r->headers_out.status);\n\n    if (status) {\n        *pos++ = status;\n    } else {\n        *pos++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_STATUS_INDEX);\n        *pos++ = NGX_HTTP_V2_ENCODE_RAW | 3;\n        pos = ngx_sprintf(pos, ""%03ui"", r->headers_out.status);\n    }\n\n    /* later only allowed server fields are emitted such as ""server"", ""date"", etc. */', 'explanation': 'This code segment carefully constructs the HTTP/2 pseudo header "":status"" and then emits only header fields that are proper for a server response. It does not generate client-specific protocol elements (such as "":method"" or "":path"") and thereby avoids creating syntax alternatives that are reserved for roles other than that of the sender. This behavior directly reflects the RFC requirement that within a given message, a sender must not generate protocol elements only allowed to be generated by participants in other roles.'}}]","The function 'ngx_http_v2_header_filter' assembles the HTTP/2 header frame for a server response by encoding pseudo headers and other response-specific fields. In doing so, it selectively outputs only those protocol elements (like "":status"", ""server"", ""date"", etc.) that a server is allowed to generate. This shows an implementation strategy to avoid generating any protocol elements that are reserved for other roles, thereby fulfilling the RFC specification as stated.",success,
4118,ngx_http_v2_header_filter,An origin server MAY generate a Server header field in its responses.,89,Fully Matches,"[{'C1': {'code': ""if (r->headers_out.server == NULL) {\n    ...\n    *pos++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_SERVER_INDEX);\n\n    if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_ON) {\n        if (nginx_ver[0] == '\\0') {\n            p = ngx_http_v2_write_value(nginx_ver, (u_char *) NGINX_VER,\n                                        sizeof(NGINX_VER) - 1, tmp);\n            nginx_ver_len = p - nginx_ver;\n        }\n        pos = ngx_cpymem(pos, nginx_ver, nginx_ver_len);\n\n    } else if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_BUILD) {\n        if (nginx_ver_build[0] == '\\0') {\n            p = ngx_http_v2_write_value(nginx_ver_build,\n                                        (u_char *) NGINX_VER_BUILD,\n                                        sizeof(NGINX_VER_BUILD) - 1, tmp);\n            nginx_ver_build_len = p - nginx_ver_build;\n        }\n        pos = ngx_cpymem(pos, nginx_ver_build, nginx_ver_build_len);\n\n    } else {\n        pos = ngx_cpymem(pos, nginx, sizeof(nginx));\n    }\n}"", 'explanation': 'The function explicitly checks if the Server header is absent (r->headers_out.server == NULL) and, based on configuration (server_tokens), generates a Server header field using one of the predefined token values. This directly addresses the RFC specification that an origin server MAY generate a Server header field in its responses.'}}]","The ngx_http_v2_header_filter function includes logic to produce a 'Server' header when it is not already set, using different formats based on the configuration settings. This behavior directly implements the RFC requirement that an origin server may generate a Server header field, meaning that the provided function fully addresses the spec constraints within its own logic.",success,
4118,ngx_http_v2_header_filter,An origin server SHOULD NOT generate a Server header field containing needlessly fine-grained detail and SHOULD limit the addition of subproducts by third parties.,90,Partially Matches,"[{'C1': {'code': 'if (r->headers_out.server == NULL) {\n    if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_ON) {\n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, fc->log, 0,\n                       ""http2 output header: \\""server: %s\\"""",\n                       NGINX_VER);\n        *pos++ = ngx_http_v2_inc_indexed(NGX_HTTP_V2_SERVER_INDEX);\n        if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_ON) {\n            if (nginx_ver[0] == \'\\0\') {\n                p = ngx_http_v2_write_value(nginx_ver, (u_char *) NGINX_VER,\n                                            sizeof(NGINX_VER) - 1, tmp);\n                nginx_ver_len = p - nginx_ver;\n            }\n            pos = ngx_cpymem(pos, nginx_ver, nginx_ver_len);\n        } else if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_BUILD) {\n            if (nginx_ver_build[0] == \'\\0\') {\n                p = ngx_http_v2_write_value(nginx_ver_build,\n                                            (u_char *) NGINX_VER_BUILD,\n                                            sizeof(NGINX_VER_BUILD) - 1, tmp);\n                nginx_ver_build_len = p - nginx_ver_build;\n            }\n            pos = ngx_cpymem(pos, nginx_ver_build, nginx_ver_build_len);\n        } else {\n            pos = ngx_cpymem(pos, nginx, sizeof(nginx));\n        }\n    }', 'explanation': 'This block is responsible for generating the Server header field. It checks if the header is absent and then chooses what to output based on the server_tokens configuration. When the configuration is not set for detailed tokens, it outputs the minimal value (using a pre-defined short value), which is in line with the RFC recommendation to avoid fine-grained detail. However, when server_tokens is enabled, it may output detailed version information, so the function only partially meets the requirement.'}}]","The HTTP/2 header filter function includes logic to generate the Server header field and conditionally output minimal or detailed server information based on the server_tokens configuration. This approach attempts to implement the RFC guideline of not including needlessly fine‐grained detail. However, because it allows detailed information to be output when the configuration permits (NGX_HTTP_SERVER_TOKENS_ON or NGX_HTTP_SERVER_TOKENS_BUILD), it does not strictly enforce the limitation in all cases. Therefore, the function only partially matches the RFC specification.",success,
4123,ngx_http_v2_create_headers_frame,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'type = NGX_HTTP_V2_HEADERS_FRAME;\nflags = fin ? NGX_HTTP_V2_END_STREAM_FLAG : NGX_HTTP_V2_NO_FLAG;\n...\n\nb->last = ngx_http_v2_write_len_and_type(b->last, frame_size, type);\n*b->last++ = flags;\nb->last = ngx_http_v2_write_sid(b->last, stream->node->id);', 'explanation': 'This code segment constructs the frame header strictly using predefined constants and helper functions that write the length, type, flags, and stream identifier. By doing so, it ensures that the generated header strictly adheres to the expected ABNF grammar for HTTP/2 frames, thereby not generating any protocol elements outside the allowed grammar.'}}]","The function ngx_http_v2_create_headers_frame builds HTTP/2 HEADERS (and, if necessary, CONTINUATION) frames by setting fixed header fields using constant values and helper routines. These routines (e.g., ngx_http_v2_write_len_and_type and ngx_http_v2_write_sid) are used within the function to construct protocol elements in a manner that complies with the ABNF grammar specified by the RFC. Since all frame elements are generated in a controlled way and only valid protocol elements are produced, the function fully implements the requirement that a sender must not generate protocol elements that do not match the defined grammar.",success,
4123,ngx_http_v2_create_headers_frame,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, ngx_http_v2_create_headers_frame, is responsible for constructing HTTP/2 header frames (and continuation frames if needed). However, within its code there are no explicit checks or logic that prevent the sender from generating protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. In other words, while the function correctly builds the frame segments, it does not enforce the specific RFC requirement that a sender MUST NOT generate protocol elements reserved for other roles. Therefore, the function does not visibly address the labeled spec constraint within its own implementation.",success,
4126,ngx_http_v2_create_trailers_frame,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (header[i].key.len > NGX_HTTP_V2_MAX_FIELD) {\n    ngx_log_error(NGX_LOG_CRIT, fc->log, 0,\n                  ""too long response trailer name: \\""%V\\"""",\n                  &header[i].key);\n    return NULL;\n}\n\nif (header[i].value.len > NGX_HTTP_V2_MAX_FIELD) {\n    ngx_log_error(NGX_LOG_CRIT, fc->log, 0,\n                  ""too long response trailer value: \\""%V: %V\\"""",\n                  &header[i].key, &header[i].value);\n    return NULL;\n}', 'explanation': ""This part of the function protects against protocol elements that exceed a pre-defined maximum length, thereby enforcing a limit on the buffer size. This aligns with the defensive approach of ensuring the element fits within a 'reasonable buffer size'.""}}]","The function performs defensive checks by verifying that the lengths of trailer header names and values do not exceed NGX_HTTP_V2_MAX_FIELD, thereby ensuring they fit within a reasonable size. However, it does not address other aspects of the RFC—such as validating conformance to the ABNF grammar—which means it only partially implements the overall defensive parsing strategy specified in the RFC.",success,
4129,ngx_http_v2_send_chain,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'A1': {'code': 'if (size && ngx_http_v2_flow_control(h2c, stream) == NGX_DECLINED) {\n    if (ngx_http_v2_filter_send(fc, stream) == NGX_ERROR) {\n        return NGX_CHAIN_ERROR;\n    }\n\n    if (ngx_http_v2_flow_control(h2c, stream) == NGX_DECLINED) {\n        fc->write->active = 1;\n        fc->write->ready = 0;\n        return in;\n    }\n}\n...\nif (in && ngx_http_v2_flow_control(h2c, stream) == NGX_DECLINED) {\n    fc->write->active = 1;\n    fc->write->ready = 0;\n}', 'explanation': 'The function checks the underlying transport’s flow-control mechanism (via ngx_http_v2_flow_control) and, when it declines, it marks the connection as not immediately writable (by setting fc->write->active and fc->write->ready flags) rather than terminating the connection. This behavior is aligned with the RFC requirement to allow flow-control mechanisms to resolve temporary overloads, which helps sustain persistent connections.'}}]","The function contains logic to adhere to the RFC guidance by respecting the transport's flow control. It actively checks if the connection’s send window allows more data to be sent and defers data transmission if flow-control conditions are not met, thereby not immediately closing the connection. However, it does not explicitly implement all aspects of maintaining a persistent connection or handling all associated conditions (such as client monitoring for errors during transmission), so it only partially matches the spec constraints.",success,
4145,ngx_http_v2_string_encode,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that within a message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. The provided function (ngx_http_v2_string_encode) is solely focused on encoding strings either by Huffman encoding or raw encoding. It does not include any logic that verifies or restricts the generation of protocol elements based on sender role or conforms to role-based restrictions as described (for example, ensuring that only allowed protocol elements per role are generated). Therefore, this function does not visibly address the labeled RFC constraint.",success,
4147,ngx_http_v2_write_int,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'ngx_http_v2_write_int' only encodes an integer into a variable-length format for HTTP/2 and does not implement any logic regarding role-based protocol element generation or syntax verification as required by the RFC specification. There is no code within this function to check or restrict the generation of protocol elements based on sender roles (e.g., conditions like C1 or actions like A1), hence it does not address the specified HTTP RFC constraint.",success,
4248,ngx_ssl_shutdown,Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection.,325,Fully Matches,"[{'C1': {'code': 'for ( ;; ) {\n    /* For bidirectional shutdown, SSL_shutdown() needs to be called\n     * twice: first call sends the ""close notify"" alert and returns 0,\n     * second call waits for the peer\'s ""close notify"" alert.\n     */\n    n = SSL_shutdown(c->ssl->connection);\n    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, ""SSL_shutdown: %d"", n);\n    if (n == 1) {\n        goto done;\n    }\n    if (n == 0 && tries-- > 1) {\n        continue;\n    }\n    ...\n}', 'explanation': ""The function initiates an exchange of closure alerts by calling SSL_shutdown in a loop. The first call sends the 'close notify' alert and subsequent logic ensures that the function attempts to complete the bidirectional shutdown by waiting for the peer's 'close notify' alert. This directly implements the requirement that the server must initiate an exchange of closure alerts before closing the connection.""}}]","The code in ngx_ssl_shutdown explicitly implements the shutdown protocol as specified in the RFC by calling SSL_shutdown to send and then wait for a response, fulfilling the condition that the server must attempt to initiate an exchange of closure alerts prior to closing the connection. All logic required is contained within the function itself.",success,
4277,ngx_ssl_get_certificate,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Does Not Match,[],"The RFC specification requires that a sender must not generate a bare CR (a CR not immediately followed by LF). In this function, there is no logic that inspects CR characters or ensures that any CR is followed by an LF. The function only processes LF characters by adding a tab character after each LF, but it does not check for or handle bare CRs. Therefore, the function does not address the RFC requirement within its own logic.",success,
5181,ngx_parse_inet_url,A recipient that processes such a URI reference MUST reject it as invalid.,226,Fully Matches,"[{'C1': {'code': 'if (len == 0) {\n    u->err = ""no host"";\n    return NGX_ERROR;\n}', 'explanation': 'This segment explicitly checks if the length of the host part is zero and, if so, sets an error and returns NGX_ERROR. This behavior directly corresponds to the RFC requirement that a recipient MUST reject an https URI that has an empty host identifier.'}}]",The function implements the necessary logic to reject URIs with an empty host by verifying the host length and returning an error if it is zero. This visible handling fulfills the specified RFC constraint about rejecting a URI with an empty host identifier.,success,
5181,ngx_parse_inet_url,A recipient that processes such a URI reference MUST reject it as invalid.,224,Fully Matches,"[{'C1': {'code': 'len = last - host;\n\nif (len == 0) {\n    u->err = ""no host"";\n    return NGX_ERROR;\n}', 'explanation': ""The code checks if the host part (from 'host' to 'last') has zero length. If it is empty, it sets an error message ('no host') and returns an error, thereby rejecting a URI with an empty host identifier in accordance with the RFC requirement.""}}]","The specification requires that a URI reference with an empty host identifier must be rejected as invalid. Within the function, the check 'if (len == 0)' accomplishes this, ensuring that an empty host is caught and results in NGX_ERROR. No other dependencies or external functions are required for this rejection, so the function itself directly implements the constraint.",success,
5181,ngx_parse_inet_url,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': '...\nno_port:\n\n    u->err = NULL;\n    u->no_port = 1;\n    u->port = u->default_port;\n    sin->sin_port = htons(u->default_port);\n    u->last_port = 0;', 'explanation': 'This segment explicitly handles the case when no port is provided by setting the port to the default_port, thereby interpreting the absence of an explicit port as meaning the request was received on the default port. This directly implements the RFC requirement.'}}]","The function ngx_parse_inet_url contains logic that checks for the presence of a port in the input URL. If no port is provided, the code path under the 'no_port' label assigns u->port and sin->sin_port with the value of u->default_port. This behavior aligns with the RFC specification that states a recipient may interpret a missing port as meaning the message was received on the default port for the protocol. Thus, the implementation fully meets the specified RFC constraint.",success,
5487,ngx_time_update,"When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.",245,Fully Matches,"[{'A1': {'code': 'p0 = &cached_http_time[slot][0];\n\n(void) ngx_sprintf(p0, ""%s, %02d %s %4d %02d:%02d:%02d GMT"",\n                       week[gmt.ngx_tm_wday], gmt.ngx_tm_mday,\n                       months[gmt.ngx_tm_mon - 1], gmt.ngx_tm_year,\n                       gmt.ngx_tm_hour, gmt.ngx_tm_min, gmt.ngx_tm_sec);', 'explanation': 'This segment generates an HTTP timestamp string using the IMF-fixdate format required by the RFC. It formats the date as ""Day, DD Mon YYYY HH:MM:SS GMT"", which directly meets the specification that all timestamps in HTTP-date fields must use the IMF-fixdate format.'}}]","The function 'ngx_time_update' constructs several timestamp strings. Specifically, the segment that writes to 'cached_http_time' uses a format string that exactly matches the IMF-fixdate format. This shows that the function itself is fully responsible for implementing the spec condition that mandates using the IMF-fixdate for HTTP-date values.",success,
5490,ngx_http_time,"When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.",245,Fully Matches,"[{'C1': {'code': 'return ngx_sprintf(buf, ""%s, %02d %s %4d %02d:%02d:%02d GMT"", week[tm.ngx_tm_wday], tm.ngx_tm_mday, months[tm.ngx_tm_mon - 1], tm.ngx_tm_year, tm.ngx_tm_hour, tm.ngx_tm_min, tm.ngx_tm_sec);', 'explanation': ""This code segment formats the timestamp according to the IMF-fixdate format. It correctly places the weekday, day, month, year, time components, and the 'GMT' literal, fulfilling the spec requirement.""}}]","The function 'ngx_http_time' generates a timestamp string using ngx_sprintf with a format string that adheres to the IMF-fixdate format as specified by the RFC. The format string includes the necessary components in the correct order and with proper formatting, thereby fully meeting the RFC specification within the function's own logic.",success,
5494,ngx_parse_http_time,A recipient that parses a timestamp value in an HTTP field MUST accept all three HTTP-date formats.,244,Fully Matches,"[{'C1': {'code': ""for (p = value; p < end; p++) {\n    if (*p == ',') {\n        break;\n    }\n\n    if (*p == ' ') {\n        fmt = isoc;\n        break;\n    }\n}\n\n... // Later logic distinguishes between formats (rfc822, rfc850, isoc)"", 'explanation': 'This code segment inspects the HTTP-date string to determine which of the three supported formats is present by looking for a comma or space, thereby enabling parsing of all three HTTP-date formats as required by the spec.'}}, {'A1': {'code': ""if (fmt != isoc) {\n    if (*p < '0' || *p > '9' || *(p + 1) < '0' || *(p + 1) > '9') {\n        return NGX_ERROR;\n    }\n\n    day = (*p - '0') * 10 + (*(p + 1) - '0');\n    p += 2;\n\n    if (*p == ' ') {\n        if (end - p < 18) {\n            return NGX_ERROR;\n        }\n        fmt = rfc822;\n\n    } else if (*p == '-') {\n        fmt = rfc850;\n\n    } else {\n        return NGX_ERROR;\n    }\n\n    p++;\n}\n\n... // Separate branches for parsing month, year, time components according to rfc822, rfc850, or isoc formats"", 'explanation': 'This section of the code implements different parsing branches for the two obsolete formats (rfc850 and asctime represented as isoc) and the current HTTP-date format (rfc822/IMF-fixdate). This satisfies the action requirement of accepting all three HTTP-date formats.'}}]","The function 'ngx_parse_http_time' contains explicit logic to detect and parse three distinct HTTP-date formats. It uses an enum to differentiate between rfc822 (IMF-fixdate), rfc850 (obsolete), and asctime (isoc) formats, and implements separate parsing routines for each. This clearly addresses the specification that a recipient must accept all three HTTP-date formats, and thus the function fully meets the spec constraints by itself.",success,
5494,ngx_parse_http_time,"Recipients of a timestamp value in rfc850-date format, which uses a two-digit year, MUST interpret a timestamp that appears to be more than 50 years in the future as representing the most recent year in the past that had the same last two digits.",246,Partially Matches,[],"The function clearly implements parsing of various HTTP date formats including rfc850. In the rfc850 branch, it converts a two‐digit year to a full year using a fixed pivot (i.e. adding 2000 if the two-digit year is less than 70, otherwise adding 1900). However, the RFC specifies that recipients must interpret a two‐digit year that appears to be more than 50 years in the future (relative to the current time) as the most recent matching past year. The function does not perform any check against the current time or a dynamically calculated 50-year threshold; it only uses a fixed pivot. Therefore, while some logic for handling rfc850 dates exists, it does not fully meet the RFC requirement regarding future timestamps.",success,
5710,ngx_mail_auth_http_write_handler,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (wev->timedout) {\n    ngx_log_error(NGX_LOG_ERR, wev->log, NGX_ETIMEDOUT,\n                  ""auth http server %V timed out"", ctx->peer.name);\n    ngx_close_connection(c);\n    ngx_destroy_pool(ctx->pool);\n    ngx_mail_session_internal_server_error(s);\n    return;\n}', 'explanation': 'This segment actively checks for a timeout event and proceeds to close the connection. This behavior follows the RFC which states that a client, server, or proxy MAY close the transport connection at any time.'}}, {'A1': {'code': 'if (n == NGX_ERROR) {\n    ngx_close_connection(c);\n    ngx_destroy_pool(ctx->pool);\n    ngx_mail_session_internal_server_error(s);\n    return;\n}', 'explanation': 'Here the function handles send errors by closing the connection, which is in line with the RFC’s allowance for connection closure on error conditions.'}}]","The function demonstrates a visible attempt to follow the RFC's guidance regarding connection closure by checking for timeout conditions and send errors, and then closing the connection accordingly. However, while it handles scenarios for forced closure (e.g., on timeout or error), it does not cover all aspects of a graceful close or monitor for remote closure signals as mentioned in the broader context of the spec. Thus, it only partially matches the full set of implied behaviors in the RFC.",success,
5711,ngx_mail_auth_http_read_handler,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (rev->timedout) {\n    ngx_log_error(NGX_LOG_ERR, rev->log, NGX_ETIMEDOUT,\n                  ""auth http server %V timed out"", ctx->peer.name);\n    ngx_close_connection(c);\n    ngx_destroy_pool(ctx->pool);\n    ngx_mail_session_internal_server_error(s);\n    return;\n}', 'explanation': 'This code block detects a timeout event (a condition where a connection might need to be closed) and immediately closes the connection. It directly implements the allowed behavior of closing the transport connection when a timeout occurs.'}}, {'A1': {'code': 'if (n > 0) {\n    ctx->response->last += n;\n    ctx->handler(s, ctx);\n    return;\n}\n\nif (n == NGX_AGAIN) {\n    return;\n}\n\nngx_close_connection(c);\nngx_destroy_pool(ctx->pool);\nngx_mail_session_internal_server_error(s);', 'explanation': 'This segment handles cases where the read fails or returns an error (other than NGX_AGAIN), leading to a connection closure. The function follows the RFC allowance to close the connection under error conditions.'}}]","The function implements connection closure in two key scenarios: when a timeout is detected and when a read error occurs (other than simply waiting for more data). These code segments address part of the RFC specification that states a client, server, or proxy may close the transport connection at any time. However, the function does not incorporate more comprehensive or graceful closure processes (such as clean shutdown signaling beyond immediate closure), so it only partially meets the overall intent of the spec.",success,
5712,ngx_mail_auth_http_ignore_status_line,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'for (p = ctx->response->pos; p < ctx->response->last; p++) {\n    ch = *p;\n\n    switch (state) {\n\n    /* ""HTTP/"" */\n    case sw_start:\n        if (ch == \'H\') {\n            state = sw_H;\n            break;\n        }\n        goto next;\n\n    case sw_H:\n        if (ch == \'T\') {\n            state = sw_HT;\n            break;\n        }\n        goto next;\n\n    case sw_HT:\n        if (ch == \'T\') {\n            state = sw_HTT;\n            break;\n        }\n        goto next;\n\n    case sw_HTT:\n        if (ch == \'P\') {\n            state = sw_HTTP;\n            break;\n        }\n        goto next;\n\n    case sw_HTTP:\n        if (ch == \'/\') {\n            state = sw_skip;\n            break;\n        }\n        goto next;', 'explanation': ""This segment implements a defensive state machine that checks for the expected 'HTTP/' prefix. Although it does not enforce explicit length limitations, it follows the guideline of parsing marginally conformant protocol elements by validating the expected characters.""}}, {'A1': {'code': 'case sw_skip:\n    switch (ch) {\n    case CR:\n        state = sw_almost_done;\n        break;\n    case LF:\n        goto done;\n    }\n    break;\n\ncase sw_almost_done:\n    if (ch == LF) {\n        goto done;\n    }\n    ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                  ""auth http server %V sent invalid response"",\n                  ctx->peer.name);\n    ngx_close_connection(ctx->peer.connection);\n    ngx_destroy_pool(ctx->pool);\n    ngx_mail_session_internal_server_error(s);\n    return;', 'explanation': 'This code segment handles deviations in the expected CR/LF sequence, thus enforcing a level of error checking in line with a defensive parsing approach. It logs errors and terminates the connection when the status line does not meet the minimal HTTP format expectations.'}}]","The function attempts to parse the HTTP status line in a defensive manner by using a state machine to sequentially match the expected 'HTTP/' prefix and handling the end-of-line markers. It includes error handling for malformed responses (i.e., improper CR/LF handling) by logging errors and closing connections. However, it does not implement additional checks such as enforcing a maximum buffer size, which is part of the broader defensive parsing expectations in the RFC context. Thus, while key aspects of defensive parsing are present, not all potential constraints from the RFC specification are fully implemented in this function alone.",success,
5712,ngx_mail_auth_http_ignore_status_line,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Fully Matches,"[{'C1': {'code': 'case sw_skip:\n    switch (ch) {\n    case CR:\n        state = sw_almost_done;\n        break;\n    case LF:\n        goto done;\n    }', 'explanation': ""This segment addresses the RFC's allowance that a recipient may recognize a single LF as a line terminator and ignore any preceding CR, by immediately completing the line processing when LF is encountered and handling CR by transitioning to expect LF.""}}, {'A1': {'code': 'case sw_almost_done:\n    if (ch == LF) {\n        goto done;\n    }\n    ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                  ""auth http server %V sent invalid response"",\n                  ctx->peer.name);\n    ngx_close_connection(ctx->peer.connection);\n    ngx_destroy_pool(ctx->pool);\n    ngx_mail_session_internal_server_error(s);\n    return;', 'explanation': 'This segment enforces that any CR not immediately followed by an LF is treated as an error, which complies with the RFC requirement that a bare CR should be considered invalid.'}}]","The function implements the key RFC requirements by using a state machine to detect the proper HTTP status line termination. It correctly handles both CRLF and lone LF terminators, and flags a bare CR (one not followed by LF) as an error. Therefore, the code function fully addresses the specified RFC constraints as defined in the provided spec.",success,
5712,ngx_mail_auth_http_ignore_status_line,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'for (p = ctx->response->pos; p < ctx->response->last; p++) {\n    ch = *p;\n\n    switch (state) {\n\n    /* ""HTTP/"" */\n    case sw_start:\n        if (ch == \'H\') {\n            state = sw_H;\n            break;\n        }\n        goto next;\n\n    case sw_H:\n        if (ch == \'T\') {\n            state = sw_HT;\n            break;\n        }\n        goto next;\n\n    case sw_HT:\n        if (ch == \'T\') {\n            state = sw_HTT;\n            break;\n        }\n        goto next;\n\n    case sw_HTT:\n        if (ch == \'P\') {\n            state = sw_HTTP;\n            break;\n        }\n        goto next;\n\n    case sw_HTTP:\n        if (ch == \'/\') {\n            state = sw_skip;\n            break;\n        }\n        goto next;', 'explanation': ""This segment implements a state machine to parse the received status line, ensuring it begins with the 'HTTP/' prefix as required by the specification. It shows that the function is attempting to interpret the protocol element according to its defined semantics.""}}, {'A1': {'code': 'case sw_almost_done:\n    if (ch == LF) {\n        goto done;\n    }\n\n    ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                  ""auth http server %V sent invalid response"",\n                  ctx->peer.name);\n    ngx_close_connection(ctx->peer.connection);\n    ngx_destroy_pool(ctx->pool);\n    ngx_mail_session_internal_server_error(s);\n    return;', 'explanation': ""This segment handles the scenario where the end-of-status-line does not match the expected LF after a CR. By logging the error, closing the connection, cleaning up resources, and returning an error state, the function attempts an error recovery or handling mechanism in line with the RFC's allowance for recovering from an invalid construct.""}}]","The function uses a state machine to interpret the HTTP status line format, checking for the 'HTTP/' prefix and subsequently scanning for the proper carriage return and line feed to mark the end of the status line. This behavior partially fulfills the specification requirement to interpret protocol elements according to defined semantics. Moreover, in cases where the status line is not properly terminated, the function performs error handling (logging an error, closing the connection, releasing resources) in an attempt to handle or reject an invalid construct. However, since not all aspects of the comprehensive RFC semantics (including handling of extensions or varied error recovery strategies) are fully managed within this isolated function, the match to the RFC is partial.",success,
5715,ngx_mail_auth_http_parse_header_line,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': ""case sw_start:\n    switch (ch) {\n    case CR:\n        ctx->header_end = p;\n        state = sw_header_almost_done;\n        break;\n    case LF:\n        ctx->header_end = p;\n        goto header_done;\n    default:\n        state = sw_name;\n        ctx->header_name_start = p;\n        c = (u_char) (ch | 0x20);\n        if (c >= 'a' && c <= 'z') {\n            break;\n        }\n        if (ch >= '0' && ch <= '9') {\n            break;\n        }\n        return NGX_ERROR;\n    }"", 'explanation': 'This segment implements defensive parsing by examining the first character of the header line and only accepting characters that fall within a marginal set of expectations (letters and digits). It immediately returns an error for unexpected characters, reflecting a defensive approach as required by the spec.'}}, {'A1': {'code': 'for (p = ctx->response->pos; p < ctx->response->last; p++) {\n    ch = *p;\n    switch (state) {\n        ... // various cases handling sw_name, sw_space_before_value, sw_value, etc.\n    }\n}\n\nctx->response->pos = p;\nctx->state = state;\n\nreturn NGX_AGAIN;', 'explanation': ""This loop and its state machine structure ensure that the protocol element is parsed strictly within the limits of the available buffer. It deliberately checks for proper termination (CR, LF) and incomplete data (returning NGX_AGAIN), which aligns with the spec's recommendation for defensive and buffer‐aware parsing.""}}]","The provided function uses a state machine to parse HTTP header lines defensively. It checks each character against a limited acceptable set, handles different states such as header names, spaces, and header values, and returns errors when unexpected characters are encountered. In addition, it properly handles partial input by returning NGX_AGAIN, ensuring that parsing is done without assuming full compliance with the anticipated ABNF grammar. Taken together, these elements fully match the RFC specification's guidance for a defensive parsing approach.",success,
5715,ngx_mail_auth_http_parse_header_line,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Fully Matches,"[{'C1': {'code': 'case LF:\n    ctx->header_end = p;\n    goto header_done;', 'explanation': ""The function directly accepts a lone LF as a valid line terminator by setting header_end and finalizing header parsing. This complies with the spec's allowance to recognize a single LF as a line terminator.""}}, {'A1': {'code': 'case CR:\n    ctx->header_end = p;\n    state = sw_header_almost_done;\n\n... \n\ncase sw_header_almost_done:\n    switch (ch) {\n    case LF:\n        goto header_done;\n    default:\n        return NGX_ERROR;\n    }', 'explanation': ""The function handles CR by moving to a state (sw_header_almost_done) which requires that a CR must immediately be followed by a LF. If a bare CR (CR not immediately followed by LF) is encountered, the function returns an error, meeting the spec's requirement to treat such a CR as invalid.""}}]","The function implements a state machine for parsing header lines and visibly addresses the key aspects of the spec constraints. It accepts both CRLF and a bare LF as valid terminators by explicitly checking for LF in multiple states, and it treats a CR not immediately followed by LF as an error. Thus, the code function itself fully implements the specified behavior as per the provided RFC constraints.",success,
5715,ngx_mail_auth_http_parse_header_line,"It MUST conform to the field-name syntax defined in Section 5.1, and it SHOULD be restricted to just letters, digits, and hyphen ('-') characters, with the first character being a letter.",293,Partially Matches,"[{'C2': {'code': ""case sw_name:\n    c = (u_char) (ch | 0x20);\n    if (c >= 'a' && c <= 'z') {\n        break;\n    }\n    if (ch == ':') {\n        ctx->header_name_end = p;\n        state = sw_space_before_value;\n        break;\n    }\n    if (ch == '-') {\n        break;\n    }\n    if (ch >= '0' && ch <= '9') {\n        break;\n    }\n    if (ch == CR) {\n        ctx->header_name_end = p;\n        ctx->header_start = p;\n        ctx->header_end = p;\n        state = sw_almost_done;\n        break;\n    }\n    if (ch == LF) {\n        ctx->header_name_end = p;\n        ctx->header_start = p;\n        ctx->header_end = p;\n        goto done;\n    }\n    return NGX_ERROR;"", 'explanation': ""This segment checks that characters in the header name (beyond the first character) are restricted to a-z, 0-9, or '-' and uses ':' to terminate the name, which aligns with the allowed characters (letters, digits, and hyphen).""}}]","The RFC specification requires that the field name must conform to a specific syntax: it should be limited to letters, digits, and hyphen characters, with the first character being a letter. The function implements a state machine that parses a header line and enforces that the characters (in the sw_name phase) are among those allowed. However, in the sw_start state, when processing the first character, the code permits both letters and digits (allowing a digit as the first character) instead of strictly enforcing that the first character be a letter. Thus, while the function correctly checks most of the allowed characters (meeting C2), it fails to fully implement the condition for the first character, resulting in a partial match of the spec constraints.",success,
5715,ngx_mail_auth_http_parse_header_line,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': ""case sw_space_before_value:\n    switch (ch) {\n    case ' ':\n        break;\n    case CR:\n        ctx->header_start = p;\n        ctx->header_end = p;\n        state = sw_almost_done;\n        break;\n    case LF:\n        ctx->header_start = p;\n        ctx->header_end = p;\n        goto done;\n    default:\n        ctx->header_start = p;\n        state = sw_value;\n        break;\n    }"", 'explanation': 'This segment skips leading spaces before the header value by not updating the header_start until a non-space character is reached, thereby excluding leading whitespace from evaluation.'}}, {'A1': {'code': ""case sw_value:\n    switch (ch) {\n    case ' ':\n        ctx->header_end = p;\n        state = sw_space_after_value;\n        break;\n    case CR:\n        ctx->header_end = p;\n        state = sw_almost_done;\n        break;\n    case LF:\n        ctx->header_end = p;\n        goto done;\n    }"", 'explanation': 'This part marks the end of the header value upon encountering a space (or CR/LF), effectively trimming any trailing whitespace before the field value is further processed.'}}]","The function implements a state machine to parse a header line and explicitly handles whitespace: it skips over leading spaces before the actual header value (in the sw_space_before_value state) and stops reading the header value when trailing whitespace is encountered (in the sw_value and sw_space_after_value states). Thus, it directly implements the requirement from the RFC specification to exclude whitespace prior to evaluating the field value.",success,
5715,ngx_mail_auth_http_parse_header_line,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'state = ctx->state;\nfor (p = ctx->response->pos; p < ctx->response->last; p++) {\n    ch = *p;\n    switch (state) {\n        case sw_start:\n            ...\n        case sw_name:\n            ...\n        // (other state cases)\n    }\n}\nctx->state = sw_start;', 'explanation': 'This portion of the code implements a state‐machine parser that reads and interprets the header line according to specified semantics. In doing so, it attempts to follow the requirement to interpret received protocol elements as defined in the RFC.'}}, {'A1': {'code': 'case sw_almost_done:\n    switch (ch) {\n    case LF:\n         goto done;\n    default:\n         return NGX_ERROR;\n    }', 'explanation': ""This segment handles the end of the header line, including error conditions and some level of recovery (via transition to the 'done' label) when minor deviations (such as unexpected line endings) occur. It shows an attempt to complete the parsing even when nonideal constructs are encountered.""}}]","The function implements a state-machine to parse header lines from an HTTP response in a manner that partially reflects the RFC requirement to interpret protocol elements by their semantics. It handles standard transitions and some error conditions (thereby attempting recovery when possible). However, it does not cover the full breadth of error recovery or configuration‐based decision‐making as indicated in the RFC's broader requirements. In isolation, it only addresses a subset of the applicable conditions and actions, thus the outcome is 'Partially Matches.'",success,
5718,ngx_mail_auth_http_create_request,"A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the ""message/http"" media type.",301,Fully Matches,"[{'C1': {'code': 'b->last = ngx_cpymem(b->last, ""GET "", sizeof(""GET "") - 1);\n...\n*b->last++ = CR; *b->last++ = LF;  // Repeated for each header line\n...\nif (ahcf->header.len) {\n    b->last = ngx_copy(b->last, ahcf->header.data, ahcf->header.len);\n}\n/* add ""\\r\\n"" at the header end */\n*b->last++ = CR; *b->last++ = LF;', 'explanation': 'The function constructs an HTTP request header by manually appending header fields and terminating each with a CRLF. It never introduces extra CRLF characters or folding whitespace into a single header field, thereby ensuring that no obs-fold (line folding) occurs. Additionally, fields that could include user data (e.g., login, passwd) are escaped via ngx_mail_auth_http_escape, which further mitigates inadvertent line folding.'}}]","The provided function builds the HTTP request message in a controlled manner. It explicitly constructs each header field as a single, unsplit line terminated by CRLF without inserting any additional whitespace or CRLF sequences that would constitute line folding. This approach directly satisfies the constraint from the RFC that the sender must not generate a message with line folding, thereby fully matching the condition (labeled C1) from the spec.",success,
5718,ngx_mail_auth_http_create_request,A sender MUST NOT send whitespace between the start-line and the first header field.,295,Fully Matches,"[{'C1': {'code': 'b->last = ngx_cpymem(b->last, ""GET "", sizeof(""GET "") - 1);\n...\nb->last = ngx_cpymem(b->last, "" HTTP/1.0"" CRLF, sizeof("" HTTP/1.0"" CRLF) - 1);\n...\nb->last = ngx_cpymem(b->last, ""Host: "", sizeof(""Host: "") - 1);', 'explanation': 'The function constructs the HTTP request-line and immediately appends the first header field without inserting any additional whitespace or empty lines between them. The request-line ends with CRLF as required, and the next header (Host:) is placed directly after that CRLF, thus ensuring compliance with the RFC requirement.'}}]","The code function builds the HTTP request by writing the 'GET <URI> HTTP/1.0' request-line followed by a CRLF, and then immediately writes the 'Host:' header field. There is no extra whitespace or empty line inserted between the request-line and the first header field, fulfilling the specification that the sender MUST NOT send whitespace between the start-line and the first header field.",success,
5718,ngx_mail_auth_http_create_request,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (ngx_mail_auth_http_escape(pool, &s->login, &login) != NGX_OK) {\n    return NULL;\n}\n\nif (ngx_mail_auth_http_escape(pool, &s->passwd, &passwd) != NGX_OK) {\n    return NULL;\n}\n\n... \n\nb->last = ngx_cpymem(b->last, ""GET "", sizeof(""GET "") - 1);\nb->last = ngx_copy(b->last, ahcf->uri.data, ahcf->uri.len);\nb->last = ngx_cpymem(b->last, "" HTTP/1.0"" CRLF, sizeof("" HTTP/1.0"" CRLF) - 1);\n\n... \n\n(both the careful use of escape functions for login, passwd, and raw_cert as well as the controlled assembly of request line and headers using fixed strings and CRLF delimiters)', 'explanation': ""This function constructs an HTTP GET request and deliberately escapes certain input values (e.g. login, passwd, and certificate data) to avoid introducing characters that might violate the HTTP ABNF grammar. By assembling the request header with fixed tokens (such as 'GET ', ' HTTP/1.0', and CRLF), it attempts to conform to the RFC’s requirement that protocol elements follow the defined grammar. However, not every field (for instance, some header values) is explicitly verified or escaped within this function, so full assurance against generating non‐grammatical elements is not provided solely by the function itself.""}}]","The RFC constraint requires that a sender must not generate protocol elements that deviate from the defined ABNF grammar. This function attempts to meet that by assembling the HTTP request in a controlled manner (using fixed strings for method, HTTP version, and CRLF terminators) and by applying escape functions to sensitive fields (such as login and password). While those parts suggest an effort toward conforming to the grammar, the function does not universally validate or process every header field to ensure complete adherence. As a result, the code partially meets the constraint by addressing key elements directly, but it does not fully enforce the entire grammar as required by the RFC.",success,
5718,ngx_mail_auth_http_create_request,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Fully Matches,"[{'C1': {'code': 'b->last = ngx_cpymem(b->last, "" HTTP/1.0"" CRLF, sizeof("" HTTP/1.0"" CRLF) - 1);\n... \n*b->last++ = CR; *b->last++ = LF; // repeated multiple times for each header line', 'explanation': 'The function consistently appends a CR immediately followed by an LF every time it terminates a header line. Whether constructing the request-line (using constants like "" HTTP/1.0"" CRLF) or appending headers (using manual assignments *b->last++ = CR; *b->last++ = LF), the code ensures that no CR is left unpaired with an LF. This directly addresses the RFC requirement that a sender MUST NOT generate a bare CR.'}}]","The analyzed function explicitly constructs its HTTP request headers by joining strings and manually appending CRLF pairs for each header element. Every occurrence of the CR character is immediately followed by an LF, both in fixed strings and through explicit assignments, ensuring that no bare CR is generated within any protocol element. This meets the specification constraint outlined in the RFC regarding bare CR usage.",success,
5718,ngx_mail_auth_http_create_request,"It MUST conform to the field-name syntax defined in Section 5.1, and it SHOULD be restricted to just letters, digits, and hyphen ('-') characters, with the first character being a letter.",293,Partially Matches,"[{'C1': {'code': 'b->last = ngx_cpymem(b->last, ""Auth-Method: "", sizeof(""Auth-Method: "") - 1);\n...\nb->last = ngx_cpymem(b->last, ""Host: "", sizeof(""Host: "") - 1);', 'explanation': 'The function constructs the HTTP request using hardcoded header field names (such as ""Host"", ""Auth-Method"", ""Auth-User"", etc.) which, by their literal values, conform to the RFC field-name syntax (starting with a letter and only containing letters, digits, and hyphen characters). This demonstrates an implicit compliance with Condition C1. However, there is no dynamic validation or explicit enforcement within the function, and the other spec requirement regarding the field ""Status"" is not addressed.'}}]","The function builds an HTTP request by concatenating literal header field names and values. The hardcoded header names (e.g., ""Host"", ""Auth-Method"", ""Auth-User"", and others) inherently meet the RFC’s requirement for field-name syntax (Condition C1). However, since the spec also mandates a status field with specific allowable values and there is no verification logic for dynamic field names or checking of a status value in this function, only part of the spec constraints are visibly handled in the function. Therefore, the function only partially implements the HTTP RFC requirements as specified.",success,
5718,ngx_mail_auth_http_create_request,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,[],"The RFC constraint requires that a sender must not generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. In the function, we observe that the construction of the HTTP request is done conditionally based on input values (for example, SMTP‐related headers are only added if s->auth_method equals NGX_MAIL_AUTH_NONE). Also, user-supplied data (login, password, etc.) is escaped before being included. This indicates some concern for producing a valid request. However, the function does not include explicit logic ensuring that protocol elements disallowed for the sender’s role are omitted; it merely relies on configuration (s->auth_method and other flags) to decide which headers to add. Thus, while the function attempts to address the message formation, it does not fully enforce the role‐based restrictions mandated by the RFC solely within its own logic. As a result, it only partially corresponds to the spec constraint.",success,
5721,ngx_mail_auth_http_merge_conf,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function 'ngx_mail_auth_http_merge_conf' only merges configuration settings and constructs header strings from the provided configuration. It does not implement any logic that checks or enforces the RFC requirement that a sender must not generate protocol elements or syntax alternatives that are reserved for other roles. There is no code within this function that validates the role of the sender or restricts generation of protocol elements based on the sender's role, so no spec constraints (e.g., C1, A1) are visibly addressed by this function in isolation.",success,
5721,ngx_mail_auth_http_merge_conf,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Fully Matches,"[{'C1': {'code': ""for (i = 0; i < conf->headers->nelts; i++) {\n    p = ngx_cpymem(p, header[i].key.data, header[i].key.len);\n    *p++ = ':'; *p++ = ' ';\n    p = ngx_cpymem(p, header[i].value.data, header[i].value.len);\n    *p++ = CR; *p++ = LF;\n}"", 'explanation': 'This code snippet constructs each header line by appending a CR character immediately followed by an LF, ensuring that no bare CR is generated in accordance with the RFC specification.'}}]","The function constructs header strings intended for HTTP communication by concatenating the header key, ': ', the header value, and finally a CRLF pair. This guarantees that if a CR is generated, it is always immediately followed by an LF, fulfilling the RFC requirement that a sender must not generate a bare CR. Therefore, the implementation within this function visibly addresses the spec constraint (C1).",success,
5722,ngx_mail_auth_http,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'u.default_port = 80;', 'explanation': 'This line sets the default port to 80 if none is provided in the URL, directly implementing the RFC requirement that a missing port be interpreted as the default port for the received-protocol.'}}]","The provided function sets the default port by assigning u.default_port = 80 and subsequently relies on ngx_parse_url to process the URL. This directly matches the RFC specification that states if a port is not provided, it may be interpreted as having been received on the default port for the protocol. Therefore, the function visibly addresses the labeled specification constraint.",success,
5722,ngx_mail_auth_http,"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",225,Does Not Match,[],"The provided function does not address the spec constraint that a sender MUST NOT generate an ""https"" URI with an empty host identifier. The function only handles URIs beginning with ""http://"" and does not contain any explicit checks or logic for https URIs, nor does it verify if the host identifier is empty for https URIs. Therefore, none of the labeled spec constraints are implemented in this function.",success,
5732,ngx_mail_proxy_protocol_handler,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (rev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");\n    c->timedout = 1;\n    ngx_mail_close_connection(c);\n    return;\n}', 'explanation': 'This code segment checks if the connection timed out and then proceeds to close the connection, which is in line with the RFC’s allowance that the client, server, or proxy may close the connection at any time.'}}, {'A1': {'code': 'if (n == -1) {\n    if (err == NGX_EAGAIN) {\n        ...\n        return;\n    }\n    ngx_connection_error(c, err, ""recv() failed"");\n    ngx_mail_close_connection(c);\n    return;\n}\n\n...\nif (p == NULL) {\n    ngx_mail_close_connection(c);\n    return;\n}\n\nif (c->recv(c, buf, size) != (ssize_t) size) {\n    ngx_mail_close_connection(c);\n    return;\n}\n\nif (ngx_mail_realip_handler(s) != NGX_OK) {\n    ngx_mail_close_connection(c);\n    return;\n}', 'explanation': 'Multiple checks for errors, including failed recv, unsuccessful reads, and other processing errors, all result in calling ngx_mail_close_connection. These actions implement the possibility to close the connection as permitted by the RFC.'}}]","The function includes logic to detect error and timeout conditions and immediately closes the connection in these cases. This behavior aligns with the RFC requirement that a client, server, or proxy MAY close the transport connection at any time. However, not all aspects of the spec context—such as the recommendation to issue a graceful close when intending to time out and handling persistent connections—are fully implemented within this function alone, which is why the match is considered partial.",success,
5732,ngx_mail_proxy_protocol_handler,A client or server that wishes to time out SHOULD issue a graceful close on the connection.,314,Partially Matches,"[{'C1': {'code': 'if (rev->timedout) {\n    ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out"");\n    c->timedout = 1;\n    ngx_mail_close_connection(c);\n    return;\n}', 'explanation': ""This segment checks whether the event has timed out and, if so, logs the timeout and calls ngx_mail_close_connection, which is an attempt to close the connection in a controlled (graceful) manner, aligning with the spec's requirement that a client or server wishing to time out should issue a graceful close.""}}]","The function partially meets the specification by handling the timeout condition and initiating a connection close. However, the RFC also emphasizes other aspects such as continuously monitoring for remote closure signals and handling them appropriately. Since this function only addresses the timeout case (and not the full range of connection closure monitoring and graceful shutdown behaviors as specified), the implementation in this function only partially matches the spec constraints.",success,
