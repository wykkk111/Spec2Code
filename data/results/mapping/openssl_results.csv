function_id,function_name,sr_content,sr_index,outcome,met_constrains,explanation,status,api_response
5670,ssl3_setup_key_block,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function 'ssl3_setup_key_block' is concerned solely with key block setup and generation. It obtains the cipher and digest (via ssl_cipher_get_evp), assigns them to the session structure, and computes parameters for key block generation. However, there is no visible logic within this function that inspects or filters out RC4 cipher suites or checks for cipher strength requirements (e.g., ensuring a minimum of 112 bits). Therefore, the function does not address the TLS RFC specification conditions related to not offering or negotiating RC4 cipher suites or low strength ciphers.",success,
5679,ssl3_alert_code,"If the decryption fails, the receiver MUST terminate the connection with a ""bad_record_mac"" alert.",293,Partially Matches,"[{'C1': {'code': 'case SSL_AD_DECRYPTION_FAILED:\n        return SSL3_AD_BAD_RECORD_MAC;', 'explanation': ""This code segment maps a decryption failure (SSL_AD_DECRYPTION_FAILED) to the 'bad_record_mac' alert (SSL3_AD_BAD_RECORD_MAC) as required by the RFC. However, the function also handles the record overflow case incorrectly by mapping it to the same 'bad_record_mac' alert.""}}]","The function attempts to implement part of the TLS RFC requirement by ensuring that if decryption fails, the connection is terminated with a 'bad_record_mac' alert, as seen in the SSL_AD_DECRYPTION_FAILED case. However, it does not fully meet the spec because it also maps SSL_AD_RECORD_OVERFLOW to SSL3_AD_BAD_RECORD_MAC rather than using a distinct 'record_overflow' alert. This partial handling means that, while some conditions are addressed within the function, not all specified constraints are properly implemented solely in this code.",success,
5679,ssl3_alert_code,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function only maps SSL/TLS alert codes to corresponding internal codes. It does not implement or attempt to enforce any policy regarding cipher suite selection, specifically the prohibition against using RC4 cipher suites or cipher suites with insufficient strength (as specified by the TLS RFC). In other words, there is no code within this function that addresses the spec constraint to not offer or negotiate RC4 cipher suites (or weak ciphers), so it does not match the TLS RFC requirements.",success,
5679,ssl3_alert_code,"Sending this alert is OPTIONAL; servers MAY instead choose to send a ""decrypt_error"" alert to merely indicate an invalid PSK identity.",324,Partially Matches,"[{'A1': {'code': 'case SSL_AD_UNKNOWN_PSK_IDENTITY:\n    return TLS1_AD_UNKNOWN_PSK_IDENTITY;', 'explanation': ""This segment handles the unknown_psk_identity alert by mapping it to TLS1_AD_UNKNOWN_PSK_IDENTITY. This shows that when a PSK identity issue occurs the function returns an alert code. However, the RFC specifies that sending this alert is OPTIONAL and that servers MAY instead choose to send a 'decrypt_error' alert. The function does not provide any alternative branch (or conditional logic) to choose between sending TLS1_AD_UNKNOWN_PSK_IDENTITY versus a decrypt error, which is why the implementation only partially addresses the spec.""}}]","The function_body implements various alert code mappings and includes a branch for unknown_psk_identity. While it does address the condition where an unknown PSK identity is encountered (by returning TLS1_AD_UNKNOWN_PSK_IDENTITY), it does not implement any logic to optionally send a decrypt_error alert as allowed by the RFC. Since the RFC allows for this alternative and the function does not provide for it, the implementation only partially matches the specified TLS RFC behavior.",success,
5684,SSL_SESSION_print,"Because TLS 1.3 always hashes in the transcript up to the server Finished, implementations which support both TLS 1.3 and earlier versions SHOULD indicate the use of the Extended Master Secret extension in their APIs whenever TLS 1.3 is used.",376,Partially Matches,"[{'A1': {'code': 'if (BIO_printf(bp, ""    Extended master secret: %s\\n"",\n                   x->flags & SSL_SESS_FLAG_EXTMS ? ""yes"" : ""no"") <= 0)\n    goto err;', 'explanation': 'This code segment prints an indication of whether the Extended Master Secret extension was used by examining the session flag. It partially addresses the spec requirement to indicate the use of the Extended Master Secret when TLS 1.3 is in use, even though it does not enforce or set the flag specifically for TLS 1.3 within this function.'}}]","The TLS RFC specification mandates that implementations supporting both TLS 1.3 and earlier versions should indicate in their APIs the use of the Extended Master Secret extension whenever TLS 1.3 is used. In this function, the only visible handling related to this requirement is the printing of the Extended Master Secret status based on the SSL_SESS_FLAG_EXTMS flag. While this output serves as an indication, the function does not include any logic that guarantees that TLS 1.3 sessions always have the Extended Master Secret marked as used, nor does it conditionally enforce this behavior. Therefore, while the function does address the spec by showing the extension indicator (A1), it only partially matches the full intent of the specification.",success,
5684,SSL_SESSION_print,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided code function, SSL_SESSION_print, is solely responsible for printing session details such as protocols, cipher, session IDs, keys, and related metadata. It does not contain any logic related to the handling of early data retransmission or decision making based on ALPN negotiation. The TLS RFC specification requires that the implementation should not automatically resend early data unless the negotiated connection selects the same ALPN protocol, and that the application should control retransmission. There is no code within this function that addresses these conditions (e.g., checking ALPN protocol consistency before resending early data) or actions. Therefore, no labeled conditions (C1, C2, etc.) or actions (A1, A2, etc.) relevant to the TLS early data retransmission guideline are implemented in this function.",success,
5732,DTLSv1_listen,"Handshake messages MAY be coalesced into a single TLSPlaintext record or fragmented across several records, provided that:",274,Partially Matches,"[{'C1': {'code': 'if (rectype != SSL3_RT_HANDSHAKE) {\n    ERR_raise(ERR_LIB_SSL, SSL_R_UNEXPECTED_MESSAGE);\n    goto end;\n}', 'explanation': 'This code explicitly checks that the record type is a handshake (SSL3_RT_HANDSHAKE), which prevents interleaving of other record types among handshake messages as required by the RFC.'}}, {'A1': {'code': 'if (fragoff != 0 || fraglen > msglen) {\n    /* Non initial ClientHello fragment (or bad fragment) */\n    ERR_raise(ERR_LIB_SSL, SSL_R_FRAGMENTED_CLIENT_HELLO);\n    goto end;\n}', 'explanation': 'This check ensures that the ClientHello is not a fragmented message. The RFC allows handshake messages to be fragmented as long as they are not interleaved. Here the function deliberately accepts only non-fragmented (initial) ClientHello messages, thus partially addressing the RFC by enforcing a stricter policy.'}}]","The function partially implements the TLS RFC specification. It visibly enforces that only handshake records are processed (thus preventing interleaving with other record types) and checks for fragmentation by ensuring that a ClientHello is only accepted if it is not a subsequent fragment. However, while the RFC permits handshake messages to be fragmented and later reassembled, this function purposely rejects fragmented ClientHellos, meaning that it does not fully implement all aspects of the RFC's allowances for fragmentation.",success,
5732,DTLSv1_listen,-Handshake messages MUST NOT be interleaved with other record types.,275,Fully Matches,"[{'C1': {'code': 'if (rectype != SSL3_RT_HANDSHAKE) {\n            ERR_raise(ERR_LIB_SSL, SSL_R_UNEXPECTED_MESSAGE);\n            goto end;\n        }', 'explanation': 'This code segment explicitly checks that the record type is SSL3_RT_HANDSHAKE. If a different record type is encountered, it raises an unexpected_message error and terminates processing. This directly enforces the RFC requirement that handshake messages must not be interleaved with other record types.'}}]","The DTLSv1_listen function inspects the record header and verifies that only handshake records are processed (as shown in the check for 'rectype != SSL3_RT_HANDSHAKE'). By rejecting any non-handshake records, the code prevents the interleaving of handshake messages with any other record types. This behavior, implemented directly within the function, ensures that the specified TLS RFC constraint is met without relying on external dependencies.",success,
5732,DTLSv1_listen,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Fully Matches,"[{'C1': {'code': 'if (versmajor != DTLS1_VERSION_MAJOR) {\n    ERR_raise(ERR_LIB_SSL, SSL_R_BAD_PROTOCOL_VERSION_NUMBER);\n    goto end;\n}', 'explanation': 'This code verifies that the major version number in the record header matches DTLS1_VERSION_MAJOR. Since SSLv2 compatible CLIENT-HELLO messages would not have this expected version, the function effectively prevents negotiating SSL 2.0.'}}, {'A1': {'code': 'if (PACKET_remaining(&cookiepkt) == 0) {\n    next = LISTEN_SEND_VERIFY_REQUEST;\n} else {\n    ...\n    if (ssl->ctx->app_verify_cookie_cb(ssl, PACKET_data(&cookiepkt),\n            (unsigned int)PACKET_remaining(&cookiepkt)) == 0) {\n        next = LISTEN_SEND_VERIFY_REQUEST;\n    } else {\n        next = LISTEN_SUCCESS;\n    }\n}\n\n...\n\nif (next == LISTEN_SEND_VERIFY_REQUEST) {\n    ...\n    if (!WPACKET_init_static_len(&wpkt, wbuf, ...)\n        || !WPACKET_put_bytes_u8(&wpkt, SSL3_RT_HANDSHAKE)\n        || ...\n        || !WPACKET_start_sub_packet_u24(&wpkt)\n        || !dtls_raw_hello_verify_request(&wpkt, cookie, cookielen)\n        || !WPACKET_close(&wpkt)\n        || !WPACKET_close(&wpkt)\n        || !WPACKET_finish(&wpkt)) {\n        ERR_raise(ERR_LIB_SSL, ERR_R_INTERNAL_ERROR);\n        WPACKET_cleanup(&wpkt);\n        ret = -1;\n        goto end;\n    }\n}', 'explanation': 'This segment handles the reception of a ClientHello without a valid cookie by initiating a HelloVerifyRequest. By enforcing a stateless cookie exchange, the function avoids scenarios that could lead to falling back to insecure (e.g. SSLv2-like) handshake patterns.'}}]","The DTLSv1_listen function implements the DTLS handshake processing in a way that inherently disallows SSL 2.0 negotiation. It checks the major version number of incoming records and only processes those that match the DTLS1 major version, thereby excluding SSLv2-compatible CLIENT-HELLO messages. Additionally, it manages the handshake via a HelloVerifyRequest mechanism when required. Together, these code segments address the specification constraint that SSL 2.0 must not be negotiated, fulfilling the conditions and actions defined in the spec constraints.",success,
5732,DTLSv1_listen,Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less.,395,Does Not Match,[],"The RFC specification requires that implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less. In this function, although the version field is read from incoming packets and a version is computed before sending the HelloVerifyRequest, there is no explicit logic that enforces or checks that the legacy version value in a ClientHello or ServerHello is greater than 0x0300. The function does not explicitly set or verify this field in its outgoing handshake message, and thus it does not visibly address the specified constraint within its own code.",success,
5732,DTLSv1_listen,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Fully Matches,"[{'C1': {'code': 'if ((s->version & 0xff00) != (DTLS1_VERSION & 0xff00)) {\n    ERR_raise(ERR_LIB_SSL, SSL_R_UNSUPPORTED_SSL_VERSION);\n    return -1;\n}\n\n...\n\nif (versmajor != DTLS1_VERSION_MAJOR) {\n    ERR_raise(ERR_LIB_SSL, SSL_R_BAD_PROTOCOL_VERSION_NUMBER);\n    goto end;\n}', 'explanation': 'These code segments check that the negotiated protocol version matches the expected DTLS version and thus reject unsupported versions like SSL 3.0. This directly implements the requirement from the RFC that SSL 3.0 (and by context, similarly insufficient protocols) MUST NOT be negotiated.'}}]","The function DTLSv1_listen explicitly validates the protocol version by comparing both the internal SSL version and the record header's version. The condition 'if ((s->version & 0xff00) != (DTLS1_VERSION & 0xff00))' together with the check 'if (versmajor != DTLS1_VERSION_MAJOR)' ensure that only the proper DTLS version is accepted, effectively rejecting SSL 3.0 in accordance with the RFC specification. Thus, the code function visibly and solely implements the constraint that 'the security of SSL 3.0 ... MUST NOT be negotiated'.",success,
5732,DTLSv1_listen,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function DTLSv1_listen is focused on handling the DTLS handshake process, particularly with regard to processing ClientHello messages and performing cookie verification/exchange. It does not contain any logic related to selecting or filtering cipher suites, and there is no check or restriction regarding RC4 cipher suites. The RFC specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites, but this function does not inspect or enforce any cipher suite-specific constraints. Therefore, no labeled condition or action from the spec constraints is implemented in this function.",success,
5732,DTLSv1_listen,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The DTLSv1_listen function is focused on handling DTLS-specific cookie exchange and ClientHello processing for DTLS (not TLS 1.3) and does not include any logic for detecting, ignoring, or preventing the use of the status_request_v2 extension. There is no code within the function that addresses the RFC requirement that TLS 1.3 servers must not act on the presence or information of the status_request_v2 extension or send it in subsequent messages.",success,
5781,tls1_change_cipher_state,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The specification requires that implementations MUST NOT use the Truncated HMAC extension (and additionally avoid processing records with a version less than 0x0300). In the provided function, there is no visible logic that checks for or disables the use of the Truncated HMAC extension; nor is there any check on the record version to ensure it is not less than 0x0300. While the function processes key derivation and configuration for encryption and MAC, it does not include any explicit code addressing the specified requirements. Therefore, in isolation, the function does not implement the protocol requirements as specified.",success,
6775,SSL_CTX_add1_to_CA_list,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function, SSL_CTX_add1_to_CA_list, only adds a CA name to the SSL context by calling add_ca_name. It does not contain any logic that addresses the TLS 1.3 requirement regarding the status_request_v2 extension (i.e., ignoring its presence and not sending it in certain messages). There is no conditional or any other logic within this function that pertains to the specified constraints, so it does not implement any of the labeled conditions or actions from the spec.",success,
6911,cmd_VerifyCAPath,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function 'cmd_VerifyCAPath' only calls the helper function 'do_store' and does not contain any logic related to the TLS 1.3 extension handling described in the RFC. It neither checks for the presence of the status_request_v2 extension, nor does it enforce the rule of not sending that extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. Therefore, the code function does not visibly address any of the labeled conditions or actions from the spec constraints in its own body.",success,
6947,ssl_get_cert_to_compress,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Does Not Match,[],"The provided function focuses on constructing a certificate chain for compression and does not include any logic to send alert messages when errors occur. The TLS specification requires that on detecting a fatal error, an alert (specifically an X alert) must be sent before terminating the connection. In this function, error paths lead to a cleanup (goto out) and a return of 0 without any alert being issued. The error handling logic related to terminating the connection with a specific alert is absent in the function body, and therefore, it does not visibly address any of the spec constraints regarding alert sending.",success,
6950,ssl_get_compressed_cert,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The function ssl_get_compressed_cert only implements logic for compressing certificate data. It neither checks for nor ignores the status_request_v2 extension in any of the TLS messages, which is the specific requirement from the TLS 1.3 RFC. Therefore, none of the conditions or actions (e.g., pertaining to not acting upon status_request_v2 presence) are addressed within the function_body.",success,
6960,dtls1_write_app_data_bytes,"Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure.",283,Partially Matches,"[{'C1': {'code': 'if (len > SSL3_RT_MAX_PLAIN_LENGTH) {\n    ERR_raise(ERR_LIB_SSL, SSL_R_DTLS_MESSAGE_TOO_BIG);\n    return -1;\n}\n\nreturn dtls1_write_bytes(sc, type, buf_, len, written);', 'explanation': 'The RFC specifies that zero-length fragments of Application Data MAY be sent. This function does not include any explicit handling or special-case logic for zero-length fragments; it merely passes the provided length (even if zero) to dtls1_write_bytes after checking that it does not exceed the maximum plain length. Thus, while it allows sending zero-length fragments (by not rejecting len == 0), there is no proactive logic implementing the traffic analysis countermeasure aspect of the RFC.'}}]","The function dtls1_write_app_data_bytes indirectly supports sending zero-length Application Data fragments by not rejecting a len value of 0. However, it does not explicitly implement any logic targeted at the RFC requirement (e.g. actively generating or handling zero-length fragments as a countermeasure for traffic analysis). Because of this, we conclude that while the function does not conflict with the RFC and allows zero-length fragments, it only partially matches the specified constraint.",success,
6961,dtls1_dispatch_alert,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided code function, dtls1_dispatch_alert, solely handles dispatching of alert messages in DTLS and does not contain any logic related to cipher suite negotiation or the prevention of RC4 cipher suite usage as required by the spec. There are no code segments within this function that attempt to check, filter, or avoid the use of RC4 cipher suites, nor is there any logic enforcing the minimum cipher strength. Therefore, it does not address any labeled spec constraints (such as C1 or A1) related to RC4 or low-strength cipher suites.",success,
7198,ssl_cipher_get_evp,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The TLS RFC specification requires that implementations MUST NOT use the Truncated HMAC extension (and also imposes restrictions on record versions). In the provided function, there is no visible logic that addresses the prohibition of the Truncated HMAC extension; no code segments expressly check for or prevent its use. Although there is a version check (using s->ssl_version) in one branch, it relates to choosing between different cipher configurations and does not implement the specification’s forbidden use of Truncated HMAC. Therefore, the function does not visibly address the required spec constraints within its own logic.",success,
7216,ssl_create_cipher_list,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function 'ssl_create_cipher_list' does not contain any explicit logic addressing the spec constraint regarding the Truncated HMAC extension. It performs cipher selection and applies rules for ordering and filtering ciphers, but there is no code segment that checks for or disables the Truncated HMAC extension as required by the RFC. Thus, with respect to the labeled condition (e.g., C1 regarding not using the Truncated HMAC extension), there is no corresponding logic in the function body.",success,
7216,ssl_create_cipher_list,"Implementations negotiating the use of older versions of TLS SHOULD prefer forward secret and AEAD cipher suites, when available.",388,Partially Matches,"[{'C1': {'code': 'ssl_cipher_apply_rule(0, SSL_kECDHE, SSL_aECDSA, 0, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);\nssl_cipher_apply_rule(0, SSL_kECDHE, 0, 0, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);\nssl_cipher_apply_rule(0, SSL_kECDHE, 0, 0, 0, 0, 0, CIPHER_DEL, -1, &head, &tail);', 'explanation': 'These calls attempt to prefer forward secret ciphers (ECDHE variants) by reordering the cipher list, reflecting the requirement to prefer forward secret cipher suites.'}}, {'A1': {'code': 'ssl_cipher_apply_rule(0, 0, 0, SSL_AESGCM, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);\nssl_cipher_apply_rule(0, 0, 0, 0, SSL_AEAD, 0, 0, CIPHER_BUMP, -1, &head, &tail);', 'explanation': 'These lines show the function giving priority to AEAD cipher suites by bumping them up in the preference order, which is in keeping with the requirement to prefer AEAD cipher suites when available.'}}]","The function performs several explicit reordering operations via ssl_cipher_apply_rule to prioritize ECDHE (providing forward secrecy) and AEAD cipher suites. However, while the specification also mandates that RC4 cipher suites MUST NOT be offered (for older versions of TLS), this function only moves RC4 to lower priority using an ordering rule rather than removing them entirely. Therefore, the cipher list ordering mechanism partially implements the intended behavior from the TLS RFC, addressing some but not all of the specified constraints within the function itself.",success,
7217,SSL_CIPHER_description,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function 'SSL_CIPHER_description' only creates a human-readable string to describe a given SSL cipher and does not include any logic related to the specified TLS RFC requirements. In particular, the function does not address the prohibition on using the Truncated HMAC extension (as required by the RFC) nor does it check or enforce rules related to record versions. No code within this function implements any of the labeled conditions or actions from the provided spec constraints.",success,
7241,ssl_cipher_get_overhead,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The function ssl_cipher_get_overhead only computes overhead values for various cipher algorithms and does not include any logic that addresses the specified TLS RFC constraints. In particular, there is no check or mechanism within this function to prevent the use of the Truncated HMAC extension (as required) or to enforce record version limits. None of the code segments specifically implement the constraint regarding the Truncated HMAC extension or the record version requirements, so the function does not visibly address the labeled conditions/actions from the RFC specification.",success,
7244,OSSL_default_ciphersuites,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The code function OSSL_default_ciphersuites solely returns a string containing a list of predefined TLS 1.3 cipher suites (all of which are AEAD algorithms). There is no logic within this function that checks, enforces, or references the prohibition of using the Truncated HMAC extension or any version constraints as specified in the TLS RFC. The function does not implement any conditions (like C1) or actions (like A1) related to the spec constraints, and thus does not address the required security measures.",success,
7244,OSSL_default_ciphersuites,An AEAD algorithm where N_MAX is less than 8 bytes MUST NOT be used with TLS.,298,Does Not Match,[],"The function 'OSSL_default_ciphersuites' simply returns a string of default TLS cipher suites and does not contain any logic that addresses nonce formation, sequence number handling, or the AEAD algorithm restrictions as described in the TLS RFC specification. It does not incorporate any condition (e.g., C1) or action (e.g., A1) related to the requirement that AEAD algorithms with N_MAX less than 8 bytes MUST NOT be used with TLS.",success,
7244,OSSL_default_ciphersuites,"Implementations negotiating the use of older versions of TLS SHOULD prefer forward secret and AEAD cipher suites, when available.",388,Partially Matches,"[{'C1': {'code': 'return ""TLS_AES_256_GCM_SHA384:"" \n       ""TLS_CHACHA20_POLY1305_SHA256:"" \n       ""TLS_AES_128_GCM_SHA256"";', 'explanation': 'The function returns only AEAD cipher suites that are inherently forward secret, addressing the preference for forward secret and AEAD cipher suites.'}}, {'A1': {'code': 'return ""TLS_AES_256_GCM_SHA384:"" \n       ""TLS_CHACHA20_POLY1305_SHA256:"" \n       ""TLS_AES_128_GCM_SHA256"";', 'explanation': 'The list explicitly excludes RC4 cipher suites, aligning with the mandate to not offer or negotiate RC4.'}}]","The function returns a fixed string of cipher suites that are all AEAD and provide forward secrecy, thereby implicitly meeting parts of the RFC specification requiring a preference for forward secret and AEAD cipher suites and the exclusion of RC4. However, the function contains no logic to handle negotiation differences (such as with older TLS versions) or other protocol features mentioned in the spec context (e.g., change_cipher_spec handling), so its implementation only partially matches the overall RFC constraints.",success,
7253,ssl_print_extension,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The TLS RFC requirement specifies that a TLS implementation SHOULD NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol. In the function, the only handling of early data is in the case for TLSEXT_TYPE_early_data, where it simply prints the max_early_data value if the message type indicates a NewSession Ticket. There is no logic to enforce or check the ALPN protocol, or to control retransmission of early data. Therefore, this function does not implement the specified conditions, and no labeled constraints (e.g., C1, A1) from the spec constraints are visibly addressed within this function.",success,
7255,ssl_print_client_hello,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function is responsible for printing the contents of a ClientHello message and does not contain any logic that addresses the specified TLS RFC constraint regarding the Truncated HMAC extension. There is no explicit check or handling in the function for avoiding or filtering out records or extensions related to the Truncated HMAC; the function only processes and prints various fields. Thus, no parts of the function directly implement any condition or action related to the spec constraints.",success,
7257,ssl_print_server_hello,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The provided function, ssl_print_server_hello, is responsible for printing the Server Hello message and does not include any logic to check for or prevent the inclusion of the 'psk_key_exchange_modes' extension. There is no code segment within this function that explicitly verifies that the server does not send this extension (as required by the spec constraint). The function merely processes and prints various fields (like version, random, cipher suite, extensions, etc.) without filtering or enforcing the absence of the 'psk_key_exchange_modes' extension. Therefore, in isolation, this function does not implement the TLS RFC requirement.",success,
7257,ssl_print_server_hello,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The function 'ssl_print_server_hello' is primarily responsible for printing the server hello message details (such as the version, random, session id, cipher suite, compression method, and extensions) and does not implement any logic to enforce the specified constraints from the RFC. In particular, it does not include any checks that prevent the use of the Truncated HMAC extension or that verify record versions to ensure none are less than 0x0300. There is no visible code segment within this function that addresses either of these requirements, hence it does not meet any of the labeled spec constraints.",success,
7257,ssl_print_server_hello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The provided function, ssl_print_server_hello, is designed to print a ServerHello message. It calls ssl_print_extensions to output the extensions, but it does not contain any logic to enforce or verify the ordering of extensions, especially the requirement that the pre_shared_key extension MUST be the last extension in the ClientHello. Since the spec constraint targets the ClientHello ordering and the function does not implement any check or manipulation regarding extension ordering (nor is such logic evident within this printing function), the function does not visibly address the specified TLS RFC constraint.",success,
7257,ssl_print_server_hello,Servers MUST NOT send this extension.,115,Does Not Match,[],"The RFC specification requires that servers MUST NOT send the post_handshake_auth extension. The function ssl_print_server_hello is responsible for printing the ServerHello message and processes several fields (e.g., server_version, random, session_id, cipher_suite, compression_method, and extensions) by calling ssl_print_extensions. However, there is no explicit logic in this function that checks for, omits, or enforces the absence of the post_handshake_auth extension. Since the implementation does not visibly address or implement the constraint (i.e., not sending the post_handshake_auth extension), it does not match the RFC specification constraint within this function.",success,
7263,ssl_print_certificates,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function does not contain any logic that excludes or checks for the OpenPGP certificate type when TLS 1.3 is in use. The RFC6091 requirement that the OpenPGP certificate type MUST NOT be used with TLS 1.3 is not visibly addressed within the function_body. Instead, the code only implements different branches for processing raw public key types (rpk) and certificate lists without verifying or prohibiting the usage of the OpenPGP certificate type in TLS 1.3.",success,
7265,ssl_print_cert_request,The server MAY send it in the CertificateRequest message.,106,Fully Matches,"[{'C1': {'code': 'if (msglen < 2)\n    return 0;\nxlen = (msg[0] << 8) | msg[1];\nBIO_indent(bio, indent, 80);\nif (msglen < xlen + 2)\n    return 0;\nmsg += 2;\nmsglen -= 2 + xlen;\nBIO_printf(bio, ""certificate_authorities (len=%d)\\n"", (int)xlen);\nwhile (xlen > 0) {\n    size_t dlen;\n    X509_NAME *nm;\n    const unsigned char *p;\n    if (xlen < 2)\n         return 0;\n    dlen = (msg[0] << 8) | msg[1];\n    if (xlen < dlen + 2)\n         return 0;\n    msg += 2;\n    BIO_indent(bio, indent + 2, 80);\n    BIO_printf(bio, ""DistinguishedName (len=%d): "", (int)dlen);\n    p = msg;\n    nm = d2i_X509_NAME(NULL, &p, dlen);\n    if (!nm) {\n         BIO_puts(bio, ""<UNPARSEABLE DN>\\n"");\n    } else {\n         X509_NAME_print_ex(bio, nm, 0, XN_FLAG_ONELINE);\n         BIO_puts(bio, ""\\n"");\n         X509_NAME_free(nm);\n    }\n    xlen -= dlen + 2;\n    msg += dlen;\n}', 'explanation': 'This segment parses and prints the certificate_authorities field. According to the RFC and provided spec context, the server may include a list of acceptable certificate authorities in the CertificateRequest message. The code extracts the length, then iterates over each DER-encoded distinguished name and prints it.'}}, {'A1': {'code': 'if (SSL_CONNECTION_IS_TLS13(sc)) {\n    if (!ssl_print_hexbuf(bio, indent, ""request_context"", 1, &msg, &msglen))\n        return 0;\n    if (!ssl_print_extensions(bio, indent, 1, SSL3_MT_CERTIFICATE_REQUEST, &msg, &msglen))\n        return 0;\n    return 1;\n}', 'explanation': 'This TLS1.3-specific branch handles printing the request_context and the extensions field (which in TLS1.3 may include details similar to the certificate_authorities extension). This mirrors the RFC allowance for the server to send such details in the CertificateRequest message.'}}]","The function ssl_print_cert_request visibly implements the processing of the CertificateRequest message as specified in the TLS RFC. In the case of non‐TLS1.3 connections, it explicitly extracts and prints the certificate_types, signature_algorithms and particularly the certificate_authorities, matching the RFC statement that the server MAY send this information. For TLS1.3, the function processes the request_context and the extensions, which would include any relevant certificate authority information in that version. Thus, the code function meets the constraints outlined in the RFC specification.",success,
7265,ssl_print_cert_request,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function does not implement any logic to enforce the spec constraint that the OpenPGP certificate type (as defined in RFC6091) is not allowed with TLS 1.3. In the function body, the branch for TLS 1.3 (identified by the check if (SSL_CONNECTION_IS_TLS13(sc))) simply prints the request context and extensions without verifying the certificate types. There is no code that inspects or filters for the OpenPGP certificate type, meaning that this function, by itself, does not address the required constraint.",success,
7266,ssl_print_ticket,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided code function, ssl_print_ticket, only handles the printing and parsing of ticket data (including TLS 1.3-specific ticket fields) and does not include any logic to check or enforce that the OpenPGP certificate type [RFC6091] is not used with TLS 1.3. There is no reference or check within the function that addresses the specific constraint from the spec regarding the prohibition of OpenPGP certificate type in TLS 1.3. As a result, none of the labeled spec conditions/actions (such as C1, A1, etc.) are implemented in this function.",success,
7268,SSL_trace,"In other words, a record with an Alert type MUST contain exactly one message.",282,Fully Matches,"[{'C1': {'code': 'case SSL3_RT_ALERT:\n    if (msglen != 2)\n        BIO_puts(bio, ""    Illegal Alert Length\\n"");\n    else {\n        BIO_printf(bio, ""    Level=%s(%d), description=%s(%d)\\n"",\n                   SSL_alert_type_string_long(msg[0] << 8),\n                   msg[0], SSL_alert_desc_string_long(msg[1]), msg[1]);\n    }', 'explanation': 'The TLS RFC requirement that a record with an Alert type MUST contain exactly one message is enforced here by checking that the message length is exactly 2 bytes (one for level and one for description), and treating any other length as an error.'}}]","Within the function, the Alert message branch specifically checks that msglen equals 2, which corresponds to exactly one alert message as required by the TLS specification. This check is directly implemented in the function_body, satisfying the spec constraint on Alert messages without relying on external dependencies.",success,
8334,ssl_check_allowed_versions,"In particular, it MUST NOT negotiate TLS 1.3.",14,Does Not Match,[],"The specification explicitly requires that the implementation must not negotiate TLS 1.3—especially in a renegotiation scenario—and must terminate the connection with an 'unexpected_message' alert in certain cases. The provided function only handles version massaging and checking by setting min_version and max_version. It conditionally downgrades TLS 1.3 to TLS 1.2 using the OPENSSL_NO_TLS1_3 macro, but it does not contain any logic to detect a renegotiation scenario or to send an 'unexpected_message' alert. Additionally, if compiled without OPENSSL_NO_TLS1_3, TLS 1.3 is allowed. Therefore, the function does not visibly address the constraints described in the RFC specification.",success,
8340,ossl_ssl_connection_new_int,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The TLS RFC specification requires that a TLS implementation MUST NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol, and that applications should control early data retransmission. In the provided function, while there are assignments copying early data parameters (e.g., s->max_early_data and s->recv_max_early_data) and the assignment of s->allow_early_data_cb for non-QUIC contexts, there is no logic that enforces or checks the ALPN protocol match or prevents automatic retransmission of early data. The function merely initializes various configuration parameters, without incorporating any control or decision mechanism regarding early data retransmission. Therefore, no part of the function visibly implements the specified RFC constraints regarding early data retransmission.",success,
8396,SSL_CTX_get_verify_callback,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function only returns the 'default_verify_callback' from the 'SSL_CTX' structure and does not contain any logic related to the handling of the status_request_v2 extension as mandated by the TLS 1.3 RFC specification. There is no evidence in this function that it addresses any conditions (e.g., C1) or actions (e.g., A1) regarding the processing or omission of the status_request_v2 extension in ClientHello or subsequent messages. Dependencies or context from other parts of the system are not considered; only the code within this function is evaluated.",success,
8423,ssl_read_internal,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Partially Matches,"[{'C1': {'code': 'if (sc->early_data_state == SSL_EARLY_DATA_CONNECT_RETRY\n                || sc->early_data_state == SSL_EARLY_DATA_ACCEPT_RETRY) {\n        ERR_raise(ERR_LIB_SSL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }', 'explanation': ""This code segment explicitly checks for an early data retry state and raises an error instead of proceeding, which prevents automatic resending of early data. This aligns with the spec's requirement that a TLS implementation SHOULD NOT automatically resend early data. However, the function does not implement logic regarding ALPN protocol selection for resending early data, hence only partially matching the overall RFC constraint.""}}]","The function contains a check for early data retry states (SSL_EARLY_DATA_CONNECT_RETRY and SSL_EARLY_DATA_ACCEPT_RETRY) and prevents further processing by raising an error, which stops an automatic resend. This addresses the RFC's directive that early data should not be automatically retransmitted. However, the additional requirement that retransmission is allowed only when the negotiated ALPN protocol matches is not handled within this function, leading to a 'Partially Matches' judgment.",success,
8426,SSL_read_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Partially Matches,"[{'A1': {'code': 'if (sc->ext.early_data == SSL_EARLY_DATA_ACCEPTED) {\n    sc->early_data_state = SSL_EARLY_DATA_READING;\n    ret = SSL_read_ex(s, buf, num, readbytes);\n    /* ... state machine and retry logic ... */\n} else {\n    sc->early_data_state = SSL_EARLY_DATA_FINISHED_READING;\n}\n*readbytes = 0;\nreturn SSL_READ_EARLY_DATA_FINISH;', 'explanation': 'This code block shows that early data is only read when the early_data extension is accepted. The function does not attempt any automatic retransmission of early data on its own, which aligns with the RFC’s mandate that a TLS implementation SHOULD NOT automatically resend early data. However, the function does not include any explicit check (e.g., ALPN protocol matching) as required by the RFC for permitting automatic retransmission.'}}]","The function implements a state machine for processing early data read operations and does not resend early data automatically. This partially addresses the RFC specification which requires that early data NOT be automatically resent, thus leaving retransmission decisions to the application. However, the function does not fully enforce the remaining condition from the spec (i.e., that automatic retransmission is only permissible if the negotiated connection selects the same ALPN protocol). Since the code does not show any ALPN checking within this function, it only partially meets the full requirements of the spec.",success,
8427,SSL_get_early_data_status,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The function SSL_get_early_data_status only retrieves the early data status by returning the value stored in sc->ext.early_data. It does not implement any logic to decide whether or not to automatically resend early data based on the negotiated ALPN protocol or connection state, as required by the RFC specification. There is no code addressing the constraint that a TLS implementation SHOULD NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol. Thus, the code does not address any of the labeled conditions (e.g., C1) or actions (e.g., A1) related to retransmission of early data.",success,
8431,ssl_write_internal,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Fully Matches,"[{'C1': {'code': ""/* If we are a client and haven't sent the Finished we better do that */\nif (!ossl_statem_check_finish_init(sc, 1))\n    return -1;"", 'explanation': 'This code segment explicitly checks to ensure that the Finished message has been sent before application data is sent, which directly enforces the requirement that application data MUST NOT be sent prior to sending the Finished message.'}}]","The function visibly implements the TLS RFC specification by calling ossl_statem_check_finish_init to verify that the Finished message has been transmitted before proceeding with writing application data. This check directly enforces the constraint described in the specification context, fulfilling the labeled condition (C1) in the spec.",success,
8431,ssl_write_internal,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Partially Matches,"[{'C1': {'code': 'if (sc->early_data_state == SSL_EARLY_DATA_CONNECT_RETRY\n                || sc->early_data_state == SSL_EARLY_DATA_ACCEPT_RETRY\n                || sc->early_data_state == SSL_EARLY_DATA_READ_RETRY) {\n        ERR_raise(ERR_LIB_SSL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }', 'explanation': 'This code checks if the connection is in an early data retransmission state and, if so, triggers an error and aborts the write. This prevents automatic retransmission of early data, in line with the TLS specification that advises against automatically resending early data.'}}]","The function includes logic that explicitly avoids automatically resending early data by checking for retry states and returning an error when such a state is detected. This directly addresses the TLS RFC requirement that early data should not be automatically retransmitted. However, the specification also requires that retransmission is disallowed unless the negotiated connection selects the same ALPN protocol. There is no ALPN protocol verification in this function, so while it handles part of the requirement, it does not fully cover all aspects of the spec. Thus, the implementation is only a partial match.",success,
8432,SSL_sendfile,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The TLS RFC specification requires that implementations must not offer or negotiate RC4 cipher suites. The function SSL_sendfile is solely focused on sending file data via ktls and handling associated states (e.g., alerts, flushing BIO, error handling). There is no logic within the function that checks, selects, or rejects any cipher suites (including RC4). Therefore, no parts of this function address the specific constraint from the RFC regarding RC4 cipher suites.",success,
8436,SSL_write_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function implements a state machine for sending early data and handling connection retries, but it does not include any logic that verifies whether the negotiated ALPN protocol matches the one used for early data. In the TLS specification, the implementation MUST NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol, and it SHOULD leave retransmission decisions to the application. Although the function handles different early-data states (e.g., SSL_EARLY_DATA_CONNECT_RETRY, SSL_EARLY_DATA_WRITE_RETRY), it does not check or enforce if the ALPN protocol is maintained. Therefore, within this function there is no visible implementation addressing the specific constraint regarding preventing automatic retransmission of early data in case of an ALPN mismatch.",success,
8440,can_renegotiate,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(sc)) {\n    ERR_raise(ERR_LIB_SSL, SSL_R_WRONG_SSL_VERSION);\n    return 0;\n}', 'explanation': 'This block checks if the current connection is TLS 1.3. If true, it raises an error and returns 0, thereby preventing renegotiation. This directly implements the specification that TLS 1.3 must not be negotiated.'}}]","The function clearly prohibits renegotiation when a connection is using TLS 1.3 by checking SSL_CONNECTION_IS_TLS13 and aborting the renegotiation with an error. This logic, taken in isolation from its dependencies, fully addresses the RFC requirement that a server must not negotiate TLS 1.3, thus fully matching the specified constraint.",success,
8444,SSL_new_session_ticket,"Servers MAY send multiple tickets on a single connection, either immediately after each other or after specific events (see Appendix C.4).",240,Partially Matches,"[{'C1': {'code': 'if ((SSL_in_init(s) && sc->ext.extra_tickets_expected == 0)\n        || SSL_IS_FIRST_HANDSHAKE(sc) || !sc->server\n        || !SSL_CONNECTION_IS_TLS13(sc))\n    return 0;', 'explanation': 'This code block checks that the connection is in an appropriate state (not the first handshake, is a server and is using TLS 1.3) before proceeding. It ensures that extra tickets are not sent improperly, which is related to the RFC’s allowance of sending multiple tickets only under the right conditions.'}}, {'A1': {'code': 'sc->ext.extra_tickets_expected++;', 'explanation': 'This line increments the count of extra tickets expected, thereby supporting the RFC feature that allows a server to send multiple session tickets on a single connection.'}}]","The function contains logic to decide whether it is appropriate to issue an additional session ticket based on factors like connection state, role, and protocol version. By incrementing the extra_tickets_expected counter when conditions are met, it partially implements the RFC requirement that a server may send multiple tickets on a single connection. However, aspects such as the timing and triggering of subsequent ticket sends (for instance, after specific events) are not directly handled in this function. Therefore, while the function visibly addresses some of the constraints laid out in the RFC, it does so only partially within its own scope.",success,
8475,SSL_export_keying_material,Future specifications MUST NOT define a use of exporters that permit both an empty context and no context with the same label.,332,Does Not Match,[],"The function SSL_export_keying_material only performs basic validation on pointers and TLS version and then delegates the keying material export to another function. There is no visible logic within this function that addresses or enforces the constraint regarding empty context versus no context with the same label (as specified in the RFC). The function simply passes the context, context length, and use_context flag directly to the lower-layer export_keying_material method without any additional processing to ensure the spec's requirement is met.",success,
8495,SSL_CTX_set_cert_verify_callback,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function only sets the certificate verification callback and its argument in the SSL_CTX structure. There is no code within the function that addresses any of the TLS 1.3 server restrictions on the use of the status_request_v2 extension, nor does it implement or enforce any of the spec constraints from the RFC. Therefore, the function does not visibly address any of the labeled conditions or actions specified.",success,
8501,ssl_check_srvr_ecc_cert_and_alg,"-The server's end-entity certificate's public key (and associated restrictions) MUST be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension (currently RSA, ECDSA, or EdDSA).",205,Partially Matches,"[{'C1': {'code': 'if (s->s3.tmp.new_cipher->algorithm_auth & SSL_aECDSA) {\n    /* key usage, if present, must allow signing */\n    if (!(X509_get_key_usage(x) & X509v3_KU_DIGITAL_SIGNATURE)) {\n        ERR_raise(ERR_LIB_SSL, SSL_R_ECC_CERT_NOT_FOR_SIGNING);\n        return 0;\n    }\n}', 'explanation': ""This code segment checks that if the authentication algorithm is ECDSA then the certificate has the 'digitalSignature' key usage bit set, thus ensuring the certificate key can be used for signing. This covers the requirement regarding key usage for ECDSA from the RFC specification.""}}]","The function addresses part of the TLS RFC requirements by enforcing that, in the case of using an ECDSA authentication algorithm, the certificate must have the digitalSignature bit enabled in its key usage extension. However, it does not verify other aspects specified in the RFC, such as ensuring compatibility for RSA or EdDSA, or checking that the certificate type is X.509v3. Thus, it only partially implements the specified RFC conditions.",success,
8515,ssl_protocol_to_string,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The provided function only maps integer version constants to their corresponding string names. It does not implement any logic regarding the TLS RFC specification that prohibits offering or negotiating values within 'obsolete_RESERVED' ranges. There is no conditional check or logic within the function that enforces the constraint stated in the RFC specification, so no part of the code addresses the given conditions (e.g., C1) or actions (e.g., A1). Therefore, the function does not attempt to implement the specified TLS RFC constraint.",success,
8560,SSL_CTX_get_cert_store,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function simply returns the 'cert_store' field from the SSL context; it does not contain any logic pertaining to the processing of the TLS status_request_v2 extension or any related TLS 1.3 behavior as specified in the RFC constraints. There is no code in the function that addresses any condition (C1, C2, etc.) or action (A1, A2, etc.) related to the TLS RFC requirements.",success,
8583,SSL_CTX_set_block_padding_ex,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Partially Matches,[],"The provided function configures padding lengths (for both application data and handshake data) by setting context variables, which does relate to the notion of choosing whether to pad TLS records. However, the TLS RFC specifies that implementations MAY choose to pad and that any padding octets must be set to zero before encryption. In this function, while the block_padding and hs_padding values are set based on input parameters (and a value of 1 is treated as no padding), there is no visible logic that actually appends a string of zero-valued bytes or ensures that any padding data is zeroed out. Therefore, the code partially addresses the padding configuration aspect mentioned in the spec but does not fully implement the padding logic as described in the RFC.",success,
8631,ssl_validate_ct,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Fully Matches,"[{'C1': {'code': 'if (ctx == NULL) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_CT_LIB);\n    goto end;\n}', 'explanation': 'This code checks for a fatal error condition (failure to allocate a CT policy evaluation context) and directly handles it by invoking SSLfatal, which is expected to send an appropriate fatal alert as required by the spec.'}}, {'A1': {'code': 'if (SCT_LIST_validate(scts, ctx) < 0) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_SCT_VERIFICATION_FAILED);\n    goto end;\n}\n...\nif (!ret)\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_CALLBACK_FAILED);', 'explanation': 'These segments trigger SSLfatal to send fatal alerts when SCT validation or callback processing fails, fulfilling the action requirement to notify the peer and signal termination of the handshake as specified in the RFC.'}}]","The function 'ssl_validate_ct' implements error handling according to the TLS RFC by detecting fatal error conditions (e.g. failure to allocate a context, SCT validation errors, or callback failures) and invoking SSLfatal to send the specified fatal alerts. These in-function error checks and alert invocations directly address the spec's requirements to send appropriate fatal alerts and terminate the connection immediately on such errors.",success,
8631,ssl_validate_ct,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Fully Matches,"[{'A1': {'code': 'if (ctx == NULL) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_CT_LIB);\n    goto end;\n}\n...\nif (SCT_LIST_validate(scts, ctx) < 0) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_SCT_VERIFICATION_FAILED);\n    goto end;\n}\n...\nif (!ret)\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_CALLBACK_FAILED);', 'explanation': ""The TLS spec requirement mandates that on fatal errors the implementation must send a specific alert (i.e. 'terminate the connection with an X alert' or 'abort the handshake with an X alert'). This function directly implements that by calling SSLfatal with the appropriate alert codes (SSL_AD_INTERNAL_ERROR and SSL_AD_HANDSHAKE_FAILURE) in all fatal error cases within its own logic.""}}]","Upon detecting a fatal error (failure to allocate context, invalid SCT validation result, or a failed callback), the function immediately calls SSLfatal with a specific alert value, thereby ensuring that any termination or handshake abort is accompanied by the required alert per the TLS RFC. All alert sending logic is contained within the function_body, fulfilling the spec constraints.",success,
8631,ssl_validate_ct,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data.",320,Partially Matches,"[{'A1': {'code': 'if (ctx == NULL) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_CT_LIB);\n    goto end;\n}\n\n...\n\nif (SCT_LIST_validate(scts, ctx) < 0) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_SCT_VERIFICATION_FAILED);\n    goto end;\n}\n\n...\n\nif (!ret)\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_CALLBACK_FAILED);', 'explanation': 'The function calls SSLfatal in several places when an error condition is detected. This indicates an attempt to send an appropriate fatal alert as required by the spec. However, there is no direct logic within the function that explicitly closes the connection immediately after the fatal error is detected.'}}]","The RFC specifies that when a fatal error occurs, an appropriate fatal alert must be sent and the connection must be closed immediately without further data transfer. Within the function, error conditions are handled by invoking SSLfatal, which sends the fatal alert. This partially meets the specification regarding alerting. However, the function does not contain explicit logic to close the connection immediately, leaving that responsibility possibly to the caller. Because only the alert component is visibly implemented in this function, the implementation only partially matches the full requirements of the specification.",success,
8646,SSL_client_hello_get1_extensions_present,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function, SSL_client_hello_get1_extensions_present, does not contain any logic related to the TLS RFC constraints specified. In particular, there is no check or handling related to the Truncated HMAC extension (e.g., ensuring it is not used for AEAD algorithms), nor is there any validation regarding record versions (ensuring no records with a version less than 0x0300 are sent or accepted). The function only collects information about present client hello extensions without addressing any of the RFC specified conditions. Dependencies and context provided are not implemented in this function itself.",success,
8648,SSL_client_hello_get0_ext,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function 'SSL_client_hello_get0_ext' is focused only on locating and returning a specific extension from the client hello message. There is no evidence within this function that it checks or enforces any TLS version requirements as specified in the context (e.g., rejecting records with a version less than 0x0300), nor does it perform any validation related to the Truncated HMAC extension (e.g., ensuring it is not used). Thus, none of the labeled conditions (such as C1) or actions (such as A1) from the RFC specification are addressed by this code function in isolation.",success,
8655,ssl_log_secret,Implementations MUST NOT combine external PSKs with certificate-based authentication of either the client or the server unless negotiated by some extension.,400,Does Not Match,[],"The provided code in ssl_log_secret only logs key material by calling nss_keylog_int with provided parameters. There is no logic present within this function that checks or enforces the RFC requirement which states that implementations MUST NOT combine external PSKs with certificate-based authentication unless negotiated via an extension. The function’s behavior is unrelated to PSK or certificate-based authentication constraints, and therefore it does not address any labeled condition (e.g., C1) or action (e.g., A1) from the provided spec.",success,
8656,ssl_cache_cipherlist,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (PACKET_remaining(cipher_suites) == 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_NO_CIPHERS_SPECIFIED);\n    return 0;\n}', 'explanation': 'This segment checks for an empty cipher suite list, which is a syntactic error, and terminates the connection with a decode_error alert as required by the RFC.'}}, {'C2': {'code': 'if (PACKET_remaining(cipher_suites) % n != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST);\n    return 0;\n}', 'explanation': 'This code ensures that the number of remaining bytes is a multiple of the expected cipher length. A mismatch indicates a message whose length extends beyond what is valid, triggering a decode_error alert.'}}, {'C3': {'code': 'if (!PACKET_get_1(&sslv2ciphers, &leadbyte)\n        || (leadbyte == 0 && !PACKET_copy_bytes(&sslv2ciphers, raw, TLS_CIPHER_LEN))\n        || (leadbyte != 0 && !PACKET_forward(&sslv2ciphers, TLS_CIPHER_LEN))) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_PACKET);\n    OPENSSL_free(s->s3.tmp.ciphers_raw);\n    s->s3.tmp.ciphers_raw = NULL;\n    s->s3.tmp.ciphers_rawlen = 0;\n    return 0;\n}', 'explanation': 'During SSLv2 cipher processing, the function validates each cipher entry. If the parsing fails at any point, it correctly sends a decode_error alert and cleans up, addressing a syntactic parsing error as specified.'}}]","The function explicitly checks different aspects of the cipher suite message for syntactical correctness. When any anomaly is detected—whether it is an empty message, incorrect length alignment, or individual parsing errors—the function terminates the connection by calling SSLfatal with the decode_error alert. This directly implements the TLS RFC requirement that syntactical parsing errors be handled by terminating the connection with a decode_error alert, hence fully matching the specified constraints.",success,
8658,ossl_bytes_to_cipher_list,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'C1': {'code': 'if (PACKET_remaining(cipher_suites) == 0) {\n    if (fatal)\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_NO_CIPHERS_SPECIFIED);\n    else\n        ERR_raise(ERR_LIB_SSL, SSL_R_NO_CIPHERS_SPECIFIED);\n    return 0;\n}', 'explanation': ""This segment checks for an empty cipher suite list, which is semantically invalid, and terminates the connection with an 'illegal_parameter' alert as required by the spec.""}}, {'C2': {'code': 'if (PACKET_remaining(cipher_suites) % n != 0) {\n    if (fatal)\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST);\n    else\n        ERR_raise(ERR_LIB_SSL, SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST);\n    return 0;\n}\n...\nif (PACKET_remaining(cipher_suites) > 0) {\n    if (fatal)\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_LENGTH);\n    else\n        ERR_raise(ERR_LIB_SSL, SSL_R_BAD_LENGTH);\n    goto err;\n}', 'explanation': ""This code ensures that the message is properly parsed by checking the length (i.e. cipher suite list must be a multiple of the expected length) and that no extra bytes remain. If these conditions are violated, a 'decode_error' alert is issued as specified for syntactic errors.""}}]","The function implements error-handling logic that differentiates between syntactic parsing errors (using decode_error alerts) and certain semantic validation failures (using an illegal_parameter alert for empty input). This aligns partially with the TLS RFC requirements regarding alert generation. However, it does not address other potential semantic issues (e.g., invalid enum values or DHE share values like p-1) entirely within this function, hence it only partially matches the complete spec requirements.",success,
8658,ossl_bytes_to_cipher_list,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (PACKET_remaining(cipher_suites) % n != 0) {\n    if (fatal)\n        SSLfatal(s, SSL_AD_DECODE_ERROR,\n                 SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST);\n    else\n        ERR_raise(ERR_LIB_SSL, SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST);\n    return 0;\n}\n\n...\n\nif (PACKET_remaining(cipher_suites) > 0) {\n    if (fatal)\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_LENGTH);\n    else\n        ERR_raise(ERR_LIB_SSL, SSL_R_BAD_LENGTH);\n    goto err;\n}', 'explanation': 'These code segments check that the number of bytes in the cipher_suites Packet exactly conforms to the expected multiple of cipher length and rejects the message (with a decode_error alert) if there is a remainder or extra bytes. This implements the requirement for terminating connections when a message cannot be parsed according to the syntax.'}}]","The function inspects the input packet's length to ensure it is correctly formed, and it triggers a 'decode_error' alert (via SSLfatal) when the packet length is incorrect. This visibly addresses the portion of the TLS RFC concerning messages that cannot be parsed. However, the function also uses an 'illegal_parameter' alert for an empty cipher list, and in nonfatal cases it only raises errors rather than terminating the connection. These differences indicate that while the function implements core logic for syntactic validation as required by the specification, it does not fully match all aspects of the RFC alerting and termination behavior solely within this function.",success,
8659,SSL_CTX_set_max_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function only sets the maximum early data value by assigning it to a field in the SSL_CTX structure. It does not contain any logic addressing conditions such as verifying that early data is not automatically resent or checking if the negotiated ALPN protocol matches, as required by the TLS RFC specification. Therefore, it does not meet any of the specified constraints within its own implementation.",success,
8660,SSL_CTX_get_max_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function only returns the value of the max_early_data field from the SSL_CTX structure. There is no logic within this function that addresses any of the specified TLS RFC conditions or actions, such as controlling or preventing the automatic retransmission of early data. No code within the function attempts to implement the behavior outlined in the spec constraints regarding ALPN protocol checks or retransmission control. Therefore, the function does not visibly implement any of the labeled conditions or actions.",success,
8661,SSL_set_max_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The function only sets the maximum early data value in the SSL connection structure. It does not contain any logic to address the TLS RFC specification regarding the non-automatic retransmission of early data, such as checking whether the negotiated ALPN protocol matches or ensuring that early data is not resent automatically. Therefore, there is no portion of this function that implements any of the conditions or actions from the spec constraints.",success,
8662,SSL_get_max_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The function SSL_get_max_early_data merely retrieves the maximum early data value from the SSL_CONNECTION structure and does not implement any logic related to the TLS early data retransmission policy. Specifically, it does not address checking or enforcing that early data should not be automatically resent unless the negotiated connection selects the same ALPN protocol (as required by the specification). There is no code within this function that implements any of the spec constraints (e.g., C1, A1). Therefore, the function does not address the specified conditions and actions.",success,
8663,SSL_CTX_set_recv_max_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The function only sets the recv_max_early_data field in the SSL_CTX structure and does not implement any logic related to controlling retransmission of early data. It does not check for ALPN protocol mismatches or implement any safeguards against automatic retransmission. Therefore, the function does not address any conditions or actions specified in the TLS RFC regarding early data retransmission.",success,
8664,SSL_CTX_get_recv_max_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The code function simply returns the value of the recv_max_early_data field from the context structure and does not contain any logic that addresses any of the spec constraints (e.g., preventing the automatic retransmission of early data or checking the negotiated ALPN protocol). No part of the function implements the conditions or actions outlined in the RFC specification.",success,
8665,SSL_set_recv_max_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function only sets the 'recv_max_early_data' value in the SSL_CONNECTION structure and does not contain any logic to address the TLS RFC specification concerning retransmission of early data. There is no check or conditional logic that inspects the negotiated ALPN protocol or determines if early data should be resent. All logic related to preventing automatic retransmission or verifying ALPN protocols is absent from the function body, so it does not meet any of the labeled constraints from the spec.",success,
8666,SSL_get_recv_max_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function only returns the value of the 'recv_max_early_data' field, with no logic concerning retransmission of early data or verification of ALPN matching. It does not address any of the conditions or actions in the RFC specification regarding automatic retransmission of early data.",success,
8672,SSL_verify_client_post_handshake,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function does not include any code that addresses the RFC specification requiring that TLS 1.3 servers must not act upon or send the status_request_v2 extension when processing ClientHello messages. The function focuses on post-handshake client authentication and certificate request handling, and no segments in the function check for or skip sending the status_request_v2 extension. Therefore, none of the spec constraints (e.g., C1 and A1) related to handling status_request_v2 are implemented in this function.",success,
8672,SSL_verify_client_post_handshake,Servers MUST NOT send a post-handshake CertificateRequest to clients which do not offer this extension.,114,Fully Matches,"[{'C1': {'code': 'if (sc->post_handshake_auth == SSL_PHA_NONE)\n    ERR_raise(ERR_LIB_SSL, SSL_R_EXTENSION_NOT_RECEIVED);\n    return 0;', 'explanation': ""This code checks that the client's post-handshake auth extension was not offered (i.e. state is SSL_PHA_NONE) and then immediately returns an error, ensuring that no post-handshake CertificateRequest is sent when the extension is absent.""}}, {'A1': {'code': 'case SSL_PHA_EXT_RECEIVED:\n    break;\n\nsc->post_handshake_auth = SSL_PHA_REQUEST_PENDING;\n\nif (!send_certificate_request(sc)) {\n    sc->post_handshake_auth = SSL_PHA_EXT_RECEIVED; /* restore on error */\n    ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_CONFIG);\n    return 0;\n}', 'explanation': 'This segment confirms that if the client did offer the post-handshake auth extension (state is SSL_PHA_EXT_RECEIVED), the server proceeds to change the state and sends a CertificateRequest, fulfilling the action only when the extension is present.'}}]","The function explicitly checks the internal state (sc->post_handshake_auth) to determine whether the client offered the post-handshake authentication extension. If the extension is not present (SSL_PHA_NONE), it raises an error and aborts, thereby ensuring that a CertificateRequest is only sent when the client has indicated support. This directly implements the TLS RFC requirement that 'Servers MUST NOT send a post-handshake CertificateRequest to clients which do not offer this extension.'",success,
8672,SSL_verify_client_post_handshake,"When the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message.",254,Partially Matches,"[{'C1': {'code': 'switch (sc->post_handshake_auth) {\n    case SSL_PHA_EXT_RECEIVED:\n        break;\n    ...\n}', 'explanation': 'The code checks that the client has sent the post_handshake_auth extension by verifying that the state (sc->post_handshake_auth) equals SSL_PHA_EXT_RECEIVED. This is in line with the spec requirement that the server should request client authentication only if the client sent the extension.'}}, {'A1': {'code': 'if (!send_certificate_request(sc)) {\n    sc->post_handshake_auth = SSL_PHA_EXT_RECEIVED; /* restore on error */\n    ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_CONFIG);\n    return 0;\n}\n...\nossl_statem_set_in_init(sc, 1);\nreturn 1;', 'explanation': 'After validating the preconditions, the function attempts to send a CertificateRequest message by calling send_certificate_request(sc). This implements the server action as specified by the RFC when the client has sent the post_handshake_auth extension.'}}]","The function verifies necessary conditions (e.g., TLS 1.3, server mode, handshake completion, and that the post_handshake_auth extension was received) and then calls send_certificate_request to send a CertificateRequest message. However, it does not handle subsequent client responses as detailed in the RFC, so while key aspects are implemented, the function only partially meets the full specification.",success,
8674,SSL_CTX_set_allow_early_data_cb,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function solely registers a callback by setting structure fields and does not contain any logic to prevent or control automatic retransmission of early data per the TLS RFC specification. It does not implement any checks or conditions (e.g., ALPN protocol verification) required by the spec constraints, so none of the labeled conditions (such as C1) or actions (such as A1) are addressed within this function body.",success,
8675,SSL_set_allow_early_data_cb,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The code function simply assigns a callback function and its associated data to a field within the SSL_CONNECTION structure. It does not contain any logic that verifies the negotiated ALPN protocol, nor does it include any behavior to prevent or manage the automatic retransmission of early data, as required by the TLS specification. As such, none of the conditions (e.g., preventing automatic resend unless the same ALPN is selected) or actions specified in the RFC are directly addressed within this function.",success,
8951,tls1_check_group_id,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Partially Matches,"[{'C1': {'code': 'if (!s->server)\n        return 1;', 'explanation': 'This branch ensures that when operating as a client, the function does not evaluate the peer’s supported_groups list, which is consistent with the requirement that clients MUST NOT act upon any supported_groups information before the handshake completes.'}}]","The function checks the group id based on local (own) preferences and, if operating as a server, it additionally checks the peer's supplied supported_groups list. In the client case, by immediately returning 1 without checking peer groups, it avoids acting on the supported_groups data, which addresses one aspect (C1) of the spec. However, the spec also allows clients to update subsequent connections based on prior handshake information (an action not implemented here) and does not include additional logic within this function regarding updating key_share preferences. Consequently, only a part of the constraints (C1) is addressed in the code function, leading to a 'Partially Matches' outcome.",success,
8967,tls12_check_peer_sigalg,"-The server's end-entity certificate's public key (and associated restrictions) MUST be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension (currently RSA, ECDSA, or EdDSA).",205,Partially Matches,"[{'C1': {'code': 'pkeyid = EVP_PKEY_get_id(pkey);\n...\nif (pkeyid != lu->sig\n        && (lu->sig != EVP_PKEY_RSA_PSS || pkeyid != EVP_PKEY_RSA)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_SIGNATURE_TYPE);\n    return 0;\n}\n...\nif (!ssl_cert_lookup_by_nid(\n         (pkeyid == EVP_PKEY_RSA_PSS) ? EVP_PKEY_get_id(pkey) : pkeyid,\n         &cidx, SSL_CONNECTION_GET_CTX(s))\n        || lu->sig_idx != (int)cidx) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_SIGNATURE_TYPE);\n    return 0;\n}', 'explanation': ""The code verifies that the provided public key is compatible with the selected signature algorithm. It determines the key type, uses lookup functions to match the sig algorithm (from the client's 'signature_algorithms' extension) and ensures that aspects like RSA vs. RSA-PSS and, for EC keys, the correct curve are enforced. This implements the compatibility requirement of the server's public key (C1).""}}]","The function implements several checks to ensure that the server's end‐entity certificate’s public key is compatible with the client's selected authentication algorithm, such as verifying the key type, the matching signature algorithm, protocol versions and (for EC keys) curve suitability. However, while the specification also requires that the certificate allow the key to be used for signing (e.g., the digitalSignature bit is set), this function does not check certificate key usage restrictions. Therefore, the function only partially matches the full TLS RFC specification constraints.",success,
8967,tls12_check_peer_sigalg,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (lu == NULL) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_SIGNATURE_TYPE);\n    return 0;\n}\n...\nif ((SSL_CONNECTION_IS_TLS13(s) && (lu->hash == NID_sha1 || lu->hash == NID_sha224))\n    || (pkeyid != lu->sig\n        && (lu->sig != EVP_PKEY_RSA_PSS || pkeyid != EVP_PKEY_RSA))) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_SIGNATURE_TYPE);\n    return 0;\n}\n...\nif (pkeyid == -1) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_SIGNATURE_TYPE);\n    return -1;\n}\n...\nif (!ssl_cert_lookup_by_nid(...)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_SIGNATURE_TYPE);\n    return 0;\n}\n...\nif (!tls1_check_pkey_comp(s, pkey)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_ILLEGAL_POINT_COMPRESSION);\n    return 0;\n}\n...\nif (!tls1_lookup_md(SSL_CONNECTION_GET_CTX(s), lu, &md)) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_UNKNOWN_DIGEST);\n    return 0;\n}\n...\nif (secbits == 0 ||\n    !ssl_security(s, SSL_SECOP_SIGALG_CHECK, secbits,\n                  md != NULL ? EVP_MD_get_type(md) : NID_undef,\n                  (void *)sigalgstr)) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_WRONG_SIGNATURE_TYPE);\n    return 0;\n}', 'explanation': 'The function performs multiple semantic validations (e.g., lookup failures, mismatches in signature algorithm, keys, curve parameters, etc.) and if any of these checks fail it immediately calls SSLfatal with an ILLEGAL_PARAMETER alert (or related fatal alerts), thereby acting according to the TLS RFC requirement for semantically invalid messages.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_SIGNATURE_TYPE);', 'explanation': 'Repeatedly in the code function, when a validation check determines the received parameters are semantically invalid, the connection is terminated by calling SSLfatal with SSL_AD_ILLEGAL_PARAMETER, thus implementing the RFC’s mandated action on such messages.'}}]","The provided function conducts numerous checks on the peer’s signature algorithm parameters—for example, validating the available signature algorithms, checking key types, ensuring curve compatibility, and confirming compliance with Suite B or TLS 1.3 restrictions. In each case where a semantic error is detected, the function terminates the connection by invoking SSLfatal with SSL_AD_ILLEGAL_PARAMETER (or with a closely related fatal alert) as required by the RFC. Therefore, the function itself visibly addresses the condition that syntactically correct but semantically invalid messages lead to an 'illegal_parameter' alert, fully matching the specified RFC constraint.",success,
8967,tls12_check_peer_sigalg,"If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the ""signature_algorithms"" extension in the CertificateRequest message.",226,Fully Matches,"[{'C1': {'code': 'sent_sigslen = tls12_get_psigalgs(s, 1, &sent_sigs);\nfor (i = 0; i < sent_sigslen; i++, sent_sigs++) {\n    if (sig == *sent_sigs)\n        break;\n}\nif (i == sent_sigslen && (lu->hash != NID_sha1\n    || s->cert->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT)) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_WRONG_SIGNATURE_TYPE);\n    return 0;\n}', 'explanation': 'This segment checks that the signature algorithm used in the peer’s CertificateVerify message is among the list of algorithms previously offered (through tls12_get_psigalgs) which corresponds to the supported_signature_algorithms field in the CertificateRequest message when sent by a client.'}}, {'A1': {'code': 'if ((SSL_CONNECTION_IS_TLS13(s)\n        && (lu->hash == NID_sha1 || lu->hash == NID_sha224))\n    || (pkeyid != lu->sig\n        && (lu->sig != EVP_PKEY_RSA_PSS || pkeyid != EVP_PKEY_RSA))) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_SIGNATURE_TYPE);\n    return 0;\n}', 'explanation': 'This block validates that for TLS1.3 (and similarly in other cases) disallowed hash functions (SHA1/SHA224) are rejected and that the key type is consistent with using RSASSA-PSS for RSA signatures, satisfying key compatibility requirements stated by the RFC.'}}]","Evaluating the function in isolation, the code visibly implements the RFC’s requirements for CertificateVerify signature validation when sent by a client. It checks that the signature algorithm is one of those negotiated (by comparing with the list obtained via tls12_get_psigalgs) and performs additional checks ensuring the algorithm’s compatibility with the certificate and its key—as well as disallowing prohibited hash functions in TLS 1.3. These directly address the specified conditions and actions from the RFC specification.",success,
8967,tls12_check_peer_sigalg,"If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client's ""signature_algorithms"" extension unless no valid certificate chain can be produced without unsupported algorithms (see Section 4.2.3).",225,Partially Matches,"[{'C1': {'code': 'sent_sigslen = tls12_get_psigalgs(s, 1, &sent_sigs);\nfor (i = 0; i < sent_sigslen; i++, sent_sigs++) {\n    if (sig == *sent_sigs)\n        break;\n}\nif (i == sent_sigslen && (lu->hash != NID_sha1 || s->cert->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT)) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_WRONG_SIGNATURE_TYPE);\n    return 0;\n}', 'explanation': ""This segment verifies that the signature algorithm provided by the peer is among the list (sent_sigs) that were offered in the client's 'signature_algorithms' extension. This check implements the requirement that the signature algorithm used in the CertificateVerify message be one that was offered, which is part of the spec.""}}]","The function clearly contains logic to check that the signature algorithm from the peer is one of the algorithms offered in the client's signature_algorithms extension, thereby addressing part of the RFC specification. However, it does not fully implement the exception clause (i.e. the allowance for unsupported algorithms when no valid certificate chain can be produced) solely within this function. Since only a portion of the spec constraints is handled by this function, the overall result is 'Partially Matches'.",success,
8967,tls12_check_peer_sigalg,"RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in ""signature_algorithms"".",228,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)) {\n    /* Only allow PSS for TLS 1.3 */\n    if (pkeyid == EVP_PKEY_RSA)\n        pkeyid = EVP_PKEY_RSA_PSS;\n}', 'explanation': 'This segment forces any RSA key encountered in a TLS 1.3 connection to be treated as RSA_PSS. This directly implements the RFC requirement that RSA signatures must use the RSASSA-PSS algorithm, regardless of other algorithms present in the signature_algorithms extension.'}}, {'C2': {'code': 'if ((SSL_CONNECTION_IS_TLS13(s)\n        && (lu->hash == NID_sha1 || lu->hash == NID_sha224))) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_SIGNATURE_TYPE);\n    return 0;\n}', 'explanation': 'This check disallows the use of SHA1 or SHA224 in TLS 1.3 signatures, aligning with the specification that SHA-1 must not be used in CertificateVerify messages.'}}, {'A1': {'code': 'sent_sigslen = tls12_get_psigalgs(s, 1, &sent_sigs);\nfor (i = 0; i < sent_sigslen; i++, sent_sigs++) {\n    if (sig == *sent_sigs)\n        break;\n}\nif (i == sent_sigslen && (lu->hash != NID_sha1\n    || s->cert->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT)) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_WRONG_SIGNATURE_TYPE);\n    return 0;\n}', 'explanation': ""This segment checks that the peer's signature algorithm is one of the algorithms we previously proposed (from the signature_algorithms extension). It ensures compatibility with the supported signature algorithms and enforces the strict mode requirement regarding permitted algorithms.""}}]","The function 'tls12_check_peer_sigalg' contains explicit checks that address the key constraints described in the RFC specification. It mandates that for TLS 1.3 connections, if an RSA key is encountered it is forced to use RSASSA-PSS (C1), and disallows the use of SHA1 or SHA224 in TLS 1.3 signatures (C2). In addition, it verifies that the signature algorithm is one that was offered in the client's supported list (A1). These logic checks collectively indicate that the function, in isolation from its dependencies, fully implements the specified TLS RFC constraint.",success,
8967,tls12_check_peer_sigalg,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6).",10,Partially Matches,"[{'C1': {'code': 'for (i = 0; i < sent_sigslen; i++, sent_sigs++) {\n    if (sig == *sent_sigs)\n        break;\n}\nif (i == sent_sigslen && (lu->hash != NID_sha1 || s->cert->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT)) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_WRONG_SIGNATURE_TYPE);\n    return 0;\n}', 'explanation': ""This segment checks whether the peer's signature algorithm is among the supported ones (i.e. there is an overlap between client‐sent sigalgs and the negotiated algorithm). If not, it aborts the handshake via a fatal alert, which attempts to satisfy the RFC requirement of aborting when no supported parameters are negotiated.""}}]","The RFC specifies that if no supported parameters overlap between client and server, the handshake must be aborted using a fatal alert. In this function, several checks are performed on the peer's signature algorithm, and if the algorithm does not match any of those previously sent by the server (as seen in the loop checking sent_sigs), the function calls SSLfatal with a fatal alert (using SSL_AD_HANDSHAKE_FAILURE or SSL_AD_ILLEGAL_PARAMETER). While the function clearly aborts the handshake when a mismatch is detected, it only addresses this behavior for signature algorithm negotiation and not for all possible parameter negotiations that the RFC might cover. Thus, it partially meets (C1) the spec as a localized check, but does not fully encompass every aspect of the RFC’s negotiation failure handling.",success,
8973,tls1_set_server_sigalgs,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6).",10,Fully Matches,"[{'C1': {'code': 'if (s->shared_sigalgs != NULL)\n    return 1;\n\n/* Fatal error if no shared signature algorithms */\nSSLfatal(s, SSL_AD_HANDSHAKE_FAILURE,\n         SSL_R_NO_SHARED_SIGNATURE_ALGORITHMS);\nreturn 0;', 'explanation': 'This segment checks if there is an overlap between the client and server supported signature algorithms (i.e. a shared set exists). If not, it proceeds to abort the handshake.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_NO_SHARED_SIGNATURE_ALGORITHMS);', 'explanation': ""This call aborts the handshake by sending a 'handshake_failure' fatal alert, directly fulfilling the action required by the specification when no supported set is negotiated.""}}]","The function inspects if there is a shared set of signature algorithms between the client and server. If not, it aborts the handshake using the 'handshake_failure' fatal alert. This directly addresses the RFC requirement that the handshake must be aborted when no overlapping parameters exist.",success,
8973,tls1_set_server_sigalgs,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function tls1_set_server_sigalgs is solely responsible for setting up server signature algorithms. It processes and validates peer signature algorithms and assigns certificate validity flags but does not include any logic pertaining to the negotiation or exclusion of RC4 cipher suites or the enforcement of minimum cipher strength (112 bits). Therefore, the function does not address the conditions and actions specified in the RFC specification regarding the prohibition on RC4 cipher suites and low strength ciphers.",success,
8993,tls1_check_chain,"A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the ""signature_algorithms"" extension.",97,Does Not Match,[],"The TLS RFC specification states that a certificate that begins a certification path (e.g. self‐signed or a trust anchor) MAY use a signature algorithm that is not advertised in the ""signature_algorithms"" extension. In the function tls1_check_chain, the logic for checking signature algorithms is applied uniformly without detecting or exempting a certificate that begins the certification path. In other words, the code does not contain a specific branch or conditional logic to allow the exception specified (i.e. to allow a non‐advertised signature algorithm for a certificate that begins a certification path). Therefore, within the function body itself no segment implements the RFC exception, and the function does not meet the specified constraint.",success,
8993,tls1_check_chain,TLS 1.3 implementations willing to negotiate TLS 1.2 MUST behave in accordance with the requirements of [RFC5246] when negotiating that version.,98,Partially Matches,"[{'C1': {'code': 'if (TLS1_get_version(SSL_CONNECTION_GET_SSL(s)) >= TLS1_2_VERSION && strict_mode) {\n    int default_nid;\n    int rsign = 0;\n\n    if (s->s3.tmp.peer_cert_sigalgs != NULL\n            || s->s3.tmp.peer_sigalgs != NULL) {\n        default_nid = 0;\n    /* If no sigalgs extension use defaults from RFC5246 */\n    } else {\n        switch (idx) {\n        case SSL_PKEY_RSA:\n            rsign = EVP_PKEY_RSA;\n            default_nid = NID_sha1WithRSAEncryption;\n            break;\n\n        case SSL_PKEY_DSA_SIGN:\n            rsign = EVP_PKEY_DSA;\n            default_nid = NID_dsaWithSHA1;\n            break;\n\n        case SSL_PKEY_ECC:\n            rsign = EVP_PKEY_EC;\n            default_nid = NID_ecdsa_with_SHA1;\n            break;\n\n        case SSL_PKEY_GOST01:\n            rsign = NID_id_GostR3410_2001;\n            default_nid = NID_id_GostR3411_94_with_GostR3410_2001;\n            break;\n\n        case SSL_PKEY_GOST12_256:\n            rsign = NID_id_GostR3410_2012_256;\n            default_nid = NID_id_tc26_signwithdigest_gost3410_2012_256;\n            break;\n\n        case SSL_PKEY_GOST12_512:\n            rsign = NID_id_GostR3410_2012_512;\n            default_nid = NID_id_tc26_signwithdigest_gost3410_2012_512;\n            break;\n\n        default:\n            default_nid = -1;\n            break;\n        }\n    }', 'explanation': 'This segment verifies that when the TLS version is 1.2 or higher and strict mode is active, the function examines whether the peer sent a signature_algorithms extension. If the extension is missing, it selects default signature algorithms as specified by RFC5246. This addresses the requirement to follow RFC5246 behavior when negotiating TLS 1.2.'}}, {'A1': {'code': '/* Check signature algorithm of each cert in chain */\nif (SSL_CONNECTION_IS_TLS13(s)) {\n    if (find_sig_alg(s, x, pk) != NULL)\n        rv |= CERT_PKEY_EE_SIGNATURE;\n} else if (!tls1_check_sig_alg(s, x, default_nid)) {\n    if (!check_flags)\n        goto end;\n} else\n    rv |= CERT_PKEY_EE_SIGNATURE;\nrv |= CERT_PKEY_CA_SIGNATURE;\nfor (i = 0; i < sk_X509_num(chain); i++) {\n    if (!tls1_check_sig_alg(s, sk_X509_value(chain, i), default_nid)) {\n        if (check_flags) {\n            rv &= ~CERT_PKEY_CA_SIGNATURE;\n            break;\n        } else\n            goto end;\n    }\n}', 'explanation': 'In this portion, the function verifies that the signature algorithms used in the certificate and its chain comply either with those specified by the peer or, if absent, with the default set from RFC5246. This aligns with the TLS 1.2 requirement that in the absence of the signature_algorithms extension (which ClientHellos may omit per spec), default values should be used.'}}]","The function body demonstrates logic that inspects the TLS version and enforces RFC5246 behaviors when TLS 1.2 is negotiated by checking for the presence of the signature_algorithms extension and falling back to default signature methods if absent. This addresses key aspects of the specification context regarding TLS 1.2 negotiation and signature verification. However, while it clearly implements default behavior and signature algorithm checks, it does not address every aspect mentioned in the broader specification context (for example, handling of self‐signed or trust anchor certificates is referenced but not fully implemented in this function). As a result, the code function partially matches the set of spec constraints as implemented within its own logic.",success,
8998,ssl_security_cert_sig,"A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the ""signature_algorithms"" extension.",97,Partially Matches,"[{'C1': {'code': 'if ((X509_get_extension_flags(x) & EXFLAG_SS) != 0)\n        return 1;', 'explanation': 'This code segment checks if the certificate is self-signed (which indicates that it is likely the certificate that begins a certification path) and bypasses further signature algorithm validation. This behavior aligns with the RFC requirement that a certificate that begins a certification path MAY use a signature algorithm that is not advertised as supported.'}}]","The function contains logic that, when the certificate is self-signed, avoids checking the signature algorithm (thereby allowing a non-advertised algorithm to be used), which partially implements the RFC specification. However, it does not address other aspects of the TLS RFC regarding support advertisement and additional legacy constraints; hence, the implementation only partially matches the specification.",success,
9002,check_cert_usable,"These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2.",86,Fully Matches,"[{'C1': {'code': 'if (sig->hash != NID_undef)\n    mdname = OBJ_nid2sn(sig->hash);\nsupported = EVP_PKEY_digestsign_supports_digest(pkey, sctx->libctx,\n                                                mdname,\n                                                sctx->propq);\nif (supported <= 0)\n    return 0;', 'explanation': 'This segment ensures that the certificate’s public key supports signing with the specified digest algorithm, as required by TLS requirements on certificate signatures.'}}, {'A1': {'code': 'if (s->s3.tmp.peer_cert_sigalgs != NULL) {\n    if (!X509_get_signature_info(x, &mdnid, &pknid, NULL, NULL))\n        return 0;\n    for (i = 0; i < s->s3.tmp.peer_cert_sigalgslen; i++) {\n        lu = tls1_lookup_sigalg(SSL_CONNECTION_GET_CTX(s),\n                                s->s3.tmp.peer_cert_sigalgs[i]);\n        if (lu == NULL)\n            continue;\n\n        if (mdnid == lu->hash && pknid == lu->sig)\n            return 1;\n    }\n    return 0;\n}', 'explanation': ""This block implements the TLS 1.3 'signature_algorithms_cert' extension logic by checking that the certificate’s signature algorithm (hash and key type) matches one of the allowed algorithms specified by the peer. If none match, the certificate is rejected.""}}]","The function first validates that the EVP_PKEY associated with the certificate supports the digest algorithm required by the TLS protocol (addressing, for example, condition C1). It then checks whether the certificate’s signature algorithm is among those permitted by the TLS 1.3 signature_algorithms_cert extension (addressing action A1). In the absence of the extension, it allows any certificate with a viable key, which is also consistent with the TLS specification. Therefore, the code in the function fully addresses the labeled TLS RFC constraints within its own logic.",success,
9006,tls_choose_sigalg,"-The server's end-entity certificate's public key (and associated restrictions) MUST be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension (currently RSA, ECDSA, or EdDSA).",205,Partially Matches,"[{'C1': {'code': 'if (!has_usable_cert(s, lu, sig_idx))\n    continue;\n\nif (lu->sig == EVP_PKEY_RSA_PSS) {\n    EVP_PKEY *pkey = s->cert->pkeys[sig_idx].privatekey;\n    if (!rsa_pss_check_min_key_size(sctx, pkey, lu))\n        continue;\n}', 'explanation': ""The function attempts to ensure that the certificate (its public key and associated restrictions) is compatible with the selected signature algorithm by checking if the certificate is usable (via the has_usable_cert call) and, in the case of RSA-PSS, whether the key size meets minimum requirements. This corresponds to part of the spec requirement that the certificate be compatible with the authentication algorithm selected from the client's signature_algorithms extension.""}}]","The tls_choose_sigalg function examines the client's offered signature algorithms and selects an algorithm that both matches the protocol version requirements and is compatible with the certificate provided by the server. It validates compatibility by checking that the certificate can be used for signing (via has_usable_cert) and, for RSA-PSS, by verifying the key size. However, other aspects of the spec—such as explicit enforcement of certificate type (X.509v3) or checking that the certificate permits digitalSignature usage—are not visibly implemented within this function itself. Therefore, although the function addresses a significant part of the certificate compatibility requirement, it does not fully implement all the spec constraints on its own.",success,
9006,tls_choose_sigalg,"If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client's ""signature_algorithms"" extension unless no valid certificate chain can be produced without unsupported algorithms (see Section 4.2.3).",225,Fully Matches,"[{'C1': {'code': 'if (s->server) {\n    if ((sig_idx = tls12_get_cert_sigalg_idx(s, lu)) == -1)\n        continue;\n}', 'explanation': ""In the non‐TLS13 branch, when the connection is acting as a server (s->server is true) and the client's offered signature_algorithms (reflected in s->shared_sigalgs and s->s3.tmp.peer_sigalgs) are available, the function selects a candidate signature algorithm only if tls12_get_cert_sigalg_idx returns a valid index. This logic ensures that for a server-generated CertificateVerify message, the signature algorithm is one that was offered by the client, as required by the RFC.""}}]","The function clearly distinguishes server from client roles and, in the case of a server, iterates through the shared signature algorithms (which originate from the client's signature_algorithms extension) to select a matching algorithm. By using tls12_get_cert_sigalg_idx to confirm that the candidate algorithm is among those acceptable according to the client's provided data, the function directly implements the condition specified in the RFC. Therefore, within the context of this function alone, the necessary constraint is fully addressed.",success,
9006,tls_choose_sigalg,TLS 1.3 implementations willing to negotiate TLS 1.2 MUST behave in accordance with the requirements of [RFC5246] when negotiating that version.,98,Partially Matches,"[{'C1': {'code': ""if (SSL_CONNECTION_IS_TLS13(s)) {\n    lu = find_sig_alg(s, NULL, NULL);\n    if (lu == NULL) {\n        if (!fatalerrs)\n            return 1;\n        SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE,\n                 SSL_R_NO_SUITABLE_SIGNATURE_ALGORITHM);\n        return 0;\n    }\n} else {\n    /* If ciphersuite doesn't require a cert nothing to do */\n    if (!(s->s3.tmp.new_cipher->algorithm_auth & SSL_aCERT))\n        return 1;\n    ...\n}"", 'explanation': 'This segment clearly distinguishes between TLS 1.3 and TLS 1.2 negotiation. For TLS 1.3, it immediately calls the TLS 1.3 specific function (find_sig_alg) while the TLS 1.2 branch follows a legacy path. This separation is key to the RFC’s requirement for TLS 1.3 implementations willing to negotiate TLS 1.2.'}}, {'A1': {'code': 'if (SSL_USE_SIGALGS(s)) {\n    if (s->s3.tmp.peer_sigalgs != NULL) {\n        ... /* iterates over shared_sigalgs to select an appropriate signature algorithm */\n    } else {\n        /* If we have no sigalg use defaults */\n        const uint16_t *sent_sigs;\n        size_t sent_sigslen;\n\n        if ((lu = tls1_get_legacy_sigalg(s, -1)) == NULL) {\n            if (!fatalerrs)\n                return 1;\n            SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE,\n                     SSL_R_NO_SUITABLE_SIGNATURE_ALGORITHM);\n            return 0;\n        }\n\n        sent_sigslen = tls12_get_psigalgs(s, 1, &sent_sigs);\n        for (i = 0; i < sent_sigslen; i++, sent_sigs++) {\n            if (lu->sigalg == *sent_sigs && has_usable_cert(s, lu, lu->sig_idx))\n                break;\n        }\n        if (i == sent_sigslen) {\n            if (!fatalerrs)\n                return 1;\n            SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE,\n                     SSL_R_WRONG_SIGNATURE_TYPE);\n            return 0;\n        }\n    }\n}', 'explanation': ""This branch handles the scenario when the TLS 1.2 ClientHello may omit the 'signature_algorithms' extension, by falling back to a legacy default signature algorithm. This closely follows the RFC5246 requirements for backward compatibility in TLS 1.2.""}}]","The function implements logic to select a certificate signature algorithm based on the negotiated TLS version. It explicitly differentiates between TLS 1.3 and TLS 1.2 flows, and in the TLS 1.2 branch it correctly handles cases where the 'signature_algorithms' extension is omitted by using legacy defaults. However, the overall context from the RFC also deals with certificate signature validation (e.g., self-signed certificates or trust anchors) which is not addressed within this function. Therefore, while key aspects (C1 and A1) related to selecting signature algorithms under differing TLS version constraints are implemented here, the function does not cover all facets of the RFC spec as provided.",success,
9006,tls_choose_sigalg,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6).",10,Fully Matches,"[{'C1': {'code': 'if (lu == NULL) {\n    if (!fatalerrs)\n        return 1;\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE,\n             SSL_R_NO_SUITABLE_SIGNATURE_ALGORITHM);\n    return 0;\n}', 'explanation': ""This code segment checks if no suitable signature algorithm (i.e. no overlapping parameters) is found. If that's the case and fatalerrs is set, it aborts the handshake by calling SSLfatal, thus enforcing the requirement to abort the handshake when negotiation fails.""}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_NO_SUITABLE_SIGNATURE_ALGORITHM);', 'explanation': 'This is the direct invocation of the fatal alert mechanism as mandated by the specification when no common set of parameters is found.'}}]","The function tls_choose_sigalg is responsible for selecting a suitable signature algorithm based on the client and server parameters. In multiple branches (both TLS 1.3 and earlier versions), the function checks for a matching algorithm and, if none is found, explicitly aborts the handshake by calling SSLfatal with SSL_AD_HANDSHAKE_FAILURE. This matches the spec requirement that the server must abort the handshake with a fatal alert (handshake_failure) when it is unable to negotiate a supported set of parameters.",success,
9006,tls_choose_sigalg,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function tls_choose_sigalg is responsible for selecting signature algorithms in the TLS handshake process. It does not include any logic that restricts or prohibits the use of RC4 cipher suites, nor does it check for ciphers with strength less than 112 bits as mandated by the TLS RFC specification. There are no code segments within this function that address or implement the specified constraints (e.g., not negotiating RC4). Hence, in isolation, this function does not meet the spec constraints.",success,
9039,serverinfoex_srv_parse_cb,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (inlen != 0) {\n        *al = SSL_AD_DECODE_ERROR;\n        return 0;\n    }', 'explanation': 'This code segment checks whether extra data is present after the expected field. According to the spec, if there are any bytes (i.e. if not empty), the handshake must be aborted with a decode_error alert.'}}, {'A1': {'code': '*al = SSL_AD_DECODE_ERROR;\nreturn 0;', 'explanation': 'This segment aborts the handshake by setting the alert to decode_error and returning an error, satisfying the required action of aborting the handshake when the condition is not met.'}}]","The function directly checks that the input data length (inlen) is zero. If it is not, it sets the alert to decode_error and returns an error immediately. This behavior fully implements the specified TLS requirement: if extra data is present, abort the handshake with a decode_error alert. All necessary logic is contained within the function itself.",success,
9039,serverinfoex_srv_parse_cb,"Otherwise, it MUST be set as a zero-length vector (i.e., a zero-valued single byte length field).",19,Fully Matches,"[{'C1': {'code': 'if (inlen != 0) {\n        *al = SSL_AD_DECODE_ERROR;\n        return 0;\n    }', 'explanation': 'This code ensures that if any data is provided (i.e., the vector is not zero-length), an error is produced. This directly implements the RFC requirement that, in cases where the field is not used, it MUST be sent as a zero-length vector.'}}]","The function checks that the incoming data length for the extension is zero. This behavior directly addresses the spec constraint stating that the field must be a zero-length vector when not used. All necessary verification is contained within the function, fulfilling the requirement as specified.",success,
9039,serverinfoex_srv_parse_cb,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (inlen != 0) {\n    *al = SSL_AD_DECODE_ERROR;\n    return 0;\n}', 'explanation': ""This code segment checks if the incoming message length is non-zero—interpreting any content as a syntactic error—and sets the alert to 'decode_error' as required by the RFC when a message cannot be parsed properly.""}}]","The function directly inspects the message length and, if it differs from the expected zero, triggers the decode_error alert. This behavior clearly implements the RFC requirement that messages which cannot be parsed according to the syntax (for instance, due to an out-of-range length) must result in a 'decode_error' alert, fulfilling the designated condition from the specification.",success,
9041,serverinfoex_srv_add_cb,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The TLS 1.3 RFC specification requires that servers MUST NOT act on the status_request_v2 extension when processing ClientHello messages, specifically they must not send this extension in EncryptedExtensions, CertificateRequest, or Certificate messages. In the provided function_body, there is no explicit check or handling logic that relates to the status_request_v2 extension. Its logic is focused on retrieving serverinfo data and identifying an extension for the server certificate, but it does not impose any restrictions on the status_request_v2 extension. Therefore, the code does not attempt to implement the specific constraints related to status_request_v2 as required by the spec.",success,
9045,extension_append_length,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function 'extension_append_length' only calculates a new extension length by adding the result of 'extension_contextoff(version)' to the provided 'extension_length'. There is no logic within this function that checks for or prevents the use of the Truncated HMAC extension (as specified in the RFC constraints) nor does it enforce any record version validation (e.g., ensuring the version is not less than 0x0300). Therefore, no part of the function's code directly addresses any of the labeled constraints from the TLS RFC specification.",success,
9046,extension_append,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided code function 'extension_append' simply appends an extension to a serverinfo buffer after computing a context offset. It does not include any logic to enforce or check the prohibition on using the Truncated HMAC extension (as specified in the RFC) nor does it validate TLS record version numbers (i.e., records with a version less than 0x0300). Thus, none of the spec constraints (e.g., C1/A1 if they refer to these requirements) are visibly addressed by this function alone.",success,
9049,SSL_CTX_use_serverinfo_file,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function, SSL_CTX_use_serverinfo_file, is focused on reading and processing PEM-formatted server information. It parses the data, checks the header consistency, and appends the extensions accordingly. However, it does not include any logic to check or enforce restrictions related to the Truncated HMAC extension (i.e., it does not explicitly ensure that the Truncated HMAC extension is not used), nor does it handle TLS record version constraints. Therefore, the function does not address any of the labeled conditions or actions specified by the RFC.",success,
9053,TLS_method,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function body only registers a TLS method using a macro invocation with parameters such as TLS_ANY_VERSION and TLSv1_2_enc_data. There is no logic within this function that checks or restricts the use of the OpenPGP certificate type with TLS 1.3, as required by RFC6091. Since no part of the code addresses the condition that the OpenPGP certificate type MUST NOT be used with TLS 1.3 (e.g., by examining certificate_list entries or TLS version negotiations), the function does not implement any labeled condition or action from the spec constraints.",success,
9069,tlsv1_client_method,"In particular, it MUST NOT negotiate TLS 1.3.",14,Does Not Match,[],"The function body only invokes IMPLEMENT_tls_meth_func with parameters that set the protocol version to TLS1_VERSION and use TLSv1 client method and encryption data. There is no explicit logic inside this code function that addresses the spec constraint of non-negotiation of TLS 1.3 — for example, there are no condition checks or alert triggering mechanisms for handling a TLS 1.3 ClientHello during renegotiation. Therefore, the function does not visibly implement the TLS RFC requirement as specified.",success,
9073,DTLS_method,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The function_body here is a single call to a macro (IMPLEMENT_dtls1_meth_func) with parameters that define DTLS method behavior. There is no visible logic or code within this function that checks, restricts, or handles the OpenPGP certificate type in relation to TLS 1.3 as specified in RFC6091. Since none of the constraints (such as prohibiting the use of the OpenPGP certificate type with TLS 1.3) are implemented directly within this function, it does not address any of the labeled conditions or actions.",success,
9173,d2i_SSL_SESSION_ex,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function (d2i_SSL_SESSION_ex) is solely responsible for deserializing an SSL_SESSION from its ASN.1 representation. It does not implement any logic concerning the handling or retransmission of early data, nor does it check whether the negotiated connection selects the same ALPN protocol before allowing automatic early data retransmission. Since the TLS RFC specifies that a TLS implementation SHOULD NOT automatically resend early data (except if the ALPN protocols match), and this function provides no such decision-making or verification logic, it does not address the specified constraints in the TLS RFC.",success,
9425,ssl_get_prev_session,"Servers which are authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, though they MAY send it in post-handshake authentication (see Section 4.6.2) provided that the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6).",184,Does Not Match,[],"The provided function focuses on retrieving a previous session, handling session tickets, and verifying session parameters. There is no logic in this function addressing the TLS RFC requirement regarding not sending CertificateRequest messages during the main handshake when using PSK authentication. Specifically, the RFC condition that servers authenticating with a PSK MUST NOT send a CertificateRequest message is not implemented or enforced anywhere in the function_body. Thus, the code function does not visibly address any of the labeled RFC constraints pertaining to CertificateRequest handling.",success,
9425,ssl_get_prev_session,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The RFC specifies that in TLS 1.3, servers MUST NOT act upon or send the status_request_v2 extension. In the provided function, there is no code that inspects, ignores, or prevents the sending of the status_request_v2 extension. The function only handles session retrieval, ticket processing, and checks related to PSK extensions (e.g., psk_kex_modes and psk) but makes no reference to status_request_v2. Therefore, the function does not visibly address any of the conditions or actions outlined by the spec constraint.",success,
9425,ssl_get_prev_session,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function handles session retrieval and session resumption logic for TLS, such as ticket processing, session cache lookup, and consistency verifications (e.g., TLS version, session context, and extended master secret extension). It does not include any code logic to address retransmission of early data or enforcement of ALPN protocol consistency with respect to early data. Since the RFC specification mandates that a TLS implementation SHOULD NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol, and there is no visible handling of early data transmission or ALPN protocol comparison in this function, the function does not implement the specified TLS RFC requirement.",success,
9425,ssl_get_prev_session,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The provided function does not contain any logic that directly enforces or prevents the server from sending a ""psk_key_exchange_modes"" extension. Instead, the function only parses the client's extensions in TLS 1.3 (including TLSEXT_IDX_psk_kex_modes) and handles session resumption. There is no code in this function that addresses the spec requirement (C1) stating that the server MUST NOT send a ""psk_key_exchange_modes"" extension. As a result, within the scope of this function alone, the constraint is not implemented.",success,
9425,ssl_get_prev_session,"If clients offer ""pre_shared_key"" without a ""psk_key_exchange_modes"" extension, servers MUST abort the handshake.",137,Fully Matches,"[{'C1': {'code': 'if (!tls_parse_extension(s, TLSEXT_IDX_psk_kex_modes,\n                                 SSL_EXT_CLIENT_HELLO, hello->pre_proc_exts,\n                                 NULL, 0)\n        || !tls_parse_extension(s, TLSEXT_IDX_psk, SSL_EXT_CLIENT_HELLO,\n                                hello->pre_proc_exts, NULL, 0))\n    return -1;', 'explanation': ""In the TLS 1.3 branch, the code verifies that both the 'psk_key_exchange_modes' and the 'pre_shared_key' extensions are present. If either extension is absent, it immediately returns -1, effectively aborting the handshake. This behavior directly implements the RFC requirement that if a client offers 'pre_shared_key' without the 'psk_key_exchange_modes' extension, the server must abort the handshake.""}}]","The function, in its TLS 1.3 branch, explicitly checks for the presence of both required extensions. By aborting (returning -1) when either is missing, the code visibly addresses the specification that mandates clients must include the 'psk_key_exchange_modes' extension when offering 'pre_shared_key'. Therefore, within the confines of this function, the TLS RFC requirement is fully implemented.",success,
9425,ssl_get_prev_session,"A client MUST provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension.",136,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)) {\n    s->ext.ticket_expected = 1;\n    if (!tls_parse_extension(s, TLSEXT_IDX_psk_kex_modes,\n                             SSL_EXT_CLIENT_HELLO, hello->pre_proc_exts,\n                             NULL, 0)\n            || !tls_parse_extension(s, TLSEXT_IDX_psk, SSL_EXT_CLIENT_HELLO,\n                                    hello->pre_proc_exts, NULL, 0))\n        return -1;\n    ret = s->session;\n}', 'explanation': ""This segment explicitly checks that both the 'psk_key_exchange_modes' extension and the 'pre_shared_key' extension are present in a TLS 1.3 connection. If the 'psk_key_exchange_modes' extension is missing while a 'pre_shared_key' is present, the function returns -1, thus aborting the handshake as required by the RFC specification.""}}]","The function 'ssl_get_prev_session' in its TLS 1.3 branch ensures that if a client offers a 'pre_shared_key' extension, it must also include the 'psk_key_exchange_modes' extension. This direct check and error return in the code clearly implements the requirement described in the specification, fulfilling condition C1.",success,
9425,ssl_get_prev_session,"In order to use PSKs, clients MUST also send a ""psk_key_exchange_modes"" extension.",135,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)) {\n    s->ext.ticket_expected = 1;\n    if (!tls_parse_extension(s, TLSEXT_IDX_psk_kex_modes,\n                             SSL_EXT_CLIENT_HELLO, hello->pre_proc_exts,\n                             NULL, 0)\n            || !tls_parse_extension(s, TLSEXT_IDX_psk, SSL_EXT_CLIENT_HELLO,\n                                    hello->pre_proc_exts, NULL, 0))\n        return -1;\n    ret = s->session;\n}', 'explanation': 'This code segment directly enforces the RFC requirement by checking that when a client sends a pre_shared_key extension (checked via TLSEXT_IDX_psk), it must also include the psk_key_exchange_modes extension (checked via TLSEXT_IDX_psk_kex_modes). If either extension is missing, the handshake is aborted by returning -1.'}}]","The function, in its TLS 1.3 branch, explicitly checks for the presence of both the psk_key_exchange_modes and pre_shared_key extensions. This meets the RFC mandate that if a client offers PSKs, it must also send the psk_key_exchange_modes extension; otherwise, the server should abort the handshake. The logic is self-contained within this function, fulfilling the spec requirement without relying on external dependencies.",success,
9429,SSL_SESSION_free,"Once all the values which are to be derived from a given secret have been computed, that secret SHOULD be erased.",325,Partially Matches,"[{'A1': {'code': 'OPENSSL_cleanse(ss->master_key, sizeof(ss->master_key));\nOPENSSL_clear_free(ss, sizeof(*ss));', 'explanation': 'The code explicitly wipes sensitive data (e.g., the master_key) and clears the session memory, which aligns with the requirement that secrets be erased once they are no longer needed. However, it does not check that all derived values have been computed before erasing, so the implementation only partially addresses the spec requirement.'}}]","The TLS specification states that once all values derived from a given secret have been computed, that secret SHOULD be erased. The function SSL_SESSION_free shows an attempt to protect sensitive information by cleansing the master_key and eventually clearing the complete session memory using OPENSSL_cleanse and OPENSSL_clear_free respectively. While this demonstrates an intent to erase secrets from memory consistent with the guideline, the function does not verify whether all derived values have been computed before performing this erasure. Hence, in isolation, the function partially matches the TLS RFC requirement.",success,
9442,SSL_SESSION_set_cipher,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The function SSL_SESSION_set_cipher only sets the cipher field of an SSL_SESSION structure and returns 1. It does not include any logic related to certificate types, including the requirement that the OpenPGP certificate type [RFC6091] must not be used with TLS 1.3, nor does it address any constraints related to RawPublicKey certificate negotiation or the certificate_list composition as described in the spec. Thus, none of the labeled conditions or actions from the spec constraints are implemented within this function.",success,
9448,SSL_SESSION_get_max_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The function SSL_SESSION_get_max_early_data simply returns the value of s->ext.max_early_data and contains no logic to control or check the automatic retransmission of early data, nor does it validate the ALPN protocol or related conditions outlined in the RFC specification. The function does not implement any of the required behaviors such as preventing automatic retransmission or checking the negotiated ALPN protocol, and therefore does not address any of the labeled conditions/actions.",success,
9449,SSL_SESSION_set_max_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function only assigns a given max_early_data value to the session structure (s->ext.max_early_data) and returns 1. There is no logic in this function that implements any part of the TLS RFC specification regarding the prevention of automatic retransmission of early data or checking whether the negotiated connection selects the same ALPN protocol. As a result, none of the conditions (e.g., C1) or actions (e.g., A1) specified in the RFC or its context are addressed by this function.",success,
9488,tls13_derive_key,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The provided function, tls13_derive_key, solely implements key derivation using HKDF expansion with a fixed label (""key""). There is no logic within the function that addresses or enforces the TLS 1.3 constraint regarding 'obsolete_RESERVED' ranges—that such values should not be offered or negotiated. Therefore, the function does not visibly address the spec constraint related to obsolete_RESERVED values.",success,
9488,tls13_derive_key,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Partially Matches,"[{'A1': {'code': 'return tls13_hkdf_expand(s, md, secret, keylabel, sizeof(keylabel) - 1,\n                         NULL, 0, key, keylen, 1);', 'explanation': 'This line calls the HKDF-Expand function with a proper key label. In TLS 1.3, the spec requires that every HKDF-Extract be followed by one or more HKDF-Expand operations. By using tls13_hkdf_expand directly, this function ensures that an output from HKDF-Extract is not misused as input to another HKDF-Extract without an intervening HKDF-Expand.'}}]","The tls13_derive_key function implements the HKDF-Expand part of the TLS 1.3 key derivation process by calling tls13_hkdf_expand with a designated label, which aligns with the TLS RFC's requirement that each HKDF-Extract be followed by an HKDF-Expand. However, since it only performs the HKDF-Expand and does not itself enforce or check the overall ordering (e.g. preventing chaining of HKDF-Extract calls), it only partially addresses the full set of constraints required by the spec.",success,
9489,tls13_derive_iv,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Fully Matches,"[{'C1': {'code': 'return tls13_hkdf_expand(s, md, secret, ivlabel, sizeof(ivlabel) - 1,\n                             NULL, 0, iv, ivlen, 1);', 'explanation': ""The RFC requires that an output of HKDF-Extract must always be followed by at least one invocation of HKDF-Expand before being reused. This function, by calling tls13_hkdf_expand with a differentiation label ('iv'), clearly implements that requirement.""}}]","The function tls13_derive_iv directly calls tls13_hkdf_expand, thus ensuring that any output from a preceding HKDF-Extract is properly processed through HKDF-Expand. This satisfies the specification's ordering requirement, addressing the condition from the RFC. No other HKDF-Extract invocation chaining is present in this function, so the ordering constraint is fully met.",success,
9490,tls13_derive_finishedkey,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Partially Matches,"[{'C1': {'code': 'return tls13_hkdf_expand(s, md, secret, finishedlabel, sizeof(finishedlabel) - 1, NULL, 0, fin, finlen, 1);', 'explanation': ""This code calls the HKDF-Expand function with a specific label ('finished'), thereby ensuring that an HKDF-Expand invocation occurs after an HKDF-Extract (whose output is expected to be in 'secret'), which aligns with the spec’s requirement that an output of HKDF-Extract should not be directly reused without an intervening HKDF-Expand.""}}]","The function solely implements the HKDF-Expand part of the TLS 1.3 key derivation process by using a predefined 'finished' label. This visible use of HKDF-Expand addresses the ordering requirement in the RFC. However, since no additional constraints or actions (if any others exist) are handled exclusively within this function, it only partially matches the overall TLS RFC specification as provided.",success,
9494,tls13_final_finish_mac,"Once all the values which are to be derived from a given secret have been computed, that secret SHOULD be erased.",325,Partially Matches,"[{'A1': {'code': 'OPENSSL_cleanse(finsecret, sizeof(finsecret));', 'explanation': 'The function erases the local temporary secret (finsecret) immediately before returning, which partially implements the RFC requirement to erase a secret after all derived values have been computed. However, in the branches where the secret is taken directly from s->server_finished_secret or s->client_finished_secret, no such erasure is performed within this function.'}}]","The RFC specifies that once all dependent values have been computed from a given secret, that secret SHOULD be erased. In this function, when the finished key is derived using tls13_derive_finishedkey, the resulting secret is stored in the local variable 'finsecret' which is cleansed using OPENSSL_cleanse before the function returns. This addresses the requirement for that specific case. However, when the secret is directly taken from the SSL_CONNECTION structure (using s->server_finished_secret or s->client_finished_secret), the function does not clear these values. As a result, while part of the action is implemented (the cleansing of finsecret), the overall requirement is only partially met within the scope of this function.",success,
9496,derive_secret_key_and_iv,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Fully Matches,"[{'C1': {'code': 'if (!tls13_hkdf_expand(s, md, insecret, label, labellen, hash, hashlen, secret, hashlen, 1)) { ... }', 'explanation': 'This call ensures that the output (insecret), which would typically be the result of an HKDF-Extract, is immediately processed by an HKDF-Expand before it is used in further key derivations, directly satisfying the RFC requirement to not use an output of HKDF-Extract as an input to another HKDF-Extract without an intervening HKDF-Expand.'}}]","The function 'derive_secret_key_and_iv' implements the ordering constraint from the TLS RFC by invoking tls13_hkdf_expand using the provided 'insecret' along with other parameters to produce a 'secret', which is subsequently used by tls13_derive_key and tls13_derive_iv. This sequence clearly shows that the output from a potential HKDF-Extract is not reused directly for another extract operation, but is properly expanded first, thereby fully matching the spec constraint.",success,
9496,derive_secret_key_and_iv,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function 'derive_secret_key_and_iv' is responsible for deriving secret keys, IVs, and tags using TLS 1.3 HKDF operations. It calculates key lengths, IV lengths, and tag lengths based on the cipher mode but does not contain any logic that prohibits or checks for the usage of the Truncated HMAC extension as specified in Section 7 of RFC6066. In addition, there is no code within the function that verifies the record version (that it is at least 0x0300) or otherwise enforces the prohibition of the Truncated HMAC extension. Therefore, none of the labeled conditions or actions (such as C1 for disallowing the truncated HMAC extension) specified in the RFC are handled by this function in isolation.",success,
9497,tls13_change_cipher_state,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data.",320,Partially Matches,"[{'A1': {'code': 'if (handlen <= 0) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_HANDSHAKE_LENGTH);\n    goto err;\n}\n\n...\n\nif (!ssl_cipher_get_evp_cipher(sctx, sslcipher, &cipher)) {\n    /* Error is already recorded */\n    SSLfatal_alert(s, SSL_AD_INTERNAL_ERROR);\n    goto err;\n}\n\nif (!ssl_cipher_get_evp_md_mac(sctx, sslcipher, &mac_md, &mac_pkey_type, NULL)) {\n    SSLfatal_alert(s, SSL_AD_INTERNAL_ERROR);\n    goto err;\n}\n\n/* ... additional error handling invoking SSLfatal() ... */', 'explanation': 'The function calls SSLfatal() and SSLfatal_alert() at error conditions indicating an attempt to send a fatal alert as specified in the TLS RFC (i.e. upon detecting a fatal error, an appropriate alert is sent).'}}]","The TLS RFC requires that upon a fatal error the implementation should send a fatal alert and then close the connection immediately without further data exchange. In this function, error conditions are detected and fatal alert functions (SSLfatal and SSLfatal_alert) are invoked, which satisfies the alert-sending portion of the specification. However, the function does not implement explicit logic to close the connection within its scope; any connection shutdown is expected to occur elsewhere in the call chain. Therefore, while the function addresses sending fatal alerts (action A1), it does not visibly enforce immediate connection closure as mandated, making the implementation only a partial match.",success,
9497,tls13_change_cipher_state,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function tls13_change_cipher_state does not contain any visible logic that checks for or prevents the use of the Truncated HMAC extension, as required by the specification. While the function does contain logic that handles different cipher suites (including AEAD ciphers) and selects MAC algorithms conditionally, it does not implement an explicit check or any mechanism to disallow or avoid truncated HMAC usage. Thus, based solely on the code within this function (ignoring dependencies), there is no implementation that addresses the spec constraint regarding the prohibition of the Truncated HMAC extension.",success,
9498,tls13_update_key,"Once all the values which are to be derived from a given secret have been computed, that secret SHOULD be erased.",325,Fully Matches,"[{'A1': {'code': 'OPENSSL_cleanse(secret, sizeof(secret));', 'explanation': ""After using the secret to derive keys and set up the record layer, the function calls OPENSSL_cleanse on the local 'secret' buffer. This directly corresponds to the TLS RFC requirement to erase the secret once all values derived from it have been computed.""}}]","The function computes a new secret (used for establishing application traffic secrets), uses it in subsequent operations, and then erases it using OPENSSL_cleanse. This in-function logic fully addresses the TLS RFC specification that the secret should be erased after its derived values have been computed. Although additional secret copies exist elsewhere (like in 'insecret'), this function's responsibility is limited to its local variables, and it successfully erases the computed secret as required.",success,
9500,tls13_export_keying_material,Implementations MUST use the exporter_master_secret unless explicitly specified by the application.,331,Fully Matches,"[{'C1': {'code': 'tls13_hkdf_expand(s, md, s->exporter_master_secret, (const unsigned char *)label, llen, data, datalen, exportsecret, hashsize, 0)', 'explanation': 'The function directly uses s->exporter_master_secret when calling tls13_hkdf_expand, thereby ensuring that the exporter_master_secret is used as mandated by the specification.'}}, {'A1': {'code': 'if (!use_context)\n    contextlen = 0;', 'explanation': 'This code sets the context length to zero when no context is provided, matching the spec requirement that an absent context is treated the same as an empty context.'}}]","The function implements the key parts of the TLS exporter derivation as defined in the RFC. It uses the exporter_master_secret (fulfilling the condition) and handles the context parameter correctly by setting context length to zero when not used. Hence, the code function visibly addresses the specified constraints within its own logic.",success,
9500,tls13_export_keying_material,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Fully Matches,"[{'C1': {'code': 'if (!tls13_hkdf_expand(s, md, s->exporter_master_secret,\n                                  (const unsigned char *)label, llen,\n                                  data, datalen, exportsecret, hashsize, 0)\n            || !tls13_hkdf_expand(s, md, exportsecret, exporterlabel,\n                                  sizeof(exporterlabel) - 1, hash, hashsize,\n                                  out, olen, 0))\n        goto err;', 'explanation': 'The RFC requires that after any application of HKDF-Extract an HKDF-Expand must follow, and that one should not chain HKDF-Extract calls without an intervening expand. This function does not call any HKDF-Extract; instead, it makes two consecutive calls to tls13_hkdf_expand. The first expands the previously derived exporter_master_secret (produced by an HKDF-Extract earlier in the handshake) and the second further expands its output. This ordering satisfies the RFC constraint.'}}]","Within the function body, all operations relevant to key derivation use HKDF-Expand calls without chaining HKDF-Extracts, thereby adhering to the specific TLS RFC requirement regarding ordering. Although the extraction phase is handled elsewhere, the function correctly implements its part by ensuring that any HKDF_Extract output is used only as input to an HKDF-Expand, thus fully matching the constraint.",success,
9501,tls13_export_keying_material_early,Future specifications MUST NOT define a use of exporters that permit both an empty context and no context with the same label.,332,Does Not Match,[],"The RFC specification states that future specifications MUST NOT define a use of exporters that permit both an empty context and no context with the same label. In the provided function, although the context (or lack thereof) is processed by hashing the given 'context' with its provided length (thereby treating a missing context as a zero‐length input akin to an empty context), there is no explicit check or enforcement in the function that forbids using the same exporter label when the context is empty versus absent. Therefore, none of the labeled conditions or actions from the spec constraints are visibly implemented within the function_body.",success,
9501,tls13_export_keying_material_early,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Fully Matches,"[{'C1': {'code': 'if (!tls13_hkdf_expand(s, md, s->early_exporter_master_secret, (const unsigned char *)label, llen, data, datalen, exportsecret, hashsize, 0)\n            || !tls13_hkdf_expand(s, md, exportsecret, exporterlabel, sizeof(exporterlabel) - 1, hash, hashsize, out, olen, 0))\n        goto err;', 'explanation': 'The RFC dictates that every application of HKDF-Extract must be followed by at least one invocation of HKDF-Expand, and in particular, one should never use an output of HKDF-Extract as input to another HKDF-Extract without an intervening HKDF-Expand. In this function, the early exporter master secret (presumably the result of a prior HKDF-Extract) is used only as input to tls13_hkdf_expand (i.e., HKDF-Expand) and its output (exportsecret) is then passed as input to a second tls13_hkdf_expand call. This sequence of operations strictly adheres to the required ordering.'}}]","The function implements the key derivation material export mechanism for TLS 1.3 in a manner that respects the ordering required by the RFC. It does this by ensuring that the output from a prior HKDF-Extract is never directly fed to another HKDF-Extract; instead, it is immediately processed by an HKDF-Expand call. This satisfies the spec constraint that requires an HKDF-Expand to intervene between consecutive HKDF-Extract operations, ensuring that the design aligns with the TLS 1.3 HKDF usage mandates.",success,
9535,ssl3_free,"Once all the values which are to be derived from a given secret have been computed, that secret SHOULD be erased.",325,Partially Matches,"[{'A1': {'code': 'OPENSSL_clear_free(sc->s3.tmp.pms, sc->s3.tmp.pmslen);\n...\nmemset(&sc->s3, 0, sizeof(sc->s3));', 'explanation': 'The function clears sensitive secret data by using OPENSSL_clear_free to erase the pre-master secret (pms) and then zeroing the entire s3 structure with memset. This indicates an attempt to erase secrets after their use. However, it does not check that all derived values have been computed before erasing, thus only partially matching the RFC requirement.'}}]","The RFC specifies that a secret should be erased once all values derived from it have been computed. The code function ssl3_free shows logic for erasing sensitive data (using OPENSSL_clear_free and memset), which is an attempt to fulfill that requirement. Nonetheless, the function does not include explicit logic to verify that all necessary computations have been completed before erasing the secret, meaning it only partially implements the required behavior in isolation.",success,
9536,ssl3_clear,"Once all the values which are to be derived from a given secret have been computed, that secret SHOULD be erased.",325,Partially Matches,"[{'A1': {'code': 'OPENSSL_clear_free(sc->s3.tmp.pms, sc->s3.tmp.pmslen);\n...\nmemset(&sc->s3, 0, sizeof(sc->s3));', 'explanation': 'The function explicitly clears sensitive secret data by first calling OPENSSL_clear_free to zero and free the premaster secret and then using memset to erase the entire s3 structure. This demonstrates an attempt to erase secret material as required by the spec. However, the function does not check or enforce that all values derived from the secret have been computed before the erasure, which only partially meets the specification.'}}]","The TLS RFC requires that a secret be erased once its derived values have been computed. In this function, while there is clear logic to erase sensitive memory (notably the premaster secret and the state in the s3 structure), there is no explicit check ensuring that all derived values have been computed beforehand. As a result, the function shows a partial implementation of the spec constraint within its own code body.",success,
9548,ssl3_choose_cipher,The server MUST ensure that it selects a compatible PSK (if any) and cipher suite.,160,Partially Matches,"[{'C1': {'code': 'if ((alg_k & SSL_PSK) && s->psk_server_callback == NULL)\n                continue;', 'explanation': 'This code checks that if a cipher suite uses PSK for key exchange, then a PSK callback must be set. This prevents the selection of a PSK-based cipher suite when no PSK is available, which is part of ensuring PSK compatibility.'}}, {'A1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)) {\n#ifndef OPENSSL_NO_PSK\n    size_t j;\n    if (s->psk_server_callback != NULL) {\n        for (j = 0; j < s->ssl_pkey_num && !ssl_has_cert(s, j); j++);\n        if (j == s->ssl_pkey_num) {\n            /* There are no certificates */\n            prefer_sha256 = 1;\n        }\n    }\n#endif\n}', 'explanation': 'In TLS 1.3, when no certificate is available (implying reliance on a PSK), the code sets a flag (prefer_sha256) to prioritize cipher suites that employ the SHA-256 hash. This aligns with the RFC’s requirement that externally established PSKs default to using SHA-256.'}}]","The function 'ssl3_choose_cipher' contains logic that partially addresses the TLS RFC requirement to select a compatible PSK and cipher suite. It enforces that if a PSK is involved, a PSK callback must be provided (C1), and in TLS 1.3 it sets a preference for SHA-256 (A1) when there are no certificates available. However, the function does not explicitly verify every aspect of the PSK to cipher suite compatibility as further detailed in the RFC, so it only partially meets the specification.",success,
9551,ssl3_shutdown,"If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation MUST receive a ""close_notify"" alert before indicating end-of-data to the application layer.",318,Fully Matches,"[{'C1': {'code': 'else if (!(sc->shutdown & SSL_RECEIVED_SHUTDOWN)) {\n    size_t readbytes;\n    s->method->ssl_read_bytes(s, 0, NULL, NULL, 0, 0, &readbytes);\n    if (!(sc->shutdown & SSL_RECEIVED_SHUTDOWN)) {\n        return -1;        /* return WANT_READ */\n    }\n}', 'explanation': 'This code segment ensures that the function does not complete the shutdown (i.e. does not indicate end‐of‐data) until a close_notify alert has been received, which is exactly what the specification requires.'}}, {'A1': {'code': 'if (!(sc->shutdown & SSL_SENT_SHUTDOWN)) {\n    sc->shutdown |= SSL_SENT_SHUTDOWN;\n    ssl3_send_alert(sc, SSL3_AL_WARNING, SSL_AD_CLOSE_NOTIFY);\n    if (sc->s3.alert_dispatch > 0)\n        return -1;        /* return WANT_WRITE */\n}', 'explanation': 'This segment sends the close_notify alert to the peer before proceeding with the shutdown, fulfilling the requirement that each party must send a close_notify alert before closing its write side of the connection.'}}]","The function ssl3_shutdown implements the TLS shutdown process in a manner that visibly adheres to the specified RFC requirement. It sends a close_notify alert if it has not been sent already (A1) and it waits to receive a close_notify alert by calling ssl_read_bytes and checking the shutdown flag (C1) before completing the shutdown process. Although other parts of the overall TLS transport management may be handled elsewhere, within its own logic the function fully implements both actions as required by the spec.",success,
9551,ssl3_shutdown,"Either party MAY initiate a close of its write side of the connection by sending a ""close_notify"" alert.",315,Fully Matches,"[{'A1': {'code': 'if (!(sc->shutdown & SSL_SENT_SHUTDOWN)) {\n    sc->shutdown |= SSL_SENT_SHUTDOWN;\n    ssl3_send_alert(sc, SSL3_AL_WARNING, SSL_AD_CLOSE_NOTIFY);\n    if (sc->s3.alert_dispatch > 0)\n        return -1;\n}', 'explanation': ""This code segment checks whether a shutdown alert has already been sent and, if not, sends a 'close_notify' alert with a warning level. This directly implements the TLS RFC requirement that either party may initiate a close by sending a 'close_notify' alert.""}}]","The function implements the TLS close_notify mechanism by ensuring that when the shutdown process is initiated (and provided that the handshake was performed and the 'quiet_shutdown' flag is not set), a 'close_notify' alert is sent to the peer. By setting the SSL_SENT_SHUTDOWN flag and handling alert dispatch, the function visibly addresses the requirement specified in the TLS RFC. All necessary logic is contained within the function body itself, fulfilling the action as required by the spec.",success,
9551,ssl3_shutdown,"This alert SHOULD be followed by a ""close_notify"".",314,Fully Matches,"[{'A1': {'code': 'if (!(sc->shutdown & SSL_SENT_SHUTDOWN)) {\n    sc->shutdown |= SSL_SENT_SHUTDOWN;\n    ssl3_send_alert(sc, SSL3_AL_WARNING, SSL_AD_CLOSE_NOTIFY);\n    if (sc->s3.alert_dispatch > 0)\n        return -1;\n}', 'explanation': 'This segment explicitly sets the shutdown flag and sends a close_notify alert. Because the TLS RFC requires that an alert (such as user_canceled) be followed by a close_notify, this code implements that behavior directly by ensuring that close_notify is sent when appropriate.'}}]","Analyzing the function independently shows that, when conditions indicate a full shutdown and handshake completion, the function sends a 'close_notify' alert via ssl3_send_alert. This directly implements the action mandated by the TLS RFC specification. Therefore, the function fully matches the specified constraint by its internal logic without relying on external dependency calls.",success,
9551,ssl3_shutdown,"Each party MUST send a ""close_notify"" alert before closing its write side of the connection, unless it has already sent some error alert",317,Partially Matches,"[{'C1': {'code': 'if (!(sc->shutdown & SSL_SENT_SHUTDOWN)) {\n    sc->shutdown |= SSL_SENT_SHUTDOWN;\n    ssl3_send_alert(sc, SSL3_AL_WARNING, SSL_AD_CLOSE_NOTIFY);\n    if (sc->s3.alert_dispatch > 0)\n        return -1;        /* return WANT_WRITE */\n}', 'explanation': ""This code segment checks whether a shutdown alert has already been sent and, if not, it sends a 'close_notify' alert. This addresses the core requirement of the RFC that each party must send a 'close_notify' alert before closing its write side. However, it does not explicitly check for the condition that it should not send if an error alert was already sent (it uses the 'quiet_shutdown' flag to bypass sending in some circumstances), so the function only partially implements the full constraint.""}}]","The tls shutdown function sends a 'close_notify' alert before closing the write side in the normal operation path (when handshake is complete and quiet_shutdown is not set), which visibly implements part of the RFC requirement. However, the RFC states that a close_notify alert must be sent unless an error alert has been already sent, and this nuance is not clearly handled in the function (instead, it relies on the quiet_shutdown flag and handshake check). Thus, while the function addresses the main action of sending the close_notify alert, it does not fully cover all conditions specified by the RFC.",success,
9552,ssl3_write,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Does Not Match,[],"The target function only handles writing application data by calling s->method->ssl_write_bytes with SSL3_RT_APPLICATION_DATA. It does not contain any logic addressing even one of the RFC constraints regarding alert messages, such as preventing fragmentation of alert messages or coalescing multiple alerts into a single record. The function does not implement any checks or handling for alert types as described in the specification. Therefore, no part of the function meets the conditions (e.g., C1) or actions (e.g., A1) related to alert message processing.",success,
9559,ssl_fill_hello_random,"The last 8 bytes MUST be overwritten as described below if negotiating TLS 1.2 or TLS 1.1, but the remaining bytes MUST be random.",30,Fully Matches,"[{'C1': {'code': 'ret = RAND_bytes_ex(SSL_CONNECTION_GET_CTX(s)->libctx, result, len, 0);\n\n... \nret = RAND_bytes_ex(SSL_CONNECTION_GET_CTX(s)->libctx, p, len - 4, 0);', 'explanation': 'These calls to RAND_bytes_ex fill the entire random buffer (or the portion following a timestamp if send_time is true) ensuring that all bytes are generated from a secure random source. This meets the requirement that the remaining bytes MUST be random.'}}, {'A1': {'code': 'if (ret > 0) {\n    if (!ossl_assert(sizeof(tls11downgrade) < len) || !ossl_assert(sizeof(tls12downgrade) < len))\n         return 0;\n    if (dgrd == DOWNGRADE_TO_1_2)\n        memcpy(result + len - sizeof(tls12downgrade), tls12downgrade, sizeof(tls12downgrade));\n    else if (dgrd == DOWNGRADE_TO_1_1)\n        memcpy(result + len - sizeof(tls11downgrade), tls11downgrade, sizeof(tls11downgrade));\n}', 'explanation': 'This block checks that there is enough room in the buffer and then, if the downgrade flag indicates TLS 1.2 or TLS 1.1, overwrites the final bytes (assumed to be 8 bytes) with the appropriate downgrade constant. This implements the requirement to overwrite the last 8 bytes.'}}]","The function first generates a random sequence (with an optional timestamp prefix) using a secure random generator and then conditionally overwrites the last portion of the buffer with downgrade constants if the connection is being negotiated for TLS 1.2 or TLS 1.1. This logic directly implements the RFC specification: ensuring all but the last 8 bytes are randomly generated, and the last 8 bytes are overwritten with specific downgrade values.",success,
9560,ssl_generate_master_secret,"Once all the values which are to be derived from a given secret have been computed, that secret SHOULD be erased.",325,Fully Matches,"[{'A1': {'code': 'OPENSSL_clear_free(s->s3.tmp.psk, psklen);\n...\nOPENSSL_clear_free(pskpms, pskpmslen);\n...\nif (pms) {\n    if (free_pms)\n        OPENSSL_clear_free(pms, pmslen);\n    else\n        OPENSSL_cleanse(pms, pmslen);\n}', 'explanation': ""The code explicitly clears and frees secret materials after they have been used to derive the master secret. In the PSK branch, it frees s->s3.tmp.psk and the locally allocated 'pskpms' after using them. In both branches, after computing the master secret, it uses OPENSSL_clear_free or OPENSSL_cleanse to erase the pre-master secret (pms). This fulfills the RFC requirement that once all derived values are computed from a given secret, that secret should be erased.""}}]","The TLS RFC requires that once all values derived from a given secret are computed, the secret must be erased from memory. This function meets that requirement entirely on its own by explicitly clearing and freeing the sensitive secret material using functions such as OPENSSL_clear_free and OPENSSL_cleanse immediately after their use. All erasure logic is contained within the function, independent of any external caller or dependency.",success,
9562,ssl_generate_pkey_group,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided code function 'ssl_generate_pkey_group' is solely focused on generating a cryptographic key for a TLS group and does not contain any logic related to cipher suite selection or negotiation. Specifically, it does not implement any checks or conditions that would prevent the offering or negotiation of RC4 cipher suites, nor does it verify the cipher strength requirement (i.e., ciphers less than 112 bits). Therefore, no part of the function directly implements the specified RFC that mandates not offering or negotiating RC4 cipher suites, and it does not address any corresponding labeled condition (e.g., C1) or action (e.g., A1) from the spec constraints.",success,
9564,ssl_gensecret,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The provided function_body does not implement any logic related to the TLS RFC specification stating that values within the 'obsolete_RESERVED' ranges must not be offered or negotiated by TLS 1.3 implementations. The code only distinguishes between TLS1.3 and non-TLS1.3 paths to generate early or master secrets and does not inspect or restrict any 'obsolete_RESERVED' values. Therefore, no part of the function addresses the corresponding condition or action from the spec.",success,
9565,ssl_derive,"Once all the values which are to be derived from a given secret have been computed, that secret SHOULD be erased.",325,Does Not Match,[],"The RFC spec requires that once all values derived from a secret have been computed, that secret should be erased. In the provided function, the secret (pms) is cleared via OPENSSL_clear_free() only in the error path and only if the memory is still held in the local variable. In the branch where gensecret is false, the secret is stored in the s->s3.tmp.pms field and is not erased within this function. As a result, the function does not fully implement the requirement to erase the secret after all derivations.",success,
9566,ssl_decapsulate,"Once all the values which are to be derived from a given secret have been computed, that secret SHOULD be erased.",325,Partially Matches,"[{'A1': {'code': 'OPENSSL_clear_free(pms, pmslen);', 'explanation': 'In the gensecret branch, after deriving values via ssl_gensecret(pms, pmslen), the function calls OPENSSL_clear_free() to clear and free the memory allocated for the secret. This indicates an effort to erase the secret once derived values have been computed.'}}]","The TLS RFC specification requires that once all values derived from a secret have been computed, the secret SHOULD be erased. In this function, when gensecret is true, the derived secret is passed to ssl_gensecret() and then the secret is cleared using OPENSSL_clear_free(), which partially meets the requirement. However, when gensecret is false, the premaster secret (pms) is stored to s->s3.tmp.pms without immediate erasure, relying on later processing for cleanup. Because the secret is not cleared by this function in the alternative branch, the implementation only partially addresses the spec constraint within the function_body.",success,
9566,ssl_decapsulate,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function ssl_decapsulate solely focuses on the decapsulation of a pre-master secret using EVP_PKEY decapsulation functions. It does not contain any logic aimed at offering or negotiating cipher suites, RC4 in particular, nor does it check or refuse RC4-based cipher suites. Therefore, it does not visibly address the spec constraint that implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS.",success,
9567,ssl_encapsulate,"Once all the values which are to be derived from a given secret have been computed, that secret SHOULD be erased.",325,Partially Matches,"[{'A1': {'code': 'if (gensecret) {\n    rv = ssl_gensecret(s, pms, pmslen);\n} ...\n\nerr:\n    OPENSSL_clear_free(pms, pmslen);', 'explanation': 'In the branch where gensecret is true, the function uses the pms to derive further secrets via ssl_gensecret and then clears the memory holding pms by calling OPENSSL_clear_free. This aligns with the RFC requirement to erase the secret after use. However, in the alternative branch (gensecret false), the secret is stored in s->s3.tmp.pms for later use and is not cleared in this function, so the erasure requirement is deferred and not handled fully within this code function.'}}]","The RFC requirement states that once all values derived from a given secret have been computed, the secret SHOULD be erased. The code function addresses this in the gensecret branch by clearing pms immediately after use. However, when gensecret is false the premaster secret is stored in the connection’s temporary structure without being erased, leaving its erasure for later (presumably in another part of the system). Since the function does not consistently erase the secret in all cases, it only partially matches the RFC requirement.",success,
9930,dtls1_read_bytes,"Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure.",283,Fully Matches,"[{'A1': {'code': 'if (len == 0) {\n    /* Release a zero length record. This ensures multiple calls to\n     * SSL_read() with a zero length buffer will eventually cause\n     * SSL_pending() to report data as being available. */\n    if (rr->length == 0 && !ssl_release_record(sc, rr, 0))\n        return -1;\n    return 0;\n}', 'explanation': 'This code block explicitly handles zero-length fragments of Application Data. Since the RFC permits zero-length fragments as a countermeasure against traffic analysis, the function’s special-case for len == 0 directly implements that behavior.'}}]","The function dtls1_read_bytes contains dedicated logic for when a zero-length read is requested, releasing a zero-length record as allowed by the RFC. This demonstrates that the function, by itself, visibly addresses the TLS specification requirement that zero-length Application Data fragments may be sent.",success,
9930,dtls1_read_bytes,"If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation MUST receive a ""close_notify"" alert before indicating end-of-data to the application layer.",318,Fully Matches,"[{'C1': {'code': 'if (alert_descr == SSL_AD_CLOSE_NOTIFY) {\n#ifndef OPENSSL_NO_SCTP\n    if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n        BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)) > 0) {\n        sc->d1->shutdown_received = 1;\n        sc->rwstate = SSL_READING;\n        BIO_clear_retry_flags(SSL_get_rbio(s));\n        BIO_set_retry_read(SSL_get_rbio(s));\n        return -1;\n    }\n#endif\n    sc->shutdown |= SSL_RECEIVED_SHUTDOWN;\n    return 0;\n}', 'explanation': ""This code segment explicitly detects a 'close_notify' alert (when alert_descr equals SSL_AD_CLOSE_NOTIFY) and sets the shutdown flag before returning 0. This behavior enforces that the TLS implementation does not indicate end-of-data to the application until a 'close_notify' alert has been received, as specified in the RFC.""}}, {'A1': {'code': 'if (sc->shutdown & SSL_RECEIVED_SHUTDOWN) {\n    if (!ssl_release_record(sc, rr, 0))\n        return -1;\n    sc->rwstate = SSL_NOTHING;\n    return 0;\n}', 'explanation': ""This snippet ensures that once the shutdown flag has been set (due to a received 'close_notify'), the function immediately indicates end-of-data by returning 0, in compliance with the specified requirement.""}}]","The function 'dtls1_read_bytes' contains explicit logic to handle a 'close_notify' alert. It checks for incoming alert records, and when a warning level alert with the 'close_notify' descriptor is encountered, it sets the shutdown flag and returns 0. This directly implements the RFC requirement that the TLS implementation MUST receive a 'close_notify' alert before end-of-data is indicated to the application layer. The relevant code segments within the function itself satisfy the labeled constraints (C1 for receiving the close_notify and A1 for acting on it) without relying on external dependencies.",success,
9930,dtls1_read_bytes,"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",272,Partially Matches,"[{'A1': {'code': 'default:\n        SSLfatal(sc, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_RECORD);\n        return -1;', 'explanation': ""This code segment in the switch block terminates the connection with an 'unexpected_message' alert when an unexpected record type is encountered, which addresses the action required by the spec.""}}]","The TLS RFC requires that if an unexpected record type is received the connection must be terminated with an 'unexpected_message' alert. In this function, the default case in the switch statement calls SSLfatal with the SSL_AD_UNEXPECTED_MESSAGE alert and then returns -1, thereby implementing this behavior. However, the spec also mandates that change_cipher_spec records be processed specially (e.g. dropping unencrypted CCS records consisting solely of the byte value 0x01, and aborting otherwise), but this function does not explicitly verify the value of the change_cipher_spec record nor does it implement additional checks regarding protected versus unprotected records. Thus, while the function does address the unexpected record type action, it only partially meets the complete range of behaviors outlined in the RFC specification.",success,
9930,dtls1_read_bytes,"If an implementation detects a change_cipher_spec record received before the first ClientHello message or after the peer's Finished message, it MUST be treated as an unexpected record type (though stateless servers may not be able to distinguish these cases from allowed cases).",270,Partially Matches,"[{'C1': {'code': ""if (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC) {\n    /*\n     * We can't process a CCS now, because previous handshake messages\n     * are still missing, so just drop it.\n     */\n    if (!ssl_release_record(sc, rr, 0))\n        return -1;\n    goto start;\n}"", 'explanation': 'This segment detects a record of type change_cipher_spec and simply drops it (by releasing the record and re-looping) instead of processing it. This demonstrates that the function is aware of CCS records and handles them specially.'}}]","The RFC requires that if a change_cipher_spec record is received before the first ClientHello or after the peer's Finished message, it must be treated as an unexpected record type and the connection aborted with an 'unexpected_message' alert. The function does check for CCS records and drops them when they are encountered in certain contexts (e.g. when handshake records are still expected), which partially addresses the specified behavior. However, the function does not explicitly distinguish between a valid CCS record (the allowed plaintext 0x01 between ClientHello and Finished) and one received in an already unexpected state (either too early or too late) that should trigger an alert. Instead of aborting the connection with an 'unexpected_message' alert when required by the spec, it simply drops the record. Therefore, while it implements some logic to handle CCS records, it does not fully fulfill the RFC’s constraint regarding unexpected CCS record ordering.",success,
9930,dtls1_read_bytes,An implementation may receive an unencrypted record of type change_cipher_spec consisting of the single byte value 0x01 at any time after the first ClientHello message has been sent or received and before the peer's Finished message has been received and MUST simply drop it without further processing.,268,Partially Matches,"[{'A1': {'code': ""if (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC) {\n    /*\n     * We can't process a CCS now, because previous handshake messages\n     * are still missing, so just drop it.\n     */\n    if (!ssl_release_record(sc, rr, 0))\n        return -1;\n    goto start;\n}"", 'explanation': 'This segment drops any received ChangeCipherSpec records without further processing, which aligns with the RFC requirement to simply drop such records. However, the code does not verify that the record holds the single byte value 0x01 or that it is received specifically between the ClientHello and Finished messages.'}}]","The function contains logic to drop ChangeCipherSpec records as required by the specification (action A1), but it does not fully check the detailed conditions (e.g., content value of 0x01 and proper timing with regard to the handshake state). As a result, while the dropping mechanism is implemented, the handling is only partially compliant with the full RFC specification.",success,
9930,dtls1_read_bytes,"Upon transmission or receipt of a fatal alert message, both parties MUST immediately close the connection.",319,Fully Matches,"[{'C1': {'code': 'else if (alert_level == SSL3_AL_FATAL) {\n            sc->rwstate = SSL_NOTHING;\n            sc->s3.fatal_alert = alert_descr;\n            SSLfatal_data(sc, SSL_AD_NO_ALERT,\n                          SSL_AD_REASON_OFFSET + alert_descr,\n                          ""SSL alert number %d"", alert_descr);\n            sc->shutdown |= SSL_RECEIVED_SHUTDOWN;\n            if (!ssl_release_record(sc, rr, 0))\n                return -1;\n            SSL_CTX_remove_session(sc->session_ctx, sc->session);\n            return 0;\n        }', 'explanation': 'This segment detects a fatal alert message (a condition required by the spec) and immediately sets the shutdown flag, releases the record and removes the session, effectively closing the connection as mandated.'}}]","The TLS spec requires that upon transmission or receipt of a fatal alert, the connection must be immediately closed. In this function, when a fatal alert (SSL3_AL_FATAL) is received, the code sets the shutdown flag, cleans up the session, and returns, effectively ensuring that the connection is closed immediately. Thus, the function fully addresses the receipt side of the requirement.",success,
9930,dtls1_read_bytes,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data.",320,Fully Matches,"[{'C1': {'code': 'if ((type && (type != SSL3_RT_APPLICATION_DATA) && (type != SSL3_RT_HANDSHAKE)) || (peek && (type != SSL3_RT_APPLICATION_DATA))) {\n    SSLfatal(sc, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return -1;\n}\n\n... \nif (!PACKET_buf_init(&alert, alert_bytes, rr->length) || !PACKET_get_1(&alert, &alert_level) || !PACKET_get_1(&alert, &alert_descr) || PACKET_remaining(&alert) != 0) {\n    SSLfatal(sc, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_INVALID_ALERT);\n    return -1;\n}\n\n... \nelse if (alert_level == SSL3_AL_FATAL) {\n    sc->rwstate = SSL_NOTHING;\n    sc->s3.fatal_alert = alert_descr;\n    SSLfatal_data(sc, SSL_AD_NO_ALERT, SSL_AD_REASON_OFFSET + alert_descr, ""SSL alert number %d"", alert_descr);\n    sc->shutdown |= SSL_RECEIVED_SHUTDOWN;\n    if (!ssl_release_record(sc, rr, 0))\n        return -1;\n    SSL_CTX_remove_session(sc->session_ctx, sc->session);\n    return 0;\n}', 'explanation': 'The function detects various error conditions (e.g., invalid type, invalid alert format, unexpected messages) and in those cases immediately calls the SSLfatal() or SSLfatal_data() routines, thereby treating them as fatal errors.'}}, {'A1': {'code': 'SSLfatal(sc, ...); \n...\nsc->shutdown |= SSL_RECEIVED_SHUTDOWN;\nreturn -1;\n\n... \n// In the fatal alert branch:\nelse if (alert_level == SSL3_AL_FATAL) {\n    ...\n    SSLfatal_data(sc, ...);\n    sc->shutdown |= SSL_RECEIVED_SHUTDOWN;\n    ...\n    return 0;\n}', 'explanation': 'Upon encountering a fatal error, the function sends an appropriate fatal alert via SSLfatal() or SSLfatal_data() and then sets the shutdown flag (sc->shutdown |= SSL_RECEIVED_SHUTDOWN) so that no additional data is processed, effectively closing the connection per TLS RFC requirements.'}}]","The provided code function detects fatal error conditions (for example, when receiving an unexpected record type, an invalid alert message, or encountering handshake anomalies) and responds by calling SSLfatal/SSLfatal_data to send a fatal alert. It further prevents further data processing by setting shutdown flags and returning immediately. This behavior aligns with the specification from the TLS RFC which mandates sending a fatal alert and closing the connection without further data exchange.",success,
9930,dtls1_read_bytes,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Partially Matches,[],"The RFC requires that if a handshake message is received in an unexpected order, the peer must abort the handshake with an 'unexpected_message' alert. In the function, there are several places where SSLfatal() is called with an alert type of SSL_AD_UNEXPECTED_MESSAGE (for example, when application data is received during the initial handshake or when an unexpected record type is encountered in the switch(default) branch). However, when an unexpected handshake record is received (i.e. when rr->type == SSL3_RT_HANDSHAKE and the state does not indicate an expected handshake), the function does not immediately abort the handshake; instead, it may invoke the handshake function again (after checking the message header) in an attempt to re‐enter init. This indicates that while some parts of the function do attempt to signal an unexpected message condition via fatal alerts, it does not consistently abort the handshake in all cases of receiving a handshake message in an unexpected order as required by the RFC. Therefore, the implementation only partially matches the specified constraint.",success,
9930,dtls1_read_bytes,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function 'dtls1_read_bytes' does not include any logic that checks, processes, or prevents the automatic resending of early data based on the negotiation of the ALPN protocol. The RFC specifies that a TLS implementation MUST NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol, but there is no condition in the code that verifies an early_data state or ALPN protocol matching. Therefore, none of the labeled constraints from the specification (e.g., C1, A1) are visibly addressed within the function's body.",success,
9932,do_dtls1_write,"Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure.",283,Does Not Match,[],"The RFC specifies that zero‐length fragments of Application Data MAY be sent as a countermeasure against traffic analysis. However, the function immediately returns when len == 0 (line: 'if (len == 0) return 0;'), without constructing or sending a zero‐length record. This behavior means that the function does not attempt to implement the RFC's provision regarding zero-length Application Data fragments.",success,
9932,do_dtls1_write,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Does Not Match,[],"The provided function, do_dtls1_write, is focused on writing DTLS records and managing alerts. It does not contain any logic related to preventing negotiation of SSL 3.0 or any checks regarding cipher strength (i.e., ciphers below 112 bits), as required by the spec context. All protocol version handling in this function is related to DTLS (and using DTLS1_VERSION) without any explicit mechanism to block SSL 3.0 negotiation. Therefore, no labeled conditions or actions from the spec constraints (specifically regarding the prohibition of SSL 3.0) are implemented within this function.",success,
9932,do_dtls1_write,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The provided function, do_dtls1_write, does not contain any code that explicitly checks or prevents the negotiation or sending of SSL version 2.0 compatible messages as required by the specification. Although there is a conditional branch that sets the version field (using DTLS_ANY_VERSION and sc->max_proto_version conditions), there is no logic that directly implements the security requirement of not supporting SSL 2.0. The function is focused on writing DTLS records and does not visibly enforce the TLS RFC constraints regarding SSL 2.0 compatibility in client-hello messages.",success,
9932,do_dtls1_write,Implementations MUST NOT send any records with a version less than 0x0300.,397,Does Not Match,[],"The TLS RFC specification requires that implementations MUST NOT send any records with a version less than 0x0300. In the provided function, although a version is selected (either DTLS1_VERSION or sc->version based on conditions), there is no explicit logic to check or enforce that the version is not less than 0x0300. The function lacks any safeguard or abort mechanism if an invalid version (< 0x0300) is used, meaning it does not directly implement the specified constraint within its own logic.",success,
9964,ossl_get_max_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The specified RFC constraint states that a TLS implementation SHOULD NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol, ensuring that retransmission decisions are left to the application. The function ossl_get_max_early_data simply computes and returns a value for the maximum early data allowed based on session parameters. It does not contain any logic that checks ALPN protocols or prevents automatic retransmission of early data. Thus, no part of the function directly implements the specified condition or action from the TLS RFC.",success,
9965,ossl_early_data_count_ok,"A server receiving more than max_early_data_size bytes of 0-RTT data SHOULD terminate the connection with an ""unexpected_message"" alert.",252,Fully Matches,"[{'C1': {'code': 'if (s->early_data_count + length > max_early_data) {\n    SSLfatal(s, send ? SSL_AD_INTERNAL_ERROR : SSL_AD_UNEXPECTED_MESSAGE,\n             SSL_R_TOO_MUCH_EARLY_DATA);\n    return 0;\n}', 'explanation': 'This segment checks whether adding the incoming data would exceed the max allowed 0-RTT data (after accounting for any overhead), which directly corresponds to the condition specified in the RFC.'}}, {'A1': {'code': 'SSLfatal(s, send ? SSL_AD_INTERNAL_ERROR : SSL_AD_UNEXPECTED_MESSAGE, SSL_R_TOO_MUCH_EARLY_DATA);', 'explanation': ""This call terminates the connection with an alert. In the receiving case (send == 0) it uses the 'unexpected_message' alert, as required by the RFC.""}}]","The function retrieves the maximum allowed early data size, adjusts it by any overhead for ciphertext, and then verifies whether the cumulative early data (s->early_data_count + length) exceeds this limit. If the limit is exceeded, it terminates the connection by calling SSLfatal with an alert, where in the receiving branch (send == 0) it uses the 'unexpected_message' alert exactly as specified in the TLS RFC. Thus, the code visibly addresses both the condition (C1) and the corresponding action (A1) as required.",success,
9965,ossl_early_data_count_ok,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function only validates that the cumulative early data does not exceed a pre-determined maximum by checking and updating s->early_data_count. It does not contain any logic to determine whether early data should be automatically retransmitted or to verify that the ALPN protocol has not changed. Therefore, it does not attempt to address the spec constraint requiring that a TLS implementation SHOULD NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol.",success,
9972,ssl3_write_bytes,"legacy_record_version: MUST be set to 0x0303 for all records generated by a TLS 1.3 implementation other than an initial ClientHello (i.e., one not generated after a HelloRetryRequest), where it MAY also be 0x0301 for compatibility purposes.",285,Fully Matches,"[{'C1': {'code': 'recversion = (s->version == TLS1_3_VERSION) ? TLS1_2_VERSION : s->version;\n    if (SSL_get_state(ssl) == TLS_ST_CW_CLNT_HELLO\n            && !s->renegotiate\n            && TLS1_get_version(ssl) > TLS1_VERSION\n            && s->hello_retry_request == SSL_HRR_NONE)\n        recversion = TLS1_VERSION;\n\n... \n\nfor (j = 0; j < maxpipes; j++) {\n    tmpls[j].type = type;\n    tmpls[j].version = recversion;\n    tmpls[j].buf = &(buf[tot]) + (j * split_send_fragment);\n    tmpls[j].buflen = split_send_fragment;\n}\n', 'explanation': 'The function sets the legacy_record_version field by first choosing TLS1_2_VERSION (0x0303) when s->version indicates TLS1_3_VERSION and then, in the case of an initial ClientHello (detected via SSL_get_state, absence of renegotiation, version check, and no HelloRetryRequest), it resets recversion to TLS1_VERSION (0x0301). This logic directly implements the RFC requirement that the legacy_record_version MUST be 0x0303 for TLS 1.3 records except for an initial ClientHello, where it may be 0x0301 for compatibility.'}}]","The code function directly computes the legacy_record_version as required by the spec. It uses a ternary operator to set the version to TLS1_2_VERSION (equivalent to 0x0303) for TLS 1.3, and conditionally sets it to TLS1_VERSION (0x0301) for an initial ClientHello, thereby fully matching the specified constraint.",success,
9972,ssl3_write_bytes,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The TLS RFC specifies that an implementation SHOULD NOT automatically resend early data and MUST NOT do so unless the negotiated connection selects the same ALPN protocol. In the provided function_body, while there is a check for early data state (for example, the condition 'if (s->early_data_state == SSL_EARLY_DATA_WRITING && !ossl_early_data_count_ok(s, len, 0, 1))') that appears to validate early data usage, there is no visible logic within this function that prevents automatic retransmission of early data or verifies that the ALPN protocol of the connection matches before a resend is performed. The function does not implement any conditional handling according to the specified constraints (e.g., no check on negotiated ALPN protocol) but simply proceeds with writing the provided data if early data conditions seem acceptable. Therefore, no labeled condition (C1, etc.) or action (A1, etc.) from the specification is fully addressed in this function.",success,
9972,ssl3_write_bytes,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function ssl3_write_bytes focuses on writing records, fragmenting data, handling early data states, and managing state transitions for sending data. It does not contain any logic or checks related to cipher suite selection or negotiation, and hence does not address the RFC specification requirement that implementations MUST NOT offer or negotiate RC4 cipher suites. There are no code segments in this function that exclude RC4 or perform any cipher strength verification.",success,
9975,ssl3_read_bytes,"If an implementation detects a change_cipher_spec record received before the first ClientHello message or after the peer's Finished message, it MUST be treated as an unexpected record type (though stateless servers may not be able to distinguish these cases from allowed cases).",270,Partially Matches,"[{'C1': {'code': 'if (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_CCS_RECEIVED_EARLY);\n    return -1;\n}', 'explanation': 'This block detects a ChangeCipherSpec record arriving in an unexpected context (i.e. when a handshake is expected) and aborts the connection, which corresponds to the condition of receiving a CCS before the ClientHello or after the Finished message.'}}, {'A1': {'code': 'if (s->s3.change_cipher_spec && (rr->type != SSL3_RT_HANDSHAKE)) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);\n    return -1;\n}', 'explanation': ""This segment causes an abort with an 'unexpected_message' alert when a CCS has already been processed (i.e. the change_cipher_spec flag is set) but a non-handshake record is now received, fulfilling the action requirement to terminate the connection on unexpected CCS records.""}}]","The function contains explicit checks for a ChangeCipherSpec record in contexts where it is not expected. In particular, it aborts the connection with an unexpected_message alert if a CCS record is received either out-of-order (i.e. during a handshake where CCS is not allowed) or after a change_cipher_spec flag has been set. These checks address key parts of the RFC requirement (e.g. treating unexpected CCS records as errors). However, the code does not show logic for the allowed scenario (dropping the record without error) when a CCS record is received between the first ClientHello and the peer’s Finished message. Thus, only some of the specified conditions and actions are visibly implemented within this function, making the match partial.",success,
9975,ssl3_read_bytes,"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",272,Fully Matches,"[{'C1': {'code': 'default:\n        /*\n         * TLS 1.0 and 1.1 say you SHOULD ignore unrecognised record types, but\n         * TLS 1.2 says you MUST send an unexpected message alert. We use the\n         * TLS 1.2 behaviour for all protocol versions to prevent issues where\n         * no progress is being made and the peer continually sends unrecognised\n         * record types, using up resources processing them.\n         */\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_RECORD);\n        return -1;', 'explanation': ""This segment (in the default case within the switch) enforces that if the record type received does not match any of the expected types, the connection is terminated with an 'unexpected_message' alert, exactly as specified.""}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_RECORD);', 'explanation': 'By invoking SSLfatal with the alert SSL_AD_UNEXPECTED_MESSAGE when an unexpected record type is encountered, the function implements the action required by the RFC that mandates terminating the connection with the specified alert.'}}]","The function inspects the received record type and compares it with the expected type provided by the caller. When the record type is not one of those allowed (or in cases where a change_cipher_spec is received at an inappropriate time), the code eventually reaches a default branch (or specific error branches) that calls SSLfatal with the SSL_AD_UNEXPECTED_MESSAGE alert. This behavior directly addresses the TLS RFC requirement which states that an unexpected record type must result in terminating the connection with an 'unexpected_message' alert. Therefore, within this function itself (independent of its dependencies), the marked constraint is fully implemented.",success,
9975,ssl3_read_bytes,"Handshake messages MAY be coalesced into a single TLSPlaintext record or fragmented across several records, provided that:",274,Partially Matches,"[{'C1': {'code': 'if (s->rlayer.handshake_fragment_len > 0 && rr->type != SSL3_RT_HANDSHAKE && SSL_CONNECTION_IS_TLS13(s)) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_MIXED_HANDSHAKE_AND_NON_HANDSHAKE_DATA);\n        return -1;\n    }', 'explanation': 'This check ensures that when there is an ongoing handshake fragment (i.e. a handshake message is split across records), no non-handshake record (other than the allowed types) is processed in TLS 1.3. It attempts to enforce the spec condition that handshake messages must not be interleaved with other record types.'}}, {'A1': {'code': 'if ((type == SSL3_RT_HANDSHAKE) && (s->rlayer.handshake_fragment_len > 0)) {\n    unsigned char *src = s->rlayer.handshake_fragment;\n    unsigned char *dst = buf;\n    while ((len > 0) && (s->rlayer.handshake_fragment_len > 0)) {\n        *dst++ = *src++;\n        len--;\n        s->rlayer.handshake_fragment_len--;\n        n++;\n    }\n}\n\n...\n\nif (rr->type == SSL3_RT_HANDSHAKE) {\n    size_t dest_maxlen = sizeof(s->rlayer.handshake_fragment);\n    unsigned char *dest = s->rlayer.handshake_fragment;\n    size_t *dest_len = &s->rlayer.handshake_fragment_len;\n    n = dest_maxlen - *dest_len;\n    if (rr->length < n)\n        n = rr->length;\n    if (n > 0) {\n        memcpy(dest + *dest_len, rr->data + rr->off, n);\n        *dest_len += n;\n    }\n    if ((n > 0 || rr->length == 0) && !ssl_release_record(s, rr, n))\n        return -1;\n    if (*dest_len < dest_maxlen)\n        goto start;\n}', 'explanation': 'This code accumulates handshake data over multiple records by storing partial handshake messages into a dedicated handshake_fragment buffer and looping until a complete header (or expected fragment size) is reached. It thereby implements the coalescing/fragmentation aspect of the handshake as outlined in the spec.'}}]","The function implements logic for handling the fragmentation and reassembly of handshake messages, as required by the RFC. It collects handshake fragments, allowing messages to be split across several records, and enforces (for TLS 1.3) that non-handshake records do not interleave with these fragments. However, the check for non-interleaving is explicitly applied only in the TLS 1.3 branch, meaning that while the function does address some of the specified constraints regarding handshake fragmentation and coalescence, it does so only partially relative to the full generality of the RFC.",success,
9975,ssl3_read_bytes,-Handshake messages MUST NOT be interleaved with other record types.,275,Fully Matches,"[{'C1': {'code': 'if (s->rlayer.handshake_fragment_len > 0 && rr->type != SSL3_RT_HANDSHAKE && SSL_CONNECTION_IS_TLS13(s)) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_MIXED_HANDSHAKE_AND_NON_HANDSHAKE_DATA);\n    return -1;\n}', 'explanation': 'This code checks that if there is a pending handshake fragment (i.e. part of a handshake message that was previously received) then the next record (rr) must also be of handshake type. This enforces the RFC requirement that handshake messages must not be interleaved with other record types.'}}]","The function includes explicit logic that verifies if a handshake message fragment is pending (stored in s->rlayer.handshake_fragment) and ensures that the next record processed is also a handshake message. If this condition is not met (i.e., a non-handshake record is encountered while a handshake fragment is still pending, at least for TLS 1.3), the connection is terminated with an unexpected_message alert. This direct check in the function_body alone satisfies the specified RFC constraint that handshake messages MUST NOT be interleaved with other record types.",success,
9975,ssl3_read_bytes,"That is, if a handshake message is split over two or more records, there MUST NOT be any other records between them.",276,Partially Matches,"[{'C1': {'code': 'if (s->rlayer.handshake_fragment_len > 0\n            && rr->type != SSL3_RT_HANDSHAKE\n            && SSL_CONNECTION_IS_TLS13(s)) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE,\n                 SSL_R_MIXED_HANDSHAKE_AND_NON_HANDSHAKE_DATA);\n        return -1;\n    }', 'explanation': 'This code explicitly checks for TLS 1.3 to ensure that when a handshake message is fragmented (handshake_fragment_len > 0), no non-handshake record is processed in-between. This check enforces that handshake records aren’t interleaved with other record types for TLS 1.3, thereby partially addressing the spec requirement.'}}]","The provided function contains logic to handle fragmented handshake messages, specifically for TLS 1.3 by verifying that if a handshake fragment exists, any subsequent record must also be of handshake type. This directly corresponds to the spec condition stating that handshake messages split over multiple records must not have any other records between them. However, the enforcement is only active when TLS 1.3 is in use; for other TLS versions this function does not visibly implement a similar check. Hence, the function only partially matches the overall specification.",success,
9975,ssl3_read_bytes,"In other words, a record with an Alert type MUST contain exactly one message.",282,Fully Matches,"[{'C1': {'code': 'if (!PACKET_buf_init(&alert, alert_bytes, rr->length)\n                || !PACKET_get_1(&alert, &alert_level)\n                || !PACKET_get_1(&alert, &alert_descr)\n                || PACKET_remaining(&alert) != 0) {\n            SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_INVALID_ALERT);\n            return -1;\n        }', 'explanation': 'This code segment checks that an SSL3_RT_ALERT record contains exactly two bytes (an alert level and an alert description). By ensuring that PACKET_remaining(&alert) returns 0 after extracting these two bytes, it verifies that the record does not contain any additional data, thus enforcing the TLS RFC requirement that an alert record must have exactly one message.'}}]","The function explicitly checks the integrity of an alert record by parsing exactly two bytes and confirming that no extra bytes remain, thereby directly implementing the specification that an alert record must contain exactly one message. This logic is contained within the function itself and does not rely on external dependencies, so the constraint is fully matched within this function.",success,
9975,ssl3_read_bytes,"Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure.",283,Fully Matches,"[{'C1': {'code': 'if (len == 0) {\n            /* Skip a zero length record. This ensures multiple calls to\n             * SSL_read() with a zero length buffer will eventually cause\n             * SSL_pending() to report data as being available.\n             */\n            if (rr->length == 0 && !ssl_release_record(s, rr, 0))\n                return -1;\n\n            return 0;\n        }', 'explanation': 'The code explicitly checks if the requested read length is zero and, in that case, it skips over a zero-length record. This behavior aligns with the TLS RFC specification that zero‐length fragments of Application Data MAY be sent. By handling zero-length records without error, the code meets the specified countermeasure against traffic analysis.'}}]","The function contains direct logic to handle zero-length Application Data records. When the read length is zero, it checks if the underlying record is empty and then skips it, consistent with the TLS RFC's allowance for zero‐length fragments. This implementation detail, isolated in the function_body, satisfies the spec constraint.",success,
9975,ssl3_read_bytes,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Partially Matches,"[{'C1': {'code': 'if (rr->version == SSL2_VERSION) {\n    /*\n     * Should never happen. ssl3_get_record() should only give us an SSLv2\n     * record back if this is the first packet and we are looking for an\n     * initial ClientHello. Therefore |type| should always be equal to\n     * |rr->type|. If not then something has gone horribly wrong\n     */\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return -1;\n}', 'explanation': 'This section explicitly checks if the incoming record is using SSL2 (by comparing rr->version with SSL2_VERSION) and aborts the connection using an internal error. This directly addresses the RFC requirement that SSL2 negotiation must be rejected. However, other aspects of the spec (for example, ensuring that no SSLv2-compatible ClientHello is sent or accepted) are not handled within this function, so only a part of the spec constraints (namely the prohibition of SSL2 records) is enforced here.'}}]","The function partially meets the spec constraints by checking for SSL2 record versions and aborting if one is detected, which enforces the prohibition of negotiating SSL2 as required by the RFC. However, additional constraints mentioned in the spec context—such as handling SSL version 2 compatible CLIENT-HELLO messages—are not implemented within this function. Thus, only some of the labeled conditions are addressed directly in the function body.",success,
9975,ssl3_read_bytes,"If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation MUST receive a ""close_notify"" alert before indicating end-of-data to the application layer.",318,Fully Matches,"[{'C1': {'code': 'if (alert_descr == SSL_AD_CLOSE_NOTIFY\n                && (is_tls13 || alert_level == SSL3_AL_WARNING)) {\n            s->shutdown |= SSL_RECEIVED_SHUTDOWN;\n            return 0;\n        }', 'explanation': ""This segment checks for a 'close_notify' alert. When such an alert is received, it sets the shutdown flag and returns 0, thereby ensuring that end-of-data is only indicated after a close_notify, which is in line with the spec requirement.""}}]","The function 'ssl3_read_bytes' explicitly processes TLS alert records. In the alert handling branch, it looks for a 'close_notify' (with additional TLS version checks) and, upon detection, marks the connection as shutdown and returns 0. This ensures that no further data is delivered to the application layer until a close_notify alert has been received, fully implementing the spec constraint, independent of external dependencies.",success,
9975,ssl3_read_bytes,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data.",320,Fully Matches,"[{'C1': {'code': 'if ((type != 0 && (type != SSL3_RT_APPLICATION_DATA) && (type != SSL3_RT_HANDSHAKE)) || (peek && (type != SSL3_RT_APPLICATION_DATA))) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return -1;\n}\n\n... (similar calls to SSLfatal on various error conditions)', 'explanation': 'Throughout the function, whenever a fatal error condition is detected (e.g., receiving an unexpected record type, version mismatches, or when processing alerts), the code calls SSLfatal (or SSLfatal_data) with an appropriate alert code. This explicitly implements the condition that upon encountering a fatal error, the function sends a fatal alert.'}}, {'A1': {'code': 'if (alert_level == SSL3_AL_FATAL || is_tls13) {\n    s->rwstate = SSL_NOTHING;\n    s->s3.fatal_alert = alert_descr;\n    SSLfatal_data(s, SSL_AD_NO_ALERT, SSL_AD_REASON_OFFSET + alert_descr,\n                  ""SSL alert number %d"", alert_descr);\n    s->shutdown |= SSL_RECEIVED_SHUTDOWN;\n    if (!ssl_release_record(s, rr, 0))\n        return -1;\n    SSL_CTX_remove_session(s->session_ctx, s->session);\n    return 0;\n}\n\n... and similar immediate returns after fatal errors', 'explanation': 'After sending a fatal alert via SSLfatal or SSLfatal_data, the function immediately sets shutdown flags (e.g., s->shutdown |= SSL_RECEIVED_SHUTDOWN) and returns an error code, ensuring that no additional data is sent or processed. This directly addresses the action that the connection must be closed after a fatal error.'}}]","The function visibly implements the TLS error handling requirements specified in the RFC by thoroughly checking for error conditions and, upon detection, using SSLfatal (or SSLfatal_data) to send an appropriate fatal alert followed by immediate termination of processing (e.g., setting shutdown flags and returning early). This behavior prevents any further sending or receiving of data, thereby fully meeting both the condition and the action outlined in the specification.",success,
9975,ssl3_read_bytes,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Fully Matches,"[{'C1': {'code': 'if (s->rlayer.handshake_fragment_len > 0 && rr->type != SSL3_RT_HANDSHAKE && SSL_CONNECTION_IS_TLS13(s)) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_MIXED_HANDSHAKE_AND_NON_HANDSHAKE_DATA);\n    return -1;\n}', 'explanation': 'This segment checks if there is leftover handshake fragment data while the current record is not a handshake record (in TLS 1.3), which indicates that a handshake message has arrived in an unexpected order.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);\n...\nSSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_RECORD);', 'explanation': 'Throughout the function, when the record type does not match the expected ordering (for instance, receiving application data or ChangeCipherSpec during handshake), the function calls SSLfatal() with the alert type SSL_AD_UNEXPECTED_MESSAGE to abort the handshake as required by the RFC.'}}]","The ssl3_read_bytes function contains explicit checks for the order of incoming handshake messages. It verifies that handshake fragments and record types appear in the expected order and, when they do not, aborts the handshake by calling SSLfatal() with the SSL_AD_UNEXPECTED_MESSAGE alert. These code segments directly implement the behavior specified in the TLS RFC, thus fully matching the conditions and actions required by the RFC specification.",success,
9982,rlayer_padding_wrapper,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Does Not Match,[],"The function rlayer_padding_wrapper does not contain any direct logic that implements the padding as specified by the TLS RFC. The RFC specifies that implementations may choose to pad and outlines specific requirements for padding (such as ensuring padding bytes are zeros), but this function merely delegates the padding operation to an external callback (s->rlayer.record_padding_cb). No decision-making, padding value setting, or specific TLS record handling is performed within this function itself. Therefore, it does not visibly address any of the spec constraints (like C1 or A1) in isolation.",success,
9986,ssl_set_new_record_layer,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function configures a new record layer and conditionally sets a maximum early data parameter when early data is in use. However, it does not implement any logic to prevent automatic retransmission of early data, nor does it verify that the negotiated connection selects the same ALPN protocol before resending early data. This lack of control logic directly in the function means that the TLS RFC specification—which requires that a TLS implementation MUST NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol—is not visibly addressed within this function's code.",success,
10394,tls13_set_crypto_state,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function does not contain any logic to address the spec constraint regarding the Truncated HMAC extension. Specifically, there is no mechanism in the code to reject or disable the truncated HMAC extension as mandated; instead, the function simply sets up HMAC when the cipher is ""NULL"". Moreover, the function does not perform any checks related to record version numbers (e.g., rejecting versions less than 0x0300). Therefore, based solely on the code within function_body, none of the specified constraints (e.g., that implementations MUST NOT use the Truncated HMAC extension) are visibly implemented.",success,
10395,tls13_cipher,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Fully Matches,"[{'C1': {'code': 'if (rec->type == SSL3_RT_ALERT) {\n    memmove(rec->data, rec->input, rec->length);\n    rec->input = rec->data;\n    return 1;\n}', 'explanation': 'This block directly handles TLS alert messages, ensuring that when an alert is being processed, the function does not perform any encryption or splitting; it simply copies the alert into the output buffer. This prevents fragmentation of a single alert message.'}}, {'C2': {'code': 'if (n_recs != 1) {\n    /* Should not happen */\n    RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}', 'explanation': 'By enforcing that exactly one record is processed (n_recs must equal 1), the code prevents multiple alert messages from being coalesced into a single TLSPlaintext record.'}}]","The function explicitly distinguishes alert records from other record types by checking if the record type is SSL3_RT_ALERT. It then bypasses the encryption and AAD processing, simply copying the alert data over, and returns early. Additionally, the early check on n_recs ensures that only one record is processed, thus preventing any multiple-alert coalescing. These implementations directly satisfy the spec constraints that alert messages must neither be fragmented across records nor coalesced, thereby fully matching the requirements.",success,
10395,tls13_cipher,"In other words, a record with an Alert type MUST contain exactly one message.",282,Does Not Match,[],"The specification requires that a record with an Alert type must contain exactly one message. Although the function checks that only one record is processed (n_recs == 1) and includes a conditional branch for Alert types, it does not implement any explicit verification to ensure that an Alert record is not fragmented or coalesced with additional messages. The branch for rec->type == SSL3_RT_ALERT simply memmoves the data and returns without checking the message length or structure, thereby not fully addressing the requirement directly within this function.",success,
10395,tls13_cipher,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The TLS RFC specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites. The provided function, tls13_cipher, is focused on encryption/decryption operations for TLS 1.3 records, handling nonce construction, tag computation, and AEAD processing. There is no visible logic within this function that checks for or prevents the negotiation or use of RC4 cipher suites. Therefore, the code function does not address the specified constraint regarding RC4 cipher suites.",success,
10395,tls13_cipher,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided tls13_cipher function does not contain any explicit logic addressing the TLS RFC requirement to disallow the truncated HMAC extension. Although the code handles MAC computation and AEAD encryption, there is no conditional check, flag, or logic that prevents the use of a truncated HMAC extension. Furthermore, while the function processes TLS record headers (including the version field) when setting up AAD, there is no verification ensuring that records with a version less than 0x0300 are rejected. Therefore, none of the spec constraints (e.g., the prohibition on using the Truncated HMAC extension) are addressed within this function.",success,
10396,tls13_validate_record_header,"An endpoint that receives a record from its peer with TLSCiphertext.length larger than 2^14 + 256 octets MUST terminate the connection with a ""record_overflow"" alert.",295,Fully Matches,"[{'C1': {'code': 'if (rec->length > SSL3_RT_MAX_TLS13_ENCRYPTED_LENGTH) {\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\n    return 0;\n}', 'explanation': ""This segment directly checks if the received record length exceeds the maximum allowed TLSCiphertext length (2^14 + 256 octets) and terminates the connection with a 'record_overflow' alert, as required by the RFC specification.""}}]","The function tls13_validate_record_header implements the TLS RFC requirement regarding records with excessive lengths by verifying that the rec->length field does not exceed the defined maximum (SSL3_RT_MAX_TLS13_ENCRYPTED_LENGTH). When the check fails, it calls RLAYERfatal with the SSL_AD_RECORD_OVERFLOW alert. This logic directly addresses the RFC's mandate to terminate the connection with a 'record_overflow' alert if the ciphertext exceeds the allowed size. Hence, within its scope, the function fully matches the specified constraint.",success,
10396,tls13_validate_record_header,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (rec->rec_version != TLS1_2_VERSION) {\n        RLAYERfatal(rl, SSL_AD_DECODE_ERROR, SSL_R_WRONG_VERSION_NUMBER);\n        return 0;\n    }', 'explanation': 'This segment checks the record version and, if it does not match the expected version, terminates the connection with a decode_error alert as required for syntactic parsing errors.'}}]","The function performs several validations on the TLS record header. It checks the record type, version, and length. The version check explicitly triggers a decode_error alert when the version is incorrect, which partially fulfills the RFC requirement that syntactic parsing errors result in a decode_error. However, other syntactic errors such as an incorrect record type or an excessive length trigger different alerts (unexpected_message and record_overflow, respectively) rather than a decode_error. Since the RFC mandates a decode_error for messages that cannot be parsed according to the syntax, the function only partially meets the specification constraints in its direct implementation.",success,
10396,tls13_validate_record_header,"An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.",292,Fully Matches,"[{'C1': {'code': 'if (rec->length > SSL3_RT_MAX_TLS13_ENCRYPTED_LENGTH) {\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\n    return 0;\n}', 'explanation': ""This code segment checks if the received record's length exceeds the maximum allowed (2^14 + 256 bytes, defined by SSL3_RT_MAX_TLS13_ENCRYPTED_LENGTH) and, if so, terminates the connection with a 'record_overflow' alert as mandated by the TLS RFC specification.""}}]","The function 'tls13_validate_record_header' directly implements the TLS RFC requirement by verifying that the record length does not exceed the defined maximum. When the condition is violated, it calls RLAYERfatal to terminate the connection with a record_overflow alert. This matches the specified constraint in the RFC, and therefore the function fully matches the required condition as implemented in its own logic.",success,
10396,tls13_validate_record_header,"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",272,Partially Matches,"[{'A1': {'code': 'if (rec->type != SSL3_RT_APPLICATION_DATA\n        && (rec->type != SSL3_RT_CHANGE_CIPHER_SPEC || !rl->is_first_handshake)\n        && (rec->type != SSL3_RT_ALERT || !rl->allow_plain_alerts)) {\n    RLAYERfatal(rl, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_BAD_RECORD_TYPE);\n    return 0;\n}', 'explanation': ""This segment checks the record type and calls RLAYERfatal with an unexpected_message alert if the received record type does not match allowed types. This addresses the spec requirement that an unexpected record type must terminate the connection with an 'unexpected_message' alert. However, nuances related to change_cipher_spec content (dropping single-byte 0x01 records in the proper handshake context) are not explicitly handled here.""}}]","The function inspects the record header and validates the record type, version, and length. In doing so, it aborts the connection with an unexpected_message alert when the record type is not one of the allowed types. This partially meets the TLS RFC specification requirement of terminating the connection upon receiving an unexpected record type. However, the detailed behavior specific to change_cipher_spec records—such as checking for a single byte value 0x01 and dropping it rather than aborting—is not implemented within this function. Therefore, while the core requirement (terminating upon an unexpected record type) is addressed, the function does not fully implement all aspects of the spec constraints.",success,
10396,tls13_validate_record_header,"An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.",288,Fully Matches,"[{'C1': {'code': 'if (rec->length > SSL3_RT_MAX_TLS13_ENCRYPTED_LENGTH) {\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW,\n                SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\n    return 0;\n}', 'explanation': ""This code segment checks whether the record length exceeds the allowed maximum (2^14 bytes for the TLSPlaintext.fragment as per the spec) and terminates the connection by calling RLAYERfatal with the 'record_overflow' alert. This directly implements the TLS RFC requirement regarding records that exceed the maximum allowed length.""}}]","The function 'tls13_validate_record_header' includes a check for the record length and properly terminates the connection with a 'record_overflow' alert if the check fails, which satisfies the specific TLS RFC requirement provided. All relevant logic is encapsulated within this function, hence it fully matches the spec constraint.",success,
10397,tls13_post_process_record,"An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.",288,Fully Matches,"[{'C1': {'code': 'if (rec->length > SSL3_RT_MAX_PLAIN_LENGTH) {\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_DATA_LENGTH_TOO_LONG);\n    return 0;\n}', 'explanation': ""This segment directly checks whether the record's length exceeds the maximum permitted (2^14 bytes, represented by SSL3_RT_MAX_PLAIN_LENGTH) and, if so, calls RLAYERfatal to terminate the connection with a 'record_overflow' alert, fully meeting the RFC's specification.""}}]","The TLS RFC requires an endpoint to terminate the connection with a 'record_overflow' alert if a record's length exceeds 2^14 bytes. The function contains a clear length check that compares rec->length against SSL3_RT_MAX_PLAIN_LENGTH and issues the appropriate alert when the record is too long. This logic, implemented directly within the function_body, fully addresses the specified condition and corresponding action.",success,
10397,tls13_post_process_record,"An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.",292,Fully Matches,"[{'C1': {'code': 'if (rec->length > SSL3_RT_MAX_PLAIN_LENGTH) {\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_DATA_LENGTH_TOO_LONG);\n    return 0;\n}', 'explanation': ""This code block directly checks if the record length exceeds the maximum allowed length (as specified by the TLS RFC: 2^14+256 bytes) and, if so, terminates the connection with a 'record_overflow' alert. This matches the RFC specification condition that an endpoint receiving an oversized record must abort the connection with a record_overflow alert.""}}]","Within the function_body, the record length is explicitly validated. When the record length is greater than SSL3_RT_MAX_PLAIN_LENGTH, the function calls RLAYERfatal with SSL_AD_RECORD_OVERFLOW, thereby fulfilling the TLS RFC requirement about handling records that exceed the maximum allowed size.",success,
10397,tls13_post_process_record,"An endpoint that receives a record from its peer with TLSCiphertext.length larger than 2^14 + 256 octets MUST terminate the connection with a ""record_overflow"" alert.",295,Fully Matches,"[{'C1': {'code': 'if (rec->length > SSL3_RT_MAX_PLAIN_LENGTH) {\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_DATA_LENGTH_TOO_LONG);\n    return 0;\n}', 'explanation': 'This segment explicitly checks if the record length exceeds the maximum allowed (which corresponds to 2^14 + 256 octets as defined by SSL3_RT_MAX_PLAIN_LENGTH) and triggers the action.'}}, {'A1': {'code': 'RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_DATA_LENGTH_TOO_LONG);', 'explanation': ""Upon detecting an oversized record, this code terminates the connection by raising a 'record_overflow' alert as prescribed.""}}]","The tls13_post_process_record function directly implements the specified TLS RFC check by verifying that the incoming record's length does not exceed the maximum permitted value (derived as 2^14 + 256 octets). When it does, the function calls RLAYERfatal to terminate the connection with a 'record_overflow' alert. Thus, the function itself visibly addresses both the condition of oversize record and the required termination action.",success,
10397,tls13_post_process_record,The presence of padding does not change the overall record size limitations: the full encoded TLSInnerPlaintext MUST NOT exceed 2^14 + 1 octets.,304,Partially Matches,"[{'A1': {'code': '/* Strip trailing padding */\nfor (end = rec->length - 1; end > 0 && rec->data[end] == 0; end--)\n    continue;\n\nrec->length = end;\nrec->type = rec->data[end];', 'explanation': 'This loop removes trailing zero octets (the padding) from the record, which corresponds to the spec’s discussion of handling padding, even though the selection policy is not fully specified by the RFC.'}}, {'C1': {'code': 'if (rec->length > SSL3_RT_MAX_PLAIN_LENGTH) {\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_DATA_LENGTH_TOO_LONG);\n    return 0;\n}', 'explanation': 'This length check is intended to ensure that the processed record does not exceed the maximum allowed length (implicitly 2^14 + 1 octets), addressing the RFC requirement. However, it is applied after the padding removal rather than on the full encoded TLSInnerPlaintext.'}}]","The function attempts to implement two aspects of the RFC: removing padding (A1) and ensuring that the record’s length does not exceed the maximum allowed limit (C1). However, it does so on the record after stripping trailing padding, rather than on the full encoded TLSInnerPlaintext, and it does not explicitly check for the presence of a non‐zero octet as mandated by the spec context. As such, only part of the spec constraints are visibly handled within this function.",success,
10397,tls13_post_process_record,"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",272,Partially Matches,"[{'A1': {'code': 'if (rec->length == 0\n        || rec->type != SSL3_RT_APPLICATION_DATA) {\n    RLAYERfatal(rl, SSL_AD_UNEXPECTED_MESSAGE,\n                SSL_R_BAD_RECORD_TYPE);\n    return 0;\n}', 'explanation': 'This segment checks that if a record is not of type SSL3_RT_APPLICATION_DATA (and is not a plaintext alert), the function terminates the connection by calling RLAYERfatal with an unexpected_message alert. This directly implements the action that a TLS implementation must abort when receiving an unexpected record type.'}}]","The function addresses the RFC requirement to terminate the connection with an 'unexpected_message' alert when an unexpected record type is encountered (A1). It does so by checking whether the record type is SSL3_RT_APPLICATION_DATA and aborting if it is not. However, the RFC specification also includes special handling for change_cipher_spec records (e.g., dropping an unencrypted change_cipher_spec record with a single byte value 0x01) along with additional context-based conditions. This function does not include any logic to detect or handle change_cipher_spec records as described in the spec context, meaning that while it enforces the termination on unexpected record types, it does not fully implement all aspects of the specification. Therefore, the code function partially matches the requirements.",success,
10399,tls13_add_record_padding,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Fully Matches,"[{'C1': {'code': 'if (rlen < rl->max_frag_len) {\n    size_t padding = 0;\n    size_t max_padding = rl->max_frag_len - rlen;\n    \n    if (rl->padding != NULL) {\n        padding = rl->padding(rl->cbarg, thistempl->type, rlen);\n    } else if (rl->block_padding > 0 || rl->hs_padding > 0) {\n        size_t mask, bp = 0, remainder;\n\n        if (thistempl->type == SSL3_RT_HANDSHAKE && rl->hs_padding > 0)\n            bp = rl->hs_padding;\n        else if (thistempl->type == SSL3_RT_ALERT && rl->hs_padding > 0)\n            bp = rl->hs_padding;\n        else if (thistempl->type == SSL3_RT_APPLICATION_DATA\n                 && rl->block_padding > 0)\n            bp = rl->block_padding;\n        if (bp > 0) {\n            mask = bp - 1;\n            if ((bp & mask) == 0)\n                remainder = rlen & mask;\n            else\n                remainder = rlen % bp;\n            if (remainder == 0)\n                padding = 0;\n            else\n                padding = bp - remainder;\n        }\n    }\n    if (padding > 0) { ... }\n}', 'explanation': 'This segment checks whether the current record length is less than the maximum allowed and then determines the optional padding length to add. This implements the condition that the TLSCiphertext record may be padded.'}}, {'A1': {'code': 'if (padding > 0) {\n    if (padding > max_padding)\n        padding = max_padding;\n    if (!WPACKET_memset(thispkt, 0, padding)) {\n        RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    TLS_RL_RECORD_add_length(thiswr, padding);\n}', 'explanation': 'This code fills the determined padding area with zero-valued bytes using WPACKET_memset, thereby satisfying the requirement to set the padding octets to zero before encryption.'}}]","The function tls13_add_record_padding directly implements the TLS RFC specification regarding optional record padding. It first checks if additional space is available (thereby fulfilling the 'may choose to pad' condition) and then calculates an appropriate padding length. When padding is applied, the function uses memset to set the padding octets to zero as mandated. Thus, by performing both the decision to pad (C1) and the action of zeroing the padding (A1) strictly within the function body, the implementation fully meets the specified TLS RFC requirements.",success,
10399,tls13_add_record_padding,The presence of padding does not change the overall record size limitations: the full encoded TLSInnerPlaintext MUST NOT exceed 2^14 + 1 octets.,304,Fully Matches,"[{'C1': {'code': 'rlen = TLS_RL_RECORD_get_length(thiswr);\nif (rlen < rl->max_frag_len) {\n    size_t max_padding = rl->max_frag_len - rlen;\n    ...\n    if (padding > max_padding)\n        padding = max_padding;\n    if (!WPACKET_memset(thispkt, 0, padding)) {\n        RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    TLS_RL_RECORD_add_length(thiswr, padding);\n}', 'explanation': ""This segment ensures that the overall length of the TLSInnerPlaintext, after adding any padding, does not exceed 'rl->max_frag_len'. The maximum extra padding is computed as the difference between the allowed max fragment length and the current record length, thereby complying with the TLS RFC requirement that the full encoded TLSInnerPlaintext (including padding) must not exceed 2^14 + 1 octets.""}}]","The function implements the TLS RFC requirement regarding padding by carefully calculating the remaining space (max_padding) based on the current record length and the maximum allowed fragment length. It then limits the added padding to ensure that the overall record length does not exceed the allowed maximum, directly matching the specified condition in the RFC. Thus, given that the code function alone enforces the record size constraint in the presence of added padding, it fully meets the provided spec constraint labeled C1.",success,
10403,ktls_read_n,"If the decryption fails, the receiver MUST terminate the connection with a ""bad_record_mac"" alert.",293,Fully Matches,"[{'A1': {'code': 'case EBADMSG:\n    RLAYERfatal(rl, SSL_AD_BAD_RECORD_MAC, SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);', 'explanation': ""When the decryption fails (indicated by errno set to EBADMSG), this code segment terminates the connection by issuing a 'bad_record_mac' alert, exactly as specified by the RFC.""}}]","The function ktls_read_n calls tls_default_read_n and then checks if an error occurred. In the case of EBADMSG, which signals a decryption failure, it calls RLAYERfatal with the SSL_AD_BAD_RECORD_MAC alert, thereby directly implementing the mandate from the TLS RFC that requires termination of the connection with a 'bad_record_mac' alert. This logic is contained solely within the function body.",success,
10403,ktls_read_n,"An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.",292,Partially Matches,"[{'A1': {'code': 'case EMSGSIZE:\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW,\n                SSL_R_PACKET_LENGTH_TOO_LONG);', 'explanation': 'This segment handles the situation when an error code EMSGSIZE is set, which indicates that the incoming record likely exceeded the maximum allowed length. It terminates the connection with the SSL_AD_RECORD_OVERFLOW alert, addressing the action requirement from the spec.'}}]","The function itself does not perform the full length check (the actual calculation of record length is delegated to tls_default_read_n), but it contains logic that directly responds to an oversized record error (via EMSGSIZE) by triggering a 'record_overflow' alert. Since this logic is present, the function partially meets the spec constraint, even though much of the record length enforcement occurs in the dependency.",success,
10403,ktls_read_n,"An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.",288,Fully Matches,"[{'C1': {'code': 'case EMSGSIZE:\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW,\n                SSL_R_PACKET_LENGTH_TOO_LONG);', 'explanation': 'This code segment checks for an EMSGSIZE error returned from tls_default_read_n, which indicates that the received record exceeds the allowed length (2^14 bytes). It then immediately terminates the connection by calling RLAYERfatal with the SSL_AD_RECORD_OVERFLOW alert, directly fulfilling the TLS RFC requirement.'}}]","The function ktls_read_n calls tls_default_read_n to read the record and then checks if an error occurred. When the errno is set to EMSGSIZE, it handles the condition by calling RLAYERfatal with the record_overflow alert. This satisfies the spec constraint that an endpoint must terminate the connection with a record_overflow alert when a record exceeding the allowed length is received. All the logic addressing this requirement is visible within the function_body.",success,
10408,ktls_allocate_write_buffers,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Does Not Match,[],"The TLS specification requires that the implementation may choose to add padding to the TLSCiphertext record, including setting explicit zero-valued bytes for padding. In the provided code function, there is no logic that deals with the creation, configuration, or appending of padding bytes. The function simply sets a single buffer on the record layer (rl->numwpipes = 1) without any indication of handling padding as described in the spec. Therefore, none of the labeled conditions or actions (e.g., C1, A1) related to padding have been implemented in this function.",success,
10412,ktls_post_encryption_processing,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Does Not Match,[],"The function body is merely a stub that returns 1 and contains no logic to address any padding of TLSCiphertext records as described in the RFC specification. There is no code in this function that implements any condition (such as checking or setting a zero-length padding or applying padding bytes) or action regarding record padding. Therefore, in isolation from its dependencies, it does not visibly address any of the specified constraints.",success,
10413,ktls_prepare_write_bio,"Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure.",283,Fully Matches,"[{'A1': {'code': 'if (type != SSL3_RT_APPLICATION_DATA) {\n    int ret, i = BIO_flush(rl->bio);\n    if (i <= 0) {\n        if (BIO_should_retry(rl->bio))\n            ret = OSSL_RECORD_RETURN_RETRY;\n        else\n            ret = OSSL_RECORD_RETURN_FATAL;\n        return ret;\n    }\n    BIO_set_ktls_ctrl_msg(rl->bio, type);\n}', 'explanation': 'This segment flushes the BIO when the record is not Application Data. By doing so it prevents control messages (such as Alerts that must not be fragmented or coalesced) from being merged with other data, in alignment with the RFC requirement that alerts be sent as lone messages.'}}, {'C1': {'code': 'return OSSL_RECORD_RETURN_SUCCESS;', 'explanation': 'For Application Data (which may include zero-length fragments allowed by the spec), the function does not flush the BIO and simply returns success. This behavior permits Application Data fragments to be coalesced or sent as separate records, consistent with RFC guidance.'}}]","The function distinguishes between Application Data and other record types. For non-Application Data messages (such as alerts), it forces a BIO flush and then sets a control message flag to ensure that these messages are not inadvertently coalesced, which meets the RFC requirement that alert messages be sent individually without fragmentation. For Application Data, including potential zero-length fragments, the function leaves the BIO unflushed, thereby implicitly allowing the behavior described in the RFC. Thus, within its scope, the function fully addresses the TLS RFC constraints as required.",success,
10424,ossl_rlayer_fatal,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, ossl_rlayer_fatal, is solely responsible for error reporting by setting error messages and an alert on the record layer. It does not incorporate any logic related to cipher suite selection or rejection (including RC4 or low-strength ciphers). There is no code within this function that addresses any of the spec constraints (such as prohibiting RC4 cipher suites or enforcing a minimum cipher strength), and therefore it does not visibly attempt to implement the specified TLS RFC conditions.",success,
10425,ossl_set_tls_provider_parameters,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The TLS RFC specification mandates that implementations MUST NOT use the Truncated HMAC extension and must not send or accept records with a version less than 0x0300. The provided function ossl_set_tls_provider_parameters only sets parameters for the TLS version and MAC size based on whether the cipher is an AEAD cipher and a flag (use_etm), but it does not contain any logic to prevent the use of the Truncated HMAC extension nor does it verify the TLS version to enforce the version constraints. As such, the function does not visibly address the labeled conditions/actions from the spec constraints within its own implementation.",success,
10434,tls_record_app_data_waiting,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Does Not Match,[],"The provided function only checks for TLS application data records by verifying that the record type is SSL3_RT_APPLICATION_DATA and ensuring that the record has sufficient length based on the header and indicated record length. There is no logic that checks for alert message fragmentation or coalescing, which is required by the spec constraint stating that alert messages must not be fragmented or coalesced. Therefore, the function does not visibly address any of the alert message constraints (e.g., C1 or related actions) from the RFC specification.",success,
10434,tls_record_app_data_waiting,The value of TLSPlaintext.legacy_record_version MUST be ignored by all implementations.,372,Fully Matches,"[{'C1': {'code': '/* We only check the type and record length, we will sanity check version\n   etc later */\nif (*p != SSL3_RT_APPLICATION_DATA)\n    return 0;\n\np += 3;', 'explanation': ""The code explicitly ignores the TLSPlaintext.legacy_record_version field by not validating it. Instead, after confirming the record type, it advances the pointer past the version field (using 'p += 3;'), thereby effectively ignoring the legacy_record_version as mandated by the spec.""}}]","The function checks for the presence of a complete TLS record by verifying the header's type and length but deliberately omits any validation of the legacy_record_version field. The comment in the code confirms that version checking is deferred, which aligns with the TLS RFC requirement that the legacy_record_version MUST be ignored.",success,
10435,rlayer_early_data_count_ok,"A server receiving more than max_early_data_size bytes of 0-RTT data SHOULD terminate the connection with an ""unexpected_message"" alert.",252,Fully Matches,"[{'C1': {'code': 'if (rl->early_data_count + length > max_early_data) {\n    RLAYERfatal(rl, send ? SSL_AD_INTERNAL_ERROR : SSL_AD_UNEXPECTED_MESSAGE,\n                SSL_R_TOO_MUCH_EARLY_DATA);\n    return 0;\n}', 'explanation': 'This code checks whether the cumulative early data (early_data_count + length) exceeds the allowed max_early_data (adjusted by overhead). This directly implements the condition that a server must verify the 0-RTT data does not exceed max_early_data_size.'}}, {'A1': {'code': 'RLAYERfatal(rl, send ? SSL_AD_INTERNAL_ERROR : SSL_AD_UNEXPECTED_MESSAGE,\n            SSL_R_TOO_MUCH_EARLY_DATA);', 'explanation': 'When the limit is exceeded (and also when max_early_data is 0), the connection termination is initiated with an alert. Specifically, when not sending (i.e., when receiving early data), the alert used is SSL_AD_UNEXPECTED_MESSAGE, which fulfills the action of terminating the connection with the proper alert as specified.'}}]","The function 'rlayer_early_data_count_ok' directly implements the TLS RFC requirement by checking the cumulative 0-RTT data against the maximum allowed size (after accounting for any overhead). If the limit is exceeded, it terminates the connection with an alert (using SSL_AD_UNEXPECTED_MESSAGE when receiving data), thereby fully matching the specified RFC constraint regarding early data size limits.",success,
10436,tls_get_more_records,"If the decryption fails, the receiver MUST terminate the connection with a ""bad_record_mac"" alert.",293,Fully Matches,"[{'C1': {'code': 'if (enc_err == 0) {\n    if (rl->alert != SSL_AD_NO_ALERT) {\n        ERR_clear_last_mark();\n        goto end;\n    }\n    if (num_recs == 1 && rl->skip_early_data != NULL && rl->skip_early_data(rl->cbarg)) {\n        ...\n    }\n    ERR_clear_last_mark();\n    RLAYERfatal(rl, SSL_AD_BAD_RECORD_MAC,\n                SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n    goto end;\n}\n\n...\n\nif (enc_err == 0) {\n    if (rl->alert != SSL_AD_NO_ALERT) {\n        /* We already called RLAYERfatal() */\n        goto end;\n    }\n    RLAYERfatal(rl, SSL_AD_BAD_RECORD_MAC,\n                SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n    goto end;\n}', 'explanation': ""The code checks the result of the decryption (enc_err). When decryption failure is detected (enc_err == 0), it terminates the connection by calling RLAYERfatal() with the 'bad_record_mac' alert, which directly implements the requirement specified in the RFC.""}}]",The function implements the TLS RFC requirement that mandates termination of the connection with a 'bad_record_mac' alert if decryption fails. The logic within the function explicitly checks for decryption failure (using enc_err) and then issues RLAYERfatal() with the appropriate alert code. This direct in-function handling shows that the function fully addresses the specified constraint.,success,
10436,tls_get_more_records,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data.",320,Fully Matches,"[{'C1': {'code': 'if (!PACKET_buf_init(&pkt, p, rl->packet_length)) {\n    RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return OSSL_RECORD_RETURN_FATAL;\n}\n...\nif (thisrr->length > TLS_BUFFER_get_len(rbuf) - SSL3_RT_HEADER_LENGTH) {\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_PACKET_LENGTH_TOO_LONG);\n    return OSSL_RECORD_RETURN_FATAL;\n}\n...\nif (enc_err == 0) {\n    if (rl->alert != SSL_AD_NO_ALERT) {\n        ERR_clear_last_mark();\n        goto end;\n    }\n    RLAYERfatal(rl, SSL_AD_BAD_RECORD_MAC, SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n    goto end;\n}', 'explanation': 'Throughout the function, whenever an error condition is detected (e.g., buffer initialization failure, header parsing errors, decryption/MAC failures), the code calls RLAYERfatal with an appropriate alert code and then returns OSSL_RECORD_RETURN_FATAL. This addresses the requirement to handle fatal error conditions.'}}, {'A1': {'code': 'RLAYERfatal(rl, <appropriate_alert>, <error_code>);\nreturn OSSL_RECORD_RETURN_FATAL;', 'explanation': 'By invoking RLAYERfatal upon detecting fatal errors and immediately returning a fatal status, the function attempts to send a fatal alert and stop further processing—thereby fulfilling the action to close the connection without additional data transfer.'}}]","The provided function contains multiple checks for error conditions. In each instance, it calls RLAYERfatal with an alert code and returns a fatal status. This behavior directly corresponds to the TLS specification requirement that upon encountering a fatal error, the implementation should send an appropriate fatal alert and close the connection without further communication. All of this logic is visible within the function, so based solely on its content, it fully implements the specified error-handling constraints.",success,
10436,tls_get_more_records,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2_len(&sslv2pkt, &sslv2len) || !PACKET_get_1(&sslv2pkt, &type)) {\n    RLAYERfatal(rl, SSL_AD_DECODE_ERROR, ERR_R_INTERNAL_ERROR);\n    return OSSL_RECORD_RETURN_FATAL;\n}', 'explanation': 'This segment validates the SSLv2 header parsing. If the header cannot be parsed (e.g. length or type extraction fails), it calls RLAYERfatal with a decode error alert, thereby terminating the connection as required by the RFC for syntactic parsing errors.'}}, {'C1': {'code': 'if (!PACKET_get_1(&pkt, &type)\n        || !PACKET_get_net_2(&pkt, &version)\n        || !PACKET_get_net_2_len(&pkt, &thisrr->length)) {\n    if (rl->msg_callback != NULL)\n        rl->msg_callback(0, version, SSL3_RT_HEADER, p, 5, rl->cbarg);\n    RLAYERfatal(rl, SSL_AD_DECODE_ERROR, ERR_R_INTERNAL_ERROR);\n    return OSSL_RECORD_RETURN_FATAL;\n}', 'explanation': 'This block checks the parsing of an SSLv3+ header. On failure, it similarly uses RLAYERfatal with a decode error alert, addressing the requirement to terminate the connection when the message syntax is invalid.'}}]","The function implements several checks to parse TLS record headers and validate record lengths. In cases where parsing fails, it calls RLAYERfatal with SSL_AD_DECODE_ERROR, which aligns with the RFC requirement to issue a 'decode_error' alert when the record message cannot be parsed. However, the function also uses other alert types (for example, SSL_AD_RECORD_OVERFLOW, SSL_AD_PROTOCOL_VERSION, SSL_AD_BAD_RECORD_MAC) in different error conditions. These discrepancies mean that while the function does address syntactic parsing errors by terminating with fatal alerts, it does not exclusively follow the specification’s mandate to always use a 'decode_error' alert for all parsing failures. Consequently, the implementation only partially matches the RFC spec constraint.",success,
10436,tls_get_more_records,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'C1': {'code': 'if (num_recs == 1\n        && rl->skip_early_data != NULL\n        && rl->skip_early_data(rl->cbarg)) {\n    /*\n     * Valid early_data that we cannot decrypt will fail here. We treat\n     * it like an empty record.\n     */\n\n    ERR_pop_to_mark();\n\n    thisrr = &rr[0];\n\n    if (!rlayer_early_data_count_ok(rl, thisrr->length,\n                                    EARLY_DATA_CIPHERTEXT_OVERHEAD, 0)) {\n        /* RLAYERfatal() already called */\n        goto end;\n    }\n\n    thisrr->length = 0;\n    rl->num_recs = 0;\n    rl->curr_rec = 0;\n    rl->num_released = 0;\n    /* Reset the read sequence */\n    memset(rl->sequence, 0, sizeof(rl->sequence));\n    ret = 1;\n    goto end;\n}', 'explanation': 'This branch checks for early data decryption failure and, if the skip_early_data callback is provided and returns true, resets the record (treating it as an empty record) without automatically retransmitting early data. This defers the retransmission decision to the application as prescribed in the TLS RFC.'}}, {'A1': {'code': '/* Reset the read sequence */\nmemset(rl->sequence, 0, sizeof(rl->sequence));', 'explanation': 'By explicitly clearing the state (including the record length and sequence) when early data decryption fails, the function avoids automatically retransmitting early data, in accordance with the requirement that retransmission should be controlled by the application.'}}]","The function 'tls_get_more_records' contains explicit logic to handle early data in a manner that conforms to the TLS RFC requirement: it does not automatically retransmit early data. Instead, when early data decryption fails and the skip_early_data callback indicates that early data should be skipped, the function resets the record (by setting its length to zero and clearing relevant state) rather than resending the early data. This ensures that the decision to retransmit is deferred to the application layer, fully matching the specified behavior.",success,
10436,tls_get_more_records,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function (tls_get_more_records) deals with TLS record processing, including reading headers, decrypting records, MAC verification, and post-decryption processing. However, there is no visible logic within this function that addresses the RFC specification requiring that RC4 cipher suites must not be offered or negotiated. No code segments check for or disable RC4, nor do they enforce the prohibition against using weak ciphers as stated in the spec. The function focuses on record handling and does not implement any checks or rejections for RC4 cipher suites; thus, it does not fulfill any of the conditions or actions related to the RFC constraint.",success,
10436,tls_get_more_records,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Partially Matches,"[{'C1': {'code': 'if (rl->role == OSSL_RECORD_ROLE_SERVER\n        && rl->is_first_record\n        && (sslv2len & 0x8000) != 0\n        && (type == SSL2_MT_CLIENT_HELLO)) {\n    /* SSLv2 style record */\n    thisrr->type = SSL3_RT_HANDSHAKE;\n    thisrr->rec_version = SSL2_VERSION;\n    thisrr->length = sslv2len & 0x7fff;\n    if (thisrr->length > TLS_BUFFER_get_len(rbuf) - SSL2_RT_HEADER_LENGTH) {\n         RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW,\n                    SSL_R_PACKET_LENGTH_TOO_LONG);\n         return OSSL_RECORD_RETURN_FATAL;\n    }\n}', 'explanation': 'This segment detects a SSLv2 style ClientHello (allowed only in the very first record from a client to a server) and processes it. Although RFC6176 requires that SSLv2 is not negotiated, the spec context does allow an initial SSLv2 ClientHello on the server side in some legacy implementations. Therefore, the function attempts to distinguish SSLv2 records, but allowing a first-record SSLv2 ClientHello partially complies with the restriction.'}}, {'C2': {'code': 'if (thisrr->rec_version == SSL2_VERSION) {\n    RLAYERfatal(rl, SSL_AD_PROTOCOL_VERSION,\n                SSL_R_WRONG_VERSION_NUMBER);\n    return OSSL_RECORD_RETURN_FATAL;\n}', 'explanation': 'For records parsed in the SSLv3+ branch, if the record version is detected to be SSLv2 the function signals a fatal protocol version error. This helps to reject SSLv2 messages in situations other than the very first record, which is in line with the requirement to not negotiate using SSLv2.'}}]","The function contains logic to identify and treat SSLv2 records differently. In the case of any record (except possibly the very first one on the server side), it explicitly rejects an SSLv2 version by raising a protocol version error. This shows an attempt to enforce the spec requirement that SSLv2 is insufficient for negotiation. However, the function does allow a SSLv2-style ClientHello when it is the very first record received by the server, which is a legacy allowance rather than a strict enforcement of 'MUST NOT negotiate.' Thus, while the function addresses the constraint in part by rejecting SSLv2 records in most cases, the special-case handling of the first record means that it only partially meets the TLS RFC’s prohibition on negotiating using an SSLv2 compatible CLIENT-HELLO.",success,
10436,tls_get_more_records,"An implementation which receives any other change_cipher_spec value or which receives a protected change_cipher_spec record MUST abort the handshake with an ""unexpected_message"" alert.",269,Partially Matches,"[{'A1': {'code': 'if (num_recs == 1\n        && thisrr->type == SSL3_RT_CHANGE_CIPHER_SPEC\n        && rl->version == TLS1_3_VERSION\n        && rl->is_first_handshake) {\n    if (thisrr->length != 1 || thisrr->data[0] != 0x01) {\n        RLAYERfatal(rl, SSL_AD_UNEXPECTED_MESSAGE,\n                    SSL_R_INVALID_CCS_MESSAGE);\n        return OSSL_RECORD_RETURN_FATAL;\n    }\n    // ... further processing: treat CCS like an empty handshake record\n    if (rl->msg_callback != NULL)\n        rl->msg_callback(0, TLS1_3_VERSION, SSL3_RT_CHANGE_CIPHER_SPEC,\n                         thisrr->data, 1, rl->cbarg);\n    thisrr->type = SSL3_RT_HANDSHAKE;\n    if (++(rl->empty_record_count) > MAX_EMPTY_RECORDS) {\n        RLAYERfatal(rl, SSL_AD_UNEXPECTED_MESSAGE,\n                    SSL_R_UNEXPECTED_CCS_MESSAGE);\n        return OSSL_RECORD_RETURN_FATAL;\n    }\n    rl->num_recs = 0;\n    rl->curr_rec = 0;\n    rl->num_released = 0;\n\n    return OSSL_RECORD_RETURN_SUCCESS;\n}', 'explanation': ""This segment explicitly handles a change_cipher_spec record in TLS 1.3 during the first handshake by checking that the record is exactly one byte with the value 0x01. If not, it aborts the handshake with an 'unexpected_message' alert as specified.""}}]","The RFC specification requires that a change_cipher_spec (CCS) record must be exactly one byte long (with the value 0x01) when unprotected and that any deviation or a protected CCS record should lead to an aborted handshake with an 'unexpected_message' alert. In the provided function, there is a code segment that checks for CCS records in the TLS 1.3 case (when rl->version equals TLS1_3_VERSION and rl->is_first_handshake is true). The function verifies the CCS message length and content, and aborts the handshake if the check fails. However, the function only visibly implements this check for TLS 1.3 and does not explicitly handle the rule for receiving a protected CCS record in other contexts. Thus, while the function partially implements the spec constraint (addressing the required byte-length and value check for CCS), it does not comprehensively cover all aspects (e.g. handling of protected CCS records in non‑TLS1.3 scenarios) solely within its own code.",success,
10436,tls_get_more_records,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Fully Matches,"[{'C1': {'code': 'if (rl->md_ctx != NULL) {\n    const EVP_MD *tmpmd = EVP_MD_CTX_get0_md(rl->md_ctx);\n    if (tmpmd != NULL) {\n        imac_size = EVP_MD_get_size(tmpmd);\n        if (!ossl_assert(imac_size > 0 && imac_size <= EVP_MAX_MD_SIZE)) {\n            RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);\n            return OSSL_RECORD_RETURN_FATAL;\n        }\n        mac_size = (size_t)imac_size;\n    }\n}\n\n... (later in the function) ...\n\nif (rl->use_etm && rl->md_ctx != NULL) {\n    for (j = 0; j < num_recs; j++) {\n        thisrr = &rr[j];\n        if (thisrr->length < mac_size) {\n            RLAYERfatal(rl, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_TOO_SHORT);\n            return OSSL_RECORD_RETURN_FATAL;\n        }\n        thisrr->length -= mac_size;\n        mac = thisrr->data + thisrr->length;\n        i = rl->funcs->mac(rl, thisrr, md, 0 /* not send */);\n        if (i == 0 || CRYPTO_memcmp(md, mac, mac_size) != 0) {\n            RLAYERfatal(rl, SSL_AD_BAD_RECORD_MAC,\n                        SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n            return OSSL_RECORD_RETURN_FATAL;\n        }\n    }\n    mac_size = 0;\n}', 'explanation': 'This segment calculates the MAC based on the full digest size (obtained via EVP_MD_get_size) and performs a full MAC check via CRYPTO_memcmp. There is no logic to support or implement a truncated HMAC extension; thus, it ensures that only the full MAC is used, complying with the spec that mandates not to use truncated HMAC.'}}, {'C2': {'code': 'if (!PACKET_get_1(&pkt, &type)\n        || !PACKET_get_net_2(&pkt, &version)\n        || !PACKET_get_net_2_len(&pkt, &thisrr->length)) {\n    ...\n}\nthisrr->type = type;\nthisrr->rec_version = version;\n\nif (thisrr->rec_version == SSL2_VERSION) {\n    RLAYERfatal(rl, SSL_AD_PROTOCOL_VERSION, SSL_R_WRONG_VERSION_NUMBER);\n    return OSSL_RECORD_RETURN_FATAL;\n}', 'explanation': ""When processing an SSLv3+ style record, the function checks if the record version equals SSL2_VERSION and if so, aborts the processing with a fatal alert. This enforces that no records with a version less than 0x0300 are accepted (aside from the special case allowed for a server's first SSLv2ClientHello), matching the spec context requirements.""}}]","The function_body implements TLS record processing while explicitly ensuring that records with versions below TLS 1.0 (0x0300) are rejected and that the MAC is computed using the full digest size, thereby not supporting the truncated HMAC extension. Both of these checks are performed directly in the function, fulfilling the constraints specified in the RFC regarding the rejection of truncated HMAC and records with version less than 0x0300.",success,
10436,tls_get_more_records,"Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure.",283,Partially Matches,"[{'C1': {'code': 'if (thisrr->length == 0) {\n    if (++(rl->empty_record_count) > MAX_EMPTY_RECORDS) {\n        RLAYERfatal(rl, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_RECORD_TOO_SMALL);\n        goto end;\n    }\n} else {\n    rl->empty_record_count = 0;\n}', 'explanation': 'This snippet handles zero-length records by allowing them until a certain threshold (MAX_EMPTY_RECORDS) is exceeded. This corresponds to the TLS RFC allowance for zero-length Application Data fragments to be sent as a traffic analysis countermeasure. However, only this aspect is directly addressed in the function.'}}]","The TLS RFC states that zero-length fragments of Application Data may be sent. In the provided function, there is explicit handling of a record with a length of zero, where an empty record count is maintained without immediately raising an error unless the number of such records exceeds a defined maximum. This demonstrates that the function attempts to implement the allowance of zero-length fragments. However, since the specification also includes other conditions (for instance, specifications on how records are combined or how alerts are managed) which are not explicitly handled within this function, the overall implementation qualifies as a partial match.",success,
10436,tls_get_more_records,"Specifically, if the server fails to decrypt a 0-RTT record following an accepted ""early_data"" extension, it MUST terminate the connection with a ""bad_record_mac"" alert as per Section 5.2.",154,Fully Matches,"[{'C1': {'code': 'if (enc_err == 0) {\n    if (rl->alert != SSL_AD_NO_ALERT) {\n        ERR_clear_last_mark();\n        goto end;\n    }\n    if (num_recs == 1\n            && rl->skip_early_data != NULL\n            && rl->skip_early_data(rl->cbarg)) {\n        /* Early data decryption failed but the early_data extension is rejected,\n         * so the record is treated as empty and the handshake continues */\n        ERR_pop_to_mark();\n        thisrr = &rr[0];\n\n        if (!rlayer_early_data_count_ok(rl, thisrr->length,\n                                        EARLY_DATA_CIPHERTEXT_OVERHEAD, 0)) {\n            goto end;\n        }\n\n        thisrr->length = 0;\n        rl->num_recs = 0;\n        rl->curr_rec = 0;\n        rl->num_released = 0;\n        memset(rl->sequence, 0, sizeof(rl->sequence));\n        ret = 1;\n        goto end;\n    }\n    ERR_clear_last_mark();\n    RLAYERfatal(rl, SSL_AD_BAD_RECORD_MAC,\n                SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n    goto end;\n}', 'explanation': 'This segment checks if decryption failed (enc_err == 0) and then distinguishes whether the failure occurred on a 0-RTT record. It uses the skip_early_data callback to decide if the early data was rejected. In cases where early data was accepted (i.e. skip_early_data is not triggered), it proceeds to terminate the connection.'}}, {'A1': {'code': 'RLAYERfatal(rl, SSL_AD_BAD_RECORD_MAC, SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);', 'explanation': ""This call terminates the connection by generating a 'bad_record_mac' alert, directly implementing the action required by the specification when decryption of a 0-RTT record fails.""}}]","The function tls_get_more_records implements critical logic that handles record decryption, including 0-RTT (early data) records. In the event of a decryption failure, it checks via a callback (skip_early_data) to determine if the early data extension was rejected. If not rejected—that is, if the server has accepted the early_data extension—the function terminates the connection by calling RLAYERfatal with a 'bad_record_mac' alert. This behavior directly reflects the TLS RFC requirement that a server must terminate the connection with a 'bad_record_mac' alert when it fails to decrypt a 0-RTT record following an accepted early_data extension. Hence, the code fully meets the specified constraint.",success,
10437,tls_default_validate_record_header,"An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.",292,Fully Matches,"[{'C1': {'code': 'if (rec->length > len) {', 'explanation': 'This line checks whether the record length exceeds the allowed maximum (2^14 + 256 bytes, encapsulated in the constant SSL3_RT_MAX_ENCRYPTED_LENGTH, adjusted for compression overhead if applicable). This implements the condition that a record must not exceed the specified length.'}}, {'A1': {'code': 'RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);', 'explanation': ""When the record length is found to exceed the allowed value, this call terminates the connection by raising a 'record_overflow' alert, fulfilling the action specified in the RFC.""}}]","The function tls_default_validate_record_header directly implements the specified TLS RFC requirement by first checking if the record's length exceeds the maximum permitted value (C1). If it does, the function terminates the connection with a record_overflow alert (A1). All logic to enforce the RFC constraint is contained within the function itself, and no reliance on external dependencies is assumed.",success,
10437,tls_default_validate_record_header,"An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.",288,Fully Matches,"[{'C1': {'code': 'if (rec->length > len) { ... }', 'explanation': ""This code segment checks whether the received record's length exceeds the maximum allowed value, which is in line with the RFC condition that the record's length MUST NOT exceed 2^14 bytes.""}}, {'A1': {'code': 'RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);', 'explanation': ""When the record's length exceeds the limit, the function terminates the connection with a record_overflow alert by calling RLAYERfatal, thereby implementing the RFC action requirement.""}}]","The function 'tls_default_validate_record_header' explicitly validates the record header by checking if the record's length exceeds a predetermined maximum (which aligns with the 2^14-byte constraint). If this condition is met, it terminates the connection with a 'record_overflow' alert using RLAYERfatal. This directly implements the TLS RFC requirement stated in the specification.",success,
10440,tls_default_post_process_record,The presence of padding does not change the overall record size limitations: the full encoded TLSInnerPlaintext MUST NOT exceed 2^14 + 1 octets.,304,Partially Matches,"[{'C1': {'code': 'if (rec->length > SSL3_RT_MAX_PLAIN_LENGTH) {\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_DATA_LENGTH_TOO_LONG);\n    return 0;\n}', 'explanation': ""This segment checks that the length of the record does not exceed the maximum plaintext size (2^14 + 1 octets), directly addressing the spec's record size limitation requirement.""}}]","The provided function enforces a maximum size on the TLS inner plaintext by checking that rec->length does not exceed SSL3_RT_MAX_PLAIN_LENGTH, thereby addressing the specified RFC requirement regarding the record size limit. However, the RFC also specifies that the implementation must limit its scanning to the cleartext returned from AEAD decryption and terminate the connection if no non-zero octet is found. This additional check is not present in the function. Thus, while one key aspect (record size limitation) is implemented within this function, not all aspects of the spec constraints are handled here, resulting in a partially matching implementation.",success,
10440,tls_default_post_process_record,"An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.",292,Fully Matches,"[{'C1': {'code': 'if (rl->compctx != NULL) {\n    if (rec->length > SSL3_RT_MAX_COMPRESSED_LENGTH) {\n        RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_COMPRESSED_LENGTH_TOO_LONG);\n        return 0;\n    }\n    if (!tls_do_uncompress(rl, rec)) {\n        RLAYERfatal(rl, SSL_AD_DECOMPRESSION_FAILURE, SSL_R_BAD_DECOMPRESSION);\n        return 0;\n    }\n}\n\nif (rec->length > SSL3_RT_MAX_PLAIN_LENGTH) {\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_DATA_LENGTH_TOO_LONG);\n    return 0;\n}', 'explanation': ""The function checks whether the record length exceeds predefined maximums — for both compressed (SSL3_RT_MAX_COMPRESSED_LENGTH) and uncompressed (SSL3_RT_MAX_PLAIN_LENGTH) records. In each case where the length is too long, it calls RLAYERfatal with the SSL_AD_RECORD_OVERFLOW alert, thereby directly implementing the RFC specification that mandates terminating the connection with a 'record_overflow' alert when an oversized record is received.""}}]","The provided function_body verifies if the incoming record's length exceeds the allowed thresholds, both before and after decompression. If the length is too long, it terminates the connection by issuing a record_overflow alert (via RLAYERfatal). This logic directly addresses the TLS RFC requirement that an endpoint must terminate connections with a record_overflow alert when the record length exceeds 2^14+256 bytes (or the applicable limit), and thus the function fully matches the specified constraint.",success,
10440,tls_default_post_process_record,"An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.",288,Fully Matches,"[{'C1': {'code': 'if (rec->length > SSL3_RT_MAX_COMPRESSED_LENGTH) {\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_COMPRESSED_LENGTH_TOO_LONG);\n    return 0;\n}\n...\nif (rec->length > SSL3_RT_MAX_PLAIN_LENGTH) {\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_DATA_LENGTH_TOO_LONG);\n    return 0;\n}', 'explanation': ""The code checks if the record length exceeds the maximum allowed size (for both compressed and plain records) and, if so, terminates the connection by calling RLAYERfatal with a 'record_overflow' alert. This directly implements the spec's requirement to terminate the connection with a record_overflow alert when the record exceeds the allowed size.""}}]","The provided function directly implements the TLS RFC requirement by checking if the incoming record length exceeds the permitted maximum (using SSL3_RT_MAX_COMPRESSED_LENGTH for compressed records and SSL3_RT_MAX_PLAIN_LENGTH for uncompressed records). Upon detecting an oversize record, the function immediately terminates the connection by invoking RLAYERfatal with the SSL_AD_RECORD_OVERFLOW alert. This logic fully addresses the specified constraint within the function itself without relying on external dependencies.",success,
10441,tls13_common_post_process_record,"Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure.",283,Fully Matches,"[{'C1': {'code': 'if ((rec->type == SSL3_RT_HANDSHAKE || rec->type == SSL3_RT_ALERT) && rec->length == 0) {\n        RLAYERfatal(rl, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_BAD_LENGTH);\n        return 0;\n    }', 'explanation': 'This code explicitly ensures that TLSv1.3 handshake and alert records are non-zero in length, as required by the specification, while not imposing such a check on Application Data (thereby implicitly allowing zero-length Application Data fragments).'}}]","The function verifies that only valid TLS record types (Application Data, Alert, and Handshake) are processed. It enforces that handshake and alert records must be non-zero in length by returning an error if their length is zero. Because it does not restrict zero-length Application Data records, it aligns with the spec which allows zero-length fragments as a traffic analysis countermeasure. Therefore, the function fully addresses the relevant TLS RFC constraints within its own logic.",success,
10441,tls13_common_post_process_record,"Implementations MUST NOT send Handshake and Alert records that have a zero-length TLSInnerPlaintext.content; if such a message is received, the receiving implementation MUST terminate the connection with an ""unexpected_message"" alert.",301,Fully Matches,"[{'C1': {'code': 'if ((rec->type == SSL3_RT_HANDSHAKE || rec->type == SSL3_RT_ALERT)\n        && rec->length == 0) {\n    RLAYERfatal(rl, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_BAD_LENGTH);\n    return 0;\n}', 'explanation': 'This code segment checks if the record type is Handshake or Alert and if its length is zero. If so, it terminates the connection by calling RLAYERfatal with an unexpected_message alert, which directly implements the requirement from the RFC to disallow zero-length contents for these record types.'}}]","The function explicitly implements the spec requirement by verifying that Handshake and Alert records are not zero-length, and by terminating the connection with an 'unexpected_message' alert if they are. This logic within the function fully addresses the specified TLS RFC constraint.",success,
10441,tls13_common_post_process_record,"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",272,Partially Matches,"[{'C1': {'code': 'if (rec->type != SSL3_RT_APPLICATION_DATA\n        && rec->type != SSL3_RT_ALERT\n        && rec->type != SSL3_RT_HANDSHAKE) {\n    RLAYERfatal(rl, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_BAD_RECORD_TYPE);\n    return 0;\n}', 'explanation': 'This code segment checks if the record type is not one of the expected types (application data, alert, or handshake) and aborts the connection with an unexpected_message alert, which directly corresponds to the RFC requirement for handling unexpected record types.'}}]","The function implements a check for unexpected record types and terminates the connection with an 'unexpected_message' alert as required (labeled here as C1). However, the RFC and the provided context also specify special handling for change_cipher_spec records (dropping allowed unencrypted records and aborting in other cases), but this function does not include any logic specific to change_cipher_spec handling. Since only part of the specification is implemented within this function, the outcome is 'Partially Matches'.",success,
10447,tls_int_free,"Once all the values which are to be derived from a given secret have been computed, that secret SHOULD be erased.",325,Partially Matches,"[{'A1': {'code': 'if (rl->version == SSL3_VERSION)\n    OPENSSL_cleanse(rl->mac_secret, sizeof(rl->mac_secret));', 'explanation': 'The function makes an attempt to erase secret material by cleansing the mac_secret for SSL3 (thus addressing the requirement to clear out secret data) but only in this version. It does not generally erase all secrets or address non-SSL3 versions, hence only partially fulfilling the spec requirement.'}}]","The TLS RFC specification requires that once all values derived from a given secret are computed, the secret should be erased. In the provided function, there is an explicit call to OPENSSL_cleanse on rl->mac_secret when the version is SSL3_VERSION, which indicates an effort to remove sensitive secret data. However, this erasure is limited to one field and only under SSL3 conditions. Other secret-related fields (such as iv, nonce, and those in cryptographic contexts) are freed without special cleansing, and the function does not uniformly apply secret erasure across all potential secret data. Thus, the function only partially matches the spec requirement as implemented in its own body.",success,
10451,tls_app_data_pending,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Does Not Match,[],"The tls_app_data_pending function only aggregates the length of contiguous Application Data records and contains no logic addressing Alert messages. The RFC specification requires that each Alert record contain exactly one alert message without fragmentation or coalescing, but this function does not inspect or enforce any such rule. Therefore, none of the conditions or actions related to alert message handling have been implemented in this function.",success,
10455,tls_initialise_write_packets_default,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Does Not Match,[],"The RFC spec states that implementations MAY choose to pad TLSCiphertext records by appending a series of zero-valued bytes to obscure the size of the content before encryption. In the provided function body, although there is logic to calculate an alignment value and allocate a corresponding number of bytes (e.g., the calculation of 'align' and the call to WPACKET_allocate_bytes), there is no explicit implementation of appending or setting a padded block of zero-valued bytes as described in the RFC. The code simply initializes packet buffers and reserves some space for potential alignment without addressing the actual padding mechanism specified. Therefore, within the scope of this function, no conditions (such as C1) or actions (such as A1) described in the TLS padding specification are visibly implemented.",success,
10456,tls_prepare_record_header_default,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Does Not Match,[],"The RFC specification relates to applying optional padding to a TLSCiphertext record (i.e., appending a string of zero-valued bytes and setting a padding octet length) to obscure the record size. In the provided function_body, there is no logic that deals with padding (i.e., there is no code that appends zero-valued bytes, chooses a padding length, or explicitly initializes padding bytes to zero). The function only sets up the record header and reserves space for the record content. Thus, it does not visibly implement or address the TLS padding requirement.",success,
10457,tls_prepare_for_encryption_default,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Does Not Match,[],"The provided code function does not implement any padding logic. The TLS RFC spec describes that implementations MAY choose to pad TLSCiphertext records by appending zero-valued bytes to the ContentType field before encryption, with specific rules regarding unpadded and padded records. In the function, there is logic for handling the MAC and reserving space for encryption overhead, but there is no code that attempts to add or manage the padding bytes as described. Therefore, in isolation, this function does not visibly address the spec constraint related to optional padding as required by the TLS RFC.",success,
10459,tls_write_records_default,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Partially Matches,"[{'A1': {'code': 'if (rl->funcs->add_record_padding != NULL\n                && !rl->funcs->add_record_padding(rl, thistempl, thispkt,\n                                                  thiswr)) {\n            /* RLAYERfatal() already called */\n            goto err;\n        }', 'explanation': 'This segment shows that the function conditionally adds record padding by calling the add_record_padding callback. This correlates with the specification that implementations MAY choose to pad TLSCiphertext records. However, the function merely delegates padding responsibilities and does not itself implement the details (such as ensuring the padding octets are all zeros), so not all aspects of the spec are directly handled in the function body.'}}]","The provided function acknowledges the option to pad TLS records through a call to a helper function (add_record_padding) when available. This demonstrates an attempt to address the TLS RFC's stipulation that padding MAY be applied. However, the function does not implement the specific details of padding (for example, ensuring padding bytes are set to zero) itself; it relies on the callback for that functionality. Since the logic for generating and zeroing padding bytes is not directly in the function body, the code only partially meets the specified constraint.",success,
10459,tls_write_records_default,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data.",320,Partially Matches,"[{'A1': {'code': 'if (mac_size < 0) {\n    RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}\n\n... (other similar calls to RLAYERfatal within error paths)', 'explanation': 'The function calls RLAYERfatal in several error cases, which suggests an attempt to send an appropriate fatal alert when a fatal error condition is detected.'}}]","The TLS RFC requirement states that upon encountering a fatal error, an implementation SHOULD send an appropriate fatal alert and MUST immediately close the connection without further I/O. In this function, when errors occur, it calls RLAYERfatal (thereby addressing the 'send fatal alert' portion). However, the function does not explicitly implement logic to close the connection or prevent additional data from being sent or received; it simply jumps to an error cleanup section. Therefore, while there is an attempt (A1) to meet the error alerting requirement, the closure of the connection as mandated by the RFC is not visibly implemented within this function. As a result, the code only partially matches the specification.",success,
10461,tls_retry_write_records,"Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure.",283,Fully Matches,"[{'A1': {'code': '/*\n         * When an empty fragment is sent on a connection using KTLS,\n         * it is sent as a write of zero bytes.  If this zero byte\n         * write succeeds, i will be 0 rather than a non-zero value.\n         * Treat i == 0 as success rather than an error for zero byte\n         * writes to permit this case.\n         */\n        if (i >= 0 && tmpwrit == TLS_BUFFER_get_left(thiswb)) {\n            TLS_BUFFER_set_left(thiswb, 0);\n            TLS_BUFFER_add_offset(thiswb, tmpwrit);\n            if (++(rl->nextwbuf) < rl->numwpipes)\n                continue;\n            \n            if (rl->nextwbuf == rl->numwpipes\n                    && (rl->mode & SSL_MODE_RELEASE_BUFFERS) != 0)\n                tls_release_write_buffer(rl);\n            return OSSL_RECORD_RETURN_SUCCESS;\n        }', 'explanation': ""This code segment clearly ensures that a zero-length write (i.e. writing 0 bytes) -- which would occur when sending an empty fragment of Application Data under conditions like KTLS -- is treated as a successful operation. This directly implements the RFC specification that 'Zero-length fragments of Application Data MAY be sent.'""}}]","The tls_retry_write_records function includes explicit logic to handle the case where an empty fragment (zero-length Application Data) is sent. The comment and subsequent code treat a write of 0 bytes as a success, thereby satisfying the specification constraint concerning zero-length fragments. Since this handling is entirely visible within the function, it fully matches the relevant action specified in the RFC.",success,
10472,tls_increment_sequence_ctr,"If a TLS implementation would need to wrap a sequence number, it MUST either rekey (Section 4.6.3) or terminate the connection.",297,Fully Matches,"[{'C1': {'code': 'if (i == 0) {\n    /* Sequence has wrapped */\n    RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, SSL_R_SEQUENCE_CTR_WRAPPED);\n    return 0;\n}', 'explanation': 'This segment checks whether the sequence counter has wrapped (i.e. all bytes have cycled back to 0) and terminates the connection by calling RLAYERfatal. This behavior directly implements the RFC requirement that if a TLS implementation would need to wrap a sequence number, it must either rekey or terminate the connection. Here, termination is chosen.'}}]","The function tls_increment_sequence_ctr increments the sequence counter and validates that it has not wrapped. Upon detecting a wrap (which is not permissible under the RFC), it terminates the connection rather than attempting to rekey. This aligns with the RFC specification, as terminating the connection is an acceptable action when a sequence wrap is imminent. All relevant aspects of the specified constraint are addressed within this function.",success,
10477,tls_validate_record_header,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (rec->rec_version == SSL2_VERSION) {\n    if (rec->length < MIN_SSL2_RECORD_LEN) {\n        RLAYERfatal(rl, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_TOO_SHORT);\n        return 0;\n    }\n}', 'explanation': 'This segment checks if an SSLv2 record has a length below the minimum required and triggers a fatal alert with SSL_AD_DECODE_ERROR. This corresponds to the RFC condition that a syntactically unparseable message (in this case, too-short records) should result in a decode_error alert.'}}]","The function performs header validation by checking record length and version. In the SSLv2 branch it correctly checks for records that are too short and sends a decode_error alert. However, for other cases (e.g., rec->length exceeding SSL3_RT_MAX_PLAIN_LENGTH) the function uses a different alert (SSL_AD_RECORD_OVERFLOW) instead of a decode_error alert. Moreover, other syntactic issues are handled with various alert types. Therefore, while part of the spec condition (handling parse errors via decode_error alerts) is implemented, it is not uniformly applied across all cases mandated by the RFC, resulting in a partial match.",success,
10477,tls_validate_record_header,"An endpoint that receives a record from its peer with TLSCiphertext.length larger than 2^14 + 256 octets MUST terminate the connection with a ""record_overflow"" alert.",295,Fully Matches,"[{'C1': {'code': 'if (rec->length > SSL3_RT_MAX_PLAIN_LENGTH) {\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_DATA_LENGTH_TOO_LONG);\n    return 0;\n}', 'explanation': 'This segment checks if the received TLS record length exceeds a preset maximum (SSL3_RT_MAX_PLAIN_LENGTH), and if so, it terminates the connection with a record_overflow alert. This behavior corresponds to the RFC specification that a record with TLSCiphertext.length larger than 2^14 + 256 octets must result in connection termination with a record_overflow alert.'}}]","The function tls_validate_record_header explicitly checks the record length against a maximum allowable value (implicitly defined to reflect 2^14 + 256 octets) and, upon violation, calls RLAYERfatal with SSL_AD_RECORD_OVERFLOW to signal a record_overflow error. This directly implements the specified TLS RFC requirement within this function, independent of any external dependencies.",success,
10477,tls_validate_record_header,"An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.",292,Fully Matches,"[{'C1': {'code': 'if (rec->length > SSL3_RT_MAX_PLAIN_LENGTH) {\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_DATA_LENGTH_TOO_LONG);\n    return 0;\n}', 'explanation': ""This segment directly implements the RFC requirement that a record's length must not exceed 2^14 + 256 bytes. If the record length (rec->length) is greater than SSL3_RT_MAX_PLAIN_LENGTH, the code terminates the connection with a 'record_overflow' alert via RLAYERfatal.""}}]","The function contains the logic to terminate a connection when a received record exceeds the allowed length as specified in the TLS RFC. The check (rec->length > SSL3_RT_MAX_PLAIN_LENGTH) along with terminating the connection using RLAYERfatal with SSL_AD_RECORD_OVERFLOW meets the condition and action described in the RFC. Thus, the code function visibly addresses the spec constraint by itself.",success,
10477,tls_validate_record_header,Implementations MUST NOT negotiate TLS 1.3 or later using an SSL version 2.0 compatible CLIENT-HELLO.,394,Fully Matches,"[{'C1': {'code': 'if (rec->rec_version == SSL2_VERSION) {\n    if (!ossl_assert(rl->version == TLS_ANY_VERSION)) {\n        RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    if (rec->length < MIN_SSL2_RECORD_LEN) {\n        RLAYERfatal(rl, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_TOO_SHORT);\n        return 0;\n    }\n}', 'explanation': 'This code segment checks if the record version indicates an SSLv2 formatted ClientHello. It then asserts that the handshake version (rl->version) is still in the initial state (TLS_ANY_VERSION) and not already set to a specific TLS version like TLS 1.3. This prevents the negotiation of TLS 1.3 or later using a SSLv2 compatible ClientHello, thereby fulfilling the spec constraint.'}}]","The function explicitly inspects SSLv2 messages by checking if rec->rec_version equals SSL2_VERSION, and it enforces that such messages are only processed if the handshake version is still TLS_ANY_VERSION. This mechanism prevents an SSLv2 ClientHello from being used once a specific TLS version (including TLS 1.3 or later) is in play, thereby fully addressing the specified TLS RFC requirement.",success,
10477,tls_validate_record_header,"An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.",288,Fully Matches,"[{'C1': {'code': 'if (rec->length > SSL3_RT_MAX_PLAIN_LENGTH) {\n        RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_DATA_LENGTH_TOO_LONG);\n        return 0;\n    }', 'explanation': ""This segment checks whether the record's length exceeds the maximum allowed length (2^14 bytes, here represented by SSL3_RT_MAX_PLAIN_LENGTH) and, if it does, terminates the connection with a 'record_overflow' alert. This directly implements the RFC requirement.""}}]","The function 'tls_validate_record_header' contains logic that directly validates the record length against the maximum permitted value. When the length exceeds SSL3_RT_MAX_PLAIN_LENGTH, it calls RLAYERfatal with the alert SSL_AD_RECORD_OVERFLOW, thereby ensuring that the connection is terminated according to the TLS RFC specification. This check is implemented entirely within this function, fulfilling the requirement as per the specified constraints.",success,
10477,tls_validate_record_header,This field is deprecated and MUST be ignored for all purposes,286,Partially Matches,"[{'C1': {'code': 'if (rec->length > SSL3_RT_MAX_PLAIN_LENGTH) {\n    /* We use SSL_R_DATA_LENGTH_TOO_LONG instead of SSL_R_ENCRYPTED_LENGTH_TOO_LONG because we are the ""any"" method\n     * and we know that we are dealing with plaintext data */\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_DATA_LENGTH_TOO_LONG);\n    return 0;\n}', 'explanation': 'This segment verifies that the record length does not exceed the maximum allowed (2^14 bytes as per TLS), thereby addressing a key portion of the TLS RFC that mandates rejecting overlong records.'}}, {'C2': {'code': 'if (rec->rec_version != rl->version) {\n    if ((rl->version & 0xFF00) == (rec->rec_version & 0xFF00)) {\n        if (rec->type == SSL3_RT_ALERT) {\n            RLAYERfatal(rl, SSL_AD_NO_ALERT, SSL_R_WRONG_VERSION_NUMBER);\n            return 0;\n        }\n        rl->version = (unsigned short)rec->rec_version;\n    }\n    RLAYERfatal(rl, SSL_AD_PROTOCOL_VERSION, SSL_R_WRONG_VERSION_NUMBER);\n    return 0;\n}', 'explanation': 'This code checks the record version against the expected TLS version and handles mismatches accordingly. It even includes special handling for TLS 1.3 (ignoring the legacy record version) and for alerts, which is part of ensuring proper protocol version processing.'}}]","The tls_validate_record_header function implements several important validations required by the TLS RFC for processing record headers. It verifies that the record length does not exceed protocol limits and that the record’s version matches the expected value (with special provisions for TLS 1.3 and alert records). However, while these checks address major aspects of the TLS record header validation, the function does not cover every possible condition or action specified in the RFC constraints. As a result, the implementation partially matches the set of spec constraints by itself.",success,
10481,ssl3_set_crypto_state,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function initializes cryptographic state by setting up cipher and digest contexts and copying keys, but it does not contain any logic that addresses the specific RFC requirements. There is no code checking or prohibiting the use of the Truncated HMAC extension, nor any logic enforcing that records with version numbers less than 0x0300 are not sent or accepted. All logic related to these constraints is absent, and as such, this function does not attempt to fulfill the spec constraints described (e.g., C1 or A1).",success,
10482,ssl3_cipher,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Fully Matches,"[{'C1': {'code': 'if ((bs != 1) && sending && !provided) {\n    i = bs - (l % bs);\n    l += i;\n    memset(&rec->input[rec->length], 0, i);\n    rec->length += i;\n    rec->input[l - 1] = (unsigned char)(i - 1);\n}', 'explanation': 'This branch is executed only when sending a TLS record using a legacy cipher (i.e. non‐provided ciphers), thereby conditionally choosing to pad the outgoing TLSCiphertext record as allowed by the RFC.'}}, {'A1': {'code': 'memset(&rec->input[rec->length], 0, i);\nrec->input[l - 1] = (unsigned char)(i - 1);', 'explanation': 'The code zeros out the padding bytes before encryption (except that the final padding byte is overwritten with the padding length, which is a common method for indicating padding size in TLS records). This satisfies the action that the padding octets must be set (to zero before encryption) as specified by the RFC.'}}]","The function_body contains a clear logic branch that applies padding when generating a TLSCiphertext record in sending mode for legacy ciphers. It calculates the number of padding bytes needed, fills them with zeros (with the last byte conveying the padding length), and thereby implements the optional padding behavior described in the RFC specification. All of this is done within the function itself (without relying on external dependencies), meaning that the function visibly addresses the spec constraints.",success,
10482,ssl3_cipher,"If the decryption fails, the receiver MUST terminate the connection with a ""bad_record_mac"" alert.",293,Partially Matches,"[{'A1': {'code': ""if (EVP_Cipher(ds, rec->data, rec->input, (unsigned int)l) < 1) {\n    /* Shouldn't happen */\n    RLAYERfatal(rl, SSL_AD_BAD_RECORD_MAC, ERR_R_INTERNAL_ERROR);\n    return 0;\n}"", 'explanation': ""This branch directly attempts to implement the TLS requirement by terminating the connection with a 'bad_record_mac' alert when decryption fails for legacy (non‐provided) ciphers. However, a similar decryption failure scenario in the provided cipher branch only returns 0 without invoking RLAYERfatal.""}}]","The RFC specification requires that if decryption fails, the receiver must terminate the connection with a 'bad_record_mac' alert. In function_body, only the non-provided (legacy) cipher branch explicitly calls RLAYERfatal with the SSL_AD_BAD_RECORD_MAC alert when decryption fails. The provided cipher branch, however, simply returns 0 without explicit termination via a 'bad_record_mac' alert. This partial implementation means the function only partially meets the specified requirement.",success,
10485,dtls_record_replay_check,Servers SHOULD provide that level of replay safety by implementing one of the methods described in this section or by equivalent means.,334,Partially Matches,"[{'A1': {'code': 'cmp = satsub64be(seq, bitmap->max_seq_num);\nif (cmp > 0) {\n    ossl_tls_rl_record_set_seq_num(&rl->rrec[0], seq);\n    return 1;               /* this record in new */\n}\nshift = -cmp;\nif (shift >= sizeof(bitmap->map) * 8)\n    return 0;               /* stale, outside the window */\nelse if (bitmap->map & ((uint64_t)1 << shift))\n    return 0;               /* record previously received */\n\nossl_tls_rl_record_set_seq_num(&rl->rrec[0], seq);\nreturn 1;', 'explanation': 'This code implements a replay detection mechanism by comparing the received sequence number (representing a 0-RTT or DTLS record) with the highest known sequence number using a subtraction function. It then uses a sliding window (bitmap) to decide if a record has been accepted before. This partially fulfills the TLS replay safety requirement by ensuring that the same record (or early data) is accepted at most once. However, it does not encompass all dimensions detailed in the RFC (such as handling cross-instance state or explicitly limiting replays of 0-RTT handshakes across zones), meaning that while the function addresses replay detection locally, it only partially meets the full spec constraint.'}}]","The provided function shows logic to reject replayed records by checking sequence numbers and employing a bitmap windowing mechanism, thereby addressing a core part of the replay safety mechanism required by the spec. However, since it does not implement the entire range of measures described in the RFC (for instance, handling server instance boundaries or limiting replays beyond the local scope), the function only partially matches the specification's requirements.",success,
10489,dtls_process_record,"An endpoint that receives a record from its peer with TLSCiphertext.length larger than 2^14 + 256 octets MUST terminate the connection with a ""record_overflow"" alert.",295,Fully Matches,"[{'C1': {'code': 'if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {\n    RLAYERfatal(rl, SSL_AD_RECORD_OVERFLOW, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\n    return 0;\n}', 'explanation': ""This code segment checks if the received record length exceeds the maximum allowed (which is defined as SSL3_RT_MAX_ENCRYPTED_LENGTH and corresponds to 2^14 + 256 octets per the RFC). Upon detecting an overflow, it calls RLAYERfatal with the 'record_overflow' alert, thus enforcing the requirement in the specification.""}}]","The function directly implements the RFC requirement by verifying that TLSCiphertext.length does not exceed the maximum allowed value (2^14 + 256 octets) and terminates the connection with a 'record_overflow' alert if the check fails. This logic is self-contained within the function, fulfilling the specified constraint.",success,
10489,dtls_process_record,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification requires that implementations MUST NOT use the Truncated HMAC extension. This function does perform MAC computation and verification, but it does not include any logic to check for or disable the use of a truncated HMAC extension. Additionally, the RFC context also mentions rejecting records with a version less than 0x0300, but no version check is visible in the function. Therefore, none of the specific labeled constraints or actions from the spec are visibly implemented in this function.",success,
10490,dtls_rlayer_buffer_record,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function 'dtls_rlayer_buffer_record' is concerned with record buffering and queue management, including memory allocation, copying of buffers, and error handling. There is no logic in this function that checks for or prevents the negotiation of RC4 cipher suites or ciphers with less than 112 bits strength, which is the requirement specified under the TLS RFC constraint. Since the function does not implement any checks related to RC4 or cipher strength, it does not address any of the labeled spec constraints (such as C1 or A1) regarding cipher suite selection detailed in the spec context.",success,
10493,dtls_get_more_records,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The function dtls_get_more_records focuses on reading and processing DTLS records by validating header contents, record lengths, epoch checks, and replay conditions. Although there is a version check (e.g., comparing ssl_major with the expected version) in the code, there is no explicit logic to reject or detect an SSL version 2.0 compatible CLIENT-HELLO or to guarantee that SSL2 is not negotiated. The RFC requirement that SSL2 MUST NOT be negotiated is not directly addressed in this function. Therefore, no labeled condition or action corresponding to the spec constraint (e.g., C1 for SSL2 rejection) is visibly implemented in the provided code.",success,
10569,tls1_set_crypto_state,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function sets up the cryptographic state based on whether the cipher is an AEAD or not and properly initializes MAC keys when needed. However, there is no logic within this function that explicitly addresses the RFC requirement to not use the Truncated HMAC extension. The code does not include any checks or measures to disable or prevent the truncated HMAC extension; it simply sets up MAC keys in the non‐AEAD case and does not refer to any truncated HMAC extension specifics. As a result, this function does not visibly implement the specified RFC constraint.",success,
10570,tls1_cipher,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data.",320,Fully Matches,"[{'C1': {'code': 'if (n_recs == 0) {\n    RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}\n// ...\nif (!ossl_assert(rl->enc_ctx != NULL)) {\n    RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}', 'explanation': 'The function checks for invalid or unexpected state (such as no records or a missing encryption context) and immediately calls RLAYERfatal with an appropriate alert before returning. This matches the spec condition of detecting a fatal error condition.'}}, {'A1': {'code': 'RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\nreturn 0;', 'explanation': 'In all error cases detected within this function, it calls RLAYERfatal to send a fatal alert and then returns immediately, thereby ceasing further processing and preventing any additional data from being sent or received, which implements the RFC requirement.'}}]","The function tls1_cipher contains multiple checks for error conditions and in each case immediately calls the RLAYERfatal function (which is presumed to handle both alerting and subsequent connection termination) before returning. This behavior directly addresses the TLS RFC requirement to send an appropriate fatal alert and close the connection upon encountering a fatal error condition. As such, the function visibly implements the necessary actions and conditions, fulfilling the spec constraints within its own logic.",success,
10570,tls1_cipher,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Partially Matches,"[{'C1': {'code': '/* Legacy cipher branch when not provided, adding padding */\n            padnum = bs - (reclen[ctr] % bs);\n            if (padnum > MAX_PADDING) {\n                RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n                return 0;\n            }\n            padval = (unsigned char)(padnum - 1);\n            for (loop = reclen[ctr]; loop < reclen[ctr] + padnum; loop++)\n                recs[ctr].input[loop] = padval;\n            reclen[ctr] += padnum;\n            recs[ctr].length += padnum;', 'explanation': ""This code computes a padding length (padnum) and appends a series of padding bytes to the record's input buffer when sending with legacy ciphers. By doing so, it visibly implements the optional padding behavior as stated in the specification ('MAY choose to pad'). However, it sets each padding byte to (padnum-1) rather than zero, not fully matching the RFC requirement that padding octets be all zeros.""}}]","The function includes logic to add padding when generating TLSCiphertext records, which is an attempt to implement the RFC requirement that implementations MAY choose to pad. In the legacy cipher path, it calculates the required padding and appends the padding bytes. Nonetheless, it does not meet the full specification since it does not always set the padding octets to zero (it uses (padnum-1) instead). This means that while the function partially implements the spec (addressing the conditional padding), it does not entirely conform to the RFC constraint on the padding values.",success,
10570,tls1_cipher,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The TLS RFC specification requires that implementations must not use the Truncated HMAC extension; however, the provided function does not contain any explicit logic to check for or prevent the use of the Truncated HMAC extension. Although the function does handle AEAD cipher processing and legacy CBC processing, there is no code segment addressing the rejection or avoidance of truncated HMAC processing. The function does not inspect or validate the use of truncated HMAC based on any condition (e.g., checking mac length or extension flags), and therefore, the function does not implement the specified constraint from the RFC.",success,
10573,tls1_initialise_write_packets,"Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure.",283,Fully Matches,"[{'C1': {'code': 'prefix = rl->need_empty_fragments && templates[0].type == SSL3_RT_APPLICATION_DATA;\n\nif (prefix) {\n    /* countermeasure against known-IV weakness in CBC ciphersuites */\n    prefixtempl->buf = NULL;\n    prefixtempl->version = templates[0].version;\n    prefixtempl->buflen = 0;\n    prefixtempl->type = SSL3_RT_APPLICATION_DATA;\n\n    wb = &bufs[0];\n\n    #if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD != 0\n        align = (size_t)TLS_BUFFER_get_buf(wb) + SSL3_RT_HEADER_LENGTH;\n        align = SSL3_ALIGN_PAYLOAD - 1 - ((align - 1) % SSL3_ALIGN_PAYLOAD);\n    #endif\n    TLS_BUFFER_set_offset(wb, align);\n\n    if (!WPACKET_init_static_len(&pkt[0], TLS_BUFFER_get_buf(wb),\n                                 TLS_BUFFER_get_len(wb), 0)) {\n        RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    *wpinited = 1;\n    if (!WPACKET_allocate_bytes(&pkt[0], align, NULL)) {\n        RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n}', 'explanation': ""This code checks whether an empty fragment should be sent (using the condition 'rl->need_empty_fragments' and verifying the record type is Application Data), then constructs a record with a zero-length payload. This directly addresses the RFC specification that allows sending zero-length Application Data fragments as a traffic analysis countermeasure.""}}]","The function directly implements the mechanism to send a zero-length fragment of Application Data when required. It verifies a condition and sets up an appropriately empty record in compliance with the TLS RFC specification regarding zero-length fragments. All the logic to create an empty record is self-contained within this function, fulfilling the specified constraint.",success,
10573,tls1_initialise_write_packets,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Does Not Match,[],"The RFC specification indicates that implementations MAY choose to pad TLSCiphertext records by appending a string of zero‐valued bytes for traffic obfuscation. However, the function in question only deals with generating an empty record prefix as a countermeasure against known-IV weaknesses in CBC ciphersuites. The logic present (e.g., checking rl->need_empty_fragments, setting up a prefix template, computing an alignment, and allocating bytes accordingly) is aimed at creating an empty record for mitigation purposes rather than appending optional padding to inflate the record's size. There is no visible code within this function that implements or addresses the RFC’s padding requirement as described (i.e. appending a zero‐valued padding string to the ContentType field). Therefore, in isolation, this function does not attempt to implement the specified padding behavior from the RFC.",success,
10576,tls1_cbc_remove_padding_and_mac,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function tls1_cbc_remove_padding_and_mac primarily focuses on handling CBC padding removal and MAC extraction. It does include an AEAD branch that bypasses MAC verification, but there is no visible logic that addresses or enforces the RFC requirement that 'Implementations MUST NOT use the Truncated HMAC extension'. Since the function does not implement any specific checks or actions to avoid or disable the truncated HMAC extension, it does not meet the given spec constraint.",success,
11331,depack_do_frame_crypto,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!ossl_quic_wire_decode_frame_crypto(pkt, 0, &f)) {\n    ossl_quic_channel_raise_protocol_error(ch,\n                                           OSSL_QUIC_ERR_FRAME_ENCODING_ERROR,\n                                           OSSL_QUIC_FRAME_TYPE_CRYPTO,\n                                           ""decode error"");\n    return 0;\n}', 'explanation': 'This code segment checks if the crypto frame cannot be parsed (i.e. decoding fails) and raises a protocol error with the \'decode error\' message. This behavior directly implements the RFC requirement: \'Peers which receive a message which cannot be parsed... MUST terminate the connection with a ""decode_error"" alert\'.'}}]","The function explicitly handles parsing errors by checking the result of the decode function and raising a protocol error with a 'decode error' alert when failing to decode the frame, thereby fulfilling the specified condition in the RFC.",success,
11499,decrypt_validation_token,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function implements a decryption routine using an AEAD algorithm (likely AES-GCM), but it does not contain any logic addressing the TLS RFC requirement of not using the Truncated HMAC extension (nor does it check record versions below 0x0300). There is no code within the function that verifies or disables the use of the Truncated HMAC extension as required by the RFC specification. Since dependencies are not considered and the function itself does not implement any of the labeled spec requirements (like C1 or A1 related to this constraint), the function does not visibly implement the specified TLS RFC.",success,
11614,ch_init,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function does not contain any logic that enforces the constraint from RFC6091 which states that the OpenPGP certificate type MUST NOT be used with TLS 1.3. No code segments in the function inspect or validate the certificate_list contents or certificate types in relation to TLS 1.3. All parts of the function pertain to QUIC initialization, packet and stream handling, and TLS handshake setup, without any checks or conditions addressing the RFC6091 requirement.",success,
11672,ch_tick_tls,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function code (function_body) does not contain any logic that addresses or implements the TLS RFC specification constraint that implementations MUST NOT offer or negotiate RC4 cipher suites (specifically the conditions and actions related to that). The code primarily handles error checking and state ticking by calling ossl_quic_tls_tick and ossl_quic_tls_get_error, without any logic around cipher suite selection or filtering. Therefore, no labeled conditions or actions from the spec constraints (such as C1, A1) are implemented in this function.",success,
11683,ossl_quic_channel_start,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function does not contain any logic that checks or enforces the condition from the TLS RFC regarding the OpenPGP certificate type not being used with TLS 1.3. The function primarily focuses on QUIC channel initialization, token handling, and starting the handshake process without any specific checks related to certificate types. Thus, no part of the function directly implements or enforces the spec constraint (e.g., C1) about the OpenPGP certificate type as required by RFC6091 in the context of TLS 1.3.",success,
11992,ossl_qrx_allow_1rtt_processing,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function simply sets the allow_1rtt flag and requeues deferred messages. There is no logic within the function that checks for early data retransmission or validates the negotiated ALPN protocol as required by the TLS RFC specification. In other words, the function does not implement any of the TLS RFC spec constraints related to the handling of early data retransmission, thus it does not attempt to address conditions such as preventing automatic retransmission of early data.",success,
12103,alpn_select_cb,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6).",10,Fully Matches,"[{'C1': {'code': 'if (SSL_select_next_proto((unsigned char **)out, outlen, alpn, alpnlen,\n                              in, inlen) != OPENSSL_NPN_NEGOTIATED)\n        return SSL_TLSEXT_ERR_ALERT_FATAL;', 'explanation': 'This code checks whether there is any overlap in the supported ALPN protocols between the client and server. If there is no match (i.e., no common protocol), it meets the condition (C1) from the specification that requires aborting the handshake when parameter negotiation fails.'}}, {'A1': {'code': 'return SSL_TLSEXT_ERR_ALERT_FATAL;', 'explanation': 'This return value causes the handshake to be aborted with a fatal alert, satisfying the action (A1) dictated by the spec to terminate the handshake with either a handshake_failure or insufficient_security alert when no supported parameters are negotiated.'}}]","The function implements an ALPN selection callback that directly checks the overlap between the client's and the server's advertised ALPN protocols using SSL_select_next_proto. If no overlap is found, it immediately aborts the handshake by returning a fatal alert. This behavior directly addresses the TLS RFC requirement that mandates aborting the handshake with a fatal alert if no supported set of parameters is negotiated, thereby fully matching the cited spec constraints.",success,
12104,ossl_quic_tserver_new,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function does not contain any logic addressing the specification that the OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3. There is no check, validation, or condition within the code that inspects the certificate type or enforces the prohibition against using an OpenPGP certificate with TLS 1.3. All certificate handling in this function is limited to loading a certificate and key from files, setting an ALPN callback, and creating SSL objects without addressing the specific OpenPGP certificate restriction as stated in the RFC specification.",success,
12135,ossl_quic_tserver_set_max_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The function simply sets the maximum early data value by delegating to SSL_set_max_early_data and does not contain any logic to prevent or control the automatic retransmission of early data, nor does it check if the negotiated ALPN protocol matches the early data conditions. Thus, it does not address any of the labeled conditions or actions from the spec.",success,
12144,SSL_set_quic_tls_cbs,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function only initializes and configures QUIC TLS callbacks and related state. There is no visible logic within the function_body that checks for, filters out, or otherwise handles RC4 cipher suites or weak ciphers as required by the RFC specification. Thus, it does not implement any of the spec constraints regarding the prohibition of RC4 cipher suites (or any other cipher strength requirements) solely within this function.",success,
12146,SSL_set_quic_tls_early_data_enabled,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function only checks that the connection is TLS and that the qtls field is valid, then delegates to another function (ossl_quic_tls_set_early_data_enabled) to set early data. It does not implement any logic to either prevent automatic retransmission of early data or check the ALPN protocol consistency required by the RFC specification. No code in the function directly addresses the spec constraints regarding not automatically resending early data unless conditions such as ALPN protocol matching are met.",success,
12185,quic_new_record_layer,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function does not contain any code that explicitly checks for or prevents the use of the Truncated HMAC extension nor does it verify that records have a version at least 0x0300. Although the function accepts parameters related to MAC keys and version, it does not implement any logic to enforce the constraint that the Truncated HMAC extension MUST NOT be used, as required by the spec. Furthermore, there is no visible verification of the record version. Therefore, in isolation, this function does not address the spec constraints.",success,
12190,quic_write_records,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Fully Matches,"[{'C1': {'code': 'case SSL3_RT_ALERT:\n    if (template->buflen != 2) {\n        /* ... unexpected size: ensures exactly one alert message is sent */\n        QUIC_TLS_FATAL(rl, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_VALUE);\n        return OSSL_RECORD_RETURN_FATAL;\n    }\n    alert = template->buf[1];\n\n    if (!rl->qtls->args.alert_cb(rl->qtls->args.alert_cb_arg, alert)) {\n        QUIC_TLS_FATAL(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return OSSL_RECORD_RETURN_FATAL;\n    }\n    break;', 'explanation': 'This code segment explicitly checks that an alert record contains exactly 2 bytes (one for level and one for description). By asserting that template->buflen must equal 2, it prevents alert fragmentation and coalescing, fully addressing the TLS RFC requirement regarding alert message record structure.'}}]","The TLS spec requires that alert messages must not be fragmented across records or coalesced into a single record. The function's alert-handling logic (in the SSL3_RT_ALERT case) checks that the length of the alert message is exactly 2 bytes, ensuring that each alert record contains exactly one alert message. Therefore, this function alone visibly enforces the spec constraint regarding alert message handling.",success,
12190,quic_write_records,"In other words, a record with an Alert type MUST contain exactly one message.",282,Fully Matches,"[{'C1': {'code': 'if (!ossl_assert(numtempl == 1)) {\n    /* How could this be? quic_get_max_records() always returns 1 */\n    QUIC_TLS_FATAL(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return OSSL_RECORD_RETURN_FATAL;\n}', 'explanation': 'This check ensures that only one record template is processed at a time, aligning with the RFC requirement that a record (in this case, for alerts) must contain exactly one message.'}}, {'A1': {'code': 'case SSL3_RT_ALERT:\n    if (template->buflen != 2) {\n        /* We assume that libssl always sends both bytes of an alert to\n         * us in one go, and never fragments it. If we ever get more\n         * or less bytes than exactly 2 then this is very unexpected.\n         */\n        QUIC_TLS_FATAL(rl, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_VALUE);\n        return OSSL_RECORD_RETURN_FATAL;\n    }', 'explanation': 'This enforces that an Alert record is exactly 2 bytes long (one byte for the alert level and one for the description), ensuring that alert messages are neither fragmented nor coalesced, which meets the spec that an Alert record must contain exactly one message.'}}]","The function enforces the constraint from the TLS RFC by ensuring that exactly one record template is processed (numtempl == 1) and that any Alert record contains exactly 2 bytes, corresponding to a single alert message. This directly addresses the spec requirement that an Alert record must contain exactly one message, with the respective checks present within the function_body.",success,
12190,quic_write_records,-Handshake messages MUST NOT be interleaved with other record types.,275,Partially Matches,"[{'C1': {'code': 'if (!ossl_assert(numtempl == 1)) {\n    /* How could this be? quic_get_max_records() always returns 1 */\n    QUIC_TLS_FATAL(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return OSSL_RECORD_RETURN_FATAL;\n}\n\n...\n\nswitch (template->type) {\n    case SSL3_RT_ALERT:\n        ...\n        break;\n\n    case SSL3_RT_HANDSHAKE:\n        ...\n        break;\n\n    default:\n        QUIC_TLS_FATAL(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return OSSL_RECORD_RETURN_FATAL;\n}\n', 'explanation': 'The RFC requires that handshake messages not be interleaved with other record types. This function accepts only one record (numtempl == 1) and handles only handshake (and alert) record types. Any record type other than these (i.e. potential interleaving of non‐handshake data) causes an error. However, the function does not implement logic to handle scenarios where a handshake message is fragmented across multiple records and then interleaved with other types, so it only partially meets the requirement.'}}]","The function enforces that only a single record template is present and dispatches based on the type, only processing handshake (and alert) records. This prevents obvious interleaving of different record types at a high level. However, it does not contain explicit logic to ensure that fragments of a split handshake message are not interleaved with other record types or to check record boundaries in cases such as key changes. Thus, the implementation partially addresses the RFC constraint.",success,
12190,quic_write_records,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification prohibits offering or negotiating RC4 cipher suites. The provided function, quic_write_records, is solely responsible for writing TLS records (alerts and handshake data) and does not contain any logic related to cipher suite selection or negotiation. There are no segments in the function that address any conditions or actions related to prohibiting RC4 or ensuring cipher strengths as required by the spec.",success,
12192,quic_read_record,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function does not show any logic that checks for or prevents the use of the OpenPGP certificate type in TLS 1.3. It only reads a record, sets the TLS version to TLS1_3_VERSION, and processes handshake/application data, but does not address the specified RFC requirement that OpenPGP certificates must not be used in TLS 1.3. None of the spec constraints (e.g., the prohibition on using OpenPGP certificate type) are handled within this function.",success,
12192,quic_read_record,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The function_body does not include any logic that verifies or rejects values within ""obsolete_RESERVED"" ranges. The RFC specification requires that TLS 1.3 implementations MUST NOT offer or negotiate values from these ranges. However, this function solely reads record data and sets version and type, without filtering or checking for obsolete_RESERVED values. No code segments in this function address any labeled condition (e.g., C1) or action (e.g., A1) related to the requirement, hence the implementation does not visibly address the specification constraint.",success,
12193,quic_release_record,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function_body does not include any logic that relates to the TLS RFC specification regarding the prohibition of RC4 cipher suites or the requirement regarding cipher strength. The function only manages record release operations (asserting conditions on record lengths, calling a release callback, etc.) and does not examine, select, or verify cipher suites. Therefore, no specific part of the function addresses any of the labeled conditions/actions in the specification.",success,
12195,quic_set_protocol_version,"In particular, it MUST NOT negotiate TLS 1.3.",14,Does Not Match,[],"The RFC specification requires that TLS 1.3 must not be negotiated under certain conditions (for example, during renegotiation, the server must retain the previous TLS version and terminate with an unexpected_message alert if TLS 1.3 is received). However, the provided code function enforces that only TLS1.3 is acceptable by asserting that the version must equal TLS1_3_VERSION. It does not implement any logic to handle renegotiation or to reject TLS1.3 if it is not part of the initial negotiation. Therefore, within the function body itself, the code does not address the necessary conditions or actions from the RFC specification. Dependencies are not counted, and the function does not include the required constraints, leading to the conclusion that it does not match the spec.",success,
12201,quic_get_compression,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Fully Matches,"[{'C1': {'code': ""/* We only support TLSv1.3 which doesn't have compression */\nreturn NULL;"", 'explanation': 'The function explicitly returns NULL for the compression method, thereby not supporting compression. This directly implements the TLS 1.3 requirement that no compression methods be sent, matching the specification.'}}]","The function directly addresses the TLS 1.3 specification regarding compression by returning NULL, which means it does not offer any compression method. This is aligned with the spec stating that TLS 1.3 implementations MUST NOT send compression methods. No other action or condition is applicable within the limited scope of this function.",success,
12206,quic_app_data_pending,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function does not include any logic related to the RFC requirement of not offering or negotiating RC4 cipher suites (nor any ciphers with strength less than 112 bits). The function simply triggers a fatal error using QUIC_TLS_FATAL and does not inspect or configure TLS cipher suites. Therefore, it does not address any of the specified labeled conditions or actions.",success,
12206,quic_app_data_pending,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The function quic_app_data_pending does not implement any logic to enforce or check that Application Data is not sent prior to the Finished message (as required by the RFC and specified conditions). Instead, it unconditionally raises an error (via QUIC_TLS_FATAL) if the function is called, indicating that this function should not have been invoked. There is no code within the function that purposely implements the spec condition regarding the order of sending messages (i.e., ensuring that Finished is sent before any Application Data). Hence, the function does not address the specified TLS RFC constraint.",success,
12207,quic_get_max_record_overhead,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided code function does not incorporate any logic to implement the TLS RFC specification regarding the prohibition of RC4 cipher suites. The function solely triggers a fatal error (using QUIC_TLS_FATAL) and asserts a false condition, indicating it should not be called. There is no logic within this function that inspects or manipulates cipher suites (such as checking for RC4 or low strength ciphers) in any way. Therefore, none of the labeled conditions or actions (e.g., C1 regarding prohibiting RC4 cipher suites) are addressed within this function's body.",success,
12208,quic_increment_sequence_ctr,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The function explicitly aborts execution by calling QUIC_TLS_FATAL and ossl_assert(0), which does not implement or address any of the specified TLS RFC constraints (e.g., disallowing RC4 cipher suites). There is no logic in the function that attempts to negotiate, restrict, or influence cipher suite selection, let alone enforce the prohibition of RC4. Therefore, the function does not visibly address any of the conditions (C1, etc.) or actions (A1, etc.) specified in the TLS RFC.",success,
12214,raise_error,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function 'raise_error' is solely an error reporting mechanism that logs and tracks errors encountered during the TLS handshake. It does not contain any logic to address TLS cipher suite negotiation, specifically the requirement to not offer or negotiate RC4 cipher suites as mandated by the RFC. There is no check or decision-making related to the selection or exclusion of RC4 or any cipher suites, and thus no direct implementation of any condition (e.g., C1) or action (e.g., A1) from the spec constraints within this function.",success,
12215,ossl_quic_tls_configure,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function does not implement any logic that directly addresses the RFC6091 requirement prohibiting the use of the OpenPGP certificate type with TLS 1.3. While the function enforces the use of TLS 1.3 by setting it as the minimum protocol version, it does not check, restrict, or manipulate the certificate type to ensure that the OpenPGP certificate type is not used. No part of the function examines or validates certificate entries against the OpenPGP type, so none of the spec constraints (labeled conditions or actions) is visibly implemented in this function.",success,
12221,ossl_quic_tls_set_early_data_enabled,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Partially Matches,"[{'C1': {'code': 'if (!enabled) {\n    sc->max_early_data = 0;\n    sc->early_data_state = SSL_EARLY_DATA_NONE;\n    return 1;\n}\n\n... \n\nif ((sc->session == NULL || sc->session->ext.max_early_data != 0xffffffff) && sc->psk_use_session_cb == NULL)\n    return 0;', 'explanation': ""This code ensures that 0-RTT is not enabled unless the application explicitly requests it (i.e., the 'enabled' parameter is true) and the necessary client session conditions are met. This addresses the requirement of not enabling 0-RTT by default unless requested by the application.""}}]","The function implements logic to enable or disable 0-RTT data based on an explicit request from the application (through the 'enabled' parameter) and appropriate session conditions. This partially meets the spec that mandates 0-RTT should only be enabled when specifically requested. However, there is no logic within this function to handle the case where 0-RTT data is rejected by the server (e.g., automatically resending 0-RTT data), which is also required by the spec. Therefore, the function only partially matches the provided TLS RFC constraints.",success,
12221,ossl_quic_tls_set_early_data_enabled,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The TLS RFC requires that early data not be automatically retransmitted unless the negotiated connection selects the same ALPN protocol. In this function, while there is logic to enable or disable early data (by setting flags such as max_early_data and early_data_state), there is no visible check on the ALPN protocol or any mechanism that prevents automatic retransmission based on the connection's ALPN selection. The function only adjusts early data state and does not implement logic to decide about retransmission or verify that the ALPN protocol is consistent. Therefore, within the function_body itself no labeled condition or action from the specification (for example, conditions/actions corresponding to the ALPN check or retransmission control) is fully implemented.",success,
12310,el_setup_keyslot,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Partially Matches,"[{'A1': {'code': 'if (!tls13_hkdf_expand_ex(el->libctx, el->propq,\n                              el->md,\n                              secret,\n                              quic_v1_iv_label,\n                              sizeof(quic_v1_iv_label),\n                              NULL, 0,\n                              el->iv[keyslot], iv_len, 1))\n    ...\n    if (!tls13_hkdf_expand_ex(el->libctx, el->propq,\n                              el->md,\n                              secret,\n                              quic_v1_key_label,\n                              sizeof(quic_v1_key_label),\n                              NULL, 0,\n                              key, key_len, 1))', 'explanation': 'The function directly calls tls13_hkdf_expand_ex twice to derive the IV and key from the provided secret. This use of HKDF-Expand ensures that the secret (which is assumed to be the output of a prior HKDF-Extract) is only used after an HKDF-Expand call, thus addressing the RFC requirement that an HKDF-Extract output should not be reused without an intervening HKDF-Expand.'}}]","The TLS specification requires that the output of HKDF-Extract must only be used after an HKDF-Expand, and the function implements HKDF-Expand steps for deriving necessary keys. However, the function does not perform any HKDF-Extract operation itself—it merely assumes that the provided secret is already appropriately derived. Hence, while the function visibly enforces the ordering of using HKDF-Expand after extraction by not reusing the secret directly, it only partially fulfills the specification’s constraints on HKDF usage within its own isolated logic.",success,
12311,ossl_qrl_enc_level_set_provide_secret,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Partially Matches,"[{'A1': {'code': 'if (!tls13_hkdf_expand_ex(libctx, propq,\n                              md,\n                              secret,\n                              quic_v1_hp_label,\n                              sizeof(quic_v1_hp_label),\n                              NULL, 0,\n                              hpr_key, hpr_key_len, 1))\n            goto err;', 'explanation': 'This segment calls the HKDF-Expand function to derive the header protection key. It shows that the code uses an expansion step, which is the correct technique following an extraction (even though the extract isn’t performed in this function).'}}, {'A2': {'code': 'if (!tls13_hkdf_expand_ex(libctx, propq,\n                              md,\n                              secret,\n                              quic_v1_ku_label,\n                              sizeof(quic_v1_ku_label),\n                              NULL, 0,\n                              is_tx ? el->ku : ku_key, secret_len, 1))\n            goto err;\n\n... and later ...\n\nif (!tls13_hkdf_expand_ex(libctx, propq,\n                              md,\n                              ku_key,\n                              quic_v1_ku_label,\n                              sizeof(quic_v1_ku_label),\n                              NULL, 0,\n                              el->ku, secret_len, 1))\n            goto err;', 'explanation': ""This code uses HKDF-Expand to derive the keying material for the QUIC 'ku' keys and then advances the key epoch by re-expanding the previously derived key. It thereby avoids chaining HKDF-Extract calls without an intervening expansion, in line with the ordering requirement.""}}]","The RFC requirement states that each HKDF-Extract should be followed by one or more HKDF-Expand invocations and that one SHOULD NOT feed the output of an HKDF-Extract into another HKDF-Extract without an expansion in between. In this function, key derivation is achieved solely via calls to tls13_hkdf_expand_ex (i.e. performing HKDF-Expand). Although the function does not perform any HKDF-Extract operations itself — it accepts a pre‐derived secret as input — it nonetheless avoids the problematic chaining of extraction calls by using expansion for every key derivation step. As a result, while the extraction part is not visible (and is presumably done elsewhere), the function does visibly implement the expansion part of the ordering. This means that the function only partially implements the entire extraction–expansion ordering requirement as defined by the RFC.",success,
12312,ossl_qrl_enc_level_set_key_update,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Does Not Match,[],"The provided function implements a key update routine by calling tls13_hkdf_expand_ex to derive a new key, but it does not contain any logic related to the ordering constraint specified in the RFC. The RFC requires that every HKDF-Extract application is followed by one or more HKDF-Expand invocations and specifically prohibits using the output of an HKDF-Extract as input to another HKDF-Extract without an HKDF-Expand in between. In this function, no HKDF-Extract is performed and hence no check or ordering mechanism is present that enforces or prevents consecutive HKDF-Extract calls. Thus, within the scope of this function, there is no visible evidence of addressing the specific TLS RFC constraint regarding the ordering of HKDF-Extract and HKDF-Expand.",success,
12314,ossl_qrl_enc_level_set_key_cooldown_done,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Partially Matches,"[{'A1': {'code': 'if (!tls13_hkdf_expand_ex(el->libctx, el->propq,\n                              el->md,\n                              el->ku,\n                              quic_v1_ku_label,\n                              sizeof(quic_v1_ku_label),\n                              NULL, 0,\n                              new_ku, secret_len, 1)) {', 'explanation': 'The function derives the next key value by calling tls13_hkdf_expand_ex, which implements an HKDF-Expand operation. This aligns with the spec requirement that an HKDF-Extract output must be followed by an HKDF-Expand before any reuse. Note that the function does not perform any HKDF-Extract itself, but by using a dedicated HKDF-Expand call it avoids the forbidden chaining of extracts.'}}]","The provided function uses tls13_hkdf_expand_ex to derive a new key value from an existing key (presumably the result of a prior HKDF-Extract done elsewhere). This demonstrates an implementation of the action that an HKDF-Extract output is only used as input to an HKDF-Expand, thus partially addressing the ordering requirement as stated in the RFC specification. However, since the function does not itself invoke any HKDF-Extract calls or manage multiple sequential extractions, it only partially implements the overall constraint described in the spec.",success,
12440,quic_raise_non_normal_error,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, quic_raise_non_normal_error, is solely an error handling routine that sets error states and logs debug information. It does not contain any logic related to negotiating cipher suites, nor does it implement any checks or restrictions concerning the RC4 cipher suite (or any cipher strength requirements) as specified in the RFC. Therefore, within its own body, the function does not address any of the labeled spec constraints (e.g., the prohibition of RC4 negotiation) and does not implement any actions related to those requirements.",success,
12457,ossl_quic_new,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function does not include any logic that addresses the restriction specified by the TLS RFC regarding the OpenPGP certificate type usage (i.e., it does not check nor restrict the use of the OpenPGP certificate type with TLS 1.3). There is no code segment within this function that verifies or rejects the use of an OpenPGP certificate, and thus it does not implement any condition or action corresponding to the spec constraint.",success,
12532,ossl_quic_write_flags,"Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure.",283,Partially Matches,"[{'C1': {'code': 'if (len == 0) {\n        /* Do not autocreate default XSO for zero-length writes. */\n        if (!expect_quic_cs(s, &ctx))\n            return 0;\n\n        qctx_lock_for_io(&ctx);\n    }\n    ...\n    if (len == 0) {\n        if ((flags & SSL_WRITE_FLAG_CONCLUDE) != 0)\n            quic_post_write(ctx.xso, 0, 1, flags,\n                            qctx_should_autotick(&ctx));\n\n        ret = 1;\n        goto out;\n    }', 'explanation': 'The function explicitly checks for a zero-length write (len == 0) and processes it along a dedicated code path. This handling avoids autocreation of a default stream object (XSO) and later, if a flag is present, it posts a write with zero bytes. This behavior visibly supports the TLS RFC requirement that permits sending zero-length Application Data fragments as a traffic analysis countermeasure.'}}]","The function contains dedicated logic to handle zero-length writes, which corresponds to the TLS RFC provision allowing zero-length Application Data fragments. However, the RFC's other constraints, such as those concerning the fragmentation of alert messages, are not addressed by this function. Therefore, this implementation only partially matches the spec constraints by visibly addressing the zero-length fragment aspect.",success,
12585,ossl_quic_new_from_listener,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided TLS RFC specification requires that the OpenPGP certificate type (RFC6091) MUST NOT be used with TLS 1.3. In the function body, there is no visible logic that checks for or prevents the use of the OpenPGP certificate type. The code is primarily concerned with setting up a new QUIC connection, managing tokens, and initializing various SSL/QUIC structures, but it does not implement any conditions or actions (such as checking for certificate type, or limiting the certificate_list contents) that directly relate to the specified RFC constraint. Thus, the function does not address the labeled condition or action regarding OpenPGP certificate type usage.",success,
13150,ossl_qtx_calculate_ciphertext_payload_len,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The function ossl_qtx_calculate_ciphertext_payload_len simply calculates the ciphertext length by adding the plaintext length and the tag length, as obtained from ossl_qrl_get_suite_cipher_tag_len. It does not incorporate any logic to enforce the TLS RFC constraints specified, such as prohibiting the use of the Truncated HMAC extension or ensuring that record versions are at least 0x0300. No part of this function addresses those conditions or actions defined in the spec, and therefore, it does not match the required TLS RFC implementation constraints.",success,
13153,qtx_encrypt_into_txe,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The TLS RFC constraint provided states that implementations MUST NOT use the Truncated HMAC extension (among other requirements regarding record versions). In the function_body, the encryption is performed using an AEAD cipher (with EVP_CIPHER_CTX_ctrl used to retrieve the tag), and there is no explicit logic to check for or disable the truncated HMAC extension. Likewise, there is no visible handling for record version checks (i.e. ensuring that no records with a version less than 0x0300 are sent or accepted). Although the function uses an AEAD encryption strategy (which by design does not involve a truncated HMAC), it does not visibly implement or enforce the specific TLS RFC constraints detailed in the specification context. Therefore, the function does not visibly address any of the labeled TLS conditions or actions within its own code.",success,
13435,ossl_quic_provide_initial_secret,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Fully Matches,"[{'C1': {'code': '/* Derive initial secret from destination connection ID. */\nif (!ossl_quic_hkdf_extract(libctx, propq,\n                            sha256,\n                            quic_v1_initial_salt,\n                            sizeof(quic_v1_initial_salt),\n                            dst_conn_id->id,\n                            dst_conn_id->id_len,\n                            initial_secret,\n                            sizeof(initial_secret)))\n    goto err;\n\n/* Derive ""client in"" secret. */\nif (((qtx != NULL && tx_secret == client_initial_secret)\n     || (qrx != NULL && rx_secret == client_initial_secret))\n    && !tls13_hkdf_expand_ex(libctx, propq,\n                             sha256,\n                             initial_secret,\n                             quic_client_in_label,\n                             sizeof(quic_client_in_label),\n                             NULL, 0,\n                             client_initial_secret,\n                             sizeof(client_initial_secret), 1))\n    goto err;\n\n/* Derive ""server in"" secret. */\nif (((qtx != NULL && tx_secret == server_initial_secret)\n     || (qrx != NULL && rx_secret == server_initial_secret))\n    && !tls13_hkdf_expand_ex(libctx, propq,\n                             sha256,\n                             initial_secret,\n                             quic_server_in_label,\n                             sizeof(quic_server_in_label),\n                             NULL, 0,\n                             server_initial_secret,\n                             sizeof(server_initial_secret), 1))\n    goto err;', 'explanation': 'The function first derives an initial secret using HKDF-Extract and then applies HKDF-Expand separately for both client and server secrets. This strictly follows the TLS RFC requirement that an output from HKDF-Extract should not be fed into another HKDF-Extract without an intervening HKDF-Expand.'}}]","By isolating the HKDF operations within this function, the code conforms entirely to the TLS RFC ordering constraint. The initial extraction (HKDF-Extract) is immediately followed by expansion (HKDF-Expand) for both client and server secrets, ensuring that the prescribed ordering is maintained. No further or misordered use of HKDF-Extract is present, so the implementation fully meets the specified constraint.",success,
13839,dtls_get_message_body,An implementation may receive an unencrypted record of type change_cipher_spec consisting of the single byte value 0x01 at any time after the first ClientHello message has been sent or received and before the peer's Finished message has been received and MUST simply drop it without further processing.,268,Partially Matches,"[{'A1': {'code': 'if (s->s3.tmp.message_type == SSL3_MT_CHANGE_CIPHER_SPEC) {\n    /* Nothing to be done */\n    goto end;\n}', 'explanation': ""This code segment detects when the TLS record type is change_cipher_spec and immediately jumps to the end of the function, thereby dropping the record without further processing. It addresses the RFC requirement to simply drop an unencrypted change_cipher_spec record. However, it does not verify that the record consists of the single byte 0x01 nor does it check that this occurs between the first ClientHello and before the peer's Finished message, so the implementation is only partial with respect to the full specification.""}}]","The function implements part of the RFC requirement by checking if the message type is change_cipher_spec and then bypassing further processing to 'drop' the record. This satisfies the basic action mandated by the RFC. However, since the function does not validate that the record's content is exactly the single byte 0x01 and does not enforce timing constraints (after first ClientHello and before the Finished message), its handling is only partial. Thus, while it visibly addresses one key aspect of the spec, it does not fully implement all the specified conditions and actions.",success,
13841,dtls1_preprocess_fragment,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if ((frag_off + frag_len) > msg_len || msg_len > dtls1_max_handshake_message_len(s)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_EXCESSIVE_MESSAGE_SIZE);\n    return 0;\n}', 'explanation': ""This code ensures that if the fragment parameters are inconsistent with the total message length (i.e. semantically invalid in this context), the connection is terminated with an 'illegal_parameter' alert.""}}, {'A1': {'code': 'else if (msg_len != s->d1->r_msg_hdr.msg_len) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_EXCESSIVE_MESSAGE_SIZE);\n    return 0;\n}', 'explanation': ""This check compares the message length of subsequent fragments against the expected length, terminating the connection with an 'illegal_parameter' alert if they differ.""}}]","The function performs sanity checks on the handshake message fragments and ensures that any violation (such as the fragment length exceeding the overall message or inconsistent message sizes among fragments) results in terminating the connection with an 'illegal_parameter' alert. This reflects part of the TLS RFC requirement to close a connection upon receiving a syntactically correct but semantically invalid message. However, it only addresses message fragment boundary issues and not other potential semantic errors (e.g., specific checks for invalid enums or DHE parameter issues), so it partially matches the spec constraint indicated.",success,
13842,dtls1_retrieve_buffered_fragment,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function dtls1_retrieve_buffered_fragment focuses on reassembling DTLS handshake fragments and handling retransmissions of the ClientHello in specific scenarios. There is no logic in this function that checks for early data retransmission based on the negotiated ALPN protocol or prevents automatic retransmission of early data, as specified in the TLS RFC. Therefore, this function does not attempt to implement the spec constraint regarding early data retransmission.",success,
13845,dtls_get_reassembled_message,"An implementation which receives any other change_cipher_spec value or which receives a protected change_cipher_spec record MUST abort the handshake with an ""unexpected_message"" alert.",269,Fully Matches,"[{'C1': {'code': 'if (recvd_type == SSL3_RT_CHANGE_CIPHER_SPEC) {\n    if (p[0] != SSL3_MT_CCS) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE,\n                 SSL_R_BAD_CHANGE_CIPHER_SPEC);\n        goto f_err;\n    }\n\n    s->init_num = readbytes - 1;\n    s->init_msg = s->init_buf->data + 1;\n    s->s3.tmp.message_type = SSL3_MT_CHANGE_CIPHER_SPEC;\n    s->s3.tmp.message_size = readbytes - 1;\n    *len = readbytes - 1;\n    return 1;\n}', 'explanation': 'This code explicitly checks if the record type is change_cipher_spec, then verifies that the first byte is the expected SSL3_MT_CCS (which represents the single valid value, 0x01). If it is not, it aborts the handshake by calling SSLfatal with an unexpected_message alert. This directly implements the RFC specification requirement that any change_cipher_spec record with an unexpected value must cause handshake termination.'}}]","The function contains explicit logic for processing change_cipher_spec records. It checks that the record contains only the expected single byte value and aborts with an unexpected_message alert if any other value is detected. This behavior meets the condition defined in the TLS RFC that any change_cipher_spec value other than the expected one or a protected change_cipher_spec record must result in aborting the handshake. The implementation in the function_body directly addresses this condition, hence fully matching the constraint.",success,
13845,dtls_get_reassembled_message,"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",272,Partially Matches,"[{'A1': {'code': 'if (recvd_type == SSL3_RT_CHANGE_CIPHER_SPEC) {\n        if (p[0] != SSL3_MT_CCS) {\n            SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_BAD_CHANGE_CIPHER_SPEC);\n            goto f_err;\n        }\n        \n        s->init_num = readbytes - 1;\n        s->init_msg = s->init_buf->data + 1;\n        s->s3.tmp.message_type = SSL3_MT_CHANGE_CIPHER_SPEC;\n        s->s3.tmp.message_size = readbytes - 1;\n        *len = readbytes - 1;\n        return 1;\n    }', 'explanation': ""This code segment checks for a CHANGE_CIPHER_SPEC record. If the record's single byte value is not equal to the expected SSL3_MT_CCS (i.e. 0x01), it aborts the handshake by calling SSLfatal with an 'unexpected_message' alert. This implements the RFC’s requirement to terminate the connection if an unexpected record (in this case, an unexpected change_cipher_spec value) is received.""}}, {'A1': {'code': 'if (readbytes != DTLS1_HM_HEADER_LENGTH) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);\n        goto f_err;\n    }', 'explanation': 'This segment further handles an abnormal situation in record processing by terminating with an unexpected_message alert when the handshake header is incomplete. It contributes toward the RFC requirement that unexpected or ill-formatted messages should lead to termination.'}}]","The RFC specifies that receipt of an unexpected record type must result in termination of the connection with an 'unexpected_message' alert. In this function, there is explicit handling of the change_cipher_spec record by validating its expected value and aborting via SSLfatal if the value is not as expected. Similarly, the function aborts when the handshake header length does not match the expected DTLS1_HM_HEADER_LENGTH, also invoking an unexpected_message alert. However, beyond the specific check for change_cipher_spec records (and incomplete handshake headers), the function assumes that records have already been appropriately identified (for example, by calling ssl_read_bytes with a handshake type) and does not contain explicit checks for all types of possibly unexpected record types. As such, while the code partially implements the RFC behavior in key cases, it does not comprehensively address every potential unexpected record type within this function alone.",success,
13845,dtls_get_reassembled_message,-Handshake messages MUST NOT be interleaved with other record types.,275,Fully Matches,"[{'C1': {'code': '/*\n     * We must have at least frag_len bytes left in the record to be read.\n     * Fragments must not span records.\n     */\n    if (frag_len > s->rlayer.tlsrecs[s->rlayer.curr_rec].length) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_LENGTH);\n        goto f_err;\n    }', 'explanation': 'This code explicitly checks that the handshake fragment does not exceed the current record’s length, thereby ensuring that a handshake message fragment is fully contained within a single record. Since the function only processes data from records of the handshake type (with the exception of a permitted CCS record), it prevents interleaving of handshake messages with other record types as required by the specification.'}}]","The function dtls_get_reassembled_message is dedicated to reading and reassembling TLS handshake messages. It calls the lower-level ssl_read_bytes function with the handshake record type and incorporates a check (along with a descriptive comment) to ensure that the fragment does not cross a record boundary. This effectively prevents interleaving of handshake messages with any other record types, which fulfills the spec constraint that handshake messages must not be interleaved with other record types. All enforcement is done within the function itself, independent of its dependencies.",success,
13845,dtls_get_reassembled_message,An implementation may receive an unencrypted record of type change_cipher_spec consisting of the single byte value 0x01 at any time after the first ClientHello message has been sent or received and before the peer's Finished message has been received and MUST simply drop it without further processing.,268,Partially Matches,"[{'C1': {'code': 'if (recvd_type == SSL3_RT_CHANGE_CIPHER_SPEC) {\n    if (p[0] != SSL3_MT_CCS) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_BAD_CHANGE_CIPHER_SPEC);\n        goto f_err;\n    }\n\n    s->init_num = readbytes - 1;\n    s->init_msg = s->init_buf->data + 1;\n    s->s3.tmp.message_type = SSL3_MT_CHANGE_CIPHER_SPEC;\n    s->s3.tmp.message_size = readbytes - 1;\n    *len = readbytes - 1;\n    return 1;\n}', 'explanation': ""This code segment checks if the incoming record is of type change_cipher_spec and then verifies that the message content consists of the expected single byte (0x01). If the byte does not match, it triggers an error. This behavior addresses the RFC constraint regarding receiving a change_cipher_spec record with a valid content byte. However, instead of 'simply dropping' the record as mandated, the code passes it along (returning a non-zero length and setting handshake message fields), which only partially aligns with the specification.""}}]","The TLS RFC requires that an unencrypted change_cipher_spec record (with the single byte 0x01) be accepted at a specific point in the handshake and then simply dropped without further processing. The function contains logic to identify such a record and to verify the content byte, triggering an error if the value is incorrect. However, instead of dropping the message, it processes the record further and returns it. Thus, the function partially implements the RFC: it checks the required conditions (C1) but does not completely follow the mandated action (dropping the record) as prescribed by the spec.",success,
13845,dtls_get_reassembled_message,"That is, if a handshake message is split over two or more records, there MUST NOT be any other records between them.",276,Partially Matches,"[{'C1': {'code': 'i = ssl->method->ssl_read_bytes(ssl, SSL3_RT_HANDSHAKE, &recvd_type, p, DTLS1_HM_HEADER_LENGTH, 0, &readbytes);\n...\nif (frag_len > s->rlayer.tlsrecs[s->rlayer.curr_rec].length) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_LENGTH);\n    goto f_err;\n}', 'explanation': ""The code attempts to enforce that handshake fragments do not span beyond the bounds of a single record by reading only handshake records and verifying the fragment length against the current record's length. This indirectly supports the RFC’s constraint that handshake messages should not be interleaved with other records. However, the function does not explicitly check that there are no intervening records between fragments when a message is split, and so only partially meets this requirement.""}}]","The dtls_get_reassembled_message function includes logic for reading a handshake record, parsing its header, and reassembling fragments. It ensures that a fragment’s length does not exceed the boundaries of the current record, which helps to keep handshake fragments within a single record. This addresses part of the TLS RFC's requirement (labeled here as C1) that handshake messages split over multiple records must not have other records interleaved. However, the code does not explicitly detect or prevent the arrival or processing of intervening non-handshake records between fragments. Thus, while the function shows some handling related to the spec, it does not fully enforce the condition on interleaving, leading to a 'Partially Matches' judgment.",success,
13845,dtls_get_reassembled_message,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (frag_len > s->rlayer.tlsrecs[s->rlayer.curr_rec].length) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_LENGTH);\n    goto f_err;\n}\n\n... \n\nif (readbytes != frag_len) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_LENGTH);\n    goto f_err;\n}', 'explanation': ""These code segments check for inconsistencies in the handshake fragment lengths. If the fragment length exceeds the record length or if the number of bytes read does not equal the expected fragment length, the function calls SSLfatal with an 'illegal_parameter' alert, thereby terminating the connection as required when a semantically invalid message is encountered.""}}]","The RFC requires that if a syntactically correct message is semantically invalid, the connection must be terminated with an 'illegal_parameter' alert. This function implements checks on fragment lengths and triggers an illegal_parameter alert when discrepancies are found. However, it only covers these specific validations (e.g., length mismatches) and does not demonstrate handling of other types of semantic errors (such as an invalid enum or DHE share of p-1). Thus, the implementation in this function only partially matches the full specification.",success,
13845,dtls_get_reassembled_message,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Fully Matches,"[{'C1': {'code': 'if (msg_hdr.seq != s->d1->handshake_read_seq) {\n    if (!s->server\n            || msg_hdr.seq != 0\n            || s->d1->handshake_read_seq != 1\n            || p[0] != SSL3_MT_CLIENT_HELLO\n            || s->statem.hand_state != DTLS_ST_SW_HELLO_VERIFY_REQUEST) {\n        *errtype = dtls1_process_out_of_seq_message(s, &msg_hdr);\n        return 0;\n    }\n    /* retransmitted ClientHello handling follows */\n    chretran = 1;\n}\n\nif (readbytes != DTLS1_HM_HEADER_LENGTH) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);\n    goto f_err;\n}', 'explanation': 'The function checks whether the incoming handshake message sequence (msg_hdr.seq) matches the expected sequence (s->d1->handshake_read_seq). If the order is unexpected and not a permitted retransmission (as for initial ClientHello), it triggers an abort by eventually calling SSLfatal with SSL_AD_UNEXPECTED_MESSAGE, thus enforcing the TLS RFC requirement regarding unexpected handshake messages.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_BAD_CHANGE_CIPHER_SPEC);\n\n...\n\nSSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);', 'explanation': 'Throughout the function, whenever an unexpected formatting or ordering is detected (for example, an incomplete handshake header or an improper Change Cipher Spec message), the function calls SSLfatal with the alert type SSL_AD_UNEXPECTED_MESSAGE to abort the handshake, as required by the spec.'}}]","The function dtls_get_reassembled_message addresses the TLS RFC requirement for handling unexpected handshake message order by explicitly checking the sequence of incoming handshake messages. It detects when the message order deviates from what is expected and responds by aborting the handshake with an 'unexpected_message' alert via calls to SSLfatal. This logic, implemented within the function itself, directly corresponds to the specified conditions and actions, therefore fully matching the constraint.",success,
13870,ossl_statem_server13_read_transition,"When the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message.",254,Partially Matches,"[{'C1': {'code': 'if (s->post_handshake_auth == SSL_PHA_REQUESTED) {', 'explanation': 'This check in the TLS_ST_OK state verifies if the client sent the post_handshake_auth extension, addressing the condition that permits the server to request client authentication after the handshake.'}}, {'A1': {'code': 'if (mt == SSL3_MT_CERTIFICATE) {\n    st->hand_state = TLS_ST_SR_CERT;\n    return 1;\n}', 'explanation': ""This code segment processes an incoming Certificate message, which is part of handling the client authentication response, in line with the server's request for authentication.""}}]","The function handles state transitions for various TLS 1.3 handshake scenarios. In particular, the branch under TLS_ST_OK that checks 's->post_handshake_auth == SSL_PHA_REQUESTED' and then accepts a Certificate message implements part of the TLS RFC requirement related to post-handshake authentication. However, it only partially meets the spec constraints because it is focused on processing the response from the client rather than fully managing the entire sequence (e.g., sending the CertificateRequest message or enforcing that the client's consecutive messages are received without interruption). Thus, while it visibly addresses some of the labeled conditions (such as C1) and actions (such as A1), it does not fully implement all aspects of the RFC requirement within this function.",success,
13870,ossl_statem_server13_read_transition,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function is involved solely in transitioning the handshake state on the server side. While it does handle early data states (e.g., TLS_ST_EARLY_DATA), it does not implement any logic regarding the automatic retransmission decision for early data. In particular, it does not check or enforce that early data should only be automatically resent if the negotiated connection selects the same ALPN protocol, nor does it include any conditional logic to prevent or allow retransmission based on the RFC requirements. Therefore, within this function's scope, there is no visible implementation that addresses the TLS RFC constraint regarding automatic resending of early data.",success,
13871,ossl_statem_server_read_transition,"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",272,Fully Matches,"[{'C1': {'code': ""...\nerr:\n    /* No valid transition found */\n    if (SSL_CONNECTION_IS_DTLS(s) && mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n        BIO *rbio;\n\n        /*\n         * CCS messages don't have a message sequence number so this is probably\n         * because of an out-of-order CCS. We'll just drop it.\n         */\n        s->init_num = 0;\n        s->rwstate = SSL_READING;\n        rbio = SSL_get_rbio(SSL_CONNECTION_GET_SSL(s));\n        BIO_clear_retry_flags(rbio);\n        BIO_set_retry_read(rbio);\n        return 0;\n    }\n    SSLfatal(s, SSL3_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);\n    return 0;"", 'explanation': ""When no valid state transition is found (i.e. an unexpected record type is received), the function calls SSLfatal with the alert 'unexpected_message'. This directly enforces the RFC requirement to terminate the connection with an 'unexpected_message' alert.""}}]","The function implements a state machine for processing TLS messages. If a message type does not match any expected state transition, the default error path is reached, which calls SSLfatal with the unexpected_message alert. This behavior fully satisfies the TLS RFC specification that requires termination upon receiving an unexpected record type.",success,
13871,ossl_statem_server_read_transition,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The RFC specification mandates that SSL 2.0 must not be negotiated and that SSL2 compatible CLIENT-HELLO messages must neither be sent nor accepted. The provided function, ossl_statem_server_read_transition, only processes handshake state transitions for TLS 1.3 and SSL3/TLS1.x handshakes. There is no visible logic that checks for an SSL2 compatible CLIENT-HELLO or explicitly rejects SSL2 handshakes. Thus, the function does not implement the spec constraint regarding SSL 2.0.",success,
13871,ossl_statem_server_read_transition,"If an implementation detects a change_cipher_spec record received before the first ClientHello message or after the peer's Finished message, it MUST be treated as an unexpected record type (though stateless servers may not be able to distinguish these cases from allowed cases).",270,Fully Matches,"[{'C1': {'code': 'case TLS_ST_BEFORE:\n    ...\n    if (mt == SSL3_MT_CLIENT_HELLO) {\n        st->hand_state = TLS_ST_SR_CLNT_HELLO;\n        return 1;\n    }\n    break;\n...\nerr:\n    SSLfatal(s, SSL3_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);\n    return 0;', 'explanation': 'The RFC requires that a change_cipher_spec record arriving before the first ClientHello (or after the peer’s Finished message) be treated as an unexpected record type. In the code, when in the TLS_ST_BEFORE state only a ClientHello is accepted. Any other message—including a change_cipher_spec—falls through to the error handling section which calls SSLfatal with an unexpected_message alert. This directly addresses the condition.'}}, {'A1': {'code': '#ifdef SSL_CONNECTION_IS_DTLS(s) && mt == SSL3_MT_CHANGE_CIPHER_SPEC\n        BIO_clear_retry_flags(rbio);\n        BIO_set_retry_read(rbio);\n        return 0;\n#endif\n\nSSLfatal(s, SSL3_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);\nreturn 0;', 'explanation': 'If a change_cipher_spec record is received in an unexpected context (including DTLS out‐of‐order CCS), the code either drops the record (for DTLS) or terminates the handshake with an unexpected_message alert. This fulfills the action specified in the RFC.'}}]","The function implements a state machine that only accepts a change_cipher_spec record in specific handshake states. In the initial state (TLS_ST_BEFORE), it only accepts a ClientHello; any change_cipher_spec record at that point leads to an error via SSLfatal. Similarly, after the peer’s Finished message no valid branch accepts CCS. These in–function checks directly implement the RFC requirement to treat out–of–sequence change_cipher_spec records as unexpected. Hence, within this function the constraint from the RFC is fully addressed.",success,
13871,ossl_statem_server_read_transition,The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2).,186,Partially Matches,"[{'C1': {'code': 'else if (s->s3.tmp.cert_request) {\n            if (mt == SSL3_MT_CERTIFICATE) {\n                st->hand_state = TLS_ST_SR_CERT;\n                return 1;\n            }\n        }', 'explanation': 'This branch checks whether a CertificateRequest was issued (via s->s3.tmp.cert_request) and, if so, requires that the next message type is a Certificate message (SSL3_MT_CERTIFICATE) before transitioning to the TLS_ST_SR_CERT state. This reflects the spec’s requirement that the client must send a Certificate when the server requested client authentication.'}}, {'A1': {'code': 'if (mt == SSL3_MT_CLIENT_KEY_EXCHANGE) {\n            if (s->s3.tmp.cert_request) {\n                if (s->version == SSL3_VERSION) {\n                    if ((s->verify_mode & SSL_VERIFY_PEER)\n                        && (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) {\n                        SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE,\n                                 SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\n                        return 0;\n                    }\n                    st->hand_state = TLS_ST_SR_KEY_EXCH;\n                    return 1;\n                }\n            } else {\n                st->hand_state = TLS_ST_SR_KEY_EXCH;\n                return 1;\n            }\n        }', 'explanation': 'In the case of SSL3, when a CertificateRequest was issued, a client sending a Client Key Exchange message (instead of a Certificate) triggers a check: if the verification mode requires a certificate then an error is raised. This enforces the requirement in SSL3 that a certificate must be provided when requested.'}}]","The function implements state transitions based on whether client authentication was requested (indicated by s->s3.tmp.cert_request). It explicitly permits a Certificate message only if such a request exists and, in the SSL3 case, raises an error if the client sends a Client Key Exchange without a certificate when one is required. However, it does not fully implement all aspects of the RFC requirement (for example, handling the TLS1.0+ behavior where an empty Certificate message must be sent if no suitable certificate is available). As a result, while it visibly addresses some of the conditions and actions from the spec constraints, it only partially matches the full RFC requirement.",success,
13871,ossl_statem_server_read_transition,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Fully Matches,"[{'C1': {'code': 'if (/* none of the expected state cases match */) {\n    SSLfatal(s, SSL3_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);\n    return 0;\n}', 'explanation': 'The function’s state machine checks the incoming handshake message type (mt) against the expected ones for each handshake state. If none match (i.e., the message is received out of order), the execution eventually flows to the err block where the unexpected message is handled.'}}, {'A1': {'code': 'SSLfatal(s, SSL3_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);', 'explanation': ""This call aborts the handshake and generates an alert labeled 'unexpected_message', directly satisfying the specified action of aborting the handshake when an unexpected handshake message is received.""}}]","The provided function implements a state machine that verifies the order of handshake messages. For each state, it explicitly checks if the incoming message type is expected. If not, the function ultimately executes a call to SSLfatal with SSL3_AD_UNEXPECTED_MESSAGE, thus aborting the handshake with an 'unexpected_message' alert, which fully matches the specified TLS RFC requirement.",success,
13871,ossl_statem_server_read_transition,"In particular, it MUST NOT negotiate TLS 1.3.",14,Does Not Match,[],"The RFC explicitly requires that a server MUST NOT negotiate TLS 1.3 – in particular, if TLS 1.3 was negotiated or a TLS 1.3 ClientHello is received at an inappropriate time (such as during renegotiation), the connection must be terminated with an ""unexpected_message"" alert or must retain the previous protocol version. In this function, the only indication of TLS 1.3 handling is the check for SSL_CONNECTION_IS_TLS13(s), which delegates processing to ossl_statem_server13_read_transition(s, mt). However, there is no visible logic within this function to detect or specifically handle a TLS 1.3 ClientHello in a renegotiation situation on a connection originally established with a previous version. Thus, the function does not itself implement the specific constraint described in the specification.",success,
13874,send_certificate_request,"Servers which are authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, though they MAY send it in post-handshake authentication (see Section 4.6.2) provided that the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6).",184,Fully Matches,"[{'C1': {'code': '&& !(s->s3.tmp.new_cipher->algorithm_auth & SSL_aPSK)', 'explanation': ""This code segment explicitly verifies that if the cipher's authentication method includes PSK, the function will not proceed to send a CertificateRequest message during the main handshake, which directly complies with the RFC requirement.""}}]","The function 'send_certificate_request' contains checks that control whether or not a CertificateRequest message should be sent. In particular, the condition that excludes the case when the cipher suite uses PSK (via the '! (s->s3.tmp.new_cipher->algorithm_auth & SSL_aPSK)' clause) directly implements the RFC specification that a server authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake. Additionally, related checks for TLS 1.3 and post-handshake authentication further support the intended behavior, confirming that the function itself addresses the spec constraints as required.",success,
13874,send_certificate_request,"When the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message.",254,Partially Matches,"[{'C1': {'code': '(!SSL_CONNECTION_IS_TLS13(s) || !(s->verify_mode & SSL_VERIFY_POST_HANDSHAKE) || s->post_handshake_auth == SSL_PHA_REQUEST_PENDING)', 'explanation': ""This segment checks TLS version and the post‐handshake authentication flag. In TLSv1.3, it ensures that the SSL_VERIFY_POST_HANDSHAKE flag is set and that post-handshake auth is pending, which corresponds to the client's having offered the post_handshake_auth extension.""}}, {'A1': {'code': 'return 1;', 'explanation': 'Returning 1 indicates that a CertificateRequest should be sent, thereby performing the action of requesting client authentication as allowed by the spec.'}}]","The function 'send_certificate_request' examines several conditions – such as whether peer verification is enabled, the TLS version, and if post-handshake authentication is pending – before deciding to send a CertificateRequest by returning 1. These checks partially cover the spec constraint that the server may request client authentication after the handshake if the client has sent the post_handshake_auth extension. However, the function does not address all aspects of the RFC (for example, ensuring that all client response messages appear consecutively), and some conditions from the spec are likely handled elsewhere. Thus, the implementation in this function only partially matches the full requirements of the specification.",success,
13874,send_certificate_request,The server MAY send it in the CertificateRequest message.,106,Does Not Match,[],"The RFC specification allows the server to send the certificate_authorities extension within the CertificateRequest message. However, the provided function only evaluates conditions under which a certificate request should be sent, using fields like verify_mode, new_cipher properties, and various flags. There is no implementation logic within this function that constructs or includes the list of acceptable certificate authorities (i.e., the certificate_authorities extension) as described in the spec. Therefore, the function does not address the spec constraints directly within its code.",success,
13876,ossl_statem_server13_write_transition,"At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message.",238,Partially Matches,"[{'C1': {'code': 'case TLS_ST_SR_FINISHED:\n    s->ts_msg_read = ossl_time_now();\n    /* ... */\n    if (!s->ext.ticket_expected) {\n        st->hand_state = TLS_ST_OK;\n        return WRITE_TRAN_CONTINUE;\n    }\n    if (s->num_tickets > s->sent_tickets)\n        st->hand_state = TLS_ST_SW_SESSION_TICKET;\n    else\n        st->hand_state = TLS_ST_OK;\n    return WRITE_TRAN_CONTINUE;', 'explanation': 'This section of code is triggered after the client Finished has been processed and, based on the ticket expectations (s->ext.ticket_expected), it transitions to a state to send a NewSessionTicket. This reflects the RFC condition that a new session ticket may be sent after receiving the client Finished message.'}}, {'A1': {'code': ""case TLS_ST_SW_SESSION_TICKET:\n    /* In a resumption we only ever send a maximum of one new ticket.\n     * Following an initial handshake we send the number of tickets we have\n     * been configured for.\n     */\n    if (!SSL_IS_FIRST_HANDSHAKE(s) && s->ext.extra_tickets_expected > 0) {\n        return WRITE_TRAN_CONTINUE;\n    } else if (s->hit || s->num_tickets <= s->sent_tickets) {\n        /* We've written enough tickets out. */\n        st->hand_state = TLS_ST_OK;\n    }\n    return WRITE_TRAN_CONTINUE;"", 'explanation': 'This branch handles the state transition logic for sending NewSessionTicket messages. It checks whether extra tickets are expected and if the conditions for sending are met, mirroring the RFC’s allowance to send NewSessionTicket messages as needed.'}}]","The function implements part of the TLS RFC requirement by introducing state transitions that enable the server to send a NewSessionTicket message after processing the client Finished message. Specifically, in the TLS_ST_SR_FINISHED case it checks for the ticket expectation and then, if conditions are met, transitions to TLS_ST_SW_SESSION_TICKET, where the logic to send tickets is further delineated. However, not all aspects of ticket creation or the intricacies of the NewSessionTicket message are handled directly in this function, and some details may reside in other parts of the system. Therefore, the function partially matches the spec constraints as it visibly addresses the key condition and action in the state machine, albeit in a transitional manner.",success,
13876,ossl_statem_server13_write_transition,"Servers MAY send multiple tickets on a single connection, either immediately after each other or after specific events (see Appendix C.4).",240,Fully Matches,"[{'C1': {'code': 'if (s->ext.extra_tickets_expected > 0) {\n            st->hand_state = TLS_ST_SW_SESSION_TICKET;\n            return WRITE_TRAN_CONTINUE;\n        }', 'explanation': 'This segment (in the TLS_ST_OK state) checks if extra session tickets are expected and transitions to the state for sending session tickets, directly addressing the RFC requirement that a server may send multiple tickets.'}}, {'A1': {'code': 'case TLS_ST_SR_FINISHED:\n        ...\n        if (s->num_tickets > s->sent_tickets)\n            st->hand_state = TLS_ST_SW_SESSION_TICKET;\n        else\n            st->hand_state = TLS_ST_OK;', 'explanation': 'In the TLS_ST_SR_FINISHED state, after completing the handshake, the function checks whether additional tickets need to be sent and transitions to the session ticket state accordingly, in alignment with the RFC that allows sending multiple tickets immediately after or following specific events.'}}]","The function implements the session ticket state transitions by checking conditions related to extra tickets and the number of tickets already sent. In both the initial state (TLS_ST_OK) and after finishing the handshake (TLS_ST_SR_FINISHED), the code explicitly decides whether to transition to TLS_ST_SW_SESSION_TICKET, which is the state where new session tickets are sent. This visible, self-contained logic in the function fulfills the RFC specification requirement that a server may send multiple NewSessionTicket messages on a single connection, either consecutively or following particular events.",success,
13876,ossl_statem_server13_write_transition,"When the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message.",254,Partially Matches,"[{'C1': {'code': 'if (s->post_handshake_auth == SSL_PHA_REQUEST_PENDING) {\n    st->hand_state = TLS_ST_SW_CERT_REQ;\n    return WRITE_TRAN_CONTINUE;\n}', 'explanation': ""This code checks whether the client sent the 'post_handshake_auth' extension and, if true, transitions the handshake state to trigger sending a CertificateRequest message.""}}, {'A1': {'code': 'case TLS_ST_SW_CERT_REQ:\n    if (s->post_handshake_auth == SSL_PHA_REQUEST_PENDING) {\n        s->post_handshake_auth = SSL_PHA_REQUESTED;\n        st->hand_state = TLS_ST_OK;\n    } else if (do_compressed_cert(s)) {\n        st->hand_state = TLS_ST_SW_COMP_CERT;\n    } else {\n        st->hand_state = TLS_ST_SW_CERT;\n    }\n    return WRITE_TRAN_CONTINUE;', 'explanation': 'This segment completes the action of sending the CertificateRequest by updating the post-handshake authentication flag and transitioning the state, effectively initiating client authentication.'}}]","The function contains logic to detect if the client sent the 'post_handshake_auth' extension (C1) and, upon that condition, pivots the handshake state machine to send a CertificateRequest message (A1). This directly addresses the RFC's allowance for the server to request client authentication after the handshake. However, it does not handle the entire expected sequence (for instance, verifying the client's consecutive response messages), so the implementation only partially covers the complete specification.",success,
13876,ossl_statem_server13_write_transition,"When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message.",224,Partially Matches,"[{'C1': {'code': 'case TLS_ST_SW_CERT:\n        st->hand_state = TLS_ST_SW_CERT_VRFY;\n        return WRITE_TRAN_CONTINUE;\n\ncase TLS_ST_SW_COMP_CERT:\n    st->hand_state = TLS_ST_SW_CERT_VRFY;\n    return WRITE_TRAN_CONTINUE;', 'explanation': 'These code segments enforce that immediately after sending a Certificate (or a compressed certificate), the state machine moves to the CertificateVerify state (TLS_ST_SW_CERT_VRFY). This position is in between the Certificate and Finished states, addressing the RFC requirement that the CertificateVerify message must appear immediately after the Certificate message and immediately prior to the Finished message.'}}]","The provided function_body implements a state machine that transitions from sending the Certificate (or its compressed form) to a dedicated CertificateVerify state, and only then to the Finished state. This ordering in the handshake meets the condition (labeled C1) that the CertificateVerify message must immediately follow the Certificate. However, the function does not itself perform the message construction or transmission for CertificateVerify (an action that would be expected as part of fulfilling the full TLS RFC requirement), and any further protocol processing is handled elsewhere. Therefore, only part of the specification is addressed within this function.",success,
13876,ossl_statem_server13_write_transition,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function is responsible for transitioning through various TLS 1.3 handshake states on the server side. The RFC specification requires that Application Data MUST NOT be sent prior to sending the Finished message. However, within this function there is no explicit logic or state check that prevents the transmission of application data before the Finished message is sent. The function only handles the handshake state changes (e.g., transitioning from TLS_ST_SW_FINISHED to TLS_ST_EARLY_DATA and TLS_ST_OK) without enforcing the ordering of finished messages versus application data. Therefore, by itself, this function does not implement the specified TLS RFC constraint.",success,
13876,ossl_statem_server13_write_transition,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function_body is a state transition routine for the TLS handshake and does not contain any explicit logic that checks or enforces the TLS RFC requirement regarding early data retransmission. Specifically, the RFC states that a TLS implementation MUST NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol, meaning that the implementation should include a mechanism to verify the ALPN protocol before retransmitting early data. In the code, while there is a transition to the TLS_ST_EARLY_DATA state (for example, in the TLS_ST_SW_FINISHED and TLS_ST_SW_SRVR_HELLO cases), there is no check of the negotiated ALPN protocol or any logic that prevents retransmission of early data. Without any such ALPN verification or policy decision, the function does not address the constraint outlined in the RFC. The state transitions that lead to TLS_ST_EARLY_DATA do not constitute an implementation of the condition or action related to managing early data retransmission as defined in the spec.",success,
13876,ossl_statem_server13_write_transition,"In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message.",176,Partially Matches,"[{'C1': {'code': 'case TLS_ST_SW_SRVR_HELLO:\n    if ((s->options & SSL_OP_ENABLE_MIDDLEBOX_COMPAT) != 0\n            && s->hello_retry_request != SSL_HRR_COMPLETE)\n        st->hand_state = TLS_ST_SW_CHANGE;\n    else if (s->hello_retry_request == SSL_HRR_PENDING)\n        st->hand_state = TLS_ST_EARLY_DATA;\n    else\n        st->hand_state = TLS_ST_SW_ENCRYPTED_EXTENSIONS;\n    return WRITE_TRAN_CONTINUE;', 'explanation': ""The RFC requires that the EncryptedExtensions message be sent immediately after the ServerHello. In the normal path, the state machine transitions from TLS_ST_SW_SRVR_HELLO directly to TLS_ST_SW_ENCRYPTED_EXTENSIONS. However, alternate branches (e.g. middlebox compatibility or hello retry conditions) may alter this immediate transition. Thus, while the function sets up a state for sending EncryptedExtensions, it also allows deviations and does not fully enforce the 'immediate' ordering in every case.""}}]","The function implements part of the TLS 1.3 handshake state transitions by designating a state (TLS_ST_SW_ENCRYPTED_EXTENSIONS) that corresponds to sending the EncryptedExtensions message immediately after the ServerHello. However, because additional conditions (such as middlebox compatibility and hello retry) may modify the transition order, the function only partially matches the RFC specification constraint solely within its own logic.",success,
13876,ossl_statem_server13_write_transition,"This message, if sent, MUST follow EncryptedExtensions.",179,Fully Matches,"[{'C1': {'code': 'case TLS_ST_SW_ENCRYPTED_EXTENSIONS:\n    if (s->hit)\n        st->hand_state = TLS_ST_SW_FINISHED;\n    else if (send_certificate_request(s))\n        st->hand_state = TLS_ST_SW_CERT_REQ;\n    else if (do_compressed_cert(s))\n        st->hand_state = TLS_ST_SW_COMP_CERT;\n    else\n        st->hand_state = TLS_ST_SW_CERT;', 'explanation': 'The specification requires that if a certificate request message is sent, it must immediately follow EncryptedExtensions. In this code segment, immediately after the encrypted extensions state, the function checks if a certificate request should be sent via send_certificate_request(s) and then sets the state to TLS_ST_SW_CERT_REQ, ensuring the certificate request message follows EncryptedExtensions.'}}]","The function implements a TLS 1.3 server state machine where, during the transition from the EncryptedExtensions state, it explicitly checks for conditions to send a certificate request. This directly fulfills the specified requirement that the certificate request message, if sent, must follow EncryptedExtensions. All related logic is contained solely within this function, which means it fully matches the provided protocol specification.",success,
13877,ossl_statem_server_write_transition,The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK).,185,Partially Matches,"[{'C1': {'code': 'if (!(s->s3.tmp.new_cipher->algorithm_auth & (SSL_aNULL | SSL_aSRP | SSL_aPSK))) {\n    st->hand_state = TLS_ST_SW_CERT;\n}', 'explanation': 'This segment from the TLS_ST_SW_SRVR_HELLO case checks if the negotiated cipher uses certificate‐based authentication (i.e. it is not a PSK, anon DH/ECDH, or SRP mode) and, if so, transitions the handshake state to TLS_ST_SW_CERT. This indicates that the server will send a Certificate message when certificate authentication is required. However, the actual sending logic is implemented elsewhere, so only part of the RFC requirement is addressed within this function.'}}]","The provided function implements part of the TLS handshake state machine. Specifically, in the TLS_ST_SW_SRVR_HELLO case, it identifies when certificate-based authentication is used by checking the algorithm_auth flags and then transitions to a state (TLS_ST_SW_CERT) that is responsible for sending the Certificate message. This action corresponds to the requirement that the server must send a Certificate message when certificates are used for authentication. However, the function does not itself perform the actual transmission of the Certificate message; it only sets up the handshake state accordingly. Therefore, the code only partially matches the specified TLS RFC requirement.",success,
13877,ossl_statem_server_write_transition,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The function does not contain any visible logic that directly handles the TLS 1.3 requirement concerning the status_request_v2 extension. In the TLS 1.3 case, the function immediately defers to ossl_statem_server13_write_transition(s) without any check or decision related to status_request_v2. There is no code segment in this function that implements the condition or action (e.g., ignoring or not sending the status_request_v2 extension) as specified in the RFC. Hence, the function does not address the spec constraint by itself.",success,
13877,ossl_statem_server_write_transition,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The TLS specification requires that application data must not be sent prior to sending the Finished message. However, this function (ossl_statem_server_write_transition) only manages state transitions for the handshake process and does not include any logic that checks or enforces that application-level data is withheld until after the Finished message is sent. There is no code segment that directly addresses this requirement (e.g., to block application data), so the function does not appear to implement the specified RFC constraint within its own logic.",success,
13877,ossl_statem_server_write_transition,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The provided function does not contain any logic that addresses the specific TLS RFC requirement to ensure that the server does not send a ""psk_key_exchange_modes"" extension. There are no explicit checks or conditions related to ps_key_exchange_modes in the code segments of the function_body. All the state transitions and handshake management in the function pertain to other aspects of the TLS handshake, and no part of the code implements a restriction or prevention of sending the psk_key_exchange_modes extension. Therefore, within this function, the specified constraint is not met.",success,
13878,ossl_statem_server_pre_work,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function does not implement any specific checks or logic to prevent the automatic retransmission of early data as required by the RFC specification. Although there is a case for TLS_ST_EARLY_DATA that checks the state of early_data, it does not verify whether the negotiated connection's ALPN protocol matches the expected one before retransmission, nor does it prevent automatic retransmission. As a result, the function does not visibly address the TLS RFC condition that a TLS implementation SHOULD NOT automatically resend early data.",success,
13880,ossl_statem_server_post_work,"Upon receiving a KeyUpdate, the receiver MUST update its receiving keys.",263,Does Not Match,[],"The provided function, ossl_statem_server_post_work, includes a case for TLS_ST_SW_KEY_UPDATE that flushes the state and then calls tls13_update_key(s, 1). However, this implementation corresponds to handling a key update event on the sending side (i.e., after having sent a KeyUpdate message) rather than handling an incoming KeyUpdate. The RFC specification requires that upon receiving a KeyUpdate, the receiver must update its receiving keys. No part of the function demonstrates logic for processing an incoming KeyUpdate and updating the receiving keys accordingly. Therefore, within the function_body itself, the specified RFC constraint is not implemented.",success,
13880,ossl_statem_server_post_work,"Servers which are authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, though they MAY send it in post-handshake authentication (see Section 4.6.2) provided that the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6).",184,Does Not Match,[],"The provided function does handle various post-handshake work states, including those related to certificate requests (e.g. in TLS_ST_SW_CERT_REQ and TLS_ST_SW_ENCRYPTED_EXTENSIONS cases). However, it does not implement any logic that explicitly enforces the TLS RFC requirement that servers authenticating with a PSK must not send a CertificateRequest message in the main handshake and only send it in post‐handshake authentication when the client has sent the ""post_handshake_auth"" extension. There is no check for PSK usage or for ensuring that CertificateRequest is only sent post-handshake in the context of PSK authentication within this function. Therefore, none of the labeled conditions or actions from the specification (as represented by C1, A1, etc.) are directly addressed within this function_body.",success,
13880,ossl_statem_server_post_work,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function, ossl_statem_server_post_work, does not contain any specific logic to address the TLS 1.3 RFC requirement regarding the status_request_v2 extension. In the RFC, it is explicitly mandated that TLS 1.3 servers MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. In the function_body, there is no reference, conditional checks, or any code segments that handle or explicitly inhibit the sending of the status_request_v2 extension. All the state cases and actions relate to general handshake processing, key updates, and other transition states without any handling of that particular extension. As dependencies are irrelevant for this analysis, the function by itself does not implement the required spec constraints.",success,
13881,ossl_statem_server_construct_message,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function is responsible for constructing different TLS handshake messages based on the handshake state and does not contain any logic that checks or prevents the use of RC4 cipher suites or low strength ciphers. None of the code segments in this function address the RFC specification constraint that implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS. Therefore, the function does not visibly implement the specified constraint.",success,
13881,ossl_statem_server_construct_message,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function is a message constructor that selects a construction function and message type based on the handshake state. In the case for TLS_ST_EARLY_DATA, it sets the construction function to NULL and the message type to a dummy value, but it does not implement any logic to prevent automatic retransmission of early data nor does it enforce any check that the negotiated connection selects the same ALPN protocol. Therefore, it does not visibly address the TLS RFC constraint regarding not automatically resending early data as specified.",success,
13883,ossl_statem_server_process_message,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The code function is a dispatch routine that routes messages based on the handshake state, calling various helper functions (like tls_process_end_of_early_data) for specific handshake stages. There is no visible logic in this function that checks or prevents the automatic retransmission of early data based on the negotiated ALPN protocol, as required by the RFC specification. The function does not implement any condition (e.g., checking ALPN matches or preventing retransmission of early data) that corresponds to the spec constraint; such logic, if present, would have to be inside this function itself. Therefore, with respect to the provided TLS RFC constraint, no part of the function visibly addresses the condition, and it does not match the requirement.",success,
13887,dtls_construct_hello_verify_request,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest.",59,Does Not Match,[],"The function dtls_construct_hello_verify_request only handles generating and sending a Hello Verify Request with a cookie via a callback and packing that cookie into a message. It does not contain any logic that checks whether the remote endpoint sent an extension request or conditionally suppresses extension responses based on that. Therefore, in isolation, it does not attempt to implement the RFC constraint which mandates that extension responses should not be sent unless the corresponding extension request was received (except for the 'cookie' extension in HelloRetryRequest).",success,
13887,dtls_construct_hello_verify_request,"When sending a HelloRetryRequest, the server MAY provide a ""cookie"" extension to the client (this is an exception to the usual rule that the only extensions that may be sent are those that appear in the ClientHello).",77,Fully Matches,"[{'C1': {'code': 'if (sctx->app_gen_cookie_cb == NULL\n        || sctx->app_gen_cookie_cb(SSL_CONNECTION_GET_USER_SSL(s), s->d1->cookie,\n                                   &cookie_leni) == 0\n        || cookie_leni > DTLS1_COOKIE_LENGTH) {\n        SSLfatal(s, SSL_AD_NO_ALERT, SSL_R_COOKIE_GEN_CALLBACK_FAILURE);\n        return CON_FUNC_ERROR;\n    }\n    s->d1->cookie_len = cookie_leni;\n\n    if (!dtls_raw_hello_verify_request(pkt, s->d1->cookie,\n                                       s->d1->cookie_len)) {\n        SSLfatal(s, SSL_AD_NO_ALERT, ERR_R_INTERNAL_ERROR);\n        return CON_FUNC_ERROR;\n    }', 'explanation': 'The function verifies that a cookie generation callback exists and successfully generates a cookie with an acceptable length. It then incorporates this cookie into the HelloVerifyRequest by serializing the cookie extension into the packet. This directly addresses the RFC requirement for the server to include a cookie extension in a HelloRetryRequest.'}}]","The provided function implements the cookie extension in the construction of a HelloVerifyRequest by checking for a cookie callback, generating a cookie, ensuring it doesn't exceed the maximum length, and then adding it to the outgoing message. This meets the spec's requirement for optionally including a cookie extension without retaining state, thus fully matching the intended behavior as described in the RFC.",success,
13888,ssl_check_for_safari,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The code function 'ssl_check_for_safari' is focused on identifying a specific extension block typical of Safari clients by comparing the client hello extensions against a hard-coded block. It does not contain any logic that relates to the TLS 1.3 requirement regarding the status_request_v2 extension. In particular, it does not check for or act upon the presence of a status_request_v2 extension, nor does it implement any logic to prevent sending status_request_v2 in the EncryptedExtensions, CertificateRequest, or Certificate messages. Therefore, none of the labeled conditions or actions from the provided RFC specification are addressed within this function.",success,
13889,tls_process_client_hello,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function tls_process_client_hello is responsible for parsing and processing ClientHello messages. However, it does not contain any explicit logic that checks for or handles the status_request_v2 extension as detailed in the RFC specification. In particular, there is no code that conditionally excludes the presence of the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages for TLS 1.3. The function only collects all extensions and passes them along without filtering or special handling, so it does not visibly address the specified constraints.",success,
13889,tls_process_client_hello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2(pkt, &clienthello->legacy_version)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_TOO_SHORT);\n    goto err;\n}\n\n...\n\nif (!PACKET_get_length_prefixed_1(pkt, &session_id)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n\n...\n\nif (PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_RECORD_LENGTH_MISMATCH);\n    goto err;\n}', 'explanation': 'This code checks that when attempting to parse parts of the ClientHello message (such as legacy_version, session_id, and the remaining bytes in the packet) the appropriate boundaries are respected. When a parsing error is detected, it immediately calls SSLfatal with the decode_error alert, ensuring the connection is terminated as required by the spec.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_TOO_SHORT);\n...\nSSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n...\nSSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_RECORD_LENGTH_MISMATCH);', 'explanation': 'Multiple instances in the function use SSLfatal with an alert type of SSL_AD_DECODE_ERROR when parsing failures occur, thereby fulfilling the action to terminate the connection with a decode_error alert if the received message cannot be parsed correctly.'}}]","The function 'tls_process_client_hello' directly verifies the integrity of the ClientHello message by checking lengths and packet boundaries using various PACKET_* functions. In each case where an error is detected (for example, when the expected length is not met or extra bytes remain), the function calls SSLfatal with SSL_AD_DECODE_ERROR. This behavior fully implements the RFC specification requirement that a peer must terminate the connection with a decode_error alert when the message cannot be parsed according to its syntax.",success,
13889,tls_process_client_hello,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) == 0) {\n    PACKET_null_init(&clienthello->extensions);\n} else {\n    if (!PACKET_get_length_prefixed_2(pkt, &clienthello->extensions)\n            || PACKET_remaining(pkt) != 0) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n        goto err;\n    }\n}', 'explanation': 'This segment implements the condition that a TLS ClientHello must either have no data after the legacy_compression_methods field or a valid, well-formed extensions block with no extra bytes. This directly reflects the spec requirement to validate the presence and exact boundaries of the extensions field.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);', 'explanation': 'When the condition is not met (i.e. extra bytes remain after processing the extensions block, or the extensions block is malformed), this code aborts the handshake by signaling a decode_error alert, fulfilling the action requirement from the spec.'}}]","The function parses the ClientHello message and explicitly checks that if there are bytes following the compression_methods field, then they must form a valid extensions block with no extra data. If these conditions are not met, the function aborts the handshake with a decode_error alert. This logic is implemented directly within the function, thereby fully meeting the corresponding spec constraints.",success,
13889,tls_process_client_hello,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Partially Matches,"[{'C1': {'code': 'if (clienthello->isv2) {\n    if (!SSL_IS_FIRST_HANDSHAKE(s)\n            || s->hello_retry_request != SSL_HRR_NONE) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);\n        goto err;\n    }\n}', 'explanation': ""In the SSLv2 (backward‐compatible) branch the function explicitly checks if the ClientHello is received in an unexpected order (i.e. not the first handshake or not a proper retry) and aborts by calling SSLfatal with the 'unexpected_message' alert.""}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);', 'explanation': ""This call triggers the abort of the handshake by raising the 'unexpected_message' alert in the context of an out‐of‐order SSLv2 ClientHello, directly implementing the action required by the spec.""}}]","The TLS RFC requires that a handshake message received in an unexpected order must result in aborting the handshake with an 'unexpected_message' alert. Within the function, in the branch handling SSLv2 backward‐compatible ClientHello messages, the code checks if the message is unexpected and then calls SSLfatal with SSL_AD_UNEXPECTED_MESSAGE. This partially meets the specification. However, for the non-SSLv2 (regular TLS) path the function does not explicitly check for unexpected message ordering in the same manner—it instead handles renegotiation scenarios differently (e.g. by sending a NO_RENEGOTIATION alert). Thus, while the function does implement the required behavior in one case (SSLv2), it does not fully cover all cases outlined in the RFC, leading to a partial match overall.",success,
13890,tls_early_post_process_client_hello,"Implementations MUST verify that all messages immediately preceding a key change align with a record boundary; if not, then they MUST terminate the connection with an ""unexpected_message"" alert.",278,Partially Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)\n    && RECORD_LAYER_processed_read_pending(&s->rlayer)) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n    goto err;\n}', 'explanation': ""This code segment checks for TLSv1.3 that the ClientHello message ends exactly at a record boundary. If not, it terminates the connection with an 'unexpected_message' alert. This addresses the part of the spec that mandates messages immediately preceding a key change (or handshake boundary in TLSv1.3) must align with a record boundary.""}}]","The function contains logic for TLSv1.3 to verify that a ClientHello message does not have extra pending data that would indicate it spans multiple records. This directly implements a check aligning with the spec's requirement about record boundaries immediately preceding key changes. However, the spec also covers other handshake messages and scenarios (such as ensuring no interleaving of record types and messages spanning key changes), but this function only addresses the ClientHello case. Therefore, it partially matches the overall spec constraint.",success,
13890,tls_early_post_process_client_hello,"Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages can immediately precede a key change, implementations MUST send these messages in alignment with a record boundary.",279,Partially Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)\n        && RECORD_LAYER_processed_read_pending(&s->rlayer)) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n        goto err;\n    }', 'explanation': 'This segment enforces that the TLSv1.3 ClientHello message must be received on a record boundary by checking that there is no pending read data, which aligns with the RFC requirement for ClientHello messages preceding a key change.'}}]","The function includes logic that checks the record boundary for the ClientHello message in TLSv1.3, which addresses one part of the RFC specification regarding the alignment of certain handshake messages (specifically the ClientHello). However, it does not implement similar checks for other messages mentioned in the RFC (such as EndOfEarlyData, ServerHello, Finished, or KeyUpdate); hence, the function only partially matches the provided constraints.",success,
13890,tls_early_post_process_client_hello,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The TLS RFC specification requires that TLS 1.3 servers must not act upon or send the status_request_v2 extension in certain messages. In the provided code function, there is no explicit handling or checking for the status_request_v2 extension in the ClientHello or in any subsequent message construction. Although the function parses extensions from the ClientHello (using tls_parse_extension and tls_parse_all_extensions), it does not contain any code that specifically verifies, ignores, or drops the status_request_v2 extension as required by the spec. Therefore, none of the labeled conditions or actions (such as C1 or A1, if they were defined for this constraint) are met within this function.",success,
13890,tls_early_post_process_client_hello,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Does Not Match,[],"The TLS RFC specification requires that SSL 3.0 MUST NOT be negotiated and that ciphers with strength less than 112 bits MUST NOT be offered or negotiated. The function 'tls_early_post_process_client_hello' does perform several checks related to version and cipher processing, but it does not explicitly check or enforce the disallowance of SSL 3.0 nor does it verify the strength of the proposed ciphers. Although version selection and error handling occur in this function, there is no visible code segment that prevents the negotiation of SSL 3.0 or the use of weak ciphers based solely on the logic within this function. Therefore, in isolation, the function does not implement the specified TLS RFC requirements.",success,
13890,tls_early_post_process_client_hello,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Partially Matches,"[{'C1': {'code': 'if (clienthello->isv2) {\n    if (clienthello->legacy_version == SSL2_VERSION\n            || (clienthello->legacy_version & 0xff00) != (SSL3_VERSION_MAJOR << 8)) {\n        SSLfatal(s, SSL_AD_PROTOCOL_VERSION, SSL_R_UNKNOWN_PROTOCOL);\n        goto err;\n    }\n    s->client_version = clienthello->legacy_version;\n}', 'explanation': 'This segment verifies whether the ClientHello is of type SSLv2. If it is, and if the legacy version equals SSL2_VERSION (or does not match the expected pattern for SSLv3/TLS), the function terminates the handshake with an error. This implements the RFC requirement that SSL 2.0 (SSL2) must not be negotiated.'}}]","The function contains code that explicitly checks for and rejects SSLv2 ClientHello messages, satisfying the key requirement in the RFC specification that SSL2 must not be negotiated. However, while this condition (labeled C1) is enforced within the function, other aspects of the TLS specification context (such as not sending an SSLv2-compatible ClientHello for TLS1.3 or later) are not addressed in this function's logic. As a result, the code function partially matches the overall spec constraints by addressing some, but not all, of the required conditions.",success,
13890,tls_early_post_process_client_hello,Implementations MUST NOT negotiate TLS 1.3 or later using an SSL version 2.0 compatible CLIENT-HELLO.,394,Partially Matches,[],"The provided function does include logic handling SSLv2-compatible ClientHello messages – for example, it checks if clienthello->isv2 is set and rejects messages where clienthello->legacy_version is exactly SSL2_VERSION or has a non-SSL3 major version. However, the specific RFC mandate to “MUST NOT negotiate TLS 1.3 or later using an SSL version 2.0 compatible CLIENT-HELLO” is not explicitly enforced within this function. Although it processes the SSLv2 case, it simply sets s->client_version based on clienthello->legacy_version and does not explicitly abort if that version could lead to TLS 1.3 negotiation. Hence, the function only partially addresses the constraint because it handles some aspects of SSLv2 messages but does not explicitly forbid the negotiation of TLS 1.3 or later when the ClientHello is SSLv2-compatible.",success,
13890,tls_early_post_process_client_hello,"Any endpoint receiving a Hello message with ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 MUST abort the handshake with a ""protocol_version"" alert.",396,Does Not Match,[],"The TLS RFC constraint requires that if a Hello message is received with a legacy_version set to 0x0300, the handshake must be aborted with a protocol_version alert. In the provided code function, the only explicit check on legacy_version occurs inside the clienthello->isv2 block, which aborts the handshake if clienthello->legacy_version equals SSL2_VERSION or if its top byte does not match (SSL3_VERSION_MAJOR << 8). For a non-SSLv2 ClientHello (i.e. when clienthello->isv2 is false), there is no explicit check to abort the handshake when legacy_version is exactly 0x0300. Therefore, the function does not visibly implement the specific requirement from the RFC.",success,
13890,tls_early_post_process_client_hello,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (s->hello_retry_request == SSL_HRR_PENDING && (s->s3.tmp.new_cipher == NULL || s->s3.tmp.new_cipher->id != cipher->id)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_CIPHER);\n    goto err;\n}', 'explanation': ""This code segment enforces that if a previously chosen cipher (via HRR) does not match the subsequently selected cipher, the connection is terminated with an 'illegal_parameter' alert.""}}, {'A1': {'code': 'if (memchr(clienthello->compressions, 0, clienthello->compressions_len) == NULL) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_REQUIRED_COMPRESSION_ALGORITHM_MISSING);\n    goto err;\n}', 'explanation': ""This check ensures that a NULL compression method is present. If not, the function terminates with an 'illegal_parameter' alert, aligning with the spec requirement to reject semantically invalid messages.""}}, {'A1': {'code': 'if (clienthello->compressions_len != 1) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INVALID_COMPRESSION_ALGORITHM);\n    goto err;\n}', 'explanation': ""In TLSv1.3, only a single (NULL) compression method is permitted. This segment verifies that condition and issues an 'illegal_parameter' alert if it fails.""}}]","The RFC specifies that a semantically invalid message should cause the connection to be terminated with an 'illegal_parameter' alert. The function implements checks that, when detecting semantic errors (such as an unexpected cipher selection or invalid compression algorithms), call SSLfatal with the SSL_AD_ILLEGAL_PARAMETER alert. This shows that the function addresses the action of terminating the connection with an 'illegal_parameter' alert for certain conditions. However, it does not explicitly handle all semantic anomalies mentioned in the RFC (for example, a DHE share of p -1 or an invalid enum) solely within its own logic. Thus, while it partially implements the spec constraints by checking and terminating on several semantic errors, it does not cover the full range of potential semantically invalid conditions defined by the RFC.",success,
13890,tls_early_post_process_client_hello,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data.",320,Fully Matches,"[{'C1': {'code': 'if (protverr) {\n    if (SSL_IS_FIRST_HANDSHAKE(s)) {\n        s->version = s->client_version = clienthello->legacy_version;\n    }\n    SSLfatal(s, SSL_AD_PROTOCOL_VERSION, protverr);\n    goto err;\n}\n\n... (similar error-checking blocks for other conditions, e.g., SCSV misuse, cookie mismatch, etc.)', 'explanation': 'The function checks for various fatal error conditions (e.g., protocol version errors, fallback errors, cookie mismatches, missing compression, etc.) and immediately jumps to an error cleanup block when any such condition is met. This aligns with the spec’s requirement to detect fatal errors.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_PROTOCOL_VERSION, SSL_R_UNKNOWN_PROTOCOL);\n...\nSSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_COOKIE_MISMATCH);\n...\nSSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n...\nSSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_REQUIRED_COMPRESSION_ALGORITHM_MISSING);\n', 'explanation': 'Upon detecting any fatal error condition, the function calls SSLfatal with an appropriate alert code and error reason. After invoking SSLfatal, the function releases resources and returns immediately, which prevents further data transmission or reception, as required by the spec.'}}]","The function tls_early_post_process_client_hello visibly implements the TLS RFC’s error-handling behavior. It checks for several fatal error conditions and, when detected, it calls SSLfatal with the correct alert parameters and then aborts further processing by cleaning up and returning an error. This inline approach to detect errors, send alerts, and then terminate the handshake meets the requirement that upon a fatal error, an appropriate alert is sent and the connection is terminated without further data exchange.",success,
13890,tls_early_post_process_client_hello,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6).",10,Fully Matches,"[{'C1': {'code': 'if (cipher == NULL) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_NO_SHARED_CIPHER);\n    goto err;\n}\n\n...\n\nif (j == 0) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_REQUIRED_CIPHER_MISSING);\n    goto err;\n}\n\nif (clienthello->compressions_len == 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_NO_COMPRESSION_SPECIFIED);\n    goto err;\n}\n\nif (memchr(clienthello->compressions, 0, clienthello->compressions_len) == NULL) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_REQUIRED_COMPRESSION_ALGORITHM_MISSING);\n    goto err;\n}', 'explanation': 'The code checks for situations where there is no overlap between client and server parameters (e.g. no shared cipher or missing required compression method). In each case, it aborts the handshake using a fatal alert (such as handshake_failure or illegal_parameter), which satisfies the spec requirement.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_NO_SHARED_CIPHER);\n...\nSSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_REQUIRED_CIPHER_MISSING);', 'explanation': 'These invocations of SSLfatal are examples where the function explicitly aborts the handshake with a fatal alert when required parameters cannot be negotiated, thereby implementing the action mandated by the RFC.'}}]","The function processes the ClientHello message and includes multiple checks to ensure that a mutually supported set of parameters exists. When it detects that no common parameters (such as cipher suites or compression methods) are negotiated, it aborts the handshake with a fatal alert (using alerts like handshake_failure or illegal_parameter) in line with the RFC specification. All the relevant logic is contained within this function, thereby fully matching the requirements.",success,
13890,tls_early_post_process_client_hello,"For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS.",22,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)) {\n    if (clienthello->compressions_len != 1) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INVALID_COMPRESSION_ALGORITHM);\n        goto err;\n    }\n}', 'explanation': 'The TLS 1.3 ClientHello specification requires that the legacy_compression_methods vector contains exactly one byte and that it is set to zero. The code first checks the length and then, earlier in the function, it verifies the presence of the null (0) compression method with memchr. Together, these checks ensure that the vector meets the TLS 1.3 specification.'}}]","The function explicitly verifies that for TLS 1.3 connections, the legacy_compression_methods field provided in the ClientHello message contains exactly one byte, and it ensures that the null compression method (value 0) is present. This directly addresses the TLS 1.3 requirement, thereby fully matching the spec constraint.",success,
13890,tls_early_post_process_client_hello,"If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST abort the handshake with an ""illegal_parameter"" alert.",23,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)) {\n    if (clienthello->compressions_len != 1) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INVALID_COMPRESSION_ALGORITHM);\n        goto err;\n    }\n}', 'explanation': 'This code segment checks that for a TLS 1.3 ClientHello the legacy_compression_methods field contains exactly one value, as required by the spec.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INVALID_COMPRESSION_ALGORITHM);', 'explanation': ""By calling SSLfatal with SSL_AD_ILLEGAL_PARAMETER, the function aborts the handshake with an 'illegal_parameter' alert when the compression field does not meet the TLS 1.3 requirement.""}}]","The function_body directly implements the TLS 1.3 requirement regarding the legacy_compression_methods field. It first ensures that at least one compression method is provided and that NULL is present, and then explicitly checks that for TLS 1.3 the field has exactly one byte. If the condition is not met, it aborts the handshake with the appropriate 'illegal_parameter' alert. Thus, the code fully addresses the specified constraint.",success,
13890,tls_early_post_process_client_hello,Note that TLS 1.3 servers might receive TLS 1.2 or prior ClientHellos which contain other compression methods and (if negotiating such a prior version) MUST follow the procedures for the appropriate prior version of TLS.,24,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)) {\n    if (clienthello->compressions_len != 1) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER,\n                 SSL_R_INVALID_COMPRESSION_ALGORITHM);\n        goto err;\n    }\n}', 'explanation': 'This segment verifies that for a TLS 1.3 ClientHello the legacy_compression_methods vector contains exactly one byte. It aborts the handshake using an illegal_parameter alert if the condition is not met, which is consistent with the TLS 1.3 specification.'}}]","The function directly addresses the TLS specification regarding legacy compression methods by ensuring that a TLS 1.3 ClientHello presents exactly one byte (which must be 0). This check correctly enforces the requirement that any other value leads to an abortion of the handshake with an 'illegal_parameter' alert. As a result, the code function visibly meets the specified condition.",success,
13890,tls_early_post_process_client_hello,Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.,66,Does Not Match,[],"The provided TLS RFC specification requires that the server MAY abort the handshake if it receives a ClientHello with legacy_version 0x0304 or later. Within the function, there is no explicit check or logic that inspects the clienthello->legacy_version to determine if it is 0x0304 or later and then aborts the handshake accordingly. The version selection logic defers to the ssl_choose_server_version() function without directly enforcing the behavior specified in the RFC for legacy_version 0x0304. Thus, based solely on the function_body, this function does not visibly implement the required check for the legacy_version condition. Note that while the function processes many aspects of the ClientHello, no part of the code enforces the specific condition (here labeled as, for example, C1 or A1) to abort the handshake if legacy_version is 0x0304 or later.",success,
13891,tls_handle_status_request,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Fully Matches,"[{'A1': {'code': 'case SSL_TLSEXT_ERR_ALERT_FATAL:\ndefault:\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_CLIENTHELLO_TLSEXT);\n    return 0;', 'explanation': 'When the callback indicates a fatal error (either explicitly via SSL_TLSEXT_ERR_ALERT_FATAL or via any unspecified value in the default case), the function immediately calls SSLfatal with a specific alert (SSL_AD_INTERNAL_ERROR) and returns 0. This clearly implements the requirement to abort the handshake (or terminate the connection) with an X alert, fulfilling the RFC specification that mandates sending an alert on error.'}}]","Within the function, the error-handling branch that invokes SSLfatal ensures that if a fatal error occurs during status request processing, an alert is sent and the connection is meant to be terminated. This matches the RFC requirement that if an error is detected the implementation MUST send a fatal alert (with the specified alert code) and then close the connection immediately. Although the actual connection closure may be handled elsewhere, the function itself visibly implements the necessary alert-sending logic as specified.",success,
13891,tls_handle_status_request,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Partially Matches,"[{'A1': {'code': 'case SSL_TLSEXT_ERR_ALERT_FATAL:\n            default:\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_CLIENTHELLO_TLSEXT);\n                return 0;', 'explanation': 'The function detects an error condition from the status callback return value and, in the error branch, calls SSLfatal to send a fatal alert. This action corresponds to the specification requirement to send an appropriate fatal alert when a fatal error is detected.'}}]","The function partially meets the TLS RFC error handling requirements as described in the specification context. It checks for an error condition from the external status callback and, upon detection of a fatal error (or any unexpected return value), it triggers an error-handling mechanism by calling SSLfatal, which sends a fatal alert. However, while this covers the requirement to send an appropriate fatal alert (A1), additional aspects such as the explicit closure of the connection and further logging mechanisms are either handled elsewhere or not explicitly addressed in this function alone. Thus, the code function only partially implements the complete error-handling spec as required.",success,
13892,tls_handle_alpn,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'A1': {'code': ""if (s->session->ext.alpn_selected == NULL\n            || selected_len != s->session->ext.alpn_selected_len\n            || memcmp(selected, s->session->ext.alpn_selected, selected_len) != 0) {\n    /* Not consistent so can't be used for early_data */\n    s->ext.early_data_ok = 0;\n\n    if (!s->hit) {\n        ...\n    }\n}"", 'explanation': 'This block checks the consistency between the newly selected ALPN protocol and the session’s ALPN. If they differ (or if none exists), it disables early data retransmission by setting s->ext.early_data_ok to 0, fulfilling the RFC requirement that early data shouldn’t be automatically resent unless the ALPN protocols match.'}}, {'A2': {'code': ""if (s->session->ext.alpn_selected != NULL) {\n    /* Not consistent so can't be used for early_data */\n    s->ext.early_data_ok = 0;\n}"", 'explanation': 'In the case where no ALPN selection callback is provided, the function still checks if a session ALPN is present and disables early data by setting s->ext.early_data_ok to 0. This ensures that early data is not auto-resent when ALPN information is involved, in line with the RFC policy.'}}]","The function 'tls_handle_alpn' explicitly verifies ALPN consistency by comparing the selected ALPN protocol (obtained from the application via a callback) with the ALPN stored in the session. In both code paths—the one executing after a successful ALPN selection callback and the fallback when no callback is present—it disables automatic early data retransmission (via s->ext.early_data_ok = 0) when the protocols do not match. This directly implements the RFC requirement that a TLS implementation MUST NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol. All relevant logic is contained within the function, fulfilling the specified constraints.",success,
13893,tls_post_process_client_hello,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Partially Matches,"[{'A1': {'code': 'if (rv == 0) {\n    /* SSLfatal() was already called */\n    goto err;\n}\n\nif (!s->hit && s->cert->cert_cb != NULL) {\n    int rv = s->cert->cert_cb(ussl, s->cert->cert_cb_arg);\n\n    if (rv == 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_CERT_CB_ERROR);\n        goto err;\n    }\n    ...\n}', 'explanation': 'When an error is detected during the certificate callback, the function calls SSLfatal() with an internal error alert (SSL_AD_INTERNAL_ERROR), then jumps to the error handling label. This addresses the spec requirement to send an appropriate fatal alert upon a fatal error.'}}, {'A2': {'code': 'if (!SSL_CONNECTION_IS_TLS13(s)) {\n    cipher = ssl3_choose_cipher(s, s->peer_ciphers, SSL_get_ciphers(ssl));\n\n    if (cipher == NULL) {\n        SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_NO_SHARED_CIPHER);\n        goto err;\n    }\n    s->s3.tmp.new_cipher = cipher;\n}\n', 'explanation': 'This segment checks for a valid cipher during handshake. When no shared cipher is found, SSLfatal() is called with a handshake failure alert (SSL_AD_HANDSHAKE_FAILURE) and then aborts processing. This follows the RFC directive for aborting the handshake with a specific alert on error.'}}]","The tls_post_process_client_hello function contains error handling branches that directly invoke SSLfatal() with specific alert codes when critical errors (like certificate callback failures or lack of a shared cipher) are encountered. This is in line with the TLS RFC requirement that upon detecting a fatal error, an appropriate alert should be sent and the connection terminated. However, not every possible error condition or all aspects of TLS error handling are addressed entirely within this function; some logic (e.g., connection closure, logging of alerts) may be deferred to dependencies. Thus, the function partially implements the spec constraints on error handling by itself.",success,
13893,tls_post_process_client_hello,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'C1': {'code': 'if (!s->hit && s->cert->cert_cb != NULL) {\n    int rv = s->cert->cert_cb(ussl, s->cert->cert_cb_arg);\n\n    if (rv == 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_CERT_CB_ERROR);\n        goto err;\n    }\n    ...\n}', 'explanation': 'This segment checks for a fatal condition from the certificate callback and calls SSLfatal with SSL_AD_INTERNAL_ERROR before aborting using goto err, fulfilling the requirement to send an explicit alert on a fatal error.'}}, {'A1': {'code': 'if (cipher == NULL) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_NO_SHARED_CIPHER);\n    goto err;\n}', 'explanation': 'On failing to negotiate a shared cipher, the function calls SSLfatal with SSL_AD_HANDSHAKE_FAILURE, ensuring that an explicit alert is sent, as required by the spec for terminating the connection with a specific alert.'}}]","The function includes visible logic to detect error conditions and issues calls to SSLfatal with specific alert codes—thus attempting to implement the behavior specified in the TLS RFC, which mandates that on encountering a fatal error the implementation MUST send the corresponding alert. However, not all error handling (for instance, connection closure itself) is managed within this function (some behavior is delegated to other functions or the caller), so only some of the spec constraints are directly addressed here. Therefore, the implementation in this function only partially matches the specification.",success,
13893,tls_post_process_client_hello,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function does not contain any explicit logic that checks for, ignores, or avoids processing the status_request_v2 extension as mandated by the TLS 1.3 specification. Although the function calls tls_handle_status_request(s), there is no visible distinction in the code between status_request and status_request_v2, nor is there any logic that prevents the server from sending the status_request_v2 extension in EncryptedExtensions, CertificateRequest, or Certificate messages. This behavior may be handled elsewhere, but within the confines of this function, the spec constraint is not addressed.",success,
13893,tls_post_process_client_hello,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6).",10,Partially Matches,"[{'C1': {'code': 'if (cipher == NULL) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_NO_SHARED_CIPHER);\n    goto err;\n}', 'explanation': 'This segment checks if no shared cipher (i.e. no overlapping parameters) is negotiated and aborts the handshake by raising a handshake_failure fatal alert, addressing the requirement for aborting when parameter negotiation fails.'}}]","The function implements a key part of the specification: it aborts the handshake when there is no overlap in supported parameters through cipher negotiation (as seen in the non‐TLS 1.3 branch). However, it only handles this error condition for cipher selection and does not address other potential negotiation failures (such as those relating to TLS 1.3 or the alternative 'insufficient_security' alert) explicitly within its own logic. Therefore, while it does address one important aspect of the specification, it only partially matches the overall constraints.",success,
13894,tls_construct_server_hello,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The function body provided is responsible for constructing a ServerHello message and does not include any visible logic to either process or explicitly drop the status_request_v2 extension as required by the TLS 1.3 RFC. The RFC stipulates that TLS 1.3 servers MUST NOT send the status_request_v2 extension in EncryptedExtensions, CertificateRequest, or Certificate messages. However, this function does not contain any code related to processing status_request_v2; it only focuses on constructing core fields such as version, random, session ID, compression method, and then delegates extension construction via a call to tls_construct_extensions without checking for or filtering out the status_request_v2 extension. Since there is no specific logic within this function that matches or enforces the described spec constraints (labeled conditions or actions), the function does not address the requirement.",success,
13894,tls_construct_server_hello,"A client MUST provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension.",136,Does Not Match,[],"The specified TLS RFC requirement states that a client MUST provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension. The provided function, tls_construct_server_hello, is solely responsible for constructing the ServerHello message and does not contain any logic that checks or verifies if the client provided a ""psk_key_exchange_modes"" extension. There is no code segment within this function that addresses the condition of verifying or enforcing the presence of the ""psk_key_exchange_modes"" extension on the client side when a ""pre_shared_key"" extension is offered. As such, the function does not meet any of the labeled requirements from the spec constraints.",success,
13894,tls_construct_server_hello,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The TLS RFC specification requires that the server MUST NOT send a ""psk_key_exchange_modes"" extension. In the provided function_body, there is no explicit logic that checks for or excludes the ""psk_key_exchange_modes"" extension. The function delegates extension handling to tls_construct_extensions() based solely on the handshake type (e.g., TLS1_3_SERVER_HELLO or TLS1_2_SERVER_HELLO) without any explicit measures to prevent the inclusion of the ""psk_key_exchange_modes"" extension. Therefore, this function does not visibly address the specified constraint within its own logic.",success,
13894,tls_construct_server_hello,Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less.,395,Does Not Match,[],"The TLS specification requires that the legacy_version field in the ServerHello (or ClientHello) must never be set to a value of 0x0300 or less. In the provided function, the legacy version value is determined by the expression 'version = usetls13 ? TLS1_2_VERSION : s->version'. When TLS 1.3 is used, the hard-coded value TLS1_2_VERSION (typically 0x0303) is sent, which is compliant. However, for non-TLS 1.3 connections, the function simply writes 's->version' with no check to ensure that it is greater than 0x0300. There is no logic in the function that verifies or enforces that s->version is not less than or equal to 0x0300. Because the function does not independently implement any check to prevent sending an invalid legacy_version, it does not meet the specified TLS RFC constraint within its own scope.",success,
13894,tls_construct_server_hello,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function 'tls_construct_server_hello' does not contain any visible logic that implements the spec constraint regarding the prohibition of the Truncated HMAC extension. The code is concerned with constructing the ServerHello message (setting version, random, session ID, compression method, and extensions) but it does not check for or explicitly avoid usage of the Truncated HMAC extension. Thus, within the scope of the function itself, there is no attempt to implement the TLS RFC specification that mandates not using the Truncated HMAC extension.",success,
13894,tls_construct_server_hello,"In order to maximize backward compatibility, a record containing an initial ClientHello SHOULD have version 0x0301 (reflecting TLS 1.0) and a record containing a second ClientHello or a ServerHello MUST have version 0x0303 (reflecting TLS 1.2).",289,Partially Matches,"[{'C2': {'code': 'version = usetls13 ? TLS1_2_VERSION : s->version;\nif (!WPACKET_put_bytes_u16(pkt, version)\n           /* ... */', 'explanation': 'For TLS1.3 (or hello retry request) cases the function explicitly sets the version to TLS1_2_VERSION (i.e. 0x0303), which matches the RFC requirement that a ServerHello (or second ClientHello) MUST use version 0x0303. However, in non‐TLS1.3 cases it simply uses s->version without verifying that it equals 0x0303, relying on external configuration.'}}]","The function implements part of the RFC requirement by ensuring that in TLS1.3 or hello retry scenarios the version is set to 0x0303 (using TLS1_2_VERSION). This covers the case for a ServerHello as specified. However, when not in TLS1.3 mode it simply writes out s->version, which is not explicitly enforced to be 0x0303 as required. Therefore, while some of the condition (here labeled as C2 for ServerHello version) is handled within this function, the implementation does not fully cover all cases solely relying on this function's logic.",success,
13894,tls_construct_server_hello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The provided code function constructs a ServerHello message by writing the version, random, session ID, cipher, compression method, and then delegating extension construction to tls_construct_extensions. However, none of the code in this function explicitly addresses the TLS RFC requirement that ""pre_shared_key"" be the last extension in a ClientHello. Since the requirement applies to the ordering of extensions in ClientHello messages (and in ServerHello messages the placement is less strict), and since any handling of extension ordering is deferred to the tls_construct_extensions function (a dependency), this function does not directly check or enforce the pre_shared_key ordering constraint. Thus, the function does not visibly implement any labeled spec condition or action regarding extension ordering.",success,
13894,tls_construct_server_hello,"In TLS 1.3, the client indicates its version preferences in the ""supported_versions"" extension (Section 4.2.1) and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.",15,Fully Matches,"[{'C1': {'code': 'version = usetls13 ? TLS1_2_VERSION : s->version;\nif (!WPACKET_put_bytes_u16(pkt, version) ...', 'explanation': 'For TLS 1.3 (when usetls13 is true), the code sets the legacy_version field to TLS1_2_VERSION (which is 0x0303) and then writes it into the packet. This directly fulfills the requirement from the RFC that legacy_version MUST be set to 0x0303 in TLS 1.3.'}}, {'A1': {'code': 'tls_construct_extensions(s, pkt,\n                          s->hello_retry_request == SSL_HRR_PENDING\n                              ? SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST\n                              : (SSL_CONNECTION_IS_TLS13(s)\n                                  ? SSL_EXT_TLS1_3_SERVER_HELLO\n                                  : SSL_EXT_TLS1_2_SERVER_HELLO),\n                          NULL, 0)', 'explanation': ""This segment ensures that for TLS 1.3 connections the supported_versions extension (and corresponding server hello extension) is constructed accordingly, supporting the RFC's approach to indicating version preferences in TLS 1.3.""}}]","The function explicitly checks whether the connection is using TLS 1.3 (or a HelloRetryRequest) and then sets the 'legacy_version' field to TLS1_2_VERSION (0x0303) when needed. Furthermore, it constructs the appropriate extensions, including the supported_versions extension necessary for TLS 1.3. Taken together, these implementations within the function address the TLS RFC requirement as specified.",success,
13894,tls_construct_server_hello,"For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS.",22,Fully Matches,"[{'C1': {'code': 'if (usetls13 || s->s3.tmp.new_compression == NULL)\n    compm = 0;\nelse\n    compm = s->s3.tmp.new_compression->id;\n...\nif (!WPACKET_put_bytes_u8(pkt, compm)) {', 'explanation': 'The TLS RFC requires that for TLS 1.3 (both in ClientHello and ServerHello, by extension of legacy fields) the compression method vector be exactly one byte set to 0. In this function, when TLS1.3 is in use (or when the new_compression pointer is NULL), compm is explicitly set to 0. Subsequently, the function writes this single byte to the packet with WPACKET_put_bytes_u8. This directly implements the requirement described in the spec.'}}]","Within the tls_construct_server_hello function, the compression method is conditionally set to 0 when TLS 1.3 is in effect. This ensures that the legacy compression method field is exactly one byte with a value of zero, complying with the TLS RFC requirement. The function alone (independent of its dependencies) visibly addresses this condition, so the implementation fully matches the specified constraint.",success,
13894,tls_construct_server_hello,"This extension, if provided by the server, MUST only be sent in the CertificateRequest message.",107,Does Not Match,[],"The TLS RFC specification requires that the 'oid_filters' extension (which deals with client's certificate matching criteria) MUST only be sent in the CertificateRequest message. This function, tls_construct_server_hello, constructs a ServerHello message and does not contain any logic to handle or avoid sending the 'oid_filters' extension. In fact, it only constructs extensions related to ServerHello (either TLS1.2 or TLS1.3 extensions) via tls_construct_extensions, with no reference to any certificate request specific extensions. Therefore, there is no visible implementation in this function that attempts to enforce the restriction mandated by the RFC specification.",success,
13894,tls_construct_server_hello,Servers MUST NOT send this extension.,115,Fully Matches,"[{'C1': {'code': 'if (!tls_construct_extensions(s, pkt,\n                                  s->hello_retry_request == SSL_HRR_PENDING\n                                      ? SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST\n                                      : (SSL_CONNECTION_IS_TLS13(s)\n                                          ? SSL_EXT_TLS1_3_SERVER_HELLO\n                                          : SSL_EXT_TLS1_2_SERVER_HELLO),\n                                  NULL, 0)) {\n        /* SSLfatal() already called */\n        return CON_FUNC_ERROR;\n    }', 'explanation': 'The function calls tls_construct_extensions with extension types that are specific to ServerHello (or HelloRetryRequest) messages and does not attempt to add the post_handshake_auth extension. Thus, it ensures that the server does not send the prohibited extension.'}}]","The specification states that servers MUST NOT send the post_handshake_auth extension. In the function tls_construct_server_hello, the only extensions built are those for TLS1.2/1.3 ServerHello or HelloRetryRequest, with no logic to include the post_handshake_auth extension. This indicates that the function complies with the constraint by design.",success,
13896,tls_construct_server_key_exchange,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, tls_construct_server_key_exchange, is responsible for constructing the ServerKeyExchange message based on the negotiated key exchange mechanism (e.g., DHE, ECDHE, SRP, etc.). It does not contain any logic that checks for, prohibits, or filters out RC4 cipher suites. The RFC specification explicitly mandates that implementations MUST NOT offer or negotiate RC4 cipher suites, but this function does not address RC4 at all—instead, it focuses on key exchange parameter construction. Therefore, in isolation, this function does not implement any of the constraints (such as those labeled C1 or A1) regarding RC4 prohibition.",success,
13897,tls_construct_certificate_request,"Implementations which have the same policy in both cases MAY omit the ""signature_algorithms_cert"" extension.",85,Fully Matches,"[{'C1': {'code': 'if (SSL_USE_SIGALGS(s)) {\n    ...\n    if (!WPACKET_start_sub_packet_u16(pkt)\n            || !WPACKET_set_flags(pkt, WPACKET_FLAGS_NON_ZERO_LENGTH)\n            || !tls12_copy_sigalgs(s, pkt, psigs, nl)\n            || !WPACKET_close(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return CON_FUNC_ERROR;\n    }\n}', 'explanation': ""The RFC permits omitting the 'signature_algorithms_cert' extension when the same policy applies, in which case the 'signature_algorithms' extension is used in both contexts. In the TLS 1.2 branch the function checks if signature algorithms should be used and then calls tls12_copy_sigalgs to add the 'signature_algorithms' extension. This implies that the separate certificate-specific extension is omitted in accordance with the spec. Similarly, in the TLS 1.3 branch no extra certificate-specific extension is added. Thus the function visibly implements the allowed omission.""}}]","The function constructs the certificate request message according to TLS version. For TLS 1.2, it explicitly adds the 'signature_algorithms' extension when required and omits a separate 'signature_algorithms_cert' extension, which is permitted by the RFC when the signature policies for certificates and CertificateVerify messages are the same. For TLS 1.3, the function similarly does not add a separate certificate-specific extension. Therefore, by itself, the function fully addresses the RFC requirement that implementations may omit the 'signature_algorithms_cert' extension.",success,
13897,tls_construct_certificate_request,"When the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message.",254,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)) {\n    /* Send random context when doing post-handshake auth */\n    if (s->post_handshake_auth == SSL_PHA_REQUEST_PENDING) { ... }', 'explanation': 'The function explicitly checks if the connection is TLS 1.3 and then tests whether the post_handshake_auth extension was sent (by checking if s->post_handshake_auth equals SSL_PHA_REQUEST_PENDING). This directly addresses the condition from the spec.'}}, {'A1': {'code': 'if (s->post_handshake_auth == SSL_PHA_REQUEST_PENDING) {\n    OPENSSL_free(s->pha_context);\n    s->pha_context_len = 32;\n    if ((s->pha_context = OPENSSL_malloc(s->pha_context_len)) == NULL) { ... }\n    if (RAND_bytes_ex(SSL_CONNECTION_GET_CTX(s)->libctx, s->pha_context, s->pha_context_len, 0) <= 0\n            || !WPACKET_sub_memcpy_u8(pkt, s->pha_context, s->pha_context_len)) { ... }\n    if (!tls13_restore_handshake_digest_for_pha(s)) { ... }\n} else {\n    if (!WPACKET_put_bytes_u8(pkt, 0)) { ... }\n}\n\nif (!tls_construct_extensions(s, pkt, SSL_EXT_TLS1_3_CERTIFICATE_REQUEST, NULL, 0)) { ... }', 'explanation': ""This code constructs the CertificateRequest message. In the TLS 1.3 branch, if the post-handshake authentication is requested, it creates a random context and appends it to the packet before constructing the extensions, fulfilling the spec's requirement for the server to send a CertificateRequest message with the proper context.""}}]","The provided function implements the RFC behavior by checking for the post_handshake_auth condition and then constructing a CertificateRequest message accordingly. In the TLS 1.3 branch, it generates a random context when the post-handshake authentication is pending, and includes the necessary extensions, directly addressing the actions required by the spec. All relevant logic is contained within this function, so it fully matches the specified constraints.",success,
13897,tls_construct_certificate_request,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The RFC specification requires that any values within the obsolete_RESERVED ranges must not be offered or negotiated by TLS 1.3 implementations. In reviewing the tls_construct_certificate_request function, there is no visible logic that examines or filters out these obsolete_RESERVED values. Although the function differentiates between TLS 1.3 and earlier versions (e.g., by creating a random context for post-handshake auth in TLS 1.3), it does not include any explicit checks or conditions to ensure that obsolete_RESERVED values are not sent. Thus, the code does not implement the specified RFC constraint within the function itself.",success,
13897,tls_construct_certificate_request,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function does not contain any logic that addresses the TLS 1.3 requirement regarding the status_request_v2 extension. Specifically, the RFC mandates that the server MUST NOT act upon the status_request_v2 extension when processing ClientHello messages, and MUST NOT send it in EncryptedExtensions, CertificateRequest, or Certificate messages. Within this function, there is no explicit handling or filtering for status_request_v2; instead, the function deals with constructing a certificate request (and in the TLS 1.3 branch, handling post-handshake authentication context) and then calls tls_construct_extensions with SSL_EXT_TLS1_3_CERTIFICATE_REQUEST. There is no visible code that references or prevents the inclusion of the status_request_v2 extension. Therefore, based solely on the function_body, the constraint is not implemented.",success,
13897,tls_construct_certificate_request,The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message.,57,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)) {\n    /* Send random context when doing post-handshake auth */\n    if (s->post_handshake_auth == SSL_PHA_REQUEST_PENDING) {\n        OPENSSL_free(s->pha_context);\n        s->pha_context_len = 32;\n        if ((s->pha_context = OPENSSL_malloc(s->pha_context_len)) == NULL) {\n            s->pha_context_len = 0;\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n            return CON_FUNC_ERROR;\n        }\n        if (RAND_bytes_ex(SSL_CONNECTION_GET_CTX(s)->libctx,\n                          s->pha_context, s->pha_context_len, 0) <= 0\n                || !WPACKET_sub_memcpy_u8(pkt, s->pha_context,\n                                          s->pha_context_len)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n            return CON_FUNC_ERROR;\n        }\n        /* reset the handshake hash back to just after the ClientFinished */\n        if (!tls13_restore_handshake_digest_for_pha(s)) {\n            /* SSLfatal() already called */\n            return CON_FUNC_ERROR;\n        }\n    } else {\n        if (!WPACKET_put_bytes_u8(pkt, 0)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n            return CON_FUNC_ERROR;\n        }\n    }\n\n    if (!tls_construct_extensions(s, pkt,\n                                  SSL_EXT_TLS1_3_CERTIFICATE_REQUEST, NULL,\n                                  0)) {\n        /* SSLfatal() already called */\n        return CON_FUNC_ERROR;\n    }', 'explanation': 'This code block demonstrates how the function constructs the CertificateRequest message for TLS 1.3 by including the proper extensions. It handles post-handshake authentication context generation as specified in the RFC.'}}, {'C2': {'code': '/* get the list of acceptable cert types */\nif (!WPACKET_start_sub_packet_u8(pkt)\n    || !ssl3_get_req_cert_type(s, pkt) || !WPACKET_close(pkt)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return CON_FUNC_ERROR;\n}\n\nif (SSL_USE_SIGALGS(s)) {\n    const uint16_t *psigs;\n    size_t nl = tls12_get_psigalgs(s, 1, &psigs);\n\n    if (!WPACKET_start_sub_packet_u16(pkt)\n            || !WPACKET_set_flags(pkt, WPACKET_FLAGS_NON_ZERO_LENGTH)\n            || !tls12_copy_sigalgs(s, pkt, psigs, nl)\n            || !WPACKET_close(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return CON_FUNC_ERROR;\n    }\n}\n\nif (!construct_ca_names(s, get_ca_names(s), pkt)) {\n    /* SSLfatal() already called */\n    return CON_FUNC_ERROR;\n}', 'explanation': ""This part of the code handles construction of the CertificateRequest for pre-TLS 1.3, including setting acceptable certificate types, signature algorithms, and a list of certificate authorities as required by the TLS RFC. It ensures that the server's CertificateRequest message properly includes the requested extension-related data.""}}]","The function tls_construct_certificate_request directly implements the mechanism for constructing a CertificateRequest message in accordance with the TLS RFC. It covers both TLS 1.3 (by sending the proper extension with potential post-handshake authentication support) and earlier versions (by including acceptable certificate types, supported signature algorithms, and CA names). This aligns with the specification that requires the server to send extension requests in the CertificateRequest message, enabling the client to optionally respond with a Certificate message. All relevant logic is contained within this function, satisfying the intent of the RFC.",success,
13898,tls_process_cke_psk_preamble,The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK).,185,Does Not Match,[],"The provided function (tls_process_cke_psk_preamble) is specifically implemented for handling the PSK (Pre-Shared Key) key exchange preamble. It processes the PSK identity and related PSK data but does not implement any logic for sending a Certificate message. According to the RFC specification, the server must send a Certificate message when using certificate-based key exchange methods—not for PSK. Therefore, in isolation, this function does not address the certificate sending requirements described in the RFC.",success,
13898,tls_process_cke_psk_preamble,"Sending this alert is OPTIONAL; servers MAY instead choose to send a ""decrypt_error"" alert to merely indicate an invalid PSK identity.",324,Fully Matches,"[{'A1': {'code': 'if (psklen == 0) {\n    /*\n     * PSK related to the given identity not found\n     */\n    SSLfatal(s, SSL_AD_UNKNOWN_PSK_IDENTITY, SSL_R_PSK_IDENTITY_NOT_FOUND);\n    return 0;\n}', 'explanation': ""The RFC specifies that when a PSK key establishment is desired but no acceptable PSK identity is provided, the server MAY send an 'unknown_psk_identity' alert (or opt to send a 'decrypt_error' instead). In this function, when the PSK callback returns a length of 0 (indicating no PSK found for the provided identity), this alert is sent. This behavior directly implements the optional alert action described in the specification.""}}]","The function 'tls_process_cke_psk_preamble' processes the incoming PSK identity and invokes the PSK server callback to retrieve the corresponding PSK. When the callback indicates no PSK is found (psklen == 0), the function sends an 'unknown_psk_identity' alert, which is in direct compliance with the RFC specification that describes this as an optional action. Thus, the function visibly addresses the specified TLS alert mechanism within its own logic.",success,
13898,tls_process_cke_psk_preamble,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_length_prefixed_2(pkt, &psk_identity)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}\n\nif (PACKET_remaining(&psk_identity) > PSK_MAX_IDENTITY_LEN) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_DATA_LENGTH_TOO_LONG);\n    return 0;\n}', 'explanation': 'These code segments check if the PSK identity portion of the message is improperly formatted (either by failing to extract the expected length‐prefixed data or by exceeding the maximum allowed length) and, if so, terminate the connection with a decode_error alert in accordance with the RFC requirement.'}}]","The function explicitly validates the syntax of the incoming PSK identity by checking the length prefix and ensuring that the remaining length does not exceed the prescribed maximum. In the event of a parsing error, it calls SSLfatal with SSL_AD_DECODE_ERROR, thereby meeting the TLS RFC requirement that peers must terminate the connection with a decode_error alert when a message cannot be parsed according to the syntax. Since these checks are implemented within the function itself, the function is judged as Fully Matching the specification constraints.",success,
13898,tls_process_cke_psk_preamble,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function 'tls_process_cke_psk_preamble' is solely responsible for processing the PSK preamble and does not contain any logic related to cipher suite selection or the prohibition of RC4 cipher suites. The RFC specification mandates that implementations MUST NOT offer or negotiate RC4 cipher suites, but no part of this function implements any checks or restrictions against RC4 usage. Therefore, within the function_body itself, no code addresses the specified constraint.",success,
13900,tls_process_cke_dhe,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2(pkt, &i) || PACKET_remaining(pkt) != i) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG);\n    goto err;\n}', 'explanation': 'This code checks whether the packet can be parsed correctly (i.e., that the packet length is valid and exactly matches the remaining data). If the condition fails, it terminates the connection with a decode_error alert as required by the RFC.'}}, {'A1': {'code': 'if (EVP_PKEY_set1_encoded_public_key(ckey, data, i) <= 0) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    goto err;\n}', 'explanation': 'This segment handles the scenario where the message is syntactically correct but semantically invalid (e.g., a bad key share). In such cases, it terminates the connection with an illegal_parameter alert as specified by the TLS RFC.'}}]","The function implements checks for both parsing errors and semantic errors directly. It verifies that the packet's length is within bounds, triggering a decode_error alert when parsing fails (fulfilling the condition for messages that cannot be parsed), and it validates the encoded public key, triggering an illegal_parameter alert for semantically invalid inputs. These implementations directly address the RFC requirements within the function itself.",success,
13900,tls_process_cke_dhe,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2(pkt, &i) || PACKET_remaining(pkt) != i) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG);\n    goto err;\n}', 'explanation': 'This segment verifies that the packet’s contained length matches the actual remaining bytes, ensuring the message is syntactically valid. If this condition fails, a decode_error alert is issued, which is part of the expected behavior when parsing errors occur.'}}, {'A1': {'code': 'if (EVP_PKEY_set1_encoded_public_key(ckey, data, i) <= 0) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    goto err;\n}', 'explanation': ""This segment checks the semantic validity of the received key share by attempting to set the encoded public key. If this fails, it triggers an 'illegal_parameter' alert, thus handling semantically invalid messages as specified by the TLS RFC.""}}]","The function explicitly checks packet integrity with a length verification to catch syntactic errors and attempts to process the provided Diffie–Hellman key. If the public key share is semantically invalid, it issues an 'illegal_parameter' alert. Both of these error-handling paths directly implement the TLS requirement for terminating connections on malformed or semantically invalid messages.",success,
13901,tls_process_cke_ecdhe,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (EVP_PKEY_set1_encoded_public_key(ckey, data, i) <= 0) {\n            SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n            goto err;\n        }', 'explanation': ""This code branch checks if the ECDHE public key (provided by the client) is semantically valid. If the key cannot be set properly (for example, if it is semantically invalid as per the RFC), the function calls SSLfatal with the alert type SSL_AD_ILLEGAL_PARAMETER, matching the requirement to terminate with an 'illegal_parameter' alert on receiving a syntactically correct but semantically invalid message.""}}]","The RFC requires that when a well-formed (i.e., syntactically correct) message is found to be semantically invalid, the connection must be terminated with an 'illegal_parameter' alert. In this function, the check on EVP_PKEY_set1_encoded_public_key directly implements this requirement by issuing SSL_AD_ILLEGAL_PARAMETER when the key share is invalid. Other error conditions (e.g., decode errors) are handled in the function as well, but only the branch triggering the illegal_parameter alert meets the specific RFC criterion. Therefore, the function only partially matches the full set of labeled constraints within its own logic.",success,
13901,tls_process_cke_ecdhe,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_1(pkt, &i) || !PACKET_get_bytes(pkt, &data, i) || PACKET_remaining(pkt) != 0) { SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);', 'explanation': ""This segment checks for parsing errors such as an incorrect length (e.g., when the length field or packet boundaries do not match expectations) and then terminates the connection using a decode_error alert, directly addressing the RFC's requirement for handling syntactic errors.""}}, {'A2': {'code': 'if (EVP_PKEY_set1_encoded_public_key(ckey, data, i) <= 0) { SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);', 'explanation': ""This segment handles the case where the received parameters (the encoded public key) are syntactically valid but semantically invalid. It terminates the connection with an 'illegal_parameter' alert, as specified in the RFC for semantically invalid messages.""}}]","The function 'tls_process_cke_ecdhe' implements the TLS RFC's error handling for ClientKeyExchange messages by validating the packet's syntactic structure and ensuring a proper encoded public key is received. It checks for parsing errors (e.g., length mismatches) and, if found, terminates the session with a decode_error alert. It also verifies that the client's public key parameters are valid, and if not, it terminates the session with an illegal_parameter alert. This demonstrates that the function fully addresses the specified constraints in the RFC concerning message parsing and error handling.",success,
13903,tls_process_cke_gost,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites. The provided function (tls_process_cke_gost) focuses solely on handling a GOST key exchange and does not perform any checks, negotiations, or rejections related to RC4 cipher suites. There is no visible implementation within this function that addresses the prohibition of RC4 (or low strength ciphers less than 112 bits) as required by the spec constraints. Hence, the function does not meet any of the labeled constraints with respect to RC4.",success,
13903,tls_process_cke_gost,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'pKX = d2i_GOST_KX_MESSAGE(NULL, &ptr, PACKET_remaining(pkt));\n    if (pKX == NULL\n       || pKX->kxBlob == NULL\n       || ASN1_TYPE_get(pKX->kxBlob) != V_ASN1_SEQUENCE) {\n         SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_DECRYPTION_FAILED);\n         goto err;\n    }', 'explanation': 'This code segment attempts to check that the received message is correctly parsed. If the decoding fails or the internal structure (kxBlob) is not as expected, it terminates the connection using a decode_error alert, which addresses the RFC requirement for syntactic parse errors.'}}]","The function partially implements the RFC requirement regarding message parsing errors by checking the syntax of the GOST key exchange message and signaling a decode_error alert when parsing fails. However, additional error cases (such as issues with packet length or extra data after parsing) are handled with an internal error alert rather than a decode_error. Since not all parsing anomalies trigger the decode_error alert as mandated by the specification, the function only partially matches the spec constraints.",success,
13904,tls_process_cke_gost18,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The TLS RFC requirement states that implementations MUST NOT offer or negotiate RC4 cipher suites. However, this function (tls_process_cke_gost18) implements a GOST key exchange mechanism and does not contain any logic addressing RC4 cipher suites—neither to check for their presence nor to prohibit them. Thus, within its own code, it does not visibly implement the specified RFC constraint.",success,
13905,tls_process_client_key_exchange,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}', 'explanation': 'This segment directly checks for an unexpected extra length in the packet—in other words, if the message length extends beyond what is expected for a PSK key exchange—and triggers a decode_error alert, as required by the TLS spec for incorrectly parsed messages.'}}]","The TLS RFC requires that if a message cannot be parsed correctly (for example, if it has a length extending beyond the message boundary), the connection must be terminated with a decode_error alert. In this function, only the PSK branch visibly implements this check by verifying that no extra bytes remain in the packet and calling SSLfatal with SSL_AD_DECODE_ERROR if there are bytes left. Other parsing errors are handled indirectly via delegated functions, so within the function_body itself, only part of the spec constraint is addressed.",success,
13905,tls_process_client_key_exchange,"Once all the values which are to be derived from a given secret have been computed, that secret SHOULD be erased.",325,Does Not Match,[],"The TLS RFC specification requires that once all values derived from a given secret have been computed, the secret should be erased. In this function, while there is a call to OPENSSL_clear_free() in the error handling section for PSK (which clears the PSK on errors), there is no visible logic within the function to erase the secret once its derived values have been computed during normal (successful) execution. Since the secret erasure is not handled within this function body (and reliance on other functions would not count here), the function does not meet the specified requirement.",success,
13905,tls_process_client_key_exchange,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The spec requires that implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS. The provided function 'tls_process_client_key_exchange' deals with processing the client's key exchange message by dispatching based on the key exchange algorithm (PSK, RSA, DHE, ECDHE, SRP, GOST, etc.), but it does not contain any logic to enforce or check that RC4 cipher suites are not being offered or negotiated. Therefore, within this function's code, there is no visible handling or enforcement of the RC4 exclusion rule as required by the RFC specification.",success,
13906,tls_post_process_client_key_exchange,Implementations MUST NOT combine external PSKs with certificate-based authentication of either the client or the server unless negotiated by some extension.,400,Does Not Match,[],"The provided function does not contain any logic that addresses the spec requirement stating that implementations MUST NOT combine external PSKs with certificate-based authentication unless negotiated by an extension. The code primarily focuses on processing SCTP authentication material (for DTLS) and handling handshake transcript digestion for certificate verification. There are no checks or conditions that enforce or validate the separation of external PSKs and certificate-based authentication. Therefore, no labeled conditions or actions (e.g., C1, A1) from the spec constraints are visibly implemented in the function body.",success,
13906,tls_post_process_client_key_exchange,Future specifications MUST NOT define a use of exporters that permit both an empty context and no context with the same label.,332,Does Not Match,[],"The provided function does not include any explicit logic to enforce or check that an exporter label is not used with both an empty context and no context. The code calls SSL_export_keying_material with the label and passes a NULL pointer and a length of 0 for the context, which is the standard way to indicate no context and is equivalent to providing an empty context. However, this does not address the spec requirement which mandates that future definitions must not allow a situation where the same exporter label is used in both ways. Since no code within this function distinguishes between an empty context and no context, or avoids such dual usage with the same label, it does not visibly implement the specified TLS RFC constraint.",success,
13907,tls_process_client_rpk,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Partially Matches,"[{'C1': {'code': 'if (!tls_process_rpk(sc, pkt, &peer_rpk)) {\n    /* SSLfatal already called */\n    goto err;\n}\n\nif (peer_rpk == NULL) {\n    if ((sc->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)\n            && (sc->verify_mode & SSL_VERIFY_PEER)) {\n        SSLfatal(sc, SSL_AD_CERTIFICATE_REQUIRED,\n                 SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\n        goto err;\n    }\n} else {\n    if (ssl_verify_rpk(sc, peer_rpk) <= 0) {\n        SSLfatal(sc, ssl_x509err2alert(sc->verify_result),\n                 SSL_R_CERTIFICATE_VERIFY_FAILED);\n        goto err;\n    }\n}', 'explanation': 'This segment checks for error conditions, and when one is encountered (e.g. failure in processing RPK, missing certificate when required, or certificate verification failure), it calls SSLfatal with the appropriate alert codes.'}}, {'A1': {'code': 'SSLfatal(sc, SSL_AD_CERTIFICATE_REQUIRED, SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\n...\nSSLfatal(sc, ssl_x509err2alert(sc->verify_result), SSL_R_CERTIFICATE_VERIFY_FAILED);\n...\nSSLfatal(sc, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);', 'explanation': 'These calls to SSLfatal send fatal alerts as dictated by the RFC when errors are encountered. The function then jumps to error handling (the err label) to handle cleanup, which is consistent with terminating the connection as required by the spec.'}}]","The function implements key parts of the TLS error handling requirement by detecting error conditions and sending fatal alerts via SSLfatal. This behavior matches the spec’s mandate that upon encountering a fatal error, the implementation should send an appropriate alert and abort further communication. However, while the function takes care of alerting and error branching (via goto err) for several error conditions, it relies on external routines (like SSLfatal) to actually close the connection and perform logging. As these responsibilities are handled outside of this function's visible scope, the function only partially matches the full specification requirements in this isolated context.",success,
13907,tls_process_client_rpk,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Fully Matches,"[{'A1': {'code': 'if ((sc->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT) && (sc->verify_mode & SSL_VERIFY_PEER)) {\n    SSLfatal(sc, SSL_AD_CERTIFICATE_REQUIRED, SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\n    goto err;\n}', 'explanation': 'When no peer key is provided but a certificate is required, the function calls SSLfatal with the specific alert (SSL_AD_CERTIFICATE_REQUIRED). This implements the requirement that a fatal error condition results in the sending of a specific alert.'}}, {'A2': {'code': 'if (ssl_verify_rpk(sc, peer_rpk) <= 0) {\n    SSLfatal(sc, ssl_x509err2alert(sc->verify_result), SSL_R_CERTIFICATE_VERIFY_FAILED);\n    goto err;\n}', 'explanation': 'On failure of the peer raw public key verification, the function calls SSLfatal with an alert derived from the verification result. This reflects the mandate to abort the handshake with the appropriate fatal alert.'}}, {'A3': {'code': 'if ((new_sess = ssl_session_dup(sc->session, 0)) == NULL) {\n    SSLfatal(sc, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);\n    goto err;\n}', 'explanation': 'If a necessary operation (duplicating the session) fails, the function calls SSLfatal with the internal error alert, ensuring that fatal errors are signaled with the corresponding alert as required.'}}]","The function implements critical error-handling logic by directly calling SSLfatal with specific alert codes upon encountering fatal error conditions. Each error branch (missing certificate when required, verification failure, or session duplication failure) sends an appropriate alert and aborts further processing. This behavior is in direct alignment with the TLS RFC specification which mandates that upon detecting fatal errors in the handshake, the implementation must send the designated alert and terminate the connection. All these checks and alert-sending actions are performed within the function itself, satisfying the referenced constraints.",success,
13907,tls_process_client_rpk,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Partially Matches,"[{'C1': {'code': 'if (peer_rpk == NULL) {\n    if ((sc->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)\n            && (sc->verify_mode & SSL_VERIFY_PEER)) {\n        SSLfatal(sc, SSL_AD_CERTIFICATE_REQUIRED,\n                 SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\n        goto err;\n    }\n} else {\n    if (ssl_verify_rpk(sc, peer_rpk) <= 0) {\n        SSLfatal(sc, ssl_x509err2alert(sc->verify_result),\n                 SSL_R_CERTIFICATE_VERIFY_FAILED);\n        goto err;\n    }\n}\n...\nif ((new_sess = ssl_session_dup(sc->session, 0)) == NULL) {\n    SSLfatal(sc, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);\n    goto err;\n}', 'explanation': ""The function calls SSLfatal with fatal alert parameters when errors are detected (e.g. missing peer certificate, certificate verification failure, internal error). This indicates an intent to conform to the specification's requirement that alerts be sent with AlertLevel=fatal. However, only specific error conditions trigger such calls, and the function does not address all aspects of handling alerts (such as treating any received alert as fatal regardless of its declared level).""}}]","The code function partially implements the RFC specification regarding error alerts. It ensures that certain error conditions trigger a call to SSLfatal with fatal alert codes, which appears aligned with the requirement that alerts be sent with AlertLevel fatal. However, the function does not include logic for processing unknown alerts or handling all cases of received alert messages as required by the spec. Only a subset of the alert-related conditions is directly addressed in this function, resulting in a partial match of the constraints.",success,
13908,tls_process_client_certificate,"If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either continue the handshake without client authentication or abort the handshake with a ""certificate_required"" alert.",218,Partially Matches,"[{'C1': {'code': 'if (sk_X509_num(sk) <= 0) {\n    /* TLS does not mind 0 certs returned */\n    if (s->version == SSL3_VERSION) {\n        SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE,\n                 SSL_R_NO_CERTIFICATES_RETURNED);\n        goto err;\n    }\n    /* Fail for TLS only if we required a certificate */\n    else if ((s->verify_mode & SSL_VERIFY_PEER) &&\n             (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) {\n        SSLfatal(s, SSL_AD_CERTIFICATE_REQUIRED,\n                 SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\n        goto err;\n    }\n    /* No client certificate so digest cached records */\n    if (s->s3.handshake_buffer && !ssl3_digest_cached_records(s, 0)) {\n        goto err;\n    }\n}', 'explanation': ""This segment handles the case when the client sends an empty Certificate message. It checks if there are no certificates in the chain and, based on the TLS version and the server's verification mode (i.e. if a certificate is required) either aborts the handshake with a 'certificate_required' alert or continues processing. This aligns with the RFC spec that permits either action when no client certificate is provided.""}}]","The function visibly implements part of the RFC requirement regarding handling an empty Certificate message by checking if the certificate chain is empty and then choosing to abort the handshake or proceed based on the configuration (i.e., whether a certificate is required). However, it does not address other aspects mentioned in the full spec (such as handling certificates signed with MD5 or SHA-1, or the client abort behavior when receiving an empty certificate from the server), thereby resulting in only partial matching of the overall RFC specification.",success,
13908,tls_process_client_certificate,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data.",320,Partially Matches,"[{'A1': {'code': 'if (s->ext.client_cert_type != TLSEXT_cert_type_x509) {\n    SSLfatal(s, SSL_AD_UNSUPPORTED_CERTIFICATE, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    goto err;\n}\n\n... // similar calls to SSLfatal in other error branches', 'explanation': 'The function calls SSLfatal with various alert codes upon encountering error conditions, which indicates that it is attempting to send an appropriate fatal alert as required by the spec.'}}]","The TLS client certificate processing function checks for various error conditions and, in each error branch, calls SSLfatal to generate a fatal alert. This behavior addresses the part of the RFC that requires an appropriate fatal alert to be sent when an error is detected (Action A1). However, the RFC also mandates that the connection must be closed immediately after a fatal error is encountered, and within this function there is no explicit logic to close the connection or to prevent further communication; the function simply jumps to an error cleanup section and returns an error code. Because the connection termination responsibility appears to be deferred to other parts of the system (or assumed to be handled within SSLfatal), this function only partially implements the complete error-handling behavior described in the spec.",success,
13908,tls_process_client_certificate,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Fully Matches,"[{'C1': {'code': 'if (s->ext.client_cert_type != TLSEXT_cert_type_x509) {\n    SSLfatal(s, SSL_AD_UNSUPPORTED_CERTIFICATE, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    goto err;\n}\n...\nif ((sk = sk_X509_new_null()) == NULL) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_CRYPTO_LIB);\n    goto err;\n}\n...\nif (!PACKET_get_length_prefixed_3(pkt, &spkt) || PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n...\nif (i <= 0) {\n    SSLfatal(s, ssl_x509err2alert(s->verify_result), SSL_R_CERTIFICATE_VERIFY_FAILED);\n    goto err;\n}\n...\nif (pkey == NULL) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    goto err;\n}\n...', 'explanation': 'The function routinely checks for error conditions (such as unsupported certificate types, length mismatches, internal errors, or certificate verification failures) and in each case immediately calls SSLfatal() with a specific alert code. This fulfills the requirement that, upon detecting a fatal error, the implementation sends an appropriate alert.'}}, {'A1': {'code': 'SSLfatal(s, <alert_code>, <error_code>);', 'explanation': 'Throughout the function, when a fatal condition is detected, SSLfatal() is invoked with specific alert codes (for example, SSL_AD_UNSUPPORTED_CERTIFICATE, SSL_AD_DECODE_ERROR, etc.). This directly implements the action required by the TLS RFC specification to send alert X when terminating the connection or aborting the handshake.'}}]","The function processes the client certificate message and includes multiple checks for error conditions. In each detected error path, it calls SSLfatal() with a specific alert code, ensuring that if an alert is sent it corresponds to the failure. This clearly implements the TLS RFC requirement that mandates sending a specific alert (X alert) when the connection is terminated or the handshake is aborted due to fatal errors. All relevant alert-sending logic exists within the function itself, thereby fully meeting the specified protocol constraints.",success,
13908,tls_process_client_certificate,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Partially Matches,"[{'C1': {'code': 'if (s->ext.client_cert_type != TLSEXT_cert_type_x509) {\n    SSLfatal(s, SSL_AD_UNSUPPORTED_CERTIFICATE, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    goto err;\n}\n\n... (multiple similar calls to SSLfatal for various error conditions) ...\n\nif (!PACKET_get_length_prefixed_1(pkt, &context)\n        || (s->pha_context == NULL && PACKET_remaining(&context) != 0)\n        || (s->pha_context != NULL\n            && !PACKET_equal(&context, s->pha_context, s->pha_context_len))) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_INVALID_CONTEXT);\n    goto err;\n}', 'explanation': 'The function actively checks for various error conditions (e.g., unsupported certificate type, decode errors, length mismatches) and calls SSLfatal with appropriate alert codes each time an error is detected. This shows an effort to implement the specification’s directive to send a fatal alert upon error detection.'}}]","The function implements several internal error checks and makes use of SSLfatal to send corresponding fatal alerts when errors are detected. This behavior aligns with the RFC specification’s requirement to send an appropriate fatal alert when a fatal error occurs. However, while the function does trigger alert sending and returns an error status, it does not explicitly include logic to immediately close the connection within its body (instead relying on later processing by the caller). Therefore, the implementation in this function alone only partially meets the full intent of the specification.",success,
13908,tls_process_client_certificate,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_length_prefixed_1(pkt, &context)\n                || (s->pha_context == NULL && PACKET_remaining(&context) != 0)\n                || (s->pha_context != NULL && !PACKET_equal(&context, s->pha_context, s->pha_context_len))) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_INVALID_CONTEXT);\n        goto err;\n    }', 'explanation': 'This section validates the context field of the message. It checks the length and equality with the expected context and triggers a decode_error alert if the syntax is not as expected.'}}, {'A1': {'code': 'if (!PACKET_get_length_prefixed_3(pkt, &spkt) || PACKET_remaining(pkt) != 0) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n        goto err;\n    }\n    \n    for (chainidx = 0; PACKET_remaining(&spkt) > 0; chainidx++) {\n        if (!PACKET_get_net_3(&spkt, &l) || !PACKET_get_bytes(&spkt, &certbytes, l)) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_CERT_LENGTH_MISMATCH);\n            goto err;\n        }\n        ...\n        if (d2i_X509(&x, (const unsigned char **)&certbytes, l) == NULL) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, ERR_R_ASN1_LIB);\n            goto err;\n        }\n        if (certbytes != (certstart + l)) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_CERT_LENGTH_MISMATCH);\n            goto err;\n        }\n    }', 'explanation': 'The code performs several parsing steps (e.g. checking lengths and extracting the certificate bytes) and for each failure in parsing, it calls SSLfatal with SSL_AD_DECODE_ERROR. This directly implements the requirement to terminate connections with a decode_error alert when the syntax of the message is not met.'}}]","The function examines various aspects of the incoming certificate message (its overall length, contextual field, certificate chain lengths, and ASN.1 parsing) and in every instance where the message does not comply with the expected syntax, it invokes SSLfatal with the alert parameter set to SSL_AD_DECODE_ERROR. This behavior aligns with the TLS RFC specification that mandates peers must terminate the connection with a decode_error alert if a message cannot be correctly parsed.",success,
13908,tls_process_client_certificate,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Partially Matches,"[{'A1': {'code': 'if (s->ext.client_cert_type != TLSEXT_cert_type_x509) {\n    SSLfatal(s, SSL_AD_UNSUPPORTED_CERTIFICATE, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    goto err;\n}\n\n...\n\nif (!PACKET_get_length_prefixed_1(pkt, &context)\n        || (s->pha_context == NULL && PACKET_remaining(&context) != 0)\n        || (s->pha_context != NULL\n            && !PACKET_equal(&context, s->pha_context, s->pha_context_len))) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_INVALID_CONTEXT);\n    goto err;\n}\n\n...\n\nAnd multiple similar calls to SSLfatal(...)\n', 'explanation': 'Throughout the function, whenever an error is detected during client certificate processing (for instance, mismatched lengths, parsing errors, or internal errors), the function invokes SSLfatal with specific alert codes. This implies that error conditions trigger alerts that are meant to be fatal in accordance with the RFC requirement that error alerts be sent with AlertLevel=fatal. However, note that the function’s logic is primarily concerned with sending fatal alerts on errors during certificate processing rather than handling alert reception or verifying incoming alert levels.'}}]","The TLS RFC specification mandates that all alerts (especially those in Section 6.2) be sent with AlertLevel=fatal and treated as error alerts irrespective of the AlertLevel contained in the alert message. In this function, whenever an error is encountered during client certificate processing, the code calls SSLfatal with a fatal alert code (e.g., SSL_AD_DECODE_ERROR, SSL_AD_UNSUPPORTED_CERTIFICATE, etc.), thereby ensuring that error conditions result in fatal alerts. This shows that the function is deliberately trying to enforce the sending of fatal alerts. However, the function does not address all aspects of the specification—such as the handling of incoming alerts regardless of their declared level—that are part of the overall spec. Consequently, while the function’s error handling logic conforms to part of the RFC (the sending of fatal alerts on error), it does not fully implement every detail of the constraint as outlined in the RFC. Hence, the implementation is judged as partially matching the requirement.",success,
13908,tls_process_client_certificate,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Fully Matches,"[{'C1': {'code': 'if (s->ext.client_cert_type == TLSEXT_cert_type_rpk)\n    return tls_process_client_rpk(s, pkt);\n\nif (s->ext.client_cert_type != TLSEXT_cert_type_x509) {\n    SSLfatal(s, SSL_AD_UNSUPPORTED_CERTIFICATE, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    goto err;\n}', 'explanation': ""The specification requires that the OpenPGP certificate type (as defined in RFC6091) MUST NOT be used with TLS 1.3. In this function, the certificate type is checked immediately. If the type is 'rpk', it delegates to a specific handler; otherwise, if it is not 'x509' (which implicitly includes OpenPGP), the function immediately raises an error. This ensures that in TLS 1.3, any client certificate type other than x509 (and rpk, which is handled appropriately) is rejected, thereby satisfying the requirement.""}}]","The function 'tls_process_client_certificate' inspects the client certificate type at the very beginning. By routing 'rpk' certificates to a dedicated handler and by rejecting any certificate type that is not x509 (which includes the OpenPGP type), the code prevents the use of the OpenPGP certificate type in TLS 1.3 as required by RFC6091. The logic implemented directly in this function fulfills the spec constraint.",success,
13910,tls_construct_server_certificate,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'A1': {'code': 'if (cpk == NULL) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return CON_FUNC_ERROR;\n}\n\nif (SSL_CONNECTION_IS_TLS13(s) && !WPACKET_put_bytes_u8(pkt, 0)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return CON_FUNC_ERROR;\n}\n\n... \n\ndefault:\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;', 'explanation': ""Throughout the function, on detecting error conditions such as a NULL certificate pointer, failing to write the TLSv1.3 context byte, or encountering an unknown certificate type, the function calls 'SSLfatal' with a specific alert (SSL_AD_INTERNAL_ERROR). This demonstrates an attempt to enforce the requirement that a fatal error must trigger sending a specified alert before terminating the connection. However, while the error detection and alerting are present, the full mandated behavior (e.g. ensuring no further data is sent and immediate connection closure) is likely handled outside this function – hence only a partial match.""}}]","The function visibly addresses the TLS error handling requirement by checking for error conditions and invoking SSLfatal with an explicit alert value (SSL_AD_INTERNAL_ERROR) before returning an error. This aligns with the RFC specification that requires sending an appropriate fatal alert on error. However, since additional parts of the connection termination process (like the immediate closure and no further data transmission) are not implemented within this function itself, the match is only partial.",success,
13910,tls_construct_server_certificate,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Fully Matches,"[{'C1': {'code': 'switch (s->ext.server_cert_type) {\n    case TLSEXT_cert_type_rpk:\n        if (!tls_output_rpk(s, pkt, cpk)) {\n            return 0;\n        }\n        break;\n    case TLSEXT_cert_type_x509:\n        if (!ssl3_output_cert_chain(s, pkt, cpk, 0)) {\n            return 0;\n        }\n        break;\n    default:\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return 0;\n}', 'explanation': 'The RFC specifies that the OpenPGP certificate type MUST NOT be used with TLS 1.3. In this function, only TLSEXT_cert_type_rpk and TLSEXT_cert_type_x509 are explicitly handled. Any certificate type other than these, including OpenPGP, will hit the default case which triggers an error, thereby enforcing the specification.'}}]","The function implements the certificate construction logic by explicitly handling only the raw public key and X.509 certificate types. Any other certificate type, such as OpenPGP, causes the function to call SSLfatal and return an error. This design effectively prevents OpenPGP from being used with TLS 1.3, fulfilling the given TLS RFC requirement.",success,
13910,tls_construct_server_certificate,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Partially Matches,"[{'C1': {'code': 'if (cpk == NULL) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return CON_FUNC_ERROR;\n}', 'explanation': 'This code checks for a NULL certificate pointer, and upon detection of an error, calls SSLfatal to send a fatal alert. This corresponds to the RFC requirement of detecting an error and initiating alert transmission.'}}, {'A1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s) && !WPACKET_put_bytes_u8(pkt, 0)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return CON_FUNC_ERROR;\n}', 'explanation': 'Similarly, if writing to the packet fails in a TLSv1.3 connection, the code calls SSLfatal to send a fatal alert. This attempts to meet the spec action of sending the appropriate fatal alert upon error detection.'}}]","The function contains logic that detects error conditions and calls SSLfatal to send fatal alerts, which is in line with the TLS RFC specification regarding error handling. However, the detailed requirements such as explicitly terminating the connection and logging alert transmissions, as well as handling all fatal alert scenarios, are either abstracted to SSLfatal or managed elsewhere. Therefore, while the function addresses some of the specified behaviors (error detection and alert sending), it does not fully implement every aspect of the error handling requirements described in the spec. This results in a partial match.",success,
13910,tls_construct_server_certificate,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The RFC requires that TLS 1.3 servers must not send the status_request_v2 extension in specific messages. In the provided function, the logic only constructs the server certificate message and handles output of the certificate chain or raw public key certificate without any handling relating to the status_request_v2 extension. There is no code in the function that checks for or excludes the status_request_v2 extension. Thus, the function does not address the relevant condition/action specified in the RFC regarding status_request_v2.",success,
13911,tls_construct_server_compressed_certificate,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function tls_construct_server_compressed_certificate is solely focused on constructing and sending a compressed certificate using pre-compressed data. It does not contain any logic that directly addresses the TLS 1.3 requirements regarding the handling or omission of the status_request_v2 extension as specified in the RFC. There is no code segment within this function that processes or checks for the status_request_v2 extension, nor does it implement any restriction against sending it. As such, no labeled spec constraints (e.g., C1, A1) related to the status_request_v2 extension are handled in this function.",success,
13911,tls_construct_server_compressed_certificate,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'A1': {'code': 'if (!ossl_assert(cc != NULL)) {\n    SSLfatal(sc, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}', 'explanation': 'This segment detects an error condition (cc being NULL) and calls SSLfatal with a specific alert (SSL_AD_INTERNAL_ERROR), which aligns with the requirement to send a fatal alert when an error is detected. However, the function does not handle alert sending for other error cases (e.g., failures in the WPACKET_* functions), meaning it only partially addresses the overall error-handling requirement of sending a specific alert in every fatal error situation.'}}]","The function shows an attempt to implement the TLS RFC error handling requirement by sending a fatal alert (using SSLfatal) when a critical error (null compressed certificate) is detected. Nevertheless, it does not consistently send an alert in all error scenarios (for instance, packet writing failures are handled by a simple return without alert transmission). As only one error path implements the specified alert logic, the function only partially matches the TLS RFC constraint regarding alert sending upon fatal errors.",success,
13913,construct_stateless_ticket,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function focuses solely on constructing a stateless session ticket (including encryption and HMAC processing) and does not include any logic that enforces or checks certificate types. The RFC specification requires that the OpenPGP certificate type (RFC6091) MUST NOT be used with TLS 1.3, but no code within this function checks for certificate types or explicitly disallows the use of OpenPGP certificates in TLS 1.3. The TLS 1.3 specific check in this function is only concerned with the ticket key callback result (aborting ticket creation if a zero-length ticket is produced) and does not enforce the certificate type constraint mentioned in the spec.",success,
13916,tls_construct_new_session_ticket,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The code in tls_construct_new_session_ticket does not include any logic to check or enforce the requirement that the OpenPGP certificate type MUST NOT be used with TLS 1.3 (as specified in RFC6091). The function focuses on constructing new session tickets for TLS 1.3 by generating nonces, updating session parameters, and selecting between stateful or stateless ticket construction, but it does not reference or validate the certificate type. Therefore, it does not visibly address the constraint related to the prohibition of the OpenPGP certificate type with TLS 1.3.",success,
13916,tls_construct_new_session_ticket,The server MUST generate a fresh value for each ticket it sends.,249,Fully Matches,"[{'C1': {'code': 'if (RAND_bytes_ex(SSL_CONNECTION_GET_CTX(s)->libctx,\n                  age_add_u.age_add_c, sizeof(age_add_u), 0) <= 0) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}\ns->session->ext.tick_age_add = age_add_u.age_add;', 'explanation': ""The code calls RAND_bytes_ex to generate a fresh random 32-bit value for 'age_add' and then sets it as the ticket's 'tick_age_add'. This corresponds to the specification requirement that the server MUST generate a fresh value for each ticket it sends.""}}]","The function explicitly generates a fresh random value for ticket_age_add by calling RAND_bytes_ex each time a new session ticket is constructed. This logic, found in the function_body itself, directly implements the specific TLS RFC requirement that the server must generate a fresh value for each ticket it sends. Thus, the code function fully meets the provided spec constraint.",success,
13916,tls_construct_new_session_ticket,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Fully Matches,"[{'C1': {'code': 'if (!tls13_hkdf_expand(s, md, s->resumption_master_secret,\n                           nonce_label,\n                           sizeof(nonce_label) - 1,\n                           tick_nonce,\n                           TICKET_NONCE_SIZE,\n                           s->session->master_key,\n                           hashlen, 1)) { ... }', 'explanation': 'This segment calls tls13_hkdf_expand using s->resumption_master_secret (the output of a previous HKDF-Extract) along with other parameters. It ensures that the extracted secret is used only after an explicit HKDF-Expand call, which satisfies the TLS RFC requirement that an HKDF-Expand must follow every HKDF-Extract.'}}]","The function tls_construct_new_session_ticket implements TLS 1.3 session ticket creation. In doing so, it follows the specific ordering requirement stated in the RFC by invoking HKDF-Expand (through tls13_hkdf_expand) immediately after using the output of a prior HKDF-Extract (embedded in s->resumption_master_secret). This approach adheres to the RFC specification that mandates the use of HKDF-Expand in between successive HKDF-Extract invocations, thereby fully matching the constraint as applied in this function.",success,
13916,tls_construct_new_session_ticket,"The server MAY also send unsolicited extensions in the NewSessionTicket, though the client does not respond directly to these.",58,Fully Matches,"[{'A1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)) {\n    if (!tls_construct_extensions(s, pkt, SSL_EXT_TLS1_3_NEW_SESSION_TICKET, NULL, 0)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n    tls_update_ticket_counts(s);\n    ssl_update_cache(s, SSL_SESS_CACHE_SERVER);\n}', 'explanation': 'This code block explicitly constructs the unsolicited extensions for the NewSessionTicket in TLS 1.3 by calling tls_construct_extensions(). The specification states that the server MAY send unsolicited extensions in the NewSessionTicket (and the client does not directly respond to these), which is directly addressed by this segment.'}}]","The function constructs a new session ticket and, when operating under TLS 1.3, unconditionally includes a call to tls_construct_extensions to append unsolicited extensions. This behavior implements the TLS RFC requirement that permits the server to send unsolicited extensions in the NewSessionTicket. Since the logic relevant to this specification is contained entirely within the function, it is considered to Fully Match the specified requirement.",success,
13916,tls_construct_new_session_ticket,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The function is responsible for constructing a new session ticket in TLS 1.3 and, while it sets the field s->session->ext.max_early_data from s->max_early_data, it does not implement any logic to control or decide on the retransmission of early data. Specifically, the spec states that a TLS implementation SHOULD NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol. There is no code in the function_body that checks the ALPN protocol or prevents the automatic retransmission of early data. Thus, the function does not visibly address the constraint regarding automatic retransmission of early data.",success,
13921,tls_process_end_of_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function, tls_process_end_of_early_data, is solely responsible for processing the EndOfEarlyData message by performing length, state, and record boundary checks, then updating the early data state and changing the cipher state. It does not contain any logic to make decisions or checks regarding the automatic retransmission of early data based on the negotiated ALPN protocol. In other words, there is no code in this function that verifies whether the ALPN protocol matches or prevents automatic retransmission, as required by the TLS RFC specification. Therefore, the function does not implement the specified TLS RFC behavior concerning the resending of early data.",success,
13921,tls_process_end_of_early_data,"Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages can immediately precede a key change, implementations MUST send these messages in alignment with a record boundary.",279,Fully Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': 'This segment ensures that the EndOfEarlyData message is received as a complete, zero-length fragment, which is in line with the requirement that such handshake messages must not be split or contain extra data.'}}, {'A1': {'code': 'if (RECORD_LAYER_processed_read_pending(&s->rlayer)) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': 'This check verifies that the EndOfEarlyData message immediately precedes a key change and is aligned with a record boundary. If the record layer indicates pending processed reads (i.e. the message is not on a record boundary), it terminates the connection with an unexpected_message alert, thereby enforcing the TLS specification requirement.'}}]","The function implements the relevant TLS RFC requirement by ensuring that the EndOfEarlyData message, which signals an imminent key change, is both received correctly (as a zero-length fragment) and aligned with a record boundary. The explicit check for pending records enforces the constraint that no other records should interrupt the handshake message, directly addressing the spec constraint. All required logic for these constraints is implemented within the function itself.",success,
13921,tls_process_end_of_early_data,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': 'This code checks if the message has extra bytes (i.e. the packet length is not zero) and terminates the connection with a decode_error alert. This addresses the RFC requirement that messages which cannot be parsed due to an incorrect length should result in termination with a correct alert.'}}]","The function visibly implements part of the RFC specification by checking the packet's length and issuing a decode_error alert if extra data is detected. This check corresponds to one of the conditions (C1) described in the spec. However, the function does not address other aspects of the specification, such as handling semantically invalid messages (which would require an illegal_parameter alert), or enforcing fatal alert levels in a broader context. Therefore, the implementation in this function only partially matches the overall TLS RFC requirements.",success,
13921,tls_process_end_of_early_data,"Implementations MUST verify that all messages immediately preceding a key change align with a record boundary; if not, then they MUST terminate the connection with an ""unexpected_message"" alert.",278,Fully Matches,"[{'C1': {'code': 'if (RECORD_LAYER_processed_read_pending(&s->rlayer)) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': ""This code explicitly verifies that the EndOfEarlyData message is received at a record boundary by checking if there is pending data from the record layer (indicative of a non-boundary). Upon detecting such a condition, it terminates the processing with the 'unexpected_message' alert as required by the RFC.""}}]","The function 'tls_process_end_of_early_data' includes logic that ensures the EndOfEarlyData message (which signals a key change) is aligned with a record boundary. Specifically, by checking for pending processed read data and aborting if any is found, the function directly implements the TLS RFC requirement regarding message alignment prior to a key change. Dependencies outside this function are not considered, so the logic within this function fully addresses the relevant constraint.",success,
13921,tls_process_end_of_early_data,-Handshake messages MUST NOT be interleaved with other record types.,275,Partially Matches,"[{'A1': {'code': '/* EndOfEarlyData signals a key change so the end of the message must be on\n * a record boundary. */\nif (RECORD_LAYER_processed_read_pending(&s->rlayer)) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': 'This code snippet checks that the EndOfEarlyData message is received on a record boundary by verifying that there are no pending processed records. This corresponds to the part of the spec that requires handshake messages (which signal a key change) to be aligned with record boundaries.'}}]","The function explicitly verifies that the EndOfEarlyData message is received on a record boundary by checking with RECORD_LAYER_processed_read_pending. This addresses the condition in the spec which requires that handshake messages (in this case, the EndOfEarlyData message) do not span key changes and are aligned with a record boundary. However, the function does not address the full scope of requirements regarding handshake messages not being interleaved with other record types, as that aspect might be handled elsewhere. Therefore, the code function partially matches the TLS RFC spec constraints on its own.",success,
13921,tls_process_end_of_early_data,"That is, if a handshake message is split over two or more records, there MUST NOT be any other records between them.",276,Fully Matches,"[{'A1': {'code': 'if (RECORD_LAYER_processed_read_pending(&s->rlayer)) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': 'This code segment verifies that the EndOfEarlyData handshake message— which signals a key change — is received on a proper record boundary. According to the spec, handshake messages (especially those preceding a key change) must align with record boundaries and must not be interleaved with other record types. The check ensures that no extraneous records have been processed (i.e., no pending read data remains), thereby directly enforcing the requirement that if a handshake message is split across records, no other records should be interleaved.'}}]","The function tls_process_end_of_early_data implements the specific TLS requirement regarding handshake messages and record boundaries. By verifying that no pending read data exists before processing the key change (via the RECORD_LAYER_processed_read_pending() check), the function ensures that the handshake message (EndOfEarlyData) is correctly received on a record boundary and is not fragmented with interleaved records. This directly addresses the spec's mandate that if a handshake message is split over multiple records, there must be no other records between them.",success,
13922,tls_parse_ctos_renegotiate,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_1(pkt, &ilen) || !PACKET_get_bytes(pkt, &data, ilen)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_RENEGOTIATION_ENCODING_ERR);\n    return 0;\n}', 'explanation': 'This code block checks for parsing errors (for example, when the length byte cannot be obtained or when there are not enough bytes as indicated by the length). In such cases, the connection is terminated with a decode_error alert as required by the specification.'}}, {'A1': {'code': 'if (ilen != s->s3.previous_client_finished_len) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_RENEGOTIATION_MISMATCH);\n    return 0;\n}\n\nok = memcmp(data, s->s3.previous_client_finished, s->s3.previous_client_finished_len);\nif (ok) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_RENEGOTIATION_MISMATCH);\n    return 0;\n}', 'explanation': ""After a successful parse, the function verifies that the renegotiation data matches the expected value. If it does not match (i.e. the message is semantically invalid), the connection is terminated using a handshake_failure alert. Although the spec example mentions using an 'illegal_parameter' alert for semantically invalid messages, for the TLS renegotiation extension the standard practice (as implemented here) is to use handshake_failure. This still fulfills the requirement to abort on semantically invalid renegotiation data.""}}]","The function first ensures that the message is parsed correctly and, if not, terminates the connection with a decode_error alert. It then checks that the renegotiation information (length and content) matches the expected values, and if there is a mismatch (a semantic error) it terminates the connection with a handshake_failure alert. In the context of TLS renegotiation extensions, sending handshake_failure for mismatched data is an accepted practice. Therefore, the function visibly implements the TLS RFC requirements within its own logic.",success,
13923,tls_parse_ctos_server_name,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_2(pkt, &sni)\n            || PACKET_remaining(&sni) == 0) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n            return 0;\n        }', 'explanation': 'This segment checks that the ServerNameList is present and has a nonzero length. If the parsing fails then it immediately terminates the connection using a decode_error alert (SSL_AD_DECODE_ERROR), in line with the RFC requirement for syntactical parse failures.'}}, {'C1': {'code': 'if (!PACKET_get_1(&sni, &servname_type)\n            || servname_type != TLSEXT_NAMETYPE_host_name\n            || !PACKET_as_length_prefixed_2(&sni, &hostname)) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n            return 0;\n        }', 'explanation': 'This part verifies that the SNI type is the allowed host_name and that a hostname is correctly extracted. Failure in any of these parsing steps again results in a connection termination with a decode_error alert, addressing the RFC mandate for syntactical checking.'}}]","The function implements several syntactical checks on the incoming Server Name Indication extension. When the SNI list is absent or malformed (including an invalid SNI type), it terminates the connection using a decode_error alert, which aligns with the RFC’s requirement regarding parse errors. However, not all error cases are treated uniformly – for instance, if the hostname is too long or contains a zero byte the function uses an 'unrecognized_name' alert instead of a decode_error alert. Thus, while the function visibly implements error handling for malformed messages, it does so only partially in accordance with the full specification.",success,
13923,tls_parse_ctos_server_name,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_2(pkt, &sni)\n    || PACKET_remaining(&sni) == 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'The code checks that the ServerNameList field is present and non-empty. If this condition (as required by the RFC) is not met, it aborts the handshake with a decode_error alert.'}}, {'A1': {'code': 'if (!PACKET_get_1(&sni, &servname_type)\n    || servname_type != TLSEXT_NAMETYPE_host_name\n    || !PACKET_as_length_prefixed_2(&sni, &hostname)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': ""This segment ensures that only the valid 'host_name' type is accepted and that a proper length-prefixed hostname is present. On failure, it calls SSLfatal with a decode_error alert in accordance with the RFC.""}}]","The function implements selective parts of the required behavior by verifying SNI extension format as specified in the RFC—namely, it ensures essential fields are correctly formatted and aborts the handshake with a decode_error alert if they are not. However, while it adheres to the RFC's error handling mandates for the SNI extension, it does not attempt to cover all aspects of the TLS extension processing (for example, verifying the absence of unexpected trailing data in non-TLS 1.3 handshakes). Thus, the implementation only partially matches the full RFC constraints.",success,
13924,tls_parse_ctos_maxfragmentlen,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 1 || !PACKET_get_1(pkt, &value)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This segment checks that the packet has exactly one byte and is parseable. If not, it terminates the connection with a decode_error alert, directly addressing the RFC requirement for syntactic parsing errors.'}}, {'A1': {'code': 'if (!IS_MAX_FRAGMENT_LENGTH_EXT_VALID(value)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_SSL3_EXT_INVALID_MAX_FRAGMENT_LENGTH);\n    return 0;\n}', 'explanation': 'This segment validates the received max fragment length code. If the value is not valid, it terminates the connection with an illegal_parameter alert as specified for semantically incorrect parameters in the RFC.'}}]","The function implements the relevant parts of the TLS RFC by ensuring that any parsing errors (wrong length or failure to extract the expected byte) lead to a decode_error alert, and any semantically invalid values lead to an illegal_parameter alert. These cover the specified conditions: properly handling messages that cannot be parsed by sending the correct alert and terminating the connection.",success,
13924,tls_parse_ctos_maxfragmentlen,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'A1': {'code': 'if (PACKET_remaining(pkt) != 1 || !PACKET_get_1(pkt, &value)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This code checks the syntactic validity of the message (i.e. ensuring the packet has exactly one byte and that extraction succeeds) and, if not, triggers a decode_error alert as required by the spec for messages that cannot be parsed.'}}, {'A2': {'code': 'if (!IS_MAX_FRAGMENT_LENGTH_EXT_VALID(value)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_SSL3_EXT_INVALID_MAX_FRAGMENT_LENGTH);\n    return 0;\n}', 'explanation': 'This condition verifies that the received max_fragment_length value is semantically valid. If the value is not valid (an invalid enum), it triggers an illegal_parameter alert as mandated by the TLS RFC for semantically invalid messages.'}}]","The function tls_parse_ctos_maxfragmentlen implements the TLS RFC requirements by checking for both syntactic errors (using a length check and extraction, triggering a decode_error alert when those fail) and semantic errors (validating the max_fragment_length value and triggering an illegal_parameter alert if invalid). Both aspects are directly handled within the function_body, ensuring that it visibly addresses the spec constraints.",success,
13924,tls_parse_ctos_maxfragmentlen,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 1 || !PACKET_get_1(pkt, &value)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': ""This code confirms that the extension data is exactly one byte long. If the check fails, it aborts the handshake by invoking SSLfatal with a decode_error alert, which aligns with the spec's requirement to abort upon receiving an improperly formatted extension.""}}, {'C2': {'code': 'if (!IS_MAX_FRAGMENT_LENGTH_EXT_VALID(value)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_SSL3_EXT_INVALID_MAX_FRAGMENT_LENGTH);\n    return 0;\n}', 'explanation': 'This snippet verifies that the extracted max-fragment-length code is valid. Though the spec mandates an abort on malformed extension data, here an illegal parameter alert is used if the value is invalid. This still constitutes a mechanism to abort the handshake on error.'}}]","The function implements error checks on the max_fragment_length extension by verifying that exactly one byte is present and that the content is a valid value. When these conditions are not met, the function aborts the handshake using an alert. This behavior addresses some of the spec's constraints regarding error detection and handshake abortion. However, it does not cover other TLS version or extension-specific requirements mentioned in the context (such as handling extraneous data after the compression_methods field), so its implementation of the spec is only partial.",success,
13926,tls_parse_ctos_ec_pt_formats,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_1(pkt, &ec_point_format_list)\n        || PACKET_remaining(&ec_point_format_list) == 0) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n        return 0;\n    }', 'explanation': ""This code segment verifies that the packet can be parsed as a length-prefixed structure and also ensures that the resulting list is non-empty. If either check fails, it triggers a termination using SSLfatal with a decode_error alert, directly addressing the RFC requirement that peers must terminate the connection with a 'decode_error' alert for syntactically invalid messages.""}}]","The function checks that the incoming message is correctly parsed (by ensuring a valid length prefix and non-zero remaining data). Upon a parsing failure, it immediately sends a decode_error alert and terminates the connection. This behavior fully matches the specific portion of the RFC which mandates that a decode_error alert be issued when a message cannot be parsed according to the syntax.",success,
13926,tls_parse_ctos_ec_pt_formats,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_1(pkt, &ec_point_format_list) || PACKET_remaining(&ec_point_format_list) == 0) {', 'explanation': 'This segment checks that the extension data is present and of non-zero length, which corresponds to the condition that the extension must be validly formatted (i.e. not empty) as required by the spec. While the spec mandates a valid extension or aborting the handshake, this code only focuses on the EC point formats extension.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);', 'explanation': ""This segment implements the action to abort the handshake with a 'decode_error' alert when the extension parsing fails, matching the spec’s requirement to terminate the handshake on detecting malformed extension data.""}}]","The function attempts to implement part of the TLS RFC specification related to extension parsing by ensuring that the EC point formats extension is present and correctly formatted. If the extension is absent or empty, it aborts the handshake with a 'decode_error' alert. However, it solely focuses on the EC point formats extension, and other parts of the spec (such as dealing with additional extensions or further checks required by the full RFC) are not addressed within this function. Therefore, the function only partially meets the overall spec constraints.",success,
13928,tls_parse_ctos_sig_algs_cert,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'A1': {'code': 'if (!PACKET_as_length_prefixed_2(pkt, &supported_sig_algs) || PACKET_remaining(&supported_sig_algs) == 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': ""This code segment checks whether the incoming packet is correctly parsed (e.g., whether it has a proper 2-byte length prefix and non-zero remaining length). If not, it immediately terminates the connection by calling SSLfatal with a decode_error alert, which directly implements the TLS RFC requirement that peers receiving a malformed message must terminate the connection with a 'decode_error' alert.""}}]","The function explicitly ensures that if the packet cannot be parsed according to the expected syntax—as indicated by a failure of PACKET_as_length_prefixed_2 or an empty packet—it terminates the connection with a decode_error alert. This behavior visibly addresses the TLS RFC mandate regarding handling unparseable messages, so the function fully meets the stated specification within its own code.",success,
13928,tls_parse_ctos_sig_algs_cert,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'A1': {'code': 'if (!PACKET_as_length_prefixed_2(pkt, &supported_sig_algs) || PACKET_remaining(&supported_sig_algs) == 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': ""This code segment checks that the incoming packet is correctly formatted and not empty. If the check fails, it aborts the handshake by calling SSLfatal with a 'decode_error' alert, directly implementing the RFC requirement.""}}, {'A2': {'code': 'if (!s->hit && !tls1_save_sigalgs(s, &supported_sig_algs, 1)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': ""This branch further validates and saves the signature algorithms. If the saving step fails (for a fresh connection), it also aborts the handshake with a 'decode_error' alert, reinforcing the error handling mandated by the RFC.""}}]","The function inspects the signature algorithms extension by checking its length and content. In both cases—either an invalid/malformed packet or failure during processing—the function aborts the handshake with a decode_error alert, which directly conforms to the specified TLS RFC requirement.",success,
13929,tls_parse_ctos_sig_algs,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_2(pkt, &supported_sig_algs) || PACKET_remaining(&supported_sig_algs) == 0)', 'explanation': 'This segment checks that the client’s signature algorithms extension is present and that its length is non-zero. This aligns with the requirement to verify the extension data before proceeding.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);', 'explanation': 'This action immediately aborts the handshake with a decode_error alert if the verification condition fails, precisely implementing the specified behavior from the RFC.'}}]","The provided function explicitly validates that the signature algorithms extension is present and has a valid (non-zero) length, and it takes corrective action by aborting the handshake with a decode_error alert if the check fails. Thus, within its isolated logic, it fully implements the specified condition (C1) and action (A1) from the RFC constraints.",success,
13929,tls_parse_ctos_sig_algs,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_2(pkt, &supported_sig_algs) || PACKET_remaining(&supported_sig_algs) == 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This code block checks that the incoming message is properly formatted by verifying the length prefix and ensuring there is data. If either check fails, it terminates the connection with a decode_error alert, which directly implements the RFC requirement for handling syntactically invalid messages.'}}]","The function directly addresses the TLS RFC requirement by verifying the syntactic validity of the message. When the packet fails to meet the expected length format or contains no data, it triggers SSLfatal with a decode_error alert. This fulfills the spec constraint that peers receiving a syntactically incorrect message must terminate the connection with a decode_error alert.",success,
13930,tls_parse_ctos_status_request,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_1(pkt, (unsigned int *)&s->ext.status_type)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}\n\nif (!PACKET_get_length_prefixed_2(pkt, &responder_id_list)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}\n\nwhile (PACKET_remaining(&responder_id_list) > 0) {\n    ...\n    if (!PACKET_get_length_prefixed_2(&responder_id_list, &responder_id) || PACKET_remaining(&responder_id) == 0) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n        return 0;\n    }\n    ...\n    if (id == NULL) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n        return 0;\n    }\n    ...\n    if (id_data != PACKET_end(&responder_id)) {\n        OCSP_RESPID_free(id);\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n        return 0;\n    }\n}\n\nif (!PACKET_as_length_prefixed_2(pkt, &exts)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}\n\nif (s->ext.ocsp.exts == NULL || ext_data != PACKET_end(&exts)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'The function performs multiple syntactic checks on the received message. Any failure in parsing (e.g., reading a byte, length-prefixed fields, or improper data boundaries) results in an immediate call to SSLfatal with the decode_error alert, directly matching the RFC requirement about terminating the connection on parse errors.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);', 'explanation': 'In each error-checking branch, the function invokes SSLfatal with SSL_AD_DECODE_ERROR, ensuring that a decode_error alert is sent as specified when a message cannot be parsed correctly.'}}]",The provided code function implements the RFC requirement by thoroughly checking the syntax of the incoming message (using various PACKET_get and boundary-check functions) and immediately terminating the connection with a 'decode_error' alert (via SSLfatal) when any syntactic anomaly is detected. This fulfills both the condition that incorrectly parsed messages must trigger a termination and the action of sending a decode_error alert directly in the function.,success,
13930,tls_parse_ctos_status_request,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Does Not Match,[],"The provided function tls_parse_ctos_status_request is dedicated solely to parsing the OCSP status_request extension (including responder IDs and request extensions) and aborts the handshake with a 'decode_error' alert when parsing failures occur. The RFC specification provided, however, focuses on verifying that no superfluous data exists after the legacy_compression_methods field (or that a valid extensions block with no extra data follows) and mandates aborting the handshake with a 'decode_error' alert if this check fails. Since this function does not check for trailing bytes after legacy_compression_methods nor does it validate a general extensions block in that context, it does not implement the specified TLS RFC requirement within its own logic.",success,
13932,tls_parse_ctos_alpn,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_2(pkt, &protocol_list) || PACKET_remaining(&protocol_list) < 2) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This segment verifies that the packet contains a valid length‐prefixed ALPN list and that the remaining data is at least 2 bytes. If not, it terminates the connection by raising a decode_error alert, thereby enforcing the requirement to abort on parsing errors.'}}, {'C2': {'code': 'if (!PACKET_get_length_prefixed_1(&protocol_list, &protocol) || PACKET_remaining(&protocol) == 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': ""This segment iterates through the protocol names, ensuring that each length‐prefixed protocol is non-empty. If an empty protocol name is encountered (or if the extraction fails), the connection is terminated with a decode_error alert, aligning with the RFC's mandate on handling syntactic errors.""}}]",The function tls_parse_ctos_alpn validates the ALPN extension by checking the integrity of the packet through length-prefixed parsing. When the packet's format is invalid—either by an incorrect overall length or by having an empty protocol name—the function calls SSLfatal with SSL_AD_DECODE_ERROR to terminate the connection. This behavior directly implements the RFC requirement that messages which cannot be parsed according to the syntax must trigger a decode_error alert.,success,
13932,tls_parse_ctos_alpn,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'A1': {'code': 'if (!PACKET_as_length_prefixed_2(pkt, &protocol_list) || PACKET_remaining(&protocol_list) < 2) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}\n\n...\n\nif (!PACKET_get_length_prefixed_1(&protocol_list, &protocol) || PACKET_remaining(&protocol) == 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': ""According to the RFC snippet provided, if the data is not formatted as expected then the handshake must be aborted with a 'decode_error' alert. The function checks that the ALPN extension is correctly encoded (e.g., it has the proper length fields and non-empty protocol names) and calls SSLfatal with SSL_AD_DECODE_ERROR when these conditions are not met.""}}]","The function implements part of the RFC specification by explicitly verifying the structure of the ALPN extension and aborting the handshake with a 'decode_error' alert when the ALPN data is malformed. However, while it addresses the error handling mandated by the RFC, it only deals with the ALPN extension parsing and does not encompass all aspects of extension processing detailed in the TLS 1.3 context. Thus, the function only partially matches the full spectrum of conditions and actions expected by the RFC.",success,
13935,tls_parse_ctos_psk_kex_modes,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided code function (tls_parse_ctos_psk_kex_modes) is dedicated solely to parsing the PSK key exchange modes from a ClientHello message in TLS 1.3. It does not contain any logic that addresses or implements restrictions related to the status_request_v2 extension, such as ignoring its presence in the ClientHello or avoiding its transmission in EncryptedExtensions, CertificateRequest, or Certificate messages. As a result, none of the spec constraints concerning the handling of the status_request_v2 extension (which are detailed in the RFC specification) are addressed within this function.",success,
13935,tls_parse_ctos_psk_kex_modes,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, tls_parse_ctos_psk_kex_modes, is focused on parsing PSK key exchange modes in TLS 1.3. It does not contain any logic or checks related to the prohibition of RC4 cipher suites as specified in the RFC requirements (e.g., 'MUST NOT offer or negotiate RC4 cipher suites'). Therefore, this function does not satisfy any of the spec constraints regarding RC4 cipher suites.",success,
13935,tls_parse_ctos_psk_kex_modes,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_1(pkt, &psk_kex_modes) || PACKET_remaining(&psk_kex_modes) == 0) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n        return 0;\n    }', 'explanation': 'This segment verifies that the incoming message has a proper length prefix and non-zero content. If the parsing fails, it calls SSLfatal with a decode_error alert, directly addressing the spec requirement for handling syntactical parsing errors.'}}]","The function handles one of the main requirements from the spec by checking if the message is improperly formatted (e.g. bad length prefix or empty content) and terminating the connection with a decode_error alert. However, it does not address the case of semantically invalid messages (which should trigger an illegal_parameter alert), so it only partially implements the full specification.",success,
13935,tls_parse_ctos_psk_kex_modes,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_1(pkt, &psk_kex_modes) || PACKET_remaining(&psk_kex_modes) == 0) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n        return 0;\n    }', 'explanation': 'This segment verifies that the extension data for PSK key exchange modes is present and non-empty. If not, it aborts the handshake with a decode_error alert, thereby addressing the spec requirement \'if not, then it MUST abort the handshake with a ""decode_error"" alert.\''}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);', 'explanation': 'This call ensures that the handshake is aborted when the extension data is incorrectly formatted or missing, directly implementing the action to stop the handshake as per the specification.'}}]","The function implements a direct check for valid PSK key exchange modes data and aborts the handshake with a decode_error alert if the data is missing or empty. This addresses part of the RFC specification provided. However, while the code does handle the decoding error condition per the spec, it does not incorporate additional checks related to other extension specific requirements in TLS (such as ensuring proper placement or absence of trailing data after legacy_compression_methods) that are mentioned in the broader specification context. Thus, only a subset of the spec constraints is visible in this function.",success,
13937,extract_keyshares,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2(key_share_list, &group_id)\n        || !PACKET_get_length_prefixed_2(key_share_list, &encoded_pubkey)\n        || PACKET_remaining(&encoded_pubkey) == 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto failure;\n}', 'explanation': 'This segment explicitly checks if the incoming message cannot be parsed (for example, the encoded public key has invalid length or boundaries) and then calls SSLfatal with a decode_error alert, thus terminating the connection as required by the RFC for syntactic parse errors.'}}, {'C2': {'code': 'if (!check_in_list(s, group_id, clntgroups, clnt_num_groups, 0, &key_share_pos)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    goto failure;\n}', 'explanation': ""This code validates that the key share’s group id exists within the client's supported groups. If the check fails, it terminates the connection with an illegal_parameter alert, which aligns with the RFC requirement for semantically invalid messages.""}}]","The function 'extract_keyshares' directly addresses the TLS RFC requirements by performing thorough parsing of the key share message. It checks for parse errors (e.g., message length issues) and immediately terminates the connection with a decode_error alert when such errors are detected, as mandated by the spec. It also checks for semantic validity (e.g., ensuring the key share belongs to a supported group) and sends an illegal_parameter alert upon failure. These implementations, solely within the function itself and independent of any external dependencies, fully meet the constraints specified in the RFC.",success,
13937,extract_keyshares,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (s->s3.group_id != 0\n        && (group_id != s->s3.group_id\n            || PACKET_remaining(key_share_list) != 0)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    goto failure;\n}', 'explanation': 'This code checks that when a Hello Retry Request (HRR) has been sent (s->s3.group_id != 0), the returned key share must match the expected group and be the only one sent. If not, it terminates the connection with an illegal_parameter alert, directly addressing the spec requirement for semantically invalid messages.'}}, {'A1': {'code': 'if (!check_in_list(s, group_id, clntgroups, clnt_num_groups, 0, &key_share_pos)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    goto failure;\n}', 'explanation': 'This segment verifies that the received key share is among the supported groups provided by the client. If it is not, the connection is terminated via SSLfatal with an illegal_parameter alert, complying with the action mandated by the TLS RFC when a semantically invalid key share is received.'}}, {'A2': {'code': 'if (!PACKET_get_net_2(key_share_list, &group_id)\n        || !PACKET_get_length_prefixed_2(key_share_list, &encoded_pubkey)\n        || PACKET_remaining(&encoded_pubkey) == 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto failure;\n}', 'explanation': 'This code snippet checks for syntactic errors (e.g., improperly parsed data) and terminates the connection with a decode_error alert if the message cannot be fully parsed, which aligns with the TLS RFC’s requirement for handling syntactically incorrect messages.'}}]",The function extract_keyshares implements key parts of the TLS RFC concerning error handling for both syntactically invalid and semantically invalid messages. It verifies that the received key shares conform to the expected protocol behavior—such as matching the expected group in a Hello Retry Request and being present in the client's supported groups—and terminates the connection with either a decode_error or illegal_parameter alert as specified. This direct checking within the function satisfies the spec constraints independently of any dependency functions.,success,
13937,extract_keyshares,"However, the values MAY be a non-contiguous subset of the ""supported_groups"" extension and MAY omit the most preferred groups.",121,Fully Matches,"[{'C1': {'code': 'if (!check_in_list(s, group_id, clntgroups, clnt_num_groups, 0, &key_share_pos)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    goto failure;\n}', 'explanation': ""This segment verifies that each received KeyShareEntry corresponds to a group present in the client's supported_groups extension. It ensures that the key share is a member of a non‑contiguous subset allowed by the RFC and aborts if not.""}}, {'A1': {'code': 'if (key_share_pos < previous_key_share_pos)\n    OSSL_TRACE1(TLS, ""key share group id %d is out of RFC 8446 order\\n"", group_id);', 'explanation': ""This code checks and logs when the order of KeyShareEntries does not match the order in the supported_groups extension. It tolerates out‐of‐order shares by merely logging a trace message rather than aborting, reflecting the RFC's allowance for a non‑contiguous subset.""}}, {'A2': {'code': 'if (s->s3.group_id != 0 && (group_id != s->s3.group_id || PACKET_remaining(key_share_list) != 0)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    goto failure;\n}', 'explanation': 'This segment handles the HelloRetryRequest scenario by ensuring that if an HRR was sent, the only incoming key share is for the expected group and that no extra shares are provided.'}}]","The function 'extract_keyshares' visibly implements the requirements specified by the RFC regarding the processing of client key shares. It checks that every received share is from a permitted group (C1), tolerates a non‑contiguous ordering by logging any discrepancy (A1), and enforces the stricter rules required during a HelloRetryRequest (A2). Therefore, within its own code, the function fully addresses the constraints of the specification.",success,
13937,extract_keyshares,"Clients MUST NOT offer any KeyShareEntry values for groups not listed in the client's ""supported_groups"" extension",124,Fully Matches,"[{'C1': {'code': 'if (!check_in_list(s, group_id, clntgroups, clnt_num_groups, 0, &key_share_pos)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    goto failure;\n}', 'explanation': ""This code segment directly ensures that the received KeyShareEntry group_id is among the client's offered supported_groups. If not, it aborts the handshake with an 'illegal_parameter' alert, thus enforcing the RFC requirement that clients must not offer any KeyShareEntry values for groups not listed in the supported_groups extension.""}}]","The function inspects each key share in the provided list and uses check_in_list() to verify that the group_id is present in the client's supported_groups list. By triggering an error if the group is not found, the function alone visibly implements the constraint from the TLS RFC that forbids clients from offering unsupported groups. Other aspects mentioned in the RFC (such as order preservation and key generation) are logged or deferred to other parts of the code, but with respect to the specific requirement, the function fully matches the specification.",success,
13937,extract_keyshares,"Servers MAY check for violations of these rules and abort the handshake with an ""illegal_parameter"" alert if one is violated.",125,Partially Matches,"[{'C1': {'code': 'if (!check_in_list(s, group_id, clntgroups, clnt_num_groups, 0, &key_share_pos)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    goto failure;\n}', 'explanation': ""This segment checks that each key share’s group is present in the client's supported_groups extension. It aborts the handshake with an illegal_parameter alert if the group is not found.""}}, {'A1': {'code': 'if (s->s3.group_id != 0\n        && (group_id != s->s3.group_id\n            || PACKET_remaining(key_share_list) != 0)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    goto failure;\n}', 'explanation': 'This code enforces the HelloRetryRequest rule by ensuring that when an HRR is in effect (s->s3.group_id != 0), the returned key share is for the requested group and that it is the only key share present.'}}]","The function addresses some of the key aspects specified in the RFC. It verifies that each key share entry corresponds to a group offered in the client's supported_groups extension and enforces that in a HelloRetryRequest scenario only a single, expected key share is present. However, while the RFC mandates that key shares appear in the same order and prohibits duplicate key share entries for the same group, the function merely logs a trace when the ordering is not correct and does not explicitly reject duplicate groups. Thus, not all constraints are fully implemented within this function, leading to a 'Partially Matches' judgment.",success,
13939,tls_parse_ctos_key_share,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_2(pkt, &key_share_list)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}', 'explanation': 'This segment checks whether the packet length is within expected bounds (i.e. syntactic validation). If the message appears to have an invalid length (a parsing error), it terminates the connection with a decode_error alert, fulfilling the part of the RFC regarding syntactically invalid messages.'}}, {'A1': {'code': 'if (s->s3.group_id != 0 && PACKET_remaining(&key_share_list) == 0) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    return 0;\n}', 'explanation': 'This segment handles the situation where a key share is expected but not provided (a semantic error). It immediately terminates the connection using an illegal_parameter alert, thereby implementing the RFC mandate for handling semantically invalid messages.'}}]","The function visibly implements the TLS RFC requirements regarding error handling during key share parsing. It first verifies the syntax of the incoming message, triggering a decode_error alert if the length is off, and then checks semantic correctness by ensuring that a key share is present when expected (in the context of a HelloRetryRequest). When a semantic inconsistency is found, it terminates the connection with an illegal_parameter alert. Thus, in isolation, the function covers both syntactic and semantic error cases as required by the specification.",success,
13939,tls_parse_ctos_key_share,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_2(pkt, &key_share_list)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}', 'explanation': 'This code block verifies that the key share list is properly framed by a two‐byte length prefix. If the parsing fails (for example because the length is out‐of-range or the packet is malformed), it terminates the connection with a decode_error alert, directly addressing the RFC requirement for syntactic parsing errors.'}}, {'A1': {'code': 'if (s->s3.group_id != 0 && PACKET_remaining(&key_share_list) == 0) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    return 0;\n}', 'explanation': 'This block handles the case where a message is syntactically correct but semantically invalid (e.g., when a key share is missing after an HRR request). It terminates the connection with an illegal_parameter alert, which is in line with the RFC provision for handling semantically invalid messages.'}}]","The function 'tls_parse_ctos_key_share' includes explicit checks that ensure a message which cannot be properly parsed (using PACKET_as_length_prefixed_2) triggers a termination with a decode_error alert, and that a syntactically correct but semantically unsuitable message causes termination with an illegal_parameter alert. These measures directly implement the alert handling as specified in the TLS RFC. Although additional error and key share negotiation logic exists in the function, the components addressing the critical syntax and semantic error conditions are present, and thus the function fully addresses the provided RFC requirements within its own code.",success,
13939,tls_parse_ctos_key_share,"If the server selects an (EC)DHE group and the client did not offer a compatible ""key_share"" extension in the initial ClientHello, the server MUST respond with a HelloRetryRequest (Section 4.1.4) message.",9,Partially Matches,"[{'C1': {'code': ""if (s->s3.group_id != 0 && PACKET_remaining(&key_share_list) == 0) {\n        /* If we set a group_id already, then we must have sent an HRR\n         * requesting a new key_share. If we haven't got one then that is an error */\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n        return 0;\n    }\n\n    ...\n\n    /* In the absence of a key share overlap, record a candidate group */\n    check_overlap(s,\n                  first_group_in_tuple, number_of_groups_in_tuple,\n                  clntgroups, clnt_num_groups,\n                  &prio_group_idx, &candidate_group_idx,\n                  &group_id_candidate);\n    if (group_id_candidate > 0) {\n        s->s3.group_id_candidate = group_id_candidate;\n        goto end;\n    }"", 'explanation': 'This segment implements decision logic for group selection. It checks if a key share is missing when a group was already set (implying an expected key share response) and, in other cases, saves a candidate group when no compatible key share is provided. This mirrors the RFC requirement that the server must send a HelloRetryRequest if the client did not offer a compatible key_share, although the actual HRR response is handled elsewhere.'}}]","The function undertakes key share extraction and group selection based on the client's and server's parameters. It explicitly checks for cases where a key share extension is missing (or incompatible) when a particular (EC)DHE group has been selected, by setting a candidate group and emitting an error if expected conditions are not met. However, it does not itself generate the HelloRetryRequest message required by the RFC; rather, it sets internal state (s3.group_id_candidate) that signals to higher layers that an HRR is required. Thus, the function partially implements the RFC constraint by addressing the conditions, but defers the action (sending HRR) to other components.",success,
13940,tls_parse_ctos_cookie,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided code function (tls_parse_ctos_cookie) is focused solely on parsing and validating TLS 1.3 cookies and performing related handshake processing. There is no visible logic within the function that enforces or even checks that the OpenPGP certificate type (RFC6091) is not used with TLS 1.3, which is the specified constraint. As a result, none of the conditions or actions (e.g., C1/A1) related to the certificate type restriction are implemented in this function.",success,
13940,tls_parse_ctos_cookie,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function, tls_parse_ctos_cookie, is focused solely on parsing and verifying a stateless cookie in the context of a TLS 1.3 handshake. It performs operations such as HMAC verification, cookie format checks, version checks, and even reconstructs parts of a HelloRetryRequest message. There is no visible logic or condition that pertains to handling or ignoring the status_request_v2 extension as specified in the RFC. In particular, the function does not address the requirement that TLS 1.3 servers must not act upon any information in the status_request_v2 extension when processing ClientHello messages, nor does it implement any actions to prevent sending that extension in response (EncryptedExtensions, CertificateRequest, or Certificate messages). The absence of any checks or implementations related to the status_request_v2 extension leads to the conclusion that the function does not meet the spec constraints.",success,
13940,tls_parse_ctos_cookie,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_2(pkt, &cookie)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}\n\n... (other similar checks using PACKET_forward and PACKET_get_net_* functions)', 'explanation': 'The function verifies that portions of the message (the cookie and its fields) are within expected bounds. When these conditions fail (for example, when the length of data is less than required or forwarding fails), it calls SSLfatal with the decode_error alert, exactly as required by the spec for messages that cannot be parsed.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);', 'explanation': ""This call terminates the connection with a 'decode_error' alert whenever a syntactic parsing error is encountered, fulfilling the action requirement stated in the RFC.""}}]","The provided function implements several parsing checks for the cookie in the client message. When any parsing issue is encountered (for example, an out-of-bound length or failure to parse a length‐prefixed field), the function immediately calls SSLfatal with SSL_AD_DECODE_ERROR, effectively terminating the connection as required. Furthermore, the function differentiates between syntactic errors (triggering decode_error) and semantic errors (triggering illegal_parameter), which is in line with the TLS RFC. Thus, the code function by itself visibly implements the specified requirements.",success,
13940,tls_parse_ctos_cookie,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, tls_parse_ctos_cookie, is focused on validating cookies and reconstructing handshake messages rather than handling cipher suite negotiation. It does not contain any logic to check for, forbid, or refuse the use of RC4 cipher suites as required by the RFC specification. There is no code segment that inspects or rejects RC4, so none of the conditions (e.g., C1) or actions (e.g., A1) related to disallowing RC4 are addressed within this function.",success,
13940,tls_parse_ctos_cookie,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Partially Matches,"[{'C1': {'code': 'if (version != TLS1_3_VERSION) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER,\n             SSL_R_BAD_PROTOCOL_VERSION_NUMBER);\n    return 0;\n}', 'explanation': ""This code segment enforces that the cookie's version must exactly equal TLS1_3_VERSION. Since the spec requires that insecure protocol versions, such as SSL 3.0, MUST NOT be negotiated, rejecting any version other than TLS1.3 effectively prevents SSL 3.0 from being negotiated. Thus, this part of the TLS RFC constraint is addressed by the function.""}}]","The function implements a version check during cookie parsing that ensures only TLS 1.3 is accepted. This logic directly prevents a cookie from indicating SSL 3.0 (or any non-TLS1.3 version), thereby satisfying the portion of the RFC constraint regarding SSL 3.0 being disallowed. However, other aspects mentioned in the spec context, such as disallowing low strength ciphers, are not addressed within this function. Therefore, while the function does visibly enforce the no SSL 3.0 policy (thus partially matching the specified constraint), it does not handle all conditions mentioned within the broader spec, leading to a partial match overall.",success,
13940,tls_parse_ctos_cookie,"In TLS 1.3, the TLS server indicates its version using the ""supported_versions"" extension (Section 4.2.1), and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.",29,Fully Matches,"[{'C1': {'code': 'WPACKET_put_bytes_u16(&hrrpkt, TLS1_2_VERSION)', 'explanation': 'This code segment sets the legacy_version field to TLS1_2_VERSION (0x0303), which is the required value per the TLS 1.3 specification for backward compatibility.'}}, {'A1': {'code': 'WPACKET_put_bytes_u16(&hrrpkt, TLSEXT_TYPE_supported_versions) ||\n            !WPACKET_start_sub_packet_u16(&hrrpkt) ||\n            !WPACKET_put_bytes_u16(&hrrpkt, s->version) ||\n            !WPACKET_close(&hrrpkt)', 'explanation': ""This block constructs the supported_versions extension, using s->version to indicate the server's TLS version, thereby following the TLS 1.3 RFC requirement.""}}]",The function reconstructs a synthetic HelloRetryRequest by building a message that explicitly sets the legacy_version field to TLS1_2_VERSION (i.e. 0x0303) and includes the supported_versions extension with the server's version. These segments directly implement the TLS 1.3 RFC requirement that the legacy_version field must be set to TLS 1.2 (0x0303) while indicating the actual version via the supported_versions extension. All relevant constraints are handled within this function.,success,
13940,tls_parse_ctos_cookie,"The server's extensions MUST contain ""supported_versions""",45,Fully Matches,"[{'C1': {'code': 'if (!WPACKET_put_bytes_u16(&hrrpkt, TLSEXT_TYPE_supported_versions)\n            || !WPACKET_start_sub_packet_u16(&hrrpkt)\n            || !WPACKET_put_bytes_u16(&hrrpkt, s->version)\n            || !WPACKET_close(&hrrpkt)) {\n        WPACKET_cleanup(&hrrpkt);\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }', 'explanation': ""This segment explicitly adds the 'supported_versions' extension to the reconstructed HelloRetryRequest message, thereby fulfilling the RFC requirement that the server's extensions MUST contain 'supported_versions'.""}}]","The function 'tls_parse_ctos_cookie' includes code that reconstructs the HRR message and explicitly inserts the 'supported_versions' extension by writing the TLSEXT_TYPE_supported_versions field along with the server's protocol version (s->version). This directly addresses the spec constraint requiring that the server's extensions include 'supported_versions', thus fully implementing the specified requirement within the scope of this function.",success,
13940,tls_parse_ctos_cookie,"Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello (if the server selects the cipher suite as the first step in the negotiation, then this will happen automatically).",53,Partially Matches,"[{'C1': {'code': 'if (group_id != s->s3.group_id || s->s3.tmp.new_cipher != ssl_get_cipher_by_char(s, ciphdata, 0)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_CIPHER);\n    return 0;\n}', 'explanation': 'This code segment checks that the cipher suite (and related group parameters) embedded in the cookie match the currently selected values in the server connection. This implements the requirement that the server must negotiate the same cipher suite when handling a revised ClientHello, addressing the core of the RFC specification.'}}]","The tls_parse_ctos_cookie function verifies a stateless cookie’s integrity and contents. In doing so, it checks that the cipher suite (and group id) recorded in the cookie match the ones currently selected by the server. This directly supports the RFC requirement that servers must negotiate the same cipher suite when receiving a conformant updated ClientHello. However, since other aspects of the TLS handshake are handled elsewhere, the function only partially implements the overall spec constraint within its isolated logic.",success,
13940,tls_parse_ctos_cookie,It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2).,73,Fully Matches,"[{'C1': {'code': 'if (!WPACKET_put_bytes_u16(&hrrpkt, TLS1_2_VERSION)\n            || !WPACKET_start_sub_packet_u24(&hrrpkt)\n            || !WPACKET_put_bytes_u16(&hrrpkt, s->version)\n            || !WPACKET_close(&hrrpkt)) { ... }', 'explanation': 'This segment of code reconstructs the HelloRetryRequest message and explicitly sets the legacy_version field via WPACKET_put_bytes_u16(&hrrpkt, TLS1_2_VERSION). TLS1_2_VERSION is almost certainly defined as 0x0303, which exactly meets the requirement to set ServerHello.legacy_version to TLS 1.2.'}}]","The function tls_parse_ctos_cookie, while primarily handling cookie verification and HRR reconstruction, contains explicit logic in the HRR packet construction where it sets the legacy_version field to TLS1_2_VERSION (i.e. 0x0303). Therefore, in isolation, the function visibly implements the specification requirement to set ServerHello.legacy_version to TLS 1.2 (0x0303).",success,
13941,tls_parse_ctos_supported_groups,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Partially Matches,[],"The provided function is responsible for parsing the supported groups extension received from the client. It validates that the length is correct (ensuring at least one group and that the byte length is a multiple of two) and then stores the list in the connection structure. This behavior aligns with the part of the RFC that states TLS 1.3 implementations might receive these values from older TLS implementations. However, the RFC also mandates that TLS 1.3 implementations MUST NOT send these reserved values, and there is no logic in this function that controls outgoing behavior (i.e. it does not prevent sending reserved groups, nor is it involved in sending at all). Thus, while the receive‐side aspect is partially addressed, the sending restriction is not implemented in this isolated function.",success,
13941,tls_parse_ctos_supported_groups,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The code function only performs packet validation and stores the parsed supported_groups data. It does not implement logic that prevents acting upon the supported_groups information prior to handshake completion nor does it use the information from a successfully completed handshake to update key_share usage. In other words, none of the specific conditions (e.g., ensuring the handshake is complete before using the information) or actions (e.g., updating client's key_share preferences based on the received supported_groups) defined in the RFC are handled solely within this function.",success,
13941,tls_parse_ctos_supported_groups,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'A1': {'code': 'if (!PACKET_as_length_prefixed_2(pkt, &supported_groups_list)\n        || PACKET_remaining(&supported_groups_list) == 0\n        || (PACKET_remaining(&supported_groups_list) % 2) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': ""This code segment checks if the packet cannot be parsed correctly (e.g., incorrect length or multiple issues) and responds by calling SSLfatal with SSL_AD_DECODE_ERROR, which terminates the connection in accordance with the RFC's requirement for a decode_error alert.""}}]","The function validates the syntax of the supported_groups message by ensuring that it has a proper two-byte length-prefixed list, a non-zero length, and an even number of remaining bytes. If any of these checks fail, it immediately terminates the connection with a decode_error alert. Thus, the function visibly fulfills the RFC specification for handling messages that cannot be parsed according to the syntax.",success,
13941,tls_parse_ctos_supported_groups,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, tls_parse_ctos_supported_groups, is solely concerned with parsing the supported groups extension from a client hello message. It validates the length of the list and saves the group's values if appropriate. There is no code in the function that pertains to cipher suite negotiation or explicitly prevents the use of RC4 cipher suites, which is the primary focus of the RFC specification provided (i.e., implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS). Therefore, none of the labeled conditions (e.g., C1 regarding RC4 prohibition) or actions are addressed within this function.",success,
13941,tls_parse_ctos_supported_groups,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_2(pkt, &supported_groups_list) || PACKET_remaining(&supported_groups_list) == 0 || (PACKET_remaining(&supported_groups_list) % 2) != 0)', 'explanation': 'This conditional checks that the supported_groups extension data is present, non-empty, and that its length is a multiple of 2 (each group is 2 bytes). It enforces the TLS requirement that the extension data must be correctly formatted.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);', 'explanation': 'If the conditions fail, the function aborts the handshake with a decode_error alert per the TLS RFC specification.'}}]","The function validates the format of the supported_groups extension in a ClientHello message. It checks that the packet contains a valid length-prefixed list of groups (each of 2 bytes) and, if not, immediately aborts the handshake with a 'decode_error' alert. This directly addresses the TLS RFC's mandate that, if the extension's data is invalid, the handshake must be aborted with a decode_error alert.",success,
13942,tls_parse_ctos_ems,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This code segment checks that the incoming packet for the extension is empty. According to the RFC, if the message is not parsable (such as having extra data), it must trigger a termination with a decode_error alert.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);', 'explanation': 'This call explicitly terminates the connection using a decode_error alert, fulfilling the action requirement by the RFC for malformed messages.'}}]","The function directly implements the RFC specification by ensuring that the extended master secret extension is empty. If any extra data is present, it immediately calls SSLfatal with the appropriate decode_error alert, thereby adhering to the specified constraints. All required actions are performed within this function, meaning it fully matches the specified requirements.",success,
13942,tls_parse_ctos_ems,"Otherwise, it MUST be set as a zero-length vector (i.e., a zero-valued single byte length field).",19,Fully Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This code verifies that the extension is empty – i.e., that the length is zero – exactly as required by the specification stating the field MUST be set as a zero-length vector.'}}, {'A1': {'code': 's->s3.flags |= TLS1_FLAGS_RECEIVED_EXTMS;', 'explanation': 'After successfully verifying the extension is empty, the code sets the appropriate flag to indicate that the Extended Master Secret was received. This action supports further protocol decisions downstream.'}}]","The function directly implements the RFC requirement that the Extended Master Secret extension must be an empty vector by explicitly checking that no extra bytes are present. Additionally, it sets a flag indicating the extension's receipt. Both of these actions are fully contained within the function_body, thereby fully matching the corresponding spec constraints.",success,
13942,tls_parse_ctos_ems,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 0) {', 'explanation': 'This check ensures that the extension is empty as required by the RFC specification.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);', 'explanation': ""This call aborts the handshake using a 'decode_error' alert when the extension is not empty.""}}]","The function verifies that the extended master secret extension is empty and immediately aborts the handshake with a decode_error alert if it detects any extra data, which directly addresses the specified RFC requirements.",success,
13943,tls_parse_ctos_early_data,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 0) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n        return 0;\n    }', 'explanation': 'This block ensures that if extra data is present in the packet—which would indicate a message that cannot be parsed properly—it terminates the connection with a decode_error alert, as required by the RFC.'}}, {'A1': {'code': 'if (s->hello_retry_request != SSL_HRR_NONE) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_EXTENSION);\n        return 0;\n    }', 'explanation': 'This block checks if the context indicates a semantically invalid situation (such as processing early data during a HelloRetryRequest) and terminates the connection using an illegal_parameter alert, directly implementing the semantic validation prescribed by the RFC.'}}]","The function_body implements two key aspects from the TLS RFC: it checks for syntactic issues (extra data causing a decode_error) and semantic issues (invalid context causing an illegal_parameter alert). Both error alerts are issued via SSLfatal, which aligns with the requirement to terminate the connection with fatal alerts. As the logic for detecting these conditions is wholly contained within the function, it fully matches the spec constraints.",success,
13943,tls_parse_ctos_early_data,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': ""This block checks if the packet has extra data (i.e. an error in syntax such as length extending beyond the message boundary) and terminates the connection with a decode_error alert, fulfilling the RFC's requirement for unparseable messages.""}}, {'C2': {'code': 'if (s->hello_retry_request != SSL_HRR_NONE) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This block handles the scenario where a syntactically correct but semantically invalid message is received (e.g., early data received during a HelloRetryRequest), terminating the connection with an illegal_parameter alert, as required by the RFC.'}}]","The function implements both key aspects of the TLS RFC requirement by checking if the received message contains extra data (indicating a syntax parse error) and by validating the context in which early data is received (ensuring that messages that are semantically incorrect trigger the appropriate alert). Both conditions result in calling SSLfatal() with the specified alerts, thereby fully matching the spec constraints as implemented in this function.",success,
13943,tls_parse_ctos_early_data,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 0) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n        return 0;\n    }', 'explanation': 'This segment checks that the packet contains no extra data and aborts the handshake with a decode_error alert if extra data is found, which corresponds to the spec requirement.'}}]","The function checks that there are no additional bytes in the received packet, and it aborts the handshake with a decode_error alert if extra bytes are present. This directly addresses one part of the spec (i.e., aborting when there is extraneous data). However, the overall spec context also requires handling of extensions (especially for TLS 1.3 negotiation) and additional conditions regarding legacy ClientHello formatting, which are not directly implemented within this function. Moreover, the additional check for hello_retry_request does not directly correlate with the provided spec. Thus, although the function attempts to implement one of the required checks, it does not fully cover all aspects of the specified TLS RFC.",success,
13945,tls_parse_ctos_psk,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_length_prefixed_2(pkt, &identities)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}\n\n...\n\nif (!PACKET_get_length_prefixed_2(&binders, &binder)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    goto err;\n}\n\nif (PACKET_remaining(&binder) != (size_t)hashsize) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    goto err;\n}', 'explanation': ""The function performs several packet-parsing checks. When a parsing error occurs (such as a length extraction failure or binder length mismatch), it immediately calls SSLfatal with SSL_AD_DECODE_ERROR. This behavior directly implements the TLS RFC requirement to terminate the connection with a 'decode_error' alert when a message cannot be parsed according to the syntax.""}}]","The target function visibly implements the TLS RFC specification by checking the syntax of received messages via several PACKET extraction routines. In cases where the message cannot be parsed—due to out-of-range lengths or other malformed inputs—it calls SSLfatal with the decode_error alert. Therefore, this single function fully addresses the specified condition from the RFC without relying on its dependencies.",success,
13945,tls_parse_ctos_psk,"Once all the values which are to be derived from a given secret have been computed, that secret SHOULD be erased.",325,Fully Matches,"[{'A1': {'code': 'OPENSSL_cleanse(pskdata, pskdatalen);', 'explanation': 'The spec requires that once all values derived from a secret are computed, the secret should be erased. In the function, after using the PSK data (from the callback), the code explicitly calls OPENSSL_cleanse to erase the pskdata buffer, thereby fulfilling this action.'}}]","The TLS RFC spec mandates that a secret used to derive values shall be erased once those values are computed. In the provided function, the only secret material that is processed (i.e., the PSK data) is cleaned up via OPENSSL_cleanse immediately after it is used. This cleansing occurs in both the successful and error paths, ensuring that the secret is removed from memory once its purpose is served. Thus, the function visibly implements the secret erasure requirement from the RFC.",success,
13945,tls_parse_ctos_psk,Servers SHOULD provide that level of replay safety by implementing one of the methods described in this section or by equivalent means.,334,Fully Matches,"[{'C1': {'code': 'if (s->max_early_data > 0\n                    && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0\n                    && !SSL_CTX_remove_session(s->session_ctx, sess)) {\n                SSL_SESSION_free(sess);\n                sess = NULL;\n                continue;\n            }', 'explanation': 'This code block implements a replay safety mechanism by ensuring that if early data (0-RTT) is enabled (s->max_early_data > 0) and anti-replay protections are not disabled, the session is removed (using SSL_CTX_remove_session) once it is accepted. This prevents the same 0-RTT handshake from being accepted more than once, fulfilling the replay protection requirement described in the RFC.'}}]","The function tls_parse_ctos_psk contains explicit logic for replay safety: it checks conditions for early data usage, verifies ticket age tolerances, and most importantly, uses SSL_CTX_remove_session to ensure that a session (and thus associated 0-RTT data) is accepted at most once. This addresses the key spec requirement that servers must implement replay protection for early data, meeting the constraint by itself.",success,
13945,tls_parse_ctos_psk,Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection.,241,Partially Matches,"[{'C1': {'code': 'md = ssl_md(sctx, sess->cipher->algorithm2);\nif (!EVP_MD_is_a(md, EVP_MD_get0_name(ssl_md(sctx, s->s3.tmp.new_cipher->algorithm2)))) {\n    /* The ciphersuite is not compatible with this session. */\n    SSL_SESSION_free(sess);\n    sess = NULL;\n    s->ext.early_data_ok = 0;\n    s->ext.ticket_expected = 0;\n    continue;\n}', 'explanation': ""This segment retrieves the message digest associated with the original session's cipher (which determines the KDF hash algorithm) and compares it to the digest of the new cipher suite. If they do not match, the ticket is discarded. This implements the core requirement that a ticket may only be resumed if the cipher suite uses the same KDF hash algorithm as the original connection.""}}]","The function contains logic that enforces the RFC requirement of matching the KDF hash algorithm between the original session and the resumed session (as seen by comparing the digest values). However, the RFC specification also includes conditions regarding the validation of the SNI and server certificate, which are not addressed within this function. Therefore, while this function enforces the KDF hash algorithm matching requirement, it only partially implements the full set of constraints described in the RFC.",success,
13945,tls_parse_ctos_psk,"For PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued (see Section 8).",145,Fully Matches,"[{'C1': {'code': 'age = ossl_time_subtract(ossl_ms2time(ticket_agel), ossl_ms2time(sess->ext.tick_age_add));\n            t = ossl_time_subtract(ossl_time_now(), sess->time);\n            expire = ossl_time_add(t, ossl_ms2time(1000));\n            if (id == 0\n                    && ossl_time_compare(sess->timeout, t) >= 0\n                    && ossl_time_compare(age, expire) <= 0\n                    && ossl_time_compare(ossl_time_add(age, TICKET_AGE_ALLOWANCE), expire) >= 0) {\n                s->ext.early_data_ok = 1;\n            }', 'explanation': 'This segment computes the effective ticket age by subtracting the stored tick_age_add from the obfuscated ticket age and compares it against the elapsed time since the ticket issuance (plus a small 1000ms adjustment) with an additional allowance (TICKET_AGE_ALLOWANCE). It directly implements the RFC requirement to verify that the ticket age is within a small tolerance.'}}, {'A1': {'code': 'if (id == 0\n                    && ossl_time_compare(sess->timeout, t) >= 0\n                    && ossl_time_compare(age, expire) <= 0\n                    && ossl_time_compare(ossl_time_add(age, TICKET_AGE_ALLOWANCE), expire) >= 0) {\n                s->ext.early_data_ok = 1;\n            }', 'explanation': ""This conditional not only validates the ticket age but also determines whether early data (0-RTT) is acceptable. If the ticket age is not within the allowed tolerance, early data is rejected, consistent with the spec's directive to proceed with the handshake but not to assume the ClientHello is fresh.""}}]",The function explicitly computes the ticket age by subtracting the ticket_age_add value from the obfuscated ticket age and compares it with the elapsed time since the ticket's issuance (with an added margin for network latency). This check and subsequent decision to mark or reject early data directly address both the condition and the action required by the RFC for PSKs provisioned via NewSessionTicket.,success,
13945,tls_parse_ctos_psk,"The PSK used to encrypt the early data MUST be the first PSK listed in the client's ""pre_shared_key"" extension.",144,Fully Matches,"[{'C1': {'code': 'if (sess != NULL) {\n    ...\n    if (id == 0)\n        s->ext.early_data_ok = 1;\n    s->ext.ticket_expected = 1;\n    ...\n}\n\n...\nif (id == 0\n    && ossl_time_compare(sess->timeout, t) >= 0\n    && ossl_time_compare(age, expire) <= 0\n    && ossl_time_compare(ossl_time_add(age, TICKET_AGE_ALLOWANCE), expire) >= 0) {\n    /* Ticket age is within tolerance and not expired. We allow it\n     * for early data */\n    s->ext.early_data_ok = 1;\n}', 'explanation': 'The code explicitly checks if the currently processed PSK identity is the first in the list (by verifying that id == 0) and only then enables early data by setting s->ext.early_data_ok to 1. This directly implements the requirement that the PSK used to encrypt early data must be the first PSK listed in the client\'s ""pre_shared_key"" extension.'}}]","The function iterates over the PSK identities provided by the client and, when a valid PSK session is found, it enables early data only if the processed identity is the first one (id == 0). Both branches (using external PSK callback and NewSessionTicket with ticket age check) ensure that early data is enabled solely for the first identity, thereby meeting the RFC specification constraint.",success,
13945,tls_parse_ctos_psk,"Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value (see Section 4.2.11.2 below).",165,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_length_prefixed_2(pkt, &binders)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    goto err;\n}\n\n...\n\nif (PACKET_remaining(&binder) != (size_t)hashsize) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    goto err;\n}\nif (tls_psk_do_binder(s, md, (const unsigned char *)s->init_buf->data,\n                      binderoffset, PACKET_data(&binder), NULL, sess, 0, ext) != 1) {\n    // SSLfatal() is called inside tls_psk_do_binder if validation fails\n    goto err;\n}', 'explanation': 'The RFC requires that prior to accepting a PSK key establishment, the server must validate the corresponding binder value. In this function, after parsing the PSK identities, it obtains the binder list, selects the binder corresponding to the chosen PSK, checks that its length matches the expected hash size (ensuring presence of the binder), and then calls tls_psk_do_binder to perform the validation. If any of these checks fail, the function aborts the handshake by calling SSLfatal and returning an error.'}}]","The function implements the critical part of the TLS RFC requirement by explicitly validating the binder value before accepting PSK key establishment. It ensures that a binder is present, of the expected length, and properly validated; if not, it aborts the handshake. This directly addresses the spec constraint that mandates binder validation, thereby fully matching the requirement.",success,
13945,tls_parse_ctos_psk,"Any unknown PSKs (e.g., ones not in the PSK database or encrypted with an unknown key) SHOULD simply be ignored.",162,Fully Matches,"[{'C1': {'code': 'if (ret == SSL_TICKET_NONE || ret == SSL_TICKET_NO_DECRYPT)\n    continue;', 'explanation': 'This code segment shows that when a PSK cannot be decrypted or is not found (i.e. an unknown PSK), the function simply ignores it by continuing to the next identity rather than aborting the handshake. This behavior directly implements the RFC requirement that unknown PSKs be ignored.'}}]","The function scans through the provided PSK identities and, upon failing to retrieve or decrypt a valid PSK (i.e. when the PSK is unknown), it simply continues the loop rather than treating it as an error, which matches the RFC specification. Additionally, if no valid PSK is found, the function returns 1, thus allowing a non-PSK handshake to proceed. Both aspects confirm that the function meets the specified condition.",success,
13945,tls_parse_ctos_psk,"Servers SHOULD NOT attempt to validate multiple binders; rather, they SHOULD select a single PSK and validate solely the binder that corresponds to that PSK.",167,Fully Matches,"[{'C1': {'code': 'for (id = 0; PACKET_remaining(&identities) != 0; id++) { ... if (sess != NULL) { ... break; } ...\n\nfor (i = 0; i <= id; i++) {\n    if (!PACKET_get_length_prefixed_1(&binders, &binder)) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n        goto err;\n    }\n}\n\nif (PACKET_remaining(&binder) != (size_t)hashsize) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    goto err;\n}\n\nif (tls_psk_do_binder(s, md, (const unsigned char *)s->init_buf->data,\n                      binderoffset, PACKET_data(&binder), NULL, sess, 0, ext) != 1) {\n    goto err;\n}\n\ns->ext.tick_identity = id;', 'explanation': 'The function iterates through multiple PSK identities but, upon finding a valid session (PSK), it breaks out of the loop and then proceeds to retrieve and validate only the binder corresponding to the selected PSK. This directly implements the RFC requirement that servers should not validate multiple binders, but rather select a single PSK and validate solely its corresponding binder.'}}]","The code function reviews all provided PSK identities until it finds one with an associated valid session, then breaks out of the loop. It then selects the binder corresponding to that single PSK and validates it using tls_psk_do_binder, thereby ensuring that only one binder is validated as per the TLS RFC specification. This demonstrates a full match to the constraint specified in the RFC.",success,
13945,tls_parse_ctos_psk,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function is focused on parsing PSK extensions, ticket decryption, and setting flags (such as early_data_ok and ticket_expected) based on the received PSK identity and ticket validity. However, it does not contain any logic to decide whether or not to automatically retransmit early data based on the negotiated ALPN protocol or to prevent automatic retransmission of early data, which is the core requirement of the TLS RFC specification provided. In short, while it marks early data as acceptable in certain conditions, it does not implement the constraint that a TLS implementation SHOULD NOT automatically resend early data unless the negotiated ALPN protocol is the same, thus failing to address the spec constraints directly within this function.",success,
13945,tls_parse_ctos_psk,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_length_prefixed_2(pkt, &identities)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This branch checks for correct parsing of the identities field and aborts the handshake with a decode_error alert if the data is malformed.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);', 'explanation': 'Multiple parts of the code (for example, during identity and binder parsing) call SSLfatal with SSL_AD_DECODE_ERROR to abort the handshake when extension data does not meet the expected format, in line with the spec requirement.'}}]","The function tls_parse_ctos_psk consistently validates the PSK extension fields. In cases where the expected data is not present or malformed, the code aborts the handshake by calling SSLfatal with a decode_error alert. This directly implements the specified TLS RFC requirement (i.e. if not valid, then abort the handshake with a decode_error alert) within the function body.",success,
13945,tls_parse_ctos_psk,The server MUST ensure that it selects a compatible PSK (if any) and cipher suite.,160,Fully Matches,"[{'C1': {'code': 'if (!EVP_MD_is_a(md,\n                EVP_MD_get0_name(ssl_md(sctx,\n                                        s->s3.tmp.new_cipher->algorithm2)))) {\n            /* The ciphersuite is not compatible with this session. */\n            SSL_SESSION_free(sess);\n            sess = NULL;\n            s->ext.early_data_ok = 0;\n            s->ext.ticket_expected = 0;\n            continue;\n        }', 'explanation': 'This code segment verifies that the hash algorithm associated with the PSK session (obtained from sess->cipher->algorithm2) is compatible with the hash algorithm of the negotiated cipher suite (from s->s3.tmp.new_cipher->algorithm2). By checking the compatibility via EVP_MD_is_a and aborting (freeing the session and resetting flags) if they do not match, the function directly implements the requirement that the server must select a compatible PSK and cipher suite.'}}]","The function tls_parse_ctos_psk explicitly checks for compatibility between the PSK (and its associated hash algorithm) and the cipher suite selected for the connection. This is accomplished by retrieving the message digest for both the PSK session and the new cipher, then ensuring they match; if they do not, the session is discarded. This logic directly addresses the TLS RFC requirement that ""the server MUST ensure that it selects a compatible PSK (if any) and cipher suite.""",success,
13946,tls_parse_ctos_post_handshake_auth,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR,\n             SSL_R_POST_HANDSHAKE_AUTH_ENCODING_ERR);\n    return 0;\n}', 'explanation': 'This code checks if there is any remaining data in the packet, and if so, it triggers a decode_error alert and terminates the connection, thereby implementing the RFC requirement for handling parsing errors.'}}]","The function explicitly verifies that the incoming packet length is exactly as expected (i.e., zero). If not, it immediately raises a decode_error alert using SSLfatal, which is in accordance with the RFC requirement that messages that cannot be parsed should result in a connection termination with a decode_error alert. Since the relevant condition (C1) is fully handled within this code function, the implementation fully matches the specified constraint.",success,
13948,tls_construct_stoc_server_name,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The provided function deals with constructing the Server Name Indication (SNI) extension and includes logic related to TLS versions (e.g., skipping SNI for TLS 1.3 in session resumption), but it does not contain any logic addressing the RFC specification requirement regarding obsolete_RESERVED values. There is no code that checks for or prevents negotiation of values within the obsolete_RESERVED ranges. Therefore, none of the spec constraints (e.g., the one stating that obsolete_RESERVED values MUST NOT be offered or negotiated in TLS 1.3) are implemented within this function.",success,
13948,tls_construct_stoc_server_name,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The function tls_construct_stoc_server_name is solely responsible for constructing the SNI extension and does not implement any logic related to certificate type restrictions. In particular, it does not address the requirement that the OpenPGP certificate type (RFC6091) MUST NOT be used with TLS 1.3. There is no code within this function that checks or prevents the use of the OpenPGP certificate type when TLS 1.3 is negotiated.",success,
13952,tls_construct_stoc_session_ticket,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest.",59,Fully Matches,"[{'C1': {'code': 'if (!s->ext.ticket_expected || !tls_use_ticket(s)) {\n    s->ext.ticket_expected = 0;\n    return EXT_RETURN_NOT_SENT;\n}', 'explanation': 'This code checks whether the session ticket extension was expected (i.e., whether the remote endpoint sent the corresponding extension request). If not, it does not send the extension response, thus implementing the TLS RFC requirement that implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests. This condition is fully handled within the function.'}}]","The function implements the TLS RFC requirement by verifying that the remote endpoint requested the session ticket extension (using the ticket_expected flag) before constructing and sending the extension. Since the function only sends the extension when the flag is set (and tls_use_ticket returns true), it adheres to the specification. There is no extraneous logic regarding the 'cookie' exception since it is not applicable for the session ticket extension.",success,
13953,tls_construct_stoc_status_request,"Specifically, the body of the ""status_request"" extension from the server MUST be a CertificateStatus structure as defined in [RFC6066], which is interpreted as defined in [RFC6960].",199,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s) && !tls_construct_cert_status_body(s, pkt)) {\n   /* SSLfatal() already called */\n   return EXT_RETURN_FAIL;\n}', 'explanation': 'For TLS 1.3 the spec requires that the status_request extension’s body be a CertificateStatus structure. This branch calls tls_construct_cert_status_body() to include the certificate status, thus fulfilling the requirement.'}}, {'A1': {'code': '/* In TLSv1.3 we include the certificate status itself. In <= TLSv1.2 we\n * send back an empty extension, with the certificate status appearing as a\n * separate message */', 'explanation': 'For TLS 1.2 and below, the function does not append a certificate status into the extension (resulting in an empty extension). This behavior aligns with the spec that states the OCSP information is carried as a separate message for TLS<=1.2.'}}]","The function implements the TLS status_request extension according to the RFC specification. It conditionally builds the extension body by including the CertificateStatus structure only in TLS 1.3 (as required) via tls_construct_cert_status_body, and returns an empty extension in TLS 1.2 and below. This handling directly addresses the key constraints from RFC6066 and RFC6960, and thus the function fully matches the specification requirements.",success,
13953,tls_construct_stoc_status_request,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Fully Matches,"[{'C1': {'code': 'if (context == SSL_EXT_TLS1_3_CERTIFICATE_REQUEST)\n    return EXT_RETURN_NOT_SENT;', 'explanation': 'This check prevents the function from constructing and sending the status extension when the context indicates a CertificateRequest message, which complies with the requirement that TLS 1.3 servers must not send the status_request_v2 extension in CertificateRequest messages.'}}, {'C2': {'code': 'if (SSL_CONNECTION_IS_TLS13(s) && chainidx != 0)\n    return EXT_RETURN_NOT_SENT;', 'explanation': 'This condition ensures that in TLS 1.3 the server only includes the certificate status extension for the first certificate (chainidx == 0), preventing the extension from being sent in contexts where it is not expected.'}}, {'A1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s) && !tls_construct_cert_status_body(s, pkt)) {\n   return EXT_RETURN_FAIL;\n}', 'explanation': 'This segment enforces that, in TLS 1.3, the certificate status body is constructed and included in the extension, which aligns with the RFC requirement of carrying the OCSP response in the CertificateEntry.'}}]","The function implements the specified RFC by conditionally constructing the status_request extension based on the message context. It explicitly avoids constructing the extension in a CertificateRequest context (C1) and for non-initial certificate entries in TLS 1.3 (C2). In addition, for TLS 1.3 it includes the OCSP certificate status body (A1). Therefore, the function visibly addresses all parts of the spec constraint that require TLS 1.3 servers not to send the status_request_v2 extension in disallowed contexts, and does so entirely within its own logic.",success,
13957,tls_construct_stoc_etm,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function implements the construction of the Encrypt-then-MAC (ETM) extension record, not the Truncated HMAC extension as specified by the RFC. The RFC states that 'Implementations MUST NOT use the Truncated HMAC extension' while the function is concerned with sending the TLSEXT_TYPE_encrypt_then_mac. Although the function disables ETM when AEAD or certain ciphers are used, it does not contain any logic related to the Truncated HMAC extension. Therefore, the function does not visibly address the specified constraint regarding the Truncated HMAC extension.",success,
13958,tls_construct_stoc_ems,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function solely constructs the Extended Master Secret extension by checking a flag and writing specific bytes into a packet. It does not contain any logic related to validating or rejecting the OpenPGP certificate type with TLS 1.3, which is the subject of the specified RFC requirement. Therefore, no part of the function addresses the spec constraint that 'The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.'",success,
13959,tls_construct_stoc_supported_versions,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided code function implements the construction of the 'supported_versions' extension for TLS 1.3 and contains no logic pertaining to the status_request_v2 extension. The spec constraint requires that TLS 1.3 servers must not send the status_request_v2 extension in specific messages, but this function does not process or conditionally handle status_request_v2 at all. Therefore, none of the labeled conditions or actions from the spec constraints are met within this function's code.",success,
13959,tls_construct_stoc_supported_versions,"The server's extensions MUST contain ""supported_versions""",45,Fully Matches,"[{'C1': {'code': 'if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_supported_versions)) { ... }\nif (!WPACKET_put_bytes_u16(pkt, s->version)) { ... }', 'explanation': ""The function explicitly constructs the 'supported_versions' extension by writing the extension type (TLSEXT_TYPE_supported_versions) and the version (s->version) into the packet, thereby fulfilling the RFC requirement that the server's extensions must contain 'supported_versions'.""}}]","The function tls_construct_stoc_supported_versions constructs the supported_versions extension for a TLS 1.3 connection. It writes the extension type and the supported version into the packet, directly implementing the RFC specification requirement without relying on external dependencies. Therefore, the function fully matches the constraint labeled C1.",success,
13959,tls_construct_stoc_supported_versions,"All TLS 1.3 ServerHello messages MUST contain the ""supported_versions"" extension.",36,Fully Matches,"[{'C1': {'code': 'if (!ossl_assert(SSL_CONNECTION_IS_TLS13(s))) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return EXT_RETURN_FAIL;\n}\n\nif (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_supported_versions)\n        || !WPACKET_start_sub_packet_u16(pkt)\n        || !WPACKET_put_bytes_u16(pkt, s->version)\n        || !WPACKET_close(pkt)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return EXT_RETURN_FAIL;\n}', 'explanation': ""The function first asserts that the connection is TLS 1.3 and then constructs the 'supported_versions' extension by writing the appropriate extension type and the version from 's->version'. This directly implements the TLS 1.3 RFC requirement that all ServerHello messages include the 'supported_versions' extension.""}}]","The function directly implements the specified requirement by checking that the context is TLS 1.3 and by constructing the 'supported_versions' extension within the ServerHello message. There is no reliance on external functions or dependencies for this logic; all necessary steps are performed within this function. Therefore, the function fully matches the specified RFC constraint.",success,
13960,tls_construct_stoc_key_share,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function, tls_construct_stoc_key_share, is responsible for constructing a key share extension in TLS 1.3 handshakes and does not include any logic to filter or prohibit the use of the OpenPGP certificate type (per RFC6091) with TLS 1.3. No code segments in this function address the constraint that the OpenPGP certificate type MUST NOT be used with TLS 1.3, and thus the function does not implement the specified TLS RFC requirement.",success,
13960,tls_construct_stoc_key_share,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The RFC specification requires that TLS 1.3 servers must not process or send the status_request_v2 extension in certain messages. The provided function, tls_construct_stoc_key_share, is solely concerned with constructing the key_share extension and the associated key exchange mechanism. It does not contain any logic that checks for or deliberately ignores the status_request_v2 extension, nor does it have any code explicitly preventing the server from sending status_request_v2 in EncryptedExtensions, CertificateRequest, or Certificate messages. As a result, none of the specified conditions or actions (e.g., C1, A1 if they were related to managing status_request_v2) are addressed within this function's body.",success,
13960,tls_construct_stoc_key_share,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The provided function constructs a key share message for TLS 1.3 but does not implement any logic to check whether the group identifier is within the obsolete_RESERVED ranges. According to the RFC specification, values within these ranges must not be offered or negotiated. The function simply retrieves the group id (via s->s3.group_id and tls1_group_id_lookup) and constructs the message, without verifying whether the group falls into the obsolete (or RESERVED) range. Therefore, the function does not visibly address the spec constraint regarding obsolete_RESERVED values.",success,
13960,tls_construct_stoc_key_share,"If (EC)DHE key establishment is in use, then the ServerHello contains a ""key_share"" extension with the server's ephemeral Diffie-Hellman share; the server's share MUST be in the same group as one of the client's shares.",0,Fully Matches,"[{'C1': {'code': 'if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_key_share)\n        || !WPACKET_start_sub_packet_u16(pkt)\n        || !WPACKET_put_bytes_u16(pkt, s->s3.group_id)\n        || ...\n        if (ckey != NULL) { ... }', 'explanation': ""The function first checks if a key share from the client (ckey) exists and proceeds to send a 'key_share' extension. In the HRR case it sends the extension with the group id, and later when a client's key share is present it writes the group id and the server’s ephemeral DH (or KEM) share into the packet. This satisfies the condition that when (EC)DHE is in use, the ServerHello contains the key_share extension.""}}, {'A1': {'code': 'if ((ginf = tls1_group_id_lookup(SSL_CONNECTION_GET_CTX(s), s->s3.group_id)) == NULL) { ... }\n\nif (!ginf->is_kem) {\n    skey = ssl_generate_pkey(s, ckey);\n    ...\n    encoded_pubkey_len = EVP_PKEY_get1_encoded_public_key(skey, &encoded_pubkey);\n    if (!WPACKET_sub_memcpy_u16(pkt, encoded_pubkey, encoded_pubkey_len) || !WPACKET_close(pkt)) { ... }\n    s->s3.tmp.pkey = skey;\n    if (ssl_derive(s, skey, ckey, 1) == 0) { ... }\n}', 'explanation': ""The server uses the negotiated group identifier, s->s3.group_id, to lookup group information and then generates its ephemeral key share (or encapsulated KEM output) based on the client’s provided share (ckey). This ensures that the server's share is generated in the group associated with the client's key share.""}}]","The function implements the key share extension for TLS 1.3 when (EC)DHE key establishment is in use. It checks for a client provided key share, selects the group based on s->s3.group_id (which by context must match one of the client's offered groups), and then generates and sends the server’s ephemeral share. Thus, both the conditions that require sending the key_share extension and the action to ensure the server’s share is in the same group as the client's share are visibly handled in the function.",success,
13960,tls_construct_stoc_key_share,"In this mode, the client and server MUST supply ""key_share"" values as described in Section 4.2.8.",142,Fully Matches,"[{'C1': {'code': 'if (s->hit && (s->ext.psk_kex_mode & TLSEXT_KEX_MODE_FLAG_KE_DHE) == 0) {\n    return EXT_RETURN_NOT_SENT;\n}', 'explanation': 'This branch verifies that if the connection is a PSK resumption (indicated by s->hit) and the PSK key exchange mode does not include DHE (i.e. PSK-only key establishment), then the server does not supply a key_share value, as required by the spec for psk_ke mode.'}}, {'A1': {'code': 'if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_key_share)\n        || !WPACKET_start_sub_packet_u16(pkt)\n        || !WPACKET_put_bytes_u16(pkt, s->s3.group_id)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return EXT_RETURN_FAIL;\n}\n\n... (later the code branches into generating an ephemeral key share or encapsulating a KEM) ...\n\nif (!WPACKET_sub_memcpy_u16(pkt, encoded_pubkey, encoded_pubkey_len)\n        || !WPACKET_close(pkt)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    EVP_PKEY_free(skey);\n    OPENSSL_free(encoded_pubkey);\n    return EXT_RETURN_FAIL;\n}', 'explanation': 'These segments construct and include a key_share extension when in a PSK with (EC)DHE mode (or similar) by writing the group ID and the generated key material. This meets the spec requirement that both client and server supply key_share values in such modes.'}}]","The function 'tls_construct_stoc_key_share' implements the specified TLS RFC by conditionally constructing the key_share extension. It ensures that the key_share is only sent when appropriate – namely, in PSK with (EC)DHE key establishment mode – and omitted in pure PSK-only mode. The code branches clearly check for the PSK-only condition (C1) and, when not met, generate and send the key_share (A1) by writing the server's group ID and derived ephemeral key material or KEM encapsulation values. This visible, isolated logic within the function directly addresses the spec constraints.",success,
13961,tls_construct_stoc_cookie,"When sending a HelloRetryRequest, the server MAY provide a ""cookie"" extension to the client (this is an exception to the usual rule that the only extensions that may be sent are those that appear in the ClientHello).",77,Fully Matches,"[{'C1': {'code': 'if ((s->s3.flags & TLS1_FLAGS_STATELESS) == 0)\n    return EXT_RETURN_NOT_SENT;', 'explanation': 'This check ensures that the cookie extension is only sent when operating in stateless mode, which is required for sending a HelloRetryRequest with a cookie per the spec.'}}, {'A1': {'code': 'WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_cookie)\n    || !WPACKET_start_sub_packet_u16(pkt)\n    || !WPACKET_start_sub_packet_u16(pkt)\n    ...\n    if (!ssl3_digest_cached_records(s, 0)\n            || !ssl_handshake_hash(s, hashval1, EVP_MAX_MD_SIZE, &hashlen)) { ... }\n    ...\n    if (sctx->gen_stateless_cookie_cb(ussl, appcookie1, &appcookielen) == 0) { ... }\n    ...\n    hctx = EVP_MD_CTX_create();\n    pkey = EVP_PKEY_new_raw_private_key_ex(sctx->libctx, ""HMAC"",\n                                           sctx->propq,\n                                           s->session_ctx->ext.cookie_hmac_key,\n                                           sizeof(s->session_ctx->ext.cookie_hmac_key));\n    if (EVP_DigestSignInit_ex(hctx, NULL, ""SHA2-256"", sctx->libctx,\n                              sctx->propq, pkey, NULL) <= 0\n            || EVP_DigestSign(hctx, hmac, &hmaclen, cookie, totcookielen) <= 0) { ... }', 'explanation': ""The function builds the cookie extension by writing the extension type, composing the sub-packets with version, group ID, cipher, and a ClientHello hash. It then uses a cookie callback to generate an application cookie and applies an HMAC (using SHA2-256) to protect the cookie. This implementation directly addresses the spec's action of offloading state via a cookie extension with integrity protection.""}}]","The function clearly implements the server-side construction of the cookie extension for a HelloRetryRequest as described in the TLS specification. It conditionally sends the extension only in stateless mode (meeting the conditional requirement) and includes the necessary sub-components—including a hash of the initial ClientHello and an HMAC for integrity protection (meeting the action requirement). Thus, based solely on the logic within this function, it fully matches the TLS RFC specification requirements for handling the cookie extension.",success,
13961,tls_construct_stoc_cookie,"As with the ServerHello, a HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the ""cookie"" (see Section 4.2.2) extension.",47,Partially Matches,"[{'C1': {'code': 'if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_cookie)\n        || !WPACKET_start_sub_packet_u16(pkt)\n        || ...\n        || !WPACKET_put_bytes_u16(pkt, COOKIE_STATE_FORMAT_VERSION)\n        || !WPACKET_put_bytes_u16(pkt, TLS1_3_VERSION)\n        || !WPACKET_put_bytes_u16(pkt, s->s3.group_id)\n        || !ssl->method->put_cipher_by_char(s->s3.tmp.new_cipher, pkt, &ciphlen)\n        || !WPACKET_put_bytes_u8(pkt, s->s3.peer_tmp == NULL)\n        || !WPACKET_put_bytes_u64(pkt, time(NULL))\n        || ...\n        || sctx->gen_stateless_cookie_cb(ussl, appcookie1, &appcookielen) == 0) { ... }', 'explanation': 'This segment constructs the cookie extension allowed in a HelloRetryRequest. The RFC permits sending the cookie extension even if it was not offered in the ClientHello. The function generates, packs, and applies HMAC on the cookie, which indicates an attempt to implement the cookie exception per the TLS RFC. However, the function does not verify the client’s offered extensions list (i.e. ensuring no other unsolicited extensions are included), so it only partially addresses the overall spec requirement.'}}]","The TLS RFC requires that a HelloRetryRequest must not include any extensions not first offered by the client except for the optional cookie extension. This function specifically constructs and appends a cookie extension using a callback and proper packing routines. While it correctly implements the logic for creating the cookie extension (thereby addressing the allowed exception), it does not perform any checks to ensure that only cookie and no other unexpected extensions are sent. Because the function handles only the generation of the cookie extension and leaves validation of offered extensions to other parts of the system, it partially matches the specification's requirements.",success,
13961,tls_construct_stoc_cookie,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest.",59,Fully Matches,"[{'C1': {'code': 'if ((s->s3.flags & TLS1_FLAGS_STATELESS) == 0)\n        return EXT_RETURN_NOT_SENT;', 'explanation': 'This check ensures that the cookie extension is constructed (and sent) only when the TLS1_FLAGS_STATELESS flag is set, corresponding to the HelloRetryRequest scenario. This aligns with the spec requirement that implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests—with the cookie extension being the explicit exception in HRR.'}}]","The function tls_construct_stoc_cookie is responsible for constructing the cookie extension for a HelloRetryRequest. It starts by checking the state (s->s3.flags) to only proceed if in stateless mode—which is the HRR situation where the cookie extension is allowed even when not requested by the peer. This logic directly implements the specification’s exception rule for the cookie extension. Thus, within the context of this function, the relevant constraint (labeled C1) is fully met.",success,
13961,tls_construct_stoc_cookie,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function, tls_construct_stoc_cookie, focuses exclusively on constructing and processing a cookie for stateless TLS handshake operations (including generating, reserving, and HMACing the cookie), and has no logic related to handling or retransmission of early data. The RFC specification requires that a TLS implementation MUST NOT automatically resend early data (unless a specific ALPN protocol is negotiated) and leaves the decision of retransmission to the application. There is no evidence in the code of any checks or conditions regarding early data or negotiated ALPN protocols. Thus, from the function_body alone, none of the labeled conditions or actions from the specification (for example, C1 or A1 which would relate to early data retransmission controls) are addressed.",success,
13963,tls_construct_stoc_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function constructs the early_data extension for TLS messages based on simple internal state (such as s->max_early_data and s->ext.early_data) but does not implement any logic pertaining to the automatic retransmission of early data. The TLS RFC specifies that the implementation MUST NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol, thus leaving the decision to the application. No checks or conditions in the function (for example, verifying ALPN protocol consistency or handling retransmission decisions) are present. Therefore, none of the labeled spec constraints regarding automatic retransmission (for instance, any conditions like C1 or actions like A1 pertinent to not automatically resending early data) are addressed within this function alone.",success,
13964,tls_construct_stoc_psk,The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK).,185,Does Not Match,[],"The provided function (tls_construct_stoc_psk) is responsible for constructing a PSK extension and does not implement any logic to send a Certificate message. The RFC specification requires the server to send a Certificate message when using certificates for authentication (except in PSK key exchange methods). Since this function is specifically handling PSK (and not a certificate-based authentication mechanism) and contains no logic related to constructing or sending a Certificate message, it does not address any of the spec constraints (e.g., C1, A1) pertaining to sending a Certificate message.",success,
13965,tls_construct_stoc_client_cert_type,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The RFC specification requires that TLS 1.3 servers must not send the status_request_v2 extension in certain messages. However, this function (tls_construct_stoc_client_cert_type) is entirely focused on constructing the client certificate type extension (client_cert_type) and does not include any logic handling or preventing the status_request_v2 extension. Therefore, no part of the function's code addresses the specified TLS 1.3 requirement regarding status_request_v2, and it does not meet the labeled conditions or actions from the spec.",success,
13965,tls_construct_stoc_client_cert_type,"If the client cannot construct an acceptable chain using the provided certificates and decides to abort the handshake, then it MUST abort the handshake with an appropriate certificate-related alert (by default, ""unsupported_certificate""; see Section 6.2 for more information).",212,Partially Matches,"[{'A1': {'code': 'if (sc->ext.client_cert_type_ctos == OSSL_CERT_TYPE_CTOS_ERROR\n        && (send_certificate_request(sc)\n            || sc->post_handshake_auth == SSL_PHA_EXT_RECEIVED)) {\n    /* Did not receive an acceptable cert type - and doing client auth */\n    SSLfatal(sc, SSL_AD_UNSUPPORTED_CERTIFICATE, SSL_R_BAD_EXTENSION);\n    return EXT_RETURN_FAIL;\n}', 'explanation': ""This block checks if the client's certificate type is in an error state (indicating that an acceptable chain could not be constructed) and, if client authentication is being attempted, aborts the handshake using SSLfatal with the alert SSL_AD_UNSUPPORTED_CERTIFICATE. This directly implements the specified TLS RFC requirement to abort the handshake with an appropriate certificate-related alert when the client cannot form an acceptable chain.""}}]","The function includes logic that, when a client cannot produce an acceptable certificate chain (detected via the error flag on the certificate type), aborts the handshake with the 'unsupported_certificate' alert. This directly addresses the action specified in the RFC (abort handshake when an acceptable chain cannot be constructed). However, the function does not address the full range of criteria described in the overall RFC context (such as fallback behavior by the server), hence it only partially matches the RFC implementation requirements.",success,
13965,tls_construct_stoc_client_cert_type,"When the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message.",254,Partially Matches,"[{'C1': {'code': 'if (sc->ext.client_cert_type_ctos == OSSL_CERT_TYPE_CTOS_ERROR\n        && (send_certificate_request(sc)\n            || sc->post_handshake_auth == SSL_PHA_EXT_RECEIVED)) {', 'explanation': 'This condition checks whether an error status exists and whether the client either triggered a certificate request or indicated support via the post_handshake_auth extension. It uses the post_handshake_auth flag (SSL_PHA_EXT_RECEIVED) to decide on proceeding with client authentication, which partially mirrors the spec constraint that a server MAY request client authentication post-handshake when the client has sent the post_handshake_auth extension.'}}, {'A1': {'code': 'if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_client_cert_type)\n        || !WPACKET_start_sub_packet_u16(pkt)\n        || !WPACKET_put_bytes_u8(pkt, sc->ext.client_cert_type)\n        || !WPACKET_close(pkt)) {', 'explanation': 'This code segment constructs the client certificate type extension to be sent. Although the spec directs sending a CertificateRequest message, the function actually builds an extension (client_cert_type) that is used when determining client authentication. This covers part of the action by composing relevant data based on the server’s decision process, but it does not fully implement sending the CertificateRequest message itself.'}}]","The function partially implements the RFC specification. It visibly checks whether the client has sent the post_handshake_auth extension (thus touching condition C1) and accordingly decides whether to construct data for a client certificate type extension. However, it does not fully implement the entire mechanism required for a post-handshake CertificateRequest message (such as the full logic of requesting client authentication or ensuring the client’s subsequent consecutive responses), and thus only partially matches the specification. All relevant logic is contained within this function, but not every aspect of the spec constraint is handled here.",success,
13965,tls_construct_stoc_client_cert_type,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided code function 'tls_construct_stoc_client_cert_type' is exclusively focused on constructing the client certificate type extension. It does not contain any logic addressing the RFC specification constraint regarding RC4 cipher suites (i.e., the implementation MUST NOT offer or negotiate RC4 cipher suites). There is no code checking for or preventing RC4 usage; the function deals solely with certificate type negotiation. Therefore, with respect to the given TLS RFC spec conditions, no labeled condition (e.g., C1 for RC4 prohibition) or associated actions are visible in this function.",success,
13965,tls_construct_stoc_client_cert_type,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The provided function focuses on constructing the server-to-client 'client_cert_type' extension in TLS and handles conditions related to certificate request and type validation. There is no visible logic within this function that checks for or prevents the negotiation of SSL version 2.0, which is a key requirement of the specified RFC. All measures to forbid an SSLv2 compatible CLIENT-HELLO, as stated in the spec constraints, are absent in this function's body.",success,
13967,tls_parse_ctos_client_cert_type,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided code function, tls_parse_ctos_client_cert_type, is involved in parsing the client certificate type extension and does not address any logic related to cipher suite negotiation or filtering out RC4 cipher suites. The RFC specification mandates that implementations MUST NOT offer or negotiate RC4 cipher suites, but there is no logic in this function that deals with cipher suite selection, cryptographic strength checks, or any related filtering of RC4. Therefore, none of the labeled conditions or actions concerning RC4 (or low strength ciphers) are implemented in this code function.",success,
13967,tls_parse_ctos_client_cert_type,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_1(pkt, &supported_cert_types)) {\n    sc->ext.client_cert_type_ctos = OSSL_CERT_TYPE_CTOS_ERROR;\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}\nif ((len = PACKET_remaining(&supported_cert_types)) == 0) {\n    sc->ext.client_cert_type_ctos = OSSL_CERT_TYPE_CTOS_ERROR;\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}\nif (!PACKET_get_bytes(&supported_cert_types, &data, len)) {\n    sc->ext.client_cert_type_ctos = OSSL_CERT_TYPE_CTOS_ERROR;\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': ""These code segments check if the input message cannot be parsed (e.g., if length prefix extraction fails, if the remaining length is zero, or if the bytes cannot be extracted) and then trigger a decode_error alert via SSLfatal(), meeting the RFC's requirement.""}}]","The function explicitly checks for parsing errors in the client certificate type extension. When a parsing error is detected, it calls SSLfatal() with the decode_error alert type (SSL_AD_DECODE_ERROR) and returns 0, thereby terminating the connection as required by the RFC. This logic directly implements the constraint that syntactically invalid messages must result in a decode_error alert, fulfilling the labeled condition and action solely within the function_body.",success,
13967,tls_parse_ctos_client_cert_type,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_1(pkt, &supported_cert_types)) {\n    sc->ext.client_cert_type_ctos = OSSL_CERT_TYPE_CTOS_ERROR;\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This segment checks whether the extension’s length-prefixed format is present. If not, it aborts the handshake with a decode_error alert as required by the RFC.'}}, {'A1': {'code': 'if ((len = PACKET_remaining(&supported_cert_types)) == 0) {\n    sc->ext.client_cert_type_ctos = OSSL_CERT_TYPE_CTOS_ERROR;\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}\n\nif (!PACKET_get_bytes(&supported_cert_types, &data, len)) {\n    sc->ext.client_cert_type_ctos = OSSL_CERT_TYPE_CTOS_ERROR;\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'These checks validate that the extension data is non-empty and can be correctly extracted. Failure in either case results in aborting the handshake with a decode_error alert, fulfilling the RFC mandate.'}}]","The function explicitly verifies that the client_cert_type extension is correctly formatted by ensuring a proper length prefix, non-zero length, and successful extraction of data. In each error scenario, it aborts the handshake by calling SSLfatal with a decode_error alert. This behavior is in direct accordance with the TLS RFC requirement that an invalid extension must result in a handshake abort with a 'decode_error' alert.",success,
13968,tls_construct_stoc_server_cert_type,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'A1': {'code': 'if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_server_cert_type)\n        || !WPACKET_start_sub_packet_u16(pkt)\n        || !WPACKET_put_bytes_u8(pkt, sc->ext.server_cert_type)\n        || !WPACKET_close(pkt)) {\n    SSLfatal(sc, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return EXT_RETURN_FAIL;\n}', 'explanation': 'This segment ensures that if a failure occurs during packet construction, the function calls SSLfatal with a specific alert (SSL_AD_INTERNAL_ERROR) and returns failure. This reflects an attempt to follow the spec constraint that requires sending a fatal alert (with a specified alert code) when terminating the connection due to an error.'}}]","While the broader TLS error handling specification requires that upon detecting a fatal error the implementation MUST send a specific alert and immediately close the connection, the function only includes error handling for packet construction failure by invoking SSLfatal with an alert code. There is no other logic in this function to manage termination or the aborting of the handshake with the mandated alert if any alert is to be sent. Thus, the function only partially addresses the error handling requirement as described in the spec constraints.",success,
13969,tls_parse_ctos_server_cert_type,"If the client cannot construct an acceptable chain using the provided certificates and decides to abort the handshake, then it MUST abort the handshake with an appropriate certificate-related alert (by default, ""unsupported_certificate""; see Section 6.2 for more information).",212,Fully Matches,"[{'A1': {'code': 'if (sc->ext.server_cert_type_ctos == OSSL_CERT_TYPE_CTOS_GOOD)\n    return 1;\n\n/* Did not receive an acceptable cert type */\nSSLfatal(sc, SSL_AD_UNSUPPORTED_CERTIFICATE, SSL_R_BAD_EXTENSION);\nreturn 0;', 'explanation': ""This code segment checks if an acceptable certificate type is returned by reconcile_cert_type. If the result is not acceptable (i.e. not OSSL_CERT_TYPE_CTOS_GOOD), it aborts the handshake by calling SSLfatal with the 'unsupported_certificate' alert, which fulfills the RFC requirement to abort the handshake with the proper certificate-related alert when the provided certificates are not acceptable.""}}]","The function directly implements the logic required by the RFC specification. It verifies whether the provided certificate data leads to an acceptable chain (via the certificate type), and if not, it aborts the handshake using the appropriate alert (unsupported_certificate). This behavior fully aligns with the specification requirement that mandates aborting the handshake when the client cannot construct an acceptable certificate chain.",success,
13969,tls_parse_ctos_server_cert_type,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_1(pkt, &supported_cert_types)) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}\n\nif ((len = PACKET_remaining(&supported_cert_types)) == 0) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}\n\nif (!PACKET_get_bytes(&supported_cert_types, &data, len)) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'The function checks that the expected length‐prefixed certificate type extension data is present and nonempty. In each failure branch it aborts the handshake with a call to SSLfatal using the decode_error alert, thus directly addressing the condition in the RFC spec that invalid or missing extension data should lead to an immediate abort.'}}, {'A1': {'code': 'if (sc->ext.server_cert_type_ctos == OSSL_CERT_TYPE_CTOS_GOOD)\n    return 1;\n\n/* Did not receive an acceptable cert type */\nSSLfatal(sc, SSL_AD_UNSUPPORTED_CERTIFICATE, SSL_R_BAD_EXTENSION);\nreturn 0;', 'explanation': 'After attempting to reconcile the certificate type, the function checks the result. If the certificate type received is not acceptable, it aborts the handshake. Although here it uses the UNSUPPORTED_CERTIFICATE alert instead of decode_error, the overall intent is to abort the handshake when the extension does not meet specification.'}}]","The function implements logic to verify the structure of the certificate type extension by ensuring it is a valid, length‐prefixed block with data, and it safely aborts the handshake when these conditions are not met. This directly addresses part of the RFC requirement to abort the handshake with an error if the extension data is invalid. However, the RFC specification (as provided) precisely mandates that a decode_error alert be used for failures, yet in the branch for an unacceptable certificate type the function uses a different alert (UNSUPPORTED_CERTIFICATE). In addition, the broader context regarding extension data (detection of extra bytes after the compression_methods field) is not addressed here. Thus, while the function visibly handles some key error scenarios (meeting C1 and A1), it does not fully cover every nuance of the spec requirement.",success,
13969,tls_parse_ctos_server_cert_type,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, tls_parse_ctos_server_cert_type, deals exclusively with parsing the certificate type extension from a client message. It does not contain any logic related to the negotiation or rejection of RC4 cipher suites, nor any checks regarding cipher strength (e.g., 112 bits) as required by the TLS RFC specification. Since the code does not address any of the specified conditions or actions (e.g., C1, A1) related to cipher suite selection or restrictions on RC4, it does not fulfill the spec constraints.",success,
13969,tls_parse_ctos_server_cert_type,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_1(pkt, &supported_cert_types)) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}\n\nif ((len = PACKET_remaining(&supported_cert_types)) == 0) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}\n\nif (!PACKET_get_bytes(&supported_cert_types, &data, len)) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'These code segments ensure that if the packet cannot be correctly parsed (e.g., due to a length issue or missing bytes), the connection is terminated with a decode_error alert, which aligns with the RFC requirement for handling syntax errors in received messages.'}}, {'A1': {'code': 'sc->ext.server_cert_type_ctos = reconcile_cert_type(sc->server_cert_type, sc->server_cert_type_len,\n                                                    data, len,\n                                                    &sc->ext.server_cert_type);\nif (sc->ext.server_cert_type_ctos == OSSL_CERT_TYPE_CTOS_GOOD)\n    return 1;\n\nSSLfatal(sc, SSL_AD_UNSUPPORTED_CERTIFICATE, SSL_R_BAD_EXTENSION);\nreturn 0;', 'explanation': 'This segment attempts to determine whether the server’s certificate type is acceptable. However, when an unacceptable certificate type is encountered it terminates with an unsupported_certificate alert rather than the illegal_parameter alert as specified by the RFC for semantically invalid messages.'}}]","The function implements important aspects of the TLS RFC by checking for syntax errors in the received packet and terminating the connection with a decode_error alert when parsing issues are detected (meeting condition C1). However, while it does handle errors arising from a failed certificate type reconciliation, it does not fully adhere to the RFC requirement for semantically invalid messages (which should trigger an illegal_parameter alert instead of the unsupported_certificate alert). Since only part of the spec constraints is met within the function itself, the overall match is partial.",success,
13988,ossl_statem_skip_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Partially Matches,"[{'C1': {'code': 'if (s->ext.early_data != SSL_EARLY_DATA_REJECTED)\n        return 0;', 'explanation': 'This check ensures that unless the early_data extension has been explicitly rejected, the function will not trigger skipping early data (i.e. no automatic retransmission is performed).'}}]","The function contains logic that addresses part of the spec constraint by checking that early data is only skipped (and thus not auto-resent) when it has been rejected by the server. However, it does not handle additional aspects of the RFC requirement (such as verifying that the negotiated connection uses the same ALPN protocol) nor does it explicitly defer retransmission decisions to the application. Therefore, while it partially implements the constraint, it does not fully meet the entire spec requirement by itself.",success,
13989,ossl_statem_check_finish_init,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Partially Matches,"[{'A1': {'code': ""if (sending == -1) {\n    if (s->statem.hand_state == TLS_ST_PENDING_EARLY_DATA_END || s->statem.hand_state == TLS_ST_EARLY_DATA) {\n        ossl_statem_set_in_init(s, 1);\n        if (s->early_data_state == SSL_EARLY_DATA_WRITE_RETRY) {\n            /* SSL_write() has been called directly. We don't allow any more writing of early data. */\n            s->early_data_state = SSL_EARLY_DATA_FINISHED_WRITING;\n        }\n    }\n}"", 'explanation': 'This block explicitly prevents further writing of early data by setting the state to finished writing when early data write retry is detected, thereby ensuring that early data is not automatically resent.'}}, {'A2': {'code': 'if (s->server && SSL_NO_EOED(s) && s->ext.early_data == SSL_EARLY_DATA_ACCEPTED\n    && s->early_data_state != SSL_EARLY_DATA_FINISHED_READING\n    && s->statem.hand_state == TLS_ST_EARLY_DATA) {\n    s->early_data_state = SSL_EARLY_DATA_FINISHED_READING;\n    if (!SSL_CONNECTION_GET_SSL(s)->method->ssl3_enc->change_cipher_state(s, i))\n        return 0;\n}', 'explanation': 'On the server side, this code finalizes early data reception by marking the early data as finished reading, which helps prevent reprocessing or automatic retransmission of early data.'}}]","The RFC specifies that a TLS implementation SHOULD NOT automatically resend early data and must only do so if the negotiated ALPN protocol remains unchanged. This function includes logic to mark early data as finished (both reading on the server side and writing on the client side), which effectively prevents automatic retransmission. However, the function does not incorporate an explicit check for the negotiation of the ALPN protocol. As a result, while the function implements mechanisms to stop automatic early data retransmission, it does not fully enforce the ALPN condition required by the RFC, leading to a partial match.",success,
13994,state_machine,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Does Not Match,[],"The provided function implements the handshake state machine but does not contain any visible logic that enforces the TLS RFC requirement that SSL 3.0 (as per RFC6101 and RFC7568) MUST NOT be negotiated, nor does it verify that cipher strengths meet the minimum 112-bit requirement. Although the code performs some version checks (for example, ensuring that for non-DTLS the major version equals SSL3_VERSION_MAJOR), this check only compares the major version and does not differentiate between SSL 3.0 and later TLS versions. Since the spec explicitly requires that SSL 3.0 not be negotiated at all, and there is no direct check or constraint within the function_body that outright prevents the negotiation of SSL 3.0 (or low strength ciphers), the function does not visibly implement the relevant conditions (e.g., C1) or actions (e.g., A1) defined in the spec constraints.",success,
14005,custom_ext_add_old_cb_wrap,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function custom_ext_add_old_cb_wrap is a simple callback wrapper that checks if a nested callback pointer is NULL and, if not, forwards the call. It contains no logic related to implementing the TLS RFC specification constraints such as disallowing the Truncated HMAC extension or enforcing record version rules. Therefore, none of the conditions (e.g., C1) or actions (e.g., A1) from the specification are visibly addressed within this function.",success,
14006,custom_ext_free_old_cb_wrap,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function 'custom_ext_free_old_cb_wrap' does not contain any logic that enforces or checks TLS version numbers or prevents the use of the Truncated HMAC extension as specified in the RFC. It only checks if a free callback is defined and then calls it, which does not address any of the labeled constraints from the TLS specification.",success,
14007,custom_ext_parse_old_cb_wrap,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],The function custom_ext_parse_old_cb_wrap merely wraps a call to an external callback (parse_cb) without any inline checks or logic to enforce or verify the TLS RFC constraints specified (such as not using the Truncated HMAC extension or checking that record versions are ≥ 0x0300). None of the conditions or actions defined in the spec are implemented directly within this function.,success,
14010,custom_ext_parse,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The function 'custom_ext_parse' does not contain any logic that explicitly checks or prohibits the use of the Truncated HMAC extension (as required by the RFC specification) nor does it address record version constraints. Its implementation only deals with locating custom extension methods, verifying their relevance based on context, and invoking parse callbacks if available. Therefore, no labeled conditions or actions (such as C1, A1, etc.) related to the spec constraints are directly addressed within this function.",success,
14010,custom_ext_parse,"-A server receiving a ClientHello MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters",358,Fully Matches,"[{'C1': {'code': 'if (!meth)\n    return 1;\n\nif (!extension_is_relevant(s, meth->context, context))\n    return 1;', 'explanation': 'These code segments ensure that if a ClientHello contains an extension that is either unrecognized (custom_ext_find returns NULL) or deemed irrelevant by extension_is_relevant, the function immediately returns success, thereby ignoring the unknown extension. This matches the spec requirement that a server receiving a ClientHello must correctly ignore all unrecognized extensions.'}}]","The function custom_ext_parse checks for a custom extension entry using custom_ext_find and then uses extension_is_relevant to confirm whether its processing is applicable. When the extension is not recognized or relevant, the function returns success without processing it further. This behavior directly implements the RFC mandate for a server to ignore unrecognized cipher suites, extensions, and other parameters in a ClientHello.",success,
14010,custom_ext_parse,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest.",59,Partially Matches,"[{'C1': {'code': 'if ((context & (SSL_EXT_TLS1_2_SERVER_HELLO\n                | SSL_EXT_TLS1_3_SERVER_HELLO\n                | SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS)) != 0) {\n    if ((meth->ext_flags & SSL_EXT_FLAG_SENT) == 0) {\n        SSLfatal(s, TLS1_AD_UNSUPPORTED_EXTENSION, SSL_R_BAD_EXTENSION);\n        return 0;\n    }\n}', 'explanation': ""This code segment checks that for ServerHello and EncryptedExtensions messages, an extension response is only allowed if the extension was previously received (flagged as sent). This corresponds to the requirement that implementing endpoints must not send unsolicited extension responses. However, it does not address the exception for the 'cookie' extension in HelloRetryRequest, so while it captures the core constraint, it is incomplete.""}}]","The function implements a check to ensure that during server response messages (specifically ServerHello and EncryptedExtensions), an extension is only processed if it was previously requested by the client, which aligns with part of the RFC requirement. However, the function does not incorporate logic to handle the exception for the 'cookie' extension in a HelloRetryRequest. As a result, the function only partially matches the RFC specification as it lacks a full implementation of the exception noted in the spec.",success,
14010,custom_ext_parse,"Upon receiving such an extension, an endpoint MUST abort the handshake with an ""unsupported_extension"" alert.",60,Fully Matches,"[{'C1': {'code': 'if ((context & (SSL_EXT_TLS1_2_SERVER_HELLO\n                    | SSL_EXT_TLS1_3_SERVER_HELLO\n                    | SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS)) != 0) {\n    if ((meth->ext_flags & SSL_EXT_FLAG_SENT) == 0) {\n        SSLfatal(s, TLS1_AD_UNSUPPORTED_EXTENSION, SSL_R_BAD_EXTENSION);\n        return 0;\n    }\n}', 'explanation': ""This segment checks that if the current context is one of the server response messages (ServerHello or EncryptedExtensions) and the extension was not previously sent by the client (indicated by the SSL_EXT_FLAG_SENT flag), then it aborts the handshake with an 'unsupported_extension' alert, thereby meeting the spec's requirements.""}}]","The provided function custom_ext_parse visibly implements the specified TLS RFC requirement by checking for the presence of the extension in client messages before handling it in server responses. If the extension does not meet this requirement, it calls SSLfatal with TLS1_AD_UNSUPPORTED_EXTENSION, thereby aborting the handshake as mandated by the RFC. This logic directly addresses the condition stated in the spec.",success,
14011,custom_ext_add,"As with the ServerHello, a HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the ""cookie"" (see Section 4.2.2) extension.",47,Partially Matches,"[{'C1': {'code': 'if ((context & (SSL_EXT_TLS1_2_SERVER_HELLO\n                        | SSL_EXT_TLS1_3_SERVER_HELLO\n                        | SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS\n                        | SSL_EXT_TLS1_3_CERTIFICATE\n                        | SSL_EXT_TLS1_3_RAW_PUBLIC_KEY\n                        | SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST)) != 0) {\n            /* Only send extensions present in ClientHello/CertificateRequest */\n            if (!(meth->ext_flags & SSL_EXT_FLAG_RECEIVED))\n                continue;\n        }', 'explanation': 'This segment prevents sending extensions in server responses (including HelloRetryRequest) if they were not received from the ClientHello, which directly addresses the specification requirement to only include extensions offered by the client (with the cookie exception not handled here).'}}]","The function implements logic to check that for server messages—including HelloRetryRequest—it only adds extensions that were previously received from the ClientHello. This addresses part of the RFC requirement (specifically, that a HelloRetryRequest MUST NOT contain any extensions not first offered by the client). However, the function does not implement the cookie exception nor does it address other aspects of the RFC (such as verifying change in ClientHello or handling other mandatory extensions), so it only partially matches the specified constraints.",success,
14011,custom_ext_add,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest.",59,Partially Matches,"[{'C1': {'code': 'if ((context & (SSL_EXT_TLS1_2_SERVER_HELLO\n                        | SSL_EXT_TLS1_3_SERVER_HELLO\n                        | SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS\n                        | SSL_EXT_TLS1_3_CERTIFICATE\n                        | SSL_EXT_TLS1_3_RAW_PUBLIC_KEY\n                        | SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST)) != 0) {\n            /* Only send extensions present in ClientHello/CertificateRequest */\n            if (!(meth->ext_flags & SSL_EXT_FLAG_RECEIVED))\n                continue;\n        }', 'explanation': ""This code segment ensures that for server-side messages (including HelloRetryRequest), an extension is only added if it was received in the client's request (i.e. the SSL_EXT_FLAG_RECEIVED flag is set). This partially implements the spec which mandates that unsolicited extension responses must not be sent. However, it lacks an explicit exception for the 'cookie' extension in the HelloRetryRequest as required by the RFC.""}}]","The function custom_ext_add contains logic to check whether an extension was previously received before adding it to the response message in several TLS contexts. This complies with part of the specification that requires implementations to avoid sending extension responses unless the corresponding request was received. However, the RFC specifies an exception for the 'cookie' extension in the HelloRetryRequest scenario, and this exception is not handled within this function's logic. Therefore, the implementation only partially matches the provided specification.",success,
14011,custom_ext_add,-TLS 1.2 ClientHellos MAY omit this extension.,99,Does Not Match,[],"The RFC specification indicates that TLS 1.2 ClientHellos may omit the extension. The provided function custom_ext_add iterates through custom extension methods and conditionally adds them based on callbacks, context flags, and helper functions such as should_add_extension. However, there is no visible logic within this function that explicitly implements or accommodates the TLS 1.2 behavior of optionally omitting the extension. There is no specific check for TLS 1.2 ClientHellos or handling based on the TLS version that would align with the RFC’s allowance to omit the extension. Thus, within the scope of this function alone, none of the labeled spec constraints (e.g., C1, A1) are addressed.",success,
14012,custom_exts_copy_flags,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function, custom_exts_copy_flags, only copies extension flags from one structure to another. It does not include any logic regarding TLS version checks or the exclusion of the Truncated HMAC extension as required by the specification. There is no code in this function that directly prevents the use of the insecure Truncated HMAC extension or enforces the version restrictions, and therefore it does not address any of the labeled conditions or actions from the spec constraints.",success,
14016,ossl_tls_add_custom_ext_intern,There MUST NOT be more than one extension of the same type in a given extension block.,63,Fully Matches,"[{'C1': {'code': 'if (custom_ext_find(exts, role, ext_type, NULL))\n        return 0;', 'explanation': 'This check prevents the addition of an extension if one with the same type is already present in the extension block, thereby enforcing the RFC requirement that there must not be more than one extension of the same type.'}}]","The function inspects the existing extension block using custom_ext_find and returns immediately if a duplicate extension is found. This directly implements the TLS RFC constraint that forbids multiple extensions of the same type in a block. Although the overall extension ordering and other details are managed elsewhere, within the scope of this function, the specified duplicate check is fully addressed.",success,
14017,add_old_custom_ext,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function 'add_old_custom_ext' only allocates and wraps custom extension callbacks before passing them to an internal function. There is no visible logic in this function that checks or handles TLS version numbers or the use of the Truncated HMAC extension as mandated by the TLS RFC. In particular, there is no code addressing the prohibition of the Truncated HMAC extension (as described in the spec constraint) or any other TLS version related checks. Therefore, the function does not attempt to implement any of the specific TLS RFC conditions or actions.",success,
14019,SSL_CTX_add_server_custom_ext,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function only registers a custom server extension by calling add_old_custom_ext with specific flags and does not contain any logic related to early data retransmission or ALPN protocol verification. There is no visible implementation within this code that checks whether early data should be resent, nor does it enforce the condition that early data should only be automatically resent if the negotiated connection selects the same ALPN protocol as assumed. Therefore, it does not address any of the TLS RFC constraints regarding early data retransmission.",success,
14020,SSL_CTX_add_custom_ext,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function does not contain any logic that enforces or implements the constraints specified in the TLS RFC. It simply acts as a wrapper that delegates to ossl_tls_add_custom_ext_intern without addressing any record version checks or the prohibition of the Truncated HMAC extension. Therefore, the function_body does not visibly address the labeled conditions or actions from the spec.",success,
14021,SSL_extension_supported,"Additionally, all implementations MUST support the use of the ""server_name"" extension with applications capable of using it",351,Partially Matches,"[{'C1': {'code': 'case TLSEXT_TYPE_server_name:', 'explanation': ""This line in the switch statement indicates that the server_name TLS extension is supported, directly addressing the RFC requirement that all implementations MUST support the use of the 'server_name' extension.""}}]","The function 'SSL_extension_supported' checks if a given extension type is supported and explicitly includes the server_name extension. This addresses the requirement to support the server_name extension. However, the function does not implement any logic to handle the handshake abort or 'missing_extension' alert when a ClientHello lacks the required server_name extension. As dependencies or other parts of the system may implement this behavior, within this function alone only part of the spec (supporting the extension) is handled.",success,
14021,SSL_extension_supported,"The client MAY send the ""certificate_authorities"" extension in the ClientHello message.",105,Fully Matches,"[{'C1': {'code': 'case TLSEXT_TYPE_certificate_authorities:\n    return 1;', 'explanation': 'The function explicitly handles the certificate_authorities extension by checking for TLSEXT_TYPE_certificate_authorities and returning 1, which indicates that the extension is supported. This directly implements the RFC specification that the client MAY send the certificate_authorities extension.'}}]","Within the function, there is an explicit case for TLSEXT_TYPE_certificate_authorities that returns a positive result, thereby supporting the behavior described in the TLS RFC. The logic is contained entirely within the function, fulfilling the specification requirement as defined in the constraints.",success,
14058,verify_extension,"-A server receiving a ClientHello MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters",358,Fully Matches,"[{'A1': {'code': '/* Unknown extension. We allow it */\n*found = NULL;\nreturn 1;', 'explanation': 'This code explicitly handles extensions that are not recognized by iterating through known extensions and custom extensions. When no matching extension is found, it sets *found = NULL and returns success, thereby ignoring unrecognized extensions as required by the spec for a server receiving a ClientHello.'}}]","The function verify_extension implements processing of TLS extensions by first checking for known built-in extensions and then custom extensions. If no extension matches the provided type, it does not produce an error but instead ignores the unrecognized extension (by setting *found to NULL and returning 1). This behavior directly corresponds to the specification requirement that a server must correctly ignore all unrecognized extensions, fulfilling the relevant spec constraint solely within this function.",success,
14060,tls_collect_extensions,"Servers MUST check that it is the last extension and otherwise fail the handshake with an ""illegal_parameter"" alert.",173,Fully Matches,"[{'A1': {'code': 'if (type == TLSEXT_TYPE_psk\n    && (context & SSL_EXT_CLIENT_HELLO) != 0\n    && PACKET_remaining(&extensions) != 0) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_EXTENSION);\n    goto err;\n}', 'explanation': 'This code segment directly implements the RFC requirement by checking that when processing a ClientHello, if the pre_shared_key extension (psk) is encountered, it must be the last extension. If not (i.e. if additional extension data remains), the function calls SSLfatal with the illegal_parameter alert and aborts the handshake.'}}]","The function processes incoming extensions and explicitly checks that the pre_shared_key extension is the final extension in the ClientHello message, failing the handshake with an 'illegal_parameter' alert when additional extensions follow. This behavior fulfills the specified RFC constraint regarding extension ordering entirely within this function.",success,
14060,tls_collect_extensions,"The ""pre_shared_key"" extension MUST be the last extension in the ClientHello (this facilitates implementation as described below)",172,Fully Matches,"[{'C1': {'code': 'if (type == TLSEXT_TYPE_psk\n                    && (context & SSL_EXT_CLIENT_HELLO) != 0\n                    && PACKET_remaining(&extensions) != 0) {\n            SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_EXTENSION);\n            goto err;\n        }', 'explanation': 'This check in the function body ensures that when processing a ClientHello, if the pre_shared_key (PSK) extension is encountered, it must be the last extension (i.e. there are no further bytes/extensions left to process). This directly implements the TLS RFC requirement that the pre_shared_key extension must be the last in the ClientHello.'}}]","The function explicitly verifies that in the ClientHello context, when the PSK extension is processed, it is the last extension by checking that no additional data remains in the packet. This fully addresses the specified constraint in the TLS RFC concerning the ordering of the pre_shared_key extension.",success,
14060,tls_collect_extensions,"If any other value is returned, the client MUST abort the handshake with an ""illegal_parameter"" alert.",171,Partially Matches,"[{'A1': {'code': 'if (type == TLSEXT_TYPE_psk\n                    && (context & SSL_EXT_CLIENT_HELLO) != 0\n                    && PACKET_remaining(&extensions) != 0) {\n            SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_EXTENSION);\n            goto err;\n        }', 'explanation': ""This snippet checks that the pre_shared_key (PSK) extension is the last one in a ClientHello message. If not, it aborts the handshake with an 'illegal_parameter' alert, which aligns with the spec requirement that the PSK extension MUST be the last extension.""}}]","The function partially implements the RFC spec constraints. It visibly addresses one specified aspect by enforcing the ordering of the pre_shared_key extension (ensuring it is the final extension) using an explicit check and invoking the appropriate error when the condition is violated. However, other conditions in the spec—such as verifying that the server's selected_identity is within the client-supplied range, confirming the cipher suite’s association with the PSK, or checking that key_share is present when required—are not addressed within this function. Thus, while it meets the PSK ordering requirement, it does not cover all of the spec constraints.",success,
14060,tls_collect_extensions,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function tls_collect_extensions collects and verifies TLS extensions in a generic way (e.g., checking for duplicate extensions, validating extension ordering, etc.), but it does not contain any explicit logic to address the specific RFC requirement that implementations MUST NOT use the Truncated HMAC extension. There is no code segment that explicitly checks for or rejects the truncated HMAC extension (or its corresponding constant, if one exists), nor is there any logic handling minimum record versions (such as rejecting versions less than 0x0300). Thus, within the function_body itself, the labeled constraint from the spec is not implemented.",success,
14060,tls_collect_extensions,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2(&extensions, &type) ||\n            !PACKET_get_length_prefixed_2(&extensions, &extension)) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n            goto err;\n        }', 'explanation': 'This segment checks if the packet cannot be parsed (e.g., insufficient data for the extension type or length) and terminates the connection with a decode_error alert, directly addressing the spec requirement.'}}]","The function directly implements the specified RFC requirement by verifying the packet’s syntax through PACKET_get_net_2 and PACKET_get_length_prefixed_2. When parsing fails, it invokes SSLfatal with SSL_AD_DECODE_ERROR, which forces connection termination with the proper alert level as specified. Although there are additional checks for semantic correctness (e.g., duplicate or unsolicited extensions triggering an illegal_parameter alert), the core requirement regarding handling messages that cannot be parsed is fully implemented within the function.",success,
14060,tls_collect_extensions,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2(&extensions, &type) ||\n            !PACKET_get_length_prefixed_2(&extensions, &extension)) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n            goto err;\n        }', 'explanation': ""This code segment checks if the extension packet is syntactically valid. If not, it calls SSLfatal with the 'decode_error' alert as required by the RFC.""}}, {'C2': {'code': 'if (!verify_extension(s, context, type, exts, raw_extensions, &thisex)\n                || (thisex != NULL && thisex->present == 1)\n                || (type == TLSEXT_TYPE_psk\n                    && (context & SSL_EXT_CLIENT_HELLO) != 0\n                    && PACKET_remaining(&extensions) != 0)) {\n            SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_EXTENSION);\n            goto err;\n        }', 'explanation': ""This code segment verifies the correctness and uniqueness of the extension. On detecting a semantically invalid condition (including duplicate or misplaced extensions), it terminates the connection with an 'illegal_parameter' alert, fulfilling the RFC requirement for semantically invalid messages.""}}]","The function 'tls_collect_extensions' implements validations for both syntactic and semantic errors of TLS extensions. It explicitly checks packet syntax and, on failure, issues a 'decode_error' alert (C1). Additionally, it verifies the semantic correctness of each extension (e.g., duplicate extensions or incorrect order for PSK) and calls SSLfatal with an 'illegal_parameter' alert (C2) when violations are detected. This direct handling within the function fulfills the specified RFC requirements.",success,
14060,tls_collect_extensions,"The server MAY also send unsolicited extensions in the NewSessionTicket, though the client does not respond directly to these.",58,Fully Matches,"[{'C1': {'code': 'if (idx < OSSL_NELEM(ext_defs)\n        && (context & (SSL_EXT_CLIENT_HELLO\n                       | SSL_EXT_TLS1_3_CERTIFICATE_REQUEST\n                       | SSL_EXT_TLS1_3_NEW_SESSION_TICKET)) == 0\n        && type != TLSEXT_TYPE_cookie\n        && type != TLSEXT_TYPE_renegotiate\n        && type != TLSEXT_TYPE_signed_certificate_timestamp\n#ifndef OPENSSL_NO_GOST\n        && !((context & SSL_EXT_TLS1_2_SERVER_HELLO) != 0\n             && type == TLSEXT_TYPE_cryptopro_bug)\n#endif\n        ) {\n    SSLfatal(s, SSL_AD_UNSUPPORTED_EXTENSION, SSL_R_UNSOLICITED_EXTENSION);\n    goto err;\n}', 'explanation': 'This code segment implements the check for unsolicited extensions. It allows extensions if the context flag for NewSessionTicket (among others) is set, which fulfills the RFC requirement that unsolicited extensions (like those in a NewSessionTicket) are acceptable. Extensions not requested by the client are rejected unless they belong to the allowed categories.'}}]","The function 'tls_collect_extensions' contains logic that checks whether an extension was expected or unsolicited. Specifically, it permits unsolicited extensions in contexts such as NewSessionTicket—fulfilling the RFC specification that the server may send unsolicited extensions in the NewSessionTicket without expecting a direct client response. Thus, the function fully addresses the relevant spec constraint within its own code.",success,
14060,tls_collect_extensions,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest.",59,Fully Matches,"[{'C1': {'code': 'if (idx < OSSL_NELEM(ext_defs)\n        && (context & (SSL_EXT_CLIENT_HELLO\n                       | SSL_EXT_TLS1_3_CERTIFICATE_REQUEST\n                       | SSL_EXT_TLS1_3_NEW_SESSION_TICKET)) == 0\n        && type != TLSEXT_TYPE_cookie\n        && type != TLSEXT_TYPE_renegotiate\n        && type != TLSEXT_TYPE_signed_certificate_timestamp\n        && (s->ext.extflags[idx] & SSL_EXT_FLAG_SENT) == 0\n#ifndef OPENSSL_NO_GOST\n        && !((context & SSL_EXT_TLS1_2_SERVER_HELLO) != 0\n             && type == TLSEXT_TYPE_cryptopro_bug)\n#endif\n       ) {\n    SSLfatal(s, SSL_AD_UNSUPPORTED_EXTENSION,\n             SSL_R_UNSOLICITED_EXTENSION);\n    goto err;\n}', 'explanation': ""This code block verifies that if an extension response is processed, it must have been properly requested by the remote endpoint. It explicitly checks that unsolicited extensions are not accepted, with an exception made for the 'cookie' extension, directly implementing the specified TLS RFC requirement.""}}]","The function tls_collect_extensions() incorporates a check to ensure that only extensions which were requested (as indicated by the 's->ext.extflags' flag) are processed, except for allowed exceptions such as the cookie extension in a HelloRetryRequest. This directly addresses the spec constraint that implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests. Since this check is performed within the function itself, it fully meets the constraint.",success,
14060,tls_collect_extensions,"Upon receiving such an extension, an endpoint MUST abort the handshake with an ""unsupported_extension"" alert.",60,Fully Matches,"[{'C1': {'code': 'if (idx < OSSL_NELEM(ext_defs)\n        && (context & (SSL_EXT_CLIENT_HELLO\n                       | SSL_EXT_TLS1_3_CERTIFICATE_REQUEST\n                       | SSL_EXT_TLS1_3_NEW_SESSION_TICKET)) == 0\n        && type != TLSEXT_TYPE_cookie\n        && type != TLSEXT_TYPE_renegotiate\n        && type != TLSEXT_TYPE_signed_certificate_timestamp\n        && (s->ext.extflags[idx] & SSL_EXT_FLAG_SENT) == 0\n#ifndef OPENSSL_NO_GOST\n        && !((context & SSL_EXT_TLS1_2_SERVER_HELLO) != 0\n             && type == TLSEXT_TYPE_cryptopro_bug)\n#endif\n        ) {\n    SSLfatal(s, SSL_AD_UNSUPPORTED_EXTENSION, SSL_R_UNSOLICITED_EXTENSION);\n    goto err;\n}', 'explanation': ""This code segment checks whether an unsolicited extension is received by ensuring that the extension was not previously sent/requested, and if so, it triggers a fatal alert with the 'unsupported_extension' alert code, directly addressing the condition from the RFC.""}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_UNSUPPORTED_EXTENSION, SSL_R_UNSOLICITED_EXTENSION);', 'explanation': ""On detecting an extension that was not appropriately requested, this call aborts the handshake by sending an 'unsupported_extension' alert, thus fulfilling the action required by the RFC specification.""}}]","The function 'tls_collect_extensions' includes explicit logic to verify that any received unsolicited extension is not allowed. When such an extension is found, it calls SSLfatal with SSL_AD_UNSUPPORTED_EXTENSION, thereby aborting the handshake as mandated by the RFC. The logic directly implemented in the function_body satisfies both the condition (C1) that unsolicited extensions should be detected and the action (A1) to abort the handshake with the appropriate alert.",success,
14060,tls_collect_extensions,"If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an ""illegal_parameter"" alert.",61,Fully Matches,"[{'C1': {'code': 'if (!verify_extension(s, context, type, exts, raw_extensions, &thisex)\n                || (thisex != NULL && thisex->present == 1)\n                || (type == TLSEXT_TYPE_psk\n                    && (context & SSL_EXT_CLIENT_HELLO) != 0\n                    && PACKET_remaining(&extensions) != 0)) {\n            SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_EXTENSION);\n            goto err;\n        }', 'explanation': ""This block checks if a recognized extension is duplicated or does not meet the ordering/placement requirements (for example, the PSK extension must be the last in ClientHello) and, if so, aborts the handshake with an 'illegal_parameter' alert as the RFC requires for extensions that appear in a message in which they are not specified.""}}, {'A1': {'code': 'if (idx < OSSL_NELEM(ext_defs)\n                && (context & (SSL_EXT_CLIENT_HELLO\n                               | SSL_EXT_TLS1_3_CERTIFICATE_REQUEST\n                               | SSL_EXT_TLS1_3_NEW_SESSION_TICKET)) == 0\n                && type != TLSEXT_TYPE_cookie\n                && type != TLSEXT_TYPE_renegotiate\n                && type != TLSEXT_TYPE_signed_certificate_timestamp\n                && (s->ext.extflags[idx] & SSL_EXT_FLAG_SENT) == 0\n#ifndef OPENSSL_NO_GOST\n                && !((context & SSL_EXT_TLS1_2_SERVER_HELLO) != 0\n                     && type == TLSEXT_TYPE_cryptopro_bug)\n#endif\n                       ) {\n            SSLfatal(s, SSL_AD_UNSUPPORTED_EXTENSION,\n                     SSL_R_UNSOLICITED_EXTENSION);\n            goto err;\n        }', 'explanation': ""This section ensures that only extensions explicitly requested (or permitted in specific scenarios such as the cookie extension in HRR) are accepted. If a built-in extension is received in a context where it was not expected, it aborts the handshake with an 'unsupported_extension' alert, which aligns with the RFC’s requirement for unsolicited extensions.""}}]","The tls_collect_extensions function processes incoming TLS extensions by first checking their validity and ensuring no duplicates or ordering issues occur, and then by verifying that the extension is appropriate for the message context. In the event a recognized extension appears in an unsupported context, the function aborts the handshake with either an 'illegal_parameter' or 'unsupported_extension' alert as defined by the RFC specification. All checks are done within this function without deferring to dependencies, thereby fully implementing the specified TLS extension behavior.",success,
14060,tls_collect_extensions,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Fully Matches,"[{'C1': {'code': 'if (type == TLSEXT_TYPE_psk\n                    && (context & SSL_EXT_CLIENT_HELLO) != 0\n                    && PACKET_remaining(&extensions) != 0)', 'explanation': 'This code checks that if the pre_shared_key extension is encountered in a ClientHello, there are no further extensions remaining, thereby enforcing that pre_shared_key is the last extension.'}}, {'C2': {'code': 'if (!verify_extension(s, context, type, exts, raw_extensions, &thisex)\n            || (thisex != NULL && thisex->present == 1)\n            || ... )', 'explanation': 'This segment ensures that duplicate extensions (i.e. more than one extension of the same type) are rejected, satisfying the spec requirement that no extension appears more than once.'}}]","The function tls_collect_extensions() visibly implements the key constraints specified in the RFC. It enforces that the pre_shared_key extension in a ClientHello is the last one (C1) by checking if any data follows it, and it prevents duplicate extensions (C2) by ensuring a given extension type is only processed once. These code segments directly address the corresponding spec constraints within the function, fulfilling the requirements in isolation.",success,
14060,tls_collect_extensions,There MUST NOT be more than one extension of the same type in a given extension block.,63,Partially Matches,"[{'C1': {'code': 'if (!verify_extension(s, context, type, exts, raw_extensions, &thisex)\n        || (thisex != NULL && thisex->present == 1)\n        || (type == TLSEXT_TYPE_psk\n            && (context & SSL_EXT_CLIENT_HELLO) != 0\n            && PACKET_remaining(&extensions) != 0)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_EXTENSION);\n    goto err;\n}', 'explanation': 'This segment checks for duplicate extensions by verifying if a recognized extension (thisex) is already marked as present. If so, it triggers an error, thereby enforcing that no more than one instance of that recognized extension type is allowed.'}}]","The TLS RFC specifies that there must not be more than one extension of the same type in an extension block. The function implements a duplicate check for recognized extensions through the condition (thisex != NULL && thisex->present == 1), which effectively prevents duplicate occurrences of extensions it recognizes. However, as noted in the comments, the function only enforces this check for known extensions and does not handle duplicates for unrecognized ones, leading to a partial match of the spec constraint within the function itself.",success,
14060,tls_collect_extensions,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2(&extensions, &type) ||\n    !PACKET_get_length_prefixed_2(&extensions, &extension)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    goto err;\n}', 'explanation': 'This segment validates the structure of the extensions block and aborts the handshake with a decode_error alert when the extension cannot be parsed correctly, which reflects part of the specification requirement.'}}]","The function does address a key aspect of the RFC specification by checking that the extensions block is well-formed and by aborting the handshake with a decode_error alert if the parsing fails. However, several aspects of the complete spec—such as ensuring that no extra data follows the legacy_compression_methods in TLS versions prior to 1.3 or verifying the presence of specific extensions (like supported_versions for TLS1.3)—are either handled elsewhere or not implemented within this function. As a result, while the function includes visible logic for some conditions (labeled here as C1), it does not fully implement all the requirements of the RFC specification on its own.",success,
14061,tls_parse_extension,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function does not contain any logic that explicitly addresses the RFC specification constraints. In particular, there is no check or mechanism within this function to avoid the use of the Truncated HMAC extension (as specified in the RFC) or to enforce any record version requirements (e.g., version >= 0x0300). The function simply checks if an extension is present and whether it has been parsed, and then delegates processing to built-in or custom extension parsers. None of these operations implement or enforce the security constraints outlined in the spec.",success,
14061,tls_parse_extension,-TLS 1.2 ClientHellos MAY omit this extension.,99,Partially Matches,"[{'C1': {'code': 'if (!currext->present)\n    return 1;', 'explanation': 'This code explicitly checks if the extension is missing and returns normally, thereby supporting the TLS 1.2 ClientHellos MAY omit this extension requirement.'}}]","The function contains logic that addresses the specification's requirement that TLS 1.2 ClientHellos may omit the extension by returning immediately when the extension is not present. However, other TLS 1.2-specific requirements such as handling the hash/signature pair encoding and enforcing the deprecation of legacy algorithms (e.g., MD5, SHA-224, DSA) in the extension are not visibly handled within this function. Therefore, the implementation only partially meets the provided spec constraints.",success,
14064,tls_construct_extensions,-TLS 1.2 ClientHellos MAY omit this extension.,99,Partially Matches,"[{'C1': {'code': 'if (!WPACKET_start_sub_packet_u16(pkt)\n           || ((context & (SSL_EXT_CLIENT_HELLO | SSL_EXT_TLS1_2_SERVER_HELLO)) != 0\n               && !WPACKET_set_flags(pkt, WPACKET_FLAGS_ABANDON_ON_ZERO_LENGTH))) { ... }', 'explanation': 'This block sets the flag WPACKET_FLAGS_ABANDON_ON_ZERO_LENGTH for ClientHello messages. This ensures that if no extensions are added, then the extension length field isn’t included in the Handshake message, effectively allowing the omission of the extension, as permitted by TLS 1.2.'}}]","The function includes logic that allows the extension to be omitted from the ClientHello if no extension data is added (C1). However, it does not show any specific handling for TLS 1.2's requirements concerning the encoding of hash/signature pairs or the prohibition of deprecated algorithms such as MD5, SHA-224, and DSA (C2). Since only part of the spec constraints are visibly handled within this function, the overall judgment is 'Partially Matches'.",success,
14068,final_server_name,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function only processes Server Name Indication (SNI) and related session handling, ticket management, and context switching. It does not include any logic regarding OCSP responses or the status_request_v2 extension. Therefore, it does not address any labeled condition or action related to the TLS 1.3 requirement that servers MUST NOT send the status_request_v2 extension when processing ClientHello messages.",success,
14068,final_server_name,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data.",320,Partially Matches,"[{'C1': {'code': 'if (!ossl_assert(sctx != NULL) || !ossl_assert(s->session_ctx != NULL)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}\n\n...\n\ncase SSL_TLSEXT_ERR_ALERT_FATAL:\n    SSLfatal(s, altmp, SSL_R_CALLBACK_FAILED);\n    return 0;', 'explanation': 'The function checks for error conditions (e.g. via assertion failures and failure in session ID generation) and, upon detecting one, calls SSLfatal with an appropriate alert code. This indicates that it attempts to send a fatal alert when a fatal error is encountered.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n\n...\n\ncase SSL_TLSEXT_ERR_ALERT_FATAL:\n    SSLfatal(s, altmp, SSL_R_CALLBACK_FAILED);\n    return 0;', 'explanation': 'The function uses SSLfatal to dispatch fatal alerts when error conditions occur, which aligns with sending an appropriate fatal alert as required by the spec.'}}]","The RFC requires that on a fatal error, an appropriate fatal alert is sent and the connection is closed without further data exchange. This function shows logic to detect error conditions and sends fatal alerts via SSLfatal. However, while it returns 0 after the alert (implying an error), it does not explicitly close the connection or block further data transmission within its own scope. As such, the fatal alert sending part (actions like A1) is handled here, but the closure of the connection is likely handled elsewhere, not directly visible in this function. Therefore, the function partially matches the RFC requirement.",success,
14068,final_server_name,"Upon transmission or receipt of a fatal alert message, both parties MUST immediately close the connection.",319,Partially Matches,"[{'A1': {'code': 'case SSL_TLSEXT_ERR_ALERT_FATAL:\n    SSLfatal(s, altmp, SSL_R_CALLBACK_FAILED);\n    return 0;\n\nif (!ossl_assert(sctx != NULL) || !ossl_assert(s->session_ctx != NULL)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}\n\nif (!ssl_generate_session_id(s, ss)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}', 'explanation': 'The code calls SSLfatal() in several places when a fatal error condition is encountered (e.g., callback failure, internal error, error generating a session ID). Calling SSLfatal() is intended to send a fatal alert, which aligns with the TLS RFC requirement that a fatal alert be sent upon detecting a fatal error. However, the function itself does not explicitly close the connection, relying on the SSLfatal() implementation to handle the closing. This constitutes only a partial fulfillment of the specification.'}}]","The provided function implements part of the behavior required by the TLS RFC by calling SSLfatal() to send fatal alerts when fatal error conditions are detected. This corresponds to the specification's instruction to send a fatal alert upon error detection. However, the RFC also mandates that both parties immediately close the connection upon transmission or receipt of a fatal alert. This function does not contain explicit logic to close the connection; it relies on the SSLfatal() mechanism (or higher-level processing) to perform that action. Therefore, while the function addresses the alerting aspect (A1), it only partially fulfills the overall requirement set by the specification.",success,
14069,final_ec_pt_formats,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'A1': {'code': 'if (i == s->ext.peer_ecpointformats_len) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST);\n    return 0;\n}', 'explanation': ""This code segment checks the server's EC point formats list for the required uncompressed value. If absent, it terminates the connection by calling SSLfatal with the 'illegal_parameter' alert, directly satisfying the TLS RFC requirement that a syntactically valid but semantically invalid message must trigger an illegal_parameter alert.""}}]","The function explicitly verifies that when an ECC cipher suite is in use, the server's EC point formats extension includes the uncompressed format. If not, it terminates the connection with an 'illegal_parameter' alert. This behavior directly implements the TLS RFC specification as required, ensuring that semantically invalid messages lead to a fatal termination.",success,
14083,tls_construct_certificate_authorities,"The ""certificate_authorities"" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which SHOULD be used by the receiving endpoint to guide certificate selection.",104,Fully Matches,"[{'C1': {'code': 'if (ca_sk == NULL || sk_X509_NAME_num(ca_sk) == 0)\n    return EXT_RETURN_NOT_SENT;', 'explanation': 'The function checks whether any certificate authorities (CA names) are available by verifying that the CA names stack is non-null and non-empty, which aligns with the condition of having valid CA data to construct the extension.'}}, {'A1': {'code': 'if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_certificate_authorities)\n    || !WPACKET_start_sub_packet_u16(pkt)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return EXT_RETURN_FAIL;\n}\n\nif (!construct_ca_names(s, ca_sk, pkt)) {\n    /* SSLfatal() already called */\n    return EXT_RETURN_FAIL;\n}\n\nif (!WPACKET_close(pkt)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return EXT_RETURN_FAIL;\n}\n\nreturn EXT_RETURN_SENT;', 'explanation': 'This code segment builds the certificate_authorities extension by first writing the extension type, initiating the sub-packet for the extension body, incorporating the actual CA names using construct_ca_names(), and finishing the packet. This process meets the action requirement of correctly encoding the CertificateAuthoritiesExtension structure per the RFC.'}}]","The function 'tls_construct_certificate_authorities' directly implements the necessary logic for constructing the certificate_authorities extension as specified by the TLS RFC. It first verifies the availability of CA names (fulfilling C1) and then builds the extension by encoding the extension type, adding the CA names, and finalizing the packet (fulfilling A1). All logic required to implement the extension is contained within the function, independent of external dependencies.",success,
14084,tls_parse_certificate_authorities,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This code block checks if there are extra bytes remaining in the packet after parsing the certificate authorities, which corresponds to the condition in the RFC that requires checking for extraneous data.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);', 'explanation': 'When extra data is found, the code calls SSLfatal to abort the handshake with a decode_error alert, fulfilling the action specified in the RFC.'}}]","The function explicitly checks for any remaining data in the packet after processing the certificate authorities. If such data exists, it aborts the handshake by calling SSLfatal with a decode_error alert, thereby directly implementing the RFC's requirement. As this logic is contained within the function itself, it fully meets the spec constraints.",success,
14084,tls_parse_certificate_authorities,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This code checks if there are remaining bytes in the packet after parsing the certificate authorities. An excess indicates a parsing error, fulfilling the requirement that messages which cannot be parsed according to the syntax must be rejected.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);', 'explanation': ""Upon detecting extra data in the packet, the function calls SSLfatal with SSL_AD_DECODE_ERROR, thereby terminating the connection with the appropriate 'decode_error' alert as required by the spec.""}}]",The function 'tls_parse_certificate_authorities' implements the TLS parsing guideline by checking for leftover data (indicative of a parsing error) and then terminating the connection via SSLfatal with a 'decode_error' alert. This directly addresses the RFC requirement that any syntactically incorrect message causes a 'decode_error' alert to be sent and the connection to be terminated.,success,
14086,final_sig_algs,"Clients which desire the server to authenticate itself via a certificate MUST send the ""signature_algorithms"" extension.",82,Fully Matches,"[{'C1': {'code': 'if (!sent && SSL_CONNECTION_IS_TLS13(s) && !s->hit) {\n    SSLfatal(s, TLS13_AD_MISSING_EXTENSION, SSL_R_MISSING_SIGALGS_EXTENSION);\n    return 0;\n}', 'explanation': ""This code checks if the 'signature_algorithms' extension was not sent (i.e. !sent) in a non-resumed TLS 1.3 connection and aborts the handshake with a missing_extension alert. This directly implements the requirement that clients which expect the server to authenticate via a certificate must send the extension.""}}]",The function 'final_sig_algs' directly verifies the presence of the 'signature_algorithms' extension by checking the 'sent' flag and aborts the handshake with a missing_extension alert if the extension is not provided. This behavior aligns with the RFC specification requiring that clients send the extension when expecting certificate-based authentication.,success,
14088,final_key_share,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The RFC specifies that the server MUST NOT send a ""psk_key_exchange_modes"" extension. The provided function, final_key_share, does not contain any logic that prevents or manages the sending of a ""psk_key_exchange_modes"" extension from the server. Although it references the psk_kex_mode field (e.g., in conditions checking if certain flags are set for key exchange modes), this function is solely focused on processing key share values and handling HelloRetryRequest scenarios rather than managing the inclusion or exclusion of the ""psk_key_exchange_modes"" extension. Thus, within the function itself, no code addresses the specific RFC constraint regarding the server not sending the extension.",success,
14088,final_key_share,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function final_key_share implements logic related to the key_share extension processing, including handling the presence or absence of a key_share and managing HelloRetryRequest scenarios. However, there is no visible logic within this function that addresses the RFC requirement that clients MUST NOT act upon any information in the supported_groups extension before a successful handshake. In other words, while the function deals with key_share negotiation, it does not check or enforce the behavior stipulated for supported_groups, and therefore it does not meet the specified RFC constraint.",success,
14088,final_key_share,"Servers receiving a ClientHello which does not conform to these requirements MUST abort the handshake with a ""missing_extension"" alert.",350,Partially Matches,"[{'C1': {'code': 'if (!s->server && !sent) {\n    if ((s->ext.psk_kex_mode & TLSEXT_KEX_MODE_FLAG_KE) == 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_NO_SUITABLE_KEY_SHARE);\n        return 0;\n    }\n    if (!s->hit) {\n        SSLfatal(s, SSL_AD_MISSING_EXTENSION, SSL_R_NO_SUITABLE_KEY_SHARE);\n        return 0;\n    }\n}', 'explanation': ""On the client side, this segment checks for the presence of a key_share. If none is sent (and conditions on resumption/kex_mode are not met), it aborts the handshake with a 'missing_extension' alert, partially meeting the spec's requirement to reject non-conforming ClientHellos.""}}, {'A1': {'code': 'if (!s->hit || (s->ext.psk_kex_mode & TLSEXT_KEX_MODE_FLAG_KE) == 0) {\n    SSLfatal(s, sent ? SSL_AD_HANDSHAKE_FAILURE : SSL_AD_MISSING_EXTENSION, SSL_R_NO_SUITABLE_KEY_SHARE);\n    return 0;\n}', 'explanation': 'On the server side, when no suitable key_share is available, this part aborts the handshake (using a missing_extension or handshake_failure alert based on state), aligning with the spec’s mandate to terminate connections that do not meet extension requirements.'}}]","The function final_key_share implements logic to check for the presence of a key_share extension and aborts the handshake with an appropriate alert when the key_share is missing under certain conditions. This directly addresses the spec’s requirement for aborting when a required extension is missing. However, the RFC also mandates that if a supported_groups extension is present then a key_share must also be included (and vice versa), as well as stipulating requirements regarding the server_name extension. Since this function only handles key_share-related checks and does not make any visible checks for supported_groups or server_name, it only partially matches the overall specification constraints.",success,
14088,final_key_share,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6).",10,Fully Matches,"[{'C1': {'code': 'if (!s->hit || (s->ext.psk_kex_mode & TLSEXT_KEX_MODE_FLAG_KE) == 0) {\n    SSLfatal(s, sent ? SSL_AD_HANDSHAKE_FAILURE : SSL_AD_MISSING_EXTENSION, SSL_R_NO_SUITABLE_KEY_SHARE);\n    return 0;\n}', 'explanation': 'This branch in the server side logic checks if there is no valid key_share (i.e. no overlap in parameters between client and server) by verifying the hit flag and kex_mode. This corresponds to the condition in the RFC where, if unsupported parameters are negotiated, the handshake must be aborted.'}}, {'A1': {'code': 'SSLfatal(s, sent ? SSL_AD_HANDSHAKE_FAILURE : SSL_AD_MISSING_EXTENSION, SSL_R_NO_SUITABLE_KEY_SHARE);\nreturn 0;', 'explanation': 'This code aborts the handshake with a fatal alert (using handshake_failure when appropriate), which matches the RFC requirement that the handshake must be terminated with a fatal alert when no supported set of parameters can be negotiated.'}}]","The function explicitly checks on the server side whether a suitable key_share (i.e. a matching set of cryptographic parameters) has been negotiated. When no such share exists, it calls SSLfatal with a handshake failure alert (or an alternative alert) to abort the handshake. This logic directly reflects the RFC's mandate that in the absence of an overlap in supported parameters, the handshake must be aborted with an appropriate fatal alert.",success,
14088,final_key_share,"If the server selects an (EC)DHE group and the client did not offer a compatible ""key_share"" extension in the initial ClientHello, the server MUST respond with a HelloRetryRequest (Section 4.1.4) message.",9,Partially Matches,"[{'C1': {'code': 'if (s->server) {\n    if (s->s3.peer_tmp != NULL) {\n        /* We have a suitable key_share */\n        if ((s->s3.flags & TLS1_FLAGS_STATELESS) != 0 && !s->ext.cookieok) {\n            ...\n            s->hello_retry_request = SSL_HRR_PENDING;\n            return 1;\n        }\n    } else {\n        /* No suitable key_share */\n        if (s->hello_retry_request == SSL_HRR_NONE && sent && (!s->hit || (s->ext.psk_kex_mode & TLSEXT_KEX_MODE_FLAG_KE_DHE) != 0)) {\n            if (s->s3.group_id_candidate != 0) {\n                /* A shared group exists so send a HelloRetryRequest */\n                s->s3.group_id = s->s3.group_id_candidate;\n                s->hello_retry_request = SSL_HRR_PENDING;\n                return 1;\n            }\n        }\n        ...\n    }\n}', 'explanation': 'This segment checks whether the server has a suitable key_share from the client. If s->s3.peer_tmp is NULL – indicating no proper key_share was provided – and a candidate group is detected (s->s3.group_id_candidate != 0), the code sets hello_retry_request to HRR_PENDING. This reflects the RFC’s requirement that when an (EC)DHE group is selected but the client did not supply a compatible key_share, the server must issue a HelloRetryRequest.'}}, {'A1': {'code': 's->hello_retry_request = SSL_HRR_PENDING;', 'explanation': 'By marking hello_retry_request as pending, the function prepares to send a HelloRetryRequest, fulfilling the action part of the specification.'}}]","The function 'final_key_share' incorporates logic to respond with a HelloRetryRequest under conditions where the server detects that the client did not offer a compatible key_share (i.e. when a candidate (EC)DHE group is found but no corresponding key share was provided). This is evidenced in the server branch where, if no suitable key_share is present and a shared group candidate exists, the function sets s->hello_retry_request to SSL_HRR_PENDING and returns early – thereby attempting to implement the RFC requirement. However, the function also addresses additional scenarios (including client side and PSK-related conditions) and delegates some responsibilities to other parts of the system, which means not all aspects of the RFC’s detailed constraints are exclusively handled here. Therefore, while this function visibly implements the core condition and action regarding HelloRetryRequest issuance, it does not cover every nuance of the overall specification by itself, leading to a partial match.",success,
14088,final_key_share,"When sending a HelloRetryRequest, the server MAY provide a ""cookie"" extension to the client (this is an exception to the usual rule that the only extensions that may be sent are those that appear in the ClientHello).",77,Fully Matches,"[{'C1': {'code': 'if ((s->s3.flags & TLS1_FLAGS_STATELESS) != 0 && !s->ext.cookieok) {\n    if (!ossl_assert(s->hello_retry_request == SSL_HRR_NONE)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    s->hello_retry_request = SSL_HRR_PENDING;\n    return 1;\n}', 'explanation': ""This segment checks whether the server is operating statelessly and whether the cookie extension has not been accepted (i.e. s->ext.cookieok is false). In that case, it marks the need for a HelloRetryRequest by setting s->hello_retry_request to a pending state. This directly implements the specification's allowance for including a cookie in a HelloRetryRequest to offload state.""}}]","The function contains explicit logic that addresses the TLS RFC specification regarding the cookie extension. In particular, when operating in stateless mode and lacking a valid cookie (as indicated by s->ext.cookieok), it triggers a HelloRetryRequest which is the mechanism mandated by the spec. Thus, the function visibly implements the spec constraint about providing a cookie extension in a HelloRetryRequest, fulfilling the labeled condition (C1) as delineated in the provided spec.",success,
14090,tls_psk_do_binder,"If the verification fails, the receiver MUST terminate the handshake with a ""decrypt_error"" alert.",231,Fully Matches,"[{'A1': {'code': 'ret = (CRYPTO_memcmp(binderin, binderout, hashsize) == 0);\nif (!ret)\n    SSLfatal(s, SSL_AD_DECRYPT_ERROR, SSL_R_BINDER_DOES_NOT_VERIFY);', 'explanation': ""This code segment checks the verification of the binder. If verification fails (i.e. the computed binder does not match the received binder), the function immediately terminates the handshake by invoking SSLfatal with the 'decrypt_error' alert. This behavior directly implements the RFC requirement that if the verification fails, the receiver MUST terminate the handshake with a 'decrypt_error' alert.""}}]","The function implements the necessary binder verification procedure entirely within its body. In particular, when the binder verification fails it invokes SSLfatal with the SSL_AD_DECRYPT_ERROR alert, which fulfills the RFC specification constraint that mandates terminating the handshake with a 'decrypt_error' alert upon verification failure. Therefore, the function fully matches the specified protocol requirement.",success,
14090,tls_psk_do_binder,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Fully Matches,"[{'C1': {'code': 'early_secret = (unsigned char *)s->early_secret;  \nif (!tls13_generate_secret(s, md, NULL, sess->master_key, sess->master_key_length, early_secret)) { ... }\n\nif (!tls13_hkdf_expand(s, md, early_secret, label, labelsize, hash, hashsize, binderkey, hashsize, 1)) { ... }', 'explanation': 'The code first generates an early_secret (which is produced by an HKDF-Extract operation inside tls13_generate_secret) and then immediately applies tls13_hkdf_expand to it, ensuring that an output from an HKDF-Extract is not directly used as an input to a subsequent HKDF-Extract. This ordering strictly adheres to the RFC requirement.'}}]","The function tls_psk_do_binder explicitly implements the required ordering. It derives the early_secret (via a call to tls13_generate_secret, which internally likely uses HKDF-Extract) and then correctly feeds that secret into tls13_hkdf_expand (the HKDF-Expand call). This enforces the RFC guideline that mandates an HKDF-Expand between consecutive HKDF-Extract applications. Therefore, based solely on the code within the function, the constraint is fully addressed.",success,
14091,final_early_data,"If these values are not consistent, the client MUST abort the handshake with an ""illegal_parameter"" alert.",169,Partially Matches,"[{'C1': {'code': 'if (context == SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS\n                && sent\n                && !s->ext.early_data_ok) {\n            SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_EARLY_DATA);\n            return 0;\n        }', 'explanation': 'This code block in the client branch checks for an inconsistency during early data processing and aborts the handshake by triggering an illegal_parameter alert, which corresponds to the specification stating that the client MUST abort the handshake with an illegal_parameter alert if values are not consistent.'}}]","The function 'final_early_data' attempts to address part of the TLS RFC requirement by validating early data parameters on the client side. Specifically, it checks whether early_data conditions are inconsistent and, if so, aborts the handshake with an illegal_parameter alert. However, other specified validations (such as verifying the server's selected_identity and related cipher suite checks) are either handled elsewhere or not implemented within this function. Therefore, while the function does match part of the spec constraint (labeled as C1 here), it does not cover the entire set of specified conditions and actions.",success,
14091,final_early_data,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': ""if (context == SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS\n        && sent\n        && !s->ext.early_data_ok) {\n    /*\n     * If we get here then the server accepted our early_data but we\n     * later realised that it shouldn't have done (e.g. inconsistent\n     * ALPN)\n     */\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_EARLY_DATA);\n    return 0;\n}"", 'explanation': ""This code segment checks for a condition where early data is considered semantically invalid (e.g., early_data not being permitted) and terminates the connection by calling SSLfatal with an 'illegal_parameter' alert. This corresponds to the part of the RFC that requires peers to terminate the connection with an 'illegal_parameter' alert when receiving a semantically invalid message.""}}]","The TLS RFC requires connections to be terminated with an 'illegal_parameter' alert when a semantically invalid message is received. The provided function checks a specific early data condition where the server wrongly accepts early data (e.g., due to inconsistent ALPN) and, if detected, calls SSLfatal with SSL_AD_ILLEGAL_PARAMETER. However, this function only handles this particular case related to early data and does not cover other cases (such as messages that cannot be parsed and should trigger a 'decode_error' alert) mentioned in the RFC. Thus, while it does implement the required behavior for one scenario, it only partially addresses the complete specification.",success,
14091,final_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Partially Matches,"[{'A1': {'code': ""if (context == SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS\n        && sent\n        && !s->ext.early_data_ok) {\n    /* If we get here then the server accepted our early_data but we\n     * later realised that it shouldn't have done (e.g. inconsistent\n     * ALPN)\n     */\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_EARLY_DATA);\n    return 0;\n}"", 'explanation': 'This client‐side branch checks if the early_data_ok flag is false (which may occur due to an ALPN mismatch) and triggers an error, thereby ensuring that early data is not automatically processed when the negotiated ALPN protocol differs.'}}, {'C1': {'code': 'if (s->max_early_data == 0\n        || !s->hit\n        || s->early_data_state != SSL_EARLY_DATA_ACCEPTING\n        || !s->ext.early_data_ok\n        || s->hello_retry_request != SSL_HRR_NONE\n        || (s->allow_early_data_cb != NULL\n            && !s->allow_early_data_cb(SSL_CONNECTION_GET_USER_SSL(s),\n                                       s->allow_early_data_cb_data))) {\n    s->ext.early_data = SSL_EARLY_DATA_REJECTED;\n} else {\n    s->ext.early_data = SSL_EARLY_DATA_ACCEPTED;\n\n    if (!tls13_change_cipher_state(s,\n                SSL3_CC_EARLY | SSL3_CHANGE_CIPHER_SERVER_READ)) {\n        /* SSLfatal() already called */\n        return 0;\n    }\n}', 'explanation': 'On the server side, the function only accepts early data when multiple conditions are met – including that early_data_ok is true – rejecting it otherwise. This ensures that early data is not automatically retransmitted unless the necessary conditions (such as matching ALPN) are satisfied.'}}]","The provided function implements checks that prevent the automatic acceptance of early data when conditions are not met—most notably when the early_data_ok flag is false (which can result from an ALPN mismatch). This aligns with the TLS RFC requirement that early data should not be automatically resent unless the negotiated connection selects the same ALPN protocol. However, the function itself does not perform any automatic retransmission; instead, it finalizes the handshake state based on early data validity. Thus, it partially matches the specification by addressing the rejection of early data under inappropriate conditions, while leaving the retransmission decision to the application.",success,
14094,final_psk,"In order to use PSKs, clients MUST also send a ""psk_key_exchange_modes"" extension.",135,Fully Matches,"[{'C1': {'code': 'if (s->server && sent && s->clienthello != NULL && !s->clienthello->pre_proc_exts[TLSEXT_IDX_psk_kex_modes].present)', 'explanation': ""This condition checks that if the connection is a server-side instance and a PSK is being processed (indicated by 'sent' flag) then the client must have provided the 'psk_key_exchange_modes' extension. If the extension is not present, it indicates that the client offered the 'pre_shared_key' extension without the required accompanying extension, which matches the specification constraint.""}}, {'A1': {'code': 'SSLfatal(s, TLS13_AD_MISSING_EXTENSION, SSL_R_MISSING_PSK_KEX_MODES_EXTENSION);', 'explanation': ""This action aborts the handshake by sending a fatal alert if the 'psk_key_exchange_modes' extension is missing. This implementation directly enforces the requirement to abort the handshake when a client offers 'pre_shared_key' without the required 'psk_key_exchange_modes' extension, as specified in the RFC.""}}]","The function checks whether the client provided the 'psk_key_exchange_modes' extension when using PSKs by inspecting the clienthello structure. If the extension is missing, it invokes an error that aborts the handshake. This directly implements both the condition (C1) that a client must include the extension and the action (A1) to abort the handshake if it is not present, fulfilling the specified RFC requirement.",success,
14098,tls_parse_compress_certificate,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function (tls_parse_compress_certificate) is focused on handling certificate compression, specifically processing and validating supported compression algorithms for certificates. It does not contain any logic that relates to cipher suite negotiation, RC4, or minimum cipher strength requirements (such as disallowing RC4 or ciphers below 112 bits). Therefore, it does not address any of the TLS RFC spec constraints that mandate 'MUST NOT offer or negotiate RC4 cipher suites' or enforce minimum cipher strength requirements.",success,
14098,tls_parse_compress_certificate,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'A1': {'code': 'if (!PACKET_as_length_prefixed_1(pkt, &supported_comp_algs) || PACKET_remaining(&supported_comp_algs) == 0) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': ""This code segment checks if the extension data is properly formatted (i.e. a valid length-prefixed field with content). If not, it aborts the handshake by calling SSLfatal with a 'decode_error' alert, which corresponds to the RFC mandate of aborting the handshake when the extension is malformed.""}}]","The function 'tls_parse_compress_certificate' directly implements part of the RFC specification by validating the extension data and aborting the handshake with a 'decode_error' alert if the validation fails. However, the RFC also imposes additional conditions regarding the presence and formatting of data (e.g., handling of possible extra bytes after legacy_compression_methods) which are not addressed within this function. Thus, while the function meets the specific action of aborting the handshake when the extension is invalid, it does not cover all the conditions described in the RFC specification, resulting in a partial match.",success,
14098,tls_parse_compress_certificate,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_1(pkt, &supported_comp_algs) || PACKET_remaining(&supported_comp_algs) == 0) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This segment checks that the incoming packet is properly parsed using a length-prefixed method and that there is remaining data. If these checks fail, it calls SSLfatal with a decode_error alert (SSL_AD_DECODE_ERROR), thereby enforcing the RFC requirement that a syntactically invalid message triggers a termination with a decode_error alert.'}}]","The function directly implements the parsing of a PACKET and properly handles failure cases by issuing a decode_error alert. This aligns with the TLS RFC specification that mandates termination of the connection with a decode_error alert when a message cannot be parsed correctly. Since the required condition is handled within the function, it fully matches the specified constraint.",success,
14099,init_server_cert_type,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The target function simply resets the certificate type fields for a server context (when sc->server is true) by setting them to default X.509 values. There is no logic that checks, ignores, or prevents processing of the status_request_v2 extension, nor any handling related to the TLS 1.3 requirements as specified. Therefore, no part of this function attempts to address the TLS 1.3 constraint regarding the status_request_v2 extension per the RFC.",success,
14102,tls_construct_ctos_server_name,"Additionally, all implementations MUST support the use of the ""server_name"" extension with applications capable of using it",351,Partially Matches,"[{'C1': {'code': 'if (s->ext.hostname == NULL)\n    return EXT_RETURN_NOT_SENT;\n\n/* Add TLS extension servername to the Client Hello message */\nif (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_server_name)\n       || !WPACKET_start_sub_packet_u16(pkt)\n       || !WPACKET_start_sub_packet_u16(pkt)\n       || !WPACKET_put_bytes_u8(pkt, TLSEXT_NAMETYPE_host_name)\n       || !WPACKET_sub_memcpy_u16(pkt, s->ext.hostname, strlen(s->ext.hostname))\n       || !WPACKET_close(pkt)\n       || !WPACKET_close(pkt)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return EXT_RETURN_FAIL;\n}', 'explanation': ""This segment checks for the existence of a hostname and, if present, adds the server_name extension to the ClientHello. It implements the client side support for the server_name extension as required by the RFC. However, it does not handle server-side logic such as aborting the handshake with a 'missing_extension' alert when the extension is absent.""}}]","The function implements the creation and attachment of the 'server_name' extension to a ClientHello message if the hostname is set, addressing the RFC requirement that implementations support this extension. However, it only covers the client-side construction and does not manage the server behavior described in the context—namely, aborting the handshake with a 'missing_extension' alert when a required extension is not present. Therefore, when considered in isolation, the code function only partially matches the specification constraints.",success,
14102,tls_construct_ctos_server_name,"As servers MAY require the presence of the ""server_name"" extension, clients SHOULD send this extension, when applicable.",207,Fully Matches,"[{'C1': {'code': 'if (s->ext.hostname == NULL)\n    return EXT_RETURN_NOT_SENT;', 'explanation': 'This segment checks whether a hostname is provided (i.e. the extension is applicable) before sending the server_name extension, directly addressing the condition from the spec.'}}, {'A1': {'code': '/* Add TLS extension servername to the Client Hello message */\nif (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_server_name)\n           || !WPACKET_start_sub_packet_u16(pkt)\n           || !WPACKET_start_sub_packet_u16(pkt)\n           || !WPACKET_put_bytes_u8(pkt, TLSEXT_NAMETYPE_host_name)\n           || !WPACKET_sub_memcpy_u16(pkt, s->ext.hostname, strlen(s->ext.hostname))\n           || !WPACKET_close(pkt)\n           || !WPACKET_close(pkt)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return EXT_RETURN_FAIL;\n}', 'explanation': 'These code segments build and encode the server_name extension within the ClientHello message, specifically constructing the correct format as per the RFC. This implementation directly addresses the action required by the spec.'}}]","The function correctly checks whether a hostname is provided and then constructs the TLS server_name extension in the ClientHello message. This directly implements the requirement from the RFC that clients should send this extension when applicable, fulfilling both the condition (C1) and the action (A1) within the function itself.",success,
14102,tls_construct_ctos_server_name,"Servers MAY require clients to send a valid ""server_name"" extension",352,Partially Matches,"[{'C1': {'code': 'if (s->ext.hostname == NULL)\n    return EXT_RETURN_NOT_SENT;', 'explanation': ""This check ensures that the server_name extension is only added if a valid hostname is provided, which addresses the requirement that a valid 'server_name' extension should be sent when available.""}}, {'A1': {'code': '/* Add TLS extension servername to the Client Hello message */\nif (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_server_name)\n           || !WPACKET_start_sub_packet_u16(pkt)\n           || !WPACKET_start_sub_packet_u16(pkt)\n           || !WPACKET_put_bytes_u8(pkt, TLSEXT_NAMETYPE_host_name)\n           || !WPACKET_sub_memcpy_u16(pkt, s->ext.hostname, strlen(s->ext.hostname))\n           || !WPACKET_close(pkt)\n           || !WPACKET_close(pkt)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return EXT_RETURN_FAIL;\n}', 'explanation': 'This sequence constructs the server_name extension within the ClientHello. It starts by writing the extension type and then builds the sub-packets, including the hostname value, thereby implementing the action of adding the server_name extension if the client has one.'}}]","The provided function implements the client-side logic to include a 'server_name' extension during the ClientHello message construction, as required by the RFC context where the server may mandate its presence. It checks whether a valid hostname exists (C1) and, if so, constructs the extension accordingly (A1). However, the overall RFC mandates that if a ClientHello lacks the extension, the server should abort the handshake with a 'missing_extension' alert. This function does not handle that server-side behavior as it is solely responsible for constructing the ClientHello. Therefore, while the function addresses the client emission of the extension, it only partially meets the overall RFC requirements.",success,
14105,use_ecc,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function 'use_ecc' solely deals with checking if ECC ciphersuites and supported groups are available for an SSL connection. It does not contain any logic that addresses the TLS 1.3 status_request_v2 extension specification, nor does it ignore or not act upon its presence in ClientHello messages as required by the RFC. No part of the function code handles conditions or actions related to the handling of the status_request_v2 extension (e.g., avoiding sending it in EncryptedExtensions, CertificateRequest, or Certificate messages). Therefore, the function does not implement any of the specified TLS 1.3 constraints.",success,
14106,tls_construct_ctos_ec_pt_formats,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function (tls_construct_ctos_ec_pt_formats) only builds and sends the ECPointFormats extension for the ClientHello message, dealing with ECC configuration. It does not include any logic to check or prohibit the use of the OpenPGP certificate type with TLS 1.3 as required by the RFC6091 specification. No code within this function references or implements a condition (e.g., 'if TLS 1.3 then disallow OpenPGP certificates') that would meet that constraint.",success,
14106,tls_construct_ctos_ec_pt_formats,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function, tls_construct_ctos_ec_pt_formats, constructs and sends the ECPointFormats extension in the ClientHello message. It does not contain any logic addressing the RFC specification regarding the status_request_v2 extension (i.e., TLS 1.3 servers not acting on or sending the status_request_v2 extension). As such, none of the labeled conditions (C1, ...) or actions (A1, ...) related to the status_request_v2 handling are implemented within this function.",success,
14106,tls_construct_ctos_ec_pt_formats,"A client MUST NOT include the ""early_data"" extension in its followup ClientHello.",148,Does Not Match,[],"The provided function, tls_construct_ctos_ec_pt_formats, is focused on constructing the ECPointFormats extension for a ClientHello message by adding the extension TLSEXT_TYPE_ec_point_formats. There is no visible logic within this function that addresses the specification regarding the 'early_data' extension (i.e., ensuring that a client MUST NOT include the 'early_data' extension in its followup ClientHello). Therefore, none of the constrained conditions (such as those concerning 'early_data') are implemented in this function's body.",success,
14106,tls_construct_ctos_ec_pt_formats,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The provided function, tls_construct_ctos_ec_pt_formats, is responsible solely for constructing the ec_point_formats extension for the ClientHello message. It does not contain any logic that enforces the ordering of extensions as described in the TLS RFC (specifically that the pre_shared_key extension must be last in the ClientHello). Since none of the spec constraints (such as ensuring pre_shared_key is the final extension) are addressed or implemented within this function itself, the function does not match any of the specified constraints.",success,
14107,tls_construct_ctos_supported_groups,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function tls_construct_ctos_supported_groups focuses on constructing the supported_groups extension and validating the available groups for use in TLS (including TLS 1.3). It checks whether the selected groups are valid and whether at least one group suitable for TLS 1.3 has been added. However, it does not contain any logic related to certificate types, and in particular, it does not check or enforce the restriction that the OpenPGP certificate type (as defined in RFC6091) MUST NOT be used with TLS 1.3. As a result, the function does not visibly implement the specified RFC constraint.",success,
14107,tls_construct_ctos_supported_groups,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, tls_construct_ctos_supported_groups, is focused solely on constructing the supported groups extension (i.e., enumerating and adding elliptic curve groups for key exchange negotiation) and does not involve any logic related to cipher suite selection or negotiation, including the exclusion of the RC4 cipher suites as specified (MUST NOT offer or negotiate RC4 cipher suites). There is no code within this function that addresses the restriction regarding RC4; therefore, it does not visibly implement the spec constraint.",success,
14109,tls_construct_ctos_sig_algs,"These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2.",86,Partially Matches,"[{'C1': {'code': 'if (!SSL_CLIENT_USE_SIGALGS(s))\n    return EXT_RETURN_NOT_SENT;', 'explanation': 'This check ensures that the function only proceeds if the client is configured to use signature algorithms, which is a basic condition in the spec context.'}}, {'A1': {'code': 'WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_signature_algorithms)\n    || !WPACKET_start_sub_packet_u16(pkt)\n    || !WPACKET_start_sub_packet_u16(pkt)\n    || !tls12_copy_sigalgs(s, pkt, salg, salglen)\n    || !WPACKET_close(pkt)\n    || !WPACKET_close(pkt)', 'explanation': ""This block implements the action of constructing the 'signature_algorithms' extension by writing the extension type and embedding the list of signature algorithms, which is in line with the TLS RFC requirement for certificates.""}}]","The function attempts to implement the TLS RFC aspects concerning the signature_algorithms extension for certificates by first verifying that the client should use signature algorithms (C1) and then building the extension packet (A1). However, it does not handle every aspect of the specification (such as detailed handling of input messages and digesting behavior), and some responsibilities lie in dependencies. Thus, while the function clearly addresses some key conditions and actions on its own, it only partially fulfills the entire set of specified constraints.",success,
14109,tls_construct_ctos_sig_algs,"The ""signature_algorithms"" extension MUST be specified, and other extensions may optionally be included if defined for this message.",182,Fully Matches,"[{'C1': {'code': 'if (!SSL_CLIENT_USE_SIGALGS(s))\n        return EXT_RETURN_NOT_SENT;\n\n    salglen = tls12_get_psigalgs(s, 1, &salg);\n    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_signature_algorithms)\n            || !WPACKET_start_sub_packet_u16(pkt)\n            || !WPACKET_start_sub_packet_u16(pkt)\n            || !tls12_copy_sigalgs(s, pkt, salg, salglen)\n            || !WPACKET_close(pkt)\n            || !WPACKET_close(pkt)) {...}', 'explanation': ""The code explicitly ensures that the 'signature_algorithms' extension is constructed. It first verifies whether signature algorithms should be used (SSL_CLIENT_USE_SIGALGS(s)) and then builds the extension by writing the extension type TLSEXT_TYPE_signature_algorithms and the associated list of signature algorithms. This implementation meets the spec's requirement that the 'signature_algorithms' extension MUST be specified.""}}]","The function solely handles the creation of the 'signature_algorithms' extension, which is mandated by the RFC specification. By checking whether signature algorithms should be used and then constructing the extension accordingly, the function directly addresses the sole labeled constraint (C1) from the spec. There are no other constraints specified in the input that this function needs to implement.",success,
14110,tls_construct_ctos_status_request,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, tls_construct_ctos_status_request, is responsible for constructing the OCSP status request extension in a TLS ClientHello message. It does not contain any logic related to cipher suite selection or disallowing RC4 cipher suites. As such, it does not address the spec constraint that mandates implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS. Therefore, no labeled conditions or actions from the spec (e.g., C1, A1) are implemented in this function.",success,
14115,tls_construct_ctos_sct,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'A1': {'code': 'if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_signed_certificate_timestamp)\n        || !WPACKET_put_bytes_u16(pkt, 0)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return EXT_RETURN_FAIL;\n}', 'explanation': 'This code segment checks whether the packet writing operations succeed. In the event of a failure, it calls SSLfatal with SSL_AD_INTERNAL_ERROR, thereby sending a fatal alert as required by the spec when an error is detected. This matches the aspect of sending an explicit fatal alert upon error conditions, fully implementing that part of the error handling requirement.'}}]","The function tls_construct_ctos_sct attempts to implement part of the TLS error handling as described in the spec by sending a fatal alert (with SSL_AD_INTERNAL_ERROR) when a packet writing error occurs. However, aside from this, it does not address other potential error conditions or implement the full alert termination process described in the RFC. Since only one aspect of the spec (sending a fatal alert upon error) is handled within this function's own logic, the overall match is considered partial.",success,
14115,tls_construct_ctos_sct,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The TLS RFC specification requires that TLS 1.3 servers MUST NOT act upon the status_request_v2 extension and, in particular, MUST NOT send it in EncryptedExtensions, CertificateRequest, or Certificate messages. The provided function, tls_construct_ctos_sct, does not contain any logic addressing the status_request_v2 extension. Instead, it determines whether to send the signed_certificate_timestamp (SCT) extension based solely on the presence of a ct_validation_callback and whether the certificate (x) is NULL. There is no code in this function that implements any condition or action related to the prohibition of the status_request_v2 extension as specified. Therefore, within this function, no portions of the spec constraints are visibly implemented.",success,
14118,tls_construct_ctos_psk_kex_modes,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided code function only implements the construction of the PSK key exchange modes extension for TLS 1.3. It does not contain any logic that checks or restricts the use of the OpenPGP certificate type as mandated by RFC6091. There is no code that verifies whether the OpenPGP certificate type is being used, nor does it enforce its exclusion from TLS 1.3, which is the specific requirement of the RFC specification.",success,
14119,add_key_share,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The TLS RFC specification requires that clients must not act on information in the supported_groups extension before the handshake is completed and may update their key_share choices in later sessions based on that information. This function, add_key_share, is solely responsible for generating and encoding a key share entry (i.e., constructing the key_share extension), and it contains no logic addressing the handling, delay, or use of supported_groups data. Therefore, the function does not implement the specified constraint concerning supported_groups handling.",success,
14120,tls_construct_ctos_key_share,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The TLS RFC specification requires that clients must not act upon any information in the ""supported_groups"" extension before the handshake is completed. The provided function, tls_construct_ctos_key_share, is concerned with constructing the key_share extension rather than handling or acting upon supported_groups information. While there is a check (s->ext.supportedgroups == NULL) used to decide whether to add only one key share, this does not implement any logic to defer the use of supported_groups information until after a successful handshake. Therefore, no part of the code within this function addresses the spec constraint regarding the handling of the supported_groups extension.",success,
14120,tls_construct_ctos_key_share,"However, the values MAY be a non-contiguous subset of the ""supported_groups"" extension and MAY omit the most preferred groups.",121,Partially Matches,[],"The function shows logic for constructing the key_share extension by obtaining a list of groups (via tls1_get_requested_keyshare_groups) and then iterating over them to add key shares (via add_key_share). In doing so it distinguishes between a list that comes from an explicit key share request and a default set from supported groups, which is in line with the idea that the offered values might be a non‐contiguous subset and may omit the most preferred groups. However, the handling of ordering, uniqueness, and matching the exact policy expressed in the RFC (that each KeyShareEntry must correspond to a group offered in the supported_groups extension and appear in order) is only implicit. The function relies on earlier preparation of the group list and does not independently enforce all constraints (such as checking for duplicates or checking the precise ordering against the supported_groups list) solely within its own code. Therefore, while the function’s logic partially addresses the spec constraint, it does not fully implement all the detailed requirements by itself.",success,
14120,tls_construct_ctos_key_share,"Clients MUST NOT offer any KeyShareEntry values for groups not listed in the client's ""supported_groups"" extension",124,Fully Matches,"[{'C1': {'code': 'tls1_get_requested_keyshare_groups(s, &pgroups, &num_groups);\nif (num_groups == 1 && pgroups[0] == 0) { \n    tls1_get_supported_groups(s, &pgroups, &num_groups);\n    add_only_one = 1;\n}\n...\nfor (i = 0; i < num_groups; i++) {\n    if (!tls_group_allowed(s, pgroups[i], SSL_SECOP_CURVE_SUPPORTED))\n        continue;\n    if (!tls_valid_group(s, pgroups[i], TLS1_3_VERSION, TLS1_3_VERSION, 0, NULL))\n        continue;\n    group_id = pgroups[i];\n    ...\n}', 'explanation': ""The function fetches the keyshare groups from tls1_get_requested_keyshare_groups, which reflects the client's supported_groups extension. In the special case when only a default indicator is present, it fetches the supported groups via tls1_get_supported_groups. Then, in the loop, only groups from the provided (and thus allowed) list are processed. This logic ensures that no KeyShareEntry is offered for groups not listed in the client's supported_groups extension.""}}]","The code function explicitly retrieves the groups from the client's supported_groups extension (or a default when necessary) and iterates only over those groups while adding key share entries, thereby directly addressing the RFC requirement. All the relevant logic is contained within the function_body, making it a full implementation of the specified constraint.",success,
14121,tls_construct_ctos_cookie,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The code function tls_construct_ctos_cookie is solely responsible for constructing the TLS 1.3 cookie extension and does not implement any logic related to certificate type restrictions. Specifically, it does not address the RFC6091 requirement that the OpenPGP certificate type MUST NOT be used with TLS 1.3. No part of the function checks, validates, or restricts the certificate type, and no logic corresponding to the labeled conditions or actions (such as C1 or A1) from the spec constraints is present within this function.",success,
14121,tls_construct_ctos_cookie,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest.",59,Fully Matches,"[{'C1': {'code': 'if (s->ext.tls13_cookie_len == 0)\n    return EXT_RETURN_NOT_SENT;', 'explanation': ""This check ensures that the cookie extension is only constructed if a cookie exists (i.e. after a HelloRetryRequest), thereby preventing the sending of extension responses when the remote endpoint did not request it, with the exception allowed for the 'cookie' extension.""}}]","The function explicitly verifies that a cookie has been set by checking s->ext.tls13_cookie_len. This serves to implement the RFC requirement that extension responses must not be sent unless the corresponding extension request was received, except in the case of the cookie in a HelloRetryRequest. The comment and conditional check in the function make it clear that the cookie extension is only sent if previously set, directly addressing the specified constraint.",success,
14121,tls_construct_ctos_cookie,"As with the ServerHello, a HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the ""cookie"" (see Section 4.2.2) extension.",47,Partially Matches,"[{'A1': {'code': 'if (s->ext.tls13_cookie_len == 0)\n    return EXT_RETURN_NOT_SENT;\n\nif (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_cookie)\n       || !WPACKET_start_sub_packet_u16(pkt)\n       || !WPACKET_sub_memcpy_u16(pkt, s->ext.tls13_cookie, s->ext.tls13_cookie_len)\n       || !WPACKET_close(pkt)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto end;\n}', 'explanation': 'This segment implements the logic for constructing the cookie extension: the extension is only sent if a cookie exists (s->ext.tls13_cookie_len != 0). This addresses the RFC’s exception that allows the cookie extension in a HelloRetryRequest. However, it does not check whether the cookie extension was originally offered by the client.'}}]","The function solely implements the transmission of the cookie extension by checking if a cookie value exists and then writing it to the outgoing message. This conforms with the part of the RFC that permits including the cookie extension. However, it does not verify that the extension was first offered by the client in its ClientHello, which is a key requirement of the specification. As a result, the function partially matches the RFC constraints by addressing only the extension sending aspect but not the complete validation required by the spec.",success,
14122,tls_construct_ctos_early_data,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function focuses on constructing the early_data extension (handling PSK callbacks, early data state, ALPN consistency, etc.) and does not include any logic that enforces that Application Data is not sent prior to sending the Finished message. There is no code in this function that verifies or strictly controls the ordering of sending Application Data relative to the Finished message as required by the specified TLS RFC.",success,
14122,tls_construct_ctos_early_data,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function deals with constructing the client-to-server early data extension, handling PSK sessions and associated early data parameters. There is no code segment within this function that explicitly checks, disallows, or prevents the offer or negotiation of RC4 cipher suites as mandated by the RFC specification. The function instead uses a hard-coded TLS 1.3 AES-GCM cipher (tls13_aes128gcmsha256_id) when creating a PSK session, but this does not constitute a check against RC4 cipher suites in line with the spec requirement. Therefore, this function does not visibly address the specified constraint regarding RC4 cipher suites.",success,
14122,tls_construct_ctos_early_data,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The RFC specification requires that the server MUST NOT send a ""psk_key_exchange_modes"" extension, but the provided function, tls_construct_ctos_early_data, does not include any logic that references or manipulates the ""psk_key_exchange_modes"" extension. Instead, the function is focused on constructing and handling the early_data extension and managing PSK-related callbacks. There is no segment in this function that addresses the constraint regarding the non-transmission of the ""psk_key_exchange_modes"" extension.",success,
14122,tls_construct_ctos_early_data,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Partially Matches,"[{'C1': {'code': 'if (s->psk_use_session_cb != NULL\n        && (!s->psk_use_session_cb(ussl, handmd, &id, &idlen, &psksess)\n            || (psksess != NULL\n                && psksess->ssl_version != TLS1_3_VERSION))) {\n    SSL_SESSION_free(psksess);\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_PSK);\n    return EXT_RETURN_FAIL;\n}', 'explanation': 'This code block checks that any PSK session obtained is using TLS1.3. By verifying that psksess->ssl_version equals TLS1_3_VERSION, the function prevents the negotiation of sessions using older protocols such as SSL 3.0.'}}, {'A1': {'code': 'psksess = SSL_SESSION_new();\nif (psksess == NULL\n        || !SSL_SESSION_set1_master_key(psksess, psk, psklen)\n        || !SSL_SESSION_set_cipher(psksess, cipher)\n        || !SSL_SESSION_set_protocol_version(psksess, TLS1_3_VERSION)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    OPENSSL_cleanse(psk, psklen);\n    return EXT_RETURN_FAIL;\n}', 'explanation': 'When creating a new PSK session, the function explicitly sets the protocol version to TLS1.3. This action enforces that sessions negotiated here are using TLS1.3, indirectly ensuring that weaker protocols like SSL 3.0 are not accepted.'}}]","The function implements part of the TLS RFC requirement by ensuring that only TLS1.3 PSK sessions are accepted. The checks that verify psksess->ssl_version equals TLS1_3_VERSION and the explicit setting of the session protocol to TLS1_3_VERSION imply that insecure protocols (including SSL 3.0) would not be negotiated in this code path. However, the function does not include additional logic to enforce cipher strength requirements or other protocol aspects mentioned in the broader spec context. Thus, while it partially addresses the specified constraint concerning disallowing SSL 3.0, it does not comprehensively cover all security constraints from the spec.",success,
14122,tls_construct_ctos_early_data,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The function tls_construct_ctos_early_data is dedicated to constructing and validating the early data extension for TLS (primarily TLS 1.3) and managing PSK session parameters. It does not contain any logic that addresses or enforces constraints related to SSL 2.0, such as preventing an SSL version 2.0 compatible CLIENT-HELLO from being sent or negotiated. Therefore, it does not implement the TLS RFC specification requirement regarding the prohibition of SSL 2.0.",success,
14122,tls_construct_ctos_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Partially Matches,"[{'C1': {'code': 'if (s->early_data_state != SSL_EARLY_DATA_CONNECTING\n        || (s->session->ext.max_early_data == 0\n            && (psksess == NULL || psksess->ext.max_early_data == 0))) {\n    s->max_early_data = 0;\n    return EXT_RETURN_NOT_SENT;\n}\n...\n/* later in the function */\n/* We set this to rejected here. Later, if the server acknowledges the extension, we set it to accepted. */\ns->ext.early_data = SSL_EARLY_DATA_REJECTED;\ns->ext.early_data_ok = 1;', 'explanation': 'This segment ensures that early data is not automatically retransmitted. It checks that the connection is in the proper state and that early data is allowed; if not, it prevents sending the extension automatically by returning without sending it, and marks the early data as rejected.'}}, {'A1': {'code': 'if ((s->ext.alpn == NULL && edsess->ext.alpn_selected != NULL)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_INCONSISTENT_EARLY_DATA_ALPN);\n    return EXT_RETURN_FAIL;\n}\n...\nif (edsess->ext.alpn_selected != NULL) {\n    PACKET prots, alpnpkt;\n    int found = 0;\n\n    if (!PACKET_buf_init(&prots, s->ext.alpn, s->ext.alpn_len)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return EXT_RETURN_FAIL;\n    }\n    while (PACKET_get_length_prefixed_1(&prots, &alpnpkt)) {\n        if (PACKET_equal(&alpnpkt, edsess->ext.alpn_selected, edsess->ext.alpn_selected_len)) {\n            found = 1;\n            break;\n        }\n    }\n    if (!found) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_INCONSISTENT_EARLY_DATA_ALPN);\n        return EXT_RETURN_FAIL;\n    }\n}', 'explanation': 'This code verifies that the ALPN protocol provided in the early data matches the one negotiated (if any). It prevents automatic retransmission of early data when there is an ALPN mismatch, as required by the spec.'}}]","The TLS function implements checks that address key aspects of the spec constraints: it prevents automatic retransmission of early data unless specific conditions are met (C1) and it verifies that the negotiated ALPN protocol matches the one associated with the early data (A1). However, while it handles these checks within its own logic, some aspects (such as overall retransmission logic or additional application decisions) may be managed elsewhere, leading to a partial matching relative to the whole spec requirement.",success,
14122,tls_construct_ctos_early_data,"In addition, it MUST verify that the following values are the same as those associated with the selected PSK:",150,Fully Matches,"[{'C1': {'code': 'if (s->psk_use_session_cb != NULL\n            && (!s->psk_use_session_cb(ussl, handmd, &id, &idlen, &psksess)\n                || (psksess != NULL\n                    && psksess->ssl_version != TLS1_3_VERSION))) {\n        SSL_SESSION_free(psksess);\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_PSK);\n        return EXT_RETURN_FAIL;\n    }', 'explanation': 'This code verifies that when a PSK session is obtained via the psk_use_session_cb callback, its TLS version (psksess->ssl_version) must exactly match TLS1_3_VERSION, thereby ensuring that the PSK’s associated TLS version is the same as required by the RFC.'}}, {'A1': {'code': 'if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_early_data)\n            || !WPACKET_start_sub_packet_u16(pkt)\n            || !WPACKET_close(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return EXT_RETURN_FAIL;\n    }\n    ...\n    s->ext.early_data = SSL_EARLY_DATA_REJECTED;\n    s->ext.early_data_ok = 1;\n    return EXT_RETURN_SENT;', 'explanation': ""This segment constructs and writes the client's early_data extension into the outgoing messages. By packaging the extension (and later marking it for potential acceptance), the function satisfies the requirement to return its own early_data extension in EncryptedExtensions.""}}]","The provided function contains explicit logic that addresses the key aspects of the TLS RFC specification as described. It first verifies that the selected PSK’s TLS version number matches the expected TLS1.3 version (fulfilling condition C1) and then constructs and sends the early_data extension (fulfilling action A1). Both these implementations occur within the function itself, thereby fully matching the specified constraints.",success,
14123,tls_construct_ctos_padding,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Partially Matches,"[{'C1': {'code': 'if (!WPACKET_get_total_written(pkt, &hlen)) { ... }\n\n/* Exclude PSK extension length */\nif (s->session->ssl_version == TLS1_3_VERSION\n        && s->session->ext.ticklen != 0\n        && s->session->cipher != NULL) {\n    const EVP_MD *md = ssl_md(SSL_CONNECTION_GET_CTX(s), s->session->cipher->algorithm2);\n    if (md != NULL) {\n        int md_size = EVP_MD_get_size(md);\n        if (md_size <= 0)\n            return EXT_RETURN_FAIL;\n        hlen += PSK_PRE_BINDER_OVERHEAD + s->session->ext.ticklen + md_size;\n    }\n}\n\nif (hlen > F5_WORKAROUND_MIN_MSG_LEN && hlen < F5_WORKAROUND_MAX_MSG_LEN) {\n    /* Calculate the amount of padding we need to add */\n    hlen = F5_WORKAROUND_MAX_MSG_LEN - hlen;\n    if (hlen > 4)\n        hlen -= 4;\n    else\n        hlen = 1;\n    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_padding)\n            || !WPACKET_sub_allocate_bytes_u16(pkt, hlen, &padbytes)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return EXT_RETURN_FAIL;\n    }\n    memset(padbytes, 0, hlen);\n}', 'explanation': 'The code intentionally excludes the PSK extension (which must be written last per the TLS 1.3 spec) from the total written length when computing the amount of padding. This ensures that if a PSK extension is present, the padding extension is inserted second-to-last, maintaining the ordering requirement that pre_shared_key is the final extension in the ClientHello.'}}]","The function implements logic to adjust for the ordering requirement specified for the pre_shared_key extension by excluding its length during the padding calculation. This ensures that if the PSK extension is to be added later, the padding extension appears immediately before it. However, the function solely addresses this specific ordering aspect (i.e. ensuring that if a PSK extension is present, it remains last) and does not implement any other extension ordering rules, hence it only partially matches the overall RFC specification.",success,
14124,tls_construct_ctos_psk,Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection.,241,Partially Matches,"[{'C1': {'code': ""if (s->hello_retry_request == SSL_HRR_PENDING && mdres != handmd) {\n    /* Selected ciphersuite hash does not match the hash for the session so we can't use it. */\n    goto dopsksess;\n}\n\n...\n\nif (s->psksession != NULL) {\n    mdpsk = ssl_md(sctx, s->psksession->cipher->algorithm2);\n    if (mdpsk == NULL) {\n        /* Don't recognize this cipher so we can't use the session. */\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_PSK);\n        return EXT_RETURN_FAIL;\n    }\n\n    if (s->hello_retry_request == SSL_HRR_PENDING && mdpsk != handmd) {\n        /* Selected ciphersuite hash does not match the hash for the PSK session. This is an application bug. */\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_PSK);\n        return EXT_RETURN_FAIL;\n    }\n}"", 'explanation': 'The code function includes checks to verify that the digest associated with the resumed session (or PSK session) matches the handshake digest when a Hello Retry Request is pending. This is an attempt to ensure that the same KDF hash algorithm is used, which partly reflects the RFC requirement. However, these checks are only performed under the condition of a Hello Retry Request, and do not unconditionally enforce the constraint for all ticket resumptions. Furthermore, other related aspects (e.g., SNI validation) are not handled here, thus only a partial implementation of the spec constraint is visible.'}}]","The TLS function attempts to address the RFC requirement that a ticket must only be resumed with a cipher suite that uses the same KDF hash algorithm as that used initially, by comparing the computed message digest (KDF hash) in the case of a Hello Retry Request. However, since this check only occurs when a Hello Retry Request is pending and does not cover all resume conditions (nor does it handle the SNI validation aspect mentioned in the broader context), the implementation in this function only partially matches the specified RFC constraint.",success,
14124,tls_construct_ctos_psk,"The client MAY use this PSK for future handshakes by including the ticket value in the ""pre_shared_key"" extension in its ClientHello (Section 4.2.11).",239,Fully Matches,"[{'C1': {'code': 'if (s->session->ext.ticklen != 0) {\n    ...\n    if (!WPACKET_sub_memcpy_u16(pkt, s->session->ext.tick, s->session->ext.ticklen)\n            || !WPACKET_put_bytes_u32(pkt, agems)) {\n        ...\n    }\n}', 'explanation': 'This code block checks for the existence of a ticket (PSK) and, if present, includes the ticket value (and lifetime hint) into the pre_shared_key extension. This directly reflects the RFC requirement that the client MAY include the ticket value in its ClientHello.'}}, {'A1': {'code': 'if (dores && tls_psk_do_binder(s, mdres, msgstart, binderoffset, NULL, resbinder, s->session, 1, 0) != 1) {\n    ...\n}\n\nif (s->psksession != NULL && tls_psk_do_binder(s, mdpsk, msgstart, binderoffset, NULL, pskbinder, s->psksession, 1, 1) != 1) {\n    ...\n}', 'explanation': 'This segment computes and appends the PSK binder(s) into the pre_shared_key extension. The binder is required to verify the integrity of the PSK and is an important action in using the ticket value for resumption as described in the RFC.'}}]","The function constructs the pre_shared_key extension for the ClientHello message by conditionally including a ticket (if available) along with its corresponding binder. This directly aligns with the TLS RFC requirement which states that the client MAY use the PSK (ticket value) for future handshakes by including it in the pre_shared_key extension. The code includes all necessary steps (checking for ticket presence, copying the ticket and lifetime, and computing the binder) within the function itself, thereby fully addressing the specified constraint.",success,
14124,tls_construct_ctos_psk,"Clients MUST NOT attempt to use tickets which have ages greater than the ""ticket_lifetime"" value which was provided with the ticket.",174,Fully Matches,"[{'C1': {'code': 'if (s->session->ext.tick_lifetime_hint < agesec) {\n    /* Ticket is too old. Ignore it. */\n    goto dopsksess;\n}', 'explanation': 'This code segment computes the elapsed time since the ticket was issued (agesec) and compares it against the ticket lifetime (s->session->ext.tick_lifetime_hint). If the ticket age exceeds the lifetime, it bypasses using the ticket, thereby ensuring that clients do not attempt to use an outdated ticket as required by the RFC.'}}, {'A1': {'code': 'agems = agesec * (uint32_t)1000;\n...\n/* Obfuscate the age. Overflow here is fine, this addition is supposed to be mod 2^32. */\nagems += s->session->ext.tick_age_add;', 'explanation': ""This code computes the ticket age in milliseconds and obfuscates it by adding the tick_age_add value, fulfilling the RFC requirement that the 'obfuscated_ticket_age' be formed by adding tick_age_add (mod 2^32) to the actual age.""}}]","The function implements the RFC requirement regarding ticket age management by calculating the ticket age, comparing it against the provided ticket_lifetime value, and by obfuscating the ticket age using tick_age_add. These two key aspects ensure that the client does not attempt to use an expired ticket and obfuscates the age to prevent passive observers from correlating connections, which means the function fully addresses the TLS specification in question.",success,
14124,tls_construct_ctos_psk,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The provided function tls_construct_ctos_psk constructs the PSK extension (TLSEXT_TYPE_psk) for a ClientHello message and does not include any logic related to sending a psk_key_exchange_modes extension. The spec explicitly requires that the server MUST NOT send a ""psk_key_exchange_modes"" extension, but this function does not check, enforce, or reference that constraint. Therefore, with respect to the given spec constraints, no part of the function addresses this requirement.",success,
14124,tls_construct_ctos_psk,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided code function (tls_construct_ctos_psk) is concerned with constructing the PSK extension and handling resumption session parameters, but it does not include any logic to control the automatic retransmission of early data based on ALPN protocol or any other criteria. There is no visible implementation in this function that prevents the automatic resend of early data when the negotiated connection uses a different ALPN protocol, as specified in the TLS RFC. Therefore, the function does not address the spec constraints related to early data retransmission.",success,
14126,tls_parse_stoc_renegotiate,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'A1': {'code': 'if (ilen != expected_len) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_RENEGOTIATION_MISMATCH);\n        return 0;\n    }\n\n    if (!PACKET_get_bytes(pkt, &data, s->s3.previous_client_finished_len)\n        || memcmp(data, s->s3.previous_client_finished, s->s3.previous_client_finished_len) != 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_RENEGOTIATION_MISMATCH);\n        return 0;\n    }\n\n    if (!PACKET_get_bytes(pkt, &data, s->s3.previous_server_finished_len)\n        || memcmp(data, s->s3.previous_server_finished, s->s3.previous_server_finished_len) != 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_RENEGOTIATION_MISMATCH);\n        return 0;\n    }', 'explanation': ""The function verifies that the renegotiation extension’s length matches the expected length and that the contents of the extension match the stored client and server 'finished' messages. In cases where the message is semantically invalid (mismatched lengths or data), it terminates the connection with an 'illegal_parameter' alert, thereby implementing the RFC requirement that semantically invalid messages must trigger a fatal illegal_parameter alert.""}}]","The provided function checks the integrity of the renegotiation extension by verifying both its length and content. If either the length does not match or the expected byte sequences (client/server finished messages) are incorrect, the function calls SSLfatal with the SSL_AD_ILLEGAL_PARAMETER alert. This behavior directly addresses the TLS RFC specification which mandates that a peer receiving a syntactically correct but semantically invalid message must terminate the connection with an illegal_parameter alert. All relevant logic is contained within this function, independent of its dependencies.",success,
14126,tls_parse_stoc_renegotiate,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_1_len(pkt, &ilen)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_RENEGOTIATION_ENCODING_ERR);\n    return 0;\n}', 'explanation': 'This segment checks whether the length byte of the message can be parsed. If it fails, it immediately terminates the connection with a decode_error alert, as mandated by the RFC for syntactic parsing errors.'}}, {'C2': {'code': 'if (PACKET_remaining(pkt) != ilen) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_RENEGOTIATION_ENCODING_ERR);\n    return 0;\n}', 'explanation': 'After obtaining the intended length, the code verifies that the remaining bytes in the packet exactly match that length. A mismatch indicates that the message boundaries have been violated, triggering a decode_error alert per RFC requirements.'}}, {'A1': {'code': 'if (ilen != expected_len) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_RENEGOTIATION_MISMATCH);\n    return 0;\n}', 'explanation': ""Although the RFC distinguishes between parsing and semantic errors, this segment handles the case where the message is syntactically well-formed but semantically invalid (i.e., the renegotiation lengths do not match). It latches onto the 'illegal_parameter' alert, which is consistent with the RFC’s treatment of semantically invalid messages.""}}]","The function tls_parse_stoc_renegotiate implements checks that enforce the TLS RFC directives regarding message parsing. It verifies that the message length is correctly parsed and that the packet contains exactly the expected number of bytes. Failure to meet these conditions causes the function to terminate the connection with a decode_error alert. Additionally, it checks for semantic consistency (e.g., renegotiation extension length matching), triggering an illegal_parameter alert when necessary. All of these checks are performed within the function itself, ensuring compliance with the specified RFC requirements.",success,
14127,tls_parse_stoc_maxfragmentlen,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 1 || !PACKET_get_1(pkt, &value)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This segment checks the syntax by ensuring exactly 1 byte remains and is retrievable. If not, it triggers a decode_error alert as mandated by the RFC for parsing failures.'}}, {'A1': {'code': 'if (!IS_MAX_FRAGMENT_LENGTH_EXT_VALID(value)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_SSL3_EXT_INVALID_MAX_FRAGMENT_LENGTH);\n    return 0;\n}\n\nif (value != s->ext.max_fragment_len_mode) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_SSL3_EXT_INVALID_MAX_FRAGMENT_LENGTH);\n    return 0;\n}', 'explanation': ""These segments validate the semantic correctness of the message. If the max-fragment-length code is invalid or does not match the client-specified value, it triggers an illegal_parameter alert, aligning with the RFC's requirement for semantically invalid messages.""}}]","The function implements the TLS RFC requirements by strictly checking the packet for both syntactic (length issues) and semantic errors. It uses SSLfatal to generate a decode_error alert for messages that fail parsing and an illegal_parameter alert for messages that are semantically off. Hence, all specified conditions and actions in the RFC are visibly addressed within the function.",success,
14127,tls_parse_stoc_maxfragmentlen,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 1 || !PACKET_get_1(pkt, &value)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This segment checks that the packet is syntactically valid (exactly one byte available) and, if not, terminates the connection with a decode_error alert, satisfying the RFC requirement for handling unparsable messages.'}}, {'A1': {'code': 'if (!IS_MAX_FRAGMENT_LENGTH_EXT_VALID(value)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_SSL3_EXT_INVALID_MAX_FRAGMENT_LENGTH);\n    return 0;\n}', 'explanation': 'This segment ensures that a syntactically correct message is semantically valid by verifying the max fragment length enum value. If it is not valid, it terminates the connection with an illegal_parameter alert, as required.'}}, {'A2': {'code': 'if (value != s->ext.max_fragment_len_mode) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_SSL3_EXT_INVALID_MAX_FRAGMENT_LENGTH);\n    return 0;\n}', 'explanation': 'This code ensures that the negotiated value matches the value that was originally configured by the client. A mismatch leads to an illegal_parameter alert, which complies with the RFC constraint regarding semantically invalid responses.'}}]","The function 'tls_parse_stoc_maxfragmentlen' implements the specified TLS RFC by first ensuring that the message is syntactically valid (one byte available in the packet) and then verifying that the value is semantically correct. If the extension value is either out-of-range or does not match the expected client-proposed value, the function terminates the connection using an 'illegal_parameter' alert. Both the syntactic and semantic validations are handled within the function itself, thereby fully satisfying the RFC constraints.",success,
14128,tls_parse_stoc_server_name,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'A1': {'code': 'if (PACKET_remaining(pkt) > 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This segment checks if there are extra bytes remaining in the packet, which indicates that the message cannot be parsed correctly. In that case, it terminates the connection with a decode_error alert, directly addressing the RFC requirement for syntactically invalid messages.'}}]","The function contains logic to detect a parsing error by checking if the remaining packet bytes exceed what is expected, and promptly issues a decode_error alert accordingly. This meets the requirement for handling messages that are malformed (e.g., having a length extending beyond message boundaries). However, the RFC also mandates actions for syntactically correct but semantically invalid messages (such as illegal parameters), which this function does not address. Therefore, the implementation in this function only partially covers the specified requirements.",success,
14128,tls_parse_stoc_server_name,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) > 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': ""This code segment checks if there are any extra bytes remaining in the packet (i.e. data following an extension block). According to the RFC specification, if there is unexpected data, the handshake must be aborted with a decode_error alert. This fulfills the spec's requirement.""}}]","The function clearly implements the specified requirement by checking for extra data in the extension (using PACKET_remaining) and, if found, aborting the handshake with a decode_error alert via SSLfatal. This directly corresponds to the RFC condition that mandates aborting the handshake when extra, unrecognized data is present. Therefore, within the context of this function, the relevant spec constraint is fully matched.",success,
14129,tls_parse_stoc_ec_pt_formats,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_1(pkt, &ecptformatlist)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': ""This code checks if the incoming packet cannot be parsed (e.g., if the length prefix is invalid) and immediately triggers a 'decode_error' alert, which addresses the RFC requirement concerning messages that cannot be parsed according to the syntax.""}}, {'A1': {'code': 'if (ecpointformats_len == 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_LENGTH);\n    return 0;\n}', 'explanation': ""This segment verifies that the parsed list is non-empty; if it is empty, it again calls SSLfatal with a decode_error, thus fulfilling the action to terminate the connection with a 'decode_error' alert when a syntactic anomaly is detected.""}}]","The function implements key parts of the RFC requirement by testing for conditions where the message cannot be parsed (using the length-prefixed packet parsing and ensuring a non-zero length) and then terminating the connection with a 'decode_error' alert via SSLfatal. However, it does not implement logic for handling semantically invalid messages (which should trigger an 'illegal_parameter' alert) or unknown alert types as specified in the RFC context. Thus, while the function does visibly address some conditions and actions (C1 and A1) from the specification, it only partially covers the complete requirements of the RFC in isolation.",success,
14130,tls_parse_stoc_session_ticket,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) > 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This code segment checks if there are remaining bytes in the packet (i.e. extra data beyond the expected length) and, if so, triggers a decode_error alert, which directly reflects the TLS RFC requirement that messages which cannot be parsed (e.g. due to a length extending beyond the message boundary) must be terminated with a decode_error alert.'}}]","The function attempts to enforce the RFC requirement by verifying that the entire packet is consumed. In cases where there is extra unexpected data, it terminates the connection with a decode_error alert. However, while it does handle this specific syntax error case, it does not cover other potential requirements such as handling semantically invalid but syntactically correct messages (e.g., using an illegal_parameter alert) as noted in the spec. Therefore, the function only partially matches the full set of TLS RFC constraints provided.",success,
14131,tls_parse_stoc_status_request,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!SSL_CONNECTION_IS_TLS13(s) && PACKET_remaining(pkt) > 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This block checks, for TLS <= 1.2, if there is remaining data in the packet that would indicate a parsing issue (e.g. a length extending beyond the message boundary) and terminates the connection using decode_error as required.'}}]","The RFC specifies that if a message cannot be parsed according to syntax, the connection must be terminated with a decode_error alert. The function partially addresses this by checking for extra data in the packet for TLS <= 1.2 and calling SSLfatal with SSL_AD_DECODE_ERROR. However, it does not cover all syntax parsing errors (e.g., out‐of-range lengths in other contexts or similar violations in TLS 1.3) and other semantically invalid scenarios that should trigger an illegal_parameter alert. In isolation, only part of the specified constraint is implemented in this function.",success,
14132,tls_parse_stoc_sct,The server MAY send it in the CertificateRequest message.,106,Does Not Match,[],"The provided function, tls_parse_stoc_sct, is dedicated to parsing and handling the Signed Certificate Timestamp (SCT) extension. In its logic, if the context indicates that the SCT was received in a TLS 1.3 CertificateRequest message, it immediately returns success (ignoring the extension). This behavior does not implement or process the certificate_authorities extension as described in the spec—where the server MAY send the certificate_authorities extension (or trusted CA keys) in the CertificateRequest message. No part of the function’s code addresses processing or utilizing these distinguished names. Therefore, the function does not visibly address the specified TLS RFC requirement.",success,
14132,tls_parse_stoc_sct,"In TLS 1.3, a client receiving a CertificateRequest or NewSessionTicket MUST also ignore all unrecognized extensions.",359,Partially Matches,"[{'C1': {'code': 'if (context == SSL_EXT_TLS1_3_CERTIFICATE_REQUEST) {\n    /* We ignore this if the server sends it in a CertificateRequest */\n    return 1;\n}', 'explanation': 'This code segment directly checks if the context is a TLS 1.3 CertificateRequest and ignores the extension (by returning 1), which satisfies the RFC mandate to ignore unrecognized extensions in a CertificateRequest.'}}]","The RFC states that in TLS 1.3, a client receiving a CertificateRequest or NewSessionTicket must ignore all unrecognized extensions. This function explicitly implements the ignoring behavior when the context is a CertificateRequest. However, it does not explicitly check for or handle the NewSessionTicket context. As only part of the spec (the CertificateRequest case) is addressed within this function, the implementation is considered to partially match the specified RFC requirement.",success,
14133,ssl_next_proto_validate,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_length_prefixed_1(pkt, &tmp_protocol) || PACKET_remaining(&tmp_protocol) == 0)', 'explanation': 'This check verifies that the protocol information in the packet can be parsed correctly. If the length is out of range or missing (i.e. syntactically invalid), the condition triggers, addressing the requirement to detect unparseable messages.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);', 'explanation': 'On detecting a parsing error, this call terminates the connection with a decode_error alert, fulfilling the spec action that unparseable messages must lead to a fatal decode_error alert.'}}]","The function inspects the packet using length‐prefixed extraction and checks for empty data, which are indicative of syntax errors (e.g., length extending beyond the message boundary or missing protocol data). When such an error is detected, it directly terminates the connection with a decode_error alert as required by the TLS RFC. Thus, the function fully implements the behavior for handling unparseable messages based solely on its own logic.",success,
14133,ssl_next_proto_validate,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'C1': {'code': 'if (!PACKET_get_length_prefixed_1(pkt, &tmp_protocol) || PACKET_remaining(&tmp_protocol) == 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': ""This code segment verifies that a length‐prefixed protocol entry exists and is non‐empty. In doing so, it ensures that if the protocol data is missing or malformed, the function aborts the handshake with a 'decode_error' alert, which corresponds to the RFC requirement.""}}]","The function checks the integrity of each protocol entry within the packet by parsing a length‐prefixed field and ensuring it is not empty. When this condition is not met, it aborts the handshake by calling SSLfatal with SSL_AD_DECODE_ERROR, thereby meeting the specified action from the RFC. However, the overall TLS context involves additional checks (e.g., handling the presence of extensions after compression methods, or verifying required extensions for TLS 1.3) which are not addressed within this function, so only a specific part of the RFC is handled here.",success,
14135,tls_parse_stoc_alpn,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2_len(pkt, &len)\n    || PACKET_remaining(pkt) != len || !PACKET_get_1_len(pkt, &len)\n    || PACKET_remaining(pkt) != len) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This code block validates the length fields of the received message. If the lengths do not match expectations (i.e. the message cannot be parsed according to the syntax), it terminates the connection with a decode_error alert, which addresses the RFC requirement for handling parsing errors.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);', 'explanation': 'Throughout the function, when a parsing or matching error is detected, the function calls SSLfatal with the decode_error alert. This error handling action is intended to enforce termination of the connection when a decode error is encountered.'}}]","The function implements checks for message parsing errors by verifying length fields and terminates the connection with a decode_error alert when the message fails these syntax checks. This meets the RFC requirement for handling messages that cannot be parsed correctly. However, the RFC also requires that semantically invalid messages (those that are syntactically correct but invalid, such as a protocol mismatch) result in an 'illegal_parameter' alert, whereas this function uses the decode_error alert in those situations as well. Consequently, while the function addresses part of the specification (the syntax parsing error case), it does not correctly differentiate between parse errors and semantically invalid messages, resulting in a partial match to the spec constraints.",success,
14135,tls_parse_stoc_alpn,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function 'tls_parse_stoc_alpn' exclusively deals with negotiating and processing the ALPN extension in the TLS handshake. There is no logic addressing the specification constraint that states implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS, nor any reference to cipher strengths. All checks and operations in this function pertain solely to ALPN protocol list parsing, comparison, and selection. Therefore, this function does not address any of the specified constraints regarding RC4 cipher suites.",success,
14135,tls_parse_stoc_alpn,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Partially Matches,"[{'A1': {'code': 'if (s->session->ext.alpn_selected == NULL\n            || s->session->ext.alpn_selected_len != len\n            || memcmp(s->session->ext.alpn_selected, s->s3.alpn_selected, len) != 0) {\n        /* ALPN not consistent with the old session so cannot use early_data */\n        s->ext.early_data_ok = 0;\n    }', 'explanation': 'This section directly checks that if the negotiated ALPN protocol does not match the one stored in the session, early data use is disabled by setting s->ext.early_data_ok = 0. This addresses the RFC requirement that a TLS implementation must not automatically resend early data unless the negotiated connection selects the same ALPN protocol.'}}]","The tls_parse_stoc_alpn function is primarily responsible for parsing the ALPN extension from the server and verifying that it matches one of the protocols previously offered by the client. Within the function, there is a check to ensure that the ALPN value in the current handshake matches the one stored in the session, and if not, it disables early data by setting s->ext.early_data_ok to 0. This behavior partially meets the RFC’s stipulation regarding early data retransmission. However, the function does not implement other aspects of the early data retransmission policy (for example, it does not control when or how early data might be resented), so on its own, it only partially addresses the complete set of constraints from the specification.",success,
14136,tls_parse_stoc_use_srtp,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2(pkt, &ct) || ct != 2\n        || !PACKET_get_net_2(pkt, &id)\n        || !PACKET_get_1(pkt, &mki)\n        || PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST);\n    return 0;\n}', 'explanation': 'This code block verifies that the incoming message is correctly parsed. It checks that the necessary fields are obtained correctly and that there is no extra data in the packet. In case of a parsing error (e.g., message length extending beyond boundary), it terminates the connection with a decode_error alert, which satisfies the spec requirement.'}}, {'A1': {'code': 'if (mki != 0) {\n    /* Must be no MKI, since we never offer one */\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_SRTP_MKI_VALUE);\n    return 0;\n}', 'explanation': 'This part checks for a valid semantic value (MKI must be zero, since this implementation does not offer one). If mki is non-zero, the function triggers an illegal_parameter alert, complying with the spec requirement for syntactically valid but semantically invalid messages.'}}]","The function 'tls_parse_stoc_use_srtp' contains explicit checks for both syntactical parsing errors and semantic parameter validation as described in the TLS RFC. The parsing error block (labeled here as C1) ensures that messages with invalid length or unexpected extra data result in a 'decode_error' alert. Additionally, the check for a non-zero MKI (labeled as A1) ensures that messages which, although syntactically correct, are semantically invalid, trigger an 'illegal_parameter' alert. This direct implementation of the two main alerting mechanisms from the specification indicates that the function fully matches the provided TLS RFC constraints.",success,
14136,tls_parse_stoc_use_srtp,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2(pkt, &ct) || ct != 2\n        || !PACKET_get_net_2(pkt, &id)\n        || !PACKET_get_net_1(pkt, &mki)\n        || PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST);\n    return 0;\n}', 'explanation': ""This code segment checks the syntax of the incoming message by validating field lengths and contents. It sends a decode_error alert when the message cannot be parsed correctly, in accordance with the RFC's requirement for syntactic errors.""}}, {'A1': {'code': 'if (mki != 0) {\n    /* Must be no MKI, since we never offer one */\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_SRTP_MKI_VALUE);\n    return 0;\n}', 'explanation': 'This segment verifies a semantically invalid parameter (a non-zero MKI) and terminates the connection with an illegal_parameter alert, as mandated by the RFC for semantically invalid messages.'}}]","The function implements both the syntax checking and semantic validation stipulated by the RFC. It distinguishes between parsing errors (triggering a decode_error alert) and semantic errors (triggering an illegal_parameter alert), which fully addresses the specified constraints.",success,
14136,tls_parse_stoc_use_srtp,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided code function, tls_parse_stoc_use_srtp, is concerned with parsing the SRTP protection profile from a server message and validating the SRTP extension structure. It does not contain any logic addressing the RFC specification requirement regarding the RC4 cipher suite (i.e., ensuring that RC4 cipher suites are not offered or negotiated). No code segments within this function implement any condition or action related to rejecting RC4 cipher suites, so it does not visibly address the labeled conditions or actions from the spec.",success,
14139,tls_parse_stoc_supported_versions,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Fully Matches,"[{'C1': {'code': 'if (version != TLS1_3_VERSION) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER,\n             SSL_R_BAD_PROTOCOL_VERSION_NUMBER);\n    return 0;\n}', 'explanation': 'This code segment explicitly checks that the supported version negotiated is TLS1.3. Since the RFC specifies that obsolete_RESERVED values (and any non‐TLS1.3 values) must not be offered or negotiated, this check fulfills that condition (labeled here as C1).'}}]","The function tls_parse_stoc_supported_versions inspects the version field extracted from the packet and ensures it matches TLS1_3_VERSION. This directly enforces the TLS RFC requirement that obsolete or earlier reserved values (including those in the obsolete_RESERVED range) must not be accepted, thereby implementing the relevant spec constraint within this function.",success,
14139,tls_parse_stoc_supported_versions,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2(pkt, &version) || PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}', 'explanation': 'This code checks if the packet is parseable (i.e. verifies that exactly two bytes can be read and no extra data remains). If the packet is not correctly formatted, it terminates the connection by triggering a decode_error alert as required by the RFC.'}}, {'C2': {'code': 'if (version != TLS1_3_VERSION) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_PROTOCOL_VERSION_NUMBER);\n    return 0;\n}', 'explanation': 'This segment verifies that the version extracted from the packet is TLS1_3_VERSION. If the version is semantically invalid, it terminates the connection with an illegal_parameter alert, exactly following the RFC requirement for handling syntactically correct but semantically invalid messages.'}}]","The function independently implements the RFC requirements by first ensuring that the message is correctly parsed (invoking a decode_error alert if not) and then confirming that the semantics (here, the protocol version) meet expectations (invoking an illegal_parameter alert if the version is incorrect). Hence, the function visibly addresses all labeled conditions and actions required by the specification.",success,
14139,tls_parse_stoc_supported_versions,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Partially Matches,"[{'C1': {'code': 'if (version != TLS1_3_VERSION) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER,\n             SSL_R_BAD_PROTOCOL_VERSION_NUMBER);\n    return 0;\n}', 'explanation': 'The function accepts only TLS1.3 as a valid version in the supported_versions extension. By immediately rejecting any value that is not TLS1_3_VERSION, it effectively prevents any attempt to negotiate older protocol versions such as SSL 2.0. However, the check is implemented indirectly by verifying equality with TLS1.3, rather than explicitly detecting and forbidding an SSL 2.0 value.'}}]","The provided function parses the supported_versions extension in the ServerHello message and only accepts TLS1.3. Since any protocol version not equal to TLS1.3 is rejected, the function indirectly enforces the spec requirement that insecure versions like SSL 2.0 MUST NOT be negotiated. However, because the logic does not explicitly inspect for an SSL 2.0 value (or other conditions related to SSL 2.0) and instead uses a direct check for TLS1.3 only, the implementation only partially addresses the spec constraint in its own code. It relies on the assumption that any version other than TLS1.3 is not permitted, but does not provide targeted handling solely for SSL2, which is why this is considered a partial match.",success,
14139,tls_parse_stoc_supported_versions,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Fully Matches,"[{'C1': {'code': 'if (version != TLS1_3_VERSION) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_PROTOCOL_VERSION_NUMBER);\n    return 0;\n}', 'explanation': 'This code segment ensures that only TLS 1.3 is accepted in the supported_versions extension. Because any version other than TLS1_3_VERSION (including SSL 3.0) is rejected, it directly implements the requirement that SSL 3.0 MUST NOT be negotiated.'}}]","The function tls_parse_stoc_supported_versions explicitly checks that the version provided in the Supported Versions extension is TLS 1.3. Since the security requirement specified in the RFC mandates that SSL 3.0 must not be negotiated under any circumstance, the code correctly rejects any unsupported version (thereby rejecting SSL 3.0) by performing the version check and triggering a fatal error whenever the version does not match TLS1_3_VERSION. This verification is fully implemented within the function itself, meeting the labeled condition (C1) from the spec constraints.",success,
14139,tls_parse_stoc_supported_versions,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function solely handles the parsing and validation of the TLS supported version extension, checking that the version received is TLS1_3_VERSION and setting it accordingly. There is no logic within this function that checks or prevents the negotiation or offering of RC4 cipher suites, as demanded by the RFC specification which states that RC4 cipher suites MUST NOT be offered or negotiated. Thus, the code does not address the relevant spec constraints regarding RC4.",success,
14139,tls_parse_stoc_supported_versions,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2(pkt, &version)\n        || PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}', 'explanation': ""This code segment verifies that the incoming packet is exactly the expected length and correctly parsed. If not, it issues a 'decode_error' alert as required by the RFC when message syntax (such as length) is invalid.""}}, {'A1': {'code': 'if (version != TLS1_3_VERSION) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER,\n             SSL_R_BAD_PROTOCOL_VERSION_NUMBER);\n    return 0;\n}', 'explanation': ""This segment checks if the parsed version is TLS1.3. If it is not, the function triggers an 'illegal_parameter' alert, matching the RFC requirement to send an error alert for semantically invalid messages.""}}]","The function fully implements the specific requirements of the RFC by directly checking the message's syntax and semantics. It verifies the packet length and parsing (triggering a decode_error alert on failure) and also checks that the supported version is TLSv1.3 (triggering an illegal_parameter alert when it isn't), thus addressing the constraints as specified by the RFC.",success,
14139,tls_parse_stoc_supported_versions,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2(pkt, &version) || PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}', 'explanation': 'This code checks that the extension data contains exactly the expected 2 bytes for the version with no extra bytes following. According to the spec, if there are extra bytes after legacy_compression_methods or an invalid extension block, the handshake must be aborted with a decode_error alert.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);', 'explanation': 'This call aborts the handshake by raising a decode_error alert in case the input packet does not meet the expected format.'}}]","The function reads a 2-byte version field and immediately checks that there is no extra data after these bytes. If the condition fails, it aborts the handshake with a decode_error alert as required by the TLS specification. Additionally, it confirms that the only acceptable protocol version in this context is TLS 1.3. These two key behaviors directly implement the specified condition and action from the RFC, and no additional handling is deferred to dependencies. Therefore, in isolation, the function fully meets the spec constraints.",success,
14139,tls_parse_stoc_supported_versions,"If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an ""illegal_parameter"" alert.",76,Partially Matches,"[{'C1': {'code': 'if (version != TLS1_3_VERSION) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER,\n             SSL_R_BAD_PROTOCOL_VERSION_NUMBER);\n    return 0;\n}', 'explanation': ""This code segment checks that the version in the supported_versions extension is TLS1.3. If it is not TLS1_3_VERSION, it aborts the handshake with an 'illegal_parameter' alert, aligning with part of the spec requirement regarding versions prior to TLS1.3.""}}]","The function implements a crucial check by verifying that the version in the 'supported_versions' extension is exactly TLS1.3. This ensures that if a version prior to TLS1.3 (or not TLS1.3, generally speaking) is received, the handshake will be aborted with an illegal_parameter alert. However, the complete specification also requires ensuring that the version is one that was offered by the client. The validation for whether the version was originally offered by the client is deferred to another function (ssl_choose_client_version) and is not handled directly within this function. Therefore, while the function addresses a key part of the spec, it only partially meets the overall RFC requirement.",success,
14140,tls_parse_stoc_key_share,"If this check fails, the client MUST abort the handshake with an ""illegal_parameter"" alert.",132,Fully Matches,"[{'C1': {'code': 'for (i = 0; i < s->s3.tmp.num_ks_pkey; i++) {\n    if (s->s3.tmp.ks_group_id[i] == group_id) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n        return 0;\n    }\n}', 'explanation': ""This loop in the HelloRetryRequest branch verifies that the group chosen by the server is not one that was already sent by the client. If it is, it aborts the handshake with an 'illegal_parameter' alert, as required by the spec.""}}, {'A1': {'code': 'if (PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}\n\n... \n\nif (i >= num_groups\n        || !tls_group_allowed(s, group_id, SSL_SECOP_CURVE_SUPPORTED)\n        || !tls_valid_group(s, group_id, TLS1_3_VERSION, TLS1_3_VERSION, 0, NULL)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    return 0;\n}\n\n...\n\nif (valid_ks_id == 0) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    return 0;\n}', 'explanation': ""Multiple checks ensure that an illegal or unsupported group or incorrect key share leads to a handshake abort via an 'illegal_parameter' alert. This confirms the action mandated in the specification that the client must abort the handshake with this error if any check fails.""}}]","The function tls_parse_stoc_key_share implements the key checks as mandated by the TLS RFC specification. It validates that the chosen group in the server's key share corresponds to one of the client's offered groups and that no duplicate or unsupported key share is used, correctly aborting the handshake with an 'illegal_parameter' alert through SSLfatal() when a check fails. Hence, the function fully meets the specified condition (C1) and corresponding abort action (A1) solely within its own logic.",success,
14140,tls_parse_stoc_key_share,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2(pkt, &group_id)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}\n\n... \n\nif (!PACKET_as_length_prefixed_2(pkt, &encoded_pt) || PACKET_remaining(&encoded_pt) == 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}', 'explanation': 'The function checks that the packet can be parsed correctly, verifying that fields (such as group_id and the length‐prefixed key share) conform to the expected syntax. In cases where parsing fails (e.g. due to length mismatches or unexpected trailing data), it calls SSLfatal with the SSL_AD_DECODE_ERROR alert, thereby terminating the connection as required by the RFC.'}}, {'A1': {'code': 'if (PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}', 'explanation': 'Within the HelloRetryRequest branch, the function ensures that the packet does not contain extra data. If extra data is detected, it terminates the connection with a decode_error alert, fulfilling the action requirement in the spec.'}}]","The function implements the TLS RFC requirement by performing strict packet parsing and verifying message boundaries. When it detects any parsing errors or length mismatches that indicate the message cannot be properly parsed, it terminates the connection by calling SSLfatal with the decode_error alert. This behavior, implemented in multiple segments of the function, directly meets the spec’s condition that any syntactically invalid message must trigger a termination with a 'decode_error' alert.",success,
14140,tls_parse_stoc_key_share,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function 'tls_parse_stoc_key_share' is responsible for parsing the key share extension for TLS 1.3 and handling key exchange, including HelloRetryRequest and key share validation. There is no logic present in the function that addresses any aspects of cipher suite selection, RC4 prohibition, or cipher strength validation as required by the specification. Thus, with respect to the spec constraint that implementations MUST NOT offer or negotiate RC4 cipher suites (and similar cipher requirements), this function does not implement any corresponding condition or action.",success,
14140,tls_parse_stoc_key_share,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'for (i = 0; i < s->s3.tmp.num_ks_pkey; i++) {\n    if (s->s3.tmp.ks_group_id[i] == group_id) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n        return 0;\n    }\n}\n\n...\nif (i >= num_groups || !tls_group_allowed(s, group_id, SSL_SECOP_CURVE_SUPPORTED) || !tls_valid_group(s, group_id, TLS1_3_VERSION, TLS1_3_VERSION, 0, NULL)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    return 0;\n}\n\n...\nif ((ginf = tls1_group_id_lookup(SSL_CONNECTION_GET_CTX(s), group_id)) == NULL) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    return 0;\n}', 'explanation': 'These code segments inspect the received key_share parameters. They check whether the group ID is acceptable, whether it was already sent, and whether it is a supported and valid group. If any of these semantic checks fail, the code triggers an error condition which matches the requirement to treat a semantically invalid message (though syntactically correct) by terminating the connection.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);', 'explanation': ""When a semantically invalid key share is detected, the function calls SSLfatal with SSL_AD_ILLEGAL_PARAMETER, thereby directly fulfilling the action to terminate the connection with an 'illegal_parameter' alert as required by the RFC.""}}]","The function implements logic to verify that the key share provided in the handshake is semantically valid. It checks for duplicate or unsupported group IDs and invalid parameters. In all cases where the message is syntactically correct but semantically invalid, the code terminates the connection by calling SSLfatal with an 'illegal_parameter' alert. This directly addresses the RFC requirement.",success,
14140,tls_parse_stoc_key_share,"If either of these checks fails, then the client MUST abort the handshake with an ""illegal_parameter"" alert.",127,Fully Matches,"[{'C1': {'code': 'for (i = 0; i < s->s3.tmp.num_ks_pkey; i++) {\n    if (s->s3.tmp.ks_group_id[i] == group_id) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n        return 0;\n    }\n}', 'explanation': 'This code verifies that the selected group in the HelloRetryRequest was not already sent in the original key_share extension, as required by the spec.'}}, {'C2': {'code': 'tls1_get_supported_groups(s, &pgroups, &num_groups);\nfor (i = 0; i < num_groups; i++) {\n    if (group_id == pgroups[i])\n        break;\n}\nif (i >= num_groups\n        || !tls_group_allowed(s, group_id, SSL_SECOP_CURVE_SUPPORTED)\n        || !tls_valid_group(s, group_id, TLS1_3_VERSION, TLS1_3_VERSION, 0, NULL)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    return 0;\n}', 'explanation': ""This segment confirms that the selected group is among those supported (from the supported_groups extension in the original ClientHello) and aborts the handshake if it is not, thereby satisfying the spec's condition.""}}]","The function 'tls_parse_stoc_key_share' contains explicit logic that implements both required checks defined in the TLS RFC spec context. In the HelloRetryRequest branch, it ensures that the selected group is not one the client originally provided (thus not reusing a key_share) and that the group is part of the client-supported group list. In both failure cases, it appropriately aborts the handshake by calling SSLfatal with an illegal_parameter alert. Therefore, the function fully meets the specified constraints.",success,
14140,tls_parse_stoc_key_share,"Servers MAY check for violations of these rules and abort the handshake with an ""illegal_parameter"" alert if one is violated.",125,Fully Matches,"[{'C1': {'code': 'for (i = 0; i < s->s3.tmp.num_ks_pkey; i++) {\n    if (s->s3.tmp.ks_group_id[i] == group_id) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n        return 0;\n    }\n}', 'explanation': 'In the HelloRetryRequest branch, the code iterates over previously sent key shares and errors out if the server selects a group already used. This directly implements the rule that a key share already sent must not be requested again.'}}, {'C2': {'code': 'tls1_get_supported_groups(s, &pgroups, &num_groups);\nfor (i = 0; i < num_groups; i++) {\n    if (group_id == pgroups[i])\n        break;\n}\nif (i >= num_groups\n        || !tls_group_allowed(s, group_id, SSL_SECOP_CURVE_SUPPORTED)\n        || !tls_valid_group(s, group_id, TLS1_3_VERSION, TLS1_3_VERSION, 0, NULL)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    return 0;\n}', 'explanation': 'This segment verifies that the server-requested group is among the supported groups provided by the client, matching the RFC requirement that every KeyShareEntry must correspond to a group in the supported_groups extension.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, ...);', 'explanation': 'Throughout the function, when a violation is detected (either a duplicate key share or an unsupported group), the code aborts the handshake by calling SSLfatal with SSL_AD_ILLEGAL_PARAMETER, fulfilling the action requirement to abort on illegal parameters.'}}]","The function 'tls_parse_stoc_key_share' implements explicit checks that mirror the TLS RFC specification. It ensures that in a HelloRetryRequest, a key share that was already sent is not reselected (C1), and it validates that the selected group is among those offered in the client's supported_groups extension (C2). When any violation is detected, it aborts the handshake using an 'illegal_parameter' alert (A1). These code paths address the spec constraints directly within the function, demonstrating a full match against the provided specification.",success,
14140,tls_parse_stoc_key_share,"Upon receipt of this extension in a HelloRetryRequest, the client MUST verify that (1) the selected_group field corresponds to a group which was provided in the ""supported_groups"" extension in the original ClientHello and (2) the selected_group field does not correspond to a group which was provided in the ""key_share"" extension in the original ClientHello.",126,Fully Matches,"[{'C1': {'code': 'tls1_get_supported_groups(s, &pgroups, &num_groups);\nfor (i = 0; i < num_groups; i++) {\n    if (group_id == pgroups[i])\n        break;\n}\nif (i >= num_groups || !tls_group_allowed(s, group_id, SSL_SECOP_CURVE_SUPPORTED) || !tls_valid_group(s, group_id, TLS1_3_VERSION, TLS1_3_VERSION, 0, NULL)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    return 0;\n}', 'explanation': 'This segment checks that the selected_group value received in the HelloRetryRequest is among those advertised in the supported_groups extension in the original ClientHello, fulfilling the requirement that the selected group must be supported (spec condition C1).'}}, {'C2': {'code': 'for (i = 0; i < s->s3.tmp.num_ks_pkey; i++) {\n    if (s->s3.tmp.ks_group_id[i] == group_id) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n        return 0;\n    }\n}', 'explanation': 'This loop verifies that the selected_group is not one for which the client already sent a key share in the original ClientHello, meeting the requirement that the selected group must not be among those in the key_share extension (spec condition C2).'}}]","The function tls_parse_stoc_key_share explicitly implements the two required checks for a HelloRetryRequest as per the TLS RFC specification. First, it ensures that the selected_group is not one of the groups already used in the original key_share extension (C2) and then it verifies that the selected_group is among the supported groups offered by the client in its original ClientHello (C1). Hence, the code function fully implements the required conditions within its logic.",success,
14140,tls_parse_stoc_key_share,"If (EC)DHE key establishment is in use, then the ServerHello contains a ""key_share"" extension with the server's ephemeral Diffie-Hellman share; the server's share MUST be in the same group as one of the client's shares.",0,Fully Matches,"[{'C1': {'code': ""for (i = 0; i < s->s3.tmp.num_ks_pkey; i++) {\n    if (s->s3.tmp.ks_group_id[i] == group_id) {\n        valid_ks_id = group_id;\n        ckey = s->s3.tmp.ks_pkey[i];\n        s->s3.group_id = group_id;\n        s->s3.tmp.pkey = ckey;\n        break;\n    }\n}\nif (valid_ks_id == 0) {\n    /* This isn't for the group that we sent in the original key_share! */\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_SHARE);\n    return 0;\n}"", 'explanation': ""This code segment iterates over the key shares sent by the client and checks that the group ID provided by the server is among them. If it is not, an error is raised. This directly implements the RFC requirement that the server's share MUST be in the same group as one of the client's shares.""}}]",The function tls_parse_stoc_key_share directly processes the 'key_share' extension from the ServerHello and validates that the server's group selection matches one of the groups offered by the client. This check fully implements the relevant RFC specification for (EC)DHE key establishment by ensuring conformity of the group parameters within the function's own logic.,success,
14140,tls_parse_stoc_key_share,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The RFC specification requires that a client must ignore the contents of the supported_groups extension until after a successful handshake and may only use that information to update its preferences for subsequent connections. The provided function tls_parse_stoc_key_share only processes the key_share from the server (including handling HelloRetryRequest scenarios) and performs checks against a locally obtained supported groups list via tls1_get_supported_groups; it does not implement logic that deliberately ignores or defers action on supported_groups data until handshake completion, nor does it update future key_share groups based on post-handshake information. All logic in this function pertains solely to validating and processing key_share information, hence no visible code segments address the specific RFC constraint regarding the handling of the supported_groups extension.",success,
14141,tls_parse_stoc_cookie,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_2(pkt, &cookie)\n        || !PACKET_memdup(&cookie, &s->ext.tls13_cookie, &s->ext.tls13_cookie_len)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}', 'explanation': 'This code segment verifies that the incoming message is correctly parsed by checking the packet length and attempting to duplicate the cookie. On failure, it terminates the connection by calling SSLfatal with SSL_AD_DECODE_ERROR, thereby enforcing the RFC requirement that a decode_error alert is sent when a message cannot be parsed.'}}]","The function clearly implements the required TLS RFC behavior by verifying the syntactic correctness of the incoming message and, if a parsing error is detected (e.g., due to a length mismatch), terminating the connection with a decode_error alert by directly calling SSLfatal. This fulfills the spec constraint that any message failing to parse must trigger a 'decode_error' alert.",success,
14142,tls_parse_stoc_early_data,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'C1': {'code': 'if (!PACKET_get_net_4(pkt, &max_early_data) || PACKET_remaining(pkt) != 0)', 'explanation': 'This check ensures that the packet is of the expected length (i.e. syntactically correct) before further processing. It is part of verifying the message syntax.'}}, {'A1': {'code': 'if (SSL_IS_QUIC_HANDSHAKE(s) && max_early_data != 0xffffffff) {\n    s->session->ext.max_early_data = 1;\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INVALID_MAX_EARLY_DATA);\n    return 0;\n}\n...\nif (!s->ext.early_data_ok || !s->hit) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': ""These branches trigger an 'illegal_parameter' alert when semantically invalid conditions are encountered: one for the QUIC handshake with an unexpected max_early_data value, and another for an early data context that is invalid. This directly addresses the RFC requirement that semantically invalid messages must prompt an illegal_parameter alert.""}}]","The function implements error handling for both syntactic and semantic message errors. It verifies the packet length to catch syntax errors (using a decode_error alert) and, in cases where the message is semantically invalid (e.g., an unexpected max_early_data value in a QUIC handshake or an invalid early data context), it terminates the connection with an illegal_parameter alert. However, it only covers specific cases (related to early data processing) rather than a comprehensive check for all semantically invalid messages described in the RFC. Therefore, while the function does address parts of the RFC requirements through checks and alert actions, it only partially matches the overall specification.",success,
14142,tls_parse_stoc_early_data,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_4(pkt, &max_early_data) || PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_INVALID_MAX_EARLY_DATA);\n    return 0;\n}', 'explanation': 'This segment checks for parsing errors by attempting to read a 4‐byte field from the packet and then verifying that no extra data remains. If either check fails (indicating a malformed message, e.g. an over‐extended length), it terminates the connection with a decode_error alert, precisely as required by the spec.'}}, {'A1': {'code': 'if (PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': ""This part ensures that in contexts other than SSL_EXT_TLS1_3_NEW_SESSION_TICKET, any leftover data in the packet causes termination with a decode_error alert, satisfying the spec's mandate for handling messages that cannot be fully parsed.""}}]","The function implements explicit logic to validate the syntax of the received message by checking the length field and ensuring no extra data remains in the packet. When these conditions are not met, it calls SSLfatal to terminate the connection with a decode_error alert. Additionally, for cases where the message is syntactically correct but semantically invalid (e.g., in QUIC handshakes or mismatched early data conditions), it terminates with an illegal_parameter alert. This behavior directly matches the TLS RFC requirement regarding handling messages that cannot be parsed (syntax errors) or are semantically invalid, thus the function fully implements the labeled spec constraints within its own scope.",success,
14142,tls_parse_stoc_early_data,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function 'tls_parse_stoc_early_data' focuses on parsing early data parameters for TLS 1.3 and QUIC but does not contain any logic related to cipher suite negotiation or filtering of RC4 cipher suites. There is no code segment addressing the spec constraint that 'Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.' Since the function does not handle any cipher suite selection or validation, it does not implement the specified TLS RFC requirement.",success,
14142,tls_parse_stoc_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function only parses and validates the early_data extension. It checks packet lengths, verifies that early data is acceptable via flags (such as s->ext.early_data_ok and s->hit), and handles the max_early_data field. However, none of the code segments directly implement the specification’s directive against automatically resending early data (nor do they check ALPN protocol consistency as required). In other words, no part of this function enforces that early data is not automatically retransmitted, which is the central requirement of the spec. Thus, the function does not visibly address the spec constraints by itself.",success,
14143,tls_parse_stoc_psk,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function tls_parse_stoc_psk does not contain any logic that checks for or disallows the use of the OpenPGP certificate type as specified in RFC6091 for TLS 1.3. Its operations are focused on parsing and validating PSK ticket identities and related session handling, without any explicit verification or rejection of OpenPGP certificates. As such, none of the labeled conditions (e.g., C1) or actions (e.g., A1) from the spec constraints are addressed within this function.",success,
14143,tls_parse_stoc_psk,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The TLS RFC specification mandates that implementations MUST NOT offer or negotiate RC4 cipher suites. However, the provided function (tls_parse_stoc_psk) is concerned with parsing PSK tickets and handling early data, with no logic handling cipher suite selection or RC4 specifically. As such, there is no part of the function that addresses the conditions or actions related to RC4 cipher suites defined in the RFC spec.",success,
14143,tls_parse_stoc_psk,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2(pkt, &identity) || PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}', 'explanation': 'This block checks if the message cannot be parsed properly (e.g., incorrect length) and terminates with a decode_error alert, which corresponds to the RFC requirement for handling syntax errors.'}}, {'A1': {'code': 'if (identity >= (unsigned int)s->ext.tick_identity) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_PSK_IDENTITY);\n    return 0;\n}', 'explanation': 'This block verifies that the received identity is within the valid range. If not, it triggers an illegal_parameter alert, fulfilling the RFC requirement for handling semantically invalid messages.'}}]","The function implements two distinct checks aligned with the TLS RFC specification: one for parsing errors (terminating the connection with a decode_error alert) and another for semantic errors (terminating the connection with an illegal_parameter alert). Both checks are clearly present in the function body, thereby fully matching the specified conditions and actions.",success,
14143,tls_parse_stoc_psk,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The TLS RFC spec requires that early data not be automatically retransmitted unless the negotiated connection selects the same ALPN protocol. In this function, while there is logic that conditionally copies the early secret and unconditionally disables early data (by setting early_data_ok to 0) when the ticket identity is not 0, there is no logic that checks or enforces the negotiated ALPN protocol. Therefore, the function does not implement the part of the specification that prevents automatic retransmission of early data based on ALPN, and no labeled condition or action relevant to the spec constraints is fully addressed within the function_body.",success,
14145,tls_parse_stoc_client_cert_type,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 1) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}\nif (!PACKET_get_1(pkt, &type)) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'These code segments check the packet length and ensure that one byte can be successfully parsed. This aligns with the RFC requirement that messages failing to meet the expected syntax (e.g., length issues) must trigger a termination with a decode_error alert.'}}, {'A1': {'code': 'SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);', 'explanation': 'On detecting a parsing error (either by an unexpected packet length or failure to retrieve the expected byte), the function calls SSLfatal to send a decode_error alert, as required by the RFC for syntax errors.'}}]","The function visibly checks for a properly formatted message by ensuring that the packet contains exactly one byte and that this byte can be parsed. Upon failing these syntactic checks, it terminates the connection by issuing a decode_error alert, fulfilling part of the RFC requirement. However, the RFC also distinguishes between syntactic errors and semantically invalid messages (which should trigger an illegal_parameter alert), yet the function uses decode_error alerts even when the parsed client certificate type is semantically unexpected. Thus, while it correctly implements the syntactic error handling portion, it does not fully differentiate between parsing errors and semantic invalidity, resulting in a partial match.",success,
14147,tls_parse_stoc_server_cert_type,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != 1) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': ""This check ensures that the packet’s length is exactly one byte, in line with the RFC's requirement to detect a message with a length that extends beyond the expected boundary. The function calls SSLfatal with a decode_error alert if the length isn’t as expected.""}}, {'C2': {'code': 'if (!PACKET_get_1(pkt, &type)) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);\n    return 0;\n}', 'explanation': 'This code attempts to extract a single byte from the packet. If extraction fails, it terminates the connection by invoking SSLfatal with a decode_error alert – conforming to the RFC requirement for handling parsing failures.'}}]","The function performs basic syntax validation by checking that the packet has the exact length expected and by safely extracting a single byte value. This correctly implements the part of the RFC that requires termination with a decode_error alert when a message cannot be parsed according to its syntax. However, the RFC also mandates that semantically invalid messages (those that are syntactically correct but contain invalid parameter values) should result in an illegal_parameter alert. In this code, even if the certificate type value extracted is semantically invalid (as indicated by further checks against the expected value and configuration), the function still uses decode_error alerts rather than the illegal_parameter alert specified by the RFC. Therefore, while the function addresses syntax parsing errors, it does not differentiate semantic errors as required, meaning it only partially implements the RFC.",success,
14154,cert_req_allowed,"Servers which are authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, though they MAY send it in post-handshake authentication (see Section 4.6.2) provided that the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6).",184,Partially Matches,"[{'C1': {'code': 'if ((s->s3.tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))\n    return 0;', 'explanation': ""This code segment checks if the cipher's algorithm_auth flags include PSK (or SRP) and, if so, returns 0 to disallow sending a CertificateRequest. This aligns with the requirement that servers authenticating with a PSK must not send the CertificateRequest in the main handshake.""}}]","The function checks for a cipher authentication flag that includes PSK (or SRP) and disallows the CertificateRequest, addressing the core part of the specification. However, the RFC also provides for an exception in post-handshake authentication (when the client sends the 'post_handshake_auth' extension), which is not handled by this function. Thus, while the code addresses the PSK condition in the main handshake, it does not implement the additional logic for post-handshake authentication, resulting in a partial match.",success,
14156,ossl_statem_client13_read_transition,"At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message.",238,Partially Matches,"[{'C1': {'code': 'case TLS_ST_OK:\n    if (mt == SSL3_MT_NEWSESSION_TICKET) {\n        st->hand_state = TLS_ST_CR_SESSION_TICKET;\n        return 1;\n    }', 'explanation': 'This code segment handles a NEWSESSION_TICKET message when the state is TLS_ST_OK, which is reached after processing the client Finished message. It meets the RFC requirement that the server may send a NewSessionTicket message at this point. However, the function solely transitions the state and does not implement the full logic for associating the ticket with a PSK or other related actions per the RFC.'}}]","The function implements the specified TLS RFC aspect in that it checks for a NEWSESSION_TICKET message in the TLS_ST_OK state, which occurs after the Finished message has been processed. This meets the condition that the server may send the NewSessionTicket message after client Finished. However, the RFC also details further processing (such as associating the ticket with resumption secrets) that is not handled in this code fragment; hence, the match is only partial with respect to the complete specification.",success,
14156,ossl_statem_client13_read_transition,"When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message.",224,Fully Matches,"[{'C1': {'code': 'case TLS_ST_CR_CERT:\ncase TLS_ST_CR_COMP_CERT:\n    if (mt == SSL3_MT_CERTIFICATE_VERIFY) {\n        st->hand_state = TLS_ST_CR_CERT_VRFY;\n        return 1;\n    }', 'explanation': 'This segment ensures that immediately after a Certificate (or Compressed Certificate) message, the next expected message is CertificateVerify. This directly addresses the spec requirement that the CertificateVerify message must follow the Certificate message.'}}, {'A1': {'code': 'case TLS_ST_CR_CERT_VRFY:\n    if (mt == SSL3_MT_FINISHED) {\n        st->hand_state = TLS_ST_CR_FINISHED;\n        return 1;\n    }', 'explanation': 'This segment processes the Finished message right after the CertificateVerify message, thus ensuring that the CertificateVerify message appears immediately before the Finished message as required.'}}]","The function implements a state machine for the TLS 1.3 handshake. It contains explicit checks to ensure that the CertificateVerify message is processed immediately following the Certificate message and that the Finished message immediately follows the CertificateVerify message. These transitions, implemented by the corresponding code segments, directly fulfill the TLS RFC specification conditions outlined in the provided context.",success,
14156,ossl_statem_client13_read_transition,"This message, if sent, MUST follow EncryptedExtensions.",179,Fully Matches,"[{'C1': {'code': 'case TLS_ST_CR_ENCRYPTED_EXTENSIONS:\n    if (s->hit) {\n        if (mt == SSL3_MT_FINISHED) {\n            st->hand_state = TLS_ST_CR_FINISHED;\n            return 1;\n        }\n    } else {\n        if (mt == SSL3_MT_CERTIFICATE_REQUEST) {\n            st->hand_state = TLS_ST_CR_CERT_REQ;\n            return 1;\n        }\n        if (mt == SSL3_MT_CERTIFICATE) {\n            st->hand_state = TLS_ST_CR_CERT;\n            return 1;\n        }\n        #ifdef OPENSSL_NO_COMP_ALG\n        #else\n        if (mt == SSL3_MT_COMPRESSED_CERTIFICATE && s->ext.compress_certificate_sent) {\n            st->hand_state = TLS_ST_CR_COMP_CERT;\n            return 1;\n        }\n        #endif\n    }', 'explanation': 'This segment ensures that the CertificateRequest message (if sent) is only processed when the handshake state is TLS_ST_CR_ENCRYPTED_EXTENSIONS, guaranteeing that the CertificateRequest follows EncryptedExtensions as required by the spec.'}}]","The function implements a TLS 1.3 client state machine. In the TLS_ST_CR_ENCRYPTED_EXTENSIONS state, it explicitly checks for a CertificateRequest message and transitions to TLS_ST_CR_CERT_REQ only when that message is received. This matches the RFC requirement that the CertificateRequest (if sent) MUST follow EncryptedExtensions. Thus, within the scope of this function, the constraint is fully met.",success,
14156,ossl_statem_client13_read_transition,"When the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message.",254,Fully Matches,"[{'C1': {'code': 'if (mt == SSL3_MT_CERTIFICATE_REQUEST) {\n#if ...\n    if (!SSL_CONNECTION_IS_DTLS(s)\n        && s->post_handshake_auth == SSL_PHA_EXT_SENT) {\n        s->post_handshake_auth = SSL_PHA_REQUESTED;\n        if (!tls13_restore_handshake_digest_for_pha(s)) {\n            return 0;\n        }\n        st->hand_state = TLS_ST_CR_CERT_REQ;\n        return 1;\n    }\n}', 'explanation': 'This code segment checks for the CertificateRequest message when the handshake state is TLS_ST_OK and confirms that the client had previously sent the post_handshake_auth extension (by verifying that s->post_handshake_auth equals SSL_PHA_EXT_SENT). It then transitions the state machine appropriately, which directly implements the RFC specification that a server MAY request client authentication (via a CertificateRequest) after the post_handshake_auth extension has been sent.'}}]",The function contains specific logic to handle the scenario when a CertificateRequest message is received from the server in a TLS 1.3 handshake. It verifies that the client sent the post_handshake_auth extension and then correctly transitions the state machine to expect the certificate response. This behavior fully covers the relevant condition and action outlined in the TLS RFC specification provided.,success,
14156,ossl_statem_client13_read_transition,"In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message.",176,Partially Matches,"[{'C1': {'code': 'case TLS_ST_CR_SRVR_HELLO:\n    if (mt == SSL3_MT_ENCRYPTED_EXTENSIONS) {\n        st->hand_state = TLS_ST_CR_ENCRYPTED_EXTENSIONS;\n        return 1;\n    }', 'explanation': 'This segment of the code shows that once the client has received the ServerHello (and is in state TLS_ST_CR_SRVR_HELLO), it expects the next message to be an EncryptedExtensions message, transitioning the state accordingly. This aligns with the RFC requirement that the server must send EncryptedExtensions immediately after the ServerHello message.'}}]","The function implements a check to ensure the EncryptedExtensions message immediately follows the ServerHello by verifying the message type when in the TLS_ST_CR_SRVR_HELLO state. However, it does not handle further processing of the EncryptedExtensions (such as checking for forbidden extensions), which is part of the full spec. Therefore, while it partially addresses the ordering requirement from the RFC, it does not fully encapsulate all aspects of the specification within this function.",success,
14156,ossl_statem_client13_read_transition,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The RFC spec requires that application data not be sent before the Finished message, but this function only handles state transitions for handshake messages (e.g., ServerHello, EncryptedExtensions, Certificate, Finished, etc.). There is no logic in the function that checks or prevents application data from being sent before the Finished message. Hence, the function does not visibly implement the specified TLS RFC constraint.",success,
14157,ossl_statem_client_read_transition,"At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message.",238,Partially Matches,"[{'C1': {'code': 'case TLS_ST_CW_FINISHED:\n    if (s->ext.ticket_expected) {\n        if (mt == SSL3_MT_NEWSESSION_TICKET) {\n            st->hand_state = TLS_ST_CR_SESSION_TICKET;\n            return 1;\n        }\n    } else if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n        st->hand_state = TLS_ST_CR_CHANGE;\n        return 1;\n    }', 'explanation': ""This branch in the TLS_ST_CW_FINISHED state checks if a NewSessionTicket is received when a ticket is expected. This aligns with the RFC condition that after the client Finished message, the server may send a NewSessionTicket message. However, the implementation handles the ticket only in this state, and while it partially reflects the spec, it does not cover the full flexibility allowed by the RFC (i.e. 'at any time after...').""}}]","The function processes state transitions in the TLS handshake and includes logic to handle a NewSessionTicket message when the client is in the TLS_ST_CW_FINISHED state and a ticket is expected. This demonstrates an attempt to implement part of the RFC spec regarding the receipt of a NewSessionTicket after the client Finished message. However, by only covering specific states rather than the full flexibility permitted by the RFC, the implementation only partially meets the specified constraint.",success,
14157,ossl_statem_client_read_transition,An implementation may receive an unencrypted record of type change_cipher_spec consisting of the single byte value 0x01 at any time after the first ClientHello message has been sent or received and before the peer's Finished message has been received and MUST simply drop it without further processing.,268,Partially Matches,"[{'C1': {'code': 'if (s->hit) {\n    ...\n    } else {\n        ...\n        else if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n            st->hand_state = TLS_ST_CR_CHANGE;\n            return 1;\n        }\n    }\n\n    ...\n\n    case TLS_ST_CW_FINISHED:\n        ...\n        else if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n            st->hand_state = TLS_ST_CR_CHANGE;\n            return 1;\n        }\n    \n    case TLS_ST_CR_SESSION_TICKET:\n        if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n            st->hand_state = TLS_ST_CR_CHANGE;\n            return 1;\n        }\n', 'explanation': 'The code checks for a change_cipher_spec (CCS) message (mt == SSL3_MT_CHANGE_CIPHER_SPEC) in several valid handshake states and transitions the handshake state accordingly. This handling reflects an attempt to implement the RFC requirement that an unencrypted CCS record may be received and should be simply dropped (i.e. not processed as a handshake message).'}}, {'A1': {'code': 'err:\n    /* No valid transition found */\n    if (SSL_CONNECTION_IS_DTLS(s) && mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n        ...\n        return 0;\n    }\n    SSLfatal(s, SSL3_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);\n    return 0;', 'explanation': 'When a CCS message is received in an unexpected context, the code either drops the message (in DTLS by resetting state and retrying) or aborts the handshake with an ""unexpected_message"" alert. This fulfills the RFC mandate to terminate the connection when an unexpected CCS (or one not matching the protocol rules) is received.'}}]","The function implements parts of the TLS RFC regarding change_cipher_spec messages by examining the message type and updating the handshake state when a CCS is received in allowed contexts, and by aborting the handshake with an unexpected_message alert when a CCS is received in a disallowed context. However, it does not inspect the actual content of the CCS record (i.e. checking for the single byte value 0x01) as specified in the RFC. Thus, while some aspects of the spec are addressed within this function, it only partially implements all of the RFC’s constraints for change_cipher_spec processing.",success,
14157,ossl_statem_client_read_transition,"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",272,Partially Matches,"[{'A1': {'code': ""err:\n    /* No valid transition found */\n    if (SSL_CONNECTION_IS_DTLS(s) && mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n        BIO *rbio;\n\n        /*\n         * CCS messages don't have a message sequence number so this is probably\n         * because of an out-of-order CCS. We'll just drop it.\n         */\n        s->init_num = 0;\n        s->rwstate = SSL_READING;\n        rbio = SSL_get_rbio(SSL_CONNECTION_GET_SSL(s));\n        BIO_clear_retry_flags(rbio);\n        BIO_set_retry_read(rbio);\n        return 0;\n    }\n    SSLfatal(s, SSL3_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);\n    return 0;"", 'explanation': 'This code branch is reached when no valid state transition for the incoming message type is found. In such cases (except for a specific DTLS out‐of‐order CCS), the function aborts the handshake by calling SSLfatal with the unexpected_message alert, which addresses the requirement to terminate the connection when an unexpected record type is received.'}}]","The function implements a state-driven transition mechanism that only accepts expected record types at each handshake state. When an unexpected record type is encountered (i.e. none of the allowed cases apply), it leads to an error branch that eventually calls SSLfatal with an unexpected_message alert. This directly implements the action of terminating the connection when an unexpected record type is received (as per the TLS RFC requirement). However, the function does not contain any explicit check on the content of a change_cipher_spec record (for example, verifying that an unencrypted change_cipher_spec contains only the single byte 0x01), which is an important nuance specified in the RFC. Hence, while the error handling for unexpected types is present, the logic for handling some special cases (like change_cipher_spec processing per the RFC) is not fully implemented within this function. Therefore, the function only partially matches the full specification.",success,
14157,ossl_statem_client_read_transition,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Fully Matches,"[{'C1': {'code': 'err:\n    /* No valid transition found */\n    if (SSL_CONNECTION_IS_DTLS(s) && mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n        ...\n        return 0;\n    }\n    SSLfatal(s, SSL3_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);\n    return 0;', 'explanation': ""This segment handles the case when a handshake message is received in an unexpected order by aborting the handshake with an 'unexpected_message' alert. The function checks all valid state transitions and, upon not matching any, jumps to the 'err' label where it ultimately calls SSLfatal with the proper alert.""}}]",The code function exhaustively verifies the order of incoming handshake messages based on the current handshake state. If none of the expected message types matches the current state—thus representing an unexpected order—the function aborts the handshake by issuing an 'unexpected_message' alert via SSLfatal. This directly implements the TLS RFC requirement specified.,success,
14157,ossl_statem_client_read_transition,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function is concerned solely with state transitions during the handshake and, although it has a branch for the TLS_ST_EARLY_DATA state, it does not implement any logic specifically addressing the RFC requirement that an implementation SHOULD NOT automatically resend early data. There is no check for ALPN protocol matching or any mechanism that governs a retransmission decision of early data. Hence, within this function there is no visible code that enforces or even addresses the constraint that early data should only be retransmitted if the negotiated connection selects the same ALPN protocol, or that the client application should decide on retransmission.",success,
14159,ossl_statem_client13_write_transition,"When the client has sent the ""post_handshake_auth"" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message.",254,Partially Matches,"[{'C1': {'code': 'case TLS_ST_CR_CERT_REQ:\n    if (s->post_handshake_auth == SSL_PHA_REQUESTED) {\n        if (do_compressed_cert(s))\n            st->hand_state = TLS_ST_CW_COMP_CERT;\n        else\n            st->hand_state = TLS_ST_CW_CERT;\n        return WRITE_TRAN_CONTINUE;\n    }', 'explanation': 'This segment checks if the client sent the post_handshake_auth extension (a condition implied by the RFC), and if so, enters the branch to prepare for sending a Certificate message. It therefore visibly addresses the condition of the client having signaled post-handshake authentication intent.'}}, {'A1': {'code': 'case TLS_ST_CW_CERT:\n    /* If a non-empty Certificate we also send CertificateVerify */\n    st->hand_state = (s->s3.tmp.cert_req == 1) ? TLS_ST_CW_CERT_VRFY\n                                                : TLS_ST_CW_FINISHED;\n    return WRITE_TRAN_CONTINUE;\n\ncase TLS_ST_CW_CERT_VRFY:\n    st->hand_state = TLS_ST_CW_FINISHED;\n    return WRITE_TRAN_CONTINUE;', 'explanation': 'These segments transition the state machine to send the Certificate (and, when applicable, CertificateVerify) message followed by Finished, in line with the RFC requirement that if the client chooses to authenticate, it must send Certificate followed by CertificateVerify and Finished.'}}]","The function implements part of the RFC behavior by handling state transitions in response to a server's CertificateRequest when the client had signaled post-handshake authentication (via post_handshake_auth). It sets the state to send either a (possibly compressed) Certificate message and, if needed, a CertificateVerify message, followed by Finished. However, it only addresses the state transitions for sending these messages and does not fully cover all aspects of the specification (for example, ensuring that all client messages are sent consecutively without intervening messages). Thus, the function only partially matches the complete spec requirements.",success,
14159,ossl_statem_client13_write_transition,"If the client chooses to authenticate, it MUST send Certificate, CertificateVerify,",256,Fully Matches,"[{'A1': {'code': 'case TLS_ST_CW_CERT:\n    /* If a non-empty Certificate we also send CertificateVerify */\n    st->hand_state = (s->s3.tmp.cert_req == 1) ? TLS_ST_CW_CERT_VRFY\n                                                : TLS_ST_CW_FINISHED;\n    return WRITE_TRAN_CONTINUE;', 'explanation': 'When the client is requested to authenticate, the state machine transitions to the Certificate sending state. In this branch, if a non‐empty certificate is present (s->s3.tmp.cert_req == 1), the code sets the next state to send CertificateVerify, thereby scheduling the Certificate and CertificateVerify messages as required by the spec.'}}, {'A2': {'code': 'case TLS_ST_CW_CERT_VRFY:\n    st->hand_state = TLS_ST_CW_FINISHED;\n    return WRITE_TRAN_CONTINUE;', 'explanation': 'This branch handles sending the CertificateVerify message. After sending the Certificate, if the certificate is non-empty and authentication is chosen, the state machine transitions to this CertificateVerify sending state before moving to sending Finished.'}}]","The provided function implements the TLS client state transitions for handling client authentication messages. When a certificate request is received (as in the TLS_ST_CR_CERT_REQ case), it determines whether to send a compressed certificate (if applicable) or a regular certificate. In the TLS_ST_CW_CERT state, the code checks if authentication was requested (via s->s3.tmp.cert_req) and, if a non-empty certificate is to be sent, schedules the CertificateVerify message by moving to TLS_ST_CW_CERT_VRFY. Finally, regardless of whether a CertificateVerify is sent or not, the state machine advances to TLS_ST_CW_FINISHED. This sequence effectively implements the RFC directive that, if the client chooses to authenticate, it MUST send Certificate, CertificateVerify, and Finished. All of the necessary transitions are visible within this function, without relying on dependency logic.",success,
14159,ossl_statem_client13_write_transition,"Clients MUST send this message whenever authenticating via a certificate (i.e., when the Certificate message is non-empty).",223,Fully Matches,"[{'C1': {'code': 'case TLS_ST_CW_COMP_CERT:\n    case TLS_ST_CW_CERT:\n        /* If a non-empty Certificate we also send CertificateVerify */\n        st->hand_state = (s->s3.tmp.cert_req == 1) ? TLS_ST_CW_CERT_VRFY : TLS_ST_CW_FINISHED;\n        return WRITE_TRAN_CONTINUE;', 'explanation': 'This segment explicitly checks if a certificate was provided (s->s3.tmp.cert_req == 1) and then sets the state to send CertificateVerify, as required by the spec when the Certificate message is non-empty.'}}, {'A1': {'code': 'case TLS_ST_CW_CERT_VRFY:\n    st->hand_state = TLS_ST_CW_FINISHED;\n    return WRITE_TRAN_CONTINUE;', 'explanation': 'This segment ensures that the CertificateVerify message transition is immediately followed by moving to the Finished state, thereby placing it immediately after the Certificate message, as the RFC mandates.'}}]",The function implements the TLSv1.3 state transitions related to certificate based authentication by directly checking if a Certificate message is non-empty and ensuring that the CertificateVerify message is sent immediately afterwards and just prior to the Finished message. The relevant state transitions (TLS_ST_CW_CERT / TLS_ST_CW_COMP_CERT and TLS_ST_CW_CERT_VRFY) in the function_body visibly address the constraints specified in the RFC.,success,
14159,ossl_statem_client13_write_transition,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The TLS RFC constraint requires that Application Data is not sent prior to sending the Finished message. The provided function focuses solely on managing state transitions for handshake messages (e.g., handling certificate request, finished, key update transitions) and does not contain explicit logic to prevent Application Data from being sent before the Finished message. Therefore, within the confines of this function alone, there is no code that enforces the specified RFC requirement.",success,
14159,ossl_statem_client13_write_transition,"When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message.",224,Fully Matches,"[{'C1': {'code': 'case TLS_ST_CW_CERT:\n    /* If a non-empty Certificate we also send CertificateVerify */\n    st->hand_state = (s->s3.tmp.cert_req == 1) ? TLS_ST_CW_CERT_VRFY : TLS_ST_CW_FINISHED;', 'explanation': 'This code checks if a certificate has been provided (non-empty) via s->s3.tmp.cert_req. If it is 1, it sets the next state to TLS_ST_CW_CERT_VRFY, thereby ensuring that the CertificateVerify message is sent immediately after the Certificate message and before the Finished message, as required.'}}, {'A1': {'code': 'case TLS_ST_CW_CERT_VRFY:\n    st->hand_state = TLS_ST_CW_FINISHED;\n    return WRITE_TRAN_CONTINUE;', 'explanation': 'After the CertificateVerify message is queued, this segment transitions to the Finished message state, maintaining the correct ordering per the RFC.'}}]","The function implements a state machine for TLS 1.3 transitions. Specifically, it checks whether the Certificate message is non-empty and, if so, transitions to send the CertificateVerify message immediately after the Certificate and immediately prior to the Finished message. The code segments under the TLS_ST_CW_CERT and TLS_ST_CW_CERT_VRFY states clearly enforce this ordering as specified in the RFC, thereby fully matching the constraints.",success,
14159,ossl_statem_client13_write_transition,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Partially Matches,"[{'C1': {'code': 'case TLS_ST_PENDING_EARLY_DATA_END:\n    if (s->ext.early_data == SSL_EARLY_DATA_ACCEPTED && !SSL_NO_EOED(s)) {\n        st->hand_state = TLS_ST_CW_END_OF_EARLY_DATA;\n        return WRITE_TRAN_CONTINUE;\n    }', 'explanation': 'This segment handles the end-of-early-data phase based on the early_data flag, indicating that the state machine is aware of early data handling. It ensures that the connection does not blindly proceed but transitions state appropriately. However, it does not perform any check on the negotiated ALPN protocol, as required by the RFC.'}}, {'A1': {'code': 'if (s->early_data_state == SSL_EARLY_DATA_WRITE_RETRY\n        || s->early_data_state == SSL_EARLY_DATA_FINISHED_WRITING)\n    st->hand_state = TLS_ST_PENDING_EARLY_DATA_END;', 'explanation': 'This segment detects specific early data states and moves the state machine to a pending early data end state, which is related to managing early data transmissions. It supports the idea that the implementation defers the decision to resend early data rather than doing it automatically. Yet, like the previous case, it does not verify that the ALPN protocol matches, missing a key part of the specification.'}}]","The code function includes logic to handle state transitions related to early data, which partially addresses the RFC requirement that a TLS implementation SHOULD NOT automatically resend early data. It clearly manages early data state (for example, transitioning to TLS_ST_PENDING_EARLY_DATA_END) and avoids automatic retransmission in some paths. However, the RFC explicitly mandates that automatic retransmission must not occur unless the negotiated connection selects the same ALPN protocol. The provided function does not contain any logic to verify that the negotiated ALPN protocol matches before proceeding, meaning it does not fully implement the complete specification requirement. Thus, only part of the constraint is visibly addressed in this function.",success,
14160,ossl_statem_client_write_transition,The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2).,186,Partially Matches,"[{'C1': {'code': 'case TLS_ST_CR_SRVR_DONE:\n    s->ts_msg_read = ossl_time_now();\n    if (s->s3.tmp.cert_req)\n        st->hand_state = TLS_ST_CW_CERT;\n    else\n        st->hand_state = TLS_ST_CW_KEY_EXCH;\n    return WRITE_TRAN_CONTINUE;', 'explanation': 'This segment checks if the server has requested client authentication (via s->s3.tmp.cert_req) and, if so, sets the handshake state to send a Certificate message (TLS_ST_CW_CERT). Conversely, if no request is present, it skips to the key exchange state. This reflects part of the requirement that the client sends a Certificate message if and only if the server requested one.'}}]","The function_body implements state transitions that conditionally lead to sending a Certificate message when a certificate request is detected. This aligns with the part of the RFC that mandates sending a Certificate message if the server requests client authentication. However, the function does not address additional aspects such as sending an empty Certificate message when no appropriate certificate is available. Since only part of the spec constraint is directly handled within this function, the implementation is assessed as partially matching the RFC specification.",success,
14160,ossl_statem_client_write_transition,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The TLS RFC requires that automatic retransmission of early data should be avoided (unless the negotiated ALPN protocol matches), thereby leaving the decision to the application. Within the provided function, although there are branches that handle an 'early_data_state' (for example, in the TLS_ST_CW_CLNT_HELLO case where it checks if s->early_data_state equals SSL_EARLY_DATA_CONNECTING) and transitions to TLS_ST_EARLY_DATA, there is no explicit logic verifying that the negotiated ALPN protocol matches or that retransmission should not occur automatically. There is no check against the ALPN condition specified by the RFC. In other words, while the function does manage some aspects of state transitions involving early data, it does not visibly enforce the constraint of not automatically resending early data nor does it condition the resend on ALPN matching. Therefore, in isolation and by itself, this function does not implement the specified TLS RFC requirement.",success,
14160,ossl_statem_client_write_transition,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function is a state‐transition routine for the handshake process. It governs the transitions between various handshake messages (ClientHello, Certificate, Key Exchange, Finished, etc.). However, the TLS RFC requirement (that Application Data MUST NOT be sent prior to the Finished message) is not explicitly checked or enforced by this function. There is no logic here that verifies or prevents the sending of Application Data until after the Finished message. Therefore, in isolation, this function does not implement or enforce the specified TLS RFC condition.",success,
14161,ossl_statem_client_pre_work,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Partially Matches,"[{'A1': {'code': 'else if (s->ext.early_data == SSL_EARLY_DATA_REJECTED) {\n    /*\n     * This must be a second ClientHello after an HRR following an\n     * earlier rejected attempt to send early data. Since we were\n     * previously encrypting the early data we now need to reset the\n     * write record layer in order to write in plaintext again.\n     */\n    if (!ssl_set_new_record_layer(s,\n                                  TLS_ANY_VERSION,\n                                  OSSL_RECORD_DIRECTION_WRITE,\n                                  OSSL_RECORD_PROTECTION_LEVEL_NONE,\n                                  NULL, 0, NULL, 0, NULL, 0, NULL,  0,\n                                  NULL, 0, NID_undef, NULL, NULL,\n                                  NULL)) {\n        /* SSLfatal already called */\n        return WORK_ERROR;\n    }\n}', 'explanation': 'This block resets the write record layer when early data has been rejected. By doing so, the function avoids automatically retransmitting the early data, which aligns with the RFC requirement that a TLS implementation SHOULD NOT automatically resend early data. However, the code does not check that the negotiated ALPN protocol is the same before potentially retransmitting, so it only partially addresses the complete spec constraint.'}}]","The RFC specifies that early data should not be automatically resent unless the negotiated connection selects the same ALPN protocol. The provided function includes logic (in the ClientHello case) to reset the record layer when early data is rejected, thereby preventing automatic retransmission. However, it does not implement any explicit check to ensure that the negotiated ALPN protocol matches that of the early data. Thus, while the function addresses part of the requirement by avoiding automatic retransmission, it does not fully enforce the ALPN protocol condition, leading to a 'Partially Matches' outcome.",success,
14162,ossl_statem_client_post_work,Any records following a Finished message MUST be encrypted under the appropriate application traffic key as described in Section 7.2.,234,Partially Matches,"[{'A1': {'code': 'case TLS_ST_CW_FINISHED:\n    ...\n    if (SSL_CONNECTION_IS_TLS13(s)) {\n        if (!tls13_save_handshake_digest_for_pha(s)) {\n            return WORK_ERROR;\n        }\n        if (s->post_handshake_auth != SSL_PHA_REQUESTED) {\n            if (!ssl->method->ssl3_enc->change_cipher_state(s,\n                    SSL3_CC_APPLICATION | SSL3_CHANGE_CIPHER_CLIENT_WRITE)) {\n                return WORK_ERROR;\n            }\n        }\n    }', 'explanation': 'This segment in the TLS_ST_CW_FINISHED branch for TLS 1.3 explicitly changes the cipher state to use the application traffic key for subsequent records, satisfying the requirement that records following a Finished message must be encrypted. However, it only addresses TLS 1.3 and does not clearly cover similar behavior for non-TLS13 cases or the handling of alerts following Finished messages as specified in the RFC.'}}]","The function attempts to implement the requirement by calling change_cipher_state with parameters for application traffic in the TLS_ST_CW_FINISHED state for TLS 1.3. However, since this logic is limited to TLS 1.3 and does not clearly address all scenarios (such as ensuring that all records following a Finished message, including alerts, are encrypted under the appropriate key in other protocol versions), the implementation is only a partial match to the RFC specification.",success,
14162,ossl_statem_client_post_work,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Fully Matches,"[{'C1': {'code': 'case TLS_ST_CW_FINISHED:\n    #ifndef OPENSSL_NO_SCTP\n        if (wst == WORK_MORE_A && SSL_CONNECTION_IS_DTLS(s) && s->hit == 0) {\n            BIO_ctrl(SSL_get_wbio(ssl), BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY, 0, NULL);\n        }\n    #endif\n    if (statem_flush(s) != 1)\n        return WORK_MORE_B;\n\n    if (SSL_CONNECTION_IS_TLS13(s)) {\n        if (!tls13_save_handshake_digest_for_pha(s)) {\n            return WORK_ERROR;\n        }\n        if (s->post_handshake_auth != SSL_PHA_REQUESTED) {\n            if (!ssl->method->ssl3_enc->change_cipher_state(s,\n                    SSL3_CC_APPLICATION | SSL3_CHANGE_CIPHER_CLIENT_WRITE)) {\n                return WORK_ERROR;\n            }\n        }\n    }', 'explanation': 'This segment handles the TLS_FINISHED state by ensuring that handshake messages are fully flushed and then transitions the cipher state to application data (using SSL3_CC_APPLICATION). This ordering guarantees that application data encryption and subsequent sending are only enabled after the Finished message has been processed, thereby enforcing that application data is not sent prematurely.'}}]","The function manages several handshake states and, in particular, within the TLS_ST_CW_FINISHED case it flushes all pending handshake messages and only then switches the cipher state to allow application data to be sent. This ensures that application data cannot be sent before the Finished message is sent, directly addressing the spec requirement that application-level data must not be transmitted prior to the Finished handshake message.",success,
14162,ossl_statem_client_post_work,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The RFC requires that a TLS implementation MUST NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol, and that applications be allowed to decide when retransmission is appropriate. Although the function checks for an early data state (for example, through the condition (s->early_data_state == SSL_EARLY_DATA_CONNECTING && s->max_early_data > 0)) and takes specific actions (such as calling tls13_change_cipher_state), it does not incorporate any logic to decide on or prevent automatic retransmission based on the negotiated ALPN protocol. In other words, the function does not include any conditional checks or safeguards related to ALPN that would enforce the spec’s constraints. Therefore, within the confines of this function’s code, the spec constraints are not visibly addressed.",success,
14163,ossl_statem_client_construct_message,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function solely selects and assigns client handshake message construction functions based on the current handshake state. It does not include any logic or checks that enforce the RFC requirement that Application Data MUST NOT be sent prior to sending the Finished message. There is no code in this function that prevents the sending of application data before the Finished message is constructed, so the spec constraints are not addressed here.",success,
14163,ossl_statem_client_construct_message,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function, ossl_statem_client_construct_message, is a state machine handler that dispatches to various construction functions based on the handshake state. It does not include any logic that checks or controls the retransmission of early data, nor does it address the ALPN protocol comparison requirement as stated in the spec. In other words, none of the code segments directly implement the spec constraints regarding preventing automatic resending of early data. The function simply maps handshake states to corresponding construction routines and does not make decisions about early data retransmission.",success,
14167,tls_construct_client_hello,Implementations MUST NOT negotiate TLS 1.3 or later using an SSL version 2.0 compatible CLIENT-HELLO.,394,Partially Matches,"[{'C1': {'code': '/*\n     * For TLS 1.3 we always set the ClientHello version to 1.2 and rely on the\n     * supported_versions extension for the real supported versions.\n     */\n    if (!WPACKET_put_bytes_u16(pkt, s->client_version)\n            || !WPACKET_memcpy(pkt, s->s3.client_random, SSL3_RANDOM_SIZE)) { ... }', 'explanation': 'The RFC requires that TLS 1.3 (or later) MUST NOT be negotiated using an SSLv2 compatible ClientHello. In this function the comment indicates that for TLS 1.3 the ClientHello version is always set to TLS 1.2 (i.e. s->client_version is set appropriately beforehand via ssl_set_client_hello_version), and the message is constructed using the standard TLS ClientHello format. This suggests that the function is avoiding the SSLv2 compatible style, though the check is indirect and relies on prior initialization of s->client_version.'}}]","This function constructs the ClientHello message by packing fields using TLS APIs (WPACKET_*). It includes a comment that for TLS 1.3 the ClientHello version is set to TLS 1.2, thus steering the handshake away from an SSLv2 compatible ClientHello. However, the function does not explicitly check or differentiate an SSLv2 style ClientHello format; it relies on earlier functions (like ssl_set_client_hello_version) and on the use of the TLS ClientHello format. Because only part of the TLS RFC constraint is handled visibly in this function, the overall outcome is 'Partially Matches'.",success,
14167,tls_construct_client_hello,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The TLS specification requires that implementations MUST NOT use the Truncated HMAC extension. However, within tls_construct_client_hello there is no explicit logic that checks for or excludes the Truncated HMAC extension. Although the function calls tls_construct_extensions to build extensions, none of the code within this function clearly implements the condition against using the Truncated HMAC extension or enforces that records have a version >= 0x0300. All version handling is delegated to other helper functions (e.g., ssl_set_client_hello_version) and no direct check for the truncated HMAC extension is performed inside this function. Therefore, the function does not visibly address the specific spec constraints by itself.",success,
14167,tls_construct_client_hello,-A client sending a ClientHello MUST support all parameters advertised in it.,357,Fully Matches,"[{'C1': {'code': 'if (!WPACKET_put_bytes_u16(pkt, s->client_version)\n        || !WPACKET_memcpy(pkt, s->s3.client_random, SSL3_RANDOM_SIZE)) { ... }\n\n... \nif (!WPACKET_start_sub_packet_u8(pkt)\n        || (sess_id_len != 0 && !WPACKET_memcpy(pkt, session_id, sess_id_len))\n        || !WPACKET_close(pkt)) { ... }\n\n... \nif (!WPACKET_start_sub_packet_u16(pkt)) { ... }\nif (!ssl_cipher_list_to_bytes(s, SSL_get_ciphers(SSL_CONNECTION_GET_SSL(s)), pkt)) { ... }\n\n... \nif (!WPACKET_start_sub_packet_u8(pkt)) { ... }\n#ifndef OPENSSL_NO_COMP\n    if (ssl_allow_compression(s) && sctx->comp_methods && (SSL_CONNECTION_IS_DTLS(s) || s->s3.tmp.max_ver < TLS1_3_VERSION)) {\n         for (i = 0; i < sk_SSL_COMP_num(sctx->comp_methods); i++) {\n             comp = sk_SSL_COMP_value(sctx->comp_methods, i);\n             if (!WPACKET_put_bytes_u8(pkt, comp->id)) { ... }\n         }\n    }\n#endif\n    if (!WPACKET_put_bytes_u8(pkt, 0) || !WPACKET_close(pkt)) { ... }\n\n... \nif (!tls_construct_extensions(s, pkt, SSL_EXT_CLIENT_HELLO, NULL, 0)) { ... }', 'explanation': 'This function constructs the ClientHello message completely. It adds all required mandatory fields such as the client_version and random, session ID, cipher suites, compression methods, and TLS extensions. By including these elements, the function ensures that all parameters it advertises in the ClientHello are supported, in accordance with the TLS RFC requirement.'}}]","The TLS RFC specifies that a client sending a ClientHello must support every parameter it advertises. The function 'tls_construct_client_hello' builds the ClientHello by explicitly writing out all expected components (version, random, session ID, cipher suites, compression, and extensions) into the packet. Each segment of the function is responsible for constructing a specific part of the ClientHello message, thereby ensuring the message carries all the parameters. As the function solely contains the logic for building the complete ClientHello message and advertising all the supported parameters, it fully meets the specified constraint.",success,
14167,tls_construct_client_hello,"For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS.",22,Fully Matches,"[{'C1': {'code': '/* COMPRESSION */\n    if (!WPACKET_start_sub_packet_u8(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return CON_FUNC_ERROR;\n    }\n    #ifndef OPENSSL_NO_COMP\n    if (ssl_allow_compression(s)\n            && sctx->comp_methods\n            && (SSL_CONNECTION_IS_DTLS(s)\n                || s->s3.tmp.max_ver < TLS1_3_VERSION)) {\n        int compnum = sk_SSL_COMP_num(sctx->comp_methods);\n        for (i = 0; i < compnum; i++) {\n            comp = sk_SSL_COMP_value(sctx->comp_methods, i);\n            if (!WPACKET_put_bytes_u8(pkt, comp->id)) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n                return CON_FUNC_ERROR;\n            }\n        }\n    }\n    #endif\n    /* Add the NULL method */\n    if (!WPACKET_put_bytes_u8(pkt, 0) || !WPACKET_close(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return CON_FUNC_ERROR;\n    }', 'explanation': 'This code block ensures that regardless of any optional compression methods (which are only added for pre-TLS 1.3 connections), the function always writes a single NULL compression byte. In TLS 1.3 scenarios, the conditional block is bypassed and only the NULL byte is inserted, fulfilling the TLS 1.3 RFC requirement.'}}]","The function 'tls_construct_client_hello' explicitly implements the handling of legacy_compression_methods as specified by TLS 1.3. After conditionally adding any non-null compression methods for older protocol versions, it unconditionally appends a single NULL compression byte. This guarantees that for every TLS 1.3 ClientHello, the legacy_compression_methods vector contains exactly one byte set to zero, thereby fully matching the specified RFC requirement.",success,
14167,tls_construct_client_hello,-TLS 1.2 ClientHellos MAY omit this extension.,99,Does Not Match,[],"The provided function does not contain any explicit logic that addresses the spec constraint regarding TLS 1.2 ClientHellos possibly omitting the extension or handling legacy hash/signature pairs (e.g., excluding MD5, SHA-224, and DSA). The code always calls tls_construct_extensions() without any visible version checks or conditional handling for TLS 1.2. While the surrounding context and dependency functions may consider such details, in this function body there is no direct implementation of the labeled conditions (e.g., C1, A1) from the spec.",success,
14167,tls_construct_client_hello,Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.,79,Fully Matches,"[{'C1': {'code': '/* cookie stuff for DTLS */\n    if (SSL_CONNECTION_IS_DTLS(s)) {\n        if (s->d1->cookie_len > sizeof(s->d1->cookie)\n                || !WPACKET_sub_memcpy_u8(pkt, s->d1->cookie, s->d1->cookie_len)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n            return CON_FUNC_ERROR;\n        }\n    }', 'explanation': 'The RFC requires that clients MUST NOT include cookies in their initial ClientHello for TLS. In this function, cookie logic is applied only for DTLS (inside the SSL_CONNECTION_IS_DTLS(s) check) and no cookie extension is appended for non-DTLS connections. This ensures that for TLS connections, the client does not include a cookie in its initial ClientHello.'}}]","The function explicitly performs cookie handling only for DTLS connections by checking if SSL_CONNECTION_IS_DTLS(s) is true. For TLS connections—which the spec targets—the cookie extension is not constructed. Hence, the function meets the RFC requirement that clients must not use cookies in their initial ClientHello in subsequent connections.",success,
14168,dtls_process_hello_verify,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!PACKET_forward(pkt, 2)\n    || !PACKET_get_length_prefixed_1(pkt, &cookiepkt)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': 'This portion of the code checks that the packet can be parsed (i.e. forwarding the packet pointer and fetching a length‐prefixed field). On failure it calls SSLfatal with a DECODE_ERROR alert, which meets the requirement for handling messages that cannot be parsed.'}}, {'A1': {'code': 'if (!PACKET_copy_bytes(&cookiepkt, s->d1->cookie, cookie_len)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': 'This code attempts to copy the cookie bytes from the packet. If the copy fails, it generates a decode_error alert as specified for parsing failures.'}}]","The RFC requires that peers encountering messages that cannot be parsed – for example, due to a length that extends beyond the message boundary or an out-of-range length – must terminate the connection with a decode_error alert. The function clearly implements checks for parsing issues and, upon such failures, calls SSLfatal with a decode_error alert. However, when the cookie length exceeds the available buffer (i.e. an out‐of-range condition), the function instead triggers an illegal_parameter alert. This handling of an out-of-range length does not perfectly align with the RFC specification (which suggests using a decode_error for such syntactic issues). Therefore, while the function addresses part of the requirement by handling parse failures with decode_error, it diverges on the out‐of-range length case, resulting in a partial match.",success,
14168,dtls_process_hello_verify,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (cookie_len > sizeof(s->d1->cookie)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_LENGTH_TOO_LONG);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': ""This segment checks if the cookie length is larger than the maximum allowed size. In the TLS spec, a syntactically correct but semantically invalid message (e.g., one with an out‐of-bound value) must cause the connection to be terminated with an 'illegal_parameter' alert. This code directly enforces that requirement.""}}, {'A1': {'code': 'if (!PACKET_forward(pkt, 2)\n    || !PACKET_get_length_prefixed_1(pkt, &cookiepkt)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': ""This part validates the structure and length of the incoming message. If the message cannot be parsed according to the expected syntax, it triggers a 'decode_error' alert in accordance with the TLS RFC requirement for detecting parsing errors.""}}]",The provided function implements handling of both syntactic errors (by checking packet boundaries and lengths and issuing a decode_error alert) and semantic errors (by verifying the cookie length and issuing an illegal_parameter alert if it exceeds allowed limits). These two key error conditions directly address the TLS RFC requirement that messages failing either syntactic parsing or semantic validity must result in termination with the appropriate alert.,success,
14169,set_client_ciphersuite,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'C1': {'code': 'if (c == NULL) {\n    /* unknown cipher */\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_UNKNOWN_CIPHER_RETURNED);\n    return 0;\n}\n\nif (ssl_cipher_disabled(s, c, SSL_SECOP_CIPHER_CHECK, 1)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_CIPHER_RETURNED);\n    return 0;\n}\n\n...\n\nif (i < 0) {\n    /* we did not say we would use this cipher */\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_CIPHER_RETURNED);\n    return 0;\n}\n\nif (SSL_CONNECTION_IS_TLS13(s) && s->s3.tmp.new_cipher != NULL\n        && s->s3.tmp.new_cipher->id != c->id) {\n    /* ServerHello selected a different ciphersuite to that in the HRR */\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_CIPHER_RETURNED);\n    return 0;\n}\n\nif (s->hit && (s->session->cipher_id != c->id)) {\n    if (SSL_CONNECTION_IS_TLS13(s)) {\n        const EVP_MD *md = ssl_md(sctx, c->algorithm2);\n\n        if (!ossl_assert(s->session->cipher != NULL)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n        if (md == NULL\n                || md != ssl_md(sctx, s->session->cipher->algorithm2)) {\n            SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER,\n                     SSL_R_CIPHERSUITE_DIGEST_HAS_CHANGED);\n            return 0;\n        }\n    } else {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER,\n                 SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);\n        return 0;\n    }\n}', 'explanation': ""The function checks for several conditions where the received cipher parameters are semantically invalid (unknown cipher, disabled cipher, wrong cipher returned, mismatched cipher in resumed sessions) and terminates the connection by calling SSLfatal with an 'SSL_AD_ILLEGAL_PARAMETER' alert, thus addressing the requirement to terminate on semantically invalid messages.""}}]","The function 'set_client_ciphersuite' implements several checks that result in terminating the connection with an 'illegal_parameter' alert when the negotiated cipher suite is semantically invalid. This behavior directly corresponds to the specification's requirement to terminate the connection when receiving a syntactically correct but semantically invalid message. However, the function only covers errors related to cipher selection and does not handle other error cases (e.g., decoding errors leading to a 'decode_error' alert), hence it only partially matches all aspects of the TLS RFC specification.",success,
14169,set_client_ciphersuite,"Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an ""illegal_parameter"" alert.",54,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s) && s->s3.tmp.new_cipher != NULL\n            && s->s3.tmp.new_cipher->id != c->id) {\n        /* ServerHello selected a different ciphersuite to that in the HRR */\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_CIPHER_RETURNED);\n        return 0;\n    }', 'explanation': ""This code segment directly implements the TLS RFC requirement. It checks that when operating in TLS1.3, if a previous cipher suite was set (likely from a HelloRetryRequest stored in s->s3.tmp.new_cipher), then the ServerHello must carry the same cipher suite. If there is a mismatch, it aborts the handshake by raising an 'illegal_parameter' alert.""}}]","The function 'set_client_ciphersuite' examines the cipher suite provided by the server and compares it against a previously established cipher suite (from a HelloRetryRequest) when operating in TLS 1.3. This directly satisfies the TLS RFC's mandate that the cipher suite supplied in the ServerHello must be the same as that in the HelloRetryRequest, otherwise the handshake should be aborted with an 'illegal_parameter' alert. The logic within the TLS1.3-specific branch of the code fully implements the specified constraint.",success,
14169,set_client_ciphersuite,"A client which receives a cipher suite that was not offered MUST abort the handshake with an ""illegal_parameter"" alert.",33,Fully Matches,"[{'C1': {'code': 'sk = ssl_get_ciphers_by_id(s);\ni = sk_SSL_CIPHER_find(sk, c);\nif (i < 0) {\n    /* we did not say we would use this cipher */\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_CIPHER_RETURNED);\n    return 0;\n}', 'explanation': ""This segment validates that the server-selected cipher is among those offered by the client. If it is not found in the client's list (i < 0), the function aborts the handshake with an 'illegal_parameter' alert, thus directly fulfilling the spec requirement.""}}]","The function 'set_client_ciphersuite' implements the key requirement of the TLS RFC by checking that the server-selected cipher suite is one that was offered by the client. In the case that the cipher suite is unknown or not present in the client's offered list, the function calls SSLfatal() with the SSL_AD_ILLEGAL_PARAMETER alert. This meets the spec's directive that a cipher suite not offered must lead to aborting the handshake with an 'illegal_parameter' alert.",success,
14170,tls_process_server_hello,-Handshake messages MUST NOT be interleaved with other record types.,275,Partially Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)) {\n    if (RECORD_LAYER_processed_read_pending(&s->rlayer)) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n        goto err;\n    }\n    ...\n}', 'explanation': 'This code segment in the TLSv1.3 branch verifies that no additional data (e.g. another record) is pending after processing the ServerHello, enforcing that the handshake message ends on a record boundary. This directly addresses the RFC requirement that handshake messages must not be interleaved with other record types when a key change is signaled.'}}]","The function explicitly checks for pending records in the TLSv1.3 branch with RECORD_LAYER_processed_read_pending(), which prevents interleaved records during a key change, thereby partially implementing the RFC constraint. However, similar checks are not visibly implemented for other handshake messages (e.g. in TLSv1.2), so the function only partially addresses the overall requirement that handshake messages MUST NOT be interleaved with other record types.",success,
14170,tls_process_server_hello,"That is, if a handshake message is split over two or more records, there MUST NOT be any other records between them.",276,Partially Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)) {\n    /* In TLSv1.3 a ServerHello message signals a key change so the end of\n     * the message must be on a record boundary. */\n    if (RECORD_LAYER_processed_read_pending(&s->rlayer)) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n        goto err;\n    }\n    ...\n}', 'explanation': ""This segment checks that in TLSv1.3 the ServerHello message, which signals a key change, ends on a record boundary. By calling RECORD_LAYER_processed_read_pending(&s->rlayer) and issuing an 'unexpected_message' alert if data remains, the code enforces that no additional record data (e.g. a split handshake message interleaved with other records) is present. This partially addresses the spec requirement regarding handshake messages split over multiple records.""}}]","The provided function partially implements the TLS RFC constraint by checking that, in TLSv1.3, the ServerHello message (which signals a key change) is aligned with a record boundary. This is done by verifying that no pending extra record data exists before proceeding. However, the code does not comprehensively address the more general requirement that, if a handshake message is split over two or more records, there must not be any other records between them. Therefore, only part of the spec constraint is directly enforced within this function.",success,
14170,tls_process_server_hello,"Implementations MUST verify that all messages immediately preceding a key change align with a record boundary; if not, then they MUST terminate the connection with an ""unexpected_message"" alert.",278,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)) {\n    /* In TLSv1.3 a ServerHello message signals a key change so the end of\n     * the message must be on a record boundary. */\n    if (RECORD_LAYER_processed_read_pending(&s->rlayer)) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n        goto err;\n    }\n    ...', 'explanation': 'This snippet checks that when operating in TLSv1.3, the ServerHello message (which immediately precedes a key change) ends exactly on a record boundary. If there is pending data (indicating that the message does not align with a record boundary), the function terminates the connection with an unexpected_message alert. This directly implements the spec requirement.'}}]","The function includes logic that verifies the record boundary condition for messages preceding a key change in TLSv1.3. By inspecting RECORD_LAYER_processed_read_pending(&s->rlayer) and triggering an unexpected_message alert if the condition is violated, it fully satisfies the TLS RFC specification requirement within its own code.",success,
14170,tls_process_server_hello,"Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages can immediately precede a key change, implementations MUST send these messages in alignment with a record boundary.",279,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)) {\n    /* In TLSv1.3 a ServerHello message signals a key change so the end of\n     * the message must be on a record boundary. */\n    if (RECORD_LAYER_processed_read_pending(&s->rlayer)) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n        goto err;\n    }\n}', 'explanation': 'This code snippet checks that when processing a TLS1.3 ServerHello, the message is received exactly at a record boundary (i.e. no pending record fragments). This directly implements the RFC requirement that handshake messages (including ServerHello) immediately preceding a key change must align with a record boundary.'}}]","The function tls_process_server_hello contains logic that verifies, for TLS1.3 ServerHello messages, that the message does not span or interleave with other record data by checking RECORD_LAYER_processed_read_pending. This meets the specified RFC requirement regarding record boundary alignment immediately before a key change, addressing the condition labeled as C1.",success,
14170,tls_process_server_hello,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The specified RFC requirement mandates that SSL 2.0 (SSL2) must not be negotiated, and implementations must prevent even an SSL version 2.0 compatible ClientHello. In the provided function tls_process_server_hello, there is no explicit check or rejection logic that identifies an SSL2 (or SSL2-compatible) handshake message. The function processes a server hello using a two‐byte version field (sversion) and then handles TLS 1.2 and TLS 1.3 paths, but it does not contain any visible logic that enforces the prohibition against negotiating SSL2. As such, within the function body itself, none of the labeled conditions or actions (e.g., C1, A1 if they would relate to rejecting SSL2) are implemented. Dependencies or external functions (like ssl_choose_client_version) are not considered here, so the function by itself does not fulfill the spec constraint.",success,
14170,tls_process_server_hello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2(pkt, &sversion)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n\n...\n\nif (!PACKET_get_length_prefixed_1(pkt, &session_id)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n\nif (!PACKET_get_bytes(pkt, &cipherchars, TLS_CIPHER_LEN)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n\nif (!PACKET_get_1(pkt, &compression)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n\nelse if (!PACKET_as_length_prefixed_2(pkt, &extpkt) || PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_LENGTH);\n    goto err;\n}', 'explanation': 'These code segments check various parts of the ServerHello message (such as version, session_id, cipher, and TLS extensions) and, if any parsing error occurs (e.g. a length issue or message boundary overrun), calls SSLfatal with the decode_error alert. This directly implements the RFC requirement that messages that cannot be parsed must result in a decode_error alert.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);', 'explanation': 'The function uses SSLfatal with appropriate alert code (SSL_AD_DECODE_ERROR) to terminate the connection when a parsing (syntax) error is detected, matching the RFC mandate to send a decode_error alert.'}}]","The tls_process_server_hello function performs multiple parsing validations on the received ServerHello message and immediately terminates the connection with a decode_error alert if any component (e.g. network version, session_id length, or extension lengths) is invalid. This behavior directly implements the RFC specification that any message that fails syntactic parsing must result in connection termination with a decode_error alert.",success,
14170,tls_process_server_hello,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'C1': {'code': 'if (session_id_len > sizeof(s->session->session_id)\n    || session_id_len > SSL3_SESSION_ID_SIZE) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_SSL3_SESSION_ID_TOO_LONG);\n    goto err;\n}', 'explanation': 'This code segment checks that the session_id length is within bounds. If not, it triggers an illegal_parameter alert, thereby addressing the requirement for semantically invalid parameters.'}}, {'A1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s) || hrr) {\n    if (compression != 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER,\n                 SSL_R_INVALID_COMPRESSION_ALGORITHM);\n        goto err;\n    }\n\n    if (session_id_len != s->tmp_session_id_len\n            || memcmp(PACKET_data(&session_id), s->tmp_session_id,\n                      session_id_len) != 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INVALID_SESSION_ID);\n        goto err;\n    }\n}', 'explanation': 'These segments in the TLS1.3/HRR branch trigger an illegal_parameter alert when compression is non-zero or when the session ID does not match expected values, meeting the spec requirement for handling semantically invalid parameter values.'}}]","The function contains multiple checks where, if a received message is found to be semantically invalid (e.g., an overly long session_id, a non-zero compression value, or a session_id mismatch in TLS 1.3), it terminates the connection by invoking SSLfatal with an SSL_AD_ILLEGAL_PARAMETER alert. This addresses the spec constraint that peers must terminate with an 'illegal_parameter' alert upon detection of semantically invalid messages. However, while these checks address some instances of semantic invalidity, the function does not cover all possible semantically invalid cases as exemplified by the RFC (such as a DHE share of p -1 or an invalid enum), hence it only partially matches the complete specification requirement.",success,
14170,tls_process_server_hello,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data.",320,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2(pkt, &sversion)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n\n... (multiple similar error checks calling SSLfatal(...))', 'explanation': 'The function checks for various error conditions (e.g., packet length mismatches, illegal parameters, unexpected messages) and upon detecting a fatal error, it calls SSLfatal. This behavior satisfies the condition where a fatal error is encountered.'}}, {'A1': {'code': 'SSLfatal(s, <alert_code>, <error_reason>);\n...\nerr:\n    OPENSSL_free(extensions);\n    return MSG_PROCESS_ERROR;', 'explanation': 'On encountering any fatal error, the function sends an appropriate fatal alert (via SSLfatal) and then aborts further processing by jumping to the error-handling block and returning an error status, ensuring no additional data is sent or received.'}}]","The function tls_process_server_hello implements error handling as specified by the TLS RFC. Throughout its logic, when an error condition is detected it immediately calls SSLfatal (which is responsible for sending the correct fatal alert) and then terminates further processing by going to an error path (err) that frees allocated resources and returns an error message. This directly reflects the spec’s requirement that upon a fatal error, an appropriate fatal alert is sent and the connection is terminated without further data exchange.",success,
14170,tls_process_server_hello,"If a client receives a second HelloRetryRequest in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest), it MUST abort the handshake with an ""unexpected_message"" alert.",50,Fully Matches,"[{'C1': {'code': 'if (s->hello_retry_request != SSL_HRR_NONE) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);\n    goto err;\n}', 'explanation': 'This code segment checks if a HelloRetryRequest has already been received (i.e., s->hello_retry_request is not SSL_HRR_NONE). If true, it aborts the handshake with an unexpected_message alert, which directly implements the RFC requirement that a second HelloRetryRequest must result in an abort.'}}]","The function includes a clear check for the scenario where a client receives a second HelloRetryRequest. When the condition is met, the function calls SSLfatal with the SSL_AD_UNEXPECTED_MESSAGE alert, exactly matching the specification's mandate. Thus, within the scope of this function, the TLS RFC constraint has been fully implemented.",success,
14170,tls_process_server_hello,"A client which receives a legacy_session_id_echo field that does not match what it sent in the ClientHello MUST abort the handshake with an ""illegal_parameter"" alert.",32,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s) || hrr) {\n    if (session_id_len != s->tmp_session_id_len\n            || memcmp(PACKET_data(&session_id), s->tmp_session_id,\n                      session_id_len) != 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INVALID_SESSION_ID);\n        goto err;\n    }\n}', 'explanation': 'This segment verifies that the legacy_session_id_echo (the session_id field in ServerHello) exactly matches the client’s originally sent session ID (stored in s->tmp_session_id and its length in s->tmp_session_id_len) for TLS 1.3 or during a HelloRetryRequest. On a mismatch, it aborts the handshake by calling SSLfatal with an illegal_parameter alert, thus directly implementing the spec requirement.'}}, {'C2': {'code': 'if (!PACKET_get_bytes(pkt, &cipherchars, TLS_CIPHER_LEN)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n...\nif (hrr) {\n    if (!set_client_ciphersuite(s, cipherchars)) {\n        goto err;\n    }\n    return tls_process_as_hello_retry_request(s, &extpkt);\n}\n...\nif (!set_client_ciphersuite(s, cipherchars)) {\n    goto err;\n}', 'explanation': 'This code calls set_client_ciphersuite() to validate that the received cipher suite is one that the client previously offered. If set_client_ciphersuite() fails, the handshake is aborted with an illegal_parameter alert. This satisfies the cipher_suite check mandated by the spec.'}}]","The function explicitly checks two key components mandated by the TLS RFC spec. First, it validates that the legacy_session_id_echo from the server matches the client's originally sent session ID (C1), and aborts with an illegal_parameter alert if it does not. Second, through calls to set_client_ciphersuite(), it ensures that the server’s chosen cipher suite was indeed among those offered by the client (C2), aborting the handshake if not. Both checks are implemented in the function itself, satisfying the specified RFC requirements.",success,
14170,tls_process_server_hello,"For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS.",22,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s) || hrr) {\n    if (compression != 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER,\n                 SSL_R_INVALID_COMPRESSION_ALGORITHM);\n        goto err;\n    }\n}', 'explanation': ""This segment ensures that when the connection is TLS1.3 (or a Hello Retry Request is in progress), the legacy_compression_methods field (accessed via the 'compression' variable) is exactly 0. This directly implements the RFC requirement that for every TLS 1.3 ClientHello (and by implication, ServerHello), the compression vector must contain one byte set to zero.""}}]","The function explicitly checks the compression method value when processing a TLS1.3 ServerHello (or HRR) and triggers an error if the value is not 0. This meets the specified constraint from the TLS 1.3 RFC regarding the legacy_compression_methods field, thereby fully matching the requirement stated in the spec.",success,
14170,tls_process_server_hello,"If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST abort the handshake with an ""illegal_parameter"" alert.",23,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s) || hrr) {\n    if (compression != 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INVALID_COMPRESSION_ALGORITHM);\n        goto err;\n    }\n}', 'explanation': ""This code segment checks that when processing a TLS 1.3 (or HRR) ServerHello, the legacy_compression_methods field (represented by 'compression') has a value of 0. If not, it aborts the handshake with an 'illegal_parameter' alert as required by the RFC.""}}]","The function explicitly implements the RFC requirement by inspecting the compression field after processing the ServerHello. It verifies for TLS 1.3 connections that the legacy_compression_methods field is exactly a 'null' (i.e., value 0) compression method. In the case of any other value, it calls SSLfatal to abort the handshake, thus fully implementing the specified constraint within the function body.",success,
14170,tls_process_server_hello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The provided function tls_process_server_hello processes the ServerHello message. The RFC specification in question focuses on the ordering of extensions in the ClientHello (specifically that pre_shared_key MUST be the last extension when present) and the non-duplication of extensions. In this function, no explicit logic is visible that enforces any ordering of the pre_shared_key extension because that ordering rule is only applicable to the ClientHello message. Instead, this function delegates extension collection and parsing via calls such as tls_collect_extensions and tls_parse_all_extensions without directly checking the order of extensions. Thus, within the body of this function there is no code addressing the specific spec constraint regarding extension ordering (or duplicate detection) as required by the RFC. Dependencies and helper functions are not considered here, so the function does not, by itself, implement the referenced TLS RFC requirement.",success,
14171,tls_process_as_hello_retry_request,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function processes the HelloRetryRequest message and handles generic TLS 1.3 handshake steps such as extension collection, synthetic message hash creation, and transcript update. However, it does not contain any logic that addresses the specific TLS 1.3 requirement regarding the status_request_v2 extension (i.e. TLS 1.3 servers MUST NOT send the status_request_v2 extension in EncryptedExtensions, CertificateRequest, or Certificate messages). There is no code in the target function that checks for, ignores, or blocks the status_request_v2 extension, so it does not visibly implement the relevant spec constraints.",success,
14171,tls_process_as_hello_retry_request,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Does Not Match,[],"The provided function is concerned with processing a TLS 1.3 Hello Retry Request, specifically setting the record layer to TLS 1.3 and managing TLS 1.3 specific extensions and handshake state. There is no explicit logic within this function addressing the prohibition of SSL 3.0 (or ensuring that SSL 3.0 is not negotiated), which is the core requirement of the RFC specification. Therefore, the function does not visibly implement any condition (e.g., C1) or action (e.g., A1) related to disallowing SSL 3.0 as outlined in the spec.",success,
14171,tls_process_as_hello_retry_request,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function tls_process_as_hello_retry_request does not contain any code addressing the RFC requirement to not offer or negotiate RC4 cipher suites. The function primarily handles TLS 1.3 hello retry request processing, including early data state management, transcript hash reinitialization, extension parsing, and key share or cookie checking. There is no visible logic that inspects, filters, or prevents the use of RC4 cipher suites. Therefore, this function does not implement any of the labeled spec constraints regarding RC4 as described in the RFC specification.",success,
14171,tls_process_as_hello_retry_request,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (s->ext.tls13_cookie_len == 0 && s->s3.tmp.pkey != NULL) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_NO_CHANGE_FOLLOWING_HRR);\n        goto err;\n    }', 'explanation': ""This segment checks that in the absence of a TLS 1.3 cookie (and with an existing key share), the message is treated as semantically invalid and terminates the connection with an 'illegal_parameter' alert, in line with the RFC requirement.""}}]","The RFC specifies that when a peer receives a semantically invalid message, it must terminate the connection with an 'illegal_parameter' alert. Within tls_process_as_hello_retry_request, there is a specific check for an HRR message condition where no cookie is provided despite the presence of a key share. In such a case, the function calls SSLfatal with the SSL_AD_ILLEGAL_PARAMETER alert, fulfilling that particular requirement. Note however that while this code segment addresses one explicit instance of the RFC constraint, it does not cover other potential syntactically correct but semantically invalid cases (for example, invalid enums or DHE share values), with such logic likely handled elsewhere. Thus, the implementation partially matches the overall RFC specification.",success,
14171,tls_process_as_hello_retry_request,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function 'tls_process_as_hello_retry_request' does not contain any logic that directly enforces or verifies that Application Data is not sent before the Finished message is transmitted. The function is focused on processing the Hello Retry Request, handling early data state and updating the transcript hash, but it does not implement checks or actions to prevent application data from being sent prior to the Finished message. Thus, it does not visibly address the spec constraint (e.g., C1: ""Application Data MUST NOT be sent prior to sending Finished"") within its own code.",success,
14171,tls_process_as_hello_retry_request,"Clients MUST abort the handshake with an ""illegal_parameter"" alert if the HelloRetryRequest would not result in any change in the ClientHello.",49,Fully Matches,"[{'C1': {'code': ""if (s->ext.tls13_cookie_len == 0 && s->s3.tmp.pkey != NULL) {\n    /* We didn't receive a cookie or a new key_share so the next\n     * ClientHello will not change\n     */\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_NO_CHANGE_FOLLOWING_HRR);\n    goto err;\n}"", 'explanation': ""This segment directly implements the RFC requirement: if the HelloRetryRequest would not result in a change in the ClientHello (indicated by the absence of a cookie and the presence of a previous key share), the handshake is aborted with an 'illegal_parameter' alert.""}}]","The function inspects the received HelloRetryRequest to determine if it would lead to any changes in the resulting ClientHello. By checking that no cookie was provided and a key share already exists, it correctly aborts the handshake with an 'illegal_parameter' alert as mandated by the TLS RFC. All required logic to enforce this specific constraint is contained within the function, thereby fully matching the specified requirement.",success,
14171,tls_process_as_hello_retry_request,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function does not contain any logic that explicitly handles the supported_groups extension as specified in the RFC. The RFC requires that clients must not act upon supported_groups information until after a successful handshake, and may later use it to influence the groups in the key_share extension in future connections. The code only performs generic extension collection and parsing (via tls_collect_extensions and tls_parse_all_extensions) without any dedicated handling or conditional logic for supported_groups. There is no indication within this function that it implements the specific conditions or actions mandated by the RFC.",success,
14172,tls_process_server_rpk,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'A1': {'code': 'if (peer_rpk == NULL) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_CERTIFICATE);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': 'This code segment checks if the result of parsing (peer_rpk) is NULL, and if so, it calls SSLfatal with SSL_AD_DECODE_ERROR (indicating a decode_error alert) and terminates processing. This directly implements the RFC requirement to terminate the connection with a decode_error alert when a message cannot be parsed.'}}]","The function tls_process_server_rpk calls tls_process_rpk to perform parsing and then verifies whether the parsing result (peer_rpk) is valid. If tls_process_rpk fails or returns a NULL peer_rpk, the function ensures a decode_error alert is sent by calling SSLfatal with SSL_AD_DECODE_ERROR. This visible logic within the function addresses the RFC requirement that a message which cannot be parsed must result in the connection being terminated with a decode_error alert. Note that although further parsing logic might be handled in dependency functions, the required behavior is explicitly implemented in this function.",success,
14172,tls_process_server_rpk,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'C1': {'code': 'if (peer_rpk == NULL) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_CERTIFICATE);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': 'This segment detects a fatal error condition (missing peer public key) and sends a fatal alert (using SSL_AD_DECODE_ERROR) in accordance with the spec’s mandate to send a specific alert when terminating the connection. However, the function relies on tls_process_rpk() to handle its own error alert, so the alert‐sending logic is split across functions.'}}]","The function visibly implements part of the TLS error handling requirement by detecting a fatal error condition and invoking SSLfatal to send an appropriate alert when peer_rpk is NULL. Similarly, in the tls_process_rpk() call it relies on that function to already have sent a fatal alert if an error occurs. Thus, while it does address the alert‐sending requirement in some cases (i.e. condition C1), not all aspects (for example, explicit connection closure logic) are handled solely within this function. Therefore, it only partially matches the constraints as specified.",success,
14173,tls_post_process_server_rpk,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Partially Matches,"[{'C1': {'code': 'if (sc->session->peer_rpk == NULL) {\n    SSLfatal(sc, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INVALID_RAW_PUBLIC_KEY);\n    return WORK_ERROR;\n}\n...\nif ((clu = ssl_cert_lookup_by_pkey(sc->session->peer_rpk, &certidx, SSL_CONNECTION_GET_CTX(sc))) == NULL) {\n    SSLfatal(sc, SSL_AD_ILLEGAL_PARAMETER, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    return WORK_ERROR;\n}\n...\nif (!SSL_CONNECTION_IS_TLS13(sc)) {\n    if ((clu->amask & sc->s3.tmp.new_cipher->algorithm_auth) == 0) {\n        SSLfatal(sc, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_RPK_TYPE);\n        return WORK_ERROR;\n    }\n}', 'explanation': ""These segments invoke SSLfatal with alert codes that are designated as error alerts. Implicitly, SSLfatal is expected to send alerts with AlertLevel=fatal, which addresses the RFC's requirement for outgoing alerts.""}}, {'A1': {'code': 'if (v_ok <= 0 && sc->verify_mode != SSL_VERIFY_NONE) {\n    ERR_clear_last_mark();\n    SSLfatal(sc, ssl_x509err2alert(sc->verify_result), SSL_R_CERTIFICATE_VERIFY_FAILED);\n    return WORK_ERROR;\n}', 'explanation': 'This segment handles certificate verification failures by calling SSLfatal with an alert generated from the verification result, again implying use of a fatal alert as required by the specification.'}}]","The function implements error handling by invoking SSLfatal in various error scenarios, such as a missing raw public key, lookup failures in certificate types, and failed certificate verification. These calls suggest that the alerts are sent as fatal, fulfilling part of the RFC’s requirement that error alerts be sent with AlertLevel=fatal. However, the function does not address the receiving end of error alerts or verify that every possible alert is sent with the fatal level directly within its logic. As a result, while important aspects of the RFC regarding error alert handling are partially implemented here, the overall specification is only partially met by this function in isolation.",success,
14173,tls_post_process_server_rpk,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Partially Matches,"[{'A1': {'code': 'if (sc->session->peer_rpk == NULL) {\n    SSLfatal(sc, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INVALID_RAW_PUBLIC_KEY);\n    return WORK_ERROR;\n}', 'explanation': 'When the raw public key is missing, the function sends a fatal alert (SSL_AD_ILLEGAL_PARAMETER) using SSLfatal and returns an error state. This is in line with the requirement to send an alert upon detecting a fatal error.'}}, {'A1': {'code': 'if (v_ok <= 0 && sc->verify_mode != SSL_VERIFY_NONE) {\n    ERR_clear_last_mark();\n    SSLfatal(sc, ssl_x509err2alert(sc->verify_result), SSL_R_CERTIFICATE_VERIFY_FAILED);\n    return WORK_ERROR;\n}', 'explanation': 'If certificate (or raw public key) verification fails, the function sends an appropriate fatal alert. This meets the spec’s action of sending a fatal alert when an error is detected.'}}, {'A1': {'code': 'if ((clu = ssl_cert_lookup_by_pkey(sc->session->peer_rpk, &certidx, SSL_CONNECTION_GET_CTX(sc))) == NULL) {\n    SSLfatal(sc, SSL_AD_ILLEGAL_PARAMETER, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    return WORK_ERROR;\n}', 'explanation': 'The code checks that a matching certificate lookup is successful; if not, it sends a fatal alert indicating an unknown certificate type.'}}, {'A1': {'code': 'if (!SSL_CONNECTION_IS_TLS13(sc)) {\n    if ((clu->amask & sc->s3.tmp.new_cipher->algorithm_auth) == 0) {\n        SSLfatal(sc, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_RPK_TYPE);\n        return WORK_ERROR;\n    }\n}', 'explanation': 'For non-TLS1.3 connections, the function ensures that the certificate type matches the requirements of the cipher suite. Upon failure, it sends an alert as required by the spec.'}}]","The function implements error detection by checking for a missing raw public key, failed verification, an unknown certificate type, and inappropriate certificate type relative to the cipher suite. In each error condition, it calls SSLfatal to send a fatal alert and returns an error state. This meets the TLS specification’s directive to send fatal alerts when errors are detected. However, while the function clearly sends alerts (thus covering the alert transmission part of the spec), it does not explicitly demonstrate the immediate closure of the connection, which is also an essential part of the RFC error handling requirements. Because the connection termination logic may be delegated to the caller or dependent on the returned error value, the function only partially addresses the full scope of the specification.",success,
14173,tls_post_process_server_rpk,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, tls_post_process_server_rpk, is focused on the processing and verification of raw public keys and certificate types, not on the selection or negotiation of cipher suites. There is no evidence in the code of any checks to ensure that RC4 cipher suites are neither offered nor negotiated. Therefore, none of the specified constraints (e.g., enforcing that RC4 is not allowed) are implemented within this function.",success,
14173,tls_post_process_server_rpk,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (sc->session->peer_rpk == NULL) {\n    SSLfatal(sc, SSL_AD_ILLEGAL_PARAMETER,\n             SSL_R_INVALID_RAW_PUBLIC_KEY);\n    return WORK_ERROR;\n}', 'explanation': 'This block checks if the received raw public key is missing—which qualifies as a semantically invalid parameter—and immediately terminates the connection using an illegal_parameter alert.'}}, {'C2': {'code': 'if ((clu = ssl_cert_lookup_by_pkey(sc->session->peer_rpk, &certidx,\n                                       SSL_CONNECTION_GET_CTX(sc))) == NULL) {\n    SSLfatal(sc, SSL_AD_ILLEGAL_PARAMETER, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    return WORK_ERROR;\n}', 'explanation': 'This segment verifies that the certificate type corresponding to the public key is known. If the lookup fails, it signals a semantic error by issuing an illegal_parameter alert.'}}, {'C3': {'code': 'if (!SSL_CONNECTION_IS_TLS13(sc)) {\n    if ((clu->amask & sc->s3.tmp.new_cipher->algorithm_auth) == 0) {\n        SSLfatal(sc, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_RPK_TYPE);\n        return WORK_ERROR;\n    }\n}', 'explanation': 'For non-TLS1.3 connections, this check ensures that the certificate type (or RPK type) is consistent with the ciphersuite expectations. A mismatch immediately triggers an illegal_parameter alert, reflecting a semantic error.'}}]","The function explicitly implements the TLS RFC requirement for handling semantically invalid messages. In three distinct cases (null raw public key, unknown certificate type, and certificate type mismatch), the function calls SSLfatal with the alert type SSL_AD_ILLEGAL_PARAMETER and then terminates the connection by returning an error. Thus, the function visibly addresses the specified condition from the RFC that peers must terminate the connection with an illegal_parameter alert when they receive a syntactically correct but semantically invalid message.",success,
14173,tls_post_process_server_rpk,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Fully Matches,"[{'C1': {'code': 'if (sc->session->peer_rpk == NULL) {\n    SSLfatal(sc, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INVALID_RAW_PUBLIC_KEY);\n    return WORK_ERROR;\n}', 'explanation': 'This segment checks whether the raw public key (peer_rpk) is present and, if not, calls SSLfatal with an appropriate fatal alert code, meeting the spec requirement to send an alert when terminating the connection due to an error.'}}, {'A1': {'code': 'if (v_ok <= 0 && sc->verify_mode != SSL_VERIFY_NONE) {\n    ERR_clear_last_mark();\n    SSLfatal(sc, ssl_x509err2alert(sc->verify_result), SSL_R_CERTIFICATE_VERIFY_FAILED);\n    return WORK_ERROR;\n}', 'explanation': 'This segment handles a verification failure by sending a fatal alert (using ssl_x509err2alert to determine the specific alert) and then returning an error state. This addresses the spec requirement to abort the handshake with the specified alert when a fatal error is detected.'}}, {'A2': {'code': 'if ((clu = ssl_cert_lookup_by_pkey(sc->session->peer_rpk, &certidx, SSL_CONNECTION_GET_CTX(sc))) == NULL) {\n    SSLfatal(sc, SSL_AD_ILLEGAL_PARAMETER, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    return WORK_ERROR;\n}', 'explanation': 'This part verifies that the certificate type is recognized; if not, it sends a fatal alert as required by the RFC when an error condition is encountered.'}}, {'A3': {'code': 'if (!SSL_CONNECTION_IS_TLS13(sc)) {\n    if ((clu->amask & sc->s3.tmp.new_cipher->algorithm_auth) == 0) {\n        SSLfatal(sc, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_RPK_TYPE);\n        return WORK_ERROR;\n    }\n}', 'explanation': 'This segment checks the consistency between the certificate type and the ciphersuite. In case of mismatch (for non-TLS13 connections), it sends a fatal alert, thereby ensuring the handshake is aborted with an explicit fatal signal.'}}]","The function implements error handling in line with the TLS RFC by checking for fatal error conditions and, upon detecting them, immediately invoking SSLfatal to send the appropriate alert and returning an error state. Each error path explicitly sends an alert, which satisfies the spec requirement to 'terminate the connection with an X alert' or 'abort the handshake with an X alert' if any error is encountered. All logic addressing these conditions is contained within the function, independent of its dependencies.",success,
14173,tls_post_process_server_rpk,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The TLS RFC specification constraint requires that Application Data MUST NOT be sent before the Finished message is transmitted. This function, tls_post_process_server_rpk, is focused solely on post-processing the server's raw public key (RPK) including verifying the RPK, checking certificate type consistency, and setting up the handshake state (e.g., by saving the hash state for the upcoming CertificateVerify). There is no logic within this function that addresses or enforces the proper ordering of sending the Finished message prior to any Application Data. As a result, the code function does not visibly address the specified RFC constraint.",success,
14174,tls_process_server_certificate,"If the server supplies an empty Certificate message, the client MUST abort the handshake with a ""decode_error"" alert.",217,Fully Matches,"[{'C1': {'code': 'if ((SSL_CONNECTION_IS_TLS13(s) && !PACKET_get_1(pkt, &context))\n        || context != 0\n        || !PACKET_get_net_3(pkt, &cert_list_len)\n        || PACKET_remaining(pkt) != cert_list_len\n        || PACKET_remaining(pkt) == 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}', 'explanation': ""This code explicitly checks if the remaining data in the packet (i.e. the certificate chain) is empty. According to the RFC, if the server supplies an empty Certificate message, the client must abort with a decode_error alert. The condition 'PACKET_remaining(pkt) == 0' triggers the error handling via SSLfatal with the alert SSL_AD_DECODE_ERROR.""}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);', 'explanation': 'When the certificate message is empty, the function calls SSLfatal with the decode_error alert, which meets the RFC requirement to abort the handshake in such a case.'}}]",The function 'tls_process_server_certificate' directly implements the TLS RFC requirement regarding an empty Certificate message by checking if the certificate data is empty (using PACKET_remaining(pkt) == 0) and subsequently aborting the handshake with a 'decode_error' alert via SSLfatal. This visible logic within the function fulfills both the condition and the corresponding action as specified by the RFC.,success,
14174,tls_process_server_certificate,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Fully Matches,"[{'C1': {'code': 'if (s->ext.server_cert_type != TLSEXT_cert_type_x509) {\n    SSLfatal(s, SSL_AD_UNSUPPORTED_CERTIFICATE, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    goto err;\n}', 'explanation': 'The RFC requires that the OpenPGP certificate type MUST NOT be used with TLS 1.3. In this function, only raw public keys and x509 certificates are accepted. The early check first routes raw public keys to a dedicated handler, and then any certificate type not equal to x509 (which includes OpenPGP) results in an error. This logic in the function itself ensures that OpenPGP certificates (or any non‐x509 certificate) are rejected, thereby satisfying the RFC specification.'}}]","The function inspects the negotiated certificate type in its beginning logic. It explicitly handles raw public key certificates (by calling a separate handler) and then rejects any type that is not an x509 certificate using an error. This inherent check prevents the use of OpenPGP certificates with TLS 1.3, as required by RFC6091. Since the rejection is enacted directly within this function, it fully addresses the specified constraint.",success,
14174,tls_process_server_certificate,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Fully Matches,"[{'C1': {'code': 'if (s->ext.server_cert_type != TLSEXT_cert_type_x509) {\n    SSLfatal(s, SSL_AD_UNSUPPORTED_CERTIFICATE, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    goto err;\n}\n\nif ((SSL_CONNECTION_IS_TLS13(s) && !PACKET_get_1(pkt, &context))\n        || context != 0\n        || !PACKET_get_net_3(pkt, &cert_list_len)\n        || PACKET_remaining(pkt) != cert_list_len\n        || PACKET_remaining(pkt) == 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n\nif (!PACKET_get_net_3(pkt, &cert_len) || !PACKET_get_bytes(pkt, &certbytes, cert_len)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_CERT_LENGTH_MISMATCH);\n    goto err;\n}\n\nif (x == NULL) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, ERR_R_ASN1_LIB);\n    goto err;\n}\n\nif (d2i_X509(&x, (const unsigned char **)&certbytes, cert_len) == NULL) {\n    SSLfatal(s, SSL_AD_BAD_CERTIFICATE, ERR_R_ASN1_LIB);\n    goto err;\n}\n\nif (certbytes != (certstart + cert_len)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_CERT_LENGTH_MISMATCH);\n    goto err;\n}\n\nif (!PACKET_get_length_prefixed_2(pkt, &extensions)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_LENGTH);\n    goto err;\n}', 'explanation': 'Multiple conditions detecting errors in the certificate parsing (e.g., unsupported certificate type, length mismatches, decode errors) call SSLfatal with a specific alert code. This satisfies the condition that if an error is detected, the implementation MUST send the appropriate fatal alert X.'}}, {'A1': {'code': 'SSLfatal(s, <alert_code>, <error_reason>);', 'explanation': 'In each error branch, the function issues an alert via SSLfatal with a specific alert code such as SSL_AD_UNSUPPORTED_CERTIFICATE, SSL_AD_DECODE_ERROR, or SSL_AD_BAD_CERTIFICATE, thereby ensuring that a fatal alert is sent when an error is encountered, just as the TLS RFC mandates when aborting the handshake or terminating the connection.'}}]","The function tls_process_server_certificate implements error handling in accordance with the TLS RFC specification. For every detected error condition (including various parsing and length issues), the function calls SSLfatal with a specific alert code. This behavior demonstrates that if the function sends any alert, it sends alert X appropriate to the error condition. Although the actual connection termination is handled elsewhere (likely by the caller in response to the returned error), the logic within this function visibly addresses the requirement to send fatal alerts as specified. Hence, the function fully matches the spec's constraints.",success,
14174,tls_process_server_certificate,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Partially Matches,"[{'A1': {'code': 'if (s->ext.server_cert_type != TLSEXT_cert_type_x509) {\n    SSLfatal(s, SSL_AD_UNSUPPORTED_CERTIFICATE, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    goto err;\n}\n\n...\n\nif ((SSL_CONNECTION_IS_TLS13(s) && !PACKET_get_1(pkt, &context))\n        || context != 0\n        || !PACKET_get_net_3(pkt, &cert_list_len)\n        || PACKET_remaining(pkt) != cert_list_len\n        || PACKET_remaining(pkt) == 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n\n...\n\nif (!PACKET_get_net_3(pkt, &cert_len)\n    || !PACKET_get_bytes(pkt, &certbytes, cert_len)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_CERT_LENGTH_MISMATCH);\n    goto err;\n}\n\n...\n\nif (x == NULL) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, ERR_R_ASN1_LIB);\n    goto err;\n}\n\nif (d2i_X509(&x, (const unsigned char **)&certbytes, cert_len) == NULL) {\n    SSLfatal(s, SSL_AD_BAD_CERTIFICATE, ERR_R_ASN1_LIB);\n    goto err;\n}\n\nif (certbytes != (certstart + cert_len)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_CERT_LENGTH_MISMATCH);\n    goto err;\n}\n\nif (!PACKET_get_length_prefixed_2(pkt, &extensions)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_LENGTH);\n    goto err;\n}', 'explanation': ""The function uses multiple calls to SSLfatal to send fatal alerts when error conditions are detected (e.g., unsupported certificate type, decoding errors, length mismatches, ASN1 parsing errors). This demonstrates an explicit attempt to follow the spec's requirement to send an appropriate fatal alert. However, the function does not itself perform connection termination, which is mandated by the RFC.""}}]","The function_body actively checks for several error conditions related to server certificate processing and sends fatal alerts via SSLfatal when errors occur. This behavior addresses the spec constraint requiring that, upon detecting a fatal error, an alert should be sent. However, while the spec mandates that the connection be immediately terminated after a fatal alert, the function only proceeds to an error label (which cleans up resources) and returns an error code, without explicitly closing the connection. This indicates that connection termination likely depends on the upper layer logic, meaning that within the confines of this function alone the RFC is only partially implemented.",success,
14174,tls_process_server_certificate,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Partially Matches,"[{'C1': {'code': 'if (s->ext.server_cert_type != TLSEXT_cert_type_x509) {\n    SSLfatal(s, SSL_AD_UNSUPPORTED_CERTIFICATE, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    goto err;\n}\n\n...\n\nif ((SSL_CONNECTION_IS_TLS13(s) && !PACKET_get_1(pkt, &context)) || context != 0 || ... ) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n\n...\n\nif (!PACKET_get_bytes(pkt, &certbytes, cert_len)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_CERT_LENGTH_MISMATCH);\n    goto err;\n}\n\n...\n\nif (d2i_X509(&x, (const unsigned char **)&certbytes, cert_len) == NULL) {\n    SSLfatal(s, SSL_AD_BAD_CERTIFICATE, ERR_R_ASN1_LIB);\n    goto err;\n}', 'explanation': 'Throughout the function, whenever an error or an inconsistency in the certificate message is detected, the code calls SSLfatal with an alert code (e.g. SSL_AD_DECODE_ERROR or SSL_AD_BAD_CERTIFICATE). This indicates that the function intends to signal these errors as fatal alerts, which is in line with the RFC requirement that alerts be sent with AlertLevel=fatal. However, the function only handles error conditions during certificate processing and does not address how to treat incoming alerts or unknown alert types, leaving aspects of the specification unhandled within this function.'}}]","The function implements error handling during the processing of server certificates by calling SSLfatal for various error conditions. This mechanism suggests that any error detected during the handshake will result in a fatal alert being sent, which partially meets the RFC specification that all alerts must be sent with AlertLevel=fatal and be treated as error alerts. However, the function does not cover the aspect of processing incoming alerts or reinterpreting the AlertLevel contained in received messages. Therefore, while the error signaling is implemented, it only partially addresses the entire spec constraint.",success,
14174,tls_process_server_certificate,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if ((SSL_CONNECTION_IS_TLS13(s) && !PACKET_get_1(pkt, &context))\n        || context != 0\n        || !PACKET_get_net_3(pkt, &cert_list_len)\n        || PACKET_remaining(pkt) != cert_list_len\n        || PACKET_remaining(pkt) == 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}', 'explanation': 'This code segment verifies that the received message has the correct syntax and length. It checks for conditions such as an unexpected ‘context’ value, mismatched certificate list length, or extra data beyond the expected boundary. If any of these conditions are violated, it triggers a decode_error alert.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);', 'explanation': ""When the packet parsing fails (due to syntax or length errors), the function calls SSLfatal with the decode_error alert. This directly implements the action of terminating the connection with a 'decode_error' alert as mandated by the RFC.""}}]",The function implements checks to validate the structure and length of the certificate message and terminates the connection by invoking SSLfatal with SSL_AD_DECODE_ERROR when parsing failures occur. This matches the RFC requirement that a peer must terminate the connection with a 'decode_error' alert if a message cannot be parsed according to the syntax. All of the logic addressing this constraint exists within the function itself.,success,
14175,tls_post_process_server_certificate,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Partially Matches,"[{'C1': {'code': 'if (i <= 0 && s->verify_mode != SSL_VERIFY_NONE) {\n    ERR_clear_last_mark();\n    SSLfatal(s, ssl_x509err2alert(s->verify_result), SSL_R_CERTIFICATE_VERIFY_FAILED);\n    return WORK_ERROR;\n}', 'explanation': 'This segment checks the result of the certificate verification and, upon failure (and when verification is enabled), calls SSLfatal with a certificate verification failure alert. This corresponds to the requirement that upon detecting a fatal error an appropriate alert be sent.'}}, {'A1': {'code': 'SSLfatal(s, <alert_code>, <error_identifier>);', 'explanation': 'Throughout the function, several error conditions (such as missing public key, unknown certificate type, certificate type mismatch, etc.) lead to an immediate call to SSLfatal. This demonstrates that the function attempts to send fatal alerts in error cases as specified by the RFC.'}}]","The function tls_post_process_server_certificate contains several explicit checks for error conditions (for example, certificate verification failure, missing public key parameters, and certificate type mismatches) and immediately calls SSLfatal with an appropriate alert code upon failure. This behavior aligns with the part of the TLS RFC that mandates that upon detection of a fatal error the implementation should send an appropriate fatal alert and then terminate the handshake. However, while the function calls SSLfatal to send alerts, it leaves connection termination to that helper function (and does not itself explicitly close the connection or log the alerts), which is part of the broader spec requirements. Therefore, in isolation the function partially meets the spec constraints by handling error detection and alert-sending but does not show all aspects (such as explicit connection teardown and logging) required by the RFC.",success,
14175,tls_post_process_server_certificate,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data.",320,Partially Matches,"[{'A1': {'code': 'if (i <= 0 && s->verify_mode != SSL_VERIFY_NONE) {\n    ERR_clear_last_mark();\n    SSLfatal(s, ssl_x509err2alert(s->verify_result),\n             SSL_R_CERTIFICATE_VERIFY_FAILED);\n    return WORK_ERROR;\n}\n\n...\n\nif (pkey == NULL || EVP_PKEY_missing_parameters(pkey)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n             SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);\n    return WORK_ERROR;\n}\n\nif ((clu = ssl_cert_lookup_by_pkey(pkey, &certidx, SSL_CONNECTION_GET_CTX(s))) == NULL) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    return WORK_ERROR;\n}\n\n...\n\nif (!X509_up_ref(x)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return WORK_ERROR;\n}\n\nif (SSL_CONNECTION_IS_TLS13(s) && !ssl_handshake_hash(s, s->cert_verify_hash, sizeof(s->cert_verify_hash), &s->cert_verify_hash_len)) {\n    /* SSLfatal() already called */;\n    return WORK_ERROR;\n}', 'explanation': 'The function handles several fatal error conditions by calling SSLfatal() with an appropriate alert code. This reflects the requirement to send a fatal alert upon encountering an error.'}}]","The provided function includes multiple checks for fatal errors (such as certificate verification failure, missing public key parameters, an unknown certificate type, or failure to update the handshake hash) and calls SSLfatal() in response. This demonstrates that the function attempts to send an appropriate fatal alert when errors are detected (meeting spec action A1). However, the function does not explicitly close the connection itself (the 'MUST close the connection without sending or receiving any additional data' part of the specification), likely deferring that responsibility to higher-level code. Since the function only partially addresses the TLS error handling requirement on its own, the overall matching judgment is 'Partially Matches'.",success,
14175,tls_post_process_server_certificate,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'C1': {'code': 'if ((clu = ssl_cert_lookup_by_pkey(pkey, &certidx, SSL_CONNECTION_GET_CTX(s))) == NULL) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    return WORK_ERROR;\n}\n\nif (!SSL_CONNECTION_IS_TLS13(s)) {\n    if ((clu->amask & s->s3.tmp.new_cipher->algorithm_auth) == 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_CERTIFICATE_TYPE);\n        return WORK_ERROR;\n    }\n}', 'explanation': ""The code checks for semantically invalid conditions when processing the server certificate. In particular, if the certificate’s associated lookup fails or if the certificate type does not match what the cipher suite requires (for TLS versions below 1.3), the function terminates the connection by calling SSLfatal with an 'illegal_parameter' alert. This aligns with the RFC requirement for terminating upon receiving a semantically invalid message. However, the function only addresses certificate‐related semantic invalidity and does not cover all possible semantically invalid cases, hence it only partially meets the overall spec constraint.""}}]","The function implements checks that terminate the connection with an 'illegal_parameter' alert for certain semantically invalid conditions (e.g., certificate type mismatches and unknown certificate types). This behavior is in line with the RFC constraint that peers must terminate the connection upon receiving a syntactically correct but semantically invalid message. However, because the implementation covers only some specific semantic invalidity cases and not the full set of conditions described in the RFC (such as other invalid enums or malformed DHE share values), the implementation only partially matches the spec constraints.",success,
14175,tls_post_process_server_certificate,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Partially Matches,"[{'C1': {'code': 'if (i <= 0 && s->verify_mode != SSL_VERIFY_NONE) {\n    ERR_clear_last_mark();\n    SSLfatal(s, ssl_x509err2alert(s->verify_result),\n             SSL_R_CERTIFICATE_VERIFY_FAILED);\n    return WORK_ERROR;\n}\n...\nif (pkey == NULL || EVP_PKEY_missing_parameters(pkey)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n             SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);\n    return WORK_ERROR;\n}\n...\nif ((clu = ssl_cert_lookup_by_pkey(pkey, &certidx, SSL_CONNECTION_GET_CTX(s))) == NULL) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    return WORK_ERROR;\n}\n...\nif ((clu->amask & s->s3.tmp.new_cipher->algorithm_auth) == 0) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_CERTIFICATE_TYPE);\n    return WORK_ERROR;\n}\n...\nif (!X509_up_ref(x)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return WORK_ERROR;\n}', 'explanation': 'The function handles various error scenarios by calling SSLfatal with alerts such as SSL_AD_INTERNAL_ERROR and SSL_AD_ILLEGAL_PARAMETER. These calls indicate an intent to send fatal alerts as mandated by the spec (i.e. error alerts must be treated as fatal).'}}]","The TLS server certificate post-processing function uses error-handling via SSLfatal for multiple failure conditions, which implies that it attempts to trigger fatal alerts as required by the TLS RFC regarding error alerts. However, the function does not explicitly perform all aspects of the spec constraints (for example, it does not itself enforce connection termination or key erasure upon these alerts) and may rely on other parts of the system to fully satisfy the RFC. Therefore, while the function visibly addresses some parts of the constraint (sending fatal alerts on errors), it only partially matches the complete set of spec requirements.",success,
14175,tls_post_process_server_certificate,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'C1': {'code': 'if (i <= 0 && s->verify_mode != SSL_VERIFY_NONE) {\n    ERR_clear_last_mark();\n    SSLfatal(s, ssl_x509err2alert(s->verify_result), SSL_R_CERTIFICATE_VERIFY_FAILED);\n    return WORK_ERROR;\n}\n\n...\n\nif (pkey == NULL || EVP_PKEY_missing_parameters(pkey)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);\n    return WORK_ERROR;\n}\n\nif ((clu = ssl_cert_lookup_by_pkey(pkey, &certidx, SSL_CONNECTION_GET_CTX(s))) == NULL) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n    return WORK_ERROR;\n}\n\nif (!SSL_CONNECTION_IS_TLS13(s)) {\n    if ((clu->amask & s->s3.tmp.new_cipher->algorithm_auth) == 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_CERTIFICATE_TYPE);\n        return WORK_ERROR;\n    }\n}\n\nif (!X509_up_ref(x)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return WORK_ERROR;\n}', 'explanation': 'The function detects various fatal error conditions (e.g. during certificate verification, public key extraction, and certificate type consistency checks) and calls SSLfatal with a specific alert value. This satisfies the requirement to send an alert when an error occurs, as stated by the spec phrases regarding terminating the connection or aborting the handshake with an X alert.'}}]","The function implements the alert-sending part of the TLS error handling specification by invoking SSLfatal with appropriate alert codes on error conditions. This is in line with the spec requirement that a fatal error should trigger sending an alert. However, while the spec mandates that the connection must be immediately closed upon such a fatal error, this function only returns an error state (WORK_ERROR) and does not itself close the connection. Terminating the connection is likely handled elsewhere (in a caller or dependency). Thus, while the alert sending logic is correctly implemented within this function, the immediate connection closure stipulated by the RFC is not directly visible here, resulting in a partial match.",success,
14177,tls_process_ske_psk_preamble,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!PACKET_get_length_prefixed_2(pkt, &psk_identity_hint)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}', 'explanation': 'This segment checks if the PSK identity hint can be parsed with a 2-byte length prefix and, if not, terminates the connection using a decode_error alert. This is in line with the RFC requirement that a message that cannot be parsed must trigger a decode_error alert.'}}]","The function correctly implements handling of a syntactic parsing error for the PSK identity hint by triggering a decode_error alert when the prefixed length cannot be read, which meets one part of the RFC spec (e.g., C1 and its corresponding action). However, the RFC also requires that messages with an out‐of‐range length (a syntactic error) lead to a decode_error alert, while semantically invalid messages should trigger an illegal_parameter alert. In this code, when the remaining PSK identity hint length exceeds PSK_MAX_IDENTITY_LEN, it triggers a handshake_failure alert rather than a decode_error (or illegal_parameter) alert as prescribed. Since this part of the spec is not addressed correctly within the function, the implementation only partially meets the RFC constraints.",success,
14177,tls_process_ske_psk_preamble,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function tls_process_ske_psk_preamble handles the processing of a PSK identity hint without any visible logic related to cipher suite selection or filtering out RC4 cipher suites as required by the RFC specification. There is no code segment in this function that checks for or rejects RC4, nor is there any logic that prevents the negotiation of low strength ciphers. Thus, the function does not address any of the labeled conditions or actions regarding RC4 cipher suites.",success,
14179,tls_process_ske_dhe,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_length_prefixed_2(pkt, &prime)\n        || !PACKET_get_length_prefixed_2(pkt, &generator)\n        || !PACKET_get_length_prefixed_2(pkt, &pub_key)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}', 'explanation': 'This code segment checks whether input packets can be parsed properly (including length boundaries). If any part of the message fails parsing, it triggers SSLfatal with a decode_error alert, thus matching the RFC requirement.'}}, {'C2': {'code': 'if (pctx == NULL\n        || EVP_PKEY_param_check_quick(pctx) != 1\n        || EVP_PKEY_public_check(pctx) != 1) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_DH_VALUE);\n    goto err;\n}', 'explanation': ""This segment validates that the Diffie-Hellman parameters and the public key are semantically valid. Upon detecting an invalid parameter, it issues an illegal_parameter alert, aligning with the RFC's instructions for semantically invalid messages.""}}]","The function implements two key aspects of the TLS RFC for error handling in key exchange messages. First, it checks length and parsing errors and terminates with a decode_error alert if the message cannot be parsed. Second, after successful parsing, it verifies the semantic validity (e.g., through quick parameter and public key checks) and, if invalid, terminates with an illegal_parameter alert. Both behaviors are directly implemented within the function, thereby fully covering the specified constraints.",success,
14179,tls_process_ske_dhe,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (EVP_PKEY_param_check_quick(pctx) != 1\n            || EVP_PKEY_public_check(pctx) != 1) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_DH_VALUE);\n        goto err;\n    }', 'explanation': ""This segment checks the DH parameters and public key semantically, and if either check fails, it terminates the connection with an 'illegal_parameter' alert, addressing the spec requirement for handling semantically invalid messages.""}}]","The function implements a check for semantic validity of the Diffie-Hellman parameters by using EVP_PKEY_param_check_quick and EVP_PKEY_public_check. When these checks fail, it terminates the connection with an 'illegal_parameter' alert, thereby partially fulfilling the spec that mandates termination upon receiving a syntactically correct but semantically invalid message. However, while it addresses the semantic error handling (action A1), it does not explicitly inspect all potential semantic faults such as a DHE share of p - 1, so the implementation is only partial.",success,
14180,tls_process_ske_ecdhe,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (curve_type != NAMED_CURVE_TYPE || !tls1_check_group_id(s, curve_id, 1)) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_CURVE);\n        return 0;\n    }', 'explanation': ""This segment verifies that the received curve type is the expected named curve and that the curve identifier is one of the supported groups. If not, it treats the semantically invalid parameters as an error per the spec and terminates the connection with the 'illegal_parameter' alert.""}}, {'A1': {'code': 'if (EVP_PKEY_set1_encoded_public_key(s->s3.peer_tmp,\n                                     PACKET_data(&encoded_pt),\n                                     PACKET_remaining(&encoded_pt)) <= 0) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_ECPOINT);\n        return 0;\n    }', 'explanation': ""This part attempts to decode and set the ephemeral ECDH public key. When the public key is not correctly interpreted (indicating a semantically invalid value), it calls SSLfatal with an 'illegal_parameter' alert. This directly implements the spec requirement for handling semantically incorrect messages.""}}]","The function tls_process_ske_ecdhe processes the Server Key Exchange for ephemeral ECDHE parameters. It verifies that the elliptic curve parameters are valid and supported, and if any semantic inconsistency is found (such as an incorrect curve type or public key issues), it immediately terminates the connection using the 'illegal_parameter' alert. This behavior fully conforms to the RFC specification that requires termination with an 'illegal_parameter' alert upon receiving a syntactically correct but semantically invalid message.",success,
14180,tls_process_ske_ecdhe,"Servers MAY check for violations of these rules and abort the handshake with an ""illegal_parameter"" alert if one is violated.",125,Partially Matches,"[{'C1': {'code': 'if (curve_type != NAMED_CURVE_TYPE || !tls1_check_group_id(s, curve_id, 1)) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_CURVE);\n    return 0;\n}', 'explanation': 'This segment directly checks that the received curve is a named curve and that the provided curve_id is acceptable (presumably by confirming it is one of the supported groups). This corresponds to the RFC mandate that a KeyShareEntry must correspond to a group listed in the supported_groups extension.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_CURVE);', 'explanation': ""When the condition is not met, the function aborts the handshake with an 'illegal_parameter' alert, which is in line with the RFC that permits the server to abort the handshake if violations are found.""}}]","The function implements parts of the RFC specification by verifying that the curve type is 'named' and by using tls1_check_group_id to ensure the curve ID is valid—in effect, checking that the key share corresponds to an allowed group. It also appropriately aborts the handshake with an 'illegal_parameter' alert when the check fails. However, the RFC also includes conditions regarding KeyShareEntry order and uniqueness as per the client's supported_groups extension. Such additional checks are not performed in this function, meaning that while some labeled constraints (C1 and corresponding action A1) are addressed, the implementation does not cover all aspects of the RFC specification on key share handling.",success,
14180,tls_process_ske_ecdhe,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_1(pkt, &curve_type) || !PACKET_get_net_2(pkt, &curve_id)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_TOO_SHORT);\n    return 0;\n}', 'explanation': 'This segment checks that the required fields (curve_type and curve_id) can be parsed. If they cannot be obtained (i.e. the message is too short), it terminates the connection with a decode_error alert, fulfilling the RFC requirement for syntactic parsing errors.'}}, {'C2': {'code': 'if (!PACKET_get_length_prefixed_1(pkt, &encoded_pt)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}', 'explanation': 'This segment validates that the length‐prefixed part of the message is properly parsed. On failure, it invokes SSLfatal with a decode_error alert, again satisfying the RFC mandate on handling messages that cannot be parsed according to the expected syntax.'}}]","The function 'tls_process_ske_ecdhe' directly implements the RFC specification by checking for message parsing errors. In cases where the message cannot be correctly parsed—either due to insufficient data for key parameters or mismatches in the expected length—it calls the SSLfatal function with the SSL_AD_DECODE_ERROR alert. This behavior fully addresses the protocol requirement that a decode_error alert must be sent when a message's syntax cannot be parsed. All logic related to parsing and error signaling resides within this function, satisfying the specification conditions.",success,
14181,tls_process_key_exchange,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_sub_packet(&save_param_start, &params, PACKET_remaining(&save_param_start) - PACKET_remaining(pkt))) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}\n\nif (!PACKET_get_length_prefixed_2(pkt, &signature) || PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n\n...\n\nif (PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_EXTRA_DATA_IN_MESSAGE);\n    goto err;\n}', 'explanation': 'The function checks for a variety of packet parsing errors. When parsing fails (such as when the packet length is incorrect or when extra data is present), it calls SSLfatal with SSL_AD_DECODE_ERROR, thereby following the RFC requirement that messages not adhering to the expected syntax cause termination with a ""decode_error"" alert.'}}]","The provided function implements the TLS RFC requirement by explicitly checking for syntax errors during parsing (e.g., improper length, extra data) and, upon detecting such errors, it terminates the connection using SSLfatal with a 'decode_error' alert. All logic addressing this behavior is contained within the function itself, thereby fully matching the specified constraint.",success,
14181,tls_process_key_exchange,"If the verification fails, the receiver MUST terminate the handshake with a ""decrypt_error"" alert.",231,Fully Matches,"[{'A1': {'code': 'if (rv <= 0) {\n    SSLfatal(s, SSL_AD_DECRYPT_ERROR, SSL_R_BAD_SIGNATURE);\n    goto err;\n}', 'explanation': ""The code verifies the digital signature, and if the verification fails (rv <= 0), it calls SSLfatal with the alert SSL_AD_DECRYPT_ERROR. This directly implements the requirement from the RFC that if signature verification fails, the handshake must be terminated with a 'decrypt_error' alert.""}}]","The function body contains logic to verify the digital signature contained in the CertificateVerify message. Upon failure, it invokes SSLfatal with the SSL_AD_DECRYPT_ERROR alert, which exactly meets the specified RFC action. The verification check and corresponding error handling are fully implemented within this function.",success,
14182,tls_process_certificate_request,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function tls_process_certificate_request is solely concerned with processing certificate requests and handling related TLS extensions and signature algorithms. It does not contain any logic that addresses the RFC requirement of not offering or negotiating RC4 cipher suites (or any conditions related to low strength ciphers). Since no part of the code inspects, filters, or prevents the use of RC4 or low-strength ciphers, it does not meet any of the labeled constraints specified in the spec.",success,
14182,tls_process_certificate_request,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_length_prefixed_1(pkt, &reqctx) ||\n            !PACKET_memdup(&reqctx, &s->pha_context, &s->pha_context_len)) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n            return MSG_PROCESS_ERROR;\n        }\n        ...\n        if (PACKET_remaining(pkt) != 0) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n            return MSG_PROCESS_ERROR;\n        }', 'explanation': 'The function performs multiple checks on the packet length and structure. When a parsing failure is detected (e.g., a length prefix cannot be obtained or the remaining data is non-zero), it calls SSLfatal with SSL_AD_DECODE_ERROR as required by the RFC. This directly implements the requirement to terminate the connection with a decode_error alert when the message cannot be parsed.'}}]","The function contains explicit checks for proper packet parsing, such as obtaining length-prefixed fields and ensuring no extra data remains. When these conditions are not met, it calls SSLfatal with SSL_AD_DECODE_ERROR, thereby ensuring that the connection is terminated with a decode_error alert. This behavior directly corresponds to the RFC statement that messages which cannot be parsed according to the syntax should result in a decode_error alert, and thus the function fully implements this specified requirement.",success,
14182,tls_process_certificate_request,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function processes the CertificateRequest message for TLS 1.3 and earlier versions, but there is no explicit code that checks for or prevents sending of the status_request_v2 extension. The spec requires that TLS 1.3 servers MUST NOT send the status_request_v2 extension in certain messages. Since this function does not include logic to filter or ignore status_request_v2 (or to handle it per the spec), it does not address the specific constraint outlined in the RFC. All handling of extensions in this function is generic (using tls_collect_extensions and tls_parse_all_extensions), with no special case for status_request_v2.",success,
14182,tls_process_certificate_request,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)) {\n    /* Free and zero certificate types: it is not present in TLS 1.3 */\n    OPENSSL_free(s->s3.tmp.ctype);\n    s->s3.tmp.ctype = NULL;\n    s->s3.tmp.ctype_len = 0;\n    ...\n}', 'explanation': 'In the TLS 1.3 branch the function immediately frees and resets the certificate types. Since the OpenPGP certificate type (per RFC6091) must not be used in TLS 1.3, this code ensures no certificate types (including OpenPGP) are processed when TLS 1.3 is in use.'}}]","The function clearly distinguishes between TLS 1.3 and earlier versions. In the TLS 1.3 branch, it deliberately discards the certificate types (by freeing and zeroing the relevant fields), thereby ensuring that no certificate type—specifically the OpenPGP type referenced in RFC6091—is used with TLS 1.3, which fully satisfies the RFC requirement.",success,
14182,tls_process_certificate_request,The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message.,57,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)) {\n    ...\n    if (!PACKET_get_length_prefixed_1(pkt, &reqctx) ||\n        !PACKET_memdup(&reqctx, &s->pha_context, &s->pha_context_len)) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n        return MSG_PROCESS_ERROR;\n    }\n\n    if (!PACKET_get_length_prefixed_2(pkt, &extensions)) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_LENGTH);\n        return MSG_PROCESS_ERROR;\n    }\n    if (!tls_collect_extensions(s, &extensions,\n                                SSL_EXT_TLS1_3_CERTIFICATE_REQUEST,\n                                &rawexts, NULL, 1)\n        || !tls_parse_all_extensions(s, SSL_EXT_TLS1_3_CERTIFICATE_REQUEST,\n                                     rawexts, NULL, 0, 1)) {\n        OPENSSL_free(rawexts);\n        return MSG_PROCESS_ERROR;\n    }\n    OPENSSL_free(rawexts);\n    if (!tls1_process_sigalgs(s)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_LENGTH);\n        return MSG_PROCESS_ERROR;\n    }\n}', 'explanation': 'This TLS1.3 branch of the function processes the CertificateRequest message by extracting the certificate request context and handling extensions via tls_collect_extensions and tls_parse_all_extensions. It directly addresses the RFC requirement for processing extension requests that may be sent by the server.'}}, {'C2': {'code': 'else {\n    PACKET ctypes;\n\n    /* get the certificate types */\n    if (!PACKET_get_length_prefixed_1(pkt, &ctypes)) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n        return MSG_PROCESS_ERROR;\n    }\n\n    if (!PACKET_memdup(&ctypes, &s->s3.tmp.ctype, &s->s3.tmp.ctype_len)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return MSG_PROCESS_ERROR;\n    }\n\n    if (SSL_USE_SIGALGS(s)) {\n        PACKET sigalgs;\n\n        if (!PACKET_get_length_prefixed_2(pkt, &sigalgs)) {\n            SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n            return MSG_PROCESS_ERROR;\n        }\n\n        if (!tls1_save_sigalgs(s, &sigalgs, 0)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_SIGNATURE_ALGORITHMS_ERROR);\n            return MSG_PROCESS_ERROR;\n        }\n        if (!tls1_process_sigalgs(s)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_SSL_LIB);\n            return MSG_PROCESS_ERROR;\n        }\n    }\n\n    /* get the CA RDNs */\n    if (!parse_ca_names(s, pkt)) {\n        return MSG_PROCESS_ERROR;\n    }\n}', 'explanation': 'In the non-TLS1.3 branch, the function processes the CertificateRequest by extracting certificate types, signature algorithms, and CA names. This behavior aligns with the RFC requirement for processing certificate request messages before the client sends a Certificate message.'}}, {'A1': {'code': 's->s3.tmp.cert_req = 1;', 'explanation': 'This line sets the flag indicating that a certificate is requested. It directly implements the action that the server’s CertificateRequest message should lead to the client preparing a Certificate message if applicable.'}}, {'A2': {'code': 'if (SSL_CONNECTION_IS_TLS13(s) && s->post_handshake_auth != SSL_PHA_REQUESTED)\n    return MSG_PROCESS_CONTINUE_READING;', 'explanation': 'For TLS1.3, the function defers the preparation of the client certificate until after the CertificateVerify message is received, which is in accordance with the RFC’s specified order of messages.'}}]","The function tls_process_certificate_request processes a CertificateRequest message by handling both TLS1.3 and earlier versions as specified in the RFC. It extracts and verifies the certificate request context and extensions in TLS1.3, while in earlier versions it processes certificate types, signature algorithms, and CA names. By setting the certificate request flag and deferring client certificate selection in TLS1.3, the function visibly implements the requirement that the client may respond to a CertificateRequest with a Certificate message, thereby fully matching the spec.",success,
14183,tls_process_new_session_ticket,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_4(pkt, &ticket_lifetime_hint)\n        || (SSL_CONNECTION_IS_TLS13(s)\n            && (!PACKET_get_net_4(pkt, &age_add)\n                || !PACKET_get_length_prefixed_1(pkt, &nonce)))\n        || !PACKET_get_net_2(pkt, &ticklen)\n        || (SSL_CONNECTION_IS_TLS13(s) ? (ticklen == 0\n                                          || PACKET_remaining(pkt) < ticklen)\n                                       : PACKET_remaining(pkt) != ticklen)) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n        goto err;\n    }', 'explanation': ""This segment verifies the syntactic correctness of the incoming message by checking that all required fields are present and that lengths are within expected boundaries. If any check fails, it immediately calls SSLfatal with a decode_error alert, directly fulfilling the RFC's requirement.""}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);', 'explanation': 'This call ensures that in case of any parsing failure the connection is terminated with a decode_error alert, as mandated by the RFC specification.'}}]","The function tls_process_new_session_ticket directly implements the TLS RFC requirement regarding the handling of syntactically malformed messages. By performing rigorous checks on the packet's structure and length fields and by invoking SSLfatal with a decode_error alert upon a failure, the code meets both the condition (C1) of detecting syntax errors and the action (A1) of terminating the connection appropriately. All logic addressing these behaviors is contained within the function, thereby fully matching the specified RFC constraint.",success,
14183,tls_process_new_session_ticket,"The server MAY also send unsolicited extensions in the NewSessionTicket, though the client does not respond directly to these.",58,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)) {\n    PACKET extpkt;\n\n    if (!PACKET_as_length_prefixed_2(pkt, &extpkt)\n            || PACKET_remaining(pkt) != 0) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n        goto err;\n    }\n\n    if (!tls_collect_extensions(s, &extpkt,\n                                SSL_EXT_TLS1_3_NEW_SESSION_TICKET, &exts,\n                                NULL, 1)\n            || !tls_parse_all_extensions(s,\n                                         SSL_EXT_TLS1_3_NEW_SESSION_TICKET,\n                                         exts, NULL, 0, 1)) {\n        goto err;\n    }\n}', 'explanation': 'This code block handles the case for TLS 1.3 where the server may send unsolicited extensions as part of the NewSessionTicket message. The function collects and parses these extensions per the TLS spec, acknowledging that extensions can be provided even without a corresponding client request.'}}, {'A1': {'code': '...\nreturn MSG_PROCESS_FINISHED_READING;\n...', 'explanation': 'After processing the extensions, the function does not generate or send any extension responses. This behavior meets the spec requirement that although extensions may be sent by the server, the client does not respond directly to them.'}}]","The function tls_process_new_session_ticket clearly implements the TLS RFC requirement by processing the NewSessionTicket message with a focus on TLS 1.3. It extracts and handles unsolicited extensions (as indicated in the spec) by collecting and parsing them while not issuing any direct responses. Therefore, the code function fully addresses the specific spec constraints regarding unsolicited extensions in the NewSessionTicket message.",success,
14184,tls_process_cert_status_body,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_1(pkt, &type) || type != TLSEXT_STATUSTYPE_ocsp) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_UNSUPPORTED_STATUS_TYPE);\n    return 0;\n}', 'explanation': 'This code verifies that the first byte parsed from the packet represents the expected status type. If the type is not as expected or if reading the byte fails, the function terminates the connection with a decode_error alert as required by the specification.'}}, {'C2': {'code': 'if (!PACKET_get_net_3_len(pkt, &resplen) || PACKET_remaining(pkt) != resplen) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}', 'explanation': 'This segment ensures that the length field is read correctly and that the remaining packet data exactly matches the indicated length. This protects against messages with lengths that extend beyond the message boundary and triggers a decode_error if the check fails.'}}, {'A1': {'code': 'if (!PACKET_copy_bytes(pkt, s->ext.ocsp.resp, resplen)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return 0;\n}', 'explanation': ""After allocating memory and setting up the response, this code copies the packet bytes to the allocated buffer. If the copy fails (implying a parsing error), it also triggers a decode_error alert in accordance with the TLS RFC's requirement to terminate the connection upon encountering syntactic errors.""}}]","The tls_process_cert_status_body function implements the specified TLS RFC requirement by checking for correct message parsing at several steps. It verifies the certificate status type and the length field, and it ensures that the entire message is correctly consumed. In any failure case, the function calls SSLfatal with a decode_error alert, thereby terminating the connection as mandated by the RFC. All logic to detect parsing errors is contained within the function, fully addressing the conditions described in the specification.",success,
14187,tls_process_server_done,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) > 0) {\n    /* should contain no data */\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': ""The function verifies that no extra data is present in the packet. In the event that extra bytes remain (indicating a parsing error such as a length error), it terminates the connection by calling SSLfatal with SSL_AD_DECODE_ERROR, thereby fulfilling the RFC requirement to terminate with a 'decode_error' alert.""}}]","The code function directly implements the RFC requirement that messages which cannot be parsed (e.g., due to extra data beyond the message boundary) result in a connection termination with a 'decode_error' alert. The check for any remaining bytes in the packet and the subsequent call to SSLfatal with the proper alert code fully addresses the specified constraint within the function itself.",success,
14189,tls_construct_cke_rsa,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Fully Matches,"[{'C1': {'code': 'if (!received_server_cert(s)) {\n    /* We should always have a server certificate with SSL_kRSA. */\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}', 'explanation': 'This block checks for a mandatory condition (the presence of a server certificate) and, upon failure, immediately sends a fatal alert (SSL_AD_INTERNAL_ERROR) before aborting, thus satisfying the spec requirement to abort the handshake with an X alert.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n\n...\n\nif (!WPACKET_start_sub_packet_u16(pkt)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}\n\n...\n\nif (pctx == NULL || EVP_PKEY_encrypt_init(pctx) <= 0 || EVP_PKEY_encrypt(pctx, NULL, &enclen, pms, pmslen) <= 0) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);\n    goto err;\n}\n\n...\n\nif (!WPACKET_allocate_bytes(pkt, enclen, &encdata) || EVP_PKEY_encrypt(pctx, encdata, &enclen, pms, pmslen) <= 0) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_RSA_ENCRYPT);\n    goto err;\n}\n\n...\n\nif (s->version > SSL3_VERSION && !WPACKET_close(pkt)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}', 'explanation': 'Throughout the function, every fatal error condition is handled by an immediate call to SSLfatal with a specific alert value (SSL_AD_INTERNAL_ERROR). This shows that the implementation ensures that if any fatal error is detected, a fatal alert is sent, thereby fulfilling the requirement to terminate the connection with a designated alert.'}}]","The tls_construct_cke_rsa function consistently checks for error conditions—inaccuracies with server certificates, public key issues, memory allocation failures, randomness generation, and encryption errors—and in each case, it calls SSLfatal with a specific alert code before aborting any further processing. This approach meets the TLS specification requirement that upon encountering a fatal error, an appropriate fatal alert must be sent, and the connection must be terminated immediately. All error-handling logic is confined within this function, thereby satisfying the spec constraints by itself.",success,
14189,tls_construct_cke_rsa,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Partially Matches,"[{'C1': {'code': 'if (!received_server_cert(s)) {\n    /* We should always have a server certificate with SSL_kRSA. */\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}\n\nif ((pkey = tls_get_peer_pkey(s)) == NULL) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}\n\nif (!EVP_PKEY_is_a(pkey, ""RSA"")) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}\n\n... \nif (RAND_bytes_ex(sctx->libctx, pms + 2, pmslen - 2, 0) <= 0) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_RAND_LIB);\n    goto err;\n}\n\n... \nif (s->version > SSL3_VERSION && !WPACKET_start_sub_packet_u16(pkt)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}\n\n... \nif (pctx == NULL || EVP_PKEY_encrypt_init(pctx) <= 0\n    || EVP_PKEY_encrypt(pctx, NULL, &enclen, pms, pmslen) <= 0) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);\n    goto err;\n}\n\nif (!WPACKET_allocate_bytes(pkt, enclen, &encdata)\n        || EVP_PKEY_encrypt(pctx, encdata, &enclen, pms, pmslen) <= 0) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_RSA_ENCRYPT);\n    goto err;\n}\n\n... \nif (s->version > SSL3_VERSION && !WPACKET_close(pkt)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}', 'explanation': 'The function performs multiple error checks throughout (e.g., missing certificate, incorrect key type, allocation, encryption failures) and calls SSLfatal with the fatal alert SSL_AD_INTERNAL_ERROR. This indicates an attempt to meet the specification constraint where, upon detecting an error, a fatal alert is sent.'}}]","The function implements several error-handling checks that trigger the sending of a fatal alert via SSLfatal() when errors occur, which aligns with the TLS specification requirement to send an alert when a fatal error is detected. However, the specification also requires that the connection be immediately terminated after sending such an alert. This immediate connection closure is not explicitly handled within the function itself, implying that some responsibilities might be delegated to higher-level routines. As a result, while the function addresses the error detection and alert sending aspect (C1), it does not fully implement the complete error-handling process specified in the TLS RFC, leading to a 'Partially Matches' judgment.",success,
14189,tls_construct_cke_rsa,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Partially Matches,"[{'C1': {'code': 'if (!received_server_cert(s)) {\n    /* We should always have a server certificate with SSL_kRSA. */\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}\n\n... (other error cases similarly call SSLfatal(...))', 'explanation': 'The TLS specification requires that all alerts defined in Section 6.2 be sent as fatal and treated as error alerts. In this function, every error situation (for example, missing a server certificate, failing to allocate memory, or encryption failures) causes a call to SSLfatal with an alert description (e.g. SSL_AD_INTERNAL_ERROR) that implies a fatal alert. Thus, the function does include logic that, when an error is detected, leads to an error alert being issued using SSLfatal. However, the function does not itself verify or enforce that the alert is sent with the fatal level (instead delegating this to the SSLfatal function) and it does not handle received alerts or unknown alert types as described in the spec context.'}}]","The function implements error handling by calling SSLfatal in various failure cases, which implies that a fatal alert will be sent in line with the TLS requirement that error alerts be fatal. This meets part of the spec constraint (here labeled C1) in that it consistently uses an error‐triggering mechanism. However, aside from initiating fatal alerts, the function does not include any additional logic to handle alert reception or other aspects (such as dealing with unknown alert types) that are described in the TLS RFC. Therefore, while the function does address the requirement through its use of SSLfatal on errors, it only partially matches the full scope of the TLS RFC’s alert-handling requirements.",success,
14189,tls_construct_cke_rsa,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function, tls_construct_cke_rsa, is responsible for constructing the client key exchange message using RSA encryption, which is a step in the handshake process. However, the TLS RFC specification constraint requiring that Application Data MUST NOT be sent prior to sending the Finished message is not addressed anywhere within this function's logic. The function solely handles preparation and encryption of the premaster secret and does not implement any logic to control or check the sending of application data, which is expected to be managed in other parts of the protocol implementation. Therefore, by itself, this function does not satisfy the specified TLS RFC constraint.",success,
14189,tls_construct_cke_rsa,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function 'tls_construct_cke_rsa' is responsible for constructing the client key exchange using RSA encryption (i.e., generating and encrypting the pre-master secret). It does not deal with cipher suite selection or negotiation. The RFC specification explicitly prohibits offering or negotiating the RC4 cipher suites, and there is no logic within this function that checks for or excludes RC4 ciphers. Therefore, none of the spec constraints (e.g., C1, A1, etc.) related to the prohibition of RC4 are addressed within this function.",success,
14192,tls_construct_cke_gost,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Fully Matches,"[{'A1': {'code': 'if ((pkey = tls_get_peer_pkey(s)) == NULL) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER);\n    return 0;\n}\n\npkey_ctx = EVP_PKEY_CTX_new_from_pkey(sctx->libctx, pkey, sctx->propq);\nif (pkey_ctx == NULL) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);\n    return 0;\n}\n\npms = OPENSSL_malloc(pmslen);\nif (pms == NULL) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_CRYPTO_LIB);\n    goto err;\n}\n\nif (EVP_PKEY_encrypt_init(pkey_ctx) <= 0 || RAND_bytes_ex(sctx->libctx, pms, pmslen, 0) <= 0) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}\n\nukm_hash = EVP_MD_CTX_new();\nif (ukm_hash == NULL || EVP_DigestInit(ukm_hash, EVP_get_digestbynid(dgst_nid)) <= 0 ||\n    EVP_DigestUpdate(ukm_hash, s->s3.client_random, SSL3_RANDOM_SIZE) <= 0 ||\n    EVP_DigestUpdate(ukm_hash, s->s3.server_random, SSL3_RANDOM_SIZE) <= 0 ||\n    EVP_DigestFinal_ex(ukm_hash, shared_ukm, &md_len) <= 0) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}\n\nif (EVP_PKEY_CTX_ctrl(pkey_ctx, -1, EVP_PKEY_OP_ENCRYPT, EVP_PKEY_CTRL_SET_IV, 8, shared_ukm) <= 0) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_LIBRARY_BUG);\n    goto err;\n}\n\nif (EVP_PKEY_encrypt(pkey_ctx, tmp, &msglen, pms, pmslen) <= 0) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_LIBRARY_BUG);\n    goto err;\n}\n\nif (!WPACKET_put_bytes_u8(pkt, V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED) ||\n    (msglen >= 0x80 && !WPACKET_put_bytes_u8(pkt, 0x81)) ||\n    !WPACKET_sub_memcpy_u8(pkt, tmp, msglen)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}', 'explanation': ""Throughout the function, whenever a fatal error condition is detected (e.g., missing peer certificate, failure to allocate resources, encryption failures, or WPACKET errors), the code calls SSLfatal with a specific alert (for instance SSL_AD_HANDSHAKE_FAILURE or SSL_AD_INTERNAL_ERROR). This behavior directly implements the TLS RFC requirement that upon encountering an error the implementation must send a fatal alert (i.e. 'terminate the connection with an X alert').""}}]","The function 'tls_construct_cke_gost' contains multiple error checks that immediately invoke SSLfatal with appropriate alert codes upon detecting a failure. This satisfies the TLS RFC specification stating that if an error is detected, the implementation MUST send a specific fatal alert (X alert) before terminating the connection. All error paths within the function correctly send alerts and abort further processing, which is a direct implementation of the specification's error handling requirements.",success,
14192,tls_construct_cke_gost,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Partially Matches,"[{'C1': {'code': 'if ((pkey = tls_get_peer_pkey(s)) == NULL) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER);\n    return 0;\n}', 'explanation': 'This code checks for a missing peer certificate and calls SSLfatal with SSL_AD_HANDSHAKE_FAILURE, which is in line with the specification’s mandate to send an appropriate fatal alert when a fatal error is detected.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);\n...\nSSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n...\nSSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_LIBRARY_BUG);', 'explanation': 'Multiple error conditions are handled by calling SSLfatal with various alert codes (e.g., SSL_AD_INTERNAL_ERROR) whenever a failure is detected. This implements the action of sending a TLS fatal alert as required by the spec.'}}]","The function contains error checking and sends appropriate fatal alerts (via SSLfatal) when errors occur, which corresponds to the TLS RFC requirement to send alerts upon detecting fatal errors. However, the function relies on external mechanisms to close the connection immediately after sending the alert. Since the spec requires not only sending the alert but also closing the connection (and the actual connection closure is handled by other parts of the system or by the SSLfatal function indirectly), the implementation in this function only partially meets the specified constraints within its own code.",success,
14192,tls_construct_cke_gost,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function implements the GOST key exchange mechanism and does not include any logic related to RC4 cipher suites. The RFC specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites, but this function makes no reference to RC4, nor does it include any logic specifically addressing the prohibition of RC4. Therefore, within the function_body there is no code corresponding to the labeled conditions or actions from the RFC specification.",success,
14192,tls_construct_cke_gost,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Partially Matches,"[{'A1': {'code': 'if ((pkey = tls_get_peer_pkey(s)) == NULL) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER);\n    return 0;\n}\n\n... (several other error paths call SSLfatal with SSL_AD_INTERNAL_ERROR)', 'explanation': 'The function uses SSLfatal in every error branch. SSLfatal is designed to send alerts as fatal, thereby attempting to fulfill the requirement that all error alerts be sent with AlertLevel=fatal.'}}, {'A2': {'code': 'OPENSSL_clear_free(pms, pmslen);', 'explanation': 'On error, the function clears sensitive keying material (the premaster secret) using OPENSSL_clear_free. This aligns with the spec requirement to discard secret values upon connection failure.'}}]","While the RFC specification demands that all error alerts be sent with AlertLevel=fatal and that secret values be discarded on connection failure, this function only indirectly contributes to that behavior. It always calls SSLfatal for error conditions (thereby sending fatal alerts) and ensures that sensitive key material is cleared upon error. However, it does not implement logic for processing received alerts or explicitly checking alert levels. Thus, only parts of the RFC constraints are visibly implemented within this function.",success,
14198,tls_client_key_exchange_post_work,Future specifications MUST NOT define a use of exporters that permit both an empty context and no context with the same label.,332,Does Not Match,[],"The provided function does not exhibit any logic that enforces or verifies the constraint specified in the RFC regarding exporters. The RFC states that future specifications must not allow the same exporter label to be used with both an empty context and no context, yet in the DTLS SCTP authentication branch the function calls SSL_export_keying_material with a NULL context (i.e., context length of 0) without any logic to distinguish between an empty context and a missing context. There is no code in the function that checks for or prevents the simultaneous use of an empty context and no context with the same label. Therefore, the function does not implement the specified TLS RFC constraint.",success,
14198,tls_client_key_exchange_post_work,"Once all the values which are to be derived from a given secret have been computed, that secret SHOULD be erased.",325,Partially Matches,[],"The TLS RFC specification requires that once all values derived from a secret have been computed, that secret SHOULD be erased. In this function, the code does make an attempt to erase the secret in one branch by calling OPENSSL_clear_free in the error path and setting the pointer and length to NULL. However, after a successful computation of the master secret (i.e. in the non-error branch) the function only resets the pointers (pms = NULL; pmslen = 0) without explicitly clearing the memory. Consequently, the erasure of the secret is only partially performed within this function, and crucially, the responsibility for securely erasing the secret appears to be delegated to external code (such as ssl_generate_master_secret) rather than being fully implemented here. Since we are considering only the logic within this function itself, it only partially meets the RFC’s requirement.",success,
14198,tls_client_key_exchange_post_work,Implementations MUST NOT combine external PSKs with certificate-based authentication of either the client or the server unless negotiated by some extension.,400,Does Not Match,[],"The RFC specification requires that implementations MUST NOT combine external PSKs with certificate-based authentication unless negotiated by an extension. The provided function does not include any logic to check or enforce that constraint. It handles pre-master secret generation for SRP and non-PSK cases and proceeds with master secret generation, but there is no mechanism in the function to verify that external PSKs are not being combined with certificate-based authentication. Thus, the function does not visibly address the specified condition in its own code.",success,
14198,tls_client_key_exchange_post_work,"However, because these secrets can be used to compute any exporter value, they SHOULD be erased as soon as possible.",403,Partially Matches,"[{'A1': {'code': 'pms = s->s3.tmp.pms;\npmslen = s->s3.tmp.pmslen;\n...\nif (!ssl_generate_master_secret(s, pms, pmslen, 1)) {\n    OPENSSL_clear_free(pms, pmslen);\n    s->s3.tmp.pms = NULL;\n    s->s3.tmp.pmslen = 0;\n    goto err;\n}\npms = NULL;\npmslen = 0;', 'explanation': 'This function explicitly clears the pre‐master secret (pms) once it is no longer needed. This aligns with the RFC recommendation to erase secrets as soon as possible. However, the RFC specifically discusses erasing exporter-related secrets (exporter_master_secret/early_exporter_master_secret), and while clearing the pre-master secret is related, the function does not explicitly address the exporter secret derivation or its cleanup. Thus, only part of the action (A1) is implemented within this function.'}}]","The provided function demonstrates an effort to erase sensitive material by nullifying and clearing the pre‐master secret (pms) after its use. This is in line with the RFC recommendation that secrets capable of deriving exporter values should be cleared promptly. However, the RFC’s focus is specifically on exporter_master_secret and early_exporter_master_secret, and this function does not show logic for deriving or erasing these exporter secrets. Consequently, while the function partially meets the intended security action (A1), it does not fully implement all aspects of the RFC’s requirement in isolation.",success,
14198,tls_client_key_exchange_post_work,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function focuses on processing the client key exchange, generating and managing the master secret and SCTP authentication key material. There is no logic within this function that examines or restricts the use of RC4 cipher suites or ciphers with strength less than 112 bits as required by the spec. Therefore, this function does not visibly address the condition stating that implementations MUST NOT offer or negotiate RC4 cipher suites.",success,
14200,tls_prepare_client_certificate,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The provided function, tls_prepare_client_certificate, focuses on handling client certificate callbacks, certificate selection, and error handling based on certificate validation. It does not include any explicit logic to detect or prevent the negotiation of SSL 2.0 (or SSL 2.0 compatible CLIENT-HELLO messages) as required by the TLS RFC specification stated. Specifically, there is no check within the function to ensure that an SSL version 2.0 compatible CLIENT-HELLO is not sent or processed. References to version checks (such as comparing against SSL3_VERSION or checking for TLS 1.3) do not address the constraints regarding SSL2. Therefore, the code does not visibly implement any of the actions or conditions (such as preventing SSL2 negotiation) indicated in the specification.",success,
14201,tls_construct_client_certificate,"If the server does not send an ""early_data"" extension in EncryptedExtensions, then the client MUST NOT send an EndOfEarlyData message.",236,Does Not Match,[],"The provided function, tls_construct_client_certificate, is responsible for constructing the client certificate message and handling parts of the TLS 1.3 handshake (including changes to the cipher state when early data or middlebox compatibility mode is used). However, it does not implement any logic that checks whether the server sent an ""early_data"" extension in the EncryptedExtensions or conditionally sends an EndOfEarlyData message based on that. The RFC specification requires that the client must send (or not send) the EndOfEarlyData message according to the server's inclusion of the early_data extension, but no such decision-making code appears in the function. Therefore, the function does not address any of the labeled constraints (C1, A1, etc.) pertaining to the EndOfEarlyData message.",success,
14201,tls_construct_client_certificate,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function, tls_construct_client_certificate, is responsible for constructing a client certificate message (or processing certificate-related data) but does not contain any logic addressing the TLS 1.3 specification regarding the status_request_v2 extension. Specifically, the RFC requires that a TLS 1.3 server MUST NOT act upon or send the status_request_v2 extension in Certificate messages (among others), yet within this function there is no code checking for, processing, or conditionally excluding the status_request_v2 extension. All certificate handling here is limited to selecting the certificate type (rpk or x509) and outputting the certificate data. Since no part of this function implements logic corresponding to the condition or action related to status_request_v2 (e.g., not sending it), the function does not visibly address the labeled constraint defined by the RFC specification.",success,
14201,tls_construct_client_certificate,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The provided code function does not contain any visible logic that addresses the TLS 1.3 constraint regarding the handling of 'obsolete_RESERVED' values. The spec requires that values within 'obsolete_RESERVED' ranges must not be offered or negotiated by TLS 1.3 implementations. However, this function only deals with constructing the client certificate (handling aspects such as the pha_context for TLS 1.3 and making a selection between certificate types) and does not implement any checks or logic to prevent the usage of obsolete_RESERVED values. Therefore, none of the labeled conditions or actions specified in the TLS RFC are implemented within this function.",success,
14201,tls_construct_client_certificate,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'A1': {'code': 'if (!WPACKET_put_bytes_u8(pkt, 0)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return CON_FUNC_ERROR;\n}\n\n... \n\ndefault:\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return CON_FUNC_ERROR;', 'explanation': 'In multiple error cases the function calls SSLfatal with an alert code (SSL_AD_INTERNAL_ERROR) before returning an error code. This shows an intent to send an alert when a fatal error condition occurs in compliance with the RFC’s requirement that an alert be sent when terminating the connection.'}}, {'A1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)\n        && SSL_IS_FIRST_HANDSHAKE(s)\n        && (s->early_data_state != SSL_EARLY_DATA_NONE\n            || (s->options & SSL_OP_ENABLE_MIDDLEBOX_COMPAT) != 0)\n        && (!ssl->method->ssl3_enc->change_cipher_state(s,\n                SSL3_CC_HANDSHAKE | SSL3_CHANGE_CIPHER_CLIENT_WRITE))) {\n    SSLfatal(s, SSL_AD_NO_ALERT, SSL_R_CANNOT_CHANGE_CIPHER);\n    return CON_FUNC_ERROR;\n}', 'explanation': 'This branch detects a fatal error when changing the cipher state. Instead of sending a specific fatal alert, the code calls SSLfatal with SSL_AD_NO_ALERT due to an inconsistent state that might lead to a crash if an alert were sent. This is a deliberate deviation that addresses internal consistency at the cost of not sending an expected alert per the RFC wording.'}}]","The function shows that it implements error handling by invoking SSLfatal in several branches, which typically causes the appropriate fatal alert to be sent before terminating the connection, as required by the TLS RFC. However, in one error branch (the cipher state change failure), it intentionally uses SSL_AD_NO_ALERT to avoid potential crashes. Because this branch does not send an alert even though the RFC mandates sending alert X if any alert is sent, the implementation only partially meets the RFC’s requirements.",success,
14201,tls_construct_client_certificate,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Partially Matches,"[{'C1': {'code': 'if (!WPACKET_put_bytes_u8(pkt, 0)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return CON_FUNC_ERROR;\n}\n\n... \n\nif (!WPACKET_sub_memcpy_u8(pkt, s->pha_context, s->pha_context_len)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return CON_FUNC_ERROR;\n}\n\n...\n\ndefault:\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return CON_FUNC_ERROR;', 'explanation': 'The function checks for errors (e.g., failure to write bytes or unexpected client_cert_type) and calls SSLfatal with a fatal alert before returning an error. This indicates an attempt to comply with the spec’s requirement of sending a fatal alert immediately upon error detection (e.g., terminating the connection).'}}, {'A1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)\n        && SSL_IS_FIRST_HANDSHAKE(s)\n        && (s->early_data_state != SSL_EARLY_DATA_NONE\n            || (s->options & SSL_OP_ENABLE_MIDDLEBOX_COMPAT) != 0)\n        && (!ssl->method->ssl3_enc->change_cipher_state(s,\n                SSL3_CC_HANDSHAKE | SSL3_CHANGE_CIPHER_CLIENT_WRITE))) {\n    SSLfatal(s, SSL_AD_NO_ALERT, SSL_R_CANNOT_CHANGE_CIPHER);\n    return CON_FUNC_ERROR;\n}', 'explanation': 'This segment detects a specific error condition in the TLS 1.3 handshake (failure to change cipher state at the last moment) and responds by calling SSLfatal without a designated alert, aligning with the RFC’s instruction to send an appropriate fatal alert and abort the handshake upon fatal errors.'}}]","The function addresses error-handling requirements from the TLS RFC by detecting error conditions and calling SSLfatal, which is used to send a fatal alert as soon as an error is detected. While these calls indicate the intention to abort the handshake (or terminate the connection) immediately as required, the function itself does not execute the actual connection closure; that responsibility likely falls to higher-level code triggered by the error return. Therefore, while the function visibly handles a portion of the error conditions and actions (such as sending alerts), it does not complete the entire prescribed behavior on its own.",success,
14201,tls_construct_client_certificate,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Does Not Match,[],"The code in tls_construct_client_certificate is focused on constructing the client certificate message and handling errors during that process by calling SSLfatal. It does not contain any logic that implements the spec constraint which requires that all alerts (specifically those in Section 6.2) be sent with AlertLevel=fatal and treated as error alerts when received. The function only calls SSLfatal with various alert codes upon failures, but does not address the alert handling semantics specified in the RFC (such as ensuring that unknown alerts or alert levels are treated as fatal). Therefore, this function does not visibly address the labeled condition/action from the spec.",success,
14201,tls_construct_client_certificate,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Fully Matches,"[{'C1': {'code': 'switch (s->ext.client_cert_type) {\n    case TLSEXT_cert_type_rpk:\n        if (!tls_output_rpk(s, pkt, cpk)) {\n            /* SSLfatal() already called */\n            return CON_FUNC_ERROR;\n        }\n        break;\n    case TLSEXT_cert_type_x509:\n        if (!ssl3_output_cert_chain(s, pkt, cpk, 0)) {\n            /* SSLfatal() already called */\n            return CON_FUNC_ERROR;\n        }\n        break;\n    default:\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return CON_FUNC_ERROR;\n}', 'explanation': 'The spec requires that the OpenPGP certificate type MUST NOT be used with TLS 1.3. In this function, only RawPublicKey (TLSEXT_cert_type_rpk) and X.509 (TLSEXT_cert_type_x509) certificate types are explicitly handled. Any other certificate type, such as OpenPGP, falls into the default branch which triggers a fatal error. This ensures that OpenPGP is not processed in TLS 1.3.'}}]","The function explicitly handles certificate selection via a switch statement on the client's certificate type. By only accepting RawPublicKey and X.509 types and triggering an error (via the default case) for all other types, the function prevents using the OpenPGP certificate type with TLS 1.3 as required by the RFC. This implementation visible within the function meets the specified constraint.",success,
14202,tls_construct_client_compressed_certificate,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function tls_construct_client_compressed_certificate deals with constructing a compressed certificate message and contains a block handling early data state with a call to change the cipher state (if early data was attempted). However, the function does not include any explicit logic to prevent automatic retransmission of early data or to check whether the negotiated connection selects the same ALPN protocol, as specified in the RFC. The code does not implement any condition or action directly corresponding to the spec constraints regarding early data retransmission, hence it does not meet the specified TLS RFC requirement.",success,
14202,tls_construct_client_compressed_certificate,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'A1': {'code': 'if (SSL_IS_FIRST_HANDSHAKE(sc) && (sc->early_data_state != SSL_EARLY_DATA_NONE || (sc->options & SSL_OP_ENABLE_MIDDLEBOX_COMPAT) != 0) && (!ssl->method->ssl3_enc->change_cipher_state(sc, SSL3_CC_HANDSHAKE | SSL3_CHANGE_CIPHER_CLIENT_WRITE))) {\n    SSLfatal(sc, SSL_AD_NO_ALERT, SSL_R_CANNOT_CHANGE_CIPHER);\n    goto out;\n}\n\n...\n\nerr:\n    SSLfatal(sc, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);', 'explanation': ""The function attempts to handle fatal error conditions by invoking SSLfatal in two error situations. This call is intended to notify the peer of a fatal error, which is in line with the RFC’s requirement to send a fatal alert when terminating the connection. However, one branch uses SSL_AD_NO_ALERT rather than a specific alert value (an 'X alert') as mandated by the RFC, meaning that if an alert is to be sent, it is not using the explicit alert code required. Thus, while error handling is implemented, it does not fully conform to the requirement to 'terminate the connection with an X alert.'""}}]","The RFC specification requires that upon detecting a fatal error the implementation MUST send a specific fatal alert (i.e. an 'X alert') when terminating the connection. In the provided function, error conditions are handled by calls to SSLfatal, which would typically trigger alert sending. However, one of the SSLfatal calls uses SSL_AD_NO_ALERT instead of a specific alert code, thereby not complying with the requirement to send a definitive X alert. This shows that while the function does include logic for handling fatal errors and initiating alert sending, it does not fully implement the spec's constraints regarding the proper alert code, resulting in a partial match.",success,
14202,tls_construct_client_compressed_certificate,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Does Not Match,[],"The provided function, tls_construct_client_compressed_certificate, is focused on constructing and compressing the certificate chain for a ClientHello message and handling errors in that context. It does invoke error handling (via SSLfatal) in error cases; however, there is no visible logic in the function that ensures that any alerts sent are explicitly using AlertLevel=fatal, nor does it implement behavior for treating received alerts as error alerts. The TLS RFC requirement that all alerts (as specified in Section 6.2) MUST be sent with AlertLevel=fatal is not directly addressed by any code segment in this function. Moreover, any additional processing such as discarding secret keys or ensuring no further data flows post-alert is not present in this function either. Therefore, no part of the function visibly implements the spec constraints regarding alerts as demanded by the RFC.",success,
14203,ssl3_check_cert_and_algorithm,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'C1': {'code': 'if (clu == NULL || (alg_a & clu->amask) == 0) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_MISSING_SIGNING_CERT);\n    return 0;\n}\n\nif (alg_k & (SSL_kRSA | SSL_kRSAPSK) && idx != SSL_PKEY_RSA) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_MISSING_RSA_ENCRYPTING_CERT);\n    return 0;\n}\n\nif ((alg_k & SSL_kDHE) && (s->s3.peer_tmp == NULL)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}\n\nif (clu->amask & SSL_aECDSA) {\n    if (ssl_check_srvr_ecc_cert_and_alg(s->session->peer, s))\n        return 1;\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_BAD_ECC_CERT);\n    return 0;\n}', 'explanation': 'For several error scenarios – such as when the certificate is unrecognized, does not support the required algorithm, or for DHE/ECDSA mismatches – the function calls SSLfatal with a specific alert code. This demonstrates that when an error is detected, the function attempts to send the required fatal alert per spec.'}}]","The TLS error‐handling specification requires that if any error is detected during the handshake, the implementation must send a specific fatal alert (for example, via the phrases 'terminate the connection with an X alert' or 'abort the handshake with an X alert'). In this function, various error conditions (e.g. missing or unsuitable certificates, algorithm mismatches, missing ephemeral keys) are detected and handled by calling SSLfatal with an explicit alert value. This indicates that the function visibly implements the requirement to send an alert when an error is detected. However, the spec also mandates immediate connection termination upon sending such a fatal alert, but this function only calls SSLfatal and returns 0; it does not directly close the connection. That responsibility is likely deferred to higher-layer code. Consequently, while the function does address sending the correct alerts, it only partially implements the full error‐handling requirements as stated in the RFC specification.",success,
14203,ssl3_check_cert_and_algorithm,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Partially Matches,"[{'A1': {'code': 'if (clu == NULL || (alg_a & clu->amask) == 0) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_MISSING_SIGNING_CERT);\n    return 0;\n}\n\nif (alg_k & (SSL_kRSA | SSL_kRSAPSK) && idx != SSL_PKEY_RSA) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_MISSING_RSA_ENCRYPTING_CERT);\n    return 0;\n}\n\nif ((alg_k & SSL_kDHE) && (s->s3.peer_tmp == NULL)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}\n\nif (clu->amask & SSL_aECDSA) {\n    if (ssl_check_srvr_ecc_cert_and_alg(s->session->peer, s))\n        return 1;\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_BAD_ECC_CERT);\n    return 0;\n}', 'explanation': 'When a fatal error condition is detected (e.g. certificate issues, algorithm mismatches, or missing temporary key material), the function calls SSLfatal to send the corresponding fatal alert. This corresponds to the TLS spec’s requirement to send an appropriate alert upon error detection. However, the function itself does not directly close the connection; it returns an error code, leaving full termination to be handled elsewhere.'}}]","The provided function performs several checks on certificate and algorithm compatibility and, if errors are detected, it calls SSLfatal to send appropriate fatal alerts as dictated by the TLS specification. This shows an attempt to conform to the requirement of sending fatal alerts (action A1) upon error detection. However, the explicit termination of the connection (as mandated by the spec) is not directly handled within this function; it only returns an error code after calling SSLfatal. Therefore, while the function visibly addresses the alert-sending part of the spec, it does not fully implement all aspects of connection termination as required by the TLS RFC.",success,
14203,ssl3_check_cert_and_algorithm,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6).",10,Partially Matches,"[{'A1': {'code': 'if (clu == NULL || (alg_a & clu->amask) == 0) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_MISSING_SIGNING_CERT);\n    return 0;\n}', 'explanation': ""This code aborts the handshake with a handshake_failure alert when the certificate is either unrecognized or its algorithm mask does not match the cipher's requirements.""}}, {'A2': {'code': 'if (alg_k & (SSL_kRSA | SSL_kRSAPSK) && idx != SSL_PKEY_RSA) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_MISSING_RSA_ENCRYPTING_CERT);\n    return 0;\n}', 'explanation': 'This check ensures that when RSA-based key exchange is used, the provided certificate actually contains an RSA key; if not, it aborts the handshake with a handshake_failure alert.'}}, {'A3': {'code': 'if (clu->amask & SSL_aECDSA) {\n    if (ssl_check_srvr_ecc_cert_and_alg(s->session->peer, s))\n         return 1;\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_BAD_ECC_CERT);\n    return 0;\n}', 'explanation': 'This segment verifies ECC certificate suitability and aborts the handshake using a handshake_failure alert if the ECC certificate check fails.'}}]","The RFC specification requires that if the server is unable to negotiate a supported set of parameters then the handshake must be aborted with a fatal alert (either handshake_failure or insufficient_security). This function implements certificate and algorithm checks that serve as a gate for compatibility between the client-provided certificate and the expected parameters. It does so by evaluating the certificate's properties against the requirements (e.g., checking algorithm masks, RSA key type, and ECC certificate validity) and aborting the handshake by calling SSLfatal with a handshake_failure alert where mismatches occur. However, the function only covers the certificate/algorithm compatibility aspect of parameter negotiation and does not address all possible scenarios of parameter negotiation failure, hence it partially matches the spec constraints.",success,
14203,ssl3_check_cert_and_algorithm,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Partially Matches,"[{'A1': {'code': 'if (clu == NULL || (alg_a & clu->amask) == 0) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_MISSING_SIGNING_CERT);\n    return 0;\n}\n\nif (alg_k & (SSL_kRSA | SSL_kRSAPSK) && idx != SSL_PKEY_RSA) {\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_MISSING_RSA_ENCRYPTING_CERT);\n    return 0;\n}\n\nif ((alg_k & SSL_kDHE) && (s->s3.peer_tmp == NULL)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}\n\nif (clu->amask & SSL_aECDSA) {\n    if (ssl_check_srvr_ecc_cert_and_alg(s->session->peer, s))\n        return 1;\n    SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_BAD_ECC_CERT);\n    return 0;\n}', 'explanation': 'The function uses SSLfatal in multiple error cases to trigger alert messages. SSLfatal, by convention in the TLS library, sends alerts with a fatal level. This behavior attempts to fulfill the spec requirement that error alerts (from Section 6.2) are sent with AlertLevel=fatal. However, the function solely relies on SSLfatal for handling alert sending and does not itself manage other aspects (such as received alert processing or handling unknown alerts), so it only partially implements the full specification.'}}]","The provided code function checks certificates and algorithms, and in multiple error cases, it calls SSLfatal to send error alerts. These calls imply that, when a problem is detected (e.g., missing or mismatched certificates, inadequate temporary keys), the function will trigger a fatal alert according to TLS error handling guidelines. This approach partially addresses the TLS RFC requirement that all alerts (as listed in Section 6.2) are sent with AlertLevel fatal. However, because the function does not cover other aspects of the spec (such as how alerts are received and how unknown alerts are handled), it only partially matches the specification.",success,
14205,tls_process_hello_req,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The tls_process_hello_req function exclusively handles the processing of HelloRequest messages and renegotiation behavior. It does not contain any logic related to cipher suite selection or the prohibition of RC4 cipher suites as required by the RFC specification. There are no code segments in this function that address the conditions pertaining to RC4 disallowance or minimum cipher strength, so this function does not implement any part of the provided spec constraints.",success,
14205,tls_process_hello_req,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The provided function tls_process_hello_req does not implement any logic that addresses the requirement to prevent negotiation of SSL version 2.0, as specified in the RFC (e.g., the mandate that implementations MUST NOT send an SSL version 2.0 compatible CLIENT-HELLO). The function strictly processes TLS HelloRequest messages for renegotiation and does not contain conditions or actions (e.g., checks or restrictions) related to SSL2. Therefore, no labeled conditions (such as C1) or actions (such as A1) from the spec constraints are implemented within this function.",success,
14205,tls_process_hello_req,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) > 0) {\n        /* should contain no data */\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n        return MSG_PROCESS_ERROR;\n    }', 'explanation': 'This code segment checks if there is additional data in the message—an indication that the message could not be parsed correctly—and immediately terminates the connection with a decode_error alert. This directly implements the RFC requirement that any syntactically malformed message (such as one with extra data beyond the expected boundary) results in a decode_error.'}}]","The function 'tls_process_hello_req' verifies that a HelloRequest message contains no extra data. If additional data is detected, it calls SSLfatal with SSL_AD_DECODE_ERROR, fully satisfying the RFC's requirement to terminate the connection with a decode_error alert when a message cannot be parsed as expected. This logic in isolation meets the spec constraint applied to syntactically invalid messages as described in the RFC.",success,
14206,tls_process_encrypted_extensions,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_2(pkt, &extensions) || PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}', 'explanation': 'This segment checks for parsing issues (e.g., incorrect length prefix or extra data beyond the expected boundary), directly addressing the condition that a message which cannot be parsed according to the syntax should trigger an error.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);', 'explanation': 'This call terminates the connection with a decode_error alert, fulfilling the action required by the specification to abort processing upon detecting a parsing error.'}}]","The function explicitly validates the encrypted extensions message by ensuring that the length-prefixed data is well-formed and entirely consumed. Upon detecting any syntax error, it immediately invokes SSLfatal with a decode_error alert, thus directly implementing the RFC requirement that peers terminate the connection with a decode_error when a message cannot be parsed.",success,
14206,tls_process_encrypted_extensions,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'C1': {'code': 'if (!PACKET_as_length_prefixed_2(pkt, &extensions) || PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}', 'explanation': 'This segment checks that the encrypted extensions are properly formatted — ensuring that the packet contains a valid length-prefixed block and no remaining extra bytes. If the condition fails, the handshake is aborted with a \'decode_error\' alert, thus addressing the requirement stated in the RFC (\'If not, then it MUST abort the handshake with a ""decode_error"" alert\').'}}]","The function verifies the integrity of the encrypted extensions block by ensuring that it is correctly length-prefixed and that no extra bytes follow, aborting the handshake with a 'decode_error' alert when these conditions are not met. This satisfies part of the RFC specification regarding rejecting improperly formatted extension data. However, the overall TLS RFC includes additional conditions (such as explicitly handling the presence or absence of mandatory extensions like 'supported_versions' for TLS1.3) which this function does not address on its own. Therefore, the function only partially matches the full set of spec constraints.",success,
14209,tls_construct_end_of_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function solely verifies and updates the early data state, ensuring that it is either in a write retry or finished writing state before marking the end of early data. It does not contain any logic to prevent automatic retransmission of early data or to check if the negotiated ALPN protocol matches. Therefore, none of the labeled constraints corresponding to the TLS RFC specification conditions (e.g., preventing automatic early data retransmission unless the same ALPN protocol is negotiated) are addressed within this function.",success,
14213,tls_setup_handshake,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6).",10,Partially Matches,"[{'C1': {'code': 'for (i = 0; i < sk_SSL_CIPHER_num(ciphers); i++) {\n    const SSL_CIPHER *c = sk_SSL_CIPHER_value(ciphers, i);\n    int cipher_minprotover = SSL_CONNECTION_IS_DTLS(s) ? c->min_dtls : c->min_tls;\n    int cipher_maxprotover = SSL_CONNECTION_IS_DTLS(s) ? c->max_dtls : c->max_tls;\n\n    if (ssl_version_cmp(s, ver_max, cipher_minprotover) >= 0\n            && ssl_version_cmp(s, ver_max, cipher_maxprotover) <= 0) {\n        ok = 1;\n        break;\n    }\n}\nif (!ok) {\n    SSLfatal_data(s, SSL_AD_HANDSHAKE_FAILURE,\n                  SSL_R_NO_CIPHERS_AVAILABLE,\n                  ""No ciphers enabled for max supported SSL/TLS version"");\n    return 0;\n}', 'explanation': 'This segment checks that for a server, there is at least one enabled cipher that supports the maximum protocol version. If not, the handshake is aborted using a handshake failure alert, which partly meets the spec requirement to abort the handshake when no supported parameter set is found.'}}, {'A1': {'code': 'if (ssl_get_min_max_version(s, &ver_min, &ver_max, NULL) != 0) {\n    SSLfatal(s, SSL_AD_PROTOCOL_VERSION, SSL_R_NO_PROTOCOLS_AVAILABLE);\n    return 0;\n}\n\n... (other abort cases such as the MD5-SHA1 check)\n', 'explanation': 'These code segments abort the handshake when a necessary protocol version or digest algorithm is missing, thereby enforcing that negotiation must only succeed when parameters are supported. This corresponds to the action in the spec that requires termination with a fatal alert if no overlap exists.'}}]","The function contains explicit checks that verify whether the chosen protocol version and ciphers are supported. In the server branch, it iterates over the available ciphers and, if none are appropriate for the maximum supported protocol, it aborts the handshake with a handshake_failure alert. Likewise, it checks for necessary digest support and valid protocol version settings, failing the handshake if these criteria are not met. While these measures partially implement the spec’s requirement to abort the handshake when no overlapping parameters are negotiated (using a handshake_failure alert), not every aspect of the candidate negotiation is handled solely within this function. Therefore, the implementation partially matches the specified TLS RFC requirement.",success,
14215,tls_construct_cert_verify,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],The provided function (tls_construct_cert_verify) implements the construction of the certificate verify message and its associated signature processing. It does not contain any logic that addresses rejecting RC4 cipher suites or any related constraints regarding cipher strength as specified in the RFC. All code segments relate solely to signing operations and do not inspect or modify cipher suite choices.,success,
14215,tls_construct_cert_verify,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The provided function tls_construct_cert_verify is responsible for constructing the certificate verification message and handling the signature process based on protocol version (differentiating between SSL3 and other versions). However, the RFC specification requires that SSL 2.0 (i.e. SSL2) must not be negotiated, and specifically mandates that implementations MUST NOT send an SSL version 2.0 compatible CLIENT-HELLO. This function does not contain any explicit logic to reject or prevent the use of SSL2 or to check for an SSL2 ClientHello. Consequently, no part of the function directly addresses or implements any of the labeled constraints (e.g., C1, A1) that pertain to SSL2 deprecation as specified in the RFC and its context. The function branches only on SSL3 and non-SSL3 cases without a safeguard against SSL2, so from the standpoint of the TLS RFC in question, it does not visibly implement the required SSL2 restrictions.",success,
14216,tls_process_cert_verify,"-The server's end-entity certificate's public key (and associated restrictions) MUST be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension (currently RSA, ECDSA, or EdDSA).",205,Partially Matches,"[{'C1': {'code': 'pkey = tls_get_peer_pkey(s);\nif (ssl_cert_lookup_by_pkey(pkey, NULL, sctx) == NULL) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);\n    goto err;\n}\n...\nif (SSL_USE_SIGALGS(s)) {\n    unsigned int sigalg;\n    if (!PACKET_get_net_2(pkt, &sigalg)) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_PACKET);\n        goto err;\n    }\n    if (tls12_check_peer_sigalg(s, sigalg, pkey) <= 0) {\n        goto err;\n    }\n}\nelse if (!tls1_set_peer_legacy_sigalg(s, pkey)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_LEGACY_SIGALG_DISALLOWED_OR_UNSUPPORTED);\n    goto err;\n}', 'explanation': ""This segment retrieves the peer's public key and ensures that it is valid for signing by invoking ssl_cert_lookup_by_pkey. It then verifies that the signature algorithm provided by the client (via its signature_algorithms extension) is compatible with the public key by calling tls12_check_peer_sigalg. This directly addresses the requirement to ensure the server's certificate public key is compatible with the selected authentication algorithm. However, additional requirements like enforcing X.509v3 or checking explicit key usage bits are not performed in this function.""}}]","The function partially implements the RFC specification regarding the compatibility between the certificate’s public key and the client's signature_algorithms extension. It does check the key's usage for signing and its compatibility with the authentication algorithm, but it does not handle all aspects of the complete spec (such as explicit checks for certificate type or key usage extensions). Thus, the implementation within this function addresses some, but not all, of the specified constraints.",success,
14216,tls_process_cert_verify,"RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in ""signature_algorithms"".",228,Partially Matches,"[{'A1': {'code': 'if (SSL_USE_PSS(s)) {\n        if (EVP_PKEY_CTX_set_rsa_padding(pctx, RSA_PKCS1_PSS_PADDING) <= 0\n            || EVP_PKEY_CTX_set_rsa_pss_saltlen(pctx, RSA_PSS_SALTLEN_DIGEST) <= 0) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);\n            goto err;\n        }\n    }', 'explanation': 'This segment configures the EVP_PKEY context to use RSASSA-PSS padding (with a digest-length salt) when the SSL_USE_PSS(s) flag is set. This action is intended to ensure that RSA signatures use the RSASSA-PSS algorithm in accordance with the RFC. However, the implementation is conditional on the flag and does not unconditionally enforce RSASSA-PSS in all execution paths.'}}]","The provided function does address the RFC requirement regarding RSA signatures by setting the RSA padding to RSASSA-PSS when SSL_USE_PSS(s) is active. This indicates an attempt to implement the required behavior by configuring the signature verification algorithm accordingly. Nevertheless, because this enforcement is only applied conditionally (based on the SSL_USE_PSS flag), the function does not fully ensure that all RSA signatures will use RSASSA-PSS regardless of other factors. Therefore, in isolation, the function only partially matches the specification.",success,
14216,tls_process_cert_verify,The receiver of a CertificateVerify message MUST verify the signature field.,230,Fully Matches,"[{'C1': {'code': 'if (s->version == SSL3_VERSION) {\n    if (EVP_DigestVerifyUpdate(mctx, hdata, hdatalen) <= 0\n            || EVP_MD_CTX_ctrl(mctx, EVP_CTRL_SSL3_MASTER_SECRET,\n                               (int)s->session->master_key_length,\n                                s->session->master_key) <= 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);\n        goto err;\n    }\n    if (EVP_DigestVerifyFinal(mctx, data, len) <= 0) {\n        SSLfatal(s, SSL_AD_DECRYPT_ERROR, SSL_R_BAD_SIGNATURE);\n        goto err;\n    }\n} else {\n    j = EVP_DigestVerify(mctx, data, len, hdata, hdatalen);\n    if (j <= 0) {\n        SSLfatal(s, SSL_AD_DECRYPT_ERROR, SSL_R_BAD_SIGNATURE);\n        goto err;\n    }\n}', 'explanation': 'This segment computes the data over which the signature is made (TBS) and then verifies the signature by calling EVP_DigestVerifyFinal (for SSL3) or EVP_DigestVerify (for other versions). This directly implements the RFC requirement that the receiver of a CertificateVerify message must verify the signature field.'}}]","The provided function extracts the signature from the CertificateVerify message, prepares the data covered by the signature (TBS data), and then verifies the signature using EVP_DigestVerify mechanisms. This addresses the TLS specification requirement that the receiver must verify the signature field as stipulated in the RFC.",success,
14216,tls_process_cert_verify,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data.",320,Partially Matches,"[{'C1': {'code': 'if (mctx == NULL) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);\n    goto err;\n}\n\npkey = tls_get_peer_pkey(s);\nif (pkey == NULL) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}\n\n... // several similar calls such as\nif (!PACKET_get_net_2(pkt, &sigalg)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_PACKET);\n    goto err;\n}\n\n... // and further down:\nif (EVP_DigestVerifyFinal(mctx, data, len) <= 0) {\n    SSLfatal(s, SSL_AD_DECRYPT_ERROR, SSL_R_BAD_SIGNATURE);\n    goto err;\n}\n\nerr:\n    BIO_free(s->s3.handshake_buffer);\n    s->s3.handshake_buffer = NULL;\n    EVP_MD_CTX_free(mctx);\n    ...\n    return ret;', 'explanation': 'The code function calls SSLfatal() on multiple error conditions to send appropriate fatal alert messages. This demonstrates an attempt to address the spec requirement that upon encountering a fatal error, an alert is sent.'}}]","The provided function correctly identifies and handles error conditions by invoking SSLfatal(), which is responsible for sending fatal alerts. This addresses the RFC mandate to send an appropriate fatal alert when a fatal error is detected. However, the RFC also requires that the connection MUST be closed immediately without sending or receiving additional data. In this function, while error conditions trigger SSLfatal() and immediate cleanup (via the 'err' label), there is no explicit connection termination logic within the function. It likely relies on higher-level call handling to close the connection. Therefore, the function only partially implements the full scope of the RFC error handling requirements.",success,
14216,tls_process_cert_verify,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_net_2(pkt, &len)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n\nif (!PACKET_get_bytes(pkt, &data, len)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n\nif (PACKET_remaining(pkt) != 0) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}', 'explanation': ""These code segments ensure that if the message cannot be parsed properly (e.g., length fields are invalid or extra bytes remain), the connection is terminated with a 'decode_error' alert, which directly meets the spec requirement.""}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_DECODE_ERROR, ...)', 'explanation': 'Throughout the function, any failure in parsing (e.g., inability to retrieve expected fields from the packet) leads to a call to SSLfatal with the decode_error alert code. This action enforces termination of the connection when a parse error occurs, as required by the RFC.'}}]","The tls_process_cert_verify function implements the TLS RFC requirement by performing rigorous parsing of the incoming message. It checks for correct length fields and ensures that no extra data remains in the packet. On any parsing error, it calls SSLfatal with the SSL_AD_DECODE_ERROR alert. This visible handling of parse errors—as well as an additional check for semantically invalid messages (using an illegal_parameter alert in one case)—indicates that the function fully addresses the specified conditions and actions solely within its own logic.",success,
14216,tls_process_cert_verify,-Implementations that advertise support for RSASSA-PSS (which is mandatory in TLS 1.3) MUST be prepared to accept a signature using that scheme even when TLS 1.2 is negotiated.,103,Fully Matches,"[{'C1': {'code': 'if (SSL_USE_PSS(s)) {\n        if (EVP_PKEY_CTX_set_rsa_padding(pctx, RSA_PKCS1_PSS_PADDING) <= 0\n            || EVP_PKEY_CTX_set_rsa_pss_saltlen(pctx, RSA_PSS_SALTLEN_DIGEST) <= 0) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);\n            goto err;\n        }\n    }', 'explanation': 'This segment checks if RSASSA-PSS is to be used (through SSL_USE_PSS(s)) and then explicitly sets the RSA padding mode to RSA_PKCS1_PSS_PADDING and configures the salt length. This ensures that implementations which advertise RSASSA-PSS support are prepared to accept a RSASSA-PSS signature even under TLS 1.2, thereby fulfilling the RFC requirement.'}}]","The function 'tls_process_cert_verify' directly addresses the TLS RFC requirement by inspecting whether the connection context is set to use RSASSA-PSS (via SSL_USE_PSS) and configuring the EVP_PKEY context accordingly. This demonstrates that the function is prepared to accept RSASSA-PSS signatures even when TLS 1.2 is negotiated, fully matching the specified constraint.",success,
14217,tls_construct_finished,A Finished message MUST be sent regardless of whether the Certificate message is empty.,188,Fully Matches,"[{'A1': {'code': 'finish_md_len = ssl->method->ssl3_enc->final_finish_mac(s,\n                                                            sender, slen,\n                                                            s->s3.tmp.finish_md);\n...\nif (!WPACKET_memcpy(pkt, s->s3.tmp.finish_md, finish_md_len)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return CON_FUNC_ERROR;\n}', 'explanation': 'This function constructs and sends the Finished message regardless of any Certificate message content. It computes the message digest (finish_md) unconditionally and writes it to the packet without checking or branching based on whether a Certificate message was sent or if its certificate_list is empty. This meets the RFC requirement that a Finished message MUST be sent regardless of whether the Certificate message is empty.'}}]","The tls_construct_finished function implements the generation and transmission of the Finished message without any dependency on the presence or content of the Certificate message. All operations related to creating the Finished message (computing finish_md and writing it into the outgoing packet) occur unconditionally. Therefore, the function visibly addresses the specification requirement by ensuring that a Finished message is sent regardless of the Certificate message state.",success,
14219,tls_process_key_update,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (updatetype != SSL_KEY_UPDATE_NOT_REQUESTED\n            && updatetype != SSL_KEY_UPDATE_REQUESTED) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_UPDATE);\n        return MSG_PROCESS_ERROR;\n    }', 'explanation': 'This code block checks that the key update type is one of the two valid enum values. If it is not, the message is considered semantically invalid as per the RFC.'}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_UPDATE);', 'explanation': ""This call explicitly generates an 'illegal_parameter' alert when an invalid enum is received, fulfilling the RFC action requirement for semantically incorrect messages.""}}]","The function addresses the RFC requirement by first checking the syntactic correctness of the KeyUpdate message (ensuring the correct length) and then validating the semantic correctness by verifying that the key update type is one of the defined valid enums. When an invalid value is encountered, it calls SSLfatal with the 'illegal_parameter' alert. This directly implements the specification's directive that peers terminate the connection with an 'illegal_parameter' alert when a semantically invalid message is received.",success,
14219,tls_process_key_update,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_1(pkt, &updatetype) || PACKET_remaining(pkt) != 0) {\n        SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_KEY_UPDATE);\n        return MSG_PROCESS_ERROR;\n    }', 'explanation': 'This code segment validates that the message has been parsed correctly by ensuring that exactly one byte is consumed and that no extra data remains. If either condition fails, it terminates the connection with a decode_error alert, fulfilling the RFC requirement for syntactical parsing errors.'}}, {'C2': {'code': 'if (updatetype != SSL_KEY_UPDATE_NOT_REQUESTED && updatetype != SSL_KEY_UPDATE_REQUESTED) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_UPDATE);\n        return MSG_PROCESS_ERROR;\n    }', 'explanation': 'This segment confirms that the key update type is within the defined range of valid values. If an invalid value is detected, it terminates the connection using an illegal_parameter alert, which aligns with the RFC mandate for handling semantically invalid but syntactically correct messages.'}}]","The function checks that the incoming KeyUpdate message fulfills the TLS RFC requirements by ensuring correct message boundaries and performing value validation on the key update type. When parsing fails or an invalid enum is detected, it triggers the appropriate SSLfatal call with either decode_error or illegal_parameter, thereby fully implementing the described RFC constraints.",success,
14219,tls_process_key_update,"Upon receiving a KeyUpdate, the receiver MUST update its receiving keys.",263,Fully Matches,"[{'C1': {'code': 'if (!tls13_update_key(s, 0)) {\n    /* SSLfatal() already called */\n    return MSG_PROCESS_ERROR;\n}', 'explanation': ""This code calls tls13_update_key which updates the receiver's keys upon receipt of a KeyUpdate, fulfilling the requirement that the receiver MUST update its receiving keys.""}}, {'A1': {'code': 'if (RECORD_LAYER_processed_read_pending(&s->rlayer)) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': ""This check ensures that the KeyUpdate message is processed on a record boundary and terminates the connection with an 'unexpected_message' alert if not, addressing the spec context that a KeyUpdate before Finished must lead to termination.""}}, {'A2': {'code': 'if (updatetype != SSL_KEY_UPDATE_NOT_REQUESTED\n        && updatetype != SSL_KEY_UPDATE_REQUESTED) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_UPDATE);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': ""This logic verifies that only valid KeyUpdate types are accepted. If an unknown value is received, it terminates the connection with an 'illegal_parameter' alert, as required by the spec.""}}, {'A3': {'code': 'if (updatetype == SSL_KEY_UPDATE_REQUESTED)\n    s->key_update = SSL_KEY_UPDATE_NOT_REQUESTED;', 'explanation': ""This condition handles the request_update scenario, ensuring that if the peer requests an update of sending keys, the flag is set such that a response KeyUpdate is generated without causing an infinite loop, aligning with the protocol's expectations.""}}]","The function implements the TLS RFC requirement for processing a KeyUpdate message by ensuring that: (1) it updates the receiving keys via tls13_update_key(); (2) it validates that the key update message is on a valid record boundary, failing with an 'unexpected_message' alert otherwise; (3) it checks for invalid key update types and fails with an 'illegal_parameter' alert if an unrecognized value is received; and (4) it properly handles the request for sending a KeyUpdate back without causing an infinite loop. All these logics are present within the function_body itself, thus fully matching the specified TLS RFC requirements.",success,
14219,tls_process_key_update,"If an implementation receives any other value, it MUST terminate the connection with an ""illegal_parameter"" alert.",264,Partially Matches,"[{'C1': {'code': 'if (updatetype != SSL_KEY_UPDATE_NOT_REQUESTED\n        && updatetype != SSL_KEY_UPDATE_REQUESTED) {\n    SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_KEY_UPDATE);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': ""This segment verifies that the received 'request_update' field is one of the two allowed values. If it isn’t, the connection is terminated with an 'illegal_parameter' alert, directly addressing the spec requirement.""}}, {'A1': {'code': 'if (updatetype == SSL_KEY_UPDATE_REQUESTED)\n    s->key_update = SSL_KEY_UPDATE_NOT_REQUESTED;', 'explanation': ""The spec requires that if 'request_update' is set to 'update_requested', the receiver MUST send a KeyUpdate message with 'update_not_requested'. This code sets a flag to trigger the update by changing s->key_update, but it does not itself send the KeyUpdate message prior to the next Application Data record. Thus, it partially addresses the requirement.""}}]","The function implements a check for invalid values by terminating the connection with an 'illegal_parameter' alert, fully satisfying that part of the spec (C1). It also detects that a KeyUpdate request was received (when the type is SSL_KEY_UPDATE_REQUESTED) and sets a flag indicating that an update is required; however, it does not complete the full action mandated by the spec (A1), which requires sending a KeyUpdate message with 'update_not_requested'. Therefore, while some constraints are visibly addressed, the implementation is only partial with respect to all aspects of the specification.",success,
14219,tls_process_key_update,"Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages can immediately precede a key change, implementations MUST send these messages in alignment with a record boundary.",279,Fully Matches,"[{'C1': {'code': 'if (RECORD_LAYER_processed_read_pending(&s->rlayer)) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': 'This code verifies that the KeyUpdate message is received at a record boundary, as required by the RFC. If any previous record processing is pending (i.e. the message is not aligned with a record boundary), the function terminates the connection with an unexpected_message alert, directly implementing the spec constraint.'}}]","The function_body for tls_process_key_update explicitly checks that the KeyUpdate message adheres to the record boundary requirement, in line with the TLS RFC. By detecting any pending read (indicating a misalignment) and terminating the connection, the function addresses the spec constraint by itself, without relying on external dependencies. This fulfills the requirement that handshake messages, including KeyUpdate, be aligned with record boundaries immediately preceding a key change.",success,
14222,tls_process_finished,-Handshake messages MUST NOT be interleaved with other record types.,275,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)\n    && RECORD_LAYER_processed_read_pending(&s->rlayer)) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': ""This segment directly enforces that in TLS 1.3 the Finished handshake message must be received at a record boundary—if there is any pending record data (indicating interleaving or fragmentation that violates the boundary), the connection is terminated with an 'unexpected_message' alert. This aligns with the RFC requirement that handshake messages must not be interleaved with other record types or span key changes.""}}]","The function's logic clearly checks that a TLS 1.3 Finished message is processed only when it is aligned on a record boundary. By calling 'RECORD_LAYER_processed_read_pending' and triggering an error through 'SSLfatal' if data has been read from another record, it ensures that handshake messages are not interleaved with other types, which is exactly what the RFC mandates.",success,
14222,tls_process_finished,"Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages can immediately precede a key change, implementations MUST send these messages in alignment with a record boundary.",279,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)\n    && RECORD_LAYER_processed_read_pending(&s->rlayer)) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': ""This segment directly checks that for a TLS 1.3 Finished message there is no pending read data (i.e. the message is aligned on a record boundary). If the message is not properly aligned, it terminates the connection with an 'unexpected_message' alert, thus ensuring that the Finished message does not span key changes.""}}]","The RFC requires handshake messages such as Finished to be sent in alignment with a record boundary in TLS 1.3. The provided function checks for any pending read data that would indicate that the message is split across records, and if found, it triggers an error. This logic within the function directly implements the specified constraint, and therefore the function fully matches the requirement as per the TLS RFC.",success,
14222,tls_process_finished,"Implementations MUST verify that all messages immediately preceding a key change align with a record boundary; if not, then they MUST terminate the connection with an ""unexpected_message"" alert.",278,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)\n        && RECORD_LAYER_processed_read_pending(&s->rlayer)) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n        return MSG_PROCESS_ERROR;\n    }', 'explanation': 'This code segment checks that if the connection is TLS 1.3, there is no pending data from previous records (i.e. the Finished message is aligned with a record boundary). Since a Finished message in TLS 1.3 signals a key change, the code enforces the requirement to terminate the connection with an ""unexpected_message"" alert if the alignment is broken.'}}]","The function directly addresses the TLS RFC requirement by verifying that the Finished message (which immediately precedes a key change) is received on a record boundary. The specific check using RECORD_LAYER_processed_read_pending ensures that there is no additional data lingering from a previous record. This satisfies the constraint as specified in the RFC, and hence the function fully matches the requirement within its own logic.",success,
14222,tls_process_finished,"That is, if a handshake message is split over two or more records, there MUST NOT be any other records between them.",276,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s)\n    && RECORD_LAYER_processed_read_pending(&s->rlayer)) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n        return MSG_PROCESS_ERROR;\n    }', 'explanation': 'This check ensures that in TLSv1.3 the Finished handshake message (which signals a key change) is received on a record boundary. If there is any pending read data (implying that the message is split and interleaved with other records), the connection is terminated. This directly enforces the spec requirement that a handshake message split across records must not have any other records between its fragments.'}}]","The function_body contains a TLSv1.3-specific check that verifies the Finished message ends on a record boundary by inspecting whether there is any pending read data. This check alone addresses the provided spec constraint regarding handshake messages not being interleaved with other records when split across multiple records. Thus, in isolation, the function visibly implements the required condition (labeled C1).",success,
14222,tls_process_finished,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (md_len != PACKET_remaining(pkt)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_DIGEST_LENGTH);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': ""This code checks that the length of the Finished message (peer's digest) exactly matches the expected length. If there is a mismatch—implying that the message cannot be parsed according to its syntax—it terminates the connection by calling SSLfatal() with a 'decode_error' alert, exactly as specified by the RFC.""}}]","The function inspects the Finished message's length and immediately terminates the connection with a decode_error alert if the length does not match the expected value. This behavior directly implements the RFC requirement that any message not parsable according to its syntax (such as an out-of-range or extended length error) must lead to termination with a decode_error alert. All relevant logic is contained within the function, fulfilling the specified constraint.",success,
14222,tls_process_finished,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Fully Matches,"[{'C1': {'code': 'if (SSL_CONNECTION_IS_TLS13(s) && RECORD_LAYER_processed_read_pending(&s->rlayer)) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_NOT_ON_RECORD_BOUNDARY);\n    return MSG_PROCESS_ERROR;\n}\n\nif (!SSL_CONNECTION_IS_TLS13(s) && !s->s3.change_cipher_spec) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_GOT_A_FIN_BEFORE_A_CCS);\n    return MSG_PROCESS_ERROR;\n}\ns->s3.change_cipher_spec = 0;', 'explanation': ""This segment directly checks for handshake messages arriving in an unexpected order: for TLS 1.3 it ensures the Finished message is on a record boundary, and for earlier versions it verifies that a Finished message is not received before the ChangeCipherSpec message. In both cases, it aborts the handshake using SSLfatal() with an 'unexpected_message' alert.""}}]","The function contains explicit checks to detect whether a Finished message is received out-of-order (either before a ChangeCipherSpec in pre-TLS 1.3 or not on a record boundary in TLS 1.3). When such a condition is detected, it aborts the handshake with an 'unexpected_message' alert, thereby fully implementing the RFC requirement within the function itself.",success,
14222,tls_process_finished,"Recipients of Finished messages MUST verify that the contents are correct and if incorrect MUST terminate the connection with a ""decrypt_error"" alert.",232,Fully Matches,"[{'C1': {'code': 'md_len = s->s3.tmp.peer_finish_md_len;\n\nif (md_len != PACKET_remaining(pkt)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_DIGEST_LENGTH);\n    return MSG_PROCESS_ERROR;\n}\n\nok = CRYPTO_memcmp(PACKET_data(pkt), s->s3.tmp.peer_finish_md, md_len);', 'explanation': 'This segment verifies that the finished message’s digest length matches the expected length and performs a constant-time memory comparison to check that the contents are correct, thus fulfilling the requirement to verify the Finished message.'}}, {'A1': {'code': 'if (ok != 0) {\n    SSLfatal(s, SSL_AD_DECRYPT_ERROR, SSL_R_DIGEST_CHECK_FAILED);\n    return MSG_PROCESS_ERROR;\n}', 'explanation': 'This segment terminates the connection with a decrypt_error alert if the finished message’s computed digest does not match the expected value, directly implementing the specified action.'}}]",The function implements both the verification of the finished message (ensuring the digest length matches and contents are verified using CRYPTO_memcmp) and the termination of the connection by signaling a decrypt_error alert in case of a mismatch. These directly address the RFC requirements to validate the Finished message and abort the connection if it is incorrect.,success,
14224,ssl_add_cert_to_wpacket,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The code function ssl_add_cert_to_wpacket() is primarily responsible for serializing an X509 certificate and constructing certificate-related extensions by calling tls_construct_extensions(). However, there is no visible logic within this function that checks for or prevents the status_request_v2 extension from being sent in EncryptedExtensions, CertificateRequest, or Certificate messages. Thus, the function does not implement or address the RFC requirement (e.g., C1, A1) that TLS 1.3 servers MUST NOT send the status_request_v2 extension when processing ClientHello messages.",success,
14224,ssl_add_cert_to_wpacket,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'A1': {'code': 'if (len < 0) {\n    if (!for_comp)\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_BUF_LIB);\n    return 0;\n}', 'explanation': ""On failure of converting the certificate (i2d_X509 returns negative), the function calls SSLfatal with the internal error alert when 'for_comp' is false, which is an attempt to send a fatal alert as required.""}}, {'A2': {'code': 'if (!WPACKET_sub_allocate_bytes_u24(pkt, len, &outbytes) || i2d_X509(x, &outbytes) != len) {\n    if (!for_comp)\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}', 'explanation': ""On failure during allocation or writing the certificate bytes, the function similarly calls SSLfatal with the internal error alert (again only if 'for_comp' is false), suggesting some handling for fatal errors as defined by the spec.""}}]","The function implements error detection for certificate conversion and packet writing, and in these cases (when for_comp is false) it explicitly invokes SSLfatal with a specified alert (SSL_AD_INTERNAL_ERROR). This partially matches the TLS specification requirement that a fatal error should trigger an immediate alert and connection termination. However, the function does not consistently send an alert when errors occur (notably, when 'for_comp' is true, it omits calling SSLfatal), meaning that not all fatal error conditions are handled in accordance with the spec entirely within this function. Therefore, it only partially meets the RFC requirement.",success,
14225,ssl_add_cert_chain,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'A1': {'code': 'if (xs_ctx == NULL) {\n    if (!for_comp)\n         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_X509_LIB);\n    return 0;\n}\n...\nif (i != 1) {\n    X509_STORE_CTX_free(xs_ctx);\n    if (!for_comp)\n         SSLfatal(s, SSL_AD_INTERNAL_ERROR, i);\n    return 0;\n}\n...\nif (!ssl_add_cert_to_wpacket(s, pkt, x, i, for_comp)) {\n    /* SSLfatal() already called */\n    X509_STORE_CTX_free(xs_ctx);\n    return 0;\n}', 'explanation': 'Throughout the function, when an error is detected (e.g. failure to allocate chain context, error during certificate chain verification, or failure to add a certificate to the packet), the function conditionally calls SSLfatal with SSL_AD_INTERNAL_ERROR. This call is intended to send a fatal alert as required by the specification. However, the responsibility to send the alert (and to properly terminate the connection) is delegated to SSLfatal, and not all error scenarios might be fully covered within this function itself. This represents a partial implementation of the specified TLS RFC requirement to send a fatal alert on error.'}}]","The TLS specification requires that when a fatal error occurs, the implementation must send a specific fatal alert (e.g. 'terminate the connection with an X alert' or 'abort the handshake with an X alert'). In this function, when errors are detected, the code calls SSLfatal with SSL_AD_INTERNAL_ERROR, which is expected to send the appropriate fatal alert and eventually lead to connection termination. While this demonstrates an attempt to enforce the requirement, the logic for selecting or sending the correct alert is encapsulated within the SSLfatal function and may not cover every scenario explicitly. Thus, the function partially matches the intended behavior as per the TLS RFC, since it addresses error conditions by triggering alert sending but relies on external functions for the complete alert dispatching and termination logic.",success,
14225,ssl_add_cert_chain,"Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data.",320,Partially Matches,"[{'A1': {'code': 'if (xs_ctx == NULL) {\n    if (!for_comp)\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_X509_LIB);\n    return 0;\n}\n\nif (!X509_STORE_CTX_init(xs_ctx, chain_store, x, NULL)) {\n    X509_STORE_CTX_free(xs_ctx);\n    if (!for_comp)\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_X509_LIB);\n    return 0;\n}\n\n...\n\nif (i != 1) {\n    X509_STORE_CTX_free(xs_ctx);\n    if (!for_comp)\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, i);\n    return 0;\n}\n\n...\n\nif (!ssl_add_cert_to_wpacket(s, pkt, x, i, for_comp)) {\n    /* SSLfatal() already called */\n    X509_STORE_CTX_free(xs_ctx);\n    return 0;\n}\n\n...\n\nif (!ssl_add_cert_to_wpacket(s, pkt, x, i, for_comp)) {\n    /* SSLfatal() already called */\n    return 0;\n}', 'explanation': ""The function checks for various error conditions and, when not in 'for_comp' mode, calls SSLfatal with an appropriate alert code (SSL_AD_INTERNAL_ERROR). This behavior indicates an attempt to send a fatal alert upon error detection, satisfying at least part of the specification requirement to send an alert when a fatal error is encountered.""}}]","The TLS RFC requirement mandates that, upon detecting a fatal error, the implementation SHOULD send an appropriate fatal alert and MUST close the connection without further data exchange. In this function, error conditions trigger calls to SSLfatal, which serves to send a fatal alert. However, the function does not include logic for closing the connection or preventing further data transmission—all such responsibilities are likely handled elsewhere. As the specification requires both alerting and connection termination to be handled by the implementation, and this function only addresses the alerting part, it only partially matches the specification.",success,
14227,tls_process_rpk,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function, tls_process_rpk, is dedicated to processing raw public keys (RPK) for TLS connections. It contains logic to handle TLS 1.3 and earlier versions for RawPublicKey messages, but there is no logic within this function that checks for or rejects the use of the OpenPGP certificate type as stipulated by RFC6091. Since the RFC states that the OpenPGP certificate type MUST NOT be used with TLS 1.3, and this function does not verify or enforce that condition (instead focusing solely on the RPK case), the function does not implement the specified TLS RFC condition.",success,
14227,tls_process_rpk,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_length_prefixed_1(pkt, &context)) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_INVALID_CONTEXT);\n    goto err;\n}', 'explanation': ""This block checks the packet's context length and, if invalid, calls SSLfatal with SSL_AD_DECODE_ERROR. It implements the required error detection and ensures that if an alert is sent, it is the specified alert.""}}, {'A1': {'code': 'SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_INVALID_CONTEXT);\n...\nSSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n...\nSSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_EMPTY_RAW_PUBLIC_KEY);\n...\nSSLfatal(sc, SSL_AD_INTERNAL_ERROR, SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);', 'explanation': 'Across multiple error conditions (such as invalid context, length mismatches, an empty raw public key, or missing parameters), the function calls SSLfatal with a specific fatal alert. This matches the spec requirement that when an error is detected, the implementation MUST send the corresponding alert.'}}]","The function_body performs thorough error checking in accordance with the TLS error handling requirements. For every error condition encountered (from decoding errors to parameter validation), it calls SSLfatal with the defined alert code. This ensures that if an alert is sent, it is the alert dictated by the specification ('terminate the connection with an X alert'), thereby fully addressing the spec constraints within the scope of this function.",success,
14227,tls_process_rpk,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_length_prefixed_1(pkt, &context)) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_INVALID_CONTEXT);\n    goto err;\n}\n\nif (sc->server) {\n    if (sc->pha_context == NULL) {\n        if (PACKET_remaining(&context) != 0) {\n            SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_INVALID_CONTEXT);\n            goto err;\n        }\n    } else {\n        if (!PACKET_equal(&context, sc->pha_context, sc->pha_context_len)) {\n            SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_INVALID_CONTEXT);\n            goto err;\n        }\n    }\n} else {\n    if (PACKET_remaining(&context) != 0) {\n        SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_INVALID_CONTEXT);\n        goto err;\n    }\n}', 'explanation': 'The code enforces that the TLS 1.3 context is correctly read and is of the expected length (or matches the recorded context). When this check fails, it calls SSLfatal with a DECODE_ERROR alert, thus addressing the RFC requirement to detect a fatal error condition and send an alert.'}}, {'A1': {'code': 'SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n// and similarly, SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_EMPTY_RAW_PUBLIC_KEY);\n// and SSLfatal(sc, SSL_AD_INTERNAL_ERROR, SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);', 'explanation': 'Each error condition (such as length mismatches, empty raw public key, or missing parameters) leads to an invocation of SSLfatal with an appropriate alert code. This implements the action specified in the RFC that upon detecting a fatal error, the implementation should send the corresponding alert and terminate the handshake/connection.'}}]","The function implements the core aspects of the TLS error handling as specified in the RFC. It verifies that message components (like the context and RPK lengths) conform to expectations, and when a discrepancy is found, it calls SSLfatal with the appropriate alert (e.g., SSL_AD_DECODE_ERROR, SSL_AD_INTERNAL_ERROR). This behavior directly reflects the specification's requirements that upon encountering an error, a fatal alert must be sent and the connection terminated. Thus, within its own logic, the function fully addresses the labeled conditions and actions described.",success,
14227,tls_process_rpk,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_length_prefixed_1(pkt, &context)) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_INVALID_CONTEXT);\n    goto err;\n}\n\nif (!PACKET_get_net_3(pkt, &cert_len) || PACKET_remaining(pkt) != cert_len) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n\nif (SSL_CONNECTION_IS_TLS13(sc)) {\n    if (!PACKET_get_net_3(pkt, &spki_len)) {\n        SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n        goto err;\n    }\n    if (spki_len == 0) {\n        SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_EMPTY_RAW_PUBLIC_KEY);\n        goto err;\n    }\n}\n\nif (!PACKET_get_bytes(pkt, &spki, spki_len)) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n\nif (spki != (spkistart + spki_len)) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n\nif (SSL_CONNECTION_IS_TLS13(sc)) {\n    if (PACKET_remaining(pkt) != (cert_len - 3 - spki_len)) {\n        SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_LENGTH);\n        goto err;\n    }\n    if (!PACKET_as_length_prefixed_2(pkt, &extensions) || PACKET_remaining(pkt) != 0) {\n        SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n        goto err;\n    }\n}', 'explanation': 'These code segments perform numerous message parsing and length verification checks (e.g., verifying the proper context length, certificate length, spki length, and overall packet integrity). When any of these parsing conditions fail, the function calls SSLfatal with SSL_AD_DECODE_ERROR, thereby meeting the spec requirement to detect unparseable syntax.'}}, {'A1': {'code': 'SSLfatal(sc, SSL_AD_DECODE_ERROR, ...);', 'explanation': 'The function consistently terminates the connection via SSLfatal (with the alert SSL_AD_DECODE_ERROR) whenever it detects any parsing issue. This directly implements the specified action of terminating the connection with a decode_error alert when a message cannot be parsed.'}}]","The function includes a series of validations to check that the packet conforms to the expected TLS message syntax (e.g., proper length prefixes, non-zero raw public key length, and complete consumption of the packet). In each case where the packet does not meet the required parse conditions, the function calls SSLfatal with SSL_AD_DECODE_ERROR, which forces termination of the connection as mandated by the TLS RFC specification. Thus, the function visibly and fully implements the condition and action of terminating the connection with a decode_error alert when a message cannot be parsed.",success,
14228,tls_output_rpk,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function builds a certificate list for raw public keys and, when operating under TLS 1.3, it attaches an extension for raw public keys. However, there is no code logic that checks or enforces the prohibition of the OpenPGP certificate type (as specified in RFC6091) when TLS 1.3 is in use. There is no branch or condition that distinguishes the OpenPGP certificate type from others; the function only handles raw public keys. Thus, the function does not visibly implement the spec constraint that states the OpenPGP certificate type MUST NOT be used with TLS 1.3.",success,
14228,tls_output_rpk,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The provided code function does not contain any logic that explicitly addresses the spec constraint regarding the prohibition of values within the 'obsolete_RESERVED' ranges in TLS 1.3. The function focuses on outputting a raw public key (RPK) either from a certificate or private key, and includes conditional handling for TLS 1.2 and TLS 1.3 (with the TLS 1.3 branch adding extensions), but it does not implement any checks or handling to ensure that values from the obsolete_RESERVED ranges are not offered or negotiated. Hence, no part of the code corresponds to any labeled condition or action related to the spec constraint.",success,
14228,tls_output_rpk,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function solely handles the encoding and outputting of raw public key data for TLS connections. There is no logic within this function that checks for, avoids, or otherwise manages the use of the Truncated HMAC extension as required by the RFC specification. Consequently, the function does not address the spec constraint related to the prohibition of using the Truncated HMAC extension (or any related version checks) within its own code.",success,
14228,tls_output_rpk,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Does Not Match,[],"The provided function is responsible for serializing and outputting a raw public key, and its error handling is limited to calling SSLfatal with SSL_AD_INTERNAL_ERROR when internal errors occur. It does not include any specific logic to implement the TLS RFC requirement that all alerts listed in Section 6.2 must be sent with AlertLevel=fatal and treated as error alerts regardless of the level in the message. The error handling present does not explicitly enforce the fatal alert level mandated by the spec, and there is no visible mechanism in the function for treating received alerts or ensuring connection abort on such error alerts as specified. Therefore, in isolation, this function does not visibly address the TLS RFC alert-handling constraints.",success,
14228,tls_output_rpk,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Partially Matches,"[{'C1': {'code': 'if (xpk == NULL) {\n    SSLfatal(sc, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}\n...\nif (pdata_len <= 0) {\n    SSLfatal(sc, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}', 'explanation': 'The RFC requires that on a fatal error, the implementation SHOULD send an appropriate fatal alert. This function does so by calling SSLfatal() when it detects errors (e.g. when xpk is NULL or when pdata_len <= 0).'}}, {'A1': {'code': 'SSLfatal(sc, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);', 'explanation': 'The function attempts to handle fatal error conditions by sending an alert via SSLfatal(). This corresponds to the requirement that the implementation sends an alert when terminating the connection on a fatal error.'}}]","The provided function partially implements the TLS error handling as specified in the RFC. It clearly detects error conditions and sends fatal alerts using SSLfatal() (addressing condition C1 and action A1). However, although the RFC mandates that upon error detection the connection MUST be closed immediately without additional data exchange, this function does not explicitly close the connection; it only frees allocated memory and returns an error value. It appears that connection termination might be handled by higher-level functions. Thus, while the alert sending part is implemented within the function, explicit connection termination is not directly addressed, leading to a 'Partially Matches' outcome.",success,
14228,tls_output_rpk,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'A1': {'code': 'if (xpk == NULL) {\n    SSLfatal(sc, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}\n...\nif (pdata_len <= 0) {\n    SSLfatal(sc, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}\n...\nif (!WPACKET_sub_memcpy_u24(pkt, pdata, pdata_len)) {\n    SSLfatal(sc, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}', 'explanation': 'The RFC requires that when a fatal error is encountered, the implementation MUST send an appropriate fatal alert. In multiple error branches this function calls SSLfatal with the alert SSL_AD_INTERNAL_ERROR, which indicates that an alert is sent when errors are detected. This satisfies the requirement to send an alert (labeled here as action A1) if an error occurs.'}}]","The function implements error detection by verifying critical conditions (such as the availability of the raw public key data) and, upon detecting an error, calls SSLfatal to send a fatal alert with SSL_AD_INTERNAL_ERROR. This aligns with the RFC’s mandate that an alert must be sent when a fatal error occurs. However, the function only handles alert sending and cleanup within its scope; it does not itself handle the subsequent connection termination which is expected to occur once a fatal alert is transmitted. Since the connection closure aspect (terminate the connection immediately without further I/O) is not directly implemented here and is likely managed elsewhere, the function only partially meets the overall spec constraints related to error handling.",success,
14228,tls_output_rpk,There MUST NOT be more than one extension of the same type in a given extension block.,63,Does Not Match,[],"The provided function tls_output_rpk does not implement any logic to enforce that no more than one extension of the same type is present in a given extension block. While the function does handle the case when TLS 1.3 is used by starting and closing a sub-packet for extensions and by calling tls_construct_extensions to add raw public key extensions, it does not include any check to prevent or detect duplicate extensions. Thus, with respect to the RFC specification which requires that there MUST NOT be more than one extension of the same type in a given extension block, this function does not address the constraint within its own logic.",success,
14228,tls_output_rpk,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The provided function, tls_output_rpk, is focused on constructing and sending a raw public key (RPK) in the handshake. It handles serialization of the certificate/public key and, in the case of TLSv1.3, it wraps the public key data in a sub-packet and calls tls_construct_extensions with SSL_EXT_TLS1_3_RAW_PUBLIC_KEY. There is no logic within this function that checks for or prevents the sending of a 'psk_key_exchange_modes' extension. Thus, none of the spec constraints related to ensuring that the server MUST NOT send a 'psk_key_exchange_modes' extension are addressed in the function_body. As dependencies do not count toward fulfilling constraints in this function, the function does not implement the specified TLS RFC requirement.",success,
14229,ssl3_output_cert_chain,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Partially Matches,"[{'A1': {'code': 'if (!WPACKET_start_sub_packet_u24(pkt)) {\n    if (!for_comp)\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}\n\n... \n\nif (!WPACKET_close(pkt)) {\n    if (!for_comp)\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}', 'explanation': 'The function attempts to meet the specification by sending a fatal alert (via the SSLfatal call) when errors occur during packet sub-packet start or close operations. This action corresponds to the spec requirement to send an appropriate alert when a fatal error is detected. However, not all error cases (for example, the error from ssl_add_cert_chain) trigger an alert, and the connection termination itself is not handled within this function.'}}]","This function partially addresses the TLS error-handling requirements as specified in the RFC context. It implements the action of sending a fatal alert (A1) when packet operations fail, but it does not comprehensively address all error detection paths (such as the failure in ssl_add_cert_chain, which merely returns 0) or explicitly perform connection termination. Thus, by itself, it only partially covers the spec’s conditions and actions.",success,
14229,ssl3_output_cert_chain,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'A1': {'code': 'if (!WPACKET_start_sub_packet_u24(pkt)) {\n    if (!for_comp)\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}\n...\nif (!WPACKET_close(pkt)) {\n    if (!for_comp)\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    return 0;\n}', 'explanation': ""These code segments call SSLfatal to send a fatal alert (SSL_AD_INTERNAL_ERROR) when an error occurs with starting or closing the packet sub-section. This shows an attempt to satisfy the requirement that a fatal error condition must result in sending an alert. However, the alert is only sent when the 'for_comp' flag is false. In cases where 'for_comp' is true or when ssl_add_cert_chain fails, no alert is sent, which means that the function does not consistently meet the specification’s mandate to send the appropriate alert upon error detection.""}}]","The function does include logic to send a fatal alert when certain errors are detected (demonstrated by the calls to SSLfatal in the event of a failure to start or close a packet). This partially addresses the TLS RFC mandate that a fatal error must trigger the sending of an alert before terminating the connection. However, because the alert is conditionally sent (only when for_comp is false) and some error conditions (such as failure in ssl_add_cert_chain) do not result in any alert being sent, the function only partially matches the specified requirements.",success,
14231,tls_get_message_header,"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",272,Partially Matches,"[{'C1': {'code': 'else if (recvd_type != SSL3_RT_HANDSHAKE) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE,\n             SSL_R_CCS_RECEIVED_EARLY);\n    return 0;\n}', 'explanation': ""This branch checks that if the received record type is not the expected handshake type (and not a valid change_cipher_spec in proper context), it terminates the connection with an 'unexpected_message' alert. This is a direct implementation of the spec's requirement for handling unexpected record types.""}}, {'A1': {'code': 'if (s->init_num != 0 || readbytes != 1 || p[0] != SSL3_MT_CCS) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE,\n             SSL_R_BAD_CHANGE_CIPHER_SPEC);\n    return 0;\n}', 'explanation': ""Within the processing of a ChangeCipherSpec record, this check ensures the record is a single valid byte (0x01). If not, it aborts by calling SSLfatal with an 'unexpected_message' alert. This corresponds to the action requirement in the RFC specification when an invalid CCS record is received.""}}]","The function implements logic that checks incoming records for expected types. In particular, it distinguishes between handshake messages and change_cipher_spec records and aborts the connection with an unexpected_message alert when it encounters an unexpected type or an improperly formatted change_cipher_spec record. While these checks address key parts of the TLS RFC constraint regarding unexpected record types, the function does not cover every contextual nuance (for example, record ordering relative to ClientHello or Finished messages) which may be handled elsewhere. Thus, it can be said to partially match the specified RFC requirement within the scope of this function.",success,
14231,tls_get_message_header,-Handshake messages MUST NOT be interleaved with other record types.,275,Fully Matches,"[{'C1': {'code': 'if (recvd_type != SSL3_RT_HANDSHAKE) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE,\n             SSL_R_CCS_RECEIVED_EARLY);\n    return 0;\n}\n\nif (recvd_type == SSL3_RT_CHANGE_CIPHER_SPEC) {\n    if (s->init_num != 0 || readbytes != 1 || p[0] != SSL3_MT_CCS) {\n        SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE,\n                 SSL_R_BAD_CHANGE_CIPHER_SPEC);\n        return 0;\n    }\n    ...\n    return 1;\n}', 'explanation': 'The function explicitly verifies the record type of incoming messages. It accepts only handshake records (SSL3_RT_HANDSHAKE) and special cases a ChangeCipherSpec record (SSL3_RT_CHANGE_CIPHER_SPEC) only when it is a single-byte message appearing exactly at a record boundary (s->init_num == 0). This enforces the RFC requirement that handshake messages must not be interleaved with other record types.'}}]","The tls_get_message_header function implements the necessary checks to ensure that only valid handshake messages are processed and that any non-handshake message (or a ChangeCipherSpec message received in the middle of a handshake dialog) triggers an error. This effectively prevents any interleaving of handshake messages with other record types, thereby fully addressing the specified TLS RFC constraint.",success,
14231,tls_get_message_header,"An implementation which receives any other change_cipher_spec value or which receives a protected change_cipher_spec record MUST abort the handshake with an ""unexpected_message"" alert.",269,Fully Matches,"[{'C1': {'code': 'if (s->init_num != 0 || readbytes != 1 || p[0] != SSL3_MT_CCS) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_BAD_CHANGE_CIPHER_SPEC);\n    return 0;\n}', 'explanation': ""This code verifies that a change_cipher_spec record consists solely of a single byte with the expected value (SSL3_MT_CCS). Any deviation (i.e. receiving any other change_cipher_spec value) immediately triggers an abort of the handshake with an 'unexpected_message' alert as mandated by the RFC.""}}, {'A1': {'code': 'if (recvd_type == SSL3_RT_CHANGE_CIPHER_SPEC) { ... } else if (recvd_type != SSL3_RT_HANDSHAKE) {\n    SSLfatal(s, SSL_AD_UNEXPECTED_MESSAGE, SSL_R_CCS_RECEIVED_EARLY);\n    return 0;\n}', 'explanation': ""The function not only checks the content of a change_cipher_spec record but also ensures that if any record of type change_cipher_spec is received at an unexpected time (for example, a protected one or one received when not expected), the handshake is aborted with an 'unexpected_message' alert.""}}]","The tls_get_message_header function explicitly handles change_cipher_spec records in accordance with the TLS RFC. It checks that any change_cipher_spec record is unencrypted, exactly one byte in length, and contains the expected value. If the record deviates from these requirements or a change_cipher_spec appears when a handshake record is expected, the function aborts the handshake with an 'unexpected_message' alert. This directly addresses the RFC specification that any other change_cipher_spec value or a protected change_cipher_spec record must result in an abort, thus the function fully meets the given specification constraints by itself.",success,
14231,tls_get_message_header,Servers operating statelessly MUST ignore these records.,80,Fully Matches,"[{'C1': {'code': 'if (recvd_type == SSL3_RT_CHANGE_CIPHER_SPEC) {\n    ...\n    if (s->statem.hand_state == TLS_ST_BEFORE && (s->s3.flags & TLS1_FLAGS_STATELESS) != 0) {\n        /* We are stateless and we received a CCS. Probably this is\n         * from a client between the first and second ClientHellos.\n         * We should ignore this, but return an error because we do\n         * not return success until we see the second ClientHello\n         * with a valid cookie. */\n        return 0;\n    }\n    ...\n}', 'explanation': 'This code segment checks if a ChangeCipherSpec record is received and, when the server is operating statelessly (indicated by TLS_ST_BEFORE and the TLS1_FLAGS_STATELESS flag), it immediately returns 0, effectively ignoring the record as required by the spec.'}}]","The function explicitly identifies ChangeCipherSpec records and includes a conditional check for a stateless server state. When operating statelessly and receiving such a record, it returns 0 without processing it further, which is in direct accordance with the TLS RFC requirement that servers operating statelessly must ignore these records.",success,
14232,tls_get_message_body,An implementation may receive an unencrypted record of type change_cipher_spec consisting of the single byte value 0x01 at any time after the first ClientHello message has been sent or received and before the peer's Finished message has been received and MUST simply drop it without further processing.,268,Partially Matches,"[{'C1': {'code': ""if (s->s3.tmp.message_type == SSL3_MT_CHANGE_CIPHER_SPEC) {\n    /* We've already read everything in */\n    *len = (unsigned long)s->init_num;\n    return 1;\n}"", 'explanation': ""This segment checks if the message type is 'change_cipher_spec' and, if so, bypasses normal processing. This behavior is in line with the RFC requirement of not processing a change_cipher_spec record further. However, it does not validate that the record contains the expected single byte (0x01) nor does it enforce aborting the handshake if other values are received.""}}]","The function does include logic to detect a change_cipher_spec record and avoid further processing for it, which partially addresses the RFC requirement. However, it does not check the payload value (ensuring it is exclusively 0x01) or handle cases of protected change_cipher_spec records or unexpected values. Therefore, the implementation only partially matches the RFC specification.",success,
14242,ssl_choose_server_version,"Any endpoint receiving a Hello message with ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 MUST abort the handshake with a ""protocol_version"" alert.",396,Partially Matches,"[{'C1': {'code': 'if (client_version <= SSL3_VERSION)\n            return SSL_R_BAD_LEGACY_VERSION;', 'explanation': ""This code snippet checks if the ClientHello.legacy_version is less than or equal to SSL3_VERSION (0x0300) and aborts the handshake accordingly. This directly addresses the RFC requirement that any Hello message with a legacy_version of 0x0300 must cause termination via an error (which is later translated to a 'protocol_version' alert).""}}]","The function implements a check that explicitly aborts the handshake when the legacy version in the Hello message is detected to be SSL3 (0x0300) or lower. This directly corresponds to the RFC requirement. However, the check is applied only in the branch where the supported_versions extension is present and the connection is not DTLS. When the extension is absent, the function instead falls through to a version selection loop that eventually rejects the version (by returning an error code such as SSL_R_VERSION_TOO_LOW), but does not explicitly perform the legacy version check. Thus, while the critical part of the RFC is implemented in one code path, the function does not uniformly address all cases solely within its own logic, leading to a partial match.",success,
14242,ssl_choose_server_version,Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less.,395,Partially Matches,"[{'C1': {'code': 'if (client_version <= SSL3_VERSION)\n    return SSL_R_BAD_LEGACY_VERSION;', 'explanation': 'This code segment checks if the ClientHello.legacy_version is less than or equal to SSL3_VERSION (i.e. 0x0300) and aborts the handshake by returning an error. This addresses the RFC requirement that a Hello message with a legacy_version set to 0x0300 or less must lead to termination of the handshake.'}}]","The function implements a check that aborts the handshake when the client's legacy version is 0x0300 or lower, thereby preventing the use of a legacy version that is forbidden by the specification. However, the RFC also mandates that implementations must not send a legacy version of 0x0300 or less in outgoing messages, and this sending behavior is not handled within this function. Therefore, only part of the specification is addressed directly in the code function.",success,
14242,ssl_choose_server_version,Implementations MUST NOT negotiate TLS 1.3 or later using an SSL version 2.0 compatible CLIENT-HELLO.,394,Partially Matches,"[{'C1': {'code': 'if (client_version <= SSL3_VERSION)\n            return SSL_R_BAD_LEGACY_VERSION;', 'explanation': 'This check ensures that if the ClientHello.legacy_version is SSLv3 (0x0300) or lower, the handshake is aborted. This enforces the requirement that a legacy SSLv2‐compatible ClientHello (which would carry a too low legacy version) is not accepted.'}}, {'A1': {'code': 'if (ssl_version_cmp(s, client_version, TLS1_3_VERSION) >= 0)\n        client_version = TLS1_2_VERSION;', 'explanation': 'In the absence of the supported versions extension (which is mandatory for negotiating TLS 1.3), this code forces the negotiation to TLS 1.2, thereby preventing TLS 1.3 or later from being negotiated using a ClientHello that may be SSLv2‐compatible.'}}]","The function includes explicit checks to validate the ClientHello.legacy_version field and to enforce a fallback to TLS 1.2 when the supported versions extension is missing. These code segments partially address the specified TLS RFC requirement that implementations MUST NOT negotiate TLS 1.3 or later using an SSL version 2.0 compatible CLIENT-HELLO. However, while the function directly rejects messages with legacy_version <= SSL3_VERSION and forces TLS 1.2 negotiation in certain cases, it does not cover all aspects of the specification (e.g. complete handling of SSLv2 compatibility in every negotiation scenario) solely within its own logic.",success,
14242,ssl_choose_server_version,"If the ""supported_versions"" extension is absent and the server only supports versions greater than ClientHello.legacy_version, the server MUST abort the handshake with a ""protocol_version"" alert.",382,Fully Matches,"[{'C1': {'code': ""/* If the supported versions extension isn't present, then the highest\n * version we can negotiate is TLSv1.2 */\nif (ssl_version_cmp(s, client_version, TLS1_3_VERSION) >= 0)\n    client_version = TLS1_2_VERSION;\n\nfor (vent = table; vent->version != 0; ++vent) {\n    if (vent->smeth == NULL ||\n        ssl_version_cmp(s, client_version, vent->version) < 0)\n        continue;\n    ...\n}\nreturn disabled ? SSL_R_UNSUPPORTED_PROTOCOL : SSL_R_VERSION_TOO_LOW;"", 'explanation': 'This block is reached when the supported_versions extension is absent. It limits the maximum negotiable version to TLS1.2 and, in the for‑loop, only selects candidate versions that do not exceed the client’s legacy version. This satisfies the condition where, if the extension is absent, the server must not negotiate a version higher than what is presented by ClientHello.legacy_version.'}}, {'A1': {'code': 'return disabled ? SSL_R_UNSUPPORTED_PROTOCOL : SSL_R_VERSION_TOO_LOW;', 'explanation': ""If no candidate version is found (i.e. the server only supports versions greater than ClientHello.legacy_version), the function aborts the handshake by returning an error, which maps to sending a 'protocol_version' alert. This fulfills the action requirement as per the RFC.""}}]","The function distinguishes whether the supported_versions extension is present. In its absence, it limits negotiated version to TLS1.2 (thereby using min(ClientHello.legacy_version, TLS1.2)) and iterates over a table of supported versions. If no suitable version is found—that is, if the server only supports versions higher than ClientHello.legacy_version—it aborts the handshake by returning an error code (SSL_R_UNSUPPORTED_PROTOCOL or SSL_R_VERSION_TOO_LOW) that corresponds to a protocol_version alert. This logic clearly and directly implements the RFC requirement.",success,
14242,ssl_choose_server_version,"If the ""supported_versions"" extension is not present, the server MUST negotiate the minimum of ClientHello.legacy_version and TLS 1.2.",381,Fully Matches,"[{'C1': {'code': ""/*\n     * If the supported versions extension isn't present, then the highest\n     * version we can negotiate is TLSv1.2\n     */\n    if (ssl_version_cmp(s, client_version, TLS1_3_VERSION) >= 0)\n        client_version = TLS1_2_VERSION;"", 'explanation': 'This code detects that the supported_versions extension is absent (i.e. when suppversions->present is false) and enforces that the client version is capped at TLS 1.2. This is equivalent to selecting the minimum of ClientHello.legacy_version and TLS 1.2.'}}, {'A1': {'code': 'for (vent = table; vent->version != 0; ++vent) {\n    if (vent->smeth == NULL ||\n        ssl_version_cmp(s, client_version, vent->version) < 0)\n        continue;\n    method = vent->smeth();\n    if (ssl_method_error(s, method) == 0) {\n        check_for_downgrade(s, vent->version, dgrd);\n        s->version = vent->version;\n        ssl->method = method;\n        if (!ssl_set_record_protocol_version(s, s->version))\n            return ERR_R_INTERNAL_ERROR;\n\n        return 0;\n    }\n    disabled = 1;\n}', 'explanation': 'Once the client_version is potentially adjusted to TLS1_2 (if necessary), the loop iterates over available protocol versions, effectively negotiating a version that is the minimum of the provided legacy version and TLS 1.2. If no acceptable version is found, an error is returned. This implements the action required by the spec when the supported_versions extension is absent.'}}]","The function first checks for the presence of the supported_versions extension. When the extension is absent, it explicitly adjusts the client_version by enforcing that any value higher than TLS1_2 is reduced to TLS1_2, thereby implementing the selection of the minimum of ClientHello.legacy_version and TLS 1.2. The subsequent loop then negotiates the protocol version according to the available methods. This directly corresponds to the provided RFC specification and its constraints, and therefore the function fully addresses the requirement.",success,
14242,ssl_choose_server_version,"If the ""supported_versions"" extension is present, the server MUST negotiate using that extension as described in Section 4.2.1.",380,Fully Matches,"[{'C1': {'code': 'suppversions = &hello->pre_proc_exts[TLSEXT_IDX_supported_versions];\n...\nif (suppversions->present && !SSL_CONNECTION_IS_DTLS(s)) {\n    ... // parse supported_versions extension\n    if (!PACKET_as_length_prefixed_1(&suppversions->data, &versionslist)) {\n        return SSL_R_LENGTH_MISMATCH;\n    }\n    ...\n    while (PACKET_get_net_2(&versionslist, &candidate_vers)) {\n         if (ssl_version_cmp(s, candidate_vers, best_vers) <= 0)\n             continue;\n         if (ssl_version_supported(s, candidate_vers, &best_method))\n             best_vers = candidate_vers;\n    }\n    ...\n    if (best_vers > 0) {\n         if (s->hello_retry_request != SSL_HRR_NONE) {\n             if (best_vers != TLS1_3_VERSION)\n                 return SSL_R_UNSUPPORTED_PROTOCOL;\n             return 0;\n         }\n         check_for_downgrade(s, best_vers, dgrd);\n         s->version = best_vers;\n         ssl->method = best_method;\n         if (!ssl_set_record_protocol_version(s, best_vers))\n             return ERR_R_INTERNAL_ERROR;\n         return 0;\n    }\n    return SSL_R_UNSUPPORTED_PROTOCOL;\n}', 'explanation': ""This code block checks if the 'supported_versions' extension is present. If it is, the function parses the extension, iterates over the client-provided version list, selects the best supported version, and applies downgrade checks. This directly implements the requirement from the TLS RFC to negotiate using the 'supported_versions' extension as described in Section 4.2.1.""}}, {'A1': {'code': 'if (!suppversions->present && s->hello_retry_request != SSL_HRR_NONE)\n    return SSL_R_UNSUPPORTED_PROTOCOL;\n...\nif (ssl_version_cmp(s, client_version, TLS1_3_VERSION) >= 0)\n    client_version = TLS1_2_VERSION;\n...\nfor (vent = table; vent->version != 0; ++vent) {\n    if (vent->smeth == NULL ||\n        ssl_version_cmp(s, client_version, vent->version) < 0)\n        continue;\n    method = vent->smeth();\n    if (ssl_method_error(s, method) == 0) {\n        check_for_downgrade(s, vent->version, dgrd);\n        s->version = vent->version;\n        ssl->method = method;\n        if (!ssl_set_record_protocol_version(s, s->version))\n            return ERR_R_INTERNAL_ERROR;\n\n        return 0;\n    }\n    disabled = 1;\n}', 'explanation': 'This part of the function handles the case when the supported_versions extension is absent. It ensures that if the extension is not present, the server falls back to negotiating TLS versions using the ClientHello.legacy_version, defaulting to a maximum of TLS1.2 as per the RFC specification. This meets the required fallback behavior described in the spec.'}}]","The function 'ssl_choose_server_version' visibly implements the TLS RFC requirement for negotiating the TLS version based on the presence of the 'supported_versions' extension. It checks for the extension, parses its content, selects the best supported candidate version, and appropriately sets the negotiated version and downgrade state. Additionally, it provides a fallback negotiation mechanism when the extension is absent, conforming to the behavior outlined in the specification. Therefore, the function fully matches the listed conditions and actions specified in the RFC constraint.",success,
14242,ssl_choose_server_version,-TLS 1.2 ClientHellos MAY omit this extension.,99,Fully Matches,"[{'C1': {'code': ""/* If the supported versions extension isn't present, then the highest\n * version we can negotiate is TLSv1.2\n */\nif (ssl_version_cmp(s, client_version, TLS1_3_VERSION) >= 0)\n    client_version = TLS1_2_VERSION;\n\n/* No supported versions extension, so we just use the version supplied in\n * the ClientHello. */"", 'explanation': 'The RFC specifies that TLS 1.2 ClientHellos may omit the supported_versions extension. In the absence of the extension, the code adjusts client_version to TLS1_2_VERSION, thereby correctly handling a TLS 1.2 ClientHello that omits the extension.'}}]","The function clearly implements logic to support TLS 1.2 ClientHellos that omit the supported_versions extension by falling back to TLS1.2 when the extension is not provided. This logic meets the specific RFC requirement. Other aspects mentioned in the context regarding TLS 1.2 (such as the handling of hash/signature pairs and deprecation warnings) are not part of this function’s responsibility, and thus do not affect the evaluation of this specific constraint.",success,
14242,ssl_choose_server_version,"If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later.",65,Fully Matches,"[{'C1': {'code': 'if (ssl_version_cmp(s, client_version, TLS1_3_VERSION) >= 0)\n    client_version = TLS1_2_VERSION;', 'explanation': 'This segment ensures that when the supported_versions extension is not present, even if ClientHello.legacy_version indicates TLS1.3 or later, the client_version is capped at TLS1.2. This directly implements the RFC requirement that servers must negotiate TLS 1.2 or prior in this case.'}}, {'A1': {'code': 'if (suppversions->present && !SSL_CONNECTION_IS_DTLS(s)) {\n    ...\n    while (PACKET_get_net_2(&versionslist, &candidate_vers)) {\n        ...\n    }\n    ...\n}', 'explanation': 'In the branch where the supported_versions extension is present, the code completely bypasses the legacy_version for version negotiation. It parses the extension’s version list and selects the best candidate version, thereby enforcing the requirement that the legacy_version should not be used when the extension is provided.'}}]","The function clearly distinguishes between cases where the supported_versions extension is present and not present. In the absence of the extension, it forces negotiation to TLS1.2 or lower (fulfilling C1), and when the extension is present, it ignores ClientHello.legacy_version and bases the decision solely on the extension’s version list (fulfilling A1). Therefore, the code function visibly addresses all the specified constraints as per the RFC.",success,
14242,ssl_choose_server_version,Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.,66,Fully Matches,"[{'C1': {'code': '/* No supported_versions extension case */\nif (ssl_version_cmp(s, client_version, TLS1_3_VERSION) >= 0)\n    client_version = TLS1_2_VERSION;', 'explanation': ""The spec states that if the supported_versions extension is not present, servers must negotiate TLS 1.2 (or lower) even if ClientHello.legacy_version is 0x0304 or later. This code branch detects when the legacy_version is at or above TLS1_3_VERSION and resets it to TLS1_2_VERSION, thereby complying with the specification. This is one acceptable behavior (instead of aborting) since the spec uses 'MAY abort' and allows alternative compliant actions.""}}, {'A1': {'code': 'if (suppversions->present && !SSL_CONNECTION_IS_DTLS(s)) {\n    ...\n    while (PACKET_get_net_2(&versionslist, &candidate_vers)) {\n         if (ssl_version_cmp(s, candidate_vers, best_vers) <= 0)\n             continue;\n         if (ssl_version_supported(s, candidate_vers, &best_method))\n             best_vers = candidate_vers;\n    }\n    ...\n    s->version = best_vers;\n    ssl->method = best_method;\n    ...\n    return 0;\n}', 'explanation': 'When the supported_versions extension is present, the code parses the list provided by the client and selects the highest (best) supported version from that list for the handshake. This strictly follows the specification requirement to use only the versions from the supported_versions extension for negotiation.'}}]","The function implements TLS version negotiation in line with the TLS 1.3 specification. It distinguishes between the case when the supported_versions extension is present (by selecting a version from the extension) and when it is absent (by downgrading to TLS 1.2 if the legacy_version is TLS 1.3 or later). Since the spec allows servers to either abort the handshake or choose a negotiation strategy (the spec says 'MAY abort'), the chosen behavior of negotiating TLS1.2 is compliant. Therefore, the code fully addresses the relevant spec constraints by itself.",success,
14242,ssl_choose_server_version,Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2.,69,Fully Matches,"[{'C1': {'code': 'if (ssl_version_cmp(s, client_version, TLS1_3_VERSION) >= 0)\n    client_version = TLS1_2_VERSION;', 'explanation': 'This code segment implements the requirement that when the supported_versions extension is not present, the server limits negotiation to TLS1.2. It effectively downgrades the client_version to TLS1_2_VERSION when the legacy version appears to be TLS1.3 or higher.'}}, {'A1': {'code': 'if (suppversions->present && !SSL_CONNECTION_IS_DTLS(s)) {\n    ...\n    while (PACKET_get_net_2(&versionslist, &candidate_vers)) {\n         if (ssl_version_cmp(s, candidate_vers, best_vers) <= 0)\n             continue;\n         if (ssl_version_supported(s, candidate_vers, &best_method))\n             best_vers = candidate_vers;\n    }\n    ...\n}', 'explanation': ""This segment shows that if the supported_versions extension is present then the function parses and selects the best version from the provided list. This matches the spec's mandate to use only the supported_versions extension for version negotiation when it is present.""}}]","The function implements the key aspects of the TLS 1.3 version negotiation as specified. It uses the presence or absence of the supported_versions extension to determine the negotiation path: if the extension is absent it forces the client version to TLS1.2 (meeting the spec that prior versions should be supported), and if it is present, it exclusively uses that extension to determine the negotiated version. Thus, within its own logic, the function visibly addresses the identified spec constraints.",success,
14242,ssl_choose_server_version,"If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences.",67,Fully Matches,"[{'C1': {'code': 'if (suppversions->present && !SSL_CONNECTION_IS_DTLS(s)) { ... while (PACKET_get_net_2(&versionslist, &candidate_vers)) { ... } }', 'explanation': 'This block checks if the supported_versions extension is present and, if so, parses the list of candidate versions and selects the appropriate version. It does not rely on hello->legacy_version for version negotiation, thus fulfilling the spec requirement to ignore ClientHello.legacy_version when the extension is present.'}}, {'A1': {'code': 'if (ssl_version_cmp(s, client_version, TLS1_3_VERSION) >= 0)\n    client_version = TLS1_2_VERSION;', 'explanation': 'When the supported_versions extension is absent, the function limits the client_version to TLS1.2 if the legacy version indicates TLS1.3 or later, which directly implements the requirement to negotiate TLS1.2 or lower in this case.'}}]","The function distinguishes based on the presence or absence of the supported_versions extension as required by the specification. When the extension is present, it ignores the legacy_version field and instead negotiates a version solely from the provided supported_versions list. When the extension is absent, it adjusts the legacy_version to TLS1.2 if needed, ensuring that only TLS1.2 or earlier is negotiated. This behavior directly matches the RFC spec constraints regarding version negotiation.",success,
14243,ssl_choose_client_version,"If the ""supported_versions"" extension is absent and the server only supports versions greater than ClientHello.legacy_version, the server MUST abort the handshake with a ""protocol_version"" alert.",382,Partially Matches,[],"The RFC requires that if the supported_versions extension is absent and the server only supports versions higher than ClientHello.legacy_version then the handshake must be aborted with a protocol_version alert. In the function, tls_parse_extension is called and if it returns false the function immediately resets s->version and returns 0. While the code does perform various version range checks (e.g., via ssl_get_min_max_version and subsequent ssl_version_cmp checks that lead to SSLfatal calls with SSL_AD_PROTOCOL_VERSION), it does not explicitly inspect the case where the supported_versions extension is absent combined with the server only supporting higher versions. There is no visible code that, upon absence of the extension, verifies whether the server’s supported versions are all above the legacy version and then aborts with a protocol_version alert. Therefore, although the function performs some version compatibility checks and does abort under version mismatches, it does not fully implement the specific behavior detailed in the RFC spec. Dependencies like tls_parse_extension might handle some of this logic, but based solely on the logic inside this function, only parts of the spec constraints are addressed.",success,
14243,ssl_choose_client_version,"If the ""supported_versions"" extension is present, the server MUST negotiate using that extension as described in Section 4.2.1.",380,Partially Matches,"[{'C1': {'code': '/* This will overwrite s->version if the extension is present */\nif (!tls_parse_extension(s, TLSEXT_IDX_supported_versions,\n                         SSL_EXT_TLS1_2_SERVER_HELLO | SSL_EXT_TLS1_3_SERVER_HELLO, extensions,\n                         NULL, 0)) {\n    s->version = origv;\n    return 0;\n}', 'explanation': 'This segment checks for the presence of the supported_versions extension and—if found—allows the extension to modify s->version. This matches the RFC requirement that if the supported_versions extension is present, the server must negotiate using that extension. However, the rest of the code does not cover negotiation when the extension is absent (i.e. the fallback logic), so only part of the spec is implemented here.'}}]","The function clearly inspects and uses the supported_versions extension (as per the condition in the RFC) via the call to tls_parse_extension, which overwrites s->version accordingly. However, it does not implement the full negotiation behavior required when the extension is absent (for instance, negotiating based on the minimum of legacy_version and TLS 1.2), nor does it explicitly follow Section 4.2.1 details beyond deferring to tls_parse_extension. Therefore, while the function addresses the extension presence part, it only partially implements the complete spec constraint.",success,
14243,ssl_choose_client_version,"If the version chosen by the server is not supported by the client (or is not acceptable), the client MUST abort the handshake with a ""protocol_version"" alert.",379,Fully Matches,"[{'C1': {'code': 'if (ssl_version_cmp(s, s->version, ver_min) < 0 || ssl_version_cmp(s, s->version, ver_max) > 0) {\n    s->version = origv;\n    SSLfatal(s, SSL_AD_PROTOCOL_VERSION, SSL_R_UNSUPPORTED_PROTOCOL);\n    return 0;\n}', 'explanation': ""This block checks whether the version chosen by the server is outside the client's supported range and, if so, aborts the handshake.""}}, {'A1': {'code': 'SSLfatal(s, SSL_AD_PROTOCOL_VERSION, SSL_R_UNSUPPORTED_PROTOCOL);\n// and similarly\nif (s->hello_retry_request != SSL_HRR_NONE && s->version != TLS1_3_VERSION) {\n    s->version = origv;\n    SSLfatal(s, SSL_AD_PROTOCOL_VERSION, SSL_R_WRONG_SSL_VERSION);\n    return 0;\n}', 'explanation': ""These calls abort the handshake, issuing a 'protocol_version' alert as required by the specification.""}}]","The function implements the TLS RFC constraint by verifying that the server‐selected version is within the allowed range. Upon detecting an unsupported or unacceptable version, it immediately aborts the handshake by calling SSLfatal with the protocol_version alert. This logic is contained entirely within the function_body, thus fully matching the spec requirements.",success,
14243,ssl_choose_client_version,"If a match is found, the client MUST abort the handshake with an ""illegal_parameter"" alert.",43,Fully Matches,"[{'C1': {'code': 'if (s->version == TLS1_2_VERSION && real_max > s->version) {\n    if (memcmp(tls12downgrade,\n               s->s3.server_random + SSL3_RANDOM_SIZE - sizeof(tls12downgrade),\n               sizeof(tls12downgrade)) == 0) {\n        s->version = origv;\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INAPPROPRIATE_FALLBACK);\n        return 0;\n    }\n}', 'explanation': ""This segment verifies that when the negotiated version is TLS1.2 (and there is a higher possible version), it checks if the last bytes of the ServerHello.random match the TLS1.2 downgrade marker. If a match is detected, it aborts the handshake with an 'illegal_parameter' alert.""}}, {'C2': {'code': 'else if (!SSL_CONNECTION_IS_DTLS(s) && s->version < TLS1_2_VERSION && real_max > s->version) {\n    if (memcmp(tls11downgrade,\n               s->s3.server_random + SSL3_RANDOM_SIZE - sizeof(tls11downgrade),\n               sizeof(tls11downgrade)) == 0) {\n        s->version = origv;\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INAPPROPRIATE_FALLBACK);\n        return 0;\n    }\n}', 'explanation': ""This branch handles the case for TLS versions below 1.2. It checks the ServerHello.random for the TLS1.1 (or below) downgrade marker, and if found, aborts the handshake with an 'illegal_parameter' alert.""}}, {'A1': {'code': 's->version = origv;\nSSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INAPPROPRIATE_FALLBACK);\nreturn 0;', 'explanation': 'Both downgrade checks use this code to abort the handshake by resetting the negotiated version and calling SSLfatal with the illegal_parameter alert, complying with the spec action.'}}]","The function ssl_choose_client_version implements explicit checks for downgrade markers by comparing the last bytes of the ServerHello.random against predefined markers (tls12downgrade and tls11downgrade) for TLS 1.2 and for older TLS versions respectively. When a match is found, the function correctly aborts the handshake using SSLfatal with an 'illegal_parameter' alert. This directly reflects the spec constraint stating that if a match is found, the client must abort the handshake. Thus, the function fully matches the described specification.",success,
14243,ssl_choose_client_version,TLS 1.2 clients SHOULD also check that the last 8 bytes are not equal to the second value if the ServerHello indicates TLS 1.1 or below.,42,Fully Matches,"[{'C1': {'code': 'else if (!SSL_CONNECTION_IS_DTLS(s)\n           && s->version < TLS1_2_VERSION\n           && real_max > s->version) {\n        if (memcmp(tls11downgrade,\n                   s->s3.server_random + SSL3_RANDOM_SIZE - sizeof(tls11downgrade),\n                   sizeof(tls11downgrade)) == 0) {\n            s->version = origv;\n            SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INAPPROPRIATE_FALLBACK);\n            return 0;\n        }\n    }', 'explanation': 'This code block checks that when the negotiated version is TLS 1.1 or below (i.e. s->version < TLS1_2_VERSION), the last 8 bytes of server_random do not equal the downgrade marker (tls11downgrade). This directly addresses the condition from the spec that TLS 1.2 clients SHOULD check the random value when the ServerHello indicates TLS 1.1 or below.'}}, {'A1': {'code': 's->version = origv;\nSSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INAPPROPRIATE_FALLBACK);\nreturn 0;', 'explanation': ""Upon detecting a matching downgrade marker, this snippet aborts the handshake with an 'illegal_parameter' alert, fulfilling the spec’s action requirement to terminate the connection if the check fails.""}}]","The function 'ssl_choose_client_version' contains explicit logic that compares the last eight bytes of the ServerHello.random value against a known downgrade marker for TLS 1.1 and below (and similarly for TLS 1.2). When a match is found, it aborts the handshake with an appropriate alert. This implements the required RFC downgrade protection check entirely within the function, thereby fully matching the relevant spec constraint.",success,
14243,ssl_choose_client_version,TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below MUST check that the last 8 bytes are not equal to either of these values.,41,Fully Matches,"[{'C1': {'code': 'if (s->version == TLS1_2_VERSION && real_max > s->version) {\n    if (memcmp(tls12downgrade,\n               s->s3.server_random + SSL3_RANDOM_SIZE - sizeof(tls12downgrade),\n               sizeof(tls12downgrade)) == 0) {\n        s->version = origv;\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INAPPROPRIATE_FALLBACK);\n        return 0;\n    }\n}', 'explanation': 'This segment checks that when the negotiated version is TLS1.2 and the maximum allowed version (real_max) is greater, the last 8 bytes of server_random (pointed to by tls12downgrade) do not match the downgrade value. It thus implements the condition that TLS1.3 clients must verify the downgrade marker for TLS1.2 ServerHellos.'}}, {'C2': {'code': 'else if (!SSL_CONNECTION_IS_DTLS(s) && s->version < TLS1_2_VERSION && real_max > s->version) {\n    if (memcmp(tls11downgrade,\n               s->s3.server_random + SSL3_RANDOM_SIZE - sizeof(tls11downgrade),\n               sizeof(tls11downgrade)) == 0) {\n        s->version = origv;\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INAPPROPRIATE_FALLBACK);\n        return 0;\n    }\n}', 'explanation': 'This segment handles cases when the negotiated version is older than TLS1.2. It verifies that the last 8 bytes do not match the TLS1.1 downgrade marker, as required by the specification for TLS1.1 or lower ServerHellos.'}}, {'A1': {'code': 's->version = origv;\nSSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_INAPPROPRIATE_FALLBACK);\nreturn 0;', 'explanation': 'Both the downgrade checks use these lines to abort the handshake with an illegal_parameter alert if a downgrade marker match is detected, fulfilling the action requirement of aborting the connection upon a downgrade attack detection.'}}]","The function ssl_choose_client_version implements the TLS RFC downgrade protection requirement by checking the last 8 bytes of the server_random field. It compares these bytes against the expected downgrade markers for both TLS1.2 (C1) and TLS1.1 or lower (C2). Upon detecting a match, it aborts the handshake by invoking SSLfatal with an illegal_parameter alert (A1). This inline logic directly addresses the specifications for TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below, thereby fully matching the spec constraints.",success,
14243,ssl_choose_client_version,"In particular, it MUST NOT negotiate TLS 1.3.",14,Does Not Match,[],"The specification clearly requires that a server MUST NOT negotiate TLS 1.3 in the renegotiation context and must terminate the connection with an 'unexpected_message' alert when a TLS 1.3 ClientHello is received in any renegotiation scenario. In the provided code, while there is a check for hello retry requests with the condition 'if (s->hello_retry_request != SSL_HRR_NONE && s->version != TLS1_3_VERSION)', this check does not enforce the RFC requirement. In fact, it does not explicitly reject a TLS 1.3 ClientHello during renegotiation; it only triggers an error when the version is not TLS1_3. Additionally, the code does not issue the required 'unexpected_message' alert in any case. Therefore, none of the spec constraints (e.g., C1: ",success,
14243,ssl_choose_client_version,Clients MUST check for this extension prior to processing the rest of the ServerHello (although they will have to,74,Partially Matches,"[{'C1': {'code': 'if (!tls_parse_extension(s, TLSEXT_IDX_supported_versions,\n                             SSL_EXT_TLS1_2_SERVER_HELLO\n                             | SSL_EXT_TLS1_3_SERVER_HELLO, extensions,\n                             NULL, 0)) {\n    s->version = origv;\n    return 0;\n}', 'explanation': 'This segment shows that the function checks for the presence of the supported_versions extension before proceeding with further processing. It implements the requirement that clients must check for this extension prior to processing the rest of the ServerHello.'}}, {'A1': {'code': '/* This will overwrite s->version if the extension is present */', 'explanation': 'By overwriting s->version based on the extension value, the function effectively ignores the legacy version value when the extension is present, in accordance with the specification.'}}]","The function demonstrates logic that checks for and processes the supported_versions extension early on (C1) and ensures that the legacy version is not used when the extension is available (A1). It also performs additional checks (e.g., version range and downgrade prevention). However, not all detailed aspects of the RFC—such as specific handling of versions not offered by the client or explicit parsing of the ServerHello.legacy_version field—are fully contained within this function. Therefore, while some core parts of the RFC behavior are addressed, the implementation in this function only partially meets the complete set of specified constraints.",success,
14243,ssl_choose_client_version,"If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the ""supported_versions"" extension to determine the selected version.",75,Partially Matches,"[{'C1': {'code': 'origv = s->version;\ns->version = version;\n\n/* This will overwrite s->version if the extension is present */\nif (!tls_parse_extension(s, TLSEXT_IDX_supported_versions,\n                         SSL_EXT_TLS1_2_SERVER_HELLO\n                         | SSL_EXT_TLS1_3_SERVER_HELLO, extensions,\n                         NULL, 0)) {\n    s->version = origv;\n    return 0;\n}', 'explanation': 'The RFC specifies that if the supported_versions extension is present, clients must ignore the legacy_version value. In this code, s->version is initially set to the provided version and then tls_parse_extension is invoked; if this extension is present, it overwrites s->version. This indirectly forces the client to ignore the initially provided ServerHello.legacy_version. However, the logic is implicit and depends on tls_parse_extension, without an explicit comment or check solely dedicated to ignoring legacy_version.'}}]","The function shows an attempt to implement the RFC’s requirement regarding the supported_versions extension by invoking tls_parse_extension to overwrite the initial version (thereby ignoring the legacy_version) when the extension is present. However, since the handling of legacy_version is not explicitly isolated within this function and relies on the behavior of tls_parse_extension, the implementation only partially meets the spec constraint.",success,
14243,ssl_choose_client_version,"If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences.",67,Partially Matches,"[{'C1': {'code': '/* This will overwrite s->version if the extension is present */\nif (!tls_parse_extension(s, TLSEXT_IDX_supported_versions,\n                         SSL_EXT_TLS1_2_SERVER_HELLO | SSL_EXT_TLS1_3_SERVER_HELLO,\n                         extensions, NULL, 0)) {\n    s->version = origv;\n    return 0;\n}\n\n... (later, selecting the appropriate version method using the table)', 'explanation': ""This segment shows that if the supported_versions extension is present, the function expects to overwrite s->version (ignoring the initially provided 'version' value, which may correspond to the legacy version). This corresponds with the RFC requirement that when the extension is present, the legacy_version should not be used for version negotiation.""}}]","The function inspects the presence of the supported_versions extension by invoking tls_parse_extension and uses its outcome to overwrite the negotiation version (s->version) if the extension is present. This behavior reflects the RFC constraint that the legacy_version value should be ignored when the extension is available. However, the function does not fully implement all the protocol details specified in the RFC (such as the complete handling of handshake fallback scenarios and specific ServerHello message modifications required in the RFC context). Hence, although it visibly addresses part of the constraint (labeled here as C1), it does not cover every aspect required by the full specification. Therefore, the match is only partial.",success,
14245,ssl_set_client_hello_version,Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less.,395,Partially Matches,"[{'A1': {'code': 'else if (ver_max > TLS1_2_VERSION) {\n    /* TLS1.3 always uses TLS1.2 in the legacy_version field */\n    ver_max = TLS1_2_VERSION;\n}', 'explanation': 'This branch ensures that when a TLS version higher than TLS1.2 (for example TLS1.3) is negotiated, the legacy version field is set to TLS1_2_VERSION (typically 0x0303), which is above 0x0300. This partially meets the spec requirement by protecting the legacy version field in the TLS1.3 case.'}}]","The provided function adjusts the legacy version for TLS1.3 by forcing it to TLS1.2; however, it does not include explicit checks or logic within the function to ensure that a ClientHello.legacy_version or ServerHello.legacy_version is never set to 0x0300 or less in other cases. The safe version determination is delegated to ssl_get_min_max_version, but since only direct logic in this function is considered, it only partially addresses the spec constraint.",success,
14245,ssl_set_client_hello_version,"In TLS 1.3, the client indicates its version preferences in the ""supported_versions"" extension (Section 4.2.1) and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.",15,Fully Matches,"[{'C1': {'code': 'else if (ver_max > TLS1_2_VERSION) {\n    /* TLS1.3 always uses TLS1.2 in the legacy_version field */\n    ver_max = TLS1_2_VERSION;\n}\n\ns->client_version = ver_max;', 'explanation': 'This segment ensures that when the maximum negotiated version exceeds TLS 1.2 (indicating a TLS 1.3 handshake), the legacy_version (stored in s->client_version) is explicitly set to TLS1_2_VERSION (0x0303). This directly complies with the RFC requirement that the legacy_version field MUST be 0x0303 in TLS 1.3 ClientHello messages, meeting the spec constraint.'}}]","The function 'ssl_set_client_hello_version' includes logic that explicitly enforces the legacy_version to be TLS1_2_VERSION (0x0303) when TLS 1.3 is negotiated. Although it does not handle the supported_versions extension, the specified RFC requirement concerning the legacy_version field is fully addressed within this function.",success,
14245,ssl_set_client_hello_version,"In TLS 1.3, the TLS server indicates its version using the ""supported_versions"" extension (Section 4.2.1), and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.",29,Fully Matches,"[{'C1': {'code': 'else if (ver_max > TLS1_2_VERSION) {\n    /* TLS1.3 always uses TLS1.2 in the legacy_version field */\n    ver_max = TLS1_2_VERSION;\n}', 'explanation': 'This code ensures that if the maximum negotiated version exceeds TLS1.2 (as in TLS1.3), the version is forced to TLS1.2. This directly implements the requirement from the RFC that the legacy_version field MUST be set to 0x0303 (TLS1.2), thereby fulfilling the spec constraint.'}}]","The function sets the client_version (legacy_version field) to TLS1.2 when a version higher than TLS1.2 is negotiated. This directly addresses the TLS 1.3 requirement specified in the RFC, independent of other dependencies. All relevant logic is contained within this function, so it fully meets the condition (C1) of the spec.",success,
14248,ca_dn_cmp,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function 'ca_dn_cmp' simply compares two X509_NAME objects using the X509_NAME_cmp function. It does not contain any logic related to handling or processing the status_request_v2 extension or any TLS 1.3 OCSP/CertificateStatus requirements outlined in the spec constraints (e.g., regarding not sending the status_request_v2 extension in EncryptedExtensions, CertificateRequest, or Certificate messages). Therefore, no part of this function addresses any of the labeled conditions or actions specified in the TLS RFC.",success,
14249,parse_ca_names,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Fully Matches,"[{'C1': {'code': 'if (ca_sk == NULL) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_CRYPTO_LIB);\n    goto err;\n}', 'explanation': 'When memory allocation fails for the certificate name stack, the function calls SSLfatal with an internal error alert, which demonstrates the requirement to send an alert upon a fatal error condition.'}}, {'A1': {'code': 'if (!PACKET_get_length_prefixed_2(pkt, &cadns)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}', 'explanation': ""On failure to retrieve the length‐prefixed certificate data, the function sends a decode error alert in accordance with the spec's mandate to send alert X when aborting the handshake.""}}, {'A1': {'code': 'if (!PACKET_get_net_2(&cadns, &name_len) || !PACKET_get_bytes(&cadns, &namebytes, name_len)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}', 'explanation': 'This error branch ensures that if the packet does not contain enough data for the certificate name, the function sends the correct fatal alert. This satisfies the requirement that any fatal error condition leads to sending the specified alert.'}}, {'A1': {'code': 'if ((xn = d2i_X509_NAME(NULL, &namebytes, name_len)) == NULL) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, ERR_R_ASN1_LIB);\n    goto err;\n}', 'explanation': 'A failure to decode the certificate name triggers a fatal alert using the decode error alert code, matching the RFC directive to send the specific alert when an error is encountered.'}}, {'A1': {'code': 'if (namebytes != (namestart + name_len)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_CA_DN_LENGTH_MISMATCH);\n    goto err;\n}', 'explanation': 'When the decoded length does not match the expected length, the function sends a fatal alert for length mismatch, which complies with the requirement to send a particular alert on error.'}}, {'A1': {'code': 'if (!sk_X509_NAME_push(ca_sk, xn)) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_CRYPTO_LIB);\n    goto err;\n}', 'explanation': 'In the event of a failure to push the decoded certificate name into the stack, the function sends an internal error alert, again fulfilling the spec requirement.'}}]","The function 'parse_ca_names' includes multiple error-handling branches where it calls SSLfatal with specific alert codes corresponding to various encountered error conditions. Each error branch in the function sends a fatal alert (using SSL_AD_INTERNAL_ERROR or SSL_AD_DECODE_ERROR with appropriate subcodes) when an error is detected, thereby addressing the TLS RFC specification's directive that when an error condition is encountered (i.e. when terminating the connection or aborting the handshake), the implementation MUST send the specified alert. Given that each error situation is directly handled by sending an alert and then aborting further processing, the function visibly implements the requirement stated in the RFC.",success,
14249,parse_ca_names,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Partially Matches,"[{'A1': {'code': 'if (ca_sk == NULL) {\n    SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_CRYPTO_LIB);\n    goto err;\n}\n\nif (!PACKET_get_length_prefixed_2(pkt, &cadns)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n\nif (!PACKET_get_net_2(&cadns, &name_len) || !PACKET_get_bytes(&cadns, &namebytes, name_len)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}\n\nif ((xn = d2i_X509_NAME(NULL, &namebytes, name_len)) == NULL) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, ERR_R_ASN1_LIB);\n    goto err;\n}\n\nif (namebytes != (namestart + name_len)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_CA_DN_LENGTH_MISMATCH);\n    goto err;\n}', 'explanation': 'Each error case in the function triggers a call to SSLfatal with an appropriate alert (e.g. SSL_AD_DECODE_ERROR, SSL_AD_INTERNAL_ERROR) upon detecting an error. This satisfies the RFC requirement that a fatal alert be sent when an error is detected. However, further actions required by the spec (such as the immediate termination of the connection) are not directly handled in this function.'}}]","The TLS RFC requires that upon detection of a fatal error, the implementation should send an appropriate fatal alert and terminate the connection without additional data exchange. In this function, error conditions are checked during the parsing of CA names, and on each error an SSLfatal call is made to send the proper alert. This shows that the function addresses the RFC's error‐alerting requirement. However, the function itself does not directly terminate the connection (for example, by closing sockets or halting further data transmission) because that is expected to be handled either in SSLfatal or by the caller. Thus, while the function clearly implements the alert-sending aspect (A1), it does not fully implement all aspects (like connection termination) solely within its body, resulting in a partial match.",success,
14249,parse_ca_names,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!PACKET_get_length_prefixed_2(pkt, &cadns)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}', 'explanation': 'This code checks the overall message length and triggers a decode_error alert if the length prefix is incorrect or extends beyond the message boundary, as required by the RFC.'}}, {'A1': {'code': 'if (!PACKET_get_net_2(&cadns, &name_len)\n    || !PACKET_get_bytes(&cadns, &namebytes, name_len)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_LENGTH_MISMATCH);\n    goto err;\n}', 'explanation': 'This segment ensures that each CA name’s length is correctly extracted from the packet. In case of failure to parse (e.g., out-of-range length), the function calls SSLfatal with a decode_error alert.'}}, {'A2': {'code': 'if ((xn = d2i_X509_NAME(NULL, &namebytes, name_len)) == NULL) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, ERR_R_ASN1_LIB);\n    goto err;\n}', 'explanation': 'The function attempts to decode the ASN1 encoded X509_NAME and, upon failure, issues a decode_error alert, which addresses the error handling for syntactic parsing issues.'}}, {'A3': {'code': 'if (namebytes != (namestart + name_len)) {\n    SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_CA_DN_LENGTH_MISMATCH);\n    goto err;\n}', 'explanation': 'After parsing the CA name, this check ensures that the parsed length exactly matches the expected length. A mismatch indicates a parsing error and triggers the decode_error alert.'}}]","The function parse_ca_names implements multiple checks to validate the syntax of incoming messages—specifically, it verifies length fields and proper decoding of ASN1 data. For every failure condition related to message parsing (e.g., length issues, incomplete data, or ASN1 decoding errors), the function calls SSLfatal with the TLS decode_error alert. This behavior directly implements the specified RFC requirement that peers must terminate the connection with a decode_error alert when the message cannot be parsed properly.",success,
14249,parse_ca_names,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The function provided is responsible for parsing CA distinguished names from a packet, and contains no logic related to TLS cipher suite negotiation rules or any checks regarding the prohibition of RC4 cipher suites or low strength ciphers. Therefore, it does not address either of the specified TLS RFC constraints.",success,
14255,tls13_process_compressed_certificate,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'C1': {'code': 'if (buf == NULL) {\n    SSLfatal(sc, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}\n\nif (!PACKET_get_net_2(pkt, (unsigned int*)&comp_alg)) {\n    SSLfatal(sc, SSL_AD_BAD_CERTIFICATE, ERR_R_INTERNAL_ERROR);\n    goto err;\n}\n\n... (other similar error checks calling SSLfatal)', 'explanation': 'The function checks for various error conditions (e.g. a null buffer, malformed packets, unsupported compression algorithms) and calls SSLfatal with specific alert codes (such as SSL_AD_INTERNAL_ERROR, SSL_AD_BAD_CERTIFICATE) before aborting further processing. This reflects the spec mandate that when an error is detected, the implementation MUST send alert X if any alert is to be sent.'}}]","The function implements several error detection checks and, upon encountering errors, calls SSLfatal with specific alert codes. This behavior corresponds to the requirement in the TLS RFC to send a fatal alert (with a predetermined alert code) when terminating the connection. However, while it visibly triggers alert sending via SSLfatal, the function does not itself explicitly handle connection closure (the spec mandates that the connection must immediately close following a fatal alert). Since connection termination is assumed to be handled by SSLfatal or at a higher layer, the function only partially matches the overall specification.",success,
14255,tls13_process_compressed_certificate,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Partially Matches,"[{'C1': {'code': 'if (buf == NULL) {\n    SSLfatal(sc, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}\n...\nif (!PACKET_get_net_2(pkt, (unsigned int*)&comp_alg)) {\n    SSLfatal(sc, SSL_AD_BAD_CERTIFICATE, ERR_R_INTERNAL_ERROR);\n    goto err;\n}\n...\nswitch (comp_alg) {\ncase TLSEXT_comp_cert_zlib:\n    method = COMP_zlib_oneshot();\n    break;\ncase TLSEXT_comp_cert_brotli:\n    method = COMP_brotli_oneshot();\n    break;\ncase TLSEXT_comp_cert_zstd:\n    method = COMP_zstd_oneshot();\n    break;\ndefault:\n    SSLfatal(sc, SSL_AD_BAD_CERTIFICATE, SSL_R_BAD_COMPRESSION_ALGORITHM);\n    goto err;\n}\n...\nif ((comp = COMP_CTX_new(method)) == NULL || !PACKET_get_net_3_len(pkt, &expected_length) || !PACKET_get_net_3_len(pkt, &comp_length)) {\n    SSLfatal(sc, SSL_AD_BAD_CERTIFICATE, SSL_R_BAD_DECOMPRESSION);\n    goto err;\n}\n...\nif (!BUF_MEM_grow(buf, expected_length) || \n    !PACKET_buf_init(tmppkt, (unsigned char *)buf->data, expected_length) || \n    COMP_expand_block(comp, (unsigned char *)buf->data, expected_length,\n                       (unsigned char*)PACKET_data(pkt), comp_length) != (int)expected_length) {\n    SSLfatal(sc, SSL_AD_BAD_CERTIFICATE, SSL_R_BAD_DECOMPRESSION);\n    goto err;\n}', 'explanation': 'The function checks for various error conditions (e.g., null input, mismatched lengths, unsupported compression algorithms) and calls SSLfatal() with a specific alert code. This behavior reflects the requirement of notifying a peer with a fatal alert during error conditions as stated in the spec context.'}}]","The function visibly implements error handling by detecting multiple conditions where something is wrong and then calling SSLfatal(), which is assumed to send the appropriate fatal alert according to the RFC. However, while it addresses sending alerts upon error detection, the function itself does not explicitly handle the immediate closure of the connection (the termination behavior) as mandated in the specification. This behavior is likely abstracted in SSLfatal() or handled by the caller, so in isolation the function only partially matches the complete error handling requirement defined in the spec.",success,
14255,tls13_process_compressed_certificate,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'C1': {'code': 'if (sc->cert_comp_prefs[0] != TLSEXT_comp_cert_none) {\n    for (i = 0; sc->cert_comp_prefs[i] != TLSEXT_comp_cert_none; i++) {\n        if (sc->cert_comp_prefs[i] == comp_alg) {\n            found = 1;\n            break;\n        }\n    }\n    if (!found) {\n        SSLfatal(sc, SSL_AD_ILLEGAL_PARAMETER, SSL_R_BAD_COMPRESSION_ALGORITHM);\n        goto err;\n    }\n}', 'explanation': ""This code segment checks if the received compression algorithm is among the permitted ones. If it is not found, it terminates the connection by calling SSLfatal with the 'illegal_parameter' alert, which aligns with the RFC requirement that a semantically invalid message result in an 'illegal_parameter' termination.""}}]","The function partially implements the RFC specification regarding handling semantically invalid messages: it directly verifies the allowed compression algorithms and sends an 'illegal_parameter' alert when the algorithm is not among those permitted. However, the RFC mentions additional potential semantic errors (such as an invalid enum or DHE share value), and the function does not address these other semantic checks. Thus, the implementation is only a partial match.",success,
14255,tls13_process_compressed_certificate,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (PACKET_remaining(pkt) != comp_length || comp_length == 0) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_DECOMPRESSION);\n    goto err;\n}', 'explanation': 'This code segment checks that the packet’s remaining length exactly matches the expected decompressed length (and that comp_length is not zero) before proceeding. If not, it terminates the connection by sending a decode_error alert, which directly addresses the RFC requirement for messages that cannot be parsed according to syntax.'}}, {'A1': {'code': 'SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_DECOMPRESSION);', 'explanation': 'When the packet length does not match the expected length, the function calls SSLfatal with SSL_AD_DECODE_ERROR, ensuring termination with a decode_error alert as mandated by the RFC.'}}]","The code function partially meets the TLS RFC specification. It visibly implements a check for syntactic integrity by verifying that the received packet's length matches the expected decompressed length. In the case of this specific parse failure, it terminates the connection with a decode_error alert (fulfilling conditions C1 and action A1). However, other parsing failures in the function (such as obtaining the compression algorithm or length fields) result in different alerts (e.g., BAD_CERTIFICATE) rather than decode_error. Since the specification mandates that all messages which cannot be parsed according to the syntax must terminate with a decode_error alert, the implementation only partially matches the requirements when considered solely within this function.",success,
14255,tls13_process_compressed_certificate,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Partially Matches,"[{'A1': {'code': 'if (buf == NULL) {\n    SSLfatal(sc, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n    goto err;\n}\n...\nif (!PACKET_get_net_2(pkt, (unsigned int*)&comp_alg)) {\n    SSLfatal(sc, SSL_AD_BAD_CERTIFICATE, ERR_R_INTERNAL_ERROR);\n    goto err;\n}\n...\nif (!ossl_comp_has_alg(comp_alg)) {\n    SSLfatal(sc, SSL_AD_BAD_CERTIFICATE, SSL_R_BAD_COMPRESSION_ALGORITHM);\n    goto err;\n}\n...\nif (!BUF_MEM_grow(buf, expected_length)\n    || !PACKET_buf_init(tmppkt, (unsigned char *)buf->data, expected_length)\n    || COMP_expand_block(comp, (unsigned char *)buf->data, expected_length,\n                         (unsigned char*)PACKET_data(pkt), comp_length) != (int)expected_length) {\n    SSLfatal(sc, SSL_AD_BAD_CERTIFICATE, SSL_R_BAD_DECOMPRESSION);\n    goto err;\n}\n...\nif (PACKET_remaining(pkt) != comp_length || comp_length == 0) {\n    SSLfatal(sc, SSL_AD_DECODE_ERROR, SSL_R_BAD_DECOMPRESSION);\n    goto err;\n}', 'explanation': 'In every error detection branch, the function calls SSLfatal with alert codes (e.g., SSL_AD_BAD_CERTIFICATE, SSL_AD_DECODE_ERROR) that imply a fatal alert is being signaled. This reflects an intent to abide by the RFC’s requirement that alerts (as error alerts) are sent with a fatal level. However, the enforcement of the actual AlertLevel=fatal is encapsulated in the SSLfatal function (i.e. a dependency), and the function itself does not explicitly check received alert levels.'}}]","The RFC requires that all alerts be sent with AlertLevel=fatal and be treated as errors, leading to connection abort. This function triggers SSLfatal on error conditions which is intended to signal fatal alerts and thus abort further processing. While the function’s error paths consistently call SSLfatal with hard‐coded alert codes, meeting the intended behavior, the responsibility to set AlertLevel=fatal is delegated to the SSLfatal function. As a result, the function partially implements the RFC spec within its own logic without independently enforcing all aspects (such as checking or setting alert levels on incoming messages).",success,
