function_id,function_name,sr_content,sr_index,outcome,met_constrains,explanation,status,api_response
7796,ssl_add_tls13_cipher,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function ssl_add_tls13_cipher only checks if a given TLS 1.3 cipher meets the policy and, if so, adds it to a structure. It does not contain any logic addressing the specific RFC6091 requirement that the OpenPGP certificate type MUST NOT be used with TLS 1.3. No part of the code implements any condition (e.g., checking for OpenPGP certificate use) or action related to the spec constraint.",success,
7797,ssl_write_client_cipher_list,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The specified RFC constraint requires that the OpenPGP certificate type must not be used with TLS 1.3. The provided function, ssl_write_client_cipher_list, handles the construction of the client cipher list and the inclusion of TLS 1.3 ciphers, but it does not contain any logic or checks pertaining to OpenPGP certificate types. Since no code in the function directly addresses or prevents the use of the OpenPGP certificate type with TLS 1.3, it does not implement the RFC6091 requirement.",success,
7797,ssl_write_client_cipher_list,"To avoid a downgrade attack, the client SHOULD NOT disable TLS 1.3, only 0-RTT.",385,Fully Matches,"[{'C1': {'code': 'if (hs->max_version >= TLS1_3_VERSION) {\n    …\n    for (auto cipher : ciphers) {\n      if (!ssl_add_tls13_cipher(&child, cipher, ssl->config->compliance_policy)) {\n        return false;\n      }\n    }\n  }', 'explanation': 'This segment unconditionally adds TLS 1.3 cipher suites when the maximum supported version is at least TLS 1.3. It ensures that TLS 1.3 is always enabled, which aligns with the RFC requirement to not disable TLS 1.3.'}}, {'A1': {'code': 'if (hs->min_version < TLS1_3_VERSION && type != ssl_client_hello_inner) {\n    …\n    // Loop over pre-TLS 1.3 ciphers and add them\n    …\n  }', 'explanation': 'By conditionally adding non–TLS 1.3 ciphers only when the handshake is not an inner (0-RTT) ClientHello, the function restricts the disabling behavior to 0-RTT. In doing so, it avoids any inadvertent disabling of TLS 1.3, thus addressing the RFC specification.'}}]","The function explicitly implements the RFC requirement by always including TLS 1.3 cipher suites when available (thereby not disabling TLS 1.3) and by conditionally adding additional ciphers only for non–0-RTT handshakes. This shows that the function is designed to avoid a downgrade attack by not disabling TLS 1.3, fulfilling the specification that only 0-RTT should be disabled if needed.",success,
7798,ssl_write_client_hello_without_extensions,Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.,79,Does Not Match,[],"The RFC constraint requires that clients must not use cookies in their initial ClientHello on subsequent connections and also defines behavior related to the '100-continue' expectation. However, the provided function focuses on constructing a ClientHello message by adding version, random, session ID (in certain circumstances), and cipher list information. It does include logic to add a DTLS cookie if SSL_is_dtls(ssl) returns true, but there is no conditional logic that prevents sending cookies in the initial ClientHello for subsequent connections, nor is there any handling related to a '100-continue' expectation. In summary, the function does not visibly implement any of the specified conditions or actions from the RFC constraints.",success,
7798,ssl_write_client_hello_without_extensions,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest.",59,Does Not Match,[],"The provided function, ssl_write_client_hello_without_extensions, constructs a ClientHello message without adding general extensions. It does not contain any logic that verifies whether the remote endpoint sent corresponding extension requests before sending any extension responses. The only extension-like logic present is the unconditional addition of the DTLS cookie extension (if SSL_is_dtls(ssl) is true), which is based solely on the DTLS condition and not on whether the remote endpoint requested the cookie extension. As a result, it does not visibly address the specification requirement (i.e., not sending extension responses unless the remote endpoint requested them, with the cookie exception in HelloRetryRequest) within its own logic.",success,
7798,ssl_write_client_hello_without_extensions,"A client MUST NOT include the ""early_data"" extension in its followup ClientHello.",148,Fully Matches,"[{'C1': {'code': 'bool ssl_write_client_hello_without_extensions(const SSL_HANDSHAKE *hs, CBB *cbb, ssl_client_hello_type_t type, bool empty_session_id) {\n  const SSL *const ssl = hs->ssl;\n  CBB child;\n  if (!CBB_add_u16(cbb, hs->client_version) ||\n      !CBB_add_bytes(cbb,\n                     type == ssl_client_hello_inner ? hs->inner_client_random\n                                                    : ssl->s3->client_random,\n                     SSL3_RANDOM_SIZE) ||\n      !CBB_add_u8_length_prefixed(cbb, &child)) {\n    return false;\n  }\n  \n  // Do not send a session ID on renegotiation.\n  if (!ssl->s3->initial_handshake_complete &&\n      !empty_session_id &&\n      !CBB_add_bytes(&child, hs->session_id.data(), hs->session_id.size())) {\n    return false;\n  }\n  \n  if (SSL_is_dtls(ssl)) {\n    if (!CBB_add_u8_length_prefixed(cbb, &child) ||\n        !CBB_add_bytes(&child, hs->dtls_cookie.data(),\n                       hs->dtls_cookie.size())) {\n      return false;\n    }\n  }\n  \n  if (!ssl_write_client_cipher_list(hs, cbb, type) ||\n      !CBB_add_u8(cbb, 1 /* one compression method */) ||\n      !CBB_add_u8(cbb, 0 /* null compression */)) {\n    return false;\n  }\n  return true;\n}', 'explanation': ""The function is specifically named 'ssl_write_client_hello_without_extensions' and, as observed in the code, it does not add any extensions whatsoever. This ensures that the early_data extension is not included in the followup ClientHello, thus meeting the RFC requirement.""}}]","The RFC specifies that a client must not include the 'early_data' extension in its followup ClientHello. In this function, no extension-related code (including any logic to add an 'early_data' extension) exists. By not adding any extension, the function intentionally avoids including early_data, which means it fully meets the constraint as required by the RFC.",success,
7798,ssl_write_client_hello_without_extensions,"For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS.",22,Fully Matches,"[{'A1': {'code': 'if (!ssl_write_client_cipher_list(hs, cbb, type) ||\n      !CBB_add_u8(cbb, 1 /* one compression method */) ||\n      !CBB_add_u8(cbb, 0 /* null compression */)) {\n    return false;\n  }', 'explanation': 'The code explicitly writes a single compression method byte (by first writing a length of 1 and then writing the value 0), which directly implements the TLS 1.3 ClientHello requirement.'}}]","The code function visibly meets the TLS 1.3 ClientHello requirement by adding exactly one byte set to 0 for the compression method. The relevant segment uses two calls: one to set the count of compression methods and another to set the compression method to the null value, thereby fully implementing the corresponding specification action within this function.",success,
7799,ssl_add_client_hello,Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.,79,Does Not Match,[],"The provided function is responsible for constructing a TLS ClientHello message and does not include any logic related to the RFC specification that mandates clients MUST NOT use cookies in their initial ClientHello in subsequent connections. There is no code segment in function_body that checks for or omits cookies from the ClientHello message, nor does it enforce any aspect of the cookie requirement specified. The function only builds and finalizes the ClientHello message without addressing the specified cookie handling rule.",success,
7800,parse_server_version,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!CBS_get_u16(&supported_versions.data, out_version) ||  \n      CBS_len(&supported_versions.data) != 0) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n  }', 'explanation': 'This segment checks that the supported_versions extension exactly contains one 16-bit value with no extra trailing bytes. If the parsing fails or extra data is present (which indicates a syntactic error), it sets the decode_error alert, thereby addressing the RFC requirement to detect a message that cannot be parsed according to the syntax.'}}, {'A1': {'code': '*out_alert = SSL_AD_DECODE_ERROR;\nreturn false;', 'explanation': 'Upon detecting a parsing error, the function sets the decode_error alert and returns false, which (via its caller) is expected to lead to termination of the connection. This reflects the action mandated by the RFC when encountering a decode error.'}}]","The function partially implements the RFC specification by validating the format of the supported_versions extension and by setting the decode_error alert if an anomaly is detected. While it correctly triggers a decode_error when the parsed message does not match expected syntax (i.e., extra data remains or no proper u16 can be read), it does not fully cover all possible syntactic parsing errors (such as other possible length breaches mentioned in the RFC) solely within this function. Therefore, the implementation only partially matches the RFC constraints.",success,
7800,parse_server_version,"If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later.",65,Partially Matches,"[{'C1': {'code': 'if (!supported_versions.present) {\n    *out_version = server_hello.legacy_version;\n    return true;\n}', 'explanation': 'This code segment implements the behavior required by the RFC: if the supported_versions extension is not present, the function falls back to using the legacy_version field for TLS negotiation. This reflects the mandate that, in absence of the extension, TLS 1.2 (or DTLS 1.2, as determined earlier) or a lower version should be negotiated.'}}]","The function checks the negotiated TLS version by first selecting a baseline version (either TLS1.2 or DTLS1.2) and then comparing it to the server's legacy_version. If they differ, it immediately uses the server-provided legacy_version. It then parses the supported_versions extension and, if not present, again falls back on the legacy_version. This approach addresses the condition described in the RFC specification that if the extension is absent, servers must negotiate TLS 1.2 or prior. However, the code has a comment noting that it does not completely match the RFC8446 formulation (especially regarding cases when ClientHello.legacy_version is 0x0304 or later), so while it implements some of the required behavior, it does not fully implement all aspects of the spec by itself.",success,
7800,parse_server_version,"If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the ""supported_versions"" extension to determine the selected version.",75,Partially Matches,[],"The RFC requirement is that if the supported_versions extension is present, the client MUST completely ignore the legacy_version value and use only the extension to determine the negotiated protocol version. In this function, while there is logic to parse the supported_versions extension (lines dealing with SSLExtension supported_versions and subsequent CBS_get_u16 call), there is also an early branch (if (server_hello.legacy_version != legacy_version)) that causes the function to immediately use the legacy_version value without checking for supported_versions. This behavior does not fully comply with the spec since it does not always ignore the legacy_version value when the extension is present. Therefore, only parts of the constraint (i.e. parsing the extension and using its value when present) are addressed directly in the function, leading to a partial match.",success,
7801,should_offer_early_data,Note that 0-RTT data is not compatible with older servers and SHOULD NOT be sent absent knowledge that the server supports TLS 1.3,378,Fully Matches,"[{'C1': {'code': 'if (hs->max_version < TLS1_3_VERSION || SSL_is_dtls(ssl)) {\n    // We discard inapplicable sessions, so this is redundant with the session\n    // checks below, but reporting that TLS 1.3 was disabled is more useful.\n    return ssl_early_data_protocol_version;\n}', 'explanation': 'This code fragment ensures that 0-RTT data will not be offered unless the negotiated protocol is TLS 1.3 and the connection is not DTLS. This directly enforces the requirement from the spec note that 0-RTT data should not be sent with older servers.'}}]","The function 'should_offer_early_data' explicitly checks that the connection supports TLS 1.3 using a condition on the maximum negotiated version (hs->max_version) as well as ensuring that the connection is not using DTLS. Since the spec mandates that 0-RTT data SHOULD NOT be sent when the server might not support TLS 1.3, this logic fully implements that constraint within the function itself.",success,
7801,should_offer_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The RFC spec requires that a TLS implementation SHOULD NOT automatically resend early data so that application logic can decide when (or whether) to retransmit. The function provided, should_offer_early_data, is solely responsible for checking various conditions to decide whether early data can be offered (e.g., checking protocol version, session presence, ALPN matching, etc.). It does not include any mechanism for automatically resending early data. In other words, all its logic is devoted to determining acceptance of early data rather than handling any retransmission or its prevention. Hence, the function does not attempt to implement the specific RFC condition regarding automatic retransmission of early data.",success,
7801,should_offer_early_data,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Partially Matches,"[{'C1': {'code': 'if (!ssl->enable_early_data) {\n    return ssl_early_data_disabled;\n}', 'explanation': 'This code segment ensures that early data (0-RTT) is only offered when early data is explicitly enabled by the application, which addresses the part of the spec requiring that TLS implementations not enable 0-RTT unless specifically requested.'}}]","The provided function checks whether early data is explicitly enabled (via the ssl->enable_early_data flag) and only then considers offering 0-RTT data. This meets the part of the RFC that mandates 0-RTT should only be enabled when specifically requested by the application (labeled here as C1). However, the RFC also states that TLS implementations MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application. There is no logic within this function handling the case where early data is rejected, meaning that the function does not address all aspects of the RFC. Therefore, the function is considered to partially match the spec.",success,
7802,ssl_done_writing_client_hello,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function only resets various handshake state variables (such as ech_client_outer, cookie, key_share_bytes, and pake_share_bytes) and does not contain any logic to evaluate or enforce the RFC constraints. There is no conditional logic or checks implemented that correspond to any labeled condition (e.g., C1) or action (e.g., A1) specified in the given RFC or spec constraints. The function does not address processing the 'supported_groups' information or comparing modification dates from an If-Unmodified-Since header as described in the spec context. Hence, the function does not visibly address any of the specified constraints.",success,
7803,do_start_connect,Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less.,395,Does Not Match,[],"The RFC specification requires that implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less. In the provided function do_start_connect, while there is logic that selects a client_version based on the maximum supported version (for example, choosing TLS1_2_VERSION if available, or falling back to hs->max_version), there is no explicit check or enforcement ensuring that the legacy_version (the value later used to populate the ClientHello message) is greater than 0x0300. In other words, the function does not visibly address or enforce the condition to prevent sending a legacy version of 0x0300 or less. Any such enforcement might occur in other parts of the codebase (possibly in functions called later), but within the confines of this function’s body, the required check or mechanism is not apparent.",success,
7803,do_start_connect,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'C1': {'code': 'ssl_early_data_reason_t reason = should_offer_early_data(hs);\n  if (reason != ssl_early_data_accepted) {\n    ssl->s3->early_data_reason = reason;\n  } else {\n    hs->early_data_offered = true;\n  }', 'explanation': 'This segment checks whether early data is acceptable and, if so, sets a flag (hs->early_data_offered) instead of automatically resending the early data. There is no logic that retries or resends early data automatically, which aligns with the RFC requirement.'}}]","The TLS handshake function sets a flag to indicate early data is offered only when accepted and does not contain any logic for automatic retransmission of early data. By avoiding any automatic resend behavior, the function conforms with the RFC recommendation that a TLS implementation SHOULD NOT automatically resend early data and leaves the decision to the application.",success,
7803,do_start_connect,"When a client offers resumption via a PSK, it SHOULD also supply a ""key_share"" extension to the server to allow the server to decline resumption and fall back to a full handshake, if needed.",3,Partially Matches,"[{'A1': {'code': 'if (!ssl_setup_key_shares(hs, /*override_group_id=*/0) ||\n      !ssl_setup_extension_permutation(hs) ||\n      !ssl_encrypt_client_hello(hs, Span(ech_enc, ech_enc_len)) ||\n      !ssl_add_client_hello(hs)) {\n    return ssl_hs_error;\n  }', 'explanation': 'This segment unconditionally invokes ssl_setup_key_shares (as well as later extension‐related functions), which appears to add the key_share extension into the ClientHello. According to the spec, when a client offers resumption via a PSK, it SHOULD supply a key_share extension. Although the function always calls these routines regardless of whether a PSK is used, it does address the action of sending the key_share extension, albeit without an explicit check for PSK resumption.'}}]","The provided function incorporates the key_share extension logic through a call to ssl_setup_key_shares (and related functions) as part of building the ClientHello message. This meets the action of including the key_share extension. However, the spec specifically requires that if a client offers resumption via a PSK then the key_share extension should be supplied, and the code does not explicitly condition upon the use of a PSK resumption. Thus, while the key_share extension is always added (thereby partially addressing the spec), the function does not fully reflect the conditional requirement dictated by the spec.",success,
7803,do_start_connect,Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.,79,Does Not Match,[],"The provided function is focused on configuring and executing a TLS handshake (including session resumption, client random generation, ECH configuration, etc.) and does not implement any logic regarding cookies in the initial ClientHello or subsequently. There is no code that addresses the RFC specification that 'Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.' Therefore, no constraint (such as C1 or A1) related to this behavior is implemented within this function.",success,
7803,do_start_connect,"In this mode, the client and server MUST supply ""key_share"" values as described in Section 4.2.8.",142,Fully Matches,"[{'C1': {'code': 'if (!ssl_setup_key_shares(hs, /*override_group_id=*/0) ||\n      !ssl_setup_extension_permutation(hs) ||\n      !ssl_encrypt_client_hello(hs, Span(ech_enc, ech_enc_len)) ||\n      !ssl_add_client_hello(hs)) {\n    return ssl_hs_error;\n  }', 'explanation': 'This segment clearly calls ssl_setup_key_shares (along with related functions) which is responsible for establishing the key_share values as required by Section 4.2.8 of the RFC. Thus, the function directly implements the spec constraint that the client (and by extension the server, in the handshake process) must supply key_share values.'}}]","The function do_start_connect includes an explicit call to ssl_setup_key_shares, ensuring that key_share values are established as mandated by the RFC. Since this key segment within the function independently and visibly addresses the requirement (i.e., the 'MUST supply key_share values'), the function fully implements the specified constraint within its own logic.",success,
7803,do_start_connect,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function 'do_start_connect' does not contain any logic that addresses the RFC specification regarding the handling of the 'supported_groups' information. There is no visible check or condition that prevents acting on 'supported_groups' prior to a successfully completed handshake, nor is there any mechanism to update key_share usage based on handshake outcomes. All logic in the function pertains to initializing handshake parameters such as session setup, client random generation, and key share establishment, but nothing in its body addresses the constraints specified by the RFC regarding 'supported_groups'. Therefore, from the code shown, it does not match any of the labeled constraints.",success,
7804,do_enter_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The RFC specification requires that a TLS implementation SHOULD NOT automatically resend early data, meaning that the decision to retransmit early data should be left to the application. In the provided function, the logic only checks whether early data was offered and then sets some session parameters and state flags. It does not include any explicit handling or decision-making process regarding the automatic retransmission of early data. As such, no part of the function clearly implements any condition or action corresponding to the spec constraints (e.g., C1, A1), and the intended behavior is not enforced within this function.",success,
7805,do_early_reverify_server_certificate,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Does Not Match,[],"The provided function does not implement any logic to ensure that alert messages are not fragmented across records or coalesced into a single TLSPlaintext record. Although there is a comment noting that no alert should be sent on error (referring to TLS 1.3 behavior), this is a deliberate avoidance of sending an alert rather than implementing the fragmentation rules specified. Hence, no part of the function handles the conditions (such as C1 for preventing fragmentation or C2 for avoiding alert coalescence) required by the RFC.",success,
7805,do_early_reverify_server_certificate,Note that Application Data records MUST NOT be written to the wire unprotected (see Section 2 for details).,290,Does Not Match,[],"The provided code function is focused on performing an early re‐verification of the server certificate and establishing early encryption keys (e.g. via add_change_cipher_spec and tls13_set_traffic_key) to enable early data transmission in a TLS 1.3–like handshake. However, the RFC specification requires that Application Data records MUST NOT be written to the wire unprotected. There is no visible logic in this function that directly checks or enforces that application data records are protected before being sent. Moreover, the additional context (e.g. the HTTP 406 status code and content negotiation) is not addressed at all by this function. Therefore, the function does not visibly implement any labeled condition or action related to the given spec constraints.",success,
7805,do_early_reverify_server_certificate,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The RFC specification requires that a TLS implementation SHOULD NOT automatically resend early data and that applications decide when retransmission is appropriate. In this function, although there is logic pertaining to early data (e.g., deferring the release of the 0-RTT key until after certificate re-verification and setting flags (hs->in_early_data and hs->can_early_write)), there is no visible logic that prevents the automatic resending of early data or defers the decision to the application. The function unconditionally proceeds with enabling early data write by setting these flags after initialization, rather than providing a mechanism for an application to decide whether to resend early data. Therefore, no part of the function directly implements the specified RFC constraint.",success,
7807,ssl_parse_server_hello,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification requires that the implementation MUST NOT use the Truncated HMAC extension. The function 'ssl_parse_server_hello' does not contain any logic that checks for, rejects, or otherwise handles a Truncated HMAC extension. It solely focuses on parsing the ServerHello message fields (version, random, session id, cipher suite, compression method, and extensions) without any reference to truncated HMAC or its potential vulnerabilities. As a result, the function does not visibly address the spec constraint.",success,
7807,ssl_parse_server_hello,"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",272,Fully Matches,"[{'C1': {'code': 'if (msg.type != SSL3_MT_SERVER_HELLO) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_MESSAGE);\n    *out_alert = SSL_AD_UNEXPECTED_MESSAGE;\n    return false;\n}', 'explanation': 'This code segment checks if the received message type is not the expected SERVER_HELLO. If true, it triggers an error, sets the alert to SSL_AD_UNEXPECTED_MESSAGE, and terminates processing as required by the RFC.'}}, {'A1': {'code': '*out_alert = SSL_AD_UNEXPECTED_MESSAGE;', 'explanation': ""This statement explicitly sets the connection alert to 'unexpected_message', thereby implementing the required action when an unexpected record type is encountered.""}}]","The function directly addresses the RFC specification by verifying that the received TLS record is a SERVER_HELLO. If not, it triggers an error and sets the unexpected_message alert, fully meeting the prescribed behavior in the constraints.",success,
7807,ssl_parse_server_hello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16(&body, &out->legacy_version) ||\n      !CBS_get_bytes(&body, &out->random, SSL3_RANDOM_SIZE) ||\n      !CBS_get_u8_length_prefixed(&body, &out->session_id) ||\n      CBS_len(&out->session_id) > SSL3_SESSION_ID_SIZE ||\n      !CBS_get_u16(&body, &out->cipher_suite) ||\n      !CBS_get_u8(&body, &out->compression_method))', 'explanation': 'This code block verifies that each component of the ServerHello message complies with expected syntax (correct lengths, valid values, etc.). If any component fails to parse correctly, it indicates the message was malformed.'}}, {'A1': {'code': 'OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n*out_alert = SSL_AD_DECODE_ERROR;\nreturn false;', 'explanation': ""When a parsing error is detected, the function logs a decode error, sets the alert value to 'decode_error', and returns false, signifying that the connection should be terminated—fulfilling the RFC requirement.""}}]","The function explicitly checks for various parsing errors in the ServerHello message and, on any failure, issues a decode_error alert before returning false. This behavior directly corresponds to the RFC requirement that a message failing to conform to the expected syntax must trigger connection termination with a decode_error alert.",success,
7807,ssl_parse_server_hello,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Fully Matches,"[{'C1': {'code': 'if (msg.type != SSL3_MT_SERVER_HELLO) {', 'explanation': 'This segment checks if the handshake message type is not the expected SERVER_HELLO, thus detecting an unexpected message order.'}}, {'A1': {'code': 'OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_MESSAGE);\n*out_alert = SSL_AD_UNEXPECTED_MESSAGE;\nreturn false;', 'explanation': ""On detecting an unexpected message, the function aborts the handshake by putting an error and setting the alert to 'unexpected_message', fully implementing the required action.""}}]","The function begins by verifying that the received message is of type SSL3_MT_SERVER_HELLO. If it is not, it reports an error and sets the alert to SSL_AD_UNEXPECTED_MESSAGE, thereby aborting the handshake as required by the spec. This logic directly and fully addresses both the condition (C1) and the action (A1) from the specification.",success,
7807,ssl_parse_server_hello,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16(&body, &out->legacy_version) ||\n    !CBS_get_bytes(&body, &out->random, SSL3_RANDOM_SIZE) ||\n    !CBS_get_u8_length_prefixed(&body, &out->session_id) ||\n    CBS_len(&out->session_id) > SSL3_SESSION_ID_SIZE ||\n    !CBS_get_u16(&body, &out->cipher_suite) ||\n    !CBS_get_u8(&body, &out->compression_method)) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n  *out_alert = SSL_AD_DECODE_ERROR;\n  return false;\n}', 'explanation': 'This code block checks critical parts of the ServerHello message. If any of these parsing steps fails, it triggers a decode error alert and aborts the handshake, which directly implements the spec requirement: \'If not, then it MUST abort the handshake with a ""decode_error"" alert.\''}}, {'A1': {'code': 'OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n*out_alert = SSL_AD_DECODE_ERROR;\nreturn false;', 'explanation': 'This action explicitly issues a decode_error alert and aborts the handshake when the message fails to meet expected conditions, fulfilling the action part of the spec.'}}]","The function strictly validates the ServerHello message fields and, upon encountering any inconsistency or malformed data, aborts the handshake by setting a decode error alert. This behavior faithfully implements the RFC specification requirement to abort the handshake with a 'decode_error' alert in case of decoding failures.",success,
7807,ssl_parse_server_hello,Servers MUST NOT send this extension.,115,Does Not Match,[],"The provided function, ssl_parse_server_hello, parses a Server Hello message by checking the message type, extracting various fields (legacy_version, random, session_id, cipher_suite, compression_method) and optionally reading an extensions block if present. However, the RFC specification requires that servers MUST NOT send the specified extension. There is no logic in the function that prevents or verifies that this extension is absent. The function simply reads and processes an extensions block if it appears, rather than enforcing its absence as required by the RFC. Hence, the function does not implement the spec constraint within its own logic.",success,
7808,do_read_server_hello,A client that attempts to send 0-RTT data MUST fail a connection if it receives a ServerHello with TLS 1.2 or older.,384,Fully Matches,"[{'C1': {'code': 'if (hs->early_data_offered &&\n      ssl->s3->version != hs->early_session->ssl_version) {\n    // This is currently only possible by reading a TLS 1.2 (or earlier) ServerHello\n    assert(ssl_protocol_version(ssl) < TLS1_3_VERSION);\n    assert(ssl_session_protocol_version(hs->early_session.get()) >= TLS1_3_VERSION);\n\n    hs->can_early_write = false;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_VERSION_ON_EARLY_DATA);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_PROTOCOL_VERSION);\n    return ssl_hs_error;\n  }', 'explanation': ""This block checks whether 0-RTT data was offered (hs->early_data_offered) and whether the server's selected version differs from the early session's TLS 1.3 version. If so, it indicates that the ServerHello is from TLS 1.2 or below, as required by the RFC condition.""}}, {'A1': {'code': 'hs->can_early_write = false;\nOPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_VERSION_ON_EARLY_DATA);\nssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_PROTOCOL_VERSION);\nreturn ssl_hs_error;', 'explanation': 'These actions enforce the failure of the connection when a 0-RTT attempt is detected with an older TLS version. The function disables early writes, sends an appropriate alert, and returns an error state—thus meeting the RFC requirement to fail the connection.'}}]","The function do_read_server_hello explicitly implements the RFC requirement for 0-RTT data. It checks if early data was offered and then verifies the negotiated protocol version. If the server indicates TLS 1.2 or an older protocol (by having a version different from the expected TLS 1.3), it immediately fails the connection by disabling early writes, sending a fatal alert, and returning an error state. This logic contained entirely within the function directly addresses both the condition (C1) and the corresponding action (A1) as specified by the RFC.",success,
7808,do_read_server_hello,Note that 0-RTT data is not compatible with older servers and SHOULD NOT be sent absent knowledge that the server supports TLS 1.3,378,Fully Matches,"[{'C1': {'code': 'if (hs->early_data_offered &&\n      ssl->s3->version != hs->early_session->ssl_version) {\n    assert(ssl_protocol_version(ssl) < TLS1_3_VERSION);\n    assert(ssl_session_protocol_version(hs->early_session.get()) >= TLS1_3_VERSION);\n    hs->can_early_write = false;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_VERSION_ON_EARLY_DATA);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_PROTOCOL_VERSION);\n    return ssl_hs_error;\n  }', 'explanation': ""This code checks if early (0-RTT) data was offered and then verifies that the server's protocol version matches what is expected for TLS 1.3. If there is a mismatch—indicating an older server—the function disables the capability to perform early writes, sends an appropriate alert, and aborts the handshake. This directly implements the RFC requirement that 0-RTT data must not be sent unless the server supports TLS 1.3.""}}]","The function contains explicit logic to detect when early (0-RTT) data has been offered but the server's negotiated version does not confirm TLS 1.3 support. On such a condition, it disables early writes and aborts with an error, ensuring that 0-RTT data is only used with TLS 1.3, which fully meets the RFC specification provided. No other constraint labels were provided, and the relevant 0-RTT handling constraint (labeled here as C1) is fully implemented within this function.",success,
7808,do_read_server_hello,"If the version chosen by the server is not supported by the client (or is not acceptable), the client MUST abort the handshake with a ""protocol_version"" alert.",379,Fully Matches,"[{'C1': {'code': 'if (!ssl_supports_version(hs, server_version)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_UNSUPPORTED_PROTOCOL);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_PROTOCOL_VERSION);\n    return ssl_hs_error;\n}', 'explanation': ""This block checks whether the server_version is supported. If it isn't, the function aborts the handshake by sending a fatal alert with the protocol version error, in direct accordance with the RFC specification.""}}, {'A1': {'code': 'OPENSSL_PUT_ERROR(SSL, SSL_R_UNSUPPORTED_PROTOCOL);\nssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_PROTOCOL_VERSION);\nreturn ssl_hs_error;', 'explanation': ""This sequence immediately sends a 'protocol_version' alert and aborts the handshake, fulfilling the action required by the specification when encountering an unsupported or unacceptable server version.""}}]","The function explicitly inspects the server's version via the ssl_supports_version check and, upon detecting an unsupported or unacceptable version, logs the error and sends a 'protocol_version' alert before aborting the handshake. Since this logic is embedded within the function and directly implements both the condition and the mandated action, the function fully matches the RFC specification as provided.",success,
7808,do_read_server_hello,"To avoid a downgrade attack, the client SHOULD NOT disable TLS 1.3, only 0-RTT.",385,Fully Matches,"[{'C1': {'code': 'if (hs->early_data_offered &&\n    ssl->s3->version != hs->early_session->ssl_version) {\n    assert(!SSL_is_dtls(ssl));\n    hs->can_early_write = false;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_VERSION_ON_EARLY_DATA);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_PROTOCOL_VERSION);\n    return ssl_hs_error;\n}', 'explanation': 'This block explicitly checks for a mismatch between the negotiated version and the early session’s version. Instead of disabling the entire TLS 1.3 protocol, it disables only 0-RTT data (by setting hs->can_early_write to false), which aligns with the requirement that the client SHOULD NOT disable TLS 1.3.'}}, {'A1': {'code': 'if (!ssl->s3->initial_handshake_complete &&\n    hs->max_version >= TLS1_3_VERSION) {\n    static_assert(...);\n    auto suffix = Span(ssl->s3->server_random).last(sizeof(kTLS13DowngradeRandom));\n    if (suffix == kTLS12DowngradeRandom ||\n        suffix == kTLS13DowngradeRandom ||\n        suffix == kJDK11DowngradeRandom) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_TLS13_DOWNGRADE);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n      return ssl_hs_error;\n    }\n}', 'explanation': 'This segment implements the anti-downgrade protection by checking the server_random suffix for known downgrade signals. This ensures that a downgrade attack is detected and handled properly without disabling TLS 1.3, fulfilling the action requirement from the RFC.'}}]","The provided function implements logic to adhere to the RFC requirement that the client should not disable TLS 1.3. Instead, it only disables 0-RTT data when a mismatch in protocol versions is detected, and it incorporates a dedicated anti-downgrade check by verifying specific downgrade signals in the server random. Both of these logic blocks are contained entirely within the function and directly address the conditions specified in the RFC.",success,
7808,do_read_server_hello,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Does Not Match,[],"The RFC requires that SSL 3.0 must never be negotiated. In reviewing the function_body, no code segment explicitly checks if the negotiated protocol version is SSL 3.0 and rejects it. Although the function calls ssl_supports_version(hs, server_version), which may internally filter unsupported versions, that check is external and not implemented in the function itself. Thus, in isolation, the function does not visibly implement the condition (e.g., a direct check for SSL 3.0) mandated by the RFC.",success,
7808,do_read_server_hello,Application protocols MUST NOT use 0-RTT data without a profile that defines its use.,406,Does Not Match,[],"The RFC specifies that application protocols MUST NOT use 0-RTT data without a profile that defines its use. While the function does contain logic to handle early data (for example, it disables early writes if there is a version mismatch in the early data offer), it does not contain any logic that checks for or validates the existence of a profile that permits 0-RTT data. Therefore, the function does not visibly address the specific requirement of ensuring that 0-RTT data is used only if a proper profile is defined, and as such it does not meet the RFC constraint.",success,
7808,do_read_server_hello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'uint8_t alert = SSL_AD_DECODE_ERROR;\n  if (!ssl_parse_server_hello(&server_hello, &alert, msg) ||\n      !parse_server_version(hs, &server_version, &alert, server_hello)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n    return ssl_hs_error;\n  }', 'explanation': 'This segment checks if the ServerHello message cannot be parsed (or has an out‐of-range length, etc.) and then immediately sends an alert (initialized with SSL_AD_DECODE_ERROR) before terminating the connection. This directly implements the requirement from the RFC to terminate the connection with a decode_error alert upon a parsing failure.'}}]","The provided function explicitly validates the incoming ServerHello message. If the message fails parsing (i.e., it does not conform to expected syntax or contains boundary/length errors), the code sends an alert with the decode_error (SSL_AD_DECODE_ERROR) and returns an error state, thus fulfilling the RFC requirement. All relevant logic is contained within the function, satisfying the constraint by itself.",success,
7808,do_read_server_hello,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'A1': {'code': 'if (suffix == kTLS12DowngradeRandom || suffix == kTLS13DowngradeRandom ||\n    suffix == kJDK11DowngradeRandom) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_TLS13_DOWNGRADE);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n  return ssl_hs_error;\n}\n\n...\n\nif (cipher == nullptr ||\n    (cipher->algorithm_mkey & mask_k) ||\n    (cipher->algorithm_auth & mask_a) ||\n    SSL_CIPHER_get_min_version(cipher) > ssl_protocol_version(ssl) ||\n    SSL_CIPHER_get_max_version(cipher) < ssl_protocol_version(ssl) ||\n    !sk_SSL_CIPHER_find(SSL_get_ciphers(ssl), nullptr, cipher)) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CIPHER_RETURNED);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n  return ssl_hs_error;\n}\n\n...\n\nif (server_hello.compression_method != 0) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n  return ssl_hs_error;\n}\n\n...\n\nif (ssl->session == nullptr || ssl->s3->ech_status == ssl_ech_rejected) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_SERVER_ECHOED_INVALID_SESSION_ID);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n  return ssl_hs_error;\n}\n\nif (ssl->session->ssl_version != ssl->s3->version) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_OLD_SESSION_VERSION_NOT_RETURNED);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n  return ssl_hs_error;\n}\n\nif (ssl->session->cipher != hs->new_cipher) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n  return ssl_hs_error;\n}', 'explanation': 'The code function performs several semantic validations of the ServerHello message. In each branch where the message is determined to be semantically invalid (e.g., incorrect downgrade signals, wrong cipher returned, non-zero compression method, or invalid session echo), it terminates the handshake by calling ssl_send_alert with SSL_AD_ILLEGAL_PARAMETER, as mandated by the spec.'}}]","The provided function do_read_server_hello implements multiple semantic validations of the ServerHello message. For each detected invalid condition, such as downgrade signals, incorrect ciphers, improper session resumption details, or unsupported compression, the function terminates the connection by sending a fatal alert with the 'illegal_parameter' code. This behavior directly addresses the RFC requirement for terminating connections upon receiving a syntactically correct but semantically invalid message, thereby fully matching the specified condition from the RFC.",success,
7808,do_read_server_hello,"If a match is found, the client MUST abort the handshake with an ""illegal_parameter"" alert.",43,Fully Matches,"[{'C1': {'code': 'if (!ssl->s3->initial_handshake_complete &&\n      hs->max_version >= TLS1_3_VERSION) {\n    ...\n    auto suffix =\n        Span(ssl->s3->server_random).last(sizeof(kTLS13DowngradeRandom));\n    if (suffix == kTLS12DowngradeRandom || suffix == kTLS13DowngradeRandom ||\n        suffix == kJDK11DowngradeRandom) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_TLS13_DOWNGRADE);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n      return ssl_hs_error;\n    }\n  }', 'explanation': ""This code checks for a downgrade signal in the server random value. When a match is found—i.e. the suffix matches a known downgrade token—it sends an alert using SSL_AD_ILLEGAL_PARAMETER and aborts the handshake, exactly as the RFC specifies ('if a match is found, the client MUST abort the handshake with an illegal_parameter alert').""}}]","The function contains explicit logic that enforces aborting the handshake with an 'illegal_parameter' alert when a downgrade signal (i.e. a matching condition) is detected. This directly implements the specified RFC requirement within the function's control flow, satisfying the labeled constraint.",success,
7808,do_read_server_hello,"A legacy TLS client performing renegotiation with TLS 1.2 or prior and which receives a TLS 1.3 ServerHello during renegotiation MUST abort the handshake with a ""protocol_version"" alert.",44,Fully Matches,"[{'C1': {'code': 'else if (server_version != ssl->s3->version) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_SSL_VERSION);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_PROTOCOL_VERSION);\n    return ssl_hs_error;\n  }', 'explanation': ""In a scenario where the initial handshake is complete (i.e. during renegotiation), the code checks if the server-version does not match the originally negotiated version. Receiving a TLS 1.3 ServerHello by a legacy TLS client (which would have negotiated TLS 1.2 or less) results in a mismatch. The function then aborts the handshake by sending a 'protocol_version' alert as required by the RFC.""}}]","The function do_read_server_hello contains explicit logic to detect a version mismatch during renegotiation. It uses the fact that in a renegotiation the initial handshake is already complete (ssl->s3->initial_handshake_complete is true) and then compares the server_version with the established version. When they differ (i.e. when a TLS 1.3 ServerHello is received by a legacy client), it aborts the handshake with a protocol_version alert. This implementation directly addresses the RFC requirement.",success,
7808,do_read_server_hello,TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below MUST check that the last 8 bytes are not equal to either of these values.,41,Fully Matches,"[{'C1': {'code': 'if (!ssl->s3->initial_handshake_complete &&\n      hs->max_version >= TLS1_3_VERSION) {\n    static_assert(sizeof(kTLS12DowngradeRandom) == sizeof(kTLS13DowngradeRandom), ""downgrade signals have different size"");\n    static_assert(sizeof(kJDK11DowngradeRandom) == sizeof(kTLS13DowngradeRandom), ""downgrade signals have different size"");\n    auto suffix = Span(ssl->s3->server_random).last(sizeof(kTLS13DowngradeRandom));\n    if (suffix == kTLS12DowngradeRandom || suffix == kTLS13DowngradeRandom ||\n        suffix == kJDK11DowngradeRandom) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_TLS13_DOWNGRADE);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n      return ssl_hs_error;\n    }\n  }', 'explanation': ""This segment checks the last 8 bytes of the server random for any downgrade sentinel values (kTLS12DowngradeRandom, kTLS13DowngradeRandom, or kJDK11DowngradeRandom) when the client's maximum version is TLS1.3. This fulfills the spec requirement for TLS 1.3 clients receiving a ServerHello for earlier versions.""}}]","The provided function includes specific logic to enforce the TLS 1.3 anti‐downgrade mechanism as required by the specification. The check on the last 8 bytes of the server random against known downgrade sentinel values directly addresses the RFC constraint, and no other dependency outside this function is required for this check.",success,
7808,do_read_server_hello,"If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2 servers SHOULD, set the last 8 bytes of their ServerHello.Random value to the bytes:",40,Does Not Match,[],"The RFC specification requires that when negotiating TLS 1.1 or below, TLS 1.3 servers MUST (and TLS 1.2 servers SHOULD) set the last 8 bytes of their ServerHello.Random value to specific bytes. In the provided function, while the ServerHello.Random value is copied from the received message (via the OPENSSL_memcpy call), there is no explicit logic that sets or enforces the mandated last 8 bytes. Instead, the code performs an anti-downgrade check by rejecting server random values that match known downgrade signals. This check does not fulfill the action of setting the last 8 bytes as required, and therefore, no labeled constraint (such as C1 or A1 corresponding to ",success,
7808,do_read_server_hello,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The RFC specification requires that application data MUST NOT be sent prior to sending the Finished message. However, the provided function (do_read_server_hello) handles the processing of the ServerHello message during the TLS handshake and does not include any logic to prevent the sending of application data before the Finished message is sent. No part of the function implements a check or mechanism to ensure that application data is withheld until after the Finished message. Therefore, the function does not visibly address the labeled condition or action from the RFC specification.",success,
7808,do_read_server_hello,"A client which receives a cipher suite that was not offered MUST abort the handshake with an ""illegal_parameter"" alert.",33,Fully Matches,"[{'C1': {'code': 'if (cipher == nullptr ||                                               \n      (cipher->algorithm_mkey & mask_k) ||                               \n      (cipher->algorithm_auth & mask_a) ||                               \n      SSL_CIPHER_get_min_version(cipher) > ssl_protocol_version(ssl) ||  \n      SSL_CIPHER_get_max_version(cipher) < ssl_protocol_version(ssl) ||  \n      !sk_SSL_CIPHER_find(SSL_get_ciphers(ssl), nullptr, cipher)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CIPHER_RETURNED);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n}', 'explanation': ""This segment verifies that the server's cipher suite is one of those the client originally offered. If not (i.e. if the cipher is null or fails the specified checks), the function aborts the handshake by sending an 'illegal_parameter' alert, which directly implements the RFC requirement.""}}]","The function clearly implements the RFC requirement by checking whether the server-selected cipher suite is acceptable. If the cipher suite was not offered by the client, the function aborts by calling ssl_send_alert with SSL_AD_ILLEGAL_PARAMETER. This direct check and error reporting fully matches the provided specification.",success,
7808,do_read_server_hello,"If it is not, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.",146,Partially Matches,"[{'A1': {'code': 'if (hs->early_data_offered &&\n    ssl->s3->version != hs->early_session->ssl_version) {\n    assert(!SSL_is_dtls(ssl));\n    hs->can_early_write = false;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_VERSION_ON_EARLY_DATA);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_PROTOCOL_VERSION);\n    return ssl_hs_error;\n  }', 'explanation': ""This segment recognizes when early data (0-RTT) has been offered but the server version does not match the early session's version. It explicitly disables early writes (rejecting 0-RTT) and reports an error. This shows an attempt to address the requirement to reject 0-RTT in situations where the ClientHello is not fresh.""}}]","The provided function contains logic to check if the early data was offered and the negotiated version differs from the early session’s version, which is indicative of a non‐fresh ClientHello. In that case, it explicitly disables early data (hs->can_early_write = false) and sends an alert. This behavior is in line with part of the RFC specification that requires a 0-RTT rejection under these circumstances. However, rather than continuing the handshake (as the RFC recommends, i.e. proceeding without early data), the function aborts the handshake by returning an error. Therefore, while the code does address the 0-RTT rejection (A1), it does not fully conform to the RFC’s guidance to proceed with the handshake, leading to a judgment of 'Partially Matches'.",success,
7808,do_read_server_hello,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Partially Matches,"[{'A1': {'code': 'if (hs->early_data_offered &&\n    ssl->s3->version != hs->early_session->ssl_version) {\n  assert(!SSL_is_dtls(ssl));\n  hs->can_early_write = false;\n  OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_VERSION_ON_EARLY_DATA);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_PROTOCOL_VERSION);\n  return ssl_hs_error;\n}', 'explanation': ""This code checks if early data was offered and the server's version does not match the early session's version, and then disables further early data transmission by setting 'hs->can_early_write' to false. This directly prevents the automatic retransmission of early data, addressing the RFC requirement.""}}]","The RFC specifies that the TLS implementation SHOULD NOT automatically resend early data. Within the 'do_read_server_hello' function, the branch that disables early writes when a version mismatch is detected (by setting 'hs->can_early_write' to false) is a direct measure to prevent automatic early data resending. However, since the function only covers this specific case and does not broadly control all aspects of early data retransmission, the implementation is considered to partially match the spec constraint.",success,
7810,do_read_server_certificate,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'A1': {'code': 'if (!ssl_parse_cert_chain(&alert, &hs->new_session->certs, &hs->peer_pubkey,\n                          NULL, &body, ssl->ctx->pool)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n    return ssl_hs_error;\n}', 'explanation': 'This branch sends an alert (using the provided alert value) when parsing the certificate chain fails, thereby aborting the handshake as required.'}}, {'A2': {'code': 'if (sk_CRYPTO_BUFFER_num(hs->new_session->certs.get()) == 0 ||\n    CBS_len(&body) != 0 ||\n    !ssl->ctx->x509_method->session_cache_objects(hs->new_session.get())) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    return ssl_hs_error;\n}', 'explanation': 'This code sends a decode error alert when the certificate chain is empty or extra data remains, thus enforcing that the connection is aborted with the correct alert.'}}, {'A3': {'code': 'if (!ssl_check_leaf_certificate(\n        hs, hs->peer_pubkey.get(),\n        sk_CRYPTO_BUFFER_value(hs->new_session->certs.get(), 0))) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n}', 'explanation': 'Here, if the leaf certificate check fails, the function sends an illegal parameter alert, which complies with the requirement to abort the handshake with a specific alert.'}}]","The provided function implements error handling during the certificate reading phase by sending specific fatal alerts in various error conditions. Each error branch sends an alert with the appropriate alert code, thereby meeting the part of the RFC specification that requires the handshake to be aborted or the connection terminated with an X alert. However, the overall RFC context also addresses connection closure (e.g., handling of a ‘close’ connection option) which this function does not implement. As a result, although the code addresses the alert-sending aspect of the spec, it does not cover all aspects of the specification context, leading to a 'Partially Matches' judgment.",success,
7810,do_read_server_certificate,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Does Not Match,[],"The provided function, do_read_server_certificate, is focused on processing the server certificate during an SSL handshake, including certificate parsing, hashing, and error handling with alerts. It does not include any logic that implements the HTTP RFC specification regarding the handling of the ""close"" connection option (e.g., closing the connection after sending a final response, ceasing to process further requests, or sending the ""close"" connection option). No parts of the function address the labeled conditions or actions defined by the provided spec constraints.",success,
7810,do_read_server_certificate,"If the server supplies an empty Certificate message, the client MUST abort the handshake with a ""decode_error"" alert.",217,Fully Matches,"[{'C1': {'code': 'if (sk_CRYPTO_BUFFER_num(hs->new_session->certs.get()) == 0 || CBS_len(&body) != 0 || ...)', 'explanation': 'This condition checks if the certificate chain is empty (or if extra data is present), which corresponds to the server supplying an empty Certificate message.'}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);', 'explanation': ""This action sends a 'decode_error' alert and aborts the handshake, exactly as mandated by the RFC when an empty Certificate message is received.""}}]","The function inspects the server's certificate message by parsing the certificate chain. When it detects that the number of certificates is zero (indicating an empty Certificate message), it sends a decode_error alert and aborts the handshake. This behavior directly implements the RFC requirement, with the condition (C1) checked by the empty certificate chain condition and the action (A1) performed by calling ssl_send_alert with SSL_AD_DECODE_ERROR.",success,
7810,do_read_server_certificate,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The RFC requirement specifies that no Application Data should be sent prior to the Finished message. The function do_read_server_certificate is solely concerned with processing the server's certificate message and its associated validations. There is no visible logic within this function that checks, blocks, or otherwise handles the premature receipt or sending of Application Data. All the operations in this function focus on certificate parsing, error handling, and state transitions for certificate-related handshake steps, leaving the handling of Application Data to other parts of the TLS implementation. Therefore, the function does not address the specified constraint.",success,
7810,do_read_server_certificate,The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK).,185,Partially Matches,"[{'C1': {'code': 'if (!ssl_cipher_uses_certificate_auth(hs->new_cipher)) {\n    hs->state = state_read_certificate_status;\n    return ssl_hs_ok;\n}\n...\nif (!ssl_check_message_type(ssl, msg, SSL3_MT_CERTIFICATE) ||\n    !ssl_hash_message(hs, msg)) {\n    return ssl_hs_error;\n}', 'explanation': 'The function first checks if the negotiated cipher uses certificate authentication. If it does, it expects to receive a Certificate message and validates the message type accordingly. This corresponds to the requirement that when certificate‐based authentication is used, a Certificate message must be sent. However, note that the RFC mandates that the server send the message, while this function only reads and processes it on the receiving side.'}}]","The RFC specifies that the server must send a Certificate message when certificate‐based authentication is used. The provided function examines whether the negotiated cipher requires certificate authentication and then attempts to process a Certificate message if needed. While it does implement logic to verify that the message is of the correct type and processes the certificate chain, its role is confined to reading and verifying the message rather than ensuring the server sends it. Thus, it partially addresses the specification by handling the message correctly when received but does not implement the sending part of the RFC requirement.",success,
7810,do_read_server_certificate,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Partially Matches,"[{'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n\nOPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\nssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n\nif (!ssl_check_leaf_certificate(...)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n}', 'explanation': 'The RFC specification requires that all alerts be sent with AlertLevel=fatal. This function, in all its error handling branches, calls ssl_send_alert with the SSL3_AL_FATAL parameter, thereby enforcing the fatal alert level. However, the RFC also mandates that such alerts be treated as error alerts when received irrespective of any provided alert level, and this receiving behavior is not addressed in this function. Hence, the function partially meets the specification by correctly sending alerts with a fatal level.'}}]","The function implements logic to send alerts using a fatal alert level on error conditions. Each call to ssl_send_alert uses SSL3_AL_FATAL, which aligns with the part of the RFC that requires alerts be sent with an AlertLevel of fatal. However, there is no implementation in this function addressing the requirement for treating received alerts as errors irrespective of the AlertLevel in the message. Because only part of the RFC constraint is addressed within this function’s logic, the overall judgment is that it partially matches the RFC specification.",success,
7810,do_read_server_certificate,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'A1': {'code': 'if (!ssl_check_leaf_certificate(\n          hs, hs->peer_pubkey.get(),\n          sk_CRYPTO_BUFFER_value(hs->new_session->certs.get(), 0))) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n  }', 'explanation': ""This segment checks the certificate's validity, and when the leaf certificate fails validation (i.e. when the message is semantically invalid), it sends an 'illegal_parameter' alert and terminates the connection, thereby directly addressing the RFC requirement.""}}]","The RFC specifies that a syntactically correct but semantically invalid message should lead to the termination of the connection with an 'illegal_parameter' alert. The function implements this by performing a leaf certificate check and, upon failure, invoking ssl_send_alert with SSL_AD_ILLEGAL_PARAMETER. This in-function logic fully meets the spec constraints without relying on any caller or external dependency behavior.",success,
7811,do_read_certificate_status,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function 'do_read_certificate_status' deals exclusively with reading and processing a CertificateStatus message from the server (including parsing the OCSP response and verifying its correctness). There is no logic within this function that handles any aspect of ensuring that Application Data is not sent prior to the Finished message as specified by the RFC. Therefore, this function does not implement any of the labeled conditions or actions (such as C1, A1, etc.) from the spec constraints.",success,
7811,do_read_certificate_status,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u8(&certificate_status, &status_type) ||\n      status_type != TLSEXT_STATUSTYPE_ocsp ||\n      !CBS_get_u24_length_prefixed(&certificate_status, &ocsp_response) ||\n      CBS_len(&ocsp_response) == 0 ||\n      CBS_len(&certificate_status) != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    return ssl_hs_error;\n}', 'explanation': ""This segment validates the syntax of the certificate status message. If any parsing step fails (e.g., reading the type, length or extra bytes remain), it triggers a decode error by sending a 'decode_error' alert and terminating the handshake, which is what the RFC specifies.""}}]","The function inspects the incoming certificate status message for proper syntax. It checks the expected fields and lengths, and if any parsing error occurs, it sends a decode error alert and terminates the connection. This directly implements the RFC requirement, fulfilling both the condition of detecting a parsing error and the action of terminating the connection with the appropriate alert.",success,
7814,do_read_server_key_exchange,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'C1': {'code': 'if (!tls1_check_group_id(hs, group_id)) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CURVE);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n      return ssl_hs_error;\n    }', 'explanation': ""This segment checks the validity of the ECDHE group by calling tls1_check_group_id. If the group is not acceptable (i.e. a semantically invalid parameter), the function terminates the handshake by sending an 'illegal_parameter' alert, which is in line with the RFC requirement.""}}]","The RFC specifies that semantically invalid messages must be met with an 'illegal_parameter' alert. The code function implements such behavior in the case of an invalid ECDHE group. However, other cases of semantic invalidity (for example, an invalid DHE share or invalid enum) are handled by sending different alerts (like decode error or unexpected message) rather than an 'illegal_parameter' alert. Since only a subset of the potential invalid conditions is directly addressed with the required 'illegal_parameter' alert, the function only partially matches the RFC specification.",success,
7814,do_read_server_key_exchange,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!CBS_get_u16_length_prefixed(&server_key_exchange, &psk_identity_hint)) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n  return ssl_hs_error;\n}\n\n...\n\nif (!CBS_get_u8_length_prefixed(&server_key_exchange, &point)) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n  return ssl_hs_error;\n}\n\n...\n\nif (!CBS_get_u16(&server_key_exchange, &signature_algorithm)) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n  return ssl_hs_error;\n}', 'explanation': 'The function attempts to parse various length‐prefixed parts of the ServerKeyExchange message and, upon encountering problems (e.g., missing expected length fields), it sends a decode_error alert. This aligns with the spec requirement that messages that cannot be parsed cause termination with a decode_error alert.'}}]","The function contains several parsing checks for fields in the ServerKeyExchange message and, in many cases, it calls ssl_send_alert with SSL_AD_DECODE_ERROR when a parse error is encountered. This shows an attempt to implement the RFC requirement. However, not every error condition uses a decode_error alert: for example, when a PSK identity hint is out of range or contains a NULL character, it sends a handshake_failure alert, and an unexpected message type triggers an unexpected_message alert. Because the RFC specifically mandates a decode_error alert on parsing failures, the implementation only partially matches the spec constraint.",success,
7814,do_read_server_key_exchange,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Fully Matches,"[{'C1': {'code': 'if (msg.type != SSL3_MT_SERVER_KEY_EXCHANGE) {\n    if (ssl_cipher_requires_server_key_exchange(hs->new_cipher)) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_MESSAGE);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);\n      return ssl_hs_error;\n    }\n\n    hs->state = state_read_certificate_request;\n    return ssl_hs_ok;\n  }', 'explanation': ""This segment checks if the handshake message type is not ServerKeyExchange. For ciphers that require a ServerKeyExchange, it immediately aborts the handshake with an 'unexpected_message' alert, directly implementing the RFC specification.""}}]","The RFC specifies that a peer must abort the handshake with an 'unexpected_message' alert when a handshake message is received out of order. In the function, if the message type is not ServerKeyExchange and the cipher requires it, the function flags an error and sends the appropriate alert. This logic is contained entirely within the function and satisfies the RFC requirement, so the function fully matches the spec constraint.",success,
7814,do_read_server_key_exchange,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function, do_read_server_key_exchange, is concerned with reading and processing the ServerKeyExchange handshake message in TLS. There is no code within this function that checks or enforces the constraint that 'Application Data MUST NOT be sent prior to sending the Finished message.' The logic in this function handles aspects of the handshake such as processing PSK identity hints, parsing ECDHE parameters, and verifying signatures, but it does not address any mechanism to prevent application data from being sent before the Finished message. Thus, none of the labeled spec constraints (e.g., C1, A1, etc.) corresponding to the provided HTTP RFC specification are implemented within the function.",success,
7814,do_read_server_key_exchange,"These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2.",86,Does Not Match,[],"The function 'do_read_server_key_exchange' implements the TLS handshake processing for the ServerKeyExchange message. It performs tasks such as parsing PSK identity hints, verifying elliptic curve groups, and checking and verifying digital signatures on handshake messages. In contrast, the RFC specification provided relates to signature values in certificates — specifically noting that such signatures are not defined for use in signed TLS handshake messages — and the accompanying context about a valid From header in HTTP requests. There is no visible logic in this function that addresses any conditions or actions related to certificate signature values or HTTP header fields. Therefore, the function does not implement any of the labeled spec constraints (e.g., C1, A1) as required by the provided RFC specification.",success,
7815,do_read_certificate_request,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function, do_read_certificate_request, focuses on processing the Certificate Request message during the SSL/TLS handshake and does not address the spec constraint regarding application data not being sent prior to the Finished message. Specifically, there is no logic in the function that prevents or checks for application data being sent before the Finished message, which is required by the spec constraint. As such, none of the labeled conditions or actions relevant to the spec are implemented within this function.",success,
7816,do_read_server_hello_done,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'A1': {'code': 'if (CBS_len(&msg.body) != 0) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    return ssl_hs_error;\n}', 'explanation': ""This segment checks that the ServerHelloDone message is empty (as required by the syntax) and, if not, it sends a 'decode_error' alert and terminates the connection. This directly implements the RFC specification that peers must terminate the connection with a decode_error alert upon receiving an improperly parsed message.""}}]","The function explicitly verifies that the ServerHelloDone message adheres to the expected syntax by checking that its length is zero. If the message does not pass this check, it sends a decode_error alert and returns an error state, which effectively terminates the connection in accordance with the RFC requirement.",success,
7816,do_read_server_hello_done,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function focuses on processing the ServerHelloDone handshake message and verifying that there is no extra unprocessed handshake data. It does not contain any logic to enforce the requirement that ""Application Data MUST NOT be sent prior to sending the Finished message."" Therefore, none of the spec constraints (such as the condition that application data not be sent early) are visibly implemented within this function.",success,
7816,do_read_server_hello_done,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Fully Matches,"[{'A1': {'code': 'if (ssl->method->has_unprocessed_handshake_data(ssl)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);\n    OPENSSL_PUT_ERROR(SSL, SSL_R_EXCESS_HANDSHAKE_DATA);\n    return ssl_hs_error;\n  }', 'explanation': ""This segment checks for any unprocessed handshake data, which would indicate receipt of an unexpected handshake message. In response, it aborts the handshake by sending an 'unexpected_message' alert, thereby enforcing the RFC requirement that any handshake message received in an unexpected order must lead to an immediate abort.""}}]","The function do_read_server_hello_done correctly implements the specified RFC constraint by including a check (using ssl->method->has_unprocessed_handshake_data) to detect whether there is any additional handshake data that would constitute an unexpected message. When such data is present, the function sends an 'unexpected_message' alert and aborts the handshake. Since this is the only requirement dictated by the RFC spec provided, the code function fully matches the specification.",success,
7817,check_credential,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided check_credential function only deals with verifying the type of certificate (X509) and choosing the appropriate signature algorithm. There is no logic that refers to TLS 1.3 handling of the status_request_v2 extension or any related behavior specified in the RFC (i.e., not acting on its presence in ClientHello or avoiding its inclusion in later messages). Consequently, none of the spec constraints (e.g., C1, A1, etc.) regarding the status_request_v2 extension are addressed within this function.",success,
7818,do_send_client_certificate,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function 'do_send_client_certificate' does not address the RFC requirement regarding handling the status_request_v2 extension during the processing of ClientHello messages. There is no logic within this function that checks or prevents the sending of the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. The function is solely focused on certificate selection and sending the client certificate, and does not implement any of the labeled conditions (e.g., C1) or actions (e.g., A1) related to the RFC specification.",success,
7818,do_send_client_certificate,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function, do_send_client_certificate, is focused on handling the TLS handshake process related to client certificates. It neither checks nor enforces the application data ordering constraint from the RFC (i.e., ensuring that application data is not sent prior to the Finished message). There is no logic within this function that addresses sending application data or delaying it until after the Finished message, and thus it does not meet the RFC specification constraint.",success,
7818,do_send_client_certificate,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Does Not Match,[],"The provided function primarily handles the process of selecting and sending a client certificate during the TLS handshake. It does send alerts (using ssl_send_alert) in error scenarios (for example, when a certificate callback fails or no valid credential is found), but these alerts are related to handshake failures or internal errors, not to the specific RFC specification that mandates terminating the connection or aborting the handshake with a particular X alert when a ""close"" connection option is involved. There is no visible logic in this function that implements the behavior described in the spec (e.g., closing the connection after sending a final response or ceasing further request processing). Therefore, according to the criteria, the function does not address the given spec constraints.",success,
7818,do_send_client_certificate,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification requires that implementations must not offer or negotiate RC4 cipher suites for any version of TLS. The provided function, do_send_client_certificate, deals solely with logic related to sending client certificates and managing related callbacks and credential selection. There is no part of the function that inspects, filters, or disallows RC4 cipher suites. Thus, within this function, no portion of the labeled conditions or actions (such as those preventing RC4 usage) is implemented.",success,
7818,do_send_client_certificate,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The provided function 'do_send_client_certificate' focuses solely on processing client certificates during a TLS handshake. It does not contain any logic or checks related to SSL 2.0 or its prohibition as required by the specification referencing RFC6176. No part of the code handles the condition stating that SSL 2.0 MUST NOT be negotiated, and therefore, this function does not visibly address the specified RFC constraint.",success,
7818,do_send_client_certificate,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Fully Matches,"[{'A1': {'code': 'if (rv == 0) {\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n  ...\n}\n...\nif (hs->credential == nullptr) {\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n  ...\n}', 'explanation': ""The specification requires that all alerts (listed in Section 6.2) be sent with AlertLevel 'fatal'. In this function, both error cases where an alert is sent use SSL3_AL_FATAL (which corresponds to the fatal level). This directly implements the requirement by ensuring all sent alerts are transmitted as fatal.""}}]","The function do_send_client_certificate explicitly sends alerts using the SSL3_AL_FATAL level in the appropriate error conditions. This matches the RFC specification that mandates alerts be sent with a fatal alert level. All relevant code segments that check for error conditions trigger an alert with SSL3_AL_FATAL, thereby fully addressing the spec constraint within the function itself.",success,
7818,do_send_client_certificate,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Does Not Match,[],"The provided function, do_send_client_certificate, is focused solely on sending the client certificate or managing the related client authentication steps in a TLS handshake. It does not include any logic to handle the ""close"" connection option or connection termination behaviors specified in the RFC and its constraints. No parts of the function address connection termination, sending a ""close"" connection option, or the subsequent prohibition of processing further requests, which are central to the RFC specification provided.",success,
7818,do_send_client_certificate,The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2).,186,Fully Matches,"[{'C1': {'code': 'if (!hs->cert_request) {\n    hs->state = state_send_client_key_exchange;\n    return ssl_hs_ok;\n}', 'explanation': ""This segment ensures that a Certificate message is sent only when a certificate request (i.e. client authentication request) is received. If no certificate request exists, the function bypasses sending the Certificate message, thereby meeting the RFC requirement 'The client MUST send a Certificate message if and only if the server has requested client authentication'.""}}]","The code function explicitly checks for the presence of a certificate request (via hs->cert_request) before proceeding. If no request is detected, it advances the handshake state without sending a Certificate message. This behavior directly aligns with the RFC specification. No other aspects of the provided spec (such as obs‐fold handling in HTTP) are relevant within this TLS handshake function; hence, the function fully implements the required condition on its own.",success,
7819,do_send_client_key_exchange,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function, do_send_client_key_exchange, is focused on constructing and sending a TLS handshake message (the Client Key Exchange) rather than handling application data. The RFC specification requires that application data must not be sent prior to the Finished message, but there is no logic in this function that checks for or prevents the premature sending of application data. In essence, the function does not implement any mechanism addressing the RFC constraint (e.g., ensuring that application data is withheld until after the Finished message), and therefore it does not meet the specified requirement.",success,
7819,do_send_client_key_exchange,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites. In reviewing the provided function, there is no visible logic that checks for or prevents the use of RC4; the function handles key exchanges based on RSA, ECDHE, and PSK without any conditions or actions addressing RC4 ciphers. Consequently, the function does not address the specified RFC constraint within its own code.",success,
7821,do_send_client_finished,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function, do_send_client_finished, is responsible for sending various handshake messages (such as ChangeCipherSpec, Next Protocol, and Channel ID if applicable) and finally invoking the sending of the Finished message. However, the RFC specification requires that application data MUST NOT be sent prior to sending the Finished message. There is no explicit logic in this function to check, prevent, or enforce that application data is not sent before the Finished message. All the code in this function is dedicated to crafting and sending handshake-related messages, and it does not address the ordering or prevention of sending application data. Therefore, based solely on the logic within this function, it does not visibly implement the specified RFC requirement.",success,
7821,do_send_client_finished,A Finished message MUST be sent regardless of whether the Certificate message is empty.,188,Fully Matches,"[{'A1': {'code': 'if (!ssl_send_finished(hs)) {\n    return ssl_hs_error;\n}\n\nhs->state = state_finish_flight;\nreturn ssl_hs_flush;', 'explanation': 'This segment unconditionally calls ssl_send_finished, ensuring that the Finished message is sent regardless of prior events (such as whether the Certificate message is empty), which directly satisfies the RFC requirement.'}}]","The function do_send_client_finished is responsible for sending the Finished message as part of the TLS handshake. The key requirement from the RFC is that a Finished message must be sent even if the Certificate message is empty. In the function, after handling optional components (such as Next Protocol and Channel ID), it always calls ssl_send_finished to send the Finished message, thereby fulfilling the specification. No additional logic in this function conditions the sending of the Finished message on the presence of a certificate, meaning the implementation meets the spec constraint on its own.",success,
7821,do_send_client_finished,"These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2.",86,Does Not Match,[],"The RFC specification provided relates to certificate signature algorithms used for signatures in certificates and not for signed TLS handshake messages, whereas the function implements sending a TLS Client Finished message and handling channel ID and next protocol negotiation. There is no visible logic in the function that addresses any RFC constraints (e.g., conditions C1, actions A1, etc.) related to certificate signature algorithms. All functionality in function_body is devoted to various aspects of the TLS handshake and does not implement or verify the specified certificate signature constraints.",success,
7823,do_finish_flight,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Does Not Match,[],"The provided function does not contain any logic that addresses the RFC specification regarding the handling of 0-RTT data—in particular, that TLS implementations must not enable or automatically resend 0-RTT unless specifically requested or instructed by the application. The code focuses on finishing the handshake and handling conditions like false start (via SSL_MODE_ENABLE_FALSE_START), but false start is not equivalent to 0-RTT. There is no visible logic in the function that checks for or prevents the use of 0-RTT data as described in the RFC specification. Thus, no labeled conditions or actions (such as C1, A1, etc.) pertaining to the RFC are implemented within this function.",success,
7823,do_finish_flight,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The RFC specifies that a TLS implementation SHOULD NOT automatically resend early data, leaving the decision to applications. In the provided function, although there is logic to enable a false start (allowing early writing) under specific conditions (e.g., checking SSL_MODE_ENABLE_FALSE_START and ensuring it’s not a renegotiation), there is no logic to prevent or control the automatic resending of early data. The function merely sets flags (hs->in_false_start and hs->can_early_write) to allow early data transmission, but it does not implement any mechanism that ensures early data is not automatically resent. Since no part of the function addresses this specific spec constraint by itself, it does not visibly meet any labeled condition (or action) related to the specification.",success,
7824,do_read_session_ticket,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, do_read_session_ticket, is solely concerned with processing a session ticket during a TLS handshake and does not address any logic regarding cipher suite selection, let alone specifically excluding RC4 cipher suites as required by the RFC specification. There is no code in the function that checks for RC4 or prevents its negotiation, so the RFC constraint is not implemented in this function.",success,
7824,do_read_session_ticket,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u32(&new_session_ticket, &ticket_lifetime_hint) ||\n      !CBS_get_u16_length_prefixed(&new_session_ticket, &ticket) ||\n      CBS_len(&new_session_ticket) != 0) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    return ssl_hs_error;\n}', 'explanation': ""This code segment checks whether the session ticket message's format is correct. If the ticket cannot be parsed according to the expected syntax (for example, if a length is out-of-bound or extra data exists), it sends a 'decode_error' alert and terminates processing. This meets the RFC requirement that a 'decode_error' alert be sent when a message parsing error is detected.""}}]",The function implements the RFC specification by verifying the session ticket's format and terminating the connection with a 'decode_error' alert when the message cannot be parsed correctly. The check and subsequent alert on failure directly address the spec condition and action regarding handling malformed messages.,success,
7824,do_read_session_ticket,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided code function is concerned with reading and processing a NEW_SESSION_TICKET message during the TLS handshake. It does not contain any logic that enforces the RFC requirement that Application Data MUST NOT be sent prior to sending the Finished message. There is no code segment that checks for or prevents application data from being sent before the Finished message, which is the key constraint in the RFC specification. Thus, none of the labeled conditions (C1, C2, etc.) or actions (A1, A2, etc.) appear to be implemented within this function.",success,
7827,do_finish_client_handshake,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function (do_finish_client_handshake) does not contain any code that checks, rejects, or prevents the negotiation of RC4 cipher suites as mandated by the RFC specification. The function is focused on completing the TLS handshake process, handling session duplication and error conditions, but it does not address any condition related to RC4 cipher suites (e.g., rejecting them). Therefore, no parts of the code meet the RFC constraint.",success,
7828,ssl_client_handshake,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function 'ssl_client_handshake' is focused on managing the TLS handshake process through various handshake states. It does not contain logic that directly addresses the RFC specification which states, 'Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.' There is no code in this function that checks, restricts, or otherwise prevents application data from being sent before the Finished message. Additionally, the HTTP spec context provided (discussing field lengths and header processing) is not addressed by any of the logic in this function. Thus, the function does not visibly implement or enforce the specified RFC constraint within its code.",success,
7828,ssl_client_handshake,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided code function implements a TLS handshake state machine by switching over various handshake states and calling corresponding helper functions. However, it does not contain any explicit logic addressing the TLS early data resending decision as specified by the RFC (i.e., 'SHOULD NOT automatically resend early data'). There is no conditional check or application decision-making process within this function to control early data retransmission. Additionally, the spec context regarding HTTP 302 redirection is not pertinent to this function. As a result, no labeled conditions or actions from the spec constraints (e.g., C1, A1) are visibly implemented in the function_body.",success,
7830,tls13_get_cert_verify_signature_input,The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages.,229,Does Not Match,[],"The RFC specification requires that the SHA-1 algorithm must not be used in any signatures of CertificateVerify messages. However, the provided code function, tls13_get_cert_verify_signature_input, only constructs the signature input by concatenating fixed bytes, a context string (determined by the verification context), and a transcript hash. There is no code within this function that checks, restricts, or otherwise handles the use of the SHA-1 algorithm. Therefore, it does not address the constraint specified in the RFC.",success,
7831,tls13_process_certificate,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The RFC specification requires that TLS 1.3 servers must not act upon the status_request_v2 extension in Certificate messages. However, in the provided function, there is explicit logic handling the status_request extension (e.g. the block beginning with 'if (status_request.present)' where the OCSP response is parsed and stored). This indicates that the function does act on the extension—in violation of the specification. No logic is present in this function to ignore or discard the status_request extension when processing Certificate messages, and thus the code does not address the relevant spec constraint.",success,
7831,tls13_process_certificate,"If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either continue the handshake without client authentication or abort the handshake with a ""certificate_required"" alert.",218,Fully Matches,"[{'C1': {'code': 'if (sk_CRYPTO_BUFFER_num(hs->new_session->certs.get()) == 0) {\n    if (!allow_anonymous) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_CERTIFICATE_REQUIRED);\n      return false;\n    }\n\n    hs->new_session->verify_result = X509_V_OK;\n    return true;\n  }', 'explanation': ""This code segment checks if the list of certificates is empty. If it is and anonymous client authentication is not allowed (allow_anonymous is false), it sends a 'certificate_required' alert and aborts the handshake, thereby fulfilling the specification requirement that the server may abort the handshake with a 'certificate_required' alert when no certificates are provided. If anonymous connections are allowed, the handshake continues without client authentication.""}}]","The provided function implements TLS 1.3 certificate processing by parsing the Certificate message. It specifically handles the situation where no certificates are provided by checking the certificate list length. Based solely on its internal logic, it correctly decides whether to abort the handshake with a 'certificate_required' alert or continue without client authentication depending on the 'allow_anonymous' flag, thereby fully addressing the corresponding spec constraint.",success,
7831,tls13_process_certificate,"If the client opts to send an OCSP response, the body of its ""status_request"" extension MUST be a CertificateStatus structure as defined in [RFC6066].",203,Fully Matches,"[{'C1': {'code': 'if (status_request.present) {\n  uint8_t status_type;\n  CBS ocsp_response;\n  if (!CBS_get_u8(&status_request.data, &status_type) ||\n      status_type != TLSEXT_STATUSTYPE_ocsp ||\n      !CBS_get_u24_length_prefixed(&status_request.data, &ocsp_response) ||\n      CBS_len(&ocsp_response) == 0 || CBS_len(&status_request.data) != 0) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    return false;\n  }\n\n  if (sk_CRYPTO_BUFFER_num(certs.get()) == 1) {\n    hs->new_session->ocsp_response.reset(\n        CRYPTO_BUFFER_new_from_CBS(&ocsp_response, ssl->ctx->pool));\n    if (hs->new_session->ocsp_response == nullptr) {\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n      return false;\n    }\n  }\n}', 'explanation': 'This segment checks for the presence of the status_request extension, confirms that the status type is OCSP (as required by RFC6066 for a CertificateStatus structure), extracts a 24‐bit length prefixed OCSP response ensuring it is non-empty and that no extra data remains. This directly implements the RFC requirement concerning the OCSP response formatting.'}}]","The code function explicitly parses and validates the OCSP response contained within the status_request extension. It ensures that the field adheres to the CertificateStatus structure (one byte for type, followed by a length-delimited OCSP response and no trailing data). This matches the spec's requirement that if a client sends an OCSP response then its extension body must follow the CertificateStatus format. As the logic is implemented entirely within the function, it fully meets the labeled constraint (C1).",success,
7831,tls13_process_certificate,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS. The provided function, tls13_process_certificate, is solely concerned with processing and parsing TLS certificates (including handling compressed certificates, verifying certificate length, extensions, and public keys) and does not contain any logic related to cipher suite selection, negotiation, or exclusion, particularly with regard to RC4. Therefore, this function does not address the specified RFC constraint.",success,
7831,tls13_process_certificate,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Does Not Match,[],"The RFC specification requires that whenever an implementation sends an alert to terminate the connection or abort the handshake, it must send a specific, predetermined alert (alert X). In this function, however, different alerts are sent in different error conditions (for example, SSL_AD_DECODE_ERROR, SSL_AD_ILLEGAL_PARAMETER, SSL_AD_CERTIFICATE_REQUIRED, and SSL_AD_INTERNAL_ERROR) rather than enforcing a uniform alert X as the spec mandates. Although the function does call ssl_send_alert on error, it does not adhere to the requirement of sending a designated alert X every time. Therefore, the function does not fully implement the specified RFC constraint within its own logic.",success,
7831,tls13_process_certificate,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Does Not Match,[],"The provided function, tls13_process_certificate, is focused on processing TLS 1.3 certificate messages including decompression, certificate chain parsing, public key extraction, and extension handling. It does send alerts on error conditions, but none of its code logic addresses the specific RFC behavior related to ""close"" connection options, such as initiating connection closure after sending a final response or ceasing to process further requests. Since the RFC specification constraints (e.g., conditions C1, actions A1) refer to handling connection termination or aborting handshakes based on ""close"" connection options, and no such logic is visible in the function body itself, the function does not implement any part of those labeled constraints.",success,
7831,tls13_process_certificate,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'C1': {'code': 'if (uncompressed_len > ssl->max_cert_list) {\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n      OPENSSL_PUT_ERROR(SSL, SSL_R_UNCOMPRESSED_CERT_TOO_LARGE);\n      ERR_add_error_dataf(""requested=%u"", static_cast<unsigned>(uncompressed_len));\n      return false;\n    }', 'explanation': ""This block checks that the uncompressed certificate length does not exceed a preset maximum. For a syntactically correct message that is semantically invalid (i.e. certificate too large), it terminates the connection with an 'illegal_parameter' alert, addressing one aspect of the spec's requirement.""}}, {'A1': {'code': 'if (!ssl_cert_check_key_usage(&certificate, key_usage_digital_signature)) {\n          ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n          return false;\n        }', 'explanation': ""This segment verifies the key usage of the leaf certificate. On detecting an invalid key usage (a semantic error in the certificate), it sends an 'illegal_parameter' alert, thereby enforcing the RFC requirement for semantically invalid messages.""}}]","The function performs several validations on the certificate (or compressed certificate) received. In cases where a semantically invalid condition is detected (for example, an oversized uncompressed certificate or incorrect key usage), the function explicitly sends an 'illegal_parameter' alert and terminates processing. Although not all possible semantic invalidities are handled solely within this function—some errors result in other alerts like DECODE_ERROR—the checks that lead to an 'illegal_parameter' alert satisfy relevant aspects of the RFC specification. Therefore, the implementation partially matches the spec constraints.",success,
7831,tls13_process_certificate,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16(&body, &alg_id) ||\n    !CBS_get_u24(&body, &uncompressed_len) ||\n    !CBS_get_u24_length_prefixed(&body, &compressed) ||\n    CBS_len(&body) != 0) {\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n  OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n  return false;\n}\n\n...\n\nif (!CBS_get_u8_length_prefixed(&body, &context) ||\n    CBS_len(&context) != 0 ||\n    !CBS_get_u24_length_prefixed(&body, &certificate_list) ||\n    CBS_len(&body) != 0) {\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n  OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n  return false;\n}', 'explanation': ""This code checks various parts of the message for correctness. When a parsing error is detected (e.g., when the message structure does not match the expected format), it sends a 'decode_error' alert and terminates processing, directly addressing the RFC’s requirement.""}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);', 'explanation': 'Throughout the function, upon any failure to parse the expected message syntax, the function calls ssl_send_alert with the decode_error alert, thereby enforcing the action required by the specification.'}}]","The function 'tls13_process_certificate' consistently validates the structure of certificate messages. In every check where the syntax might be incorrect (length mismatches, unexpected extra data, decompression issues, etc.), it sends a 'decode_error' alert and terminates further processing. This behavior directly implements the specified RFC requirement that peers must terminate the connection with a 'decode_error' alert if the message cannot be parsed according to the syntax.",success,
7831,tls13_process_certificate,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Fully Matches,"[{'C1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\nssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\nssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\nssl_send_alert(ssl, SSL3_AL_FATAL, alert);', 'explanation': 'Every invocation of ssl_send_alert in the function explicitly passes the constant SSL3_AL_FATAL. This satisfies the RFC requirement that all alerts must be sent with AlertLevel=fatal.'}}]","The function tls13_process_certificate consistently uses SSL3_AL_FATAL when sending alerts in all error cases. This meets the specified RFC constraint that alerts are sent with AlertLevel=fatal, ensuring they are treated as error alerts regardless of any other parameters. All relevant error-handling paths within the function correctly apply this fatal alert level, demonstrating a full match of the RFC specification within the scope of this function.",success,
7832,tls13_process_certificate_verify,"If the verification fails, the receiver MUST terminate the handshake with a ""decrypt_error"" alert.",231,Fully Matches,"[{'A1': {'code': 'if (!ssl_public_key_verify(ssl, signature, signature_algorithm,\n                             hs->peer_pubkey.get(), input)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_SIGNATURE);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECRYPT_ERROR);\n    return false;\n}', 'explanation': ""This segment explicitly checks for verification failure via ssl_public_key_verify and, upon failure, sends a 'decrypt_error' alert (represented by SSL_AD_DECRYPT_ERROR) and terminates the handshake, directly satisfying the spec requirement.""}}]","The provided function, tls13_process_certificate_verify, directly implements the specified RFC behavior by verifying the certificate signature. In the event of a verification failure, the code calls ssl_send_alert with the decrypt_error alert. This behavior is fully visible within the function (and not delegated to any dependency), and therefore it fully meets the spec constraint that mandates termination of the handshake with a 'decrypt_error' alert when verification fails.",success,
7832,tls13_process_certificate_verify,The receiver of a CertificateVerify message MUST verify the signature field.,230,Fully Matches,"[{'C1': {'code': 'if (!ssl_public_key_verify(ssl, signature, signature_algorithm,\n                             hs->peer_pubkey.get(), input)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_SIGNATURE);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECRYPT_ERROR);\n    return false;\n  }', 'explanation': 'This segment explicitly verifies the signature field received in the CertificateVerify message by comparing the provided signature against the expected one, thereby fulfilling the RFC requirement that the receiver MUST verify the signature field.'}}]","The function extracts the signature and its algorithm from the message, computes the expected signature input, and then calls ssl_public_key_verify to verify the signature. This in-function logic directly addresses the spec requirement to verify the signature field of the CertificateVerify message, thereby fully matching the specified constraint.",success,
7832,tls13_process_certificate_verify,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16(&body, &signature_algorithm) || !CBS_get_u16_length_prefixed(&body, &signature) || CBS_len(&body) != 0) {', 'explanation': 'This code checks that the incoming message is correctly parsed. If any part of the parsing fails (e.g. not enough bytes for a u16 or leftover data remains), the condition detecting a malformed message is met.'}}, {'A1': {'code': 'OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\nssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\nreturn false;', 'explanation': ""Upon a parsing error, the function logs the decode error and sends a fatal alert with the 'decode_error' alert code, thereby terminating the connection as required by the RFC.""}}]","The RFC specification requires that when a message cannot be correctly parsed, the connection must be terminated with a decode_error alert. The function 'tls13_process_certificate_verify' directly implements this behavior by validating the parsed structure of the message and, upon failure, logging an error, sending a decode_error alert, and returning false to terminate processing. Thus, the function visibly addresses both the condition (C1: malformed message detected) and the action (A1: termination with decode_error alert) within its own logic.",success,
7833,tls13_process_finished,"If the verification fails, the receiver MUST terminate the handshake with a ""decrypt_error"" alert.",231,Fully Matches,"[{'C1': {'code': 'bool finished_ok = CBS_mem_equal(&msg.body, verify_data.data(), verify_data.size());', 'explanation': ""This line compares the received message's finished data with the expected value, fulfilling the condition of verifying the finished message.""}}, {'A1': {'code': 'if (!finished_ok) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECRYPT_ERROR);\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DIGEST_CHECK_FAILED);\n    return false;\n}', 'explanation': ""If the verification fails, the function sends a 'decrypt_error' alert and terminates the handshake, as mandated by the spec.""}}]","The function implements the required behavior by first verifying the finished message (C1) and then, upon failure, sending a 'decrypt_error' alert and terminating the handshake (A1). Therefore, it fully matches the specified RFC requirement.",success,
7833,tls13_process_finished,"Recipients of Finished messages MUST verify that the contents are correct and if incorrect MUST terminate the connection with a ""decrypt_error"" alert.",232,Fully Matches,"[{'C1': {'code': 'bool finished_ok = CBS_mem_equal(&msg.body, verify_data.data(), verify_data.size());', 'explanation': 'This code compares the received Finished message with the expected verify_data, thus verifying the correctness of the Finished message.'}}, {'A1': {'code': 'if (!finished_ok) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECRYPT_ERROR);\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DIGEST_CHECK_FAILED);\n    return false;\n}', 'explanation': 'This code sends a decrypt_error alert and terminates the connection when the Finished message verification fails.'}}]","The function computes or retrieves the expected finished verify_data, compares it with the received message, and if the check fails, it sends a 'decrypt_error' alert and terminates the connection. This directly implements the RFC requirement for Finished messages verification.",success,
7834,tls13_add_certificate,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Fully Matches,"[{'C1': {'code': '/* No branch adds a TLSEXT_TYPE_status_request_v2 extension */\nif (hs->ocsp_stapling_requested && cred->ocsp_response != NULL) {\n  CBB contents, ocsp_response;\n  if (!CBB_add_u16(&extensions, TLSEXT_TYPE_status_request) ||\n      !CBB_add_u16_length_prefixed(&extensions, &contents) ||\n      !CBB_add_u8(&contents, TLSEXT_STATUSTYPE_ocsp) ||\n      !CBB_add_u24_length_prefixed(&contents, &ocsp_response) ||\n      !CBB_add_bytes(&ocsp_response,\n                     CRYPTO_BUFFER_data(cred->ocsp_response.get()),\n                     CRYPTO_BUFFER_len(cred->ocsp_response.get())) ||\n      !CBB_flush(&extensions)) {\n    OPENSSL_PUT_ERROR(SSL, ERR_R_INTERNAL_ERROR);\n    return false;\n  }\n}', 'explanation': 'The TLS 1.3 specification prohibits sending the status_request_v2 extension in Certificate messages. This function adds the OCSP stapling extension using TLSEXT_TYPE_status_request (the allowed version) and does not reference or add any status_request_v2 extension. Hence, by omission, the forbidden extension is not sent.'}}]","The provided function builds a TLS 1.3 Certificate message and includes several extensions such as OCSP stapling and certificate timestamps. The TLS 1.3 RFC requirement is that servers must not send the status_request_v2 extension in the Certificate (as well as other) messages. The implementation only adds the standard status_request extension when OCSP stapling is requested and never adds or checks for status_request_v2. Therefore, by the logic present in this function alone, it fully meets the constraint C1, addressing the requirement as specified.",success,
7834,tls13_add_certificate,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The RFC requires that the OpenPGP certificate type MUST NOT be used with TLS 1.3. In tls13_add_certificate, although there is an assertion (assert(hs->credential->UsesX509());) implying that only X509 credentials are expected, there is no explicit check or enforcement within this function that prevents the use of OpenPGP certificate types. The function does not contain any logic that directly verifies or forbids OpenPGP certificates; it simply assumes that the credential is of the X509 type. As a result, this function does not visibly implement the spec constraint regarding OpenPGP certificate types.",success,
7835,tls13_add_certificate_verify,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function, tls13_add_certificate_verify, constructs and sends a Certificate Verify handshake message as part of the TLS 1.3 handshake. It does not contain any logic that prevents application data from being sent before the Finished message, which is the core requirement of the specification. No part of the tls13_add_certificate_verify function checks or enforces the ordering of Application Data relative to the Finished message, so none of the spec constraints (e.g., C1, A1) are addressed by this function in isolation.",success,
7838,tls13_receive_key_update,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u8(&body, &key_update_request) ||\n      CBS_len(&body) != 0 ||\n      (key_update_request != SSL_KEY_UPDATE_NOT_REQUESTED &&\n       key_update_request != SSL_KEY_UPDATE_REQUESTED)) {', 'explanation': 'This code segment checks that the message parses exactly as expected by verifying that exactly one byte is consumed and that the key update request value is within the valid range. This addresses the condition that a message with an out‐of-range length or content must be considered unparseable.'}}, {'A1': {'code': 'OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\nssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\nreturn false;', 'explanation': 'This segment handles the action defined in the spec: if the message cannot be parsed correctly, a decode_error alert is sent and the connection is terminated.'}}]","The function verifies that the key update message is properly parsed by ensuring it has exactly one byte and that the value is within the expected range. In the event of a parse error (either due to incorrect length or invalid value), the code sends a decode_error alert and terminates the connection. This directly corresponds to the RFC requirement that any message which cannot be parsed according to the syntax must result in a connection termination with a decode_error alert. Therefore, the function fully addresses the specified constraints.",success,
7838,tls13_receive_key_update,"Upon receiving a KeyUpdate, the receiver MUST update its receiving keys.",263,Fully Matches,"[{'C1': {'code': 'if (!tls13_rotate_traffic_key(ssl, evp_aead_open)) {\n    return false;\n}', 'explanation': 'This segment ensures that upon receiving a KeyUpdate, the function attempts to update the receiving keys by rotating the traffic key, directly implementing the RFC requirement.'}}, {'A1': {'code': 'if (key_update_request == SSL_KEY_UPDATE_REQUESTED &&\n    !tls13_add_key_update(ssl, SSL_KEY_UPDATE_NOT_REQUESTED)) {\n  return false;\n}', 'explanation': 'This portion acknowledges the KeyUpdate if the update request indicates that an acknowledgement is required, thereby further managing the key update process as intended.'}}]","The function validates the KeyUpdate message and then calls tls13_rotate_traffic_key to update the receiving keys, fulfilling the key requirement of the RFC. In addition, if the KeyUpdate message requests an acknowledgement, the function sends one by invoking tls13_add_key_update. Both of these operations are directly implemented in the function, so the logic fully addresses the specified RFC constraint.",success,
7838,tls13_receive_key_update,"If the request_update field is set to ""update_requested"", then the receiver MUST send a KeyUpdate of its own with request_update set to ""update_not_requested"" prior to sending its next Application Data record.",265,Fully Matches,"[{'C1': {'code': 'if (key_update_request == SSL_KEY_UPDATE_REQUESTED &&\n      !tls13_add_key_update(ssl, SSL_KEY_UPDATE_NOT_REQUESTED)) {\n    return false;\n  }', 'explanation': 'This segment checks if the key_update_request is set to update_requested, which is the condition specified by the RFC.'}}, {'A1': {'code': 'tls13_add_key_update(ssl, SSL_KEY_UPDATE_NOT_REQUESTED)', 'explanation': 'This call sends the KeyUpdate with request_update set to update_not_requested, fulfilling the action required by the RFC.'}}]","The function verifies the key update request by checking its value and, if it is 'update_requested', triggers the sending of a KeyUpdate with 'update_not_requested'. This logic directly addresses the specified RFC requirement, thereby fully matching the constraint within the function body.",success,
7839,tls13_post_handshake,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Fully Matches,"[{'C1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);', 'explanation': ""When an unexpected handshake message (i.e. any message that is neither a new session ticket nor a valid key update) is detected, the function sends an 'unexpected_message' alert. This addresses the condition that a handshake message received in an unexpected order must abort the handshake.""}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);\nOPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_MESSAGE);\nreturn false;', 'explanation': ""The function aborts the handshake by sending an 'unexpected_message' alert and returning false, which fulfills the required action specified by the RFC.""}}]","The function inspects the message type and only processes expected post-handshake messages (new session ticket and key update). For any other handshake message, it resets the key update count and explicitly sends an 'unexpected_message' alert (and logs an error) before aborting the handshake. This clearly implements the RFC specification requirement that a handshake message received out of order triggers an aborting alert, fulfilling both the condition (C1) and action (A1) within the function itself.",success,
7839,tls13_post_handshake,"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",272,Fully Matches,"[{'C1': {'code': 'if (msg.type == SSL3_MT_NEW_SESSION_TICKET && !ssl->server) { ... }  if (msg.type == SSL3_MT_KEY_UPDATE) { ... }  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);', 'explanation': ""The function checks for specific expected message types (NEW_SESSION_TICKET and KEY_UPDATE) and, for any other (i.e. unexpected) record type, it falls through to send an unexpected_message alert. This conditional structure implements the 'unexpected record type' check (C1).""}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);', 'explanation': 'When an unexpected record type is encountered, the function calls ssl_send_alert with the alert type SSL_AD_UNEXPECTED_MESSAGE, terminating the connection as required by the RFC.'}}]","The TLS 1.3 post-handshake function explicitly distinguishes between expected (NEW_SESSION_TICKET and KEY_UPDATE) and unexpected record types. For any record type that isn’t handled by the earlier conditions, it resets state and sends an 'unexpected_message' alert before terminating the connection. This behavior directly fulfills the RFC requirement that an unexpected record type must lead to connection termination with the corresponding alert.",success,
7840,ECKeyShare,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function is a simple constructor that initializes member variables (group_ and group_id_) without any conditional logic or actions that relate to the specified RFC requirements, such as handling handshake logic or condition evaluation for If-Unmodified-Since. There is no code within this function that addresses any labeled conditions (C1, C2, etc.) or actions (A1, A2, etc.).",success,
7843,Encap,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Does Not Match,[],"The provided function does not include any logic that addresses the specification constraint regarding SSL 3.0. The RFC requires that SSL 3.0 MUST NOT be negotiated, but the function merely sets an internal error alert and proceeds with Generate and Decap calls without any checks or conditions related to SSL 3.0 negotiation. There is no evidence in the code that it implements the necessary security requirement as specified by RFC6101 and RFC7568.",success,
7843,Encap,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The code function provided does not contain any logic that addresses the RFC requirement: 'Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.' There is no condition check, configuration or explicit exclusion of RC4 within the function_body. The code appears to perform operations related to ECDH and KEM-like abstractions (via Generate and Decap), but does not reference TLS cipher suite selection or negotiation, and thus does not meet any of the spec constraints regarding RC4.",success,
7844,Decap,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'A1': {'code': 'if (ciphertext.empty() || ciphertext[0] != POINT_CONVERSION_UNCOMPRESSED ||\n    !EC_POINT_oct2point(group_, peer_point.get(), ciphertext.data(),\n                        ciphertext.size(), /*ctx=*/nullptr)) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_ECPOINT);\n  *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n  return false;\n}', 'explanation': ""This segment checks the input ciphertext for validity. If the ciphertext is empty, does not start with the expected point conversion type, or cannot be converted properly into an EC_POINT, it sets the alert value to SSL_AD_ILLEGAL_PARAMETER and returns false. This behavior directly implements the RFC requirement that a semantically invalid message results in termination with an 'illegal_parameter' alert.""}}]","The function inspects the ciphertext to validate the provided EC point. In the event of an invalid input (i.e., a ciphertext that is syntactically correct but semantically invalid), the function triggers an error by setting the out_alert to SSL_AD_ILLEGAL_PARAMETER and returns false. This mirrors the RFC specification mandating peers to terminate the connection with an 'illegal_parameter' alert when encountering semantically invalid messages. All relevant logic is contained within the function itself, fulfilling the specified constraint.",success,
7847,X25519KeyShare,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The function X25519KeyShare() is empty and does not contain any logic that attempts to implement any of the labeled conditions or actions outlined in the spec constraints. There is no code within the function body that addresses the requirement of not acting upon information in 'supported_groups' prior to a successful handshake, nor any logic related to evaluating the conditions for an If-Unmodified-Since header field. Therefore, the function does not visibly address any of the specified conditions or actions.",success,
7847,X25519KeyShare,"In this mode, the server MUST NOT supply a ""key_share"" value.",141,Does Not Match,[],"The function 'X25519KeyShare() {}' is completely empty and does not include any logic that addresses the RFC specification which requires that the server MUST NOT supply a ""key_share"" value. There are no code segments within the function that enforce or even check for this constraint. Consequently, none of the labeled conditions or actions (e.g., C1, A1) are implemented in this function.",success,
7848,GroupID,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function simply returns a constant value (SSL_GROUP_X25519) and does not contain any logic that relates to the specified RFC constraints, such as ensuring that clients do not use supported_groups data prior to handshake completion or evaluating If-Unmodified-Since header conditions. There is no conditional logic, handshake verification, or header field evaluation implemented in this function.",success,
7849,Generate,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function solely generates a public key using the X25519_keypair function and appends it to the output buffer. There is no visible logic within the function_body that relates to any of the RFC specification constraints, such as verifying conditions on supported_groups or evaluating an If-Unmodified-Since header field as detailed in the provided spec context. Therefore, the function does not attempt to implement any labeled condition (C1, C2, ...) or action (A1, A2, ...) specified in the constraints.",success,
7850,Encap,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification prohibits offering or negotiating RC4 cipher suites. The provided function, Encap, is concerned with a KEM-like abstraction for X25519 operations and does not include any logic to address or handle cipher suite selection, particularly the exclusion of RC4. No part of its code references, checks, or modifies cipher suites, and thus it does not implement the specified RFC requirement.",success,
7850,Encap,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Does Not Match,[],"The provided function body does not contain any logic that addresses the security requirement specified in the RFC (i.e., that SSL 3.0 must not be negotiated). The function simply calls Generate and Decap (with the out_alert set to SSL_AD_INTERNAL_ERROR) without any conditional checks or mechanisms linked to disabling the negotiation of SSL 3.0 as per RFC6101 or RFC7568. No code segments are handling, detecting, or restricting SSL 3.0, so none of the spec constraints (whether labeled as C1, A1, etc.) are implemented within this function.",success,
7851,Decap,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (ciphertext.size() != 32 ||  //\n    !X25519(secret.data(), private_key_, ciphertext.data())) {', 'explanation': 'This check validates the expected size (and consequently the structure) of the incoming ciphertext, and verifies its semantic correctness using X25519. It directly addresses the condition where semantically invalid input should be detected.'}}, {'A1': {'code': '*out_alert = SSL_AD_ILLEGAL_PARAMETER;', 'explanation': ""Upon detecting an invalid ciphertext (either via incorrect size or failure of the X25519 operation), the function sets the out_alert to SSL_AD_ILLEGAL_PARAMETER, which meets the action requirement of terminating the connection with an 'illegal_parameter' alert when a semantically invalid message is received.""}}]","The function checks that the ciphertext is exactly 32 bytes and that a cryptographic operation (X25519) succeeds. If either check fails, it sets the alert to SSL_AD_ILLEGAL_PARAMETER and returns false. This behavior directly implements the RFC specification requirement that peers encountering a syntactically correct but semantically invalid input must terminate the connection by sending an illegal_parameter alert. All the logic required is implemented within the function itself without relying on external dependencies.",success,
7851,Decap,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification requires that implementations must not offer or negotiate RC4 cipher suites, but the provided function (Decap) does not contain any code related to cipher suite selection or negotiation. The function solely focuses on performing an X25519 key agreement operation, and there is no visible logic addressing RC4 or its prohibition in TLS. Therefore, no part of the function_body addresses the specified RFC constraint.",success,
7851,Decap,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Does Not Match,[],"The provided function 'Decap' performs cryptographic decapsulation using an X25519 operation on a 32-byte value, and it handles error conditions related to X25519 and array initialization. However, there is no logic within this function that checks or prevents the negotiation or usage of SSL 3.0 as required by the specification. The spec states that SSL 3.0 MUST NOT be negotiated due to its insufficient security, but this constraint is not implemented in the code. Thus, no labeled constraints (e.g., C1, A1) are visibly addressed by this function.",success,
7851,Decap,Ciphers with a strength less than 112 bits MUST NOT be offered or negotiated for any version of TLS for any reason.,390,Does Not Match,[],"The provided function does not include any logic to check or enforce the RFC requirement that ciphers with a strength less than 112 bits must not be offered or negotiated. The function solely performs a decapsulation operation using X25519 and error handling related to invalid EC points, with no reference or check to the cipher strength specification. Therefore, none of the labeled conditions or actions (e.g., C1) from the spec constraints are visibly implemented within this function.",success,
7854,X25519Kyber768KeyShare,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function 'X25519Kyber768KeyShare() {}' is an empty implementation that does not include any logic addressing the specified conditions or actions from the RFC and the provided constraints. No code segments are present that attempt to handle or validate supported_groups or manage the key_share extension according to the requirements, so it fails to implement any of the labeled conditions (C1, etc.) or actions (A1, etc.) within the function body.",success,
7855,GroupID,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function only returns a constant group identifier (SSL_GROUP_X25519_KYBER768_DRAFT00) and does not include any logic related to the conditions or actions specified in the RFC specification. There is no handling of handshake completion, no conditional logic to verify header dates (such as If-Unmodified-Since evaluations), and nothing that reflects the specifications requiring behavior based on successful handshake outcomes or conditional sections (C1, A1, etc.). The function_body does not implement any of the labeled constraints.",success,
7856,Generate,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided code function does not address any of the specified RFC constraints. The RFC spec discusses not acting on information in 'supported_groups' before a handshake is complete and potentially modifying key groups based on handshake results, as well as HTTP precondition evaluation (If-Unmodified-Since). In contrast, the function solely generates two key pairs (one X25519 and one Kyber), appending their public key bytes to an output buffer. There is no logic present in the function that deals with any handshake completion checks, conditional evaluations, or related actions mandated by the spec.",success,
7857,Encap,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'C1': {'code': 'if (!CBS_get_bytes(&peer_key_cbs, &peer_x25519_cbs, 32) ||\n        !CBS_get_bytes(&peer_key_cbs, &peer_kyber_cbs, KYBER_PUBLIC_KEY_BYTES) ||\n        CBS_len(&peer_key_cbs) != 0 ||\n        !X25519(secret.data(), x25519_private_key_, CBS_data(&peer_x25519_cbs)) ||\n        !KYBER_parse_public_key(&peer_kyber_pub, &peer_kyber_cbs)) {\n      *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n      OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_ECPOINT);\n      return false;\n    }', 'explanation': 'This segment verifies that the incoming key material is well-formed. In the case of any syntactical or semantic error (e.g., unexpected length, failure in key parsing), it sets the alert to SSL_AD_ILLEGAL_PARAMETER, which follows the RFC requirement to terminate the connection when a semantically invalid message is received.'}}]","The function includes logic that detects invalid input parameters and responds by setting an 'illegal_parameter' alert. This behavior addresses the RFC specification's requirement for terminating connections upon syntactically correct but semantically invalid messages. However, while it addresses the error reporting aspect, the function does not encompass other aspects of connection management or persistence as mentioned in the broader Context (sr_context), hence it only partially matches the constraints.",success,
7857,Encap,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided code function 'Encap' is solely concerned with key encapsulation using X25519 and Kyber algorithms and does not include any logic related to cipher suite negotiation or the exclusion of RC4 cipher suites. The specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites, but none of the code in this function addresses or references RC4. Therefore, the function does not attempt to implement the specified HTTP RFC condition regarding RC4.",success,
7858,Decap,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'A1': {'code': 'if (ciphertext.size() != 32 + KYBER_CIPHERTEXT_BYTES ||\n    !X25519(secret.data(), x25519_private_key_, ciphertext.data())) {\n  *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n  OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_ECPOINT);\n  return false;\n}', 'explanation': ""The RFC requires that when a semantically invalid message is received, the connection must be terminated with an 'illegal_parameter' alert. In this function, if the ciphertext does not meet the expected length or the X25519 operation fails (indicating a semantic error in the message), the function sets '*out_alert' to 'SSL_AD_ILLEGAL_PARAMETER' and returns false, thereby fulfilling the required action.""}}]",The function verifies input correctness by checking the ciphertext size and the result of the X25519 key exchange operation. When either check fails—indicative of a semantically invalid message—the function explicitly sets an 'illegal_parameter' alert and returns an error. This behavior directly addresses the RFC specification dictating that peers must terminate the connection with an 'illegal_parameter' alert when receiving a message that is syntactically correct but semantically invalid. The logic is contained within the function itself and thus fully meets the constraint.,success,
7858,Decap,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function performs key decapsulation using X25519 and KYBER algorithms and does not include any logic related to cipher suite negotiation or filtering. There is no check or condition that prevents RC4 cipher suites from being offered or negotiated as required by the specification. Therefore, the function does not address the RFC requirement to not offer or negotiate RC4 cipher suites.",success,
7858,Decap,Ciphers with a strength less than 112 bits MUST NOT be offered or negotiated for any version of TLS for any reason.,390,Does Not Match,[],"The RFC requires that ciphers with a strength less than 112 bits MUST NOT be offered or negotiated. However, the provided function 'Decap' only performs key decapsulation using X25519 and KYBER mechanisms and does not include any logic to evaluate or enforce cipher strength requirements. There is no code that checks for cipher strength or that restricts the negotiation of ciphers below the 112-bit threshold. Therefore, the function does not address the specified constraint.",success,
7858,Decap,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Does Not Match,[],"The provided function body implements a decapsulation mechanism using X25519 and Kyber, but it does not address any constraints related to the security requirement of never negotiating SSL 3.0 as specified by the RFC. There is no logic present in the function that restricts or prevents the negotiation of SSL 3.0, which is the primary condition according to the provided RFC specification. As a result, none of the labeled conditions or actions (e.g., C1, A1) are implemented within the function.",success,
7858,Decap,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Does Not Match,[],"The provided code function implements a decapsulation routine using X25519 and KYBER. It lacks any logic related to HKDF-Extract or HKDF-Expand, or any ordering checks that would prevent using an output of HKDF-Extract as an input to another application of HKDF-Extract without an intermediate HKDF-Expand, as specified. Therefore, the function does not address the spec constraint.",success,
7859,X25519MLKEM768KeyShare,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function 'X25519MLKEM768KeyShare() {}' does not contain any logic that addresses the spec constraints (such as checking or processing the supported_groups information as per the handshake or evaluating the If-Unmodified-Since header conditions). The function body is empty, and therefore, it does not implement any conditions or actions (like C1 or A1) by itself.",success,
7860,GroupID,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function simply returns a constant value (SSL_GROUP_X25519_MLKEM768) for the group ID and does not contain any logic addressing the RFC specifications or the associated spec constraints regarding supported_groups, handshake conditions, or the evaluation of an If-Unmodified-Since header field. Therefore, none of the labeled conditions (e.g., C1) or actions (e.g., A1) are implemented within this function.",success,
7862,Encap,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (!CBS_get_bytes(&peer_key_cbs, &peer_mlkem_cbs, MLKEM768_PUBLIC_KEY_BYTES) ||\n    !MLKEM768_parse_public_key(&peer_mlkem_pub, &peer_mlkem_cbs) ||\n    !CBS_get_bytes(&peer_key_cbs, &peer_x25519_cbs, X25519_PUBLIC_VALUE_LEN) ||\n    CBS_len(&peer_key_cbs) != 0 ||\n    !X25519(secret.data() + MLKEM_SHARED_SECRET_BYTES, x25519_private_key_,\n            CBS_data(&peer_x25519_cbs))) {\n  *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n  OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_ECPOINT);\n  return false;\n}', 'explanation': ""This code segment verifies that the received key material is semantically valid. In cases where the input is syntactically well-formed but semantically invalid, it sets the alert to SSL_AD_ILLEGAL_PARAMETER and returns false. This behavior aligns with the RFC directive to terminate the connection with an 'illegal_parameter' alert when invalid parameters are received.""}}]","The function implements the error-handling path required by the RFC for semantically invalid input by setting an illegal_parameter alert. However, while it visibly addresses the alerting action (A1) for the specific invalid input condition, it does not encompass the full breadth of the RFC (for example, aspects of persistent connection management mentioned in the spec context). Hence, the overall implementation only partially matches the spec constraints.",success,
7863,Decap,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'A1': {'code': 'if (ciphertext.size() != MLKEM768_CIPHERTEXT_BYTES + X25519_PUBLIC_VALUE_LEN ||\n    !MLKEM768_decap(secret.data(), ciphertext.data(), MLKEM768_CIPHERTEXT_BYTES, &mlkem_private_key_) ||\n    !X25519(secret.data() + MLKEM_SHARED_SECRET_BYTES, x25519_private_key_,\n          ciphertext.data() + MLKEM768_CIPHERTEXT_BYTES)) {\n  *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n  OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_ECPOINT);\n  return false;\n}', 'explanation': 'This block checks for an invalid message (whether by ciphertext size or decryption failure) and, upon detecting such a condition, sets the alert to SSL_AD_ILLEGAL_PARAMETER, thereby complying with the RFC requirement that an illegal parameter alert must be generated when a semantically invalid message is received.'}}]","The function 'Decap' implements a check on the received ciphertext for validity. If the ciphertext fails size validation or decryption (indicating a semantically invalid message), the function sets out_alert to SSL_AD_ILLEGAL_PARAMETER and returns false. This behavior directly reflects the RFC mandate wherein peers must terminate the connection with an 'illegal_parameter' alert on receiving a syntactically correct but semantically invalid message. All relevant logic fulfilling this specification is contained within this function body.",success,
7866,ssl_nid_to_group_id,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function only iterates through a list of named groups to match an NID and assign a corresponding group_id. It does not implement any logic related to the RFC specification, which involves conditions regarding the use of information from the supported_groups field or the evaluation of an If-Unmodified-Since header. Therefore, none of the spec constraints (e.g., C1, A1) are addressed within this function's code.",success,
7869,SSL_get_group_name,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function is a simple lookup implementation that returns a group name based on a given group ID. It does not include any logic related to handshake procedures or conditions such as ensuring that supported_groups information is only acted upon after a successful handshake. There is also no handling of conditional logic as described in the spec regarding the use of the If-Unmodified-Since header field. Therefore, no part of the function addresses the labeled conditions or actions outlined in the spec constraints.",success,
8154,add_record_to_flight,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Does Not Match,[],"The provided function, add_record_to_flight, constructs and seals a TLS record (using tls_seal_record) and manages dynamic memory for the pending flight. However, there is no visible logic within the function that implements or even considers optional padding when generating a TLSCiphertext record as stipulated by the specification. The code does not check for alignment or add any extra bytes to pad the record. Additionally, the HTTP request context provided in sr_context is not addressed here. Therefore, the function does not attempt to implement the relevant spec constraint regarding padding.",success,
8157,tls_add_message,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification prohibits the use of the Truncated HMAC extension for AEAD algorithms; however, the tls_add_message function contains logic related to fragmenting handshake messages and handling encryption overhead. There is no visible logic in this function that addresses or prevents the use of the Truncated HMAC extension. No code segments in the function check for, disable, or otherwise handle the truncated HMAC extension, so the function does not satisfy any labeled constraints (such as C1 or A1) derived from the specification.",success,
8157,tls_add_message,"Handshake messages MAY be coalesced into a single TLSPlaintext record or fragmented across several records, provided that:",274,Partially Matches,"[{'C1': {'code': 'if (!SSL_is_quic(ssl) && ssl->s3->aead_write_ctx->is_null_cipher()) {\n    while (!rest.empty()) {\n      Span<const uint8_t> chunk = rest.subspan(0, ssl->max_send_fragment);\n      rest = rest.subspan(chunk.size());\n\n      if (!add_record_to_flight(ssl, SSL3_RT_HANDSHAKE, chunk)) {\n        return false;\n      }\n    }\n  } else {\n    while (!rest.empty()) {\n      // Flush if |pending_hs_data| is full.\n      if (ssl->s3->pending_hs_data &&\n          ssl->s3->pending_hs_data->length >= ssl->max_send_fragment &&\n          !tls_flush_pending_hs_data(ssl)) {\n        return false;\n      }\n\n      size_t pending_len =\n          ssl->s3->pending_hs_data ? ssl->s3->pending_hs_data->length : 0;\n      Span<const uint8_t> chunk =\n          rest.subspan(0, ssl->max_send_fragment - pending_len);\n      assert(!chunk.empty());\n      rest = rest.subspan(chunk.size());\n\n      if (!ssl->s3->pending_hs_data) {\n        ssl->s3->pending_hs_data.reset(BUF_MEM_new());\n      }\n      if (!ssl->s3->pending_hs_data ||\n          !BUF_MEM_append(ssl->s3->pending_hs_data.get(), chunk.data(),\n                          chunk.size())) {\n        return false;\n      }\n    }\n  }', 'explanation': 'This segment shows the function’s attempt to either send handshake messages immediately (for null cipher) or to accumulate them (for non-null ciphers) into a buffer. It intends to coalesce handshake messages into as few records as possible while respecting the max_send_fragment size. This addresses the RFC requirement that handshake messages may be coalesced or fragmented.'}}, {'A1': {'code': 'ssl_do_msg_callback(ssl, 1 /* write */, SSL3_RT_HANDSHAKE, msg);\nif (ssl->s3->hs != NULL &&  \n    !ssl->s3->hs->transcript.Update(msg)) {\n  return false;\n}', 'explanation': 'After processing and fragmenting the handshake messages, this code invokes callbacks and updates the handshake transcript. Although not a direct implementation of a coalescing action, it ensures that the resultant TLSPlaintext record(s) are properly handled, which aligns with the overall intent of the specification.'}}]","The provided function implements logic to fragment and potentially coalesce handshake messages into TLS records based on the maximum fragment size (ssl->max_send_fragment). It distinguishes between cases (null cipher vs. others) and gathers handshake data accordingly. While the function does attempt to implement the coalescing/fragmentation behavior as specified in the RFC, some aspects of the behavior are dependent on external helper functions (such as add_record_to_flight and tls_flush_pending_hs_data) and do not cover every detail explicitly within this function. Therefore, the implementation only partially meets the specified constraints on handshake message coalescing.",success,
8157,tls_add_message,-Handshake messages MUST NOT be interleaved with other record types.,275,Fully Matches,"[{'C1': {'code': 'if (!SSL_is_quic(ssl) && ssl->s3->aead_write_ctx->is_null_cipher()) {\n  while (!rest.empty()) {\n      Span<const uint8_t> chunk = rest.subspan(0, ssl->max_send_fragment);\n      rest = rest.subspan(chunk.size());\n\n      if (!add_record_to_flight(ssl, SSL3_RT_HANDSHAKE, chunk)) {\n        return false;\n      }\n  }\n} else {\n  while (!rest.empty()) {\n      if (ssl->s3->pending_hs_data &&\n          ssl->s3->pending_hs_data->length >= ssl->max_send_fragment &&\n          !tls_flush_pending_hs_data(ssl)) {\n        return false;\n      }\n\n      size_t pending_len = ssl->s3->pending_hs_data ? ssl->s3->pending_hs_data->length : 0;\n      Span<const uint8_t> chunk = rest.subspan(0, ssl->max_send_fragment - pending_len);\n      assert(!chunk.empty());\n      rest = rest.subspan(chunk.size());\n\n      if (!ssl->s3->pending_hs_data) {\n        ssl->s3->pending_hs_data.reset(BUF_MEM_new());\n      }\n      if (!ssl->s3->pending_hs_data ||\n          !BUF_MEM_append(ssl->s3->pending_hs_data.get(), chunk.data(), chunk.size())) {\n        return false;\n      }\n  }\n}', 'explanation': 'The function exclusively handles handshake messages by either directly adding them as handshake records or by buffering them in pending_hs_data. By ensuring that only handshake data (record type SSL3_RT_HANDSHAKE) is manipulated and sent, it prevents any interleaving with other record types, which directly implements the RFC constraint.'}}]","The tls_add_message function is solely concerned with handling handshake messages. It segments the input handshake data and either sends it immediately as a handshake record (in one branch) or accumulates it in a dedicated handshake buffer (in the other branch). In both cases, the code does not mix handshake data with any other record types, thereby ensuring that handshake messages are not interleaved with records of other types. This isolated handling meets the RFC requirement that 'Handshake messages MUST NOT be interleaved with other record types.'",success,
8157,tls_add_message,"That is, if a handshake message is split over two or more records, there MUST NOT be any other records between them.",276,Fully Matches,"[{'C1': {'code': 'while (!rest.empty()) {\n  Span<const uint8_t> chunk = rest.subspan(0, ssl->max_send_fragment);\n  rest = rest.subspan(chunk.size());\n  if (!add_record_to_flight(ssl, SSL3_RT_HANDSHAKE, chunk)) {\n    return false;\n  }\n}\n\n// ...\n\nwhile (!rest.empty()) {\n  if (ssl->s3->pending_hs_data &&\n      ssl->s3->pending_hs_data->length >= ssl->max_send_fragment &&\n      !tls_flush_pending_hs_data(ssl)) {\n    return false;\n  }\n\n  size_t pending_len = ssl->s3->pending_hs_data ? ssl->s3->pending_hs_data->length : 0;\n  Span<const uint8_t> chunk = rest.subspan(0, ssl->max_send_fragment - pending_len);\n  assert(!chunk.empty());\n  rest = rest.subspan(chunk.size());\n\n  if (!ssl->s3->pending_hs_data) {\n    ssl->s3->pending_hs_data.reset(BUF_MEM_new());\n  }\n  if (!ssl->s3->pending_hs_data ||\n      !BUF_MEM_append(ssl->s3->pending_hs_data.get(), chunk.data(), chunk.size())) {\n    return false;\n  }\n}', 'explanation': 'The function exclusively processes an entire handshake message, splitting it into fragments only when necessary due to the maximum fragment size. It handles both the null cipher case (sending records immediately via add_record_to_flight) and the encrypted case (accumulating fragments in a pending handshake buffer). In both scenarios, the handshake fragments are generated consecutively without any interleaving of records from other message types, which directly meets the requirement stated in the RFC.'}}]","The code function 'tls_add_message' is designed to pack a handshake message into a sequence of records without inserting any unrelated records between the fragments. Whether in the null cipher case or when using encryption (accumulated pending data), it ensures that if a handshake message is split over multiple records, the fragments are produced continuously and consecutively. This behavior directly addresses the RFC constraint that no other records must interfere between handshake fragments.",success,
8161,read_v2_client_hello,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function, read_v2_client_hello, is designed to process a legacy SSLv2 ClientHello message and transform it into a TLS ClientHello format. It does not contain any logic addressing the TLS 1.3 requirements regarding status_request_v2 extension (i.e. it does not check for or omit sending the status_request_v2 extension in EncryptedExtensions, CertificateRequest, or Certificate messages) nor does it address any HTTP message framing concerns as described in the specification context. Therefore, no part of the code function implements any of the specified constraints (e.g., C1, A1) in the provided RFC specification.",success,
8161,read_v2_client_hello,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function, read_v2_client_hello, is responsible for parsing and converting a legacy SSLv2 ClientHello into a TLS ClientHello. It handles message lengths, version conversion, and cipher suite extraction, among other tasks related to the handshake process. However, the specified RFC constraint regarding the prohibition of using the OpenPGP certificate type with TLS 1.3 is not addressed anywhere in this function. There is no logic in this function that inspects or restricts certificate types or checks for TLS 1.3. Therefore, the function does not implement any condition or action related to the RFC6091 requirement.",success,
8161,read_v2_client_hello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (msg_length > (1024 * 4)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_RECORD_TOO_LARGE);\n    return ssl_open_record_error;\n  }\n  if (msg_length < SSL3_RT_HEADER_LENGTH - 2) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_RECORD_LENGTH_MISMATCH);\n    return ssl_open_record_error;\n  }', 'explanation': 'These lines validate that the message length is neither too large (extending beyond expected limits) nor too short (shorter than the required header), which addresses the spec requirement to detect out‐of-range or invalid lengths.'}}, {'A1': {'code': 'if (!CBS_get_u8(&v2_client_hello, &msg_type) ||\n      !CBS_get_u16(&v2_client_hello, &version) ||\n      !CBS_get_u16(&v2_client_hello, &cipher_spec_length) ||\n      !CBS_get_u16(&v2_client_hello, &session_id_length) ||\n      !CBS_get_u16(&v2_client_hello, &challenge_length) ||\n      !CBS_get_bytes(&v2_client_hello, &cipher_specs, cipher_spec_length) ||\n      !CBS_get_bytes(&v2_client_hello, &session_id, session_id_length) ||\n      !CBS_get_bytes(&v2_client_hello, &challenge, challenge_length) ||\n      CBS_len(&v2_client_hello) != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    return ssl_open_record_error;\n  }', 'explanation': 'This segment attempts to parse the various fields of the V2ClientHello and if any step fails (i.e. the message cannot be fully parsed according to the expected syntax), it issues a decode error alert and returns an error, thereby terminating connection processing as mandated.'}}]","The function implements the RFC mandate by strictly checking the incoming message's length and complete parseability. When the message either extends beyond expected boundaries or has a parsing failure, it calls OPENSSL_PUT_ERROR with the specific decode error codes and returns an error state. This direct handling within the function fulfills the requirement that peers terminate the connection with a 'decode_error' alert upon receiving an unparseable message.",success,
8161,read_v2_client_hello,"For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS.",22,Fully Matches,"[{'A1': {'code': ' // Add the null compression scheme and finish.\n if (!CBB_add_u8(&hello_body, 1) ||  //\n     !CBB_add_u8(&hello_body, 0) ||  //\n     !CBB_finish(client_hello.get(), NULL, &ssl->s3->hs_buf->length)) { ... }', 'explanation': 'This segment explicitly writes out a compression vector with a length byte of 1 followed by a single compression method byte set to 0. This exactly implements the requirement that for every TLS ClientHello, the compression method vector must contain exactly one byte with the value zero.'}}]","The function constructs a TLS ClientHello message (converted from a V2ClientHello) and, within its own logic, appends a compression vector that meets the TLS specification requirement (exactly one byte set to zero). No other unrelated HTTP logic is present, and the null compression method handling is fully accomplished within this function.",success,
8167,tls_open_handshake,"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",272,Fully Matches,"[{'C1': {'code': 'if (type != SSL3_RT_HANDSHAKE) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_RECORD);\n    *out_alert = SSL_AD_UNEXPECTED_MESSAGE;\n    return ssl_open_record_error;\n}', 'explanation': 'This code segment checks if the received record type is not the expected HANDSHAKE type. This directly corresponds to the condition in the RFC that dictates handling an unexpected record type.'}}, {'A1': {'code': '*out_alert = SSL_AD_UNEXPECTED_MESSAGE;', 'explanation': ""Upon detecting an unexpected record type, the function sets the alert to 'unexpected_message' and returns an error, thereby terminating the connection in accordance with the RFC specification.""}}]","The function implements the RFC requirement by checking the record type after processing the TLS record. If the record type is not SSL3_RT_HANDSHAKE (i.e., unexpected), it sets an 'unexpected_message' alert and terminates the connection by returning an error. Thus, the necessary condition (C1) and subsequent action (A1) from the spec are fully addressed within the function_body.",success,
8167,tls_open_handshake,-Handshake messages MUST NOT be interleaved with other record types.,275,Fully Matches,"[{'C1': {'code': 'if (type != SSL3_RT_HANDSHAKE) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_RECORD);\n    *out_alert = SSL_AD_UNEXPECTED_MESSAGE;\n    return ssl_open_record_error;\n  }', 'explanation': 'This code segment directly enforces that the record type must be a handshake. If the record returned by tls_open_record is not of type SSL3_RT_HANDSHAKE, it returns an error, ensuring that handshake messages are not interleaved with other record types as required by the RFC.'}}]","The provided function begins by handling special cases and then retrieves a record using tls_open_record. It explicitly checks that the record's type is SSL3_RT_HANDSHAKE and otherwise signals an error, thereby implementing the RFC requirement that handshake messages must not be interleaved with other record types. This logic is contained completely within the function, matching the spec constraint (labeled here as C1).",success,
8175,Evaluate,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function only evaluates the cipher suite identifiers (specifically for TLS 1.3 ciphers) by returning scores based on which TLS 1.3 cipher is in use. There is no reference or logic that checks whether an OpenPGP certificate type is being used with TLS 1.3, as required by RFC6091. Therefore, the function does not implement the spec constraints (C1, A1, etc.) related to disallowing OpenPGP certificate usage with TLS 1.3.",success,
8175,Evaluate,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The TLS RFC specification states that values within the 'obsolete_RESERVED' range must not be offered or negotiated by TLS 1.3 implementations. The provided function only scores a couple of specific TLS 1.3 cipher suites (TLS1_3_CK_AES_256_GCM_SHA384 and TLS1_3_CK_AES_128_GCM_SHA256) and returns a default score for any other cipher, without any logic to check or filter out cipher suites whose values fall in the obsolete_RESERVED ranges. Therefore, the function does not visibly implement the necessary logic to meet the spec constraint.",success,
8177,ssl_choose_tls13_cipher,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The function ssl_choose_tls13_cipher is solely concerned with selecting a TLS 1.3 cipher based on a list of cipher suites, version, and compliance policy. It does not handle any aspects of processing ClientHello messages or enforce requirements related to the status_request_v2 extension as specified in the RFC. Additionally, it does not address any HTTP header field issues (e.g., Transfer-Encoding or Content-Length) mentioned in the spec context. Therefore, no part of the function's code fulfills any of the labeled conditions or actions.",success,
8190,tls1_check_duplicate_extensions,There MUST NOT be more than one extension of the same type in a given extension block.,63,Fully Matches,"[{'C1': {'code': 'qsort(extension_types.data(), extension_types.size(), sizeof(uint16_t), compare_uint16_t);\n  for (size_t i = 1; i < num_extensions; i++) {\n    if (extension_types[i - 1] == extension_types[i]) {\n      return false;\n    }\n  }', 'explanation': 'This code sorts the collected extension types and iterates through them to check for any duplicate values. If a duplicate is found, the function returns false, thereby enforcing that there is no more than one extension of the same type in the block, which directly implements the RFC requirement.'}}]","The function tls1_check_duplicate_extensions fully addresses the specified RFC requirement by first counting the number of extensions, collecting their types, sorting them, and then checking for duplicates. The presence of duplicate extension types causes an immediate false return, which ensures compliance with the specification that forbids multiple extensions of the same type.",success,
8192,ssl_parse_client_hello_with_trailing_data,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The RFC specification requires that TLS 1.3 servers must not act upon the status_request_v2 extension when processing ClientHello messages. This function, ssl_parse_client_hello_with_trailing_data, is strictly parsing various parts of the ClientHello message (like version, random, session_id, cookie for DTLS, cipher suites, compression methods, and extensions) without any logic to ignore or conditionally process the status_request_v2 extension. There is no conditional check or filtering for the status_request_v2 extension in the parsed extensions. Thus, the function does not address the specified RFC constraint by itself, and consequently, it does not match the requirement.",success,
8192,ssl_parse_client_hello_with_trailing_data,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function does not include any logic that specifically examines or excludes the Truncated HMAC extension as mandated by the RFC specification. There is no code that looks for, rejects, or otherwise handles the Truncated HMAC extension (related to AEAD algorithms) within the function_body. All operations focus on parsing the ClientHello components, and there is no segment that meets a constraint (e.g., a condition labeled as C1 or action labeled as A1) pertaining to the exclusion of the Truncated HMAC extension.",success,
8192,ssl_parse_client_hello_with_trailing_data,There MUST NOT be more than one extension of the same type in a given extension block.,63,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16_length_prefixed(cbs, &extensions) ||\n        !tls1_check_duplicate_extensions(&extensions)) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_CLIENTHELLO_PARSE_FAILED);\n  return false;\n}', 'explanation': 'This segment extracts the extension block and invokes tls1_check_duplicate_extensions to ensure that there are no duplicate extensions in the block, thus enforcing the RFC requirement that there MUST NOT be more than one extension of the same type.'}}]",The provided function directly implements the specified RFC constraint by checking the extension block for duplicate extensions using tls1_check_duplicate_extensions. This self-contained check within the function fully addresses the condition that no extension type should appear more than once in the block.,success,
8192,ssl_parse_client_hello_with_trailing_data,"Implementations which have the same policy in both cases MAY omit the ""signature_algorithms_cert"" extension.",85,Does Not Match,[],"The provided spec requires that implementations optionally omit the 'signature_algorithms_cert' extension when the same policy is used in both cases. In the function_body, while there is logic to parse the ClientHello message and extract any available extensions, there is no specific logic addressing or conditionally omitting the 'signature_algorithms_cert' extension. The code simply checks for the presence of extensions and validates for duplicate extensions. Thus, no identifiable code segment implements the spec constraint regarding the omission of 'signature_algorithms_cert', and the function does not visibly address the required condition.",success,
8193,ssl_client_hello_get_extension,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The given function ssl_client_hello_get_extension simply iterates through the SSL client hello extensions and returns the one matching a provided extension type. It does not include any logic related to checking handshake completion or conditions regarding the use of data from the 'supported_groups' extension as mandated by the RFC spec. There is no logic in this function that corresponds to any of the labeled conditions or actions (C1, A1, etc.) from the RFC specification regarding handshake state management or decision-making based on the 'supported_groups' and 'key_share' extensions.",success,
8193,ssl_client_hello_get_extension,-TLS 1.2 ClientHellos MAY omit this extension.,99,Does Not Match,[],"The provided function ssl_client_hello_get_extension only iterates over and retrieves a TLS extension from a ClientHello message if present. It does not contain any logic that addresses the RFC specifications stated (for example, the optionality of the extension in TLS 1.2 or the evaluation of an If-Match header field as described in sr_context). There is no visible implementation of any labeled condition (e.g., C1) or action (e.g., A1) within the function_body itself; it simply returns the extension if found or false otherwise. Thus, the function does not implement the relevant RFC constraints by itself.",success,
8195,tls1_get_shared_group,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function tls1_get_shared_group is concerned with selecting a TLS key-sharing group by intersecting the server’s group list and the client's supported_groups list. It contains logic related to ordering and filtering groups (e.g., preferring one list over the other and screening out post-quantum groups under TLS 1.2 and below). However, none of its logic directly addresses the RFC spec constraints given—in particular, it does not implement any check or behavior regarding acting on information in the supported_groups extension only after a successful handshake, nor does it contain any logic related to conditional handling of HTTP fields like the If-Unmodified-Since header as described in the sr_context. Since these aspects are not present in the function itself (even though they are mentioned in the RFC specification and spec constraints), the function does not visibly address any of the labeled conditions or actions (e.g., C1, A1) from the provided spec constraints.",success,
8199,tls12_check_peer_sigalg,"-The server's end-entity certificate's public key (and associated restrictions) MUST be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension (currently RSA, ECDSA, or EdDSA).",205,Fully Matches,"[{'C1': {'code': 'if (std::find(sigalgs.begin(), sigalgs.end(), sigalg) == sigalgs.end() ||\n      !ssl_pkey_supports_algorithm(hs->ssl, pkey, sigalg, /*is_verify=*/true)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_SIGNATURE_TYPE);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n}', 'explanation': ""This code verifies that the signature algorithm chosen by the peer is within the permitted list (as would be advertised in the signature_algorithms extension) and that the server's public key (certificate) supports the selected algorithm. This directly implements the spec requirement that the server's certificate public key must be compatible with the selected authentication algorithm.""}}]",The function tls12_check_peer_sigalg directly addresses the sole required constraint (labeled here as C1) by checking if the provided signature algorithm is in the allowed set and then confirming that the certificate's public key supports that algorithm. This fully meets the requirement stated in the RFC specification.,success,
8199,tls12_check_peer_sigalg,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (std::find(sigalgs.begin(), sigalgs.end(), sigalg) == sigalgs.end() ||\n      !ssl_pkey_supports_algorithm(hs->ssl, pkey, sigalg, /*is_verify=*/true))', 'explanation': 'This code segment checks that the peer’s selected signature algorithm is among the advertised options and that the public key supports it, thereby validating the message semantics as required by the spec.'}}, {'A1': {'code': '*out_alert = SSL_AD_ILLEGAL_PARAMETER;', 'explanation': ""This line sets the alert to 'illegal_parameter', which fulfills the action requirement of terminating the connection when a semantically invalid message is detected.""}}]","The function tls12_check_peer_sigalg directly addresses the RFC specification by checking if the signature algorithm provided is valid (C1) and, if not, by setting an 'illegal_parameter' alert (A1). This behavior ensures that the peer terminates the connection in case of a semantically invalid message, which fully matches the spec requirements.",success,
8201,ssl_parse_flags_extension,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!CBS_get_u8_length_prefixed(&copy, &flags) ||  \n      CBS_len(&copy) != 0 ||                         \n      CBS_len(&flags) == 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n  }', 'explanation': 'This segment checks for several parse errors (improper length prefixing, extra data, and empty flags) and returns a decode error alert as required by the RFC when a message cannot be parsed.'}}, {'A1': {'code': 'OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n*out_alert = SSL_AD_DECODE_ERROR;\nreturn false;', 'explanation': 'The code uses a decode_error alert in one branch (for general parse failures) which aligns with the RFC requirement to terminate with a decode_error alert.'}}]","The function attempts to implement the RFC mandate by checking the parsing of message components and, in some cases, issuing a decode_error alert to terminate the connection. However, not all error conditions trigger the decode_error alert; for instance, if trailing zeros are detected or if the flag length exceeds the representable size (when unknown flags are not allowed), the function returns an illegal parameter alert instead. Because the RFC requires that any parse failure result in a decode_error alert, this discrepancy means the function only partially matches the specification.",success,
8201,ssl_parse_flags_extension,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (CBS_data(&flags)[CBS_len(&flags) - 1] == 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n}\n\nif (!allow_unknown && CBS_len(&flags) > sizeof(SSLFlags)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_EXTENSION);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n}', 'explanation': ""These segments check for semantically invalid messages (e.g., trailing zero in the flags data and unexpected extra flag bytes when unknown flags are disallowed) and terminate processing by setting the alert to SSL_AD_ILLEGAL_PARAMETER. This behavior attempts to satisfy the spec requirement that peers must terminate the connection with an 'illegal_parameter' alert upon receiving a semantically invalid message.""}}]","The function inspects an extension’s flag data to validate its syntax and semantics. In cases where the message is semantically invalid (as indicated by a trailing zero or unsolicited flag bits when unknown flags are not allowed), the function terminates processing by setting the alert to SSL_AD_ILLEGAL_PARAMETER. This shows an attempt to implement the spec requirement regarding termination upon encountering semantically invalid messages. However, not all error cases are treated with an 'illegal_parameter' alert (for example, some decoding issues use a different alert), and the overall set of semantic validations may be incomplete relative to the full specification. Hence, the function only partially matches the specified constraint.",success,
8201,ssl_parse_flags_extension,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'C1': {'code': 'if (!CBS_get_u8_length_prefixed(&copy, &flags) ||\n      CBS_len(&copy) != 0 ||\n      CBS_len(&flags) == 0) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n  *out_alert = SSL_AD_DECODE_ERROR;\n  return false;\n}', 'explanation': 'This code block checks that the flags extension is correctly encoded (non‐empty, correct total length) and aborts the handshake with a \'decode_error\' alert if the condition is not met. This directly corresponds to the spec requirement: \'if not, then it MUST abort the handshake with a ""decode_error"" alert.\''}}]","The function implements error checking on a length‐prefixed flags extension. When the flags field fails basic validity tests (for example, if parsing fails, there is extra data after the length-prefixed section, or if the flags are empty), the function aborts the handshake by setting a decode_error alert. This matches the specific requirement highlighted in the RFC spec. However, the RFC context also discusses protocol-specific and upgrade header ordering issues that the function does not address. Therefore, only part of the specified RFC constraints (the aborting with a decode_error when conditions aren’t met) is implemented in this function.",success,
8203,ssl_parse_flags_extension_response,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if ((*out & allowed_flags) != *out)', 'explanation': 'This check confirms that all received flags are within the set of allowed flags. If the parsed flags are not a subset of allowed_flags, it indicates that the message is semantically invalid.'}}, {'A1': {'code': '*out_alert = SSL_AD_ILLEGAL_PARAMETER;', 'explanation': 'When unsolicited (disallowed) flags are detected, the function sets the alert to SSL_AD_ILLEGAL_PARAMETER, which enforces termination of the connection as dictated by the RFC.'}}]","The function 'ssl_parse_flags_extension_response' first calls ssl_parse_flags_extension with allow_unknown set to false, ensuring that only known flags are accepted. It then verifies that the received flags are a subset of allowed_flags (C1). If not, it sets the alert to SSL_AD_ILLEGAL_PARAMETER (A1) and returns false, thereby aligning with the RFC requirement that semantically invalid messages trigger an 'illegal_parameter' alert. This implementation within the function itself fully addresses the specified constraints.",success,
8203,ssl_parse_flags_extension_response,"If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an ""illegal_parameter"" alert.",61,Fully Matches,"[{'C1': {'code': 'if ((*out & allowed_flags) != *out) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_EXTENSION);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n}', 'explanation': 'This check verifies that the parsed flags (*out) are a subset of the allowed_flags. If any flag is present that is not permitted (i.e. the extension is recognized but not specified for the response), it meets the condition described in the RFC.'}}, {'A1': {'code': '*out_alert = SSL_AD_ILLEGAL_PARAMETER;', 'explanation': 'Upon detecting an unsolicited (illegal) extension, the function aborts the handshake by setting the alert to SSL_AD_ILLEGAL_PARAMETER, fulfilling the action requirement of the RFC spec.'}}]","The function ssl_parse_flags_extension_response directly implements the RFC requirement by first ensuring no unknown extensions are permitted (via the call to ssl_parse_flags_extension with allow_unknown set to false) and then by verifying that the flags in the received extension are a subset of the allowed flags. If an unexpected flag is detected, it sets the alert to SSL_AD_ILLEGAL_PARAMETER and aborts the handshake, which fully matches the spec's mandate.",success,
8207,ext_sni_add_clienthello,"Additionally, all implementations MUST support the use of the ""server_name"" extension with applications capable of using it",351,Fully Matches,"[{'C1': {'code': 'if (!CBB_add_u16(out, TLSEXT_TYPE_server_name) ||\n      !CBB_add_u16_length_prefixed(out, &contents) ||\n      !CBB_add_u16_length_prefixed(&contents, &server_name_list) ||\n      !CBB_add_u8(&server_name_list, TLSEXT_NAMETYPE_host_name) ||\n      !CBB_add_u16_length_prefixed(&server_name_list, &name) ||\n      !CBB_add_bytes(&name, hostname.data(), hostname.size()) ||\n      !CBB_flush(out)) {\n    return false;\n}', 'explanation': ""This code segment implements the required 'server_name' extension by constructing it with the correct type and structure. It builds the extension contents and adds the hostname, fulfilling the RFC's mandate to support the 'server_name' extension.""}}]","The function 'ext_sni_add_clienthello' directly constructs and appends the server_name extension, as required by the RFC specification. The well-defined steps for adding the extension and hostname indicate that the implementation fully addresses the specified requirement.",success,
8207,ext_sni_add_clienthello,"As servers MAY require the presence of the ""server_name"" extension, clients SHOULD send this extension, when applicable.",207,Fully Matches,"[{'C1': {'code': 'if (ssl->hostname == nullptr) {\n      return true;\n    }\n    hostname = StringAsBytes(ssl->hostname.get());\n    \n    CBB contents, server_name_list, name;\n    if (!CBB_add_u16(out, TLSEXT_TYPE_server_name) ||\n        !CBB_add_u16_length_prefixed(out, &contents) ||\n        !CBB_add_u16_length_prefixed(&contents, &server_name_list) ||\n        !CBB_add_u8(&server_name_list, TLSEXT_NAMETYPE_host_name) ||\n        !CBB_add_u16_length_prefixed(&server_name_list, &name) ||\n        !CBB_add_bytes(&name, hostname.data(), hostname.size()) ||\n        !CBB_flush(out)) {\n      return false;\n    }', 'explanation': 'This code first checks if a hostname is available (as required by the RFC’s guidance for sending the server_name extension) and then proceeds to add the server_name extension by writing its type, list, and the hostname value. This implements the mandate that clients SHOULD send the server_name extension when applicable.'}}]","The function ext_sni_add_clienthello directly implements the requirement stated in the RFC specification by ensuring that the server_name extension is added to the ClientHello message when a hostname is present. It properly checks for the presence of a hostname and constructs the extension field using a series of CBB calls. Thus, within its own logic, the function fully addresses the specified condition.",success,
8207,ext_sni_add_clienthello,"Servers MAY require clients to send a valid ""server_name"" extension",352,Fully Matches,"[{'C1': {'code': 'if (ssl->hostname == nullptr) {\n  return true;\n}\nhostname = StringAsBytes(ssl->hostname.get());', 'explanation': 'This code checks whether a hostname is configured. If absent, the function exits early without attempting to send an extension. If a hostname exists, it is correctly prepared to be included in the server_name extension in the ClientHello message.'}}, {'A1': {'code': 'if (!CBB_add_u16(out, TLSEXT_TYPE_server_name) ||\n    !CBB_add_u16_length_prefixed(out, &contents) ||\n    !CBB_add_u16_length_prefixed(&contents, &server_name_list) ||\n    !CBB_add_u8(&server_name_list, TLSEXT_NAMETYPE_host_name) ||\n    !CBB_add_u16_length_prefixed(&server_name_list, &name) ||\n    !CBB_add_bytes(&name, hostname.data(), hostname.size()) ||\n    !CBB_flush(out)) {\n  return false;\n}', 'explanation': 'This segment constructs the server_name extension by writing the extension type, adding a length-prefixed container, and then encoding the hostname under the TLSEXT_NAMETYPE_host_name. It ensures that the extension is formatted according to the expected TLS protocol rules.'}}]","The function ext_sni_add_clienthello directly implements the logic needed for adding a valid server_name (SNI) extension to the ClientHello message. It first checks for a valid hostname (fulfilling a condition such as C1) and then builds the extension with proper type and formatting (fulfilling an action such as A1). Thus, the code function fully addresses the given RFC specification that servers may require clients to send a valid server_name extension.",success,
8211,ext_ech_add_clienthello,"A client MUST NOT include the ""early_data"" extension in its followup ClientHello.",148,Does Not Match,[],"The RFC specification requires that a client MUST NOT include the ""early_data"" extension in its followup ClientHello. However, the provided function, ext_ech_add_clienthello, is concerned solely with the inclusion of the encrypted_client_hello (ECH) extension. It differentiates between inner and outer ClientHello messages and writes the ECH extension accordingly. There is no logic within this function that checks, prevents, or otherwise handles the inclusion of an ""early_data"" extension. Therefore, the function does not visibly address the specified constraint regarding the exclusion of the early_data extension.",success,
8211,ext_ech_add_clienthello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The function ext_ech_add_clienthello implements logic to add an encrypted_client_hello extension to the ClientHello message based on the type and the presence of client outer data. However, none of the logic in this function addresses the specified RFC requirement of ordering extensions such that the 'pre_shared_key' extension is the last extension in a ClientHello. Since the function does not contain any conditions or actions that enforce or check the extension ordering constraint cited in the specification, the function does not visibly address any of the spec constraints on its own.",success,
8212,ext_ech_parse_serverhello,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided code function does not include any logic that checks for or enforces the prohibition of the OpenPGP certificate type when TLS 1.3 is used as required by RFC6091. The function primarily focuses on validating the ECH extension for TLS versions and handling its different states, without any reference to or checks involving the OpenPGP certificate type. Thus, none of the conditions (C1, C2, etc.) or actions (A1, A2, etc.) from the spec constraints are implemented in this function.",success,
8212,ext_ech_parse_serverhello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!ssl_is_valid_ech_config_list(*contents)) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n  }', 'explanation': 'This segment checks if the ECH configuration list (i.e. the parsed message) is not valid. When the message cannot be parsed as expected (which could include boundary or out‐of‐range issues), it sets the alert to decode_error, directly addressing the RFC’s requirement.'}}, {'A1': {'code': 'if (!ssl_is_valid_ech_config_list(*contents)) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n  }', 'explanation': 'By setting *out_alert to SSL_AD_DECODE_ERROR and returning false, the function ensures that a malformed message leads to connection termination as required by the RFC.'}}]","The function body directly implements the logic mandated by the RFC: it validates the incoming message (ECH config list) and, if parsing fails, sets the decode_error alert and returns false, thereby ensuring that a connection is terminated in the face of a parsing error. This satisfies both the condition (C1) and its corresponding action (A1) as specified.",success,
8212,ext_ech_parse_serverhello,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function (ext_ech_parse_serverhello) is concerned with parsing the ECH extension in the TLS 1.3 ServerHello message and checking its validity. There is no implementation within this function that addresses the RFC specification requiring that implementations must not offer or negotiate RC4 cipher suites. Therefore, none of the spec constraints related to RC4 are met in this code.",success,
8212,ext_ech_parse_serverhello,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'C1': {'code': 'if (!ssl_is_valid_ech_config_list(*contents)) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n}', 'explanation': ""This code explicitly checks the validity of the ECH config list and aborts the handshake with a decode_error alert if the check fails, which corresponds to the RFC specification that requires aborting the handshake with a 'decode_error' alert in case of an invalid configuration.""}}]","The function implements a check for the validity of the ECH config list and aborts the handshake with a decode_error alert when the config is invalid, which meets part of the RFC specification. However, while there are additional checks (e.g. ensuring the ECH extension is not sent in TLS 1.2 or in response to an inner ECH extension), the only RFC constraint clearly implemented within this function is the abort-on-invalid-config using the decode_error alert. As a result, the function partially matches the spec constraints.",success,
8214,ext_ech_add_serverhello,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided code function implements logic to add an ECH (Encrypted ClientHello) extension to the server response by appending retry configurations, but it does not address the RFC requirement regarding the status_request_v2 extension. The RFC specifies that TLS 1.3 servers must not act upon or send the status_request_v2 extension in associated messages, yet this function does not inspect, filter, or suppress the status_request_v2 extension. As a result, none of the labeled conditions or actions from the spec constraints (e.g., C1, A1) are implemented within this function.",success,
8214,ext_ech_add_serverhello,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The provided function does not include any logic addressing the spec constraint regarding ""obsolete_RESERVED"" ranges. The code only checks for the TLS version and whether ECH has been accepted (or if ech_keys is null), and then writes retry configurations to the output. There is no implementation within the function that verifies whether any offered values fall within the obsolete_RESERVED ranges or prevents their negotiation in TLS 1.3, which is the requirement stated in the spec.",success,
8214,ext_ech_add_serverhello,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function does not implement any logic to enforce that the OpenPGP certificate type is not used with TLS 1.3. The code only checks if the protocol version is below TLS 1.3 or if certain ECH conditions are met, and then proceeds to add the ECH retry configurations. There is no branch or condition in the function that inspects or rejects the use of the OpenPGP certificate type as specified in RFC6091.",success,
8215,ext_ri_add_clienthello,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Fully Matches,"[{'C1': {'code': 'if (hs->min_version >= TLS1_3_VERSION ||  //\n      type == ssl_client_hello_inner) {\n    return true;\n  }', 'explanation': 'This segment ensures that if the TLS version is 1.3 (or if the ClientHello type is inner), the function returns early without adding the renegotiation extension. This directly implements the RFC requirement that TLS 1.3 implementations MUST NOT send the renegotiation extension.'}}]","The function explicitly checks for TLS 1.3 (or inner ClientHello) and avoids sending the renegotiation extension by returning early, which complies with the RFC specification that TLS 1.3 implementations must not send the renegotiation extension. Since the logic responsible for this decision is fully contained within the function, the code is judged to fully match the constraint.",success,
8215,ext_ri_add_clienthello,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Fully Matches,"[{'C1': {'code': 'if (hs->min_version >= TLS1_3_VERSION ||  //\n      type == ssl_client_hello_inner) {\n    return true;\n  }', 'explanation': 'This code snippet explicitly checks if the handshake’s minimum TLS version is TLS1.3 (or if the ClientHello is an inner one) and exits early without adding the renegotiation extension. This ensures that values from the obsolete_RESERVED range are not offered for TLS 1.3, fully complying with the spec requirement.'}}]","The specification requires that obsolete_RESERVED values, which are used in previous versions of TLS, must not be offered or negotiated by TLS 1.3 implementations. The function meets this requirement by performing an early return when the handshake version is TLS1.3 or when handling an inner client hello. This prevents any code that adds a renegotiation extension from being executed under those conditions. All relevant logic for enforcing the spec is contained within the function_body, so the function fully implements the constraint.",success,
8215,ext_ri_add_clienthello,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function only concerns the construction of the renegotiation extension for TLS versions prior to TLS 1.3. It explicitly returns early without adding the renegotiation extension when the minimum version is TLS 1.3 or when the client hello type is inner. There is no logic within this function that checks or prevents the use of the OpenPGP certificate type in TLS 1.3 as specified in RFC6091. Thus, none of the labeled constraints (e.g., C1, A1) pertaining to the OpenPGP certificate type restriction are implemented in this function.",success,
8215,ext_ri_add_clienthello,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (hs->min_version >= TLS1_3_VERSION ||  //\n      type == ssl_client_hello_inner) {\n    return true;\n  }', 'explanation': 'This conditional check ensures that if the minimum TLS version is TLS1.3 (or if the client hello is an inner message), the function exits early without adding a renegotiation indication. Since TLS1.3 must not negotiate renegotiation, the code directly addresses the RFC specification requirement.'}}]","The function checks the TLS version before attempting to add a renegotiation extension. By returning early when hs->min_version is at least TLS1.3, it avoids the inclusion of the renegotiation extension, which complies with the requirement that TLS 1.3 must not negotiate renegotiation. This logic is self-contained in the function and directly meets the spec constraint.",success,
8216,ext_ri_parse_serverhello,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'C1': {'code': 'if (contents != NULL && ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n  }\n\n  ...\n\n  if (!CBS_get_u8_length_prefixed(contents, &renegotiated_connection) ||\n      CBS_len(contents) != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_RENEGOTIATION_ENCODING_ERR);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n  }', 'explanation': ""These segments implement the RFC requirement by terminating the connection with an 'illegal_parameter' alert when receiving semantically invalid renegotiation extension data. This aligns with the spec's mandate for semantically invalid messages. However, note that in another validation (renegotiation mismatch), the function uses a handshake failure alert instead, which deviates from the spec requirement.""}}]","The function attempts to implement the RFC specification in certain cases by setting the 'illegal_parameter' alert when the renegotiation extension is either not allowed (in TLS 1.3) or improperly encoded. This directly matches some of the RFC constraints (labeled here as C1). However, for mismatches during renegotiation (a semantic error), it issues a handshake_failure alert instead of the prescribed illegal_parameter alert. Because the function only partially adheres to the RFC requirement of always using 'illegal_parameter' to terminate connections upon semantically invalid messages, the overall match is only partial.",success,
8217,ext_ri_parse_clienthello,-TLS 1.2 ClientHellos MAY omit this extension.,99,Fully Matches,"[{'C1': {'code': 'if (contents == NULL) {\n    return true;\n}', 'explanation': ""The spec indicates that TLS 1.2 ClientHellos MAY omit the extension. The code checks if 'contents' is NULL and returns true, effectively allowing the extension to be absent as permitted by the specification.""}}]","The function 'ext_ri_parse_clienthello' properly handles the case when the renegotiation_info extension is omitted by immediately returning true, which aligns with the statement that 'TLS 1.2 ClientHellos MAY omit this extension'. Additionally, when the extension is present, it further validates that the extension data is properly framed and empty. All of these checks reside within the function itself and directly address the spec constraint without reliance on dependencies.",success,
8217,ext_ri_parse_clienthello,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    return true;\n  }', 'explanation': 'This segment detects when TLS version is 1.3 or higher and immediately returns true. In doing so, it bypasses any processing or sending of the renegotiation extension, which is in compliance with the spec requirement that TLS 1.3 implementations MUST NOT send the renegotiation extension.'}}]","The function checks if the protocol version is TLS1.3 or above and, if so, avoids any processing of the renegotiation extension—effectively ensuring that no renegotiation data is sent, consistent with the RFC specification. All logic necessary for the constraint is contained within the function_body, thus it fully matches the provided spec constraint.",success,
8217,ext_ri_parse_clienthello,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The RFC specification requires that TLS 1.3 servers must not act upon the presence or information of the status_request_v2 extension when processing specific messages. The provided code function, ext_ri_parse_clienthello, is concerned solely with parsing the renegotiation information extension and, notably, returns early (ignoring any renegotiation data) if the protocol version is TLS 1.3. This behavior does not address the RFC’s requirement regarding the status_request_v2 extension, and in fact, the function is not involved with processing that extension at all. As a result, none of the labeled conditions or actions from the RFC specification are implemented within this function.",success,
8217,ext_ri_parse_clienthello,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    return true;\n  }', 'explanation': 'This code segment explicitly checks if the negotiated protocol is TLS 1.3 (or higher) and immediately returns true, thereby bypassing any further renegotiation processing. This directly ensures that the function does not engage in renegotiation (and thus negotiation) for TLS 1.3, fully addressing the spec requirement.'}}]","The function correctly handles the TLS 1.3 case by performing an early return when TLS 1.3 or later is detected. This prevents any renegotiation logic from executing for TLS 1.3, which fulfills the RFC specification requirement that it MUST NOT negotiate TLS 1.3. All logic addressing this constraint is contained within the function itself.",success,
8218,ext_ri_add_serverhello,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided RFC specification requires that TLS 1.3 servers must not process or send the status_request_v2 extension in certain messages. However, the function 'ext_ri_add_serverhello' handles the addition of the renegotiation extension (TLSEXT_TYPE_renegotiate) and explicitly avoids adding it when the protocol version is TLS 1.3. There is no code in this function that addresses the handling (or non-handling) of the status_request_v2 extension as specified. Therefore, the function does not implement the specified RFC constraints.",success,
8218,ext_ri_add_serverhello,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    return true;\n}', 'explanation': 'This code segment checks if the TLS protocol version is TLS1.3 or above, and if so, it returns early without sending the renegotiation extension. This directly implements the spec requirement that TLS 1.3 implementations MUST NOT send renegotiation extensions.'}}]","The function explicitly avoids sending the renegotiation extension for TLS1.3 connections by returning early when the protocol version is TLS1.3 or above. This behavior fully matches the specification requirement that TLS 1.3 implementations must not send these extensions, addressing the condition within the function itself.",success,
8218,ext_ri_add_serverhello,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    return true;\n  }', 'explanation': 'The RFC specifies that values from obsolete_RESERVED ranges (like the renegotiation extension) MUST NOT be offered in TLS 1.3. This code block directly checks if the TLS protocol version is 1.3 or higher and, if so, returns early without adding the renegotiation extension, thereby fulfilling the requirement.'}}]","Within the function_body, the check for TLS1.3 ensures that the obsolete renegotiation extension is not offered. By returning early for TLS 1.3, the function adheres to the RFC specification that these values must not be negotiated, thus fully matching the provided spec constraint labeled here as C1.",success,
8218,ext_ri_add_serverhello,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function does not address the RFC specification regarding the OpenPGP certificate type. The RFC states that the OpenPGP certificate type MUST NOT be used with TLS 1.3, but the code only checks for TLS 1.3 to bypass the addition of the renegotiation extension. There is no logic in the function to check, restrict, or otherwise handle the OpenPGP certificate type as required by the spec.",success,
8218,ext_ri_add_serverhello,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    return true;\n  }', 'explanation': 'This code segment checks if the negotiated protocol version is TLS 1.3 or higher. By returning early, it prevents adding the renegotiation extension, thus ensuring that TLS 1.3 is not negotiated, which directly implements the RFC requirement.'}}]","The function explicitly ensures that if the SSL protocol version is TLS 1.3 or above, it skips adding the renegotiation extension. This direct check and early return fulfill the RFC specification which mandates that TLS 1.3 MUST NOT be negotiated. No other parts of the function are needed to address this specific constraint, so the implementation fully meets the requirement as specified.",success,
8219,ext_ems_add_clienthello,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Fully Matches,"[{'C1': {'code': 'if (hs->min_version >= TLS1_3_VERSION || type == ssl_client_hello_inner) {\n    return true;\n}', 'explanation': 'This code segment checks if the minimum TLS version is 1.3 (or if the client hello is of an inner type) and returns immediately, thereby avoiding sending the extended master secret extension. This directly implements the RFC requirement that TLS 1.3 implementations MUST NOT send the extended master secret extension.'}}]","The function explicitly checks the TLS version and skips adding the extended master secret extension when TLS 1.3 is in use, fulfilling the specification requirement. The early return in the case of TLS1.3 (or for an inner client hello) ensures that no EMS is sent, which fully matches the spec constraint.",success,
8219,ext_ems_add_clienthello,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Fully Matches,"[{'C1': {'code': 'if (hs->min_version >= TLS1_3_VERSION || type == ssl_client_hello_inner) {\n    return true;\n}', 'explanation': 'This code segment checks if the TLS version is 1.3 or if the client hello is of an inner type and, in either case, bypasses adding the extended master secret extension. This behavior directly prevents offering an extension (or its value) in TLS1.3, which aligns with the RFC requirement that values within obsolete_RESERVED ranges (or legacy extensions) MUST NOT be offered by TLS 1.3 implementations.'}}]","The RFC specification mandates that values (or extensions) designated for previous TLS versions should not be offered in TLS1.3. The function 'ext_ems_add_clienthello' implements this rule by checking the TLS version (and client hello type) and returning early without adding the extension when TLS1.3 is in use. Therefore, the function fully addresses the RFC constraint within its own logic.",success,
8219,ext_ems_add_clienthello,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (hs->min_version >= TLS1_3_VERSION || type == ssl_client_hello_inner) {\n    return true;\n}', 'explanation': 'This check ensures that when the TLS version is 1.3 or later, or for an inner client hello, the function does not add the Extended Master Secret extension. This directly satisfies the RFC specification that TLS 1.3 MUST NOT negotiate the extension.'}}]","The function conditionally adds the Extended Master Secret extension only for TLS versions below 1.3. The early return when hs->min_version is TLS1_3_VERSION or greater prevents the extension from being negotiated in TLS 1.3, thereby fully implementing the spec constraint by itself.",success,
8220,ext_ems_parse_serverhello,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (ssl->s3->established_session != nullptr &&\n      hs->extended_master_secret !=\n          !!ssl->s3->established_session->extended_master_secret) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_RENEGOTIATION_EMS_MISMATCH);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n  }', 'explanation': 'This segment sets the out_alert to SSL_AD_ILLEGAL_PARAMETER and terminates the handshake (by returning false) when there is an EMS renegotiation mismatch. This corresponds to the action of terminating the connection with an illegal_parameter alert when a semantically invalid parameter is detected.'}}]","The function attempts to enforce a part of the RFC requirement by ensuring that a semantically invalid EMS negotiation during renegotiation (i.e., when the EMS negotiation state does not match an already established session) results in setting the 'illegal_parameter' alert and aborting the handshake. However, in another branch where the contents are non-empty (or the protocol version is TLS1.3), the function simply returns false without setting the alert. Since only a subset of potential semantically invalid conditions is handled with the proper alert, the function only partially matches the RFC specification.",success,
8223,ext_ticket_add_clienthello,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Fully Matches,"[{'C1': {'code': 'if (hs->min_version >= TLS1_3_VERSION || type == ssl_client_hello_inner ||\n      SSL_get_options(ssl) & SSL_OP_NO_TICKET) {\n    return true;\n  }', 'explanation': 'This early return detects when the handshake version is TLS 1.3 (or when other conditions prevail) and avoids adding the ticket extension. This behavior directly aligns with the TLS 1.3 specification requirement that implementations MUST NOT send the ticket extension.'}}]","The function ext_ticket_add_clienthello implements the RFC requirement by checking if the TLS version is 1.3 (or other conditions that preclude sending the ticket extension) and immediately returns true without constructing or sending the extension. This ensures that for TLS 1.3 handshakes, the session ticket extension is not sent, thereby fully meeting the specification.",success,
8223,ext_ticket_add_clienthello,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The RFC specification requires that values in the ""obsolete_RESERVED"" ranges are not offered or negotiated in TLS 1.3. This function, ext_ticket_add_clienthello, only contains logic to avoid sending the session ticket extension when the handshake is TLS 1.3 (or for other specified conditions) but does not address any handling or filtering of values within the obsolete_RESERVED ranges. Therefore, none of the spec constraints (such as checking or omitting any obsolete_RESERVED values) are implemented in this function.",success,
8223,ext_ticket_add_clienthello,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function 'ext_ticket_add_clienthello' does not contain any code addressing the OpenPGP certificate type as described in RFC6091. The specification restricts the use of OpenPGP certificates with TLS 1.3, but the function only manages session ticket extensions and, in the TLS 1.3 case, bypasses ticket extension processing altogether. There is no logic that implements any condition (e.g., forbidding the OpenPGP certificate type) or action related to this RFC constraint within the function body.",success,
8223,ext_ticket_add_clienthello,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (hs->min_version >= TLS1_3_VERSION || type == ssl_client_hello_inner ||\n      SSL_get_options(ssl) & SSL_OP_NO_TICKET) {\n    return true;\n  }', 'explanation': 'This condition explicitly checks if the handshake uses TLS 1.3 (or a similar condition) and immediately returns without adding the legacy ticket extension. This directly enforces the spec requirement that it MUST NOT negotiate TLS 1.3.'}}]","The function 'ext_ticket_add_clienthello' is designed to add a session ticket extension only for TLS versions below 1.3. The early return clause when 'hs->min_version >= TLS1_3_VERSION' (along with related conditions) ensures that, for TLS 1.3 handshakes, the ticket extension is not added. This logic directly satisfies the RFC constraint, as it prevents negotiation using TLS 1.3 within this function.",success,
8226,ext_sigalgs_add_clienthello,"Implementations which have the same policy in both cases MAY omit the ""signature_algorithms_cert"" extension.",85,Does Not Match,[],"The RFC specification requires that implementations may omit the ""signature_algorithms_cert"" extension if the policies in both cases are the same. However, the provided code function only implements logic for adding the ""signature_algorithms"" extension and does not include any logic related to policy comparison or the ""signature_algorithms_cert"" extension. There is no code segment addressing a condition (such as a check to decide whether to include or omit the ""signature_algorithms_cert"" extension) that would correspond to a labeled constraint (e.g., C1 or A1). As such, within the function_body itself, the relevant part of the RFC is not addressed.",success,
8226,ext_sigalgs_add_clienthello,TLS 1.3 implementations willing to negotiate TLS 1.2 MUST behave in accordance with the requirements of [RFC5246] when negotiating that version.,98,Does Not Match,[],"The provided function focuses on adding the TLS signature_algorithms extension for a TLS handshake when TLS1.2 is negotiated (and bypasses it under certain conditions such as PAKE mode), which is related to negotiating TLS 1.2 per RFC5246. However, none of the spec constraints concerning the If-Match header fields (and their associated conditions and actions) are addressed in this function. The function does not include any logic to evaluate header values or entity tags, and thus does not implement any of the labeled conditions (C1, C2, etc.) or actions (A1, A2, etc.) from the provided spec context.",success,
8226,ext_sigalgs_add_clienthello,-TLS 1.2 ClientHellos MAY omit this extension.,99,Fully Matches,"[{'C1': {'code': 'if (hs->max_version < TLS1_2_VERSION) {\n    return true;\n}', 'explanation': 'This code checks if the TLS version is less than TLS1.2 and omits the signature_algorithms extension as permitted by the RFC (i.e. ClientHellos MAY omit this extension).'}}, {'C2': {'code': 'if (hs->pake_prover != nullptr) {\n    return true;\n}', 'explanation': 'In PAKE mode, the extension is not used, so the code correctly returns early and skips adding the extension.'}}, {'A1': {'code': 'if (!CBB_add_u16(out_compressible, TLSEXT_TYPE_signature_algorithms) ||\n    !CBB_add_u16_length_prefixed(out_compressible, &contents) ||\n    !CBB_add_u16_length_prefixed(&contents, &sigalgs_cbb) ||\n    !tls12_add_verify_sigalgs(hs, &sigalgs_cbb) ||\n    !CBB_flush(out_compressible)) {\n  return false;\n}\n\nreturn true;', 'explanation': 'If the TLS version is at least TLS1.2 and not using PAKE, the function adds the signature_algorithms extension as required for proper ClientHello processing. The sequence of CBB operations builds the extension data to be sent.'}}]","The code function first checks whether the connection is using a TLS version lower than 1.2 or is in PAKE mode—both cases where the signature_algorithms extension can be omitted. Otherwise, it proceeds to add the extension into the ClientHello message. This logic directly addresses the RFC specification that 'TLS 1.2 ClientHellos MAY omit this extension' by conditionally adding it only when required. All relevant conditions (C1 and C2) and the subsequent action (A1) are handled within this function.",success,
8229,ext_ocsp_parse_serverhello,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    return false;\n  }', 'explanation': 'This code ensures that if the protocol is TLS 1.3 or higher, the OCSP response in the ServerHello extension is not processed. This directly supports the RFC requirement that TLS 1.3 implementations MUST NOT send (or in this case, process) OCSP responses.'}}]","The function explicitly checks the TLS version and, for TLS 1.3, returns false immediately, thereby preventing any OCSP response processing. Since the RFC specifies that TLS 1.3 implementations must not send (or process) OCSP responses, this logic fully addresses that constraint. All handling of the OCSP extension in this function is performed in compliance with that requirement, independent of any dependency or external context.",success,
8229,ext_ocsp_parse_serverhello,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    return false;\n}', 'explanation': 'The function explicitly checks if the negotiated protocol version is TLS 1.3 or greater and returns false, thereby preventing TLS 1.3 negotiation as required by the RFC.'}}]","The provided function directly addresses the key requirement stated in the RFC specification ('MUST NOT negotiate TLS 1.3') by verifying the protocol version and rejecting connections that are TLS 1.3 or higher. While the function includes additional logic regarding OCSP stapling and certificate authentication, the primary spec constraint related to TLS 1.3 is fully implemented within the function.",success,
8230,ext_ocsp_parse_clienthello,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided spec requires that TLS 1.3 servers must not act upon the status_request_v2 extension in the ClientHello message. However, the function explicitly parses the extension and sets the internal flag (hs->ocsp_stapling_requested) when the status type equals TLSEXT_STATUSTYPE_ocsp. This shows that the function is actively processing the extension rather than ignoring it as mandated. There is no TLS 1.3 version check or logic to avoid acting on this extension, so, in isolation, the function does not implement the required behavior from the spec.",success,
8231,ext_ocsp_add_serverhello,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_3_VERSION ||\n      !hs->ocsp_stapling_requested || ssl->s3->session_reused ||\n      !ssl_cipher_uses_certificate_auth(hs->new_cipher) ||\n      hs->credential->ocsp_response == nullptr) {\n    return true;\n  }', 'explanation': 'This code checks the TLS protocol version and ensures that if the connection is TLS 1.3 or higher, the certificate status (OCSP) extension is not sent. This directly fulfills the RFC requirement that TLS 1.3 implementations MUST NOT send them.'}}]","The function starts by verifying the connection's TLS version. By returning early when the version is TLS 1.3 or higher, it prevents the certificate status extension from being added to the ServerHello message, which is exactly what the RFC dictates. Therefore, the implementation in this function fully meets the spec as stated.",success,
8231,ext_ocsp_add_serverhello,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    return true;\n}', 'explanation': 'This check ensures that if the TLS version is 1.3 or above, the function returns early without adding any extension value. This prevents obsolete_RESERVED values (or any non-permitted extensions) from being offered in TLS 1.3 implementations, thereby directly addressing the RFC requirement.'}}]","The function immediately returns without adding the OCSP status_request extension when the TLS protocol version is 1.3 or higher. By doing this, it ensures that no extension values (which could fall into obsolete_RESERVED ranges) are offered in TLS 1.3, which is exactly what the RFC specification mandates. All logic relevant to the constraint is found within the function itself.",success,
8231,ext_ocsp_add_serverhello,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    return true;\n}', 'explanation': 'This check ensures that if the TLS version is 1.3 or higher, the function returns immediately without adding the OCSP stapling extension. This complies with the RFC requirement that TLS 1.3 servers MUST NOT process or send the status_request_v2 extension.'}}]","The function clearly checks the protocol version. When the TLS version is 1.3 or above, it skips adding the OCSP stapling extension by returning true immediately. This direct implementation prevents the server from sending the status_request_v2 extension in messages, fully addressing the specified RFC constraint. All of the logic required to adhere to the RFC is visible within the function body.",success,
8231,ext_ocsp_add_serverhello,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function ext_ocsp_add_serverhello only handles logic related to the OCSP stapling extension and checks for TLS 1.3 (by skipping addition of the extension if TLS 1.3 is used). The RFC specification under review requires that the OpenPGP certificate type MUST NOT be used with TLS 1.3, but the function does not inspect or enforce any rules regarding the certificate type (for example, checking if an OpenPGP certificate is in use). Therefore, no part of the function visibly implements any condition or action corresponding to the RFC6091 requirement.",success,
8231,ext_ocsp_add_serverhello,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_3_VERSION || ...)', 'explanation': 'This condition explicitly checks if the negotiated TLS version is TLS 1.3 (or higher), and if so, the function returns immediately without adding the OCSP stapling extension. This directly implements the requirement that TLS 1.3 must not be negotiated in this context.'}}]","The function inspects the negotiated TLS version using ssl_protocol_version, and if it is at least TLS1_3_VERSION, it avoids proceeding with adding the OCSP stapling extension. This behavior ensures that the OCSP extension is not applied when TLS 1.3 is in use, satisfying the specification constraint.",success,
8232,ext_npn_add_clienthello,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Fully Matches,"[{'C1': {'code': 'if (SSL->is_dtls(ssl) || hs->min_version >= TLS1_3_VERSION || type == ssl_client_hello_inner) {\n    return true;\n}', 'explanation': 'This check ensures that if the handshake is using DTLS or TLS 1.3 (or if an inner ClientHello is used), the NPN extension is not added. This prevents offering an extension that falls into the obsolete/reserved values as specified by the RFC for TLS 1.3.'}}]","The RFC requires that values falling within the 'obsolete_RESERVED' ranges must not be offered or negotiated in TLS 1.3. The function implements this by checking if the minimum version is TLS 1.3 (or if DTLS or an inner ClientHello is detected) and immediately returning before adding the NPN extension. Since the logic in the function prevents the extension from being added for TLS 1.3, it fulfills the spec constraint.",success,
8232,ext_npn_add_clienthello,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Fully Matches,"[{'C1': {'code': 'if (ssl->ctx->next_proto_select_cb == NULL ||\n    ssl->s3->initial_handshake_complete ||\n    SSL_is_dtls(ssl) || hs->min_version >= TLS1_3_VERSION ||\n    type == ssl_client_hello_inner) {\n  return true;\n}', 'explanation': 'The code explicitly checks if the minimum protocol version is TLS1_3_VERSION (among other conditions) and immediately returns without adding the NPN extension. This ensures that in TLS 1.3 implementations the NPN extension is not sent, thereby meeting the spec requirement that TLS 1.3 implementations MUST NOT send them.'}}]","The function 'ext_npn_add_clienthello' verifies that if the minimum TLS version is TLS 1.3 (or other non-applicable conditions such as DTLS or renegotiation) then it aborts adding the NPN extension. This conditional check directly implements the TLS 1.3 requirement posed in the spec, ensuring that the extension is not sent. No additional logic is needed for receiving older implementations since that is handled elsewhere, making this function's implementation fully compliant with the provided specification.",success,
8232,ext_npn_add_clienthello,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided code function is responsible for adding the NPN (Next Protocol Negotiation) extension to the TLS ClientHello message. It specifically avoids adding this extension if the handshake is using TLS 1.3 (as indicated by the 'hs->min_version >= TLS1_3_VERSION' check), among other conditions. However, the RFC specification given requires that the OpenPGP certificate type (as defined in RFC6091) MUST NOT be used with TLS 1.3. There is no logic in this function that checks or enforces any constraints related to the OpenPGP certificate type. Thus, the function does not address the spec constraint regarding the OpenPGP certificate type and its prohibition in TLS 1.3.",success,
8232,ext_npn_add_clienthello,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (ssl->ctx->next_proto_select_cb == NULL ||\n      // Do not allow NPN to change on renegotiation.\n      ssl->s3->initial_handshake_complete ||\n      // NPN is not defined in DTLS or TLS 1.3.\n      SSL_is_dtls(ssl) || hs->min_version >= TLS1_3_VERSION ||\n      type == ssl_client_hello_inner) {\n    return true;\n  }', 'explanation': ""The function explicitly checks if the handshake minimum version is TLS 1.3 or greater (using 'hs->min_version >= TLS1_3_VERSION'). If so, it returns early without adding the NPN extension, thereby ensuring that TLS 1.3 is not negotiated, which is in accordance with the spec requirement.""}}]",The code function directly implements the specification's constraint by checking whether the TLS version is at least TLS 1.3 and abstaining from adding the NPN extension when that condition is met. This logic is self-contained within the function and satisfies the requirement that it MUST NOT negotiate TLS 1.3.,success,
8233,ext_npn_parse_serverhello,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (!ssl->s3->alpn_selected.empty()) {\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_NEGOTIATED_BOTH_NPN_AND_ALPN);\n    return false;\n  }', 'explanation': 'This branch checks for a semantically invalid condition (both NPN and ALPN negotiated) and sets the alert to SSL_AD_ILLEGAL_PARAMETER before terminating the connection, directly addressing the spec requirement for invalid messages.'}}]","The RFC specification requires that semantically invalid messages result in connection termination with an 'illegal_parameter' alert. The code function does address this in one critical branch where it detects that both NPN and ALPN have been negotiated—the semantically invalid condition—by setting out_alert to SSL_AD_ILLEGAL_PARAMETER and returning false. However, in other error cases (for example, when parsing length-prefixed protocols fails or when the callback returns an error), the function either returns false without setting the alert or sets a different alert (SSL_AD_INTERNAL_ERROR). Since not all semantically invalid conditions explicitly set the 'illegal_parameter' alert as required, the implementation only partially meets the specification constraints.",success,
8237,ext_sct_parse_serverhello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!ssl_is_sct_list_valid(contents)) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n}', 'explanation': 'This code verifies that the received SCT list is valid. If it fails to parse correctly (e.g., due to an unexpected length or malformed content), the function treats it as a decoding error, directly addressing the condition that a message that cannot be parsed should be rejected.'}}, {'A1': {'code': 'if (!ssl_is_sct_list_valid(contents)) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n}\n\nif (ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n}', 'explanation': ""In both scenarios—either an invalid SCT list or receiving the SCT extension in TLS 1.3 where it is not expected—the function sets the output alert to 'decode_error' and returns false. This behavior is in line with the specification requirement to terminate the connection with a decode_error alert when a message cannot be correctly parsed.""}}]","The function checks for invalid SCT data by invoking ssl_is_sct_list_valid and also verifies that the SCT extension is not erroneously received in TLS 1.3. In either case, it sets the alert to SSL_AD_DECODE_ERROR and returns false, which corresponds directly to the RFC’s mandate that peers must terminate the connection with a decode_error alert when encountering unparsable messages. Therefore, the function fully meets the specified conditions and actions.",success,
8237,ext_sct_parse_serverhello,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n}', 'explanation': 'This segment enforces the RFC requirement by checking if the connection uses TLS 1.3 or higher and then returning a decode error. In TLS 1.3 the SCT extension should be in the Certificate extension, not in the ServerHello, so encountering it here results in an error.'}}]","The provided function explicitly handles the critical aspect of the RFC specification by verifying the protocol version. When the protocol is TLS 1.3 or later, it returns an error instead of processing the SCT extension, thus preventing a TLS 1.3 implementation from improperly sending these extensions. Since the key behavior mandated by the specification is implemented directly in this function, it fully meets the listed spec constraint.",success,
8237,ext_sct_parse_serverhello,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n}', 'explanation': 'This code segment explicitly checks if the negotiated TLS version is TLS 1.3 or higher and, if so, returns an error. This directly enforces the requirement that TLS 1.3 must not be negotiated.'}}]","The provided function directly implements the specified requirement by rejecting any connection that attempts to use TLS 1.3 (or a higher version). The check 'if (ssl_protocol_version(ssl) >= TLS1_3_VERSION)' ensures that TLS 1.3 is not permitted, thus fulfilling the RFC's mandate that TLS 1.3 is not negotiated.",success,
8237,ext_sct_parse_serverhello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The provided function, ext_sct_parse_serverhello, is responsible for parsing the SCT extension in the ServerHello and verifying its validity based on the TLS version and other SCT-specific criteria. It does not implement any logic related to the ordering of multiple extensions or the special handling of the ""pre_shared_key"" extension as specified (i.e., that it MUST be the last extension in the ClientHello). Therefore, no part of this function addresses the RFC specification constraint concerning extension order, and it does not visibly implement any of the conditions or actions related to that specific requirement.",success,
8241,ext_alpn_parse_serverhello,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (hs->next_proto_neg_seen) {\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_NEGOTIATED_BOTH_NPN_AND_ALPN);\n    return false;\n}\n\n...\n\nif (!CBS_get_u16_length_prefixed(contents, &protocol_name_list) ||\n    CBS_len(contents) != 0 ||\n    !CBS_get_u8_length_prefixed(&protocol_name_list, &protocol_name) ||\n    CBS_len(&protocol_name) == 0 ||\n    CBS_len(&protocol_name_list) != 0) {\n    return false;\n}\n\nif (!ssl_is_alpn_protocol_allowed(hs, protocol_name)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_INVALID_ALPN_PROTOCOL);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n}', 'explanation': ""The function performs several validations on the ALPN extension: it checks that ALPN and NPN are not both negotiated, validates the structure and content of the protocol name list, and verifies that the selected protocol is allowed. In cases where these semantical validations fail, it sets the out_alert to SSL_AD_ILLEGAL_PARAMETER, thereby fulfilling the RFC requirement to terminate the connection with an 'illegal_parameter' alert when a syntactically correct but semantically invalid message is received.""}}]","The provided function implements the required behavior from the RFC by checking the ALPN message for any semantic inconsistencies. When such an inconsistency is detected (e.g., simultaneous negotiation of NPN and ALPN, padding/length errors, or an unacceptable protocol), it sets the alert to SSL_AD_ILLEGAL_PARAMETER and returns false. This ensures that the connection will be terminated as required by the RFC, fully matching the specified constraints.",success,
8245,ssl_negotiate_alpn,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16_length_prefixed(&contents, &protocol_name_list) || CBS_len(&contents) != 0 || !ssl_is_valid_alpn_list(protocol_name_list)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_PARSE_TLSEXT);\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n}', 'explanation': 'This segment checks if the ALPN extension is improperly formatted (e.g., length issues or invalid protocol names), which corresponds to detecting a message that cannot be parsed according to the spec.'}}, {'A1': {'code': '*out_alert = SSL_AD_DECODE_ERROR;\nreturn false;', 'explanation': 'On detecting a parsing error, the function sets the alert to decode_error and returns false, thereby terminating the connection as required by the RFC spec.'}}]","The function explicitly validates the ALPN extension message format. If the parsing fails due to incorrect length or invalid content (as indicated by the conditions checked), it immediately sets the alert to SSL_AD_DECODE_ERROR and returns false. This logic directly implements the specification that dictates terminating the connection with a 'decode_error' alert when encountering a message that cannot be parsed.",success,
8250,ext_channel_id_add_serverhello,"These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2.",86,Does Not Match,[],"The provided function, ext_channel_id_add_serverhello, deals solely with adding a TLS channel ID extension to a ServerHello message when channel ID is negotiated. It does not include any logic or code that addresses the RFC specification related to signatures in certificates (nor the use or specifics of headers such as the From header outlined in the sr_context). There is no visible implementation within this function that correlates with any labeled conditions (like C1, C2, etc.) or actions (like A1, A2, etc.) from the provided RFC specification constraints.",success,
8256,ext_ec_point_add_clienthello,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Fully Matches,"[{'C1': {'code': 'if (hs->min_version >= TLS1_3_VERSION || type == ssl_client_hello_inner) {\n    return true;\n  }', 'explanation': 'This code segment checks if the handshake is using TLS 1.3 (or is an inner ClientHello) and, if so, skips adding the EC point format extension. This behavior directly implements the RFC specification that TLS 1.3 implementations MUST NOT send the extension.'}}]","The function 'ext_ec_point_add_clienthello' explicitly avoids sending the EC point format extension when the TLS version is 1.3 (or under specific conditions like an inner ClientHello). This matches the RFC requirement stating that TLS 1.3 must not send the extension. The logic is entirely contained within the function, and no external dependencies are relied upon for this behavior.",success,
8256,ext_ec_point_add_clienthello,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (hs->min_version >= TLS1_3_VERSION || type == ssl_client_hello_inner) {\n    return true;\n}', 'explanation': 'This segment checks whether the handshake uses TLS 1.3 (or if the client hello is of a specific inner type) and, if so, bypasses adding the EC point extension. This directly enforces the requirement to not negotiate TLS 1.3, as the extension is omitted when TLS 1.3 is detected.'}}]","The function explicitly checks the minimum TLS version, and if it is TLS 1.3 or greater (or if the client hello is of type 'inner'), it returns early without adding the extension. This behavior strictly adheres to the specification that demands not negotiating TLS 1.3 by not adding the extension in such cases. Hence, the function fully matches the labeled constraint.",success,
8257,ext_ec_point_parse_serverhello,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (OPENSSL_memchr(CBS_data(&ec_point_format_list),\n                     TLSEXT_ECPOINTFORMAT_uncompressed,\n                     CBS_len(&ec_point_format_list)) == NULL) {\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n}', 'explanation': 'This code segment checks whether the EC point format list contains the mandatory uncompressed format as required by RFC 4492. If it is missing, the function sets out_alert to SSL_AD_ILLEGAL_PARAMETER and returns false, thereby attempting to terminate the connection per spec (i.e., action A1).'}}]","The provided function implements part of the specified RFC requirement by verifying that the mandatory uncompressed EC point format is included. When this condition is not met, it sets the illegal_parameter alert and returns false. However, while the RFC mandates that any semantically invalid message (even if syntactically correct) should lead to connection termination with an illegal_parameter alert, the function only explicitly sets the alert in the case of missing the uncompressed format. Other error checks (such as invalid syntax, e.g. failing to extract a length‐prefixed value or leftover bytes in the buffer) merely return false without setting out_alert. Therefore, the implementation only partially matches the full constraint as laid out in the spec.",success,
8257,ext_ec_point_parse_serverhello,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(hs->ssl) >= TLS1_3_VERSION) {\n    return false;\n}', 'explanation': 'This code snippet checks if the protocol version is TLS 1.3 or higher and immediately returns false. This prevents processing of the ec_point_format extension in TLS 1.3 handshakes, which aligns with the spec requirement that TLS 1.3 implementations MUST NOT send them. The function thereby directly enforces the constraint within its own logic.'}}]","The provided function explicitly checks the protocol version and disallows processing of the ec_point_format extension in TLS 1.3 by returning false when the protocol version is TLS 1.3 or greater. This behavior fully addresses the spec constraint that TLS 1.3 implementations must not send the extension, ensuring that if it is encountered in a TLS 1.3 handshake it is treated as an error. No other parts of the function or external dependencies affect this decision, so the function fully matches the given spec constraint.",success,
8257,ext_ec_point_parse_serverhello,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(hs->ssl) >= TLS1_3_VERSION) {\n    return false;\n  }', 'explanation': 'This code explicitly checks if the protocol version is TLS 1.3 or higher and returns false in that case, ensuring that TLS 1.3 is not negotiated, as required by the RFC specification.'}}]","The function clearly implements the requirement to not negotiate TLS 1.3 by checking the protocol version and rejecting TLS 1.3 connections. No other parts of the specification are applicable here, and the relevant constraint (labeled C1) is fully addressed within the function_body itself.",success,
8258,ext_ec_point_parse_clienthello,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(hs->ssl) >= TLS1_3_VERSION) {\n    return true;\n}', 'explanation': 'This code checks if the negotiated protocol version is TLS 1.3 or higher and returns immediately, effectively bypassing any extension negotiation processing. This behavior directly supports the RFC requirement that TLS 1.3 must not be negotiated in this context.'}}]","The function explicitly avoids further processing for TLS versions 1.3 and above by returning true immediately when such a version is detected. This logic satisfies the RFC specification condition that the system must not negotiate TLS 1.3, and thus the function fully matches the given constraint.",success,
8259,ext_ec_point_add_serverhello,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    return true;\n}', 'explanation': 'This code block checks if the SSL connection is using TLS 1.3 or higher, and if so, immediately returns without adding the extension. This directly enforces the TLS 1.3 requirement that the extension MUST NOT be sent.'}}]","The function explicitly checks the protocol version and avoids sending the extension when using TLS 1.3, which matches the specification constraint that TLS 1.3 implementations MUST NOT send this extension. No other logic in the function is necessary to address the spec, making the implementation in this function fully match the provided RFC requirement.",success,
8259,ext_ec_point_add_serverhello,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    return true;\n}', 'explanation': 'This conditional check ensures that if the negotiated protocol is TLS 1.3 or higher, the function returns early and does not add the EC point extension, thereby enforcing the RFC requirement that TLS 1.3 must not be negotiated.'}}]","The function begins by checking whether the SSL protocol version is TLS 1.3 or higher. If it is, the function exits early by returning true, meaning it does not negotiate or add the EC point detail in the ServerHello. This behavior directly implements the RFC specification which mandates that TLS 1.3 must not be negotiated. The rest of the function handles ECC-related extensions for protocols prior to TLS 1.3, but regarding the specific constraint from the RFC, the code fully meets the requirement.",success,
8262,ext_pre_shared_key_add_clienthello,"The client MAY use this PSK for future handshakes by including the ticket value in the ""pre_shared_key"" extension in its ClientHello (Section 4.2.11).",239,Fully Matches,"[{'C1': {'code': 'CBB_add_u16_length_prefixed(&contents, &identity) &&\nCBB_add_u16_length_prefixed(&identity, &ticket) &&\nCBB_add_bytes(&ticket, ssl->session->ticket.data(), ssl->session->ticket.size())', 'explanation': 'This segment encodes the PSK ticket by adding its length-prefixed content and then the actual ticket bytes into the pre_shared_key extension, thereby allowing the client to include the ticket value as specified.'}}, {'A1': {'code': 'OPENSSL_timeval now = ssl_ctx_get_current_time(ssl->ctx.get());\nuint32_t ticket_age = 1000 * (now.tv_sec - ssl->session->time);\nuint32_t obfuscated_ticket_age = ticket_age + ssl->session->ticket_age_add;', 'explanation': ""This part computes the obfuscated ticket age by deriving the ticket's age based on the current time and adding a random offset. It implements the necessary action to include the obfuscated ticket age in the extension.""}}]","The function implements the pre_shared_key extension in the ClientHello message by encoding both the ticket value and the obfuscated ticket age. It follows the specification by adding the ticket data, computing the ticket age with a random addition, and reserving space for the binder. All of these steps are handled inside the function without relying on external dependencies, and thus it fully meets the spec constraints.",success,
8263,ssl_ext_pre_shared_key_parse_serverhello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16(contents, &psk_id) || CBS_len(contents) != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n}', 'explanation': 'This segment checks that the message exactly contains a 2-byte PSK identity and no extra data, ensuring that any message with an out‐of-bound length (or not enough bytes) is caught. This exactly implements the condition that if a message cannot be parsed (incorrect length), the connection must be terminated with a decode_error alert.'}}, {'A1': {'code': '*out_alert = SSL_AD_DECODE_ERROR; return false;', 'explanation': 'Upon detecting a parsing error, the function sets the alert to decode_error and returns false, which signals termination of the connection as mandated by the RFC.'}}]","The function first attempts to parse the message by extracting a 16‐bit value and ensuring no extra bytes remain. If the parsing fails, it sets the alert to decode_error and returns false, thereby fulfilling the RFC requirement to terminate the connection with a decode_error alert when a message cannot be parsed. Although the function contains additional logic (e.g., checking that the PSK identity is zero) which is not specified by the RFC, the parsing error condition is fully and correctly implemented within the function.",success,
8263,ssl_ext_pre_shared_key_parse_serverhello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The RFC spec constraints state that when multiple extensions are present in a ClientHello, the pre_shared_key extension MUST be the last extension. This function, however, parses the pre_shared_key extension in a ServerHello message by checking that the extension contains exactly a 2‐byte PSK identity (which must be zero) and does not perform any ordering checks. No part of the function attempts to verify or enforce the ordering requirement specified in the RFC. Therefore, the function does not visibly address the labeled spec constraint.",success,
8263,ssl_ext_pre_shared_key_parse_serverhello,"Sending this alert is OPTIONAL; servers MAY instead choose to send a ""decrypt_error"" alert to merely indicate an invalid PSK identity.",324,Partially Matches,"[{'C1': {'code': 'if (psk_id != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_PSK_IDENTITY_NOT_FOUND);\n    *out_alert = SSL_AD_UNKNOWN_PSK_IDENTITY;\n    return false;\n  }', 'explanation': 'This segment checks that the only advertised PSK identity index is zero and sends an alert when it isn’t. The RFC specifies that in the case of an invalid PSK identity, sending an alert is OPTIONAL and servers MAY choose to send a decrypt_error instead. Here, the function unconditionally sends a specific alert (SSL_AD_UNKNOWN_PSK_IDENTITY) rather than offering the optional behavior, which makes it only a partial match.'}}]","The function validates the PSK identity by verifying that it equals zero, which is in line with the advertisement of a single PSK identity. However, while the RFC indicates that sending an alert on an invalid PSK identity is optional and allows for alternative alert types (such as decrypt_error), this function always sends SSL_AD_UNKNOWN_PSK_IDENTITY when the check fails. Moreover, other parts of the RFC (such as the closure alert exchange context) are not handled within this function. Consequently, the function only partially matches the RFC specification.",success,
8263,ssl_ext_pre_shared_key_parse_serverhello,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided code function is dedicated to parsing a pre-shared key extension in a TLS ServerHello message and does not contain any logic addressing the prohibition of RC4 cipher suites as specified by the RFC. There are no code segments that check or prevent RC4 usage, hence none of the labeled spec conditions or actions (e.g., C1, A1) are implemented within this function.",success,
8264,ssl_ext_pre_shared_key_parse_clienthello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Fully Matches,"[{'C1': {'code': 'if (CBS_data(contents) + CBS_len(contents) != client_hello->extensions + client_hello->extensions_len) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_PRE_SHARED_KEY_MUST_BE_LAST);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n}', 'explanation': ""This segment checks that the data pointer of the pre_shared_key extension (represented by 'contents') plus its length exactly equals the end of the ClientHello extensions block. This enforces the requirement from the RFC that 'pre_shared_key' MUST be the last extension in the ClientHello.""}}]","The provided code function directly verifies the RFC constraint that when the pre_shared_key extension is present in a ClientHello message, it must be the last extension. The check using pointer arithmetic ensures that the extension occupies the final position in the extensions block. Since this is the sole constraint mentioned in the spec input regarding the order of extensions, and the function implements it directly, the function is judged as fully matching the specified condition.",success,
8264,ssl_ext_pre_shared_key_parse_clienthello,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'C1': {'code': 'if (CBS_data(contents) + CBS_len(contents) !=\n      client_hello->extensions + client_hello->extensions_len) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_PRE_SHARED_KEY_MUST_BE_LAST);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n  }', 'explanation': 'This segment checks that the pre_shared_key extension is the very last extension in ClientHello. Failing this check correctly triggers an illegal_parameter alert as required when a semantically invalid (improperly ordered) message is received.'}}, {'A1': {'code': 'if (num_identities != num_binders) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_PSK_IDENTITY_BINDER_COUNT_MISMATCH);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n  }', 'explanation': 'This segment validates that the number of PSK identities matches the number of PSK binders. A mismatch here indicates a semantically invalid message, and the function responds by setting an illegal_parameter alert.'}}]","The function contains isolated checks that ensure the pre_shared_key extension is the last extension and that PSK identities and binders count match, with both violations leading to an illegal_parameter alert. However, it only partially addresses the overall specification constraint regarding handling syntactically correct but semantically invalid messages, as not all potential semantically invalid cases are handled solely within this function. Thus, the function partially matches the spec constraints.",success,
8264,ssl_ext_pre_shared_key_parse_clienthello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (CBS_data(contents) + CBS_len(contents) !=\n      client_hello->extensions + client_hello->extensions_len) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_PRE_SHARED_KEY_MUST_BE_LAST);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n  }', 'explanation': ""This code checks that the pre_shared_key extension is the last extension, enforcing a syntactical constraint. However, the RFC requires that any parsing error results in a 'decode_error' alert; here an 'illegal_parameter' alert is issued.""}}, {'A1': {'code': 'if (!CBS_get_u16_length_prefixed(contents, &identities) ||\n      !CBS_get_u16_length_prefixed(&identities, out_ticket) ||\n      !CBS_get_u32(&identities, out_obfuscated_ticket_age) ||\n      !CBS_get_u16_length_prefixed(contents, &binders) ||\n      CBS_len(&binders) == 0 ||\n      CBS_len(contents) != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n  }', 'explanation': 'The function uses multiple length-prefixed parsing routines and, upon failing these checks, it emits a decode error alert and terminates. This directly aligns with the RFC requirement to halt processing on parsing errors.'}}]","The function attempts to ensure that malformed PSK extension data (such as length issues or format errors) results in an immediate error state. In most cases, it returns a decode error alert, which is in keeping with the RFC’s mandate to terminate the connection when a message cannot be parsed per the syntax. However, one branch (checking that the pre_shared_key extension is the last extension) sets an 'illegal_parameter' alert instead of a 'decode_error' alert. Because not all parse failures use the prescribed alert type, the function only partially implements the RFC’s specified behavior.",success,
8264,ssl_ext_pre_shared_key_parse_clienthello,"Servers MUST check that it is the last extension and otherwise fail the handshake with an ""illegal_parameter"" alert.",173,Fully Matches,"[{'C1': {'code': 'if (CBS_data(contents) + CBS_len(contents) !=\n      client_hello->extensions + client_hello->extensions_len) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_PRE_SHARED_KEY_MUST_BE_LAST);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n  }', 'explanation': ""This code segment verifies that the pre_shared_key extension is the last extension in the ClientHello by comparing the pointer to the remaining contents with the end of the extensions list. If the extension is not last, it fails the handshake with an 'illegal_parameter' alert, directly conforming to the spec requirement.""}}]","The function explicitly implements the check mandated by the RFC that requires the pre_shared_key extension to be the last extension in the ClientHello. By comparing the computed end of the extension data with the expected end, and by returning an 'illegal_parameter' alert if the check fails, the function meets the specified constraint fully with its internal logic.",success,
8264,ssl_ext_pre_shared_key_parse_clienthello,"If any other value is returned, the client MUST abort the handshake with an ""illegal_parameter"" alert.",171,Does Not Match,[],"The provided function implements logic specific to parsing the TLS pre_shared_key extension in a ClientHello message, not HTTP message parsing. Although the function sets an illegal_parameter alert in certain error conditions (for example, when the extension is not the last one or when there is a binder/identity count mismatch), it is unrelated to the RFC specification given—which requires that a client abort the handshake with an 'illegal_parameter' alert for any other returned value and also involves parsing a sequence of octets in a specific encoding with considerations for CR, LF, and bare CR handling. There are no code segments in the function that address the detailed HTTP message parsing conditions or the specific alert handling mandated by the HTTP RFC specification. Therefore, the function does not visibly implement the specified RFC constraints.",success,
8264,ssl_ext_pre_shared_key_parse_clienthello,"The ""pre_shared_key"" extension MUST be the last extension in the ClientHello (this facilitates implementation as described below)",172,Fully Matches,"[{'C1': {'code': 'if (CBS_data(contents) + CBS_len(contents) !=\n      client_hello->extensions + client_hello->extensions_len) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_PRE_SHARED_KEY_MUST_BE_LAST);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n  }', 'explanation': ""This code segment directly checks that the pre_shared_key extension is the last extension in the ClientHello message. It ensures that the pointer to the current extension data plus its length is equal to the end of the ClientHello's extensions block, which fulfills the RFC requirement that the pre_shared_key extension must be the last extension.""}}]","The function explicitly implements the RFC requirement by verifying that the pre_shared_key extension is the last extension transmitted in the ClientHello. The check comparing the sum of the pointer and length of the pre_shared_key extension data against the end of the overall extensions block directly enforces the constraint. Other parsing and validation logic in the function does not detract from this specific implementation, so the function fully meets the specified RFC condition (labeled here as C1).",success,
8264,ssl_ext_pre_shared_key_parse_clienthello,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'A1': {'code': 'if (!CBS_get_u16_length_prefixed(contents, &identities) ||    \n      !CBS_get_u16_length_prefixed(&identities, out_ticket) ||  \n      !CBS_get_u32(&identities, out_obfuscated_ticket_age) ||   \n      !CBS_get_u16_length_prefixed(contents, &binders) ||       \n      CBS_len(&binders) == 0 ||                                 \n      CBS_len(contents) != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n  }', 'explanation': ""This segment aborts the handshake by returning false and setting the alert to SSL_AD_DECODE_ERROR when parsing of identities and binders fails. It shows an attempt to meet the spec action that requires aborting with a 'decode_error' alert on error conditions.""}}]","The provided function implements several checks on the pre_shared_key extension and aborts the handshake on failure, which is in line with the requirement to abort if conditions are not met. However, although one branch uses SSL_AD_DECODE_ERROR (matching the spec’s mandate for a 'decode_error' alert), other error branches (e.g. when the extension is not the last one, or when the identity/binder counts mismatch) set the alert to SSL_AD_ILLEGAL_PARAMETER. Because the specification unambiguously requires a 'decode_error' alert, the function only partially meets the spec constraints.",success,
8265,ssl_ext_pre_shared_key_add_serverhello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The provided function exclusively handles adding the pre_shared_key extension for a ServerHello message, and its logic does not address the specific ordering requirement for the pre_shared_key extension in a ClientHello (i.e., that it must be the last extension), nor does it address any HTTP HEAD method behavior as described in the spec context. There is no visible logic within this function that implements any of the labeled conditions or actions from the provided RFC specification.",success,
8265,ssl_ext_pre_shared_key_add_serverhello,"A client MUST provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension.",136,Does Not Match,[],"The RFC specifies that a client MUST provide a 'psk_key_exchange_modes' extension if it offers a 'pre_shared_key' extension. However, this function (ssl_ext_pre_shared_key_add_serverhello) only handles adding the pre_shared_key extension on the server side (when resuming a session) and does not implement any logic to verify or enforce the presence of the psk_key_exchange_modes extension from the client. The function neither checks for nor processes the psk_key_exchange_modes extension, thus it does not address the spec constraint within its own logic.",success,
8266,ext_psk_key_exchange_modes_add_clienthello,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function, ext_psk_key_exchange_modes_add_clienthello, implements logic related to the addition of PSK key exchange modes in TLS 1.3 handshakes. It specifically checks if the maximum TLS version is at least TLS 1.3 and avoids adding PSK key exchange modes when PAKE is in use. However, the RFC specification provided states that ""The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3."" There is no logic within the function that checks for or prevents the use of the OpenPGP certificate type with TLS 1.3. Therefore, the function does not address any constraint (conditions or actions labeled as C1, A1, etc.) related to the prohibited use of the OpenPGP certificate type in TLS 1.3.",success,
8266,ext_psk_key_exchange_modes_add_clienthello,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Fully Matches,"[{'C1': {'code': 'if (hs->max_version < TLS1_3_VERSION) {\n    return true;\n  }', 'explanation': 'This check ensures that the ClientHello extension for PSK key exchange modes is only added for TLS 1.3 handshakes. By skipping the extension for non–TLS 1.3 connections, the function avoids any possibility of offering modes (including obsolete_RESERVED ones) that are only applicable in earlier versions.'}}, {'A1': {'code': '!CBB_add_u8(&ke_modes, SSL_PSK_DHE_KE)', 'explanation': 'The extension is populated with a single, valid mode (SSL_PSK_DHE_KE) and no other value. This means that no value from the obsolete_RESERVED range is ever offered, in compliance with the specification requirement.'}}]","The function implements the desired specification behavior by ensuring that for TLS 1.3, only the allowed PSK key exchange mode is added to the ClientHello message. The initial check bypasses extension addition when the protocol version is below TLS 1.3, whereas in TLS 1.3 the function adds a single mode, SSL_PSK_DHE_KE, avoiding any inclusion of values from an obsolete_RESERVED range. Therefore, the logic contained within this function alone fully meets the constraint that obsolete_RESERVED values must not be offered by TLS 1.3 implementations.",success,
8266,ext_psk_key_exchange_modes_add_clienthello,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The RFC states that the server MUST NOT send a 'psk_key_exchange_modes' extension. However, this function is client-side logic that conditionally adds the PSK key exchange modes extension to the ClientHello when using TLS 1.3 (unless hs->pake_prover is non-null). It does not address preventing the server from sending that extension. In other words, the function does not enforce the RFC requirement regarding the server’s behavior but rather constructs a client message, so it does not implement the specified constraint.",success,
8266,ext_psk_key_exchange_modes_add_clienthello,"In particular, it MUST NOT negotiate TLS 1.3.",14,Does Not Match,[],"The provided function does not implement any logic that prevents the negotiation of TLS 1.3 as required by the spec. Instead, it only performs an early exit (returning true) when the handshake maximum version is less than TLS1_3_VERSION. When hs->max_version is TLS 1.3 or higher, it proceeds to add the PSK key exchange modes extension, which is an active part of the TLS 1.3 handshake process. There is no internal mechanism in the function that forbids TLS 1.3, so it fails to address the spec constraint (i.e. it MUST NOT negotiate TLS 1.3) within its own code.",success,
8267,ext_psk_key_exchange_modes_parse_clienthello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!CBS_get_u8_length_prefixed(contents, &ke_modes) ||  \n      CBS_len(&ke_modes) == 0 ||                           \n      CBS_len(contents) != 0) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n  }', 'explanation': 'This block checks that the message is correctly parsed by ensuring a valid length‐prefixed structure, that the parsed content is non‐empty, and that no extra bytes remain. If any of these conditions fails, it sets *out_alert to SSL_AD_DECODE_ERROR and returns false, which is an attempt to enforce the RFC requirement to terminate the connection with a decode error upon a parsing error.'}}]","The function examines the provided contents by reading a length-prefixed field and then validates that the length is non-zero and that no additional data remains. In the event of a parse error, it sets the decode_error alert and returns false. This handling visibly addresses part of the RFC requirement concerning messages that cannot be parsed. However, it only covers one specific parsing error scenario and does not implement other potential checks (for example, out-of-range lengths beyond these validations) in this isolated function, which is why the match is considered partial.",success,
8267,ext_psk_key_exchange_modes_parse_clienthello,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u8_length_prefixed(contents, &ke_modes) ||  //\n      CBS_len(&ke_modes) == 0 ||                           //\n      CBS_len(contents) != 0) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n}', 'explanation': ""This code segment validates the incoming data by checking that the key exchange modes field is properly formatted (non-empty and consumes exactly the available data). If the criteria are not met, it aborts the handshake by setting the 'decode_error' alert, matching the RFC requirement.""}}, {'A1': {'code': '*out_alert = SSL_AD_DECODE_ERROR;', 'explanation': ""This action directly enforces the RFC mandate to abort the handshake with a 'decode_error' alert when the parsed data does not meet the expected format.""}}, {'C2': {'code': 'hs->accept_psk_mode = OPENSSL_memchr(CBS_data(&ke_modes), SSL_PSK_DHE_KE,\n                                       CBS_len(&ke_modes)) != NULL;', 'explanation': 'This line inspects the key exchange modes to check for a supported mode (PSK_DHE_KE) and sets the corresponding flag. It is part of handling valid extension data per spec.'}}]","The function checks the validity of the PSK key exchange modes extension by ensuring the provided data is well-formed. If not, it aborts the handshake in accordance with the RFC requirement by setting a 'decode_error' alert. Additionally, it scans for the supported PSK_DHE_KE mode and marks it accordingly, demonstrating that the function addresses both the error condition and the selection of the supported mode as specified.",success,
8268,ext_early_data_add_clienthello,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'C1': {'code': 'if (ssl->s3->used_hello_retry_request) {\n    assert(ssl->s3->early_data_reason != ssl_early_data_unknown);\n    return true;\n  }', 'explanation': 'This code explicitly checks if a Hello Retry Request was used. In that case – indicating a second ClientHello – it bypasses the addition of early data, thereby ensuring that early data is not automatically resent. This directly implements the specification requirement that a TLS implementation SHOULD NOT automatically resend early data, leaving the decision to the application.'}}]","The function 'ext_early_data_add_clienthello' includes logic that guarantees early data is not automatically resent by checking whether a Hello Retry Request occurred. If so, it returns early without adding an early data extension. This behavior satisfies the spec condition (labeled as C1) which mandates that the TLS implementation must not automatically resend early data. All of the logic meeting the specification is contained within this function, and no reliance on external dependencies is used.",success,
8268,ext_early_data_add_clienthello,Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less.,395,Does Not Match,[],"The provided function 'ext_early_data_add_clienthello' only handles the early_data extension of a ClientHello message and comprises logic for adding the early data extension but does not contain any logic related to checking or preventing a ClientHello.legacy_version or ServerHello.legacy_version from being set to 0x0300 or less. Therefore, it does not address the RFC specification constraint.",success,
8268,ext_early_data_add_clienthello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The provided function, ext_early_data_add_clienthello, only deals with adding the early_data extension to the ClientHello and contains no logic to address the ordering of extensions, specifically ensuring that the pre_shared_key extension appears as the last extension. The RFC specification requires that when multiple extensions are present, 'pre_shared_key' must be placed last in the ClientHello. Since this function does not include any checks or mechanisms to enforce this ordering (it simply adds the early_data extension without consideration of the position of pre_shared_key), it does not visibly implement the specified RFC constraint. Dependencies and context around HEAD/GET do not influence this conclusion because only the code within this function is considered.",success,
8268,ext_early_data_add_clienthello,"A client MUST NOT include the ""early_data"" extension in its followup ClientHello.",148,Fully Matches,"[{'C1': {'code': 'if (ssl->s3->used_hello_retry_request) {\n    assert(ssl->s3->early_data_reason != ssl_early_data_unknown);\n    return true;\n}', 'explanation': 'This code checks if the current ClientHello is a followup (indicated by used_hello_retry_request) and avoids adding the early_data extension, directly implementing the spec requirement that the early_data extension MUST NOT be included in followup ClientHellos.'}}]","The function explicitly checks if the ClientHello is a followup (via the used_hello_retry_request flag) and, if so, returns early without appending the early_data extension. This behavior aligns fully with the RFC specification, which mandates that a client must not include the early_data extension in its followup ClientHello. Only the followup scenario is handled in this function, so within its scope it fully meets the spec constraint.",success,
8268,ext_early_data_add_clienthello,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest.",59,Fully Matches,"[{'C1': {'code': 'if (!hs->early_data_offered) {\n    return true;\n  }', 'explanation': 'This check ensures that the early_data extension is not sent unless it was offered by the remote endpoint, satisfying the requirement to not send extension responses if the extension was not requested.'}}, {'C2': {'code': 'if (ssl->s3->used_hello_retry_request) {\n    assert(ssl->s3->early_data_reason != ssl_early_data_unknown);\n    return true;\n  }', 'explanation': 'In the context of a HelloRetryRequest, the function bypasses adding early_data, which aligns with the exception rules (only cookie extension may be sent during HelloRetryRequest) and prevents unnecessary extension responses.'}}]","The function checks whether the early_data extension was offered (via hs->early_data_offered) and only adds the early_data extension if it was. Additionally, it handles the HelloRetryRequest case by early returning and not sending early_data, thereby conforming to the spec's requirement to not send an unsolicited extension response. Thus, the function itself fully implements the relevant constraints in isolation.",success,
8269,ext_early_data_parse_serverhello,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest.",59,Partially Matches,"[{'C1': {'code': 'if (contents == NULL) {\n    if (hs->early_data_offered && !ssl->s3->used_hello_retry_request) {\n      ssl->s3->early_data_reason = ssl->s3->session_reused ? ssl_early_data_peer_declined : ssl_early_data_session_not_resumed;\n    } else {\n      assert(ssl->s3->early_data_reason != ssl_early_data_unknown);\n    }\n    return true;\n  }', 'explanation': 'This block checks if the remote endpoint did not send the early_data extension and, accordingly, does not attempt to process or reply with an extension response. This logic implements the core of the specification requirement that an extension response must not be sent if the corresponding extension request is absent.'}}]","The function inspects whether the early_data extension was received (by checking if 'contents' is NULL) and correctly avoids processing an extension response when it was not offered by the client. This implements the key idea that a response extension should not be sent if the client did not request it. However, the specified RFC exception regarding the 'cookie' extension in a HelloRetryRequest is not addressed within this function (indeed an assertion ensures that it is not processing an HRR path) and no additional logic covers that exceptional behavior. Therefore, while part of the spec constraint is implemented (as seen in the handling of the non-present extension), the overall implementation in this function only partially matches the complete RFC specification.",success,
8269,ext_early_data_parse_serverhello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (CBS_len(contents) != 0) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n}', 'explanation': 'The code checks if the parsed contents are not of the expected length (i.e. there is extra data), and if so, sets the out_alert value to SSL_AD_DECODE_ERROR and returns false. This directly addresses the requirement from the spec that a message which cannot be parsed (due to an extra length, for example) must lead to a decode_error alert.'}}]","The function partially implements the RFC specification by identifying a parsing anomaly—when the content length is non-zero—and setting the appropriate decode_error alert. However, while it meets the alert requirement, it does not on its own handle the full termination of the connection (which may be handled by the caller or elsewhere), so only part of the spec is addressed within this function.",success,
8269,ext_early_data_parse_serverhello,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function focuses on parsing the early data extension in the ServerHello message and updating flags (such as early_data_reason and early_data_accepted). It does not contain any logic that addresses whether early data should automatically be resent or not. In other words, it does not implement any mechanism to decide on or prevent automatic retransmission of early data, which is the requirement specified. Therefore, no part of this function fully implements the spec constraint that the TLS implementation SHOULD NOT automatically resend early data.",success,
8269,ext_early_data_parse_serverhello,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Does Not Match,[],"The provided function implements parsing logic for the early_data extension in a TLS ServerHello. Although there is a branch where it aborts the handshake with a decode_error alert when the content length is non-zero, this behavior pertains solely to the early_data extension. The RFC specification and context provided in the input refer to HTTP upgrade mechanisms (e.g., handling the Upgrade header field, case‐insensitive protocol name matching, and specific protocol ordering) which are not addressed anywhere in this function. Since none of the labeled conditions (e.g., C1) or actions (e.g., A1) from the HTTP RFC specification are visibly implemented within this function, it does not match the specified RFC.",success,
8270,ext_early_data_parse_clienthello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (CBS_len(contents) != 0) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n  }', 'explanation': 'This code segment checks if the received message content is non-empty (i.e., it does not conform to the expected empty body for this extension) and, upon detecting this parse error, sets the decode_error alert and terminates further processing as required by the RFC specification.'}}]","The function verifies that the early data extension in the ClientHello message is empty. In the context of this extension, any non-empty content is considered a parsing error. When such a case is detected, the function sets *out_alert to SSL_AD_DECODE_ERROR and returns false, thereby indicating termination of processing according to the RFC mandate. Since this logic directly implements the required behavior in response to a parse error without delegating to external dependencies, the function fully meets the specified constraint.",success,
8270,ext_early_data_parse_clienthello,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function only parses the early data extension from a ClientHello message by checking if the early_data is present and setting a flag (hs->early_data_offered). It does not implement any logic to prevent the automatic retransmission of early data as specified in the RFC. There is no code segment that addresses the requirement that a TLS implementation SHOULD NOT automatically resend early data, hence no condition or action (e.g., C1, A1) from the spec constraints is met within this function.",success,
8270,ext_early_data_parse_clienthello,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (CBS_len(contents) != 0) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n}', 'explanation': ""This code segment ensures that the extension's contents are empty. According to the spec, if the condition (extension is not empty) is met, the handshake must be aborted with a decode_error.""}}, {'A1': {'code': '*out_alert = SSL_AD_DECODE_ERROR;', 'explanation': 'Setting the out alert to SSL_AD_DECODE_ERROR directly implements the action to abort the handshake with the appropriate alert when the extension does not meet the conditions.'}}]","The function ext_early_data_parse_clienthello checks if the TLS version is TLS 1.3 and then verifies that the parsed 'contents' is empty. If it is not empty, it sets the alert to SSL_AD_DECODE_ERROR and aborts the handshake, which is in direct accordance with the specification that requires an alert abort if a provided extension is not valid (empty in this case). Therefore, the code fully addresses the constraints by implementing the necessary condition (C1) and consequent action (A1) stated in the RFC.",success,
8271,ext_early_data_add_serverhello,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function only checks if early data was accepted (using hs->ssl->s3->early_data_accepted) and, if so, adds an extension to the server hello message. It does not implement any logic related to retransmission control of early data as specified by the RFC requirement that a TLS implementation SHOULD NOT automatically resend early data. No part of the function manages application control over retransmissions or prevents automatic resending of early data. Therefore, the function does not address the provided spec constraint.",success,
8273,ext_key_share_add_clienthello,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function deals with processing key shares in the TLS ClientHello and does not implement any logic associated with the RFC6091 constraint that ""The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3."" There is no check or handling related to OpenPGP certificate types in the function_body. All logic present, such as checking the TLS version and handling PAKE, is unrelated to the specification constraint. Therefore, the code function does not visibly address the specified spec constraint.",success,
8273,ext_key_share_add_clienthello,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function, ext_key_share_add_clienthello, only processes the outgoing key_share extension data for a TLS client hello message. It does not contain any logic that addresses or enforces the constraints specified by the RFC regarding 'supported_groups' (i.e., not acting on such information prior to handshake completion) or the HTTP If-Unmodified-Since header evaluation context described. Therefore, none of the labeled conditions (C1, C2, etc.) or actions (A1, A2, etc.) from the spec constraints are implemented within this function.",success,
8274,ssl_ext_key_share_parse_serverhello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16(contents, &group_id) ||\n      !CBS_get_u16_length_prefixed(contents, &ciphertext) ||\n      CBS_len(contents) != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n  }', 'explanation': ""This code block checks if the message cannot be parsed correctly (e.g., invalid length or syntax issues) and, in response, sets the alert to DECODE_ERROR and terminates the connection, directly fulfilling the RFC's requirement.""}}]","The function explicitly verifies the parsing of its input message by checking the expected fields and ensuring no extraneous data remains in the buffer, which corresponds to the condition of having a well-formed message. If the parsing fails, it immediately triggers a decode error alert and returns false, effectively terminating the connection as specified by the RFC.",success,
8274,ssl_ext_key_share_parse_serverhello,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (key_share->GroupID() != group_id) {\n    if (!hs->key_shares[1] || hs->key_shares[1]->GroupID() != group_id) {\n      *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n      OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CURVE);\n      return false;\n    }\n    key_share = hs->key_shares[1].get();\n}', 'explanation': ""When the key share group does not match one of the offered groups, the function sets the alert to SSL_AD_ILLEGAL_PARAMETER and returns false. This directly addresses the specification requirement to terminate the connection with an 'illegal_parameter' alert upon detecting a semantically invalid message.""}}]","The function inspects the key share parameters from the server hello message and, in the case of a group ID mismatch (indicating a semantically invalid message), it terminates the handshake by returning false and setting an 'illegal_parameter' alert. This behavior partially implements the RFC specification which mandates that peers terminate the connection with an 'illegal_parameter' alert when a semantically invalid message is received. However, the function does not address all possible semantic errors (e.g., invalid DHE parameters) mentioned in the spec, hence the overall outcome is 'Partially Matches'.",success,
8274,ssl_ext_key_share_parse_serverhello,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function, ssl_ext_key_share_parse_serverhello, is dedicated to processing key share handshake data, such as verifying that a key share was offered, extracting the group identifier and ciphertext, selecting the appropriate key share based on the group identifier, and performing decapsulation. There is no logic within this function that relates to the RFC specifications regarding the use of the 'supported_groups' extension or the evaluation of an 'If-Unmodified-Since' header field. As the constraints (e.g., condition C1 or action A1) specified in the RFC and its context are not addressed at all within this function, the code does not attempt to implement the specified RFC constraints.",success,
8274,ssl_ext_key_share_parse_serverhello,"If (EC)DHE key establishment is in use, then the ServerHello contains a ""key_share"" extension with the server's ephemeral Diffie-Hellman share; the server's share MUST be in the same group as one of the client's shares.",0,Fully Matches,"[{'C1': {'code': 'if (hs->key_shares[0] == nullptr) {\n    // If we did not offer key shares, the extension should have been rejected\n    OPENSSL_PUT_ERROR(SSL, ERR_R_INTERNAL_ERROR);\n    *out_alert = SSL_AD_INTERNAL_ERROR;\n    return false;\n}', 'explanation': 'This code checks that the client has indeed offered key shares. The specification requires that a key_share extension must be present when (EC)DHE is in use.'}}, {'C2': {'code': 'SSLKeyShare *key_share = hs->key_shares[0].get();\nif (key_share->GroupID() != group_id) {\n    if (!hs->key_shares[1] || hs->key_shares[1]->GroupID() != group_id) {\n      *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n      OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CURVE);\n      return false;\n    }\n    key_share = hs->key_shares[1].get();\n}', 'explanation': ""This segment verifies that the group's ID provided in the ServerHello key_share extension matches one of the client's offered key share groups, as required by the spec.""}}, {'A1': {'code': 'if (!key_share->Decap(out_secret, out_alert, ciphertext)) {\n    *out_alert = SSL_AD_INTERNAL_ERROR;\n    return false;\n}', 'explanation': ""The decapsulation of the server's ephemeral Diffie-Hellman share is performed here, which is necessary to derive the shared secret. This action directly addresses the processing of the key share according to the RFC.""}}]","The function ssl_ext_key_share_parse_serverhello correctly implements the RFC requirement regarding the key_share extension in the ServerHello. It first verifies that a key share was offered by the client (C1), then checks that the group ID in the server's key share matches one of the client's offered groups (C2). Finally, it performs the decapsulation of the ephemeral share (A1) to derive the necessary secret. The logic within the function addresses all of the relevant conditions and actions specified by the RFC.",success,
8274,ssl_ext_key_share_parse_serverhello,"If this check fails, the client MUST abort the handshake with an ""illegal_parameter"" alert.",132,Fully Matches,"[{'C1': {'code': 'if (key_share->GroupID() != group_id) {\n    if (!hs->key_shares[1] || hs->key_shares[1]->GroupID() != group_id) {\n      *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n      OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CURVE);\n      return false;\n    }\n    key_share = hs->key_shares[1].get();\n  }', 'explanation': ""This segment checks whether the received group_id matches the offered key share. If there is no matching key share, it sets the alert to SSL_AD_ILLEGAL_PARAMETER and aborts the handshake, which directly implements the spec requirement stating that a failure should result in an 'illegal_parameter' alert.""}}]","The function explicitly performs a check for a matching key share using the group identifier. When the check fails (i.e., if neither of the offered key shares matches the group_id provided in the serverhello), the function sets *out_alert to SSL_AD_ILLEGAL_PARAMETER and terminates the handshake. This behavior fully addresses the spec constraint which requires that, on such a mismatch, the handshake be aborted with an 'illegal_parameter' alert. Dependencies and context outside this function are not considered, so the function itself visibly addresses the constraint.",success,
8275,ssl_ext_key_share_parse_clienthello,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (CBS_len(&peer_key) != 0) {\n        OPENSSL_PUT_ERROR(SSL, SSL_R_DUPLICATE_KEY_SHARE);\n        *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n        return false;\n      }', 'explanation': ""This code segment handles a scenario where a duplicate key share is received. When the function finds more than one key share for the selected group, it treats the message as semantically invalid and terminates the connection with an 'illegal_parameter' alert, which aligns with the specification's requirement for handling semantically invalid messages.""}}]","The RFC specifies that peers must terminate the connection with an 'illegal_parameter' alert when a message is syntactically correct but semantically invalid. The function implements one instance of that requirement by detecting a duplicate key share and setting the alert value accordingly. However, it does not address all possible semantic issues referenced in the RFC (such as handling a DHE share of p-1 or an invalid enum), so while it does attempt part of the requirement, it does not fully cover every aspect of the spec constraints within this function alone.",success,
8275,ssl_ext_key_share_parse_clienthello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!CBS_get_u16_length_prefixed(&contents, &key_shares) ||\n      CBS_len(&contents) != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    return false;\n  }', 'explanation': 'This code checks that the key share extension uses a valid length-prefix and that no extra bytes remain, which is an attempt to enforce correct parsing of message lengths as required by the RFC.'}}, {'C1': {'code': 'while (CBS_len(&key_shares) > 0) {\n    uint16_t id;\n    CBS peer_key_tmp;\n    if (!CBS_get_u16(&key_shares, &id) ||\n        !CBS_get_u16_length_prefixed(&key_shares, &peer_key_tmp) ||\n        CBS_len(&peer_key_tmp) == 0) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n      return false;\n    }\n    ...\n  }', 'explanation': 'Within the loop over key shares, the function verifies that each key share segment adheres to the expected length and structure. This is another attempt to detect and react to any out-of-bound or ill-formed length fields.'}}]","The code function attempts to enforce correct parsing by verifying length-prefixed data and checking the integrity of the structure. It issues errors (using OPENSSL_PUT_ERROR with a decode_error code) when parsing anomalies are detected. However, while it does detect syntax errors, it does not consistently set the output alert (out_alert) to a 'decode_error' alert (for example, in some cases it returns false without assigning out_alert). As the RFC requires that a decode error trigger termination with a 'decode_error' alert, the implementation only partially matches the spec constraints.",success,
8275,ssl_ext_key_share_parse_clienthello,"Servers MAY check for violations of these rules and abort the handshake with an ""illegal_parameter"" alert if one is violated.",125,Partially Matches,"[{'A1': {'code': 'if (CBS_len(&peer_key) != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DUPLICATE_KEY_SHARE);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n  }', 'explanation': 'When a duplicate key share (i.e. a violation per spec) is found, the function abandons processing and sets the alert to SSL_AD_ILLEGAL_PARAMETER, which corresponds to aborting the handshake as the spec permits.'}}]","The provided function checks for a specific violation—the presence of duplicate key shares—and aborts the handshake with an 'illegal_parameter' alert if detected. This action matches one of the spec’s allowed behaviors (i.e. the server may abort the handshake upon rule violations). However, since the spec may include other conditions or actions that are not implemented solely within this function, the implementation only partially matches the overall spec constraints.",success,
8275,ssl_ext_key_share_parse_clienthello,"Servers receiving a ClientHello which does not conform to these requirements MUST abort the handshake with a ""missing_extension"" alert.",350,Fully Matches,"[{'C1': {'code': 'if (!ssl_client_hello_get_extension(client_hello, &contents, TLSEXT_TYPE_key_share)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_MISSING_KEY_SHARE);\n    *out_alert = SSL_AD_MISSING_EXTENSION;\n    return false;\n}', 'explanation': 'This segment verifies that the ClientHello includes the required key_share extension. If not present, it aborts the handshake by setting the alert to SSL_AD_MISSING_EXTENSION, in line with the RFC requirement that a nonconforming ClientHello leads to termination with a missing_extension alert.'}}]","The function checks that the key_share extension is present in the ClientHello message. If the extension is missing, it properly aborts the handshake with a missing_extension alert. This directly implements the specified RFC requirement by ensuring that noncompliant ClientHello messages are rejected, thus fully matching the labeled condition (C1) and its corresponding action.",success,
8275,ssl_ext_key_share_parse_clienthello,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function (ssl_ext_key_share_parse_clienthello) is responsible for parsing the key_share extension in the TLS ClientHello message and does not include any logic related to handling the 'supported_groups' information nor the evaluation of the If-Unmodified-Since header as described in the RFC specification. No portions of the function implement any of the labeled conditions (e.g., C1) or actions (e.g., A1) associated with the HTTP RFC. Therefore, it does not visibly address any aspects of the specified RFC.",success,
8275,ssl_ext_key_share_parse_clienthello,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, ssl_ext_key_share_parse_clienthello, is focused on parsing the key share extension in a TLS client hello message, specifically handling ECDHE key exchange and PAKE. It does not contain any logic that checks, filters, or prohibits the use of the RC4 cipher suites as mandated by the RFC specification.",success,
8275,ssl_ext_key_share_parse_clienthello,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Does Not Match,[],"The provided code function is written to parse a TLS key_share extension from a ClientHello message and handle errors related to that extension, such as missing key share, decoding errors, or duplicate key shares. The RFC specification provided relates to an HTTP RFC dealing with an upgrade handshake (e.g., sending an Upgrade header field and aborting with a 'decode_error' alert if conditions are not met). There is no logic in the function that addresses the HTTP-specific conditions or actions (such as verifying protocol names, sending a 101 Switching Protocols response with an Upgrade header, or aborting with a 'decode_error' alert as specified). Thus, none of the labeled conditions or actions (C1, A1, etc.) from the HTTP RFC specification are implemented in this TLS key share parsing function.",success,
8276,ssl_ext_pake_add_serverhello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The RFC states that when multiple extensions are present, with the exception of ""pre_shared_key"" which must be last in the ClientHello, there is an ordering requirement. The provided function only implements logic for the PAKE extension addition and does not include any logic to enforce ordering of extensions (specifically, ensuring that pre_shared_key is last in ClientHello). Therefore, the function does not visibly address the RFC constraints regarding extension ordering within itself.",success,
8278,ext_supported_versions_add_clienthello,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The RFC specification requires that values within the obsolete_RESERVED ranges MUST NOT be offered or negotiated by TLS 1.3 implementations. In the provided function, while there is logic to add supported versions and a fake version (for grease) for TLS 1.3, there is no direct handling or explicit filtering of values within the obsolete_RESERVED ranges. The function does not implement any checks or exclusions to prevent offering these obsolete_RESERVED values. Therefore, the code does not visibly address the specified constraint within its own logic.",success,
8279,ext_cookie_add_clienthello,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest.",59,Partially Matches,"[{'C1': {'code': 'if (hs->cookie.empty()) {\n    return true;\n}', 'explanation': 'This check prevents the function from sending any cookie extension data when the handshake state does not contain a cookie, aligning with the requirement to not send an extension response if the corresponding extension request was not received.'}}]","The function inspects the handshake state (hs->cookie) and only writes out a cookie extension when a cookie is present. This behavior implements the 'MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests' requirement. However, it does not differentiate based on the hello type (the 'type' parameter is ignored), so it does not explicitly handle the exception for sending a cookie extension in a HelloRetryRequest scenario. Thus, while part of the spec (checking for the cookie) is fulfilled (C1), the exception for HelloRetryRequest is not handled, meaning the function only partially matches the complete RFC specification.",success,
8280,ext_supported_groups_add_clienthello,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function ext_supported_groups_add_clienthello constructs the supported_groups extension for the ClientHello message by adding a fake group if GREASE is enabled and iterating through the list of groups from tls1_get_grouplist. However, the RFC specification requires that clients MUST NOT act upon any information in the supported_groups extension before a successful handshake, and may use the information in subsequent connections. This function does not implement any logic to delay or restrict actions based on the handshake status—it merely adds the extension data. Therefore, none of the labeled conditions or actions (e.g., C1, A1) from the spec are addressed within this function itself.",success,
8280,ext_supported_groups_add_clienthello,"Clients MUST NOT offer any KeyShareEntry values for groups not listed in the client's ""supported_groups"" extension",124,Does Not Match,[],"The RFC requires that a client must not offer any KeyShareEntry values for groups that are not listed in the client's supported_groups extension. This function only constructs the supported_groups extension by adding group identifiers (including a grease value and values from tls1_get_grouplist) but does not enforce or check that the key share entries offered by the client are a subset of these supported groups. There is no logic within this function that addresses the constraint regarding key share entries. Therefore, the code function does not visibly implement the spec constraint.",success,
8281,ext_supported_groups_parse_serverhello,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function simply returns true without implementing any logic related to the RFC specification. It does not perform checks to ensure that clients do not act upon information from 'supported_groups' before the handshake is complete, nor does it incorporate any explicit handling of the conditions described in the spec constraints (e.g., C1, A1). The function is effectively a stub with a comment noting that the extension is not expected to be echoed, and therefore it does not visibly implement any of the required conditions or actions by itself.",success,
8284,ext_certificate_authorities_add_clienthello,"The ""certificate_authorities"" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which SHOULD be used by the receiving endpoint to guide certificate selection.",104,Does Not Match,[],"The provided code function, ext_certificate_authorities_add_clienthello, is solely responsible for adding the 'certificate_authorities' TLS extension to the ClientHello by checking for CA names and formatting the extension accordingly. It does not include any logic concerning the evaluation of an HTTP If-None-Match header or any conditions/actions (e.g., C1, A1) from the spec constraints provided. Thus, none of the labeled conditions or actions from the specification are addressed in this function.",success,
8284,ext_certificate_authorities_add_clienthello,"The client MAY send the ""certificate_authorities"" extension in the ClientHello message.",105,Fully Matches,"[{'C1': {'code': 'if (ssl_has_CA_names(hs->config)) {\n    CBB ca_contents;\n    if (!CBB_add_u16(out_compressible, TLSEXT_TYPE_certificate_authorities) ||\n        !CBB_add_u16_length_prefixed(out_compressible, &ca_contents) ||\n        !ssl_add_CA_names(hs, &ca_contents) ||\n        !CBB_flush(out_compressible)) {\n      return false;\n    }\n  }', 'explanation': ""This code block checks if the client configuration has CA names (ssl_has_CA_names) and, if so, builds the certificate_authorities extension by adding it to the ClientHello message. This directly implements the RFC's specification that the client MAY send the certificate_authorities extension.""}}]","The provided function inspects the client configuration (via ssl_has_CA_names) and, if applicable, constructs and appends the certificate_authorities extension into the ClientHello message. This logic directly addresses the RFC specification that the client MAY send the certificate_authorities extension, fulfilling the corresponding condition (C1) and its related actions within the function itself.",success,
8284,ext_certificate_authorities_add_clienthello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The provided function only handles the addition of the certificate authorities extension when CA names are present, without any logic addressing extension ordering. The RFC specification requires that when multiple extensions are present, 'pre_shared_key' must be the last extension in ClientHello, but the function does not implement any ordering constraints or checks related to 'pre_shared_key'. Therefore, within its own code, it does not visibly address the RFC requirement.",success,
8284,ext_certificate_authorities_add_clienthello,"A client MUST NOT include the ""early_data"" extension in its followup ClientHello.",148,Does Not Match,[],"The provided spec requires that an early_data extension must not be included in a followup ClientHello, but the code function is related to handling the certificate authorities extension. There is no logic in this code that checks for or prevents the inclusion of the early_data extension. The function only adds CA names if available, and the initial TODO comment does not address the early_data requirement. Therefore, the code function does not visibly address the specified constraint.",success,
8285,ext_certificate_authorities_parse_clienthello,"The client MAY send the ""certificate_authorities"" extension in the ClientHello message.",105,Fully Matches,"[{'C1': {'code': 'if (contents == NULL) {\n    return true;\n}', 'explanation': 'This check confirms that if the certificate_authorities extension is not present, the function returns true, which aligns with the RFC stating the client MAY send this optional extension.'}}, {'A1': {'code': 'hs->ca_names = SSL_parse_CA_list(hs->ssl, out_alert, contents);\nif (!hs->ca_names) {\n    return false;\n}', 'explanation': 'This segment attempts to parse the certificate_authorities list if the extension is provided (and non-empty), ensuring that a valid CA list is obtained.'}}]",The function's internal logic directly addresses the RFC requirement by handling the certificate_authorities extension as an optional component. It returns true when the extension is absent (contents == NULL) and performs a non-empty check followed by a parsing routine when provided. This clearly meets the spec's intent that the client MAY send this extension.,success,
8287,ext_trust_anchors_add_clienthello,Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.,79,Does Not Match,[],"The provided function is responsible for adding a 'trust_anchors' extension to the ClientHello message if requested, as seen in the code that checks 'hs->config->requested_trust_anchors' and adds the corresponding bytes. There is no logic within the function that addresses the specification requirement that 'Clients MUST NOT use cookies in their initial ClientHello in subsequent connections' nor any handling of the '100-continue' expectation described in the spec context. Therefore, this function does not visibly implement any of the specified constraints.",success,
8287,ext_trust_anchors_add_clienthello,"A client MUST NOT include the ""early_data"" extension in its followup ClientHello.",148,Does Not Match,[],"The RFC specification requires that the client MUST NOT include the ""early_data"" extension in its followup ClientHello. However, the provided code function is concerned with adding a trust anchors extension to the ClientHello message and does not contain any logic related to early_data. Since no part of the function addresses the early_data constraint, the function does not implement the specified HTTP RFC conditions.",success,
8288,ext_trust_anchors_parse_clienthello,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function, ext_trust_anchors_parse_clienthello, handles the parsing of a trust anchors extension from a ClientHello message. The RFC specification provided pertains to not acting upon or processing the status_request_v2 extension in TLS 1.3. Since the function is dealing with trust anchors and not with the status_request_v2 extension, it does not implement any part of the specified TLS 1.3 requirement. Furthermore, there is no logic within this function that seems to address ignoring or not sending the status_request_v2 extension as mandated by the RFC.",success,
8288,ext_trust_anchors_parse_clienthello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16_length_prefixed(contents, &child) ||\n      !ssl_is_valid_trust_anchor_list(child)) {', 'explanation': 'This code checks if the message cannot be parsed correctly (either due to a malformed length-prefix or an invalid trust anchor list), which corresponds to the condition where the syntax is not met as per the spec.'}}, {'A1': {'code': '*out_alert = SSL_AD_DECODE_ERROR;\nOPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\nreturn false;', 'explanation': ""When the parsing fails, the function sets the decode_error alert and returns false. This fulfills the action to terminate the connection with a 'decode_error' alert as specified.""}}]","The function implements the RFC requirement that a message failing syntax checks (due to length issues or invalid content) must trigger a termination of the connection with a decode_error alert. It explicitly checks the message format using CBS_get_u16_length_prefixed and ssl_is_valid_trust_anchor_list, and on failure, it sets the alert to SSL_AD_DECODE_ERROR before aborting the handshake. All of these behaviors are contained within this function, so it fully matches the spec constraints.",success,
8288,ext_trust_anchors_parse_clienthello,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, ext_trust_anchors_parse_clienthello, is concerned with parsing a trust anchor list from the ClientHello message and copying it into the handshake structure. There is no code within this function that addresses the disabling of the RC4 cipher suites as required by the RFC specification. Specifically, there is no logic to detect, filter, or avoid RC4 cipher suites, which is the focus of the spec constraint. Therefore, the function does not implement the relevant requirement.",success,
8288,ext_trust_anchors_parse_clienthello,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The provided function does not contain any logic that directly prevents negotiating SSL 2.0. The RFC specifies that SSL2 is considered insufficient and must not be allowed, yet the code only checks if the SSL protocol version is less than TLS1.3 and then returns true without any explicit SSL 2.0 handling. Therefore, none of the spec constraints (e.g., C1, A1) are visibly implemented in this function.",success,
8288,ext_trust_anchors_parse_clienthello,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'A1': {'code': 'if (!CBS_get_u16_length_prefixed(contents, &child) ||\n      !ssl_is_valid_trust_anchor_list(child)) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    return false;\n  }', 'explanation': 'This segment verifies the trust anchor list by parsing it as a length‑prefixed field and validating its content. If the parsing or validation fails, it aborts the handshake by setting the alert to decode_error, which directly implements the spec requirement.'}}]","The RFC specification requires that if an error occurs in processing the data, the handshake must be aborted with a 'decode_error' alert. The function checks whether the contents can be parsed into a properly formatted trust anchor list and, if not, sets *out_alert to SSL_AD_DECODE_ERROR and returns false, thereby aborting the handshake. This logic is implemented solely within the function, matching the specified constraint.",success,
8290,ext_trust_anchors_parse_serverhello,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'C1': {'code': 'if (ssl_protocol_version(hs->ssl) < TLS1_3_VERSION) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_EXTENSION);\n    *out_alert = SSL_AD_UNSUPPORTED_EXTENSION;\n    return false;\n  }', 'explanation': 'When the protocol version is less than TLS1.3 the function detects an unexpected extension and assigns the corresponding alert value. This shows an attempt to send an alert when an error condition is met.'}}, {'C2': {'code': 'if (!CBS_get_u16_length_prefixed(contents, &child) ||\n    CBS_len(&child) == 0 ||\n    !ssl_is_valid_trust_anchor_list(child)) {\n  *out_alert = SSL_AD_DECODE_ERROR;\n  OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n  return false;\n}', 'explanation': 'If the trust anchor list is empty or invalid, the function sets the alert to SSL_AD_DECODE_ERROR, hence trying to signal the error via an alert.'}}, {'A1': {'code': 'if (!hs->peer_available_trust_anchors.CopyFrom(child)) {\n  *out_alert = SSL_AD_INTERNAL_ERROR;\n  return false;\n}', 'explanation': 'On failing to copy trust anchors, the function assigns an internal error alert. This reflects the requirement to send an alert when aborting the handshake.'}}]","The RFC requires that if an implementation sends any alert during connection termination or handshake abortion it MUST use the specific alert code X. This function, when encountering errors (whether due to protocol version mismatch, decoding errors, or internal failures), always sets *out_alert to a particular alert value before returning false. This behavior demonstrates that the function attempts to abide by the rule of sending a designated alert when aborting the handshake. However, it does not itself perform the connection termination actions implied by 'terminate the connection' – it only indicates the error via the alert code. Therefore, while the alert-setting behavior is visible and conforms to the spec’s requirement for sending an alert on error, the actual termination/abortion of the handshake is handled elsewhere. Thus, the function partially matches the RFC requirements when considered in isolation.",success,
8290,ext_trust_anchors_parse_serverhello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16_length_prefixed(contents, &child) ||\n      CBS_len(&child) == 0 ||\n      !ssl_is_valid_trust_anchor_list(child)) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    return false;\n}', 'explanation': 'This code block checks the parsing of the incoming message by verifying that the length-prefixed data is present, non-empty, and valid. This directly implements the condition where a message which cannot be parsed (due to over-length or out-of-range data) triggers a decode error.'}}, {'A1': {'code': '*out_alert = SSL_AD_DECODE_ERROR;', 'explanation': ""Upon detecting a parsing error (as per C1), the function sets the alert to 'decode_error' and returns false. This fulfills the action of terminating the connection with the appropriate alert as required by the spec.""}}]","The function inspects the trust anchor list in the ServerHello extension and performs several checks: it validates the length-prefixed message, ensures the list is non-empty, and confirms the list's validity. When any of these checks fail, the function sets the decode error alert and returns false, thereby implementing the RFC requirement that peers terminating a connection upon receiving a non-parsable message. All relevant error signaling is done within this function without relying on external dependencies.",success,
8290,ext_trust_anchors_parse_serverhello,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Does Not Match,[],"The RFC requires that TLS 1.3 implementations must not send the trust anchor extension but may receive it (for example, from an older TLS implementation). This function, however, explicitly rejects any trust anchor extension if the negotiated protocol version is less than TLS 1.3 (see the protocol version check), thereby not supporting receipt of the extension in older TLS versions. In addition, the function only deals with parsing and storing a trust anchor list and does not handle the sending aspect at all. Therefore, no part of the function fully implements the spec constraints as stated.",success,
8290,ext_trust_anchors_parse_serverhello,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16_length_prefixed(contents, &child) ||\n      CBS_len(&child) == 0 ||\n      !ssl_is_valid_trust_anchor_list(child)) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    return false;\n  }', 'explanation': 'This code block verifies the trust anchor list: it ensures that the length-prefixed content is present, non-empty, and valid. If any of these checks fail, it sets the decode_error alert and aborts the handshake as required by the RFC specification.'}}]","The function implements the core RFC requirement: if the trust anchor list is not correctly decoded or is empty, it must abort the handshake by issuing a decode_error alert. The error-handling branch directly matches the specification phrase 'if not, then it MUST abort the handshake with a ""decode_error"" alert.' Hence, in isolation, the function fully addresses the required condition and action.",success,
8295,ext_quic_transport_params_parse_serverhello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The function 'ext_quic_transport_params_parse_serverhello' does not contain any internal logic addressing the spec constraints regarding extension ordering, including the specific requirement for 'pre_shared_key' to be last in the ClientHello. It simply calls another helper function (ext_quic_transport_params_parse_serverhello_impl) and passes along a flag, meaning that any logic enforcing the RFC constraints is deferred to that function. Since only the code inside the target function is considered, there is no visible implementation of the spec constraints in this function.",success,
8301,ext_quic_transport_params_add_serverhello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The function simply delegates its work to another function (ext_quic_transport_params_add_serverhello_impl) without any visible logic addressing any of the spec constraints. In particular, none of the conditions relating to the ordering of extensions (e.g., ensuring that 'pre_shared_key' is the last extension in a ClientHello) or any actions about handling such extensions are implemented directly within this function. Therefore, no spec constraints (such as C1, A1, etc.) are visibly addressed within the provided code function.",success,
8303,ext_delegated_credential_add_clienthello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The function body only contains a single line that returns true and does not include any logic addressing the requirements stated in the RFC specification. Specifically, the RFC requires handling of extension ordering (e.g., ensuring that 'pre_shared_key' is the last extension in the ClientHello message) as well as other possible constraints outlined in the spec context. Since the function does not perform any checks, modifications, or operations related to these constraints, it does not attempt to implement any of the given conditions (e.g., C1) or actions (e.g., A1) from the spec.",success,
8303,ext_delegated_credential_add_clienthello,"A client MUST NOT include the ""early_data"" extension in its followup ClientHello.",148,Does Not Match,[],"The target function does not implement any logic related to the specified RFC constraint. Specifically, the RFC demands that a client MUST NOT include the ""early_data"" extension in its followup ClientHello, yet the function simply returns true without checking or modifying any aspect of the ClientHello message or the early_data extension. There is no conditional, parameter check, or any related code within the function body to enforce this rule.",success,
8304,ext_delegated_credential_parse_clienthello,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Partially Matches,"[{'C1': {'code': ""if (contents == nullptr || ssl_protocol_version(hs->ssl) < TLS1_3_VERSION) {\n    // Don't use delegated credentials unless we're negotiating TLS 1.3 or\n    // higher.\n    return true;\n}"", 'explanation': 'This code segment checks that the delegated credentials extension is only processed when the connection is using TLS 1.3 or higher. This corresponds to the aspect of the RFC that relates to receiving the extension (i.e. handling it only when applicable) rather than sending it.'}}]","The RFC states that TLS 1.3 implementations MUST NOT send delegated credentials but might receive them from older implementations. This function is part of the receiving/parsing logic. It correctly bypasses processing the extension if the connection is not using TLS 1.3 by checking the protocol version. However, there is no logic in this function addressing the sending aspect of the RFC constraint. Since only the receipt/processing part is implemented within this function, it partially matches the RFC specification.",success,
8304,ext_delegated_credential_parse_clienthello,"In particular, it MUST NOT negotiate TLS 1.3.",14,Does Not Match,[],"The RFC specification explicitly states that TLS 1.3 MUST NOT be negotiated. In contrast, the function 'ext_delegated_credential_parse_clienthello' processes the delegated credentials extension only when the negotiated TLS version is TLS 1.3 or higher (as seen in the check 'ssl_protocol_version(hs->ssl) < TLS1_3_VERSION'). This indicates that the function is designed to operate when TLS 1.3 is in use, which is contrary to the specification. Since the function does not contain any logic to prevent TLS 1.3 negotiation (and in fact only proceeds with its special handling for TLS 1.3), it does not meet the spec constraint.",success,
8305,cert_compression_add_clienthello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The provided function cert_compression_add_clienthello is solely concerned with appending the cert_compression extension data to the ClientHello message. It does not contain any logic related to controlling the order of extensions nor does it check or enforce that a 'pre_shared_key' extension is the last extension in a ClientHello. Therefore, there is no visible implementation within this function addressing the RFC specification constraint about extension ordering.",success,
8305,cert_compression_add_clienthello,"A client MUST NOT include the ""early_data"" extension in its followup ClientHello.",148,Does Not Match,[],"The provided function, cert_compression_add_clienthello, is concerned with adding a certificate compression extension (TLSEXT_TYPE_cert_compression) to a ClientHello message. There is no logic in the function that checks for or excludes the 'early_data' extension as mandated by the spec. Thus, no labeled condition or action related to 'early_data' is addressed within this function.",success,
8306,cert_compression_parse_serverhello,"This extension, if provided by the server, MUST only be sent in the CertificateRequest message.",107,Fully Matches,"[{'C1': {'code': 'if (contents == nullptr) {\n    return true;\n}\n\n// The server may not echo this extension. Any server to client negotiation is\n// advertised in the CertificateRequest message.\nreturn false;', 'explanation': ""The function checks whether the extension data (contents) is present. If 'contents' is non-null, it immediately returns false, effectively rejecting the extension in the ServerHello message, which complies with the RFC specification that the extension MUST only be sent in the CertificateRequest message.""}}]","The function 'cert_compression_parse_serverhello' directly implements the specified RFC constraint by verifying that if any extension content is present in the ServerHello message (i.e., provided by the server), it returns false. This behavior enforces that such an extension is not accepted outside of the CertificateRequest message, thereby fully matching the provided RFC constraint.",success,
8308,cert_compression_add_serverhello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The provided function 'cert_compression_add_serverhello' consists solely of a return statement ('return true;') and does not contain any logic or implementation details that address the specified RFC requirements. It does not implement any ordering or processing of extensions (such as ensuring that 'pre_shared_key' appears in the correct order), nor does it handle any aspects related to the HEAD method or any other actions described in the spec constraints. All logic necessary to fulfill the spec constraints is absent from this function.",success,
8311,ssl_ext_pake_parse_serverhello,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function, ssl_ext_pake_parse_serverhello, focuses on processing a PAKE share using spake2plus and does not include any logic related to the OpenPGP certificate type or checking for TLS 1.3 as mandated by RFC6091. There is no code segment that verifies TLS version or rejects an OpenPGP certificate when TLS 1.3 is in use. Hence, the function does not address the spec constraints provided.",success,
8311,ssl_ext_pake_parse_serverhello,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites. However, the provided function, ssl_ext_pake_parse_serverhello, is focused solely on parsing a PAKE extension in the TLS handshake and does not contain any logic related to cipher suite selection or filtering, especially none addressing the prohibition of RC4 cipher suites. No code segments in this function attempt to implement any condition or action related to the provided RFC spec constraint.",success,
8311,ssl_ext_pake_parse_serverhello,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'A1': {'code': 'if (CBS_len(&pake_msg) != spake2plus::kShareSize + spake2plus::kConfirmSize) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n}', 'explanation': ""This branch checks that the PAKE share is of the proper length. A mis-sized share is a semantically invalid message, so the connection is terminated with an 'illegal_parameter' alert, as required by the RFC.""}}, {'A2': {'code': 'if (!hs->pake_prover->ComputeConfirmation(\n        prover_confirm, prover_secret,\n        pake_msg_span.subspan(0, spake2plus::kShareSize),\n        pake_msg_span.subspan(spake2plus::kShareSize))) {\n    hs->credential->ClaimPAKEAttempt();\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n}', 'explanation': ""If the computation of the confirmation from the PAKE share fails, which signifies that the message is semantically invalid, the function terminates the connection using the 'illegal_parameter' alert.""}}]","The function ssl_ext_pake_parse_serverhello directly implements the behavior mandated by the RFC: if a syntactically correct message is found to be semantically invalid (as signaled by an unexpected message length or a failure during confirmation computation), it terminates the connection by setting the out_alert to SSL_AD_ILLEGAL_PARAMETER. This in-function logic meets the requirement specified in the RFC without relying on other components.",success,
8311,ssl_ext_pake_parse_serverhello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': '*out_alert = SSL_AD_DECODE_ERROR;\n\nif (!CBS_get_u16(contents, &named_pake) ||\n    !CBS_get_u16_length_prefixed(contents, &pake_msg) ||\n    CBS_len(contents) != 0 ||\n    named_pake != SSL_PAKE_SPAKE2PLUSV1) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n  return false;\n}', 'explanation': ""This segment attempts to verify the input message's syntax. Upon a failure in parsing (e.g. message boundary/length issues or an unexpected PAKE identifier) it returns false while the default alert remains set to decode_error. This partially aligns with the RFC requirement to terminate the connection with a decode_error alert when parsing fails.""}}]","The function does include logic to check whether the message is syntactically valid and returns an error if parsing fails, which is in line with the RFC stating that peers must terminate the connection with a decode_error alert when encountering an unparseable message. However, the function also returns errors in cases where other conditions apply (for example, when the PAKE share length is incorrect or when PAKE is not offered, setting alerts such as SSL_AD_ILLEGAL_PARAMETER or SSL_AD_INTERNAL_ERROR) rather than consistently using decode_error. Thus, while part of the parsing errors is handled as specified, other error paths do not strictly use the decode_error alert mandated by the RFC, leading to a partial match.",success,
8312,ext_pake_parse_clienthello,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function ext_pake_parse_clienthello is focused on parsing a PAKEClientHello message and processing PAKE shares, specifically validating the order and handling a particular PAKE type (SSL_PAKE_SPAKE2PLUSV1). There is no visible logic that checks or enforces the condition from RFC6091 prohibiting the use of the OpenPGP certificate type with TLS 1.3. Thus, none of the labeled spec constraints (e.g., C1, A1) are addressed within this function.",success,
8312,ext_pake_parse_clienthello,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function (ext_pake_parse_clienthello) is responsible for parsing PAKEClientHello messages and handling PAKE shares. It does not contain any logic related to the RFC specification which states that implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS. Since there is no code that checks, prevents, or negotiates cipher suites (specifically RC4) within this function, the spec constraint is not implemented here.",success,
8312,ext_pake_parse_clienthello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16_length_prefixed(contents, &client_identity) ||\n      !CBS_get_u16_length_prefixed(contents, &server_identity) ||\n      !CBS_get_u16_length_prefixed(contents, &shares) ||\n      CBS_len(contents) != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    return false;\n}', 'explanation': 'This segment verifies that each length‐prefixed component of the message fits within the message boundaries. If any parsing step fails (e.g., due to an extended length or out-of-range length), it triggers an error response, thereby meeting the requirement for detecting improperly formatted messages.'}}, {'A1': {'code': '*out_alert = SSL_AD_DECODE_ERROR;', 'explanation': ""By explicitly setting the alert to 'decode_error' before any parsing checks and returning false on error, the function ensures that any unparseable message results in terminating the connection with the appropriate alert, as specified by the RFC.""}}]","The function 'ext_pake_parse_clienthello' performs robust parsing of length‐prefixed fields and ensures that any deviation from the expected syntax (whether through an overlong field, missing bytes, or other problems) immediately sets the alert to 'decode_error' and returns false. This clear and immediate handling of parsing errors directly addresses the RFC requirement that peers terminate the connection with a 'decode_error' alert when encountering messages that cannot be parsed correctly.",success,
8314,ext_alps_add_clienthello_impl,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided code function implements logic for adding the ALPS (Application Layer Protocol Settings) extension in the ClientHello message, checking conditions such as TLS 1.3 availability, non-renegotiation, and ALPN configurations. It does not address any of the RFC spec constraints regarding the status_request_v2 extension (e.g., not processing its presence in ClientHello messages or ensuring it is not sent in EncryptedExtensions, CertificateRequest, or Certificate messages). Thus, none of the labeled conditions (C1, C2, etc.) or actions (A1, A2, etc.) from the provided TLS 1.3 RFC specification are visibly implemented in this function.",success,
8314,ext_alps_add_clienthello_impl,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The RFC specification states that values within the obsolete_RESERVED ranges (i.e. the obsolete codepoint) must not be offered by TLS 1.3 implementations. In the function, the extension_type is set to TLSEXT_TYPE_application_settings_old when the configuration flag (alps_use_new_codepoint) is false. This means that in TLS 1.3, if the configuration opts for the old codepoint, the extension is offered using an obsolete value, which violates the RFC requirement. Therefore, the function does not implement the constraint fully within its own logic.",success,
8314,ext_alps_add_clienthello_impl,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided code function does not implement any logic that addresses the RFC6091 requirement stating that the OpenPGP certificate type MUST NOT be used with TLS 1.3. The function’s logic is solely focused on managing the ALPS extension under TLS 1.3 conditions and is not related to certificate type restrictions as specified in the RFC. Therefore, no spec constraints (such as a condition or action regarding OpenPGP certificate type with TLS 1.3) are visibly addressed in this function body.",success,
8314,ext_alps_add_clienthello_impl,"In particular, it MUST NOT negotiate TLS 1.3.",14,Does Not Match,[],"The RFC specification explicitly states that the implementation MUST NOT negotiate TLS 1.3. However, the code function makes a decision based on the TLS version by proceeding to add the ALPS extension only if hs->max_version is at least TLS1_3_VERSION (as indicated by the comment 'ALPS requires TLS 1.3'). This means that if TLS 1.3 is available, the function will include ALPS, which contradicts the RFC requirement. Since no logic in the function prevents negotiating TLS 1.3, the function does not meet the specified constraint.",success,
8317,ext_alps_parse_serverhello_impl,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided RFC specification states that the OpenPGP certificate type MUST NOT be used with TLS 1.3. However, the code function (ext_alps_parse_serverhello_impl) is dedicated to parsing the ALPS (Application-Layer Protocol Settings) extension and explicitly requires TLS 1.3 (as seen in the version check 'if (ssl_protocol_version(ssl) < TLS1_3_VERSION)') for its operation. There is no logic in the function that checks for or prohibits the use of the OpenPGP certificate type. Therefore, none of the spec constraints (e.g., C1, A1) regarding the OpenPGP certificate type are visibly addressed by this function.",success,
8317,ext_alps_parse_serverhello_impl,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) < TLS1_3_VERSION) {\n    *out_alert = SSL_AD_UNSUPPORTED_EXTENSION;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_EXTENSION);\n    return false;\n}', 'explanation': 'This code snippet enforces that the protocol version must be at least TLS1.3. Since SSL 3.0 (and any protocol version lower than TLS1.3) would fail this check, it prevents negotiating SSL 3.0, thereby fulfilling the RFC requirement that SSL 3.0 MUST NOT be negotiated.'}}]","The provided function implements a check to ensure that ALPS is only used with TLS 1.3 by verifying the protocol version. Because SSL 3.0 is less than TLS1_3_VERSION, the function responds with an alert and aborts processing if a lower version is detected. This directly addresses the RFC's restriction on negotiating SSL 3.0, and the logic is contained entirely within the function, meaning it fully meets the intended constraint.",success,
8323,ssl_negotiate_alps,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function ssl_negotiate_alps handles the negotiation of ALPS over TLS 1.3 by inspecting ALPN-selected values and processing application settings extensions, but it does not address the specific RFC6091 requirement that the OpenPGP certificate type MUST NOT be used with TLS 1.3. There is no logic in this function that checks for or prohibits the use of OpenPGP certificates in TLS 1.3 sessions. Therefore, none of the labeled conditions or actions related to the OpenPGP certificate type are implemented within this function.",success,
8323,ssl_negotiate_alps,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The provided code function focuses on negotiating Application Layer Protocol Settings (ALPS) over TLS 1.3 when ALPN is negotiated. It does not contain any logic addressing the RFC specification concerning SSL 2.0—that it is considered insecure and must not be negotiated. None of the labeled conditions/actions from the spec (e.g., checking or rejecting SSL2 negotiation) are implemented in this function; thus, it does not match the RFC requirement.",success,
8323,ssl_negotiate_alps,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS. However, the provided function 'ssl_negotiate_alps' is exclusively concerned with negotiating ALPS (Application-Layer Protocol Settings) in the context of ALPN (Application-Layer Protocol Negotiation) and TLS 1.3. There is no logic in this function that references or checks for RC4 cipher suites. Therefore, this function does not address the specified constraint regarding RC4, and as a result, it does not match the RFC requirement.",success,
8323,ssl_negotiate_alps,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'A1': {'code': 'if (!CBS_get_u16_length_prefixed(&alps_contents, &alps_list) ||  \n        CBS_len(&alps_contents) != 0 ||                              \n        CBS_len(&alps_list) == 0) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n      *out_alert = SSL_AD_DECODE_ERROR;\n      return false;\n    }', 'explanation': ""This segment aborts the handshake by setting the decode_error alert when the ALPS list is not correctly parsed, fulfilling the RFC requirement to abort with a 'decode_error' alert upon malformed extension data.""}}, {'A1': {'code': 'if (!CBS_get_u8_length_prefixed(&alps_list, &protocol_name) ||\n      CBS_len(&protocol_name) == 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n  }', 'explanation': 'This part aborts the handshake if any protocol name entry in the ALPS list is malformed (missing or empty), again triggering the decode_error alert as required by the RFC.'}}]","The function attempts to implement part of the RFC requirement by verifying the integrity of the ALPS extension and aborting the handshake with a 'decode_error' alert when the ALPS data is malformed. Specifically, it checks that the ALPS list is properly length-prefixed and that protocol names are non-empty. However, while these checks address error cases (i.e. the 'if not' situation), other aspects of the RFC—such as handling case-insensitive protocol comparisons or enforcing a handshake abort when the negotiated ALPS does not contain the client‐indicated protocol—are not fully handled within this function. Therefore, the implementation within this function only partially matches the full RFC specification.",success,
8323,ssl_negotiate_alps,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16_length_prefixed(&alps_contents, &alps_list) ||\n    CBS_len(&alps_contents) != 0 ||\n    CBS_len(&alps_list) == 0) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n  *out_alert = SSL_AD_DECODE_ERROR;\n  return false;\n}\n\nwhile (CBS_len(&alps_list) > 0) {\n  CBS protocol_name;\n  if (!CBS_get_u8_length_prefixed(&alps_list, &protocol_name) ||\n      CBS_len(&protocol_name) == 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n  }\n  // ... additional processing ...\n}', 'explanation': 'The function validates the ALPS extension by checking that its length-prefixed fields are correctly formed, and if any parse error is detected (e.g., extra data remains or an empty protocol name is encountered), it triggers a decode_error alert and terminates processing, which matches the RFC requirement.'}}]","The provided function explicitly parses the ALPS extension within the TLS ClientHello message. It checks for parsing errors by verifying length-prefixed structures and ensuring protocol names are not empty. Upon detecting any such error, it calls OPENSSL_PUT_ERROR, sets the alert to SSL_AD_DECODE_ERROR, and returns false, thereby implementing the spec constraint that requires terminating the connection with a decode_error alert when a message cannot be parsed correctly.",success,
8324,ssl_setup_extension_permutation,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function ssl_setup_extension_permutation only implements a permutation of TLS extensions and does not contain any logic related to the Truncated HMAC extension. The RFC specification requires that implementations MUST NOT use the Truncated HMAC extension; however, there is no code in this function that addresses, prohibits, or otherwise refers to the Truncated HMAC extension. Therefore, this function does not visibly address any part of the RFC constraint.",success,
8327,ssl_add_clienthello_tlsext_inner,"The ""pre_shared_key"" extension MUST be the last extension in the ClientHello (this facilitates implementation as described below)",172,Fully Matches,"[{'C1': {'code': 'const size_t len_before = CBB_len(&extensions);\nif (!ext_pre_shared_key_add_clienthello(hs, &extensions, out_needs_psk_binder, ssl_client_hello_inner) ||\n    !CBB_add_bytes(&extensions_encoded, CBB_data(&extensions) + len_before, CBB_len(&extensions) - len_before) ||\n    !CBB_flush(out) ||\n    !CBB_flush(out_encoded)) {\n  return false;\n}', 'explanation': 'The code explicitly adds the pre_shared_key (PSK) extension as the final extension by calling ext_pre_shared_key_add_clienthello after all other extensions have been processed. This enforces the requirement from the RFC that the pre_shared_key extension MUST be the last extension in the ClientHello.'}}]","The function_body processes multiple extensions and ensures that the PSK extension is added last. The code segment starting at 'const size_t len_before = CBB_len(&extensions);' demonstrates that after all other extensions, the pre_shared_key extension is appended. This directly fulfills the specified RFC requirement.",success,
8327,ssl_add_clienthello_tlsext_inner,"A client MUST NOT include the ""early_data"" extension in its followup ClientHello.",148,Does Not Match,[],"The provided RFC specification requires that a client MUST NOT include the 'early_data' extension in its followup ClientHello. Upon reviewing the function_body, there is no logic that checks for, excludes, or prevents the inclusion of an early_data extension. The function assembles the ClientHelloInner message by adding GREASE extensions, iterating through extensions via callbacks, and handling the PSK extension, but it does not reference or handle the early_data extension according to the spec's condition. Therefore, this function does not address the specified RFC constraint.",success,
8327,ssl_add_clienthello_tlsext_inner,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided RFC specification requires that implementations MUST NOT use the Truncated HMAC extension. A review of the function shows that it deals with building ClientHelloInner messages, handling extension encoding, and managing GREASE and compression aspects. However, there is no implementation or check related to the Truncated HMAC extension anywhere in this function. Since no part of its logic addresses this specific RFC constraint, the function does not visibly implement the requirement.",success,
8327,ssl_add_clienthello_tlsext_inner,"The client MAY use this PSK for future handshakes by including the ticket value in the ""pre_shared_key"" extension in its ClientHello (Section 4.2.11).",239,Fully Matches,"[{'A1': {'code': 'const size_t len_before = CBB_len(&extensions);\nif (!ext_pre_shared_key_add_clienthello(hs, &extensions, out_needs_psk_binder, ssl_client_hello_inner) ||\n    !CBB_add_bytes(&extensions_encoded, CBB_data(&extensions) + len_before,\n                   CBB_len(&extensions) - len_before) ||\n    !CBB_flush(out) ||\n    !CBB_flush(out_encoded)) {\n  return false;\n}', 'explanation': 'This code block ensures that the pre_shared_key (PSK) extension is added last in the ClientHello message. By invoking ext_pre_shared_key_add_clienthello and then appending its output after all other extensions, the function directly implements the requirement from the RFC that the client MAY include the ticket value (PSK) in the ClientHello message.'}}]","The function constructs the ClientHelloInner message by adding various TLS extensions and explicitly ensures that the PSK extension is appended at the end, as mandated by the RFC specification. The implementation directly embeds the action of adding the pre_shared_key extension at the last position, satisfying the key requirement given in the RFC that the client may use this PSK in future handshakes by including the ticket value in the pre_shared_key extension.",success,
8327,ssl_add_clienthello_tlsext_inner,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Fully Matches,"[{'C1': {'code': '// The PSK extension must be last. It is never compressed. Note, if there is a\n// binder, the caller will need to update both ClientHelloInner and\n// EncodedClientHelloInner after computing it.\nconst size_t len_before = CBB_len(&extensions);\nif (!ext_pre_shared_key_add_clienthello(hs, &extensions, out_needs_psk_binder, ssl_client_hello_inner) ||\n    !CBB_add_bytes(&extensions_encoded, CBB_data(&extensions) + len_before, CBB_len(&extensions) - len_before) ||\n    !CBB_flush(out) ||\n    !CBB_flush(out_encoded)) {\n  return false;\n}', 'explanation': 'This segment ensures that the pre_shared_key extension is added strictly after all other extensions, thus enforcing the RFC requirement that the pre_shared_key must be last in the ClientHello.'}}]","The function implements the specific ordering constraint dictated by the RFC: while other extensions may be in any order, the pre_shared_key extension is appended last. The explicit comment and the subsequent code segment show that the pre_shared_key extension is handled separately at the end of the extensions list. This fulfills the labeled condition (C1) related to the pre_shared_key ordering requirement.",success,
8328,ssl_add_clienthello_tlsext,"The ""pre_shared_key"" extension MUST be the last extension in the ClientHello (this facilitates implementation as described below)",172,Fully Matches,"[{'C1': {'code': '  // The PSK extension must be last, including after the padding.\n  const size_t len_before = CBB_len(&extensions);\n  if (!ext_pre_shared_key_add_clienthello(hs, &extensions, out_needs_psk_binder, type)) {\n    OPENSSL_PUT_ERROR(SSL, ERR_R_INTERNAL_ERROR);\n    return false;\n  }\n  assert(psk_extension_len == CBB_len(&extensions) - len_before);', 'explanation': 'The code explicitly adds the pre_shared_key extension at the very end of the ClientHello extensions, after any other extensions (e.g., padding). This ensures that the pre_shared_key extension is the last extension, as required by the RFC.'}}]","The function contains logic that directly satisfies the specification constraint that the pre_shared_key extension must be the last extension in the ClientHello. By adding it after all other extensions (including any padding added), the implementation fully adheres to the RFC requirement.",success,
8328,ssl_add_clienthello_tlsext,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The RFC specification requires that the server MUST NOT send a ""psk_key_exchange_modes"" extension. Upon inspection, the function only constructs the ClientHello message and processes various extensions (e.g., fake extensions for GREASE, padding, pre-shared key extensions), but it does not include any explicit logic to check for, prevent, or omit a ""psk_key_exchange_modes"" extension. There is no code segment that specifically addresses this requirement, therefore the function does not implement the specified RFC condition.",success,
8328,ssl_add_clienthello_tlsext,"A client MUST NOT include the ""early_data"" extension in its followup ClientHello.",148,Does Not Match,[],"The RFC specification requires that a client MUST NOT include the ""early_data"" extension in its followup ClientHello. In the provided function, there is no logic that checks for or prevents the inclusion of an early_data extension. The function adds various extensions such as padding extensions, GREASE extensions, and PSK extensions, but there is no indication of any condition or branch handling early_data, nor any exclusion of it in followup ClientHello messages. As a result, the code function does not address the RFC requirement.",success,
8328,ssl_add_clienthello_tlsext,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification requires that implementations MUST NOT use the Truncated HMAC extension. In reviewing the function_body, there is no visible logic that specifically detects, adds, or excludes a truncated HMAC extension. The function instead manages various other TLS extensions (padding, GREASE, PSK, etc.) but does not contain any code that addresses the handling or prohibition of the truncated HMAC extension. Therefore, this function does not visibly implement the specified RFC constraint.",success,
8328,ssl_add_clienthello_tlsext,"The client MAY use this PSK for future handshakes by including the ticket value in the ""pre_shared_key"" extension in its ClientHello (Section 4.2.11).",239,Fully Matches,"[{'A1': {'code': '  // The PSK extension must be last, including after the padding.\n  const size_t len_before = CBB_len(&extensions);\n  if (!ext_pre_shared_key_add_clienthello(hs, &extensions, out_needs_psk_binder, type)) {\n    OPENSSL_PUT_ERROR(SSL, ERR_R_INTERNAL_ERROR);\n    return false;\n  }\n  assert(psk_extension_len == CBB_len(&extensions) - len_before);', 'explanation': 'This code block appends the pre_shared_key extension at the very end of the ClientHello message. It ensures that the PSK (potentially containing the ticket for future handshakes) is included as mandated by the RFC (Section 4.2.11), satisfying the requirement that the client MAY use this PSK in subsequent handshakes.'}}]","The function 'ssl_add_clienthello_tlsext' builds the ClientHello message and clearly includes logic to add the pre_shared_key extension last. By doing so, it directly addresses the RFC specification stating that the client may include the ticket value in the 'pre_shared_key' extension for future handshakes. All the required action is implemented within the function body without relying on external dependencies for this specific behavior.",success,
8328,ssl_add_clienthello_tlsext,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Fully Matches,"[{'C1': {'code': '  // The PSK extension must be last, including after the padding.\n  const size_t len_before = CBB_len(&extensions);\n  if (!ext_pre_shared_key_add_clienthello(hs, &extensions, out_needs_psk_binder, type)) {\n    OPENSSL_PUT_ERROR(SSL, ERR_R_INTERNAL_ERROR);\n    return false;\n  }\n  assert(psk_extension_len == CBB_len(&extensions) - len_before);', 'explanation': 'This block ensures that the pre_shared_key (PSK) extension is always added after all other extensions (including any padding extension), thus enforcing the RFC requirement that the pre_shared_key extension MUST be the last extension in a ClientHello message.'}}]","The code in function_body explicitly guarantees that the PSK extension is appended last by adding it after all other extensions have been processed. This directly implements the spec constraint that while other extensions may appear in any order, the pre_shared_key extension must appear last in the ClientHello, thereby fully matching the specified requirement.",success,
8328,ssl_add_clienthello_tlsext,They MUST NOT be offered or negotiated by any implementation.,100,Does Not Match,[],"The provided function (ssl_add_clienthello_tlsext) is concerned with constructing TLS ClientHello messages, handling TLS extensions, GREASE, padding, and PSK binder logic. It does not contain any logic for evaluating the If-Match header field or taking any action based on that evaluation, as specified in the RFC spec context provided (e.g., the conditional behavior when ""*"" or a list of entity tags is received). There is no visible code addressing the RFC requirement nor any conditions or actions (like C1 or A1) from the provided spec constraints. Therefore, the function does not implement any part of the stated RFC requirement.",success,
8329,ssl_add_serverhello_tlsext,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The RFC requires that TLS 1.3 servers must not act upon the status_request_v2 extension in certain messages, specifically not sending it in EncryptedExtensions, CertificateRequest, or Certificate messages. In the provided function, there is a loop that adds all received extensions without any filtering logic to omit the status_request_v2 extension for TLS 1.3. The only TLS 1.3-specific logic (discarding empty extensions blocks) does not address the requirement to ignore or not send the status_request_v2 extension. Therefore, this function does not visibly implement any of the conditions or actions specified in the RFC constraints.",success,
8329,ssl_add_serverhello_tlsext,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The RFC specification requires that the OpenPGP certificate type MUST NOT be used with TLS 1.3. In the code provided, no logic is present that checks the certificate type or its incompatibility with TLS 1.3. The function only iterates over server hello extensions and discards empty ones for TLS versions earlier than TLS 1.3. There is no conditional or handling that enforces the restriction outlined in the RFC specification. Therefore, the function does not visibly address the specific requirement.",success,
8329,ssl_add_serverhello_tlsext,"In particular, it MUST NOT negotiate TLS 1.3.",14,Does Not Match,[],"The RFC specification requires that the implementation must not negotiate TLS 1.3. In the provided function, there is no code that actively prevents TLS 1.3 from being negotiated. The only version-related check is a condition that discards empty extension blocks for protocol versions less than TLS1_3_VERSION. This check does not constitute any logic that prohibits TLS 1.3. Since the function itself does not implement any code to enforce the TLS 1.3 prohibition, it does not address the specified RFC constraint.",success,
8330,ssl_scan_clienthello_tlsext,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function processes client hello extensions generically by iterating over all received extensions and invoking a parse callback for each. There is no specific logic within the function to ignore or avoid acting upon the status_request_v2 extension as required by the RFC for TLS 1.3 servers. Thus, none of the spec constraints (such as not sending the status_request_v2 extension) are visibly implemented in this function.",success,
8330,ssl_scan_clienthello_tlsext,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function scans and processes TLS extensions from the ClientHello message but does not include any logic that explicitly checks for or disallows the use of the Truncated HMAC extension as mandated by the RFC specification. There is no code that inspects for a truncated HMAC extension type (or any related rejection logic) within the function_body. Therefore, the function does not visibly address the RFC requirement to not use the Truncated HMAC extension.",success,
8330,ssl_scan_clienthello_tlsext,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16(&extensions, &type) ||\n        !CBS_get_u16_length_prefixed(&extensions, &extension)) {\n      *out_alert = SSL_AD_DECODE_ERROR;\n      return false;\n    }', 'explanation': 'This code checks that the message is parsed correctly (e.g., that the remaining bytes are sufficient for the u16 value and the length‐prefixed data). If not, it sets the decode error alert, directly implementing the condition that a syntactically invalid message (e.g., one with lengths beyond the boundary) must cause a decode error.'}}, {'A1': {'code': '*out_alert = SSL_AD_DECODE_ERROR;\nreturn false;', 'explanation': 'By setting the out_alert to decode_error and returning false, the function effectively terminates processing, which corresponds to terminating the connection as required by the specification when a malformed message is detected.'}}]","The function 'ssl_scan_clienthello_tlsext' processes TLS ClientHello extensions and explicitly checks for parsing errors such as length overflows or improperly formatted data. When such an error is detected, it sets the alert to SSL_AD_DECODE_ERROR and returns false, thereby enforcing the behavior described in the RFC specification (i.e., terminating the connection with a decode_error alert). The implementation in this function fully handles these constraints in its own logic without relying on external dependencies.",success,
8330,ssl_scan_clienthello_tlsext,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'A1': {'code': 'if (!CBS_get_u16(&extensions, &type) ||\n    !CBS_get_u16_length_prefixed(&extensions, &extension)) {\n  *out_alert = SSL_AD_DECODE_ERROR;\n  return false;\n}', 'explanation': ""This code segment checks for errors in decoding extension fields. If the decoding fails, it sets the alert to SSL_AD_DECODE_ERROR and aborts the handshake, which directly implements the requirement that the handshake MUST be aborted with a 'decode_error' alert when decoding does not succeed.""}}]","The provided function explicitly checks for decoding errors when processing client hello extensions. Upon failure to decode an extension, the function sets the 'out_alert' to SSL_AD_DECODE_ERROR and returns false, thereby aborting the handshake. This directly fulfills the specified RFC requirement that mandates aborting the handshake with a 'decode_error' alert if decoding fails.",success,
8330,ssl_scan_clienthello_tlsext,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function, ssl_scan_clienthello_tlsext, is solely responsible for parsing and processing TLS client hello extensions and does not contain any logic to enforce or check the specific RFC behavior regarding acting on 'supported_groups' data before handshake completion, nor does it address HTTP header (If-Unmodified-Since) evaluation. Therefore, none of the labeled conditions (such as C1) or actions (such as A1) as described in the spec constraints are visibly implemented within this function.",success,
8330,ssl_scan_clienthello_tlsext,-TLS 1.2 ClientHellos MAY omit this extension.,99,Does Not Match,[],"The provided code function is responsible for scanning and processing TLS ClientHello extensions. The RFC specification under review states that “TLS 1.2 ClientHellos MAY omit this extension,” which is not explicitly addressed within this function since it does not contain any logic specifically intended to enforce or account for the omission of a particular extension described in the spec. In addition, the additional context regarding the If-Match header evaluation and conditional responses (412 vs 2xx) is related to HTTP header processing and is not implemented in this TLS ClientHello scanning logic. As a result, no section of the function’s code directly corresponds to any labeled spec constraints or actions.",success,
8331,ssl_parse_clienthello_tlsext,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!ssl_scan_clienthello_tlsext(hs, client_hello, &alert)) {', 'explanation': 'This conditional checks for parsing errors in the client hello extensions, fulfilling the condition where a message cannot be parsed.'}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, alert);', 'explanation': ""On detecting a parsing error, this line sends the 'decode_error' alert and terminates the connection, directly implementing the required action.""}}]","The function first attempts to parse the client hello's TLS extensions. If parsing fails (indicating a violation of the syntax as described in the RFC), it sends a fatal alert with a decode_error alert code and then terminates processing by returning false. This directly corresponds to the RFC requirement to terminate the connection with a 'decode_error' alert when a message cannot be parsed.",success,
8331,ssl_parse_clienthello_tlsext,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function does not contain any visible logic that addresses the TLS 1.3 requirement that servers must NOT act upon or send the status_request_v2 extension. The function only calls ssl_scan_clienthello_tlsext and ssl_check_clienthello_tlsext and does not include any code segments that check for or prevent the processing or sending of the status_request_v2 extension in any TLS 1.3 messages. Hence, no labeled condition (such as C1) or action (such as A1) from the spec constraints is directly implemented in this function.",success,
8331,ssl_parse_clienthello_tlsext,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'C1': {'code': 'if (!ssl_scan_clienthello_tlsext(hs, client_hello, &alert)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n    return false;\n}', 'explanation': ""This branch checks for a failure (i.e. TLSEXT parsing error) and, if encountered, aborts the handshake by sending an alert with the value SSL_AD_DECODE_ERROR. This directly implements the spec requirement that on error the handshake MUST be aborted with a 'decode_error' alert.""}}]","The provided function implements part of the specification by checking a condition (via ssl_scan_clienthello_tlsext) and aborting the handshake with a decode_error alert when the condition fails. However, the full HTTP RFC context—including aspects like case-insensitive protocol matching and proper ordering of protocol names for Upgrade header fields—is not handled in this function. Therefore, while the relevant abort-on-error mechanism is correctly implemented (meeting condition C1), other aspects of the broader spec are not addressed within the function itself, resulting in a partial match.",success,
8332,ssl_scan_serverhello_tlsext,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification requires that implementations must not use the Truncated HMAC extension. However, the provided function only scans, validates, and parses TLS extensions in a generic manner without any explicit handling to reject or check for the Truncated HMAC extension. There is no code segment that explicitly prevents or disallows the use of the Truncated HMAC extension. Therefore, within the function_body, there is no visible logic that addresses the specific specification requirement.",success,
8332,ssl_scan_serverhello_tlsext,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16(&extensions, &type) ||\n        !CBS_get_u16_length_prefixed(&extensions, &extension)) {\n      *out_alert = SSL_AD_DECODE_ERROR;\n      return false;\n    }', 'explanation': ""This segment checks that the next extension is correctly parsed. If parsing fails—whether due to an incorrect length or an overrun—the function immediately sets the out_alert to SSL_AD_DECODE_ERROR and returns false, in line with the RFC's requirement to terminate the connection on a decode error.""}}, {'A1': {'code': '*out_alert = SSL_AD_DECODE_ERROR;', 'explanation': ""Throughout the function, any failure in parsing (including duplicate extensions or errors returned by individual extension parsers) results in setting the out_alert to SSL_AD_DECODE_ERROR. This ensures that the connection is terminated with the required 'decode_error' alert upon detecting a malformed message.""}}]","The function 'ssl_scan_serverhello_tlsext' implements robustness by inspecting the TLS extensions for correct formatting. In cases where the message cannot be properly parsed (for example, an improperly prefixed length or a duplicate extension), the function sets the 'out_alert' variable to SSL_AD_DECODE_ERROR and returns false. This direct handling of parse errors corresponds with the RFC specification, which mandates that peers receiving unparseable messages must terminate the connection with a decode_error alert. Therefore, the function fully meets the specified conditions and actions solely through its internal logic.",success,
8332,ssl_scan_serverhello_tlsext,There MUST NOT be more than one extension of the same type in a given extension block.,63,Fully Matches,"[{'C1': {'code': 'if (!tls1_check_duplicate_extensions(&extensions)) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n}', 'explanation': 'This code segment directly checks for duplicate extensions using tls1_check_duplicate_extensions. If duplicates are found, it triggers an error, which implements the RFC requirement that there must not be more than one extension of the same type in an extension block.'}}]","The function begins by invoking tls1_check_duplicate_extensions to verify that no duplicates exist in the provided extension block, and if duplicates are detected, it returns an error. This directly enforces the specified RFC condition, fulfilling the constraint within the function's own code.",success,
8332,ssl_scan_serverhello_tlsext,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The provided code function (ssl_scan_serverhello_tlsext) is designed to process extensions in a ServerHello message. The RFC spec requires that in a ClientHello the ""pre_shared_key"" extension must be the last extension, while allowing any order in a ServerHello. Since the function is processing ServerHello and does not enforce any ordering (nor does it check for the special case for pre_shared_key in a ClientHello), it does not address the RFC condition regarding the ordering of extensions in a ClientHello. Furthermore, the additional HTTP HEAD method context is not applicable here. Therefore, no logic within this function fully implements either of the specified constraints (neither ordering in ClientHello nor HTTP HEAD handling), and the outcome is 'Does Not Match'.",success,
8332,ssl_scan_serverhello_tlsext,"Upon receiving such an extension, an endpoint MUST abort the handshake with an ""unsupported_extension"" alert.",60,Fully Matches,"[{'C1': {'code': 'if (ext == NULL) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_EXTENSION);\n      ERR_add_error_dataf(""extension %u"", (unsigned)type);\n      *out_alert = SSL_AD_UNSUPPORTED_EXTENSION;\n      return false;\n    }', 'explanation': 'This segment checks if the extension is unknown (i.e. not found in the list of expected extensions) and aborts the handshake by setting the alert to SSL_AD_UNSUPPORTED_EXTENSION, in accordance with the requirement to abort on receiving such an extension.'}}, {'C2': {'code': 'if (!(hs->extensions.sent & (1u << ext_index))) {\n      // If the extension was never sent then it is illegal.\n      OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_EXTENSION);\n      ERR_add_error_dataf(""extension %u"", (unsigned)type);\n      *out_alert = SSL_AD_UNSUPPORTED_EXTENSION;\n      return false;\n    }', 'explanation': ""This segment verifies whether the received extension was expected (i.e., whether it was sent previously). If not, it aborts the handshake by setting the unsupported extension alert, thereby meeting the RFC's mandate.""}}]","The function 'ssl_scan_serverhello_tlsext' iterates through TLS extensions in the ServerHello message and checks for unexpected or unsupported extensions. In both cases—when an extension is unknown or when an extension was not sent by the client—the function sets the out_alert to SSL_AD_UNSUPPORTED_EXTENSION and returns false, effectively aborting the handshake. This behavior directly implements the specified RFC requirement to abort the handshake with an 'unsupported_extension' alert when such an extension is encountered.",success,
8332,ssl_scan_serverhello_tlsext,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest.",59,Partially Matches,"[{'C1': {'code': 'if (!(hs->extensions.sent & (1u << ext_index))) {\n      // If the extension was never sent then it is illegal.\n      OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_EXTENSION);\n      ERR_add_error_dataf(""extension %u"", (unsigned)type);\n      *out_alert = SSL_AD_UNSUPPORTED_EXTENSION;\n      return false;\n}', 'explanation': 'This code block checks that the received extension was previously sent (requested) by verifying the bit in hs->extensions.sent. If not, it triggers an error. This directly addresses the requirement to not accept extension responses when the corresponding extension request was not sent.'}}]","The function implements a check (labeled here as C1) to ensure that an extension response is only processed if it was expected (i.e., the corresponding extension was sent), which aligns with the main part of the RFC constraint. However, it does not explicitly implement the exception for the 'cookie' extension in the HelloRetryRequest. As a result, while some of the constraint is handled, the exception is not covered within this function, leading to a 'Partially Matches' outcome.",success,
8334,ssl_check_serverhello_tlsext,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (ssl->s3->alpn_selected.empty()) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_NEGOTIATED_ALPS_WITHOUT_ALPN);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n      return false;\n    }', 'explanation': 'When a new session includes application settings (ALPS), ALPN must have been negotiated. This check ensures that if ALPN is missing, the function terminates the connection by sending an illegal_parameter alert.'}}, {'C2': {'code': 'if (!ssl_get_local_application_settings(hs, &settings, ssl->s3->alpn_selected)) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_INVALID_ALPN_PROTOCOL);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n      return false;\n    }', 'explanation': 'This branch verifies that the negotiated protocol is one of those advertised for ALPS. If not, it sends an illegal_parameter alert and terminates the handshake, in accordance with the RFC requirement for handling semantically invalid messages.'}}]","The RFC specifies that when a peer receives a semantically invalid message, it must terminate the connection with an illegal_parameter alert. The function 'ssl_check_serverhello_tlsext' directly inspects the ALPS/ALPN relationship. In cases where ALPN is not negotiated (C1) or the negotiated protocol does not match the set of allowed protocols (C2), it sends an alert using ssl_send_alert with SSL_AD_ILLEGAL_PARAMETER and returns false to abort the handshake. This behavior clearly implements the required action within the function, independent of external dependencies.",success,
8335,ssl_parse_serverhello_tlsext,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!ssl_scan_serverhello_tlsext(hs, cbs, &alert)) { ssl_send_alert(ssl, SSL3_AL_FATAL, alert); return false; }', 'explanation': 'This code branch checks if the incoming message cannot be parsed properly and if so, sends an alert with decode_error (SSL_AD_DECODE_ERROR) and terminates processing by returning false.'}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, alert);', 'explanation': 'This call sends a fatal alert (with the decode_error) which conforms to the requirement that on a parse error the connection must be terminated with a decode_error alert.'}}]","The RFC requires that if a message cannot be parsed (for example due to an out-of-range length or extension beyond the message boundary), the connection must be terminated by sending a 'decode_error' alert. In this function, the call to ssl_scan_serverhello_tlsext is used to parse the message, and if it fails, the ensuing branch sends an alert using ssl_send_alert with alert set to SSL_AD_DECODE_ERROR and returns false. This behavior directly implements the specified conditions and actions, and therefore the function fully matches the RFC constraint on handling parse errors.",success,
8335,ssl_parse_serverhello_tlsext,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'C1': {'code': 'if (!ssl_scan_serverhello_tlsext(hs, cbs, &alert)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n    return false;\n}', 'explanation': 'This code segment checks a condition (likely that the server hello TLS extensions have been correctly parsed) and, if the check fails, drives the handshake to abort by sending an alert which is set to decode_error.'}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, alert);', 'explanation': 'This call sends the alert when the condition in C1 is not met, fulfilling the RFC requirement to abort the handshake with a decode_error alert.'}}]","The function directly handles one part of the RFC specification by verifying a condition via ssl_scan_serverhello_tlsext and then calling ssl_send_alert with a decode_error alert if that check fails. This implementation covers the scenario required by the spec ('if not, then it MUST abort the handshake with a ""decode_error"" alert') in the first branch. However, it does not handle all error cases (for example, the failure of ssl_check_serverhello_tlsext only returns false without sending an alert), so only some of the labeled conditions/actions are fully addressed within this function.",success,
8339,ssl_decrypt_ticket_with_method,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function ssl_decrypt_ticket_with_method does not include any logic that checks for or prevents the use of the Truncated HMAC extension from RFC6066. There is no conditional code, flag, or parameter that addresses the specification constraint regarding disallowing the Truncated HMAC extension. As a result, the function does not visibly address the condition specified in the RFC, and the relevant constraints (e.g., C1, A1 if they existed for this spec) are not implemented within this function.",success,
8340,ssl_process_ticket,"Any unknown PSKs (e.g., ones not in the PSK database or encrypted with an unknown key) SHOULD simply be ignored.",162,Fully Matches,"[{'C1': {'code': 'else if (is_psk && hints && !hs->hints_requested && hints->ignore_psk) {\n    result = ssl_ticket_aead_ignore_ticket;\n}', 'explanation': 'The RFC specifies that any unknown PSKs should simply be ignored. In this code segment, when the connection uses TLS 1.3 (thus employing PSKs) and the hint indicates that the PSK is to be ignored (hints->ignore_psk is true), the function sets the result to ssl_ticket_aead_ignore_ticket. This behavior directly implements the requirement by effectively ignoring unknown PSKs.'}}]","The function 'ssl_process_ticket' checks if the protocol in use is TLS 1.3—which ties tickets to PSKs—and then specifically examines the hints structure for PSK-related flags. In the branch that handles PSKs, if the hints indicate 'ignore_psk', the function sets its return value to ssl_ticket_aead_ignore_ticket, which meets the RFC requirement of simply ignoring unknown PSKs. All of the logic to address this condition is contained within the function and does not rely on external dependencies, thus fully matching the spec constraint.",success,
8341,tls1_parse_peer_sigalgs,-TLS 1.2 ClientHellos MAY omit this extension.,99,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(hs->ssl) < TLS1_2_VERSION) {\n    return true;\n}', 'explanation': 'This check allows TLS versions below 1.2 to ignore the signature algorithms extension, which is in line with the spec requirement that TLS 1.2 ClientHellos MAY omit this extension. It ensures that if the extension is omitted in appropriate contexts, the function succeeds.'}}, {'A1': {'code': 'return CBS_len(in_sigalgs) != 0 &&\n       parse_u16_array(in_sigalgs, &hs->peer_sigalgs);', 'explanation': 'For TLS 1.2 connections, if the extension is present, this code enforces that the signature algorithms list is non-empty and correctly parsed, fulfilling the requirement that when provided, the extension must contain valid data.'}}]","The function first checks whether the current protocol version is less than TLS 1.2, in which case it ignores the extension by immediately returning true. This behavior supports the spec allowance for TLS 1.2 ClientHellos to omit the extension. When the protocol is TLS 1.2, the function requires that the incoming signature algorithms extension is non-empty and successfully parsed, thereby correctly implementing the RFC's specification. Although the specification context provided about the If-Match header field is unrelated, within the scope of TLS1.2 extension handling the function fully meets the corresponding conditions and actions.",success,
8343,tls1_choose_signature_algorithm,"-The server's end-entity certificate's public key (and associated restrictions) MUST be compatible with the selected authentication algorithm from the client's ""signature_algorithms"" extension (currently RSA, ECDSA, or EdDSA).",205,Fully Matches,"[{'C1': {'code': 'if (!ssl_pkey_supports_algorithm(ssl, cred->pubkey.get(), sigalg, /*is_verify=*/false)) {\n      continue;\n    }\n\n    if (std::find(peer_sigalgs.begin(), peer_sigalgs.end(), sigalg) != peer_sigalgs.end()) {\n      *out = sigalg;\n      return true;\n    }', 'explanation': ""This code segment iterates through the candidate signature algorithms (derived either from the credential or a default set) and uses the function ssl_pkey_supports_algorithm to ensure that the server's certificate public key is compatible with the chosen algorithm. It then checks that this algorithm is among those specified by the client’s signature_algorithms extension. This directly implements the requirement stated in the RFC specification.""}}]",The tls1_choose_signature_algorithm function selects a signature algorithm by ensuring that the server's certificate public key supports the candidate algorithm and that the algorithm is present in the client's offered signature_algorithms. These steps fully address the specification that mandates compatibility between the certificate’s public key and the client's selected authentication algorithm.,success,
8343,tls1_choose_signature_algorithm,TLS 1.3 implementations willing to negotiate TLS 1.2 MUST behave in accordance with the requirements of [RFC5246] when negotiating that version.,98,Does Not Match,[],"The provided function 'tls1_choose_signature_algorithm' is concerned solely with selecting an appropriate signature algorithm for a TLS handshake, primarily handling legacy behavior and negotiating TLS 1.2 signature algorithms. It does not incorporate any logic addressing the HTTP specification context (i.e., If-Match header evaluation) or any requirements stemming from the TLS 1.3 negotiation requirements as specified in RFC5246. No part of the function implements any labeled conditions (C1, C2, etc.) or actions (A1, A2, etc.) related to the HTTP RFC or the If-Match processing rules described in the spec.",success,
8343,tls1_choose_signature_algorithm,-TLS 1.2 ClientHellos MAY omit this extension.,99,Fully Matches,"[{'C1': {'code': ""if (peer_sigalgs.empty() && version == TLS1_2_VERSION) {\n      // If the client didn't specify any signature_algorithms extension, it is\n      // interpreted as SHA-1. See http://tools.ietf.org/html/rfc5246#section-7.4.1.4.1\n      static const uint16_t kTLS12Default[] = {SSL_SIGN_RSA_PKCS1_SHA1,\n                                               SSL_SIGN_ECDSA_SHA1};\n      peer_sigalgs = kTLS12Default;\n    }"", 'explanation': ""This code implements the default behavior for TLS 1.2 when the ClientHello omits the signature_algorithms extension, directly addressing the RFC's allowance that ClientHellos may omit this extension.""}}]","The function tls1_choose_signature_algorithm handles both legacy and TLS 1.2 scenarios. Specifically, when running TLS 1.2 and the client's signature_algorithms extension is omitted (peer_sigalgs is empty), it defaults to SHA-1 algorithms as per RFC5246. This behavior fully matches the spec constraint labeled C1 ('TLS 1.2 ClientHellos MAY omit this extension') solely within this function's logic.",success,
8343,tls1_choose_signature_algorithm,"If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client's ""signature_algorithms"" extension unless no valid certificate chain can be produced without unsupported algorithms (see Section 4.2.3).",225,Partially Matches,"[{'C1': {'code': 'if (std::find(peer_sigalgs.begin(), peer_sigalgs.end(), sigalg) != peer_sigalgs.end()) {\n      *out = sigalg;\n      return true;\n    }', 'explanation': 'This segment ensures that the selected signature algorithm is one of those offered by the client in its signature_algorithms extension, which is the core requirement of the spec.'}}, {'A1': {'code': ""if (peer_sigalgs.empty() && version == TLS1_2_VERSION) {\n      // If the client didn't specify any signature_algorithms extension, it is\n      // interpreted as SHA-1. See http://tools.ietf.org/html/rfc5246#section-7.4.1.4.1\n      static const uint16_t kTLS12Default[] = {SSL_SIGN_RSA_PKCS1_SHA1,\n                                               SSL_SIGN_ECDSA_SHA1};\n      peer_sigalgs = kTLS12Default;\n    }"", 'explanation': 'This block assigns a default set of signature algorithms (SHA-1 based) when the client does not provide a signature_algorithms extension, following RFC5246. It addresses part of the client behavior expected by the spec.'}}]","The function examines the client's offered signature algorithms (or applies a default set when none are provided) and then only selects a signature algorithm if it is among those offered, which matches the spec's requirement that the server must use an algorithm the client offered. However, the spec also allows for the exception “unless no valid certificate chain can be produced without unsupported algorithms”, and this function does not implement any fallback logic for that case. Therefore, while it enforces the core check against the client's list, it does not account for the exception scenario, leading to a partial match.",success,
8344,tls1_verify_channel_id,"These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2.",86,Does Not Match,[],"The provided function, tls1_verify_channel_id, is concerned with verifying a TLS Channel ID extension during a handshake—extracting the extension, decoding its components, computing a digest, and verifying the ECDSA signature. However, the RFC specification provided relates to certificate signature values (which are not used for signed TLS handshake messages) and includes guidance on From header usage in HTTP requests. None of these labeled conditions or actions (e.g., C1, A1) appear within the function’s logic. The function does not attempt to implement any of the constraints set forth by the RFC (such as handling certificate signature values or validating a From header field). Consequently, no part of the function visibly addresses the specified RFC constraints.",success,
8344,tls1_verify_channel_id,"If the verification fails, the receiver MUST terminate the handshake with a ""decrypt_error"" alert.",231,Fully Matches,"[{'A1': {'code': 'if (!sig_ok) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_CHANNEL_ID_SIGNATURE_INVALID);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECRYPT_ERROR);\n    return false;\n}', 'explanation': 'This code segment checks the signature verification result (the \'verification\' step) and if it fails, it sends a \'decrypt_error\' alert (using SSL_AD_DECRYPT_ERROR) before terminating the handshake. This directly implements the spec requirement: \'If the verification fails, the receiver MUST terminate the handshake with a ""decrypt_error"" alert.\''}}]","The function clearly contains logic to verify the Channel ID by checking the structure of the received message, performing signature verification, and, crucially, sending the required 'decrypt_error' alert via ssl_send_alert when signature verification fails. This matches the spec, and since the logic to terminate the handshake on verification failure is implemented directly within the function, the provided code function fully meets the relevant constraint.",success,
8344,tls1_verify_channel_id,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16(&channel_id, &extension_type) ||\n      !CBS_get_u16_length_prefixed(&channel_id, &extension) ||\n      CBS_len(&channel_id) != 0 ||\n      extension_type != TLSEXT_TYPE_channel_id ||\n      CBS_len(&extension) != TLSEXT_CHANNEL_ID_SIZE) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    return false;\n}', 'explanation': 'This code segment checks for various parsing errors, such as incorrect message boundaries and unexpected extension types/lengths. On any error, it triggers a decode_error alert and terminates processing by returning false, thereby fulfilling the RFC requirement.'}}]","The function strictly validates the structure of a Channel ID handshake message. When any part of the message fails to meet the expected syntax—such as having extra bytes, an unexpected extension type, or an incorrect length—the function logs a decode error and triggers an alert to terminate the connection. This direct handling within the function matches the specified RFC constraint regarding parsing errors and connection termination with a 'decode_error' alert.",success,
8344,tls1_verify_channel_id,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided code function, tls1_verify_channel_id, is focused on verifying a Channel ID handshake message and its associated ECDSA signature. It does not include any logic that addresses cipher suite negotiation or restrictions, particularly the prohibition of offering or negotiating RC4 cipher suites as stated in the RFC specification. Thus, no part of the function implements any condition or action related to the RC4 cipher suites requirement.",success,
8344,tls1_verify_channel_id,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16(&channel_id, &extension_type) ||             \n      !CBS_get_u16_length_prefixed(&channel_id, &extension) ||  \n      CBS_len(&channel_id) != 0 ||                              \n      extension_type != TLSEXT_TYPE_channel_id ||               \n      CBS_len(&extension) != TLSEXT_CHANNEL_ID_SIZE) {', 'explanation': 'This segment validates that the Channel ID handshake message contains only one extension, that the extension type is exactly Channel ID, and that its length is exactly as expected. This corresponds to the condition required by the spec.'}}, {'A1': {'code': 'OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\nssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\nreturn false;', 'explanation': ""If the message does not meet the required structure, the function aborts the handshake by signaling a decode_error alert, thereby directly implementing the spec's mandated action.""}}]","The function tls1_verify_channel_id implements the RFC requirement by first checking that the message structure is exactly as specified (only one Channel ID extension with the correct type and length) and, if not, it aborts the handshake by sending a decode_error alert. This fulfills the spec constraints by handling the condition (C1) and performing the action (A1) entirely within the function.",success,
8350,SSL_early_callback_ctx_extension_get,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The function SSL_early_callback_ctx_extension_get simply extracts and returns extension data from a ClientHello message without any checks or logic to ignore or avoid using the status_request_v2 extension, as mandated by the spec. This function does not contain any conditional logic or actions addressing the TLS 1.3 requirement that servers must not act upon the status_request_v2 extension in any subsequent messages (e.g., EncryptedExtensions, CertificateRequest, or Certificate). Therefore, no constraints (e.g., C1, A1) are visibly implemented within this function.",success,
8350,SSL_early_callback_ctx_extension_get,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC requires that implementations must not use the Truncated HMAC extension, but the provided function does not contain any logic addressing this requirement. The function merely retrieves an extension from the client hello (by calling ssl_client_hello_get_extension and then setting out_data/out_len) without any check or enforcement related to Truncated HMAC. Thus, no part of the function's code matches any labeled condition or action related to the spec constraints.",success,
8350,SSL_early_callback_ctx_extension_get,-TLS 1.2 ClientHellos MAY omit this extension.,99,Does Not Match,[],"The provided function only retrieves an extension from a TLS ClientHello message by calling ssl_client_hello_get_extension and then returning either the data (if present) or 0 if absent. It does not include any logic that addresses the spec constraints stated (for example, managing the case when a TLS 1.2 ClientHello may omit the extension, or any logic regarding HTTP If-Match header field evaluation). No parts of the function handle conditions or actions corresponding to labeled constraints (C1, A1, etc.) solely within its own code body.",success,
8355,SSL_SESSION_dup,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function, SSL_SESSION_dup, is focused on duplicating an SSL session by copying numerous fields (including those related to early data, such as ticket_max_early_data, early_alpn, and quic_early_data_context) and then marking the new session as 'not_resumable'. However, there is no explicit logic within this function to decide against or prevent the automatic retransmission of early data as the RFC requires. The RFC specifies that a TLS implementation SHOULD NOT automatically resend early data, but this function does not include any conditional checks or controls regarding automatic retransmission; instead, it merely duplicates session contents. As such, the function does not visibly address the spec requirement within its own logic.",success,
8360,ssl_get_new_session,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The provided code function does not contain any logic that checks or restricts the use of values within the ""obsolete_RESERVED"" ranges, as specified. The function differentiates behavior based on the TLS version (e.g., for TLS 1.3 it sets ticket timeouts), but it does not perform any explicit validation or preventative measure to ensure that obsolete_RESERVED values are not offered or negotiated in TLS 1.3 implementations. Therefore, none of the spec constraints (e.g., C1, A1, etc.) related to this requirement are implemented within this function.",success,
8363,ssl_encrypt_ticket_with_method,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification requires that implementations must not use the Truncated HMAC extension. The provided function solely performs session ticket encryption using the ticket_aead_method without any logic that checks for or prevents the use of a truncated HMAC extension. There is no evidence within the function_body of any code addressing or enforcing that constraint. Therefore, this function does not visibly address the RFC requirement.",success,
8364,ssl_encrypt_ticket,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function does not include any logic that addresses the spec constraint regarding the prohibition of the Truncated HMAC extension (defined in Section 7 of RFC6066). The function merely serializes the session and delegates ticket encryption to another function (either ssl_encrypt_ticket_with_method or ssl_encrypt_ticket_with_cipher_ctx) without any explicit check or handling related to truncated HMAC. Therefore, in isolation, this function does not implement or enforce the specified condition.",success,
8367,ssl_session_is_time_valid,A server MAY treat a ticket as valid for a shorter period of time than what is stated in the ticket_lifetime.,248,Fully Matches,"[{'C1': {'code': 'if (now.tv_sec < session->time) {\n    return false;\n}\n\nreturn session->timeout > now.tv_sec - session->time;', 'explanation': ""The function verifies that the current time is not earlier than the time recorded in the ticket (preventing underflow) and then checks whether the elapsed time (now - session->time) is within the session's timeout. This mirrors the RFC allowance that a server MAY choose to validate a ticket for a period shorter than a given ticket_lifetime, by using the session->timeout as the effective shorter lifetime.""}}]","The code function implements the ticket validity check by comparing the elapsed time since the ticket creation with the session->timeout. It first ensures that tickets from the future are rejected, and then treats the ticket as valid only if this elapsed time is within the timeout limit. This logic visibly addresses the specification that a server may choose a shorter validity period than stated in the ticket_lifetime.",success,
8401,SSL_SESSION_get0_cipher,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function simply returns the cipher from an SSL session by accessing a struct field (session->cipher). There is no logic within this function that checks or enforces any conditions related to the OpenPGP certificate type not being used with TLS 1.3, nor does it address any Transfer-Encoding or HTTP/1.1 specific restrictions as described in the spec context. Therefore, none of the labeled conditions (e.g., C1) or actions (e.g., A1) for this specification are implemented in this function.",success,
8405,SSL_SESSION_early_data_capable,Note that 0-RTT data is not compatible with older servers and SHOULD NOT be sent absent knowledge that the server supports TLS 1.3,378,Fully Matches,"[{'C1': {'code': 'ssl_session_protocol_version(session) >= TLS1_3_VERSION', 'explanation': ""This code segment checks that the session's protocol version is TLS 1.3 or higher, ensuring that 0‑RTT data is only considered for sessions with a TLS version that supports it.""}}, {'A1': {'code': 'session->ticket_max_early_data != 0', 'explanation': ""This code verifies that the session's ticket permits early data (by having a non‐zero ticket_max_early_data), aligning with the requirement that 0‑RTT data should only be sent when explicitly allowed.""}}]",The function 'SSL_SESSION_early_data_capable' directly implements the specification's constraints by checking that the session is using TLS 1.3 (or higher) and that early data is allowed via the session ticket. Both required conditions from the RFC—ensuring TLS 1.3 support and the explicit ticket allowance for early data—are fully addressed within this function.,success,
8435,tls1_configure_aead,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification requires that implementations MUST NOT use the Truncated HMAC extension. However, in the function_body provided, there is no logic that checks for, prevents, or explicitly avoids using the Truncated HMAC extension. The code simply configures keys and sets up an AEAD context without any conditions or safeguards related to the truncated HMAC. Therefore, the function does not visibly address any condition corresponding to this RFC requirement.",success,
8436,tls1_change_cipher_state,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function only wraps a call to tls1_configure_aead and does not contain any logic addressing the RFC specification regarding the use of the Truncated HMAC extension. There is no check or disabling of the extension (or any logic related to it) present within the function's body. Thus, the function does not visibly implement the required spec constraint.",success,
8439,SSL_generate_key_block,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Does Not Match,[],"The provided function, SSL_generate_key_block, does not implement any logic related to ensuring the proper ordering of HKDF usage as required by the RFC specification. Specifically, the RFC states that one SHOULD NOT use an output of HKDF-Extract as an input to another HKDF-Extract without an intervening HKDF-Expand. There is no code in SSL_generate_key_block addressing this ordering requirement; the function simply checks for handshake conditions and forwards processing to generate_key_block. Without explicit logic in this function meeting any of the labeled conditions (e.g., C1) or actions (e.g., A1) related to the HKDF ordering, it does not visibly implement the spec constraints.",success,
8440,SSL_export_keying_material,Future specifications MUST NOT define a use of exporters that permit both an empty context and no context with the same label.,332,Does Not Match,[],"The RFC specification states that future specifications must not allow exporters to permit both an empty context and no context with the same label. In this function, if use_context is false, the context is forcibly set to NULL and context_len to 0, but if use_context is true and an empty context is provided (context_len == 0), the function uses an explicit empty context. This behavior effectively allows both an explicit empty context and a missing context with the same label, meaning the function does not enforce the restriction mandated by the RFC.",success,
8454,close_early_data,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification mandates that implementations MUST NOT use the Truncated HMAC extension. However, the provided function 'close_early_data' contains logic only for handling early data and encryption key state transitions (e.g., installing a null cipher, setting write states for handshake and initial encryption levels) and does not contain any checks or logic that relate to the use of a truncated HMAC extension. Therefore, the function does not visibly address any constraint (labeled here, for example, as C1 pertaining to the truncated HMAC extension) outlined in the RFC specification.",success,
8454,close_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'C1': {'code': 'hs->can_early_write = false;', 'explanation': ""The TLS specification requires that early data not be automatically resent. By explicitly setting 'hs->can_early_write' to false, the function ensures that the early data channel is closed, thereby preventing any automatic retransmission of early data. This directly meets the condition (C1) derived from the spec.""}}]","The 'close_early_data' function disables early data transmission by marking that early writing is no longer allowed (hs->can_early_write = false). This prevents the automatic resending of early data, aligning with the RFC requirement that implementations SHOULD NOT automatically resend early data, leaving retransmission decisions to the application. The function’s internal logic clearly reflects this requirement, addressing the labeled constraint fully within its own scope.",success,
8455,parse_server_hello_tls13,Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less.,395,Fully Matches,"[{'C1': {'code': 'if (out->legacy_version != expected_version ||  //\n      out->compression_method != 0 ||\n      Span<const uint8_t>(out->session_id) != expected_session_id ||\n      CBS_len(&out->extensions) == 0) {', 'explanation': ""This segment enforces that the ServerHello's legacy_version field is exactly equal to the expected version (TLS1_2_VERSION for TLS, which is greater than 0x0300), thereby preventing a legacy_version of 0x0300 or less as disallowed by the RFC.""}}]","The function 'parse_server_hello_tls13' explicitly checks that the legacy_version in ServerHello equals the expected version (TLS1_2_VERSION or DTLS1_2_VERSION). For TLS, TLS1_2_VERSION is typically 0x0303 which satisfies the RFC requirement by ensuring that a disallowed version (0x0300 or less) is not sent. This check is implemented directly in the function body, hence it fully meets the given RFC specification constraint.",success,
8455,parse_server_hello_tls13,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (out->legacy_version != expected_version ||  \n      out->compression_method != 0 ||\n      Span<const uint8_t>(out->session_id) != expected_session_id ||\n      CBS_len(&out->extensions) == 0) {', 'explanation': 'This conditional verifies that the parsed Server Hello adheres to the expected syntax—checking legacy version, compression method, session_id, and that there is at least one extension. These checks detect messages that cannot be correctly parsed according to the syntax requirements.'}}, {'A1': {'code': 'OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n*out_alert = SSL_AD_DECODE_ERROR;\nreturn false;', 'explanation': 'When the syntax checks fail, the function sets the decode_error alert and returns false, fulfilling the RFC mandate to terminate the connection upon detecting a message that cannot be parsed.'}}]","The function implements the RFC-specified behavior for handling parse errors. It explicitly checks for anomalies in the Server Hello message (using several criteria) and, if any are found, triggers an error by calling OPENSSL_PUT_ERROR, setting the output alert pointer to the decode_error value, and returning false. This clearly corresponds to the requirement that peers must terminate the connection with a 'decode_error' alert upon receiving an unparseable message.",success,
8455,parse_server_hello_tls13,"In TLS 1.3, the TLS server indicates its version using the ""supported_versions"" extension (Section 4.2.1), and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.",29,Partially Matches,"[{'C1': {'code': 'uint16_t expected_version = SSL_is_dtls(hs->ssl) ? DTLS1_2_VERSION : TLS1_2_VERSION;\n...\nif (out->legacy_version != expected_version ||  //\n      out->compression_method != 0 ||\n      Span<const uint8_t>(out->session_id) != expected_session_id ||\n      CBS_len(&out->extensions) == 0) {', 'explanation': 'This segment verifies that the legacy_version field is equal to the expected value. For TLS (non-DTLS), expected_version is set to TLS1_2_VERSION (0x0303), which satisfies the TLS 1.3 requirement that legacy_version MUST be 0x0303.'}}]","The function checks that the legacy_version field is set correctly (C1) by comparing it to TLS1_2_VERSION (0x0303) when TLS is used. This fulfills one aspect of the TLS 1.3 RFC specification regarding the legacy_version field. However, the RFC also requires that the TLS server indicate its version via the supported_versions extension. The function only ensures that there is at least one extension present (by checking that the extensions length is non-zero) without explicitly verifying the presence or content of the supported_versions extension. Thus, while part of the requirement is addressed, the function does not fully implement all aspects of the TLS 1.3 version signaling as specified in the RFC.",success,
8455,parse_server_hello_tls13,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (out->legacy_version != expected_version ||  \n      out->compression_method != 0 ||\n      Span<const uint8_t>(out->session_id) != expected_session_id ||\n      CBS_len(&out->extensions) == 0)', 'explanation': 'The function checks that the legacy_version matches the expected version, that the compression_method is 0, that session_id matches (or is empty in DTLS), and that there is at least one extension present. These represent the conditions that if not met, the handshake must be aborted.'}}, {'A1': {'code': 'OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n*out_alert = SSL_AD_DECODE_ERROR;\nreturn false;', 'explanation': 'When any of the conditions are false, the code aborts the handshake by triggering a decode error alert in accordance with the spec requirement.'}}]","The function implements the RFC requirement by verifying that all the required fields (legacy version, compression method, session_id, and extensions) are correctly set. If any condition fails, it aborts the handshake by setting a decode_error alert. All of this logic is contained within the function_body, so the spec constraint 'If not, then it MUST abort the handshake with a decode_error alert' is fully addressed.",success,
8455,parse_server_hello_tls13,"In TLS 1.3, the client indicates its version preferences in the ""supported_versions"" extension (Section 4.2.1) and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.",15,Partially Matches,"[{'C1': {'code': 'if (out->legacy_version != expected_version ||  \n      out->compression_method != 0 ||\n      Span<const uint8_t>(out->session_id) != expected_session_id ||\n      CBS_len(&out->extensions) == 0) {', 'explanation': ""This code verifies that the legacy_version field matches the expected_version (which is TLS1_2_VERSION, 0x0303, for non-DTLS connections). This corresponds to the RFC requirement that the legacy_version field MUST be set to 0x0303 in TLS 1.3. However, the function does not fully address the client’s indication of version preferences via the 'supported_versions' extension.""}}]","The provided function checks that the legacy_version field equals the expected TLS version (0x0303 for non-DTLS connections), thereby implementing part of the TLS 1.3 RFC requirement regarding the legacy_version. Nevertheless, while it ensures that some related fields (like compression_method and session_id) are properly set, it does not explicitly parse or handle the client's 'supported_versions' extension as described by the RFC. Thus, the function partially matches the RFC specification related to version handling.",success,
8457,check_ech_confirmation,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'A1': {'code': 'if (CBS_len(&ech.data) != ECH_CONFIRMATION_SIGNAL_LEN) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n      *out_alert = SSL_AD_DECODE_ERROR;\n      return false;\n    }', 'explanation': ""The RFC requires that peers, upon receiving a message that cannot be parsed correctly, terminate the connection with a 'decode_error' alert. In this code segment, when the length of 'ech.data' does not match the expected ECH_CONFIRMATION_SIGNAL_LEN, the function sets the alert to SSL_AD_DECODE_ERROR and returns false. This indicates a parse error in the message and signals the caller to terminate the connection, thereby addressing the RFC’s mandate for a decode error on malformed messages.""}}]","The function 'check_ech_confirmation' contains logic to check for a correctly formatted ECH extension. Specifically, it validates that the length of the ECH confirmation signal matches the expected constant. If the length check fails, it triggers a decode error by setting the appropriate alert and returning false, which is aligned with the specification requirement that a malformed message (e.g., due to an incorrect length) must result in a 'decode_error' alert. However, while this function handles this particular parse error condition, other responsibilities such as the complete termination of the connection upon alerting may be handled in other parts of the system. Thus, only some aspects of the RFC requirement are addressed in this function alone.",success,
8459,do_read_hello_retry_request,Note that 0-RTT data is not compatible with older servers and SHOULD NOT be sent absent knowledge that the server supports TLS 1.3,378,Fully Matches,"[{'C1': {'code': 'if (hs->in_early_data) {\n    ssl->s3->early_data_reason = ssl_early_data_hello_retry_request;\n    if (!close_early_data(hs, ssl_encryption_initial)) {\n      return ssl_hs_error;\n    }\n    return ssl_hs_early_data_rejected;\n  }', 'explanation': 'This code segment checks if early (0-RTT) data was in use and, upon receiving a HelloRetryRequest, rejects it by closing early data. This directly implements the RFC specification’s requirement that 0-RTT data SHOULD NOT be sent without confirmation of TLS 1.3 support.'}}, {'A1': {'code': 'if (hs->in_early_data) {\n    ssl->s3->early_data_reason = ssl_early_data_hello_retry_request;\n    if (!close_early_data(hs, ssl_encryption_initial)) {\n      return ssl_hs_error;\n    }\n    return ssl_hs_early_data_rejected;\n  }', 'explanation': 'This action actively terminates early data when a HelloRetryRequest response is encountered, fulfilling the requirement to not use 0-RTT data in the absence of explicit TLS 1.3 support.'}}]","The function 'do_read_hello_retry_request' contains explicit logic to detect if early data (0-RTT) was offered (via hs->in_early_data) and then rejects it if a HelloRetryRequest is received. This behavior satisfies the RFC rule that 0-RTT data should not be sent without confirmed support for TLS 1.3, thereby fully matching the spec's requirements.",success,
8459,do_read_hello_retry_request,"To avoid a downgrade attack, the client SHOULD NOT disable TLS 1.3, only 0-RTT.",385,Fully Matches,"[{'C1': {'code': 'hs->tls13_state = state_send_second_client_hello;', 'explanation': 'The function continues the TLS 1.3 handshake (by setting the state to send the second ClientHello) rather than disabling TLS 1.3. This meets the requirement that the client SHOULD NOT disable TLS 1.3.'}}, {'A1': {'code': 'if (hs->in_early_data) {\n    ssl->s3->early_data_reason = ssl_early_data_hello_retry_request;\n    if (!close_early_data(hs, ssl_encryption_initial)) {\n      return ssl_hs_error;\n    }\n    return ssl_hs_early_data_rejected;\n  }', 'explanation': 'This segment explicitly checks if early data (0-RTT) is in use and, if so, disables it (rejects early data) without aborting the TLS 1.3 handshake. This directly implements the spec action to disable only 0-RTT to avoid a downgrade attack.'}}]","The provided function clearly implements the specified RFC constraint. It preserves TLS 1.3 by continuing the handshake process while rejecting 0-RTT (early data) when a HelloRetryRequest is received. Both the decision to continue in TLS 1.3 (C1) and the action of disabling 0-RTT (A1) are handled within this function, ensuring that the client does not inadvertently disable TLS 1.3 as mandated by the RFC.",success,
8459,do_read_hello_retry_request,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Partially Matches,"[{'C1': {'code': 'if (cipher == nullptr ||\n      SSL_CIPHER_get_min_version(cipher) > ssl_protocol_version(ssl) ||\n      SSL_CIPHER_get_max_version(cipher) < ssl_protocol_version(ssl) ||\n      !ssl_tls13_cipher_meets_policy(SSL_CIPHER_get_protocol_id(cipher), ssl->config->compliance_policy)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CIPHER_RETURNED);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n  }', 'explanation': 'This code segment validates that the cipher chosen in the ServerHello meets the protocol version requirements and a policy defined by ssl->config->compliance_policy through ssl_tls13_cipher_meets_policy. Although it does not explicitly mention RC4, the compliance policy is expected to enforce the prohibition against negotiating RC4. Thus, the function indirectly applies the RFC requirement.'}}]","The RFC requires that implementations must not offer or negotiate RC4 cipher suites for any version of TLS. In this function, while there is no explicit reference to RC4, the cipher suite obtained from the ServerHello is checked against a compliance policy via the call to ssl_tls13_cipher_meets_policy. This compliance check is assumed to include a check against RC4. However, since the logic for rejecting RC4 is encapsulated in the compliance policy function (and not fully visible within this function), the function only partially demonstrates adherence to the RFC constraint.",success,
8459,do_read_hello_retry_request,Application protocols MUST NOT use 0-RTT data without a profile that defines its use.,406,Fully Matches,"[{'A1': {'code': 'if (hs->in_early_data) {\n    ssl->s3->early_data_reason = ssl_early_data_hello_retry_request;\n    if (!close_early_data(hs, ssl_encryption_initial)) {\n      return ssl_hs_error;\n    }\n    return ssl_hs_early_data_rejected;\n}', 'explanation': 'This code segment explicitly checks if early (0-RTT) data was used (hs->in_early_data) and then forces its rejection by closing early data and returning an appropriate error. This behavior implements the requirement that application protocols must not use 0‐RTT data (i.e. early data) unless an appropriate profile is in place.'}}]","The RFC specification requires that 0-RTT (early data) not be used without a profile defining its use. In this function, the relevant logic is contained in the block that checks hs->in_early_data. When early data is detected in a HelloRetryRequest context, the function sets an 'early_data_reason', calls close_early_data, and then returns an early data rejection status. This direct handling of early data in the context of a HelloRetryRequest demonstrates that the function itself is enforcing the constraint, thus fully matching the specification.",success,
8459,do_read_hello_retry_request,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Partially Matches,"[{'A1': {'code': 'if (hs->in_early_data) {\n    ssl->s3->early_data_reason = ssl_early_data_hello_retry_request;\n    if (!close_early_data(hs, ssl_encryption_initial)) {\n      return ssl_hs_error;\n    }\n    return ssl_hs_early_data_rejected;\n  }', 'explanation': 'This segment explicitly detects if early (0-RTT) data is in use and, upon receiving a HelloRetryRequest, it closes early data and signals that early data has been rejected. This addresses the specification requirement that TLS implementations MUST NOT automatically resend 0-RTT data if it is rejected by the server.'}}]","The function partially implements the RFC requirement by handling the scenario where a HelloRetryRequest is received during early (0-RTT) data usage; it does so by rejecting the early data instead of automatically resending it. However, the RFC also mandates that TLS implementations must not enable 0-RTT unless it is specifically requested by the application. This function does not contain logic to verify or enforce that early data was explicitly requested by the application. As such, only part of the spec constraint is addressed within this function.",success,
8459,do_read_hello_retry_request,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'uint8_t alert = SSL_AD_DECODE_ERROR;\nif (!parse_server_hello_tls13(hs, &server_hello, &alert, msg)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n    return ssl_hs_error;\n}', 'explanation': 'This code sets a default decode_error alert and immediately sends it if the parsing of the ServerHello fails, addressing the condition that a message failing syntax checks should be considered an error.'}}, {'A1': {'code': 'if (!CBS_get_u16_length_prefixed(&cookie.data, &cookie_value) ||\n    CBS_len(&cookie_value) == 0 ||\n    CBS_len(&cookie.data) != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    return ssl_hs_error;\n}', 'explanation': 'This segment verifies the length of a field (the cookie) and, upon detecting an out-of-range or malformed length, sends a decode_error alert and terminates the handshake, fully implementing the specified action.'}}]","The function directly addresses the RFC requirement: if a received message cannot be parsed (due to length issues or other syntax errors), it sends a decode_error alert and terminates the connection. Both the initial overall parsing check (using parse_server_hello_tls13) and subsequent detailed checks (e.g., for the cookie extension) are implemented within this function, fulfilling the spec's mandates.",success,
8459,do_read_hello_retry_request,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'A1': {'code': 'if (cipher == nullptr ||\n      SSL_CIPHER_get_min_version(cipher) > ssl_protocol_version(ssl) ||\n      SSL_CIPHER_get_max_version(cipher) < ssl_protocol_version(ssl) ||\n      !ssl_tls13_cipher_meets_policy(SSL_CIPHER_get_protocol_id(cipher),\n                                     ssl->config->compliance_policy)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CIPHER_RETURNED);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n}', 'explanation': ""This segment checks that the cipher suite provided in the ServerHello is acceptable. If not, it immediately terminates the handshake by sending an alert of type 'illegal_parameter', meeting the spec requirement that semantically invalid messages cause termination with an 'illegal_parameter' alert.""}}, {'A2': {'code': 'if (hs->key_shares[0]->GroupID() == group_id ||\n    (hs->key_shares[1] && hs->key_shares[1]->GroupID() == group_id)) {\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n  OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CURVE);\n  return ssl_hs_error;\n}', 'explanation': ""This block verifies that the key share requested by the server hasn’t been already provided in the initial ClientHello. A duplicate key share is considered semantically invalid; consequently, the function terminates the connection by sending an 'illegal_parameter' alert, as mandated by the spec.""}}]","The provided function implements checks on the received ServerHello message and explicitly terminates the connection with an 'illegal_parameter' alert when it detects semantically invalid parameters (such as an unacceptable cipher suite or an invalid key share request). These measures directly address the core requirement from the spec that peers receiving a syntactically correct but semantically invalid message must terminate with an 'illegal_parameter' alert. While additional error paths (e.g. sending a decode error for other issues) exist, the function visibly includes logic for the specific action the RFC mandates, thus fully matching the constraint within its own code.",success,
8459,do_read_hello_retry_request,"Otherwise, the client MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello.",51,Fully Matches,"[{'C1': {'code': 'SSLExtension cookie(TLSEXT_TYPE_cookie, ...);\nSSLExtension key_share(TLSEXT_TYPE_key_share, !hs->key_share_bytes.empty());\nSSLExtension supported_versions(TLSEXT_TYPE_supported_versions);\nSSLExtension ech_unused(TLSEXT_TYPE_encrypted_client_hello, hs->selected_ech_config || hs->config->ech_grease_enabled);\nif (!ssl_parse_extensions(&server_hello.extensions, &alert, {&cookie, &key_share, &supported_versions, &ech_unused}, /*ignore_unknown=*/false)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n    return ssl_hs_error;\n}', 'explanation': 'This segment processes all extensions in the HelloRetryRequest by parsing cookie, key_share, supported_versions, and encrypted_client_hello extensions, thereby satisfying the requirement to process all extensions.'}}, {'A1': {'code': 'ssl->method->next_message(ssl);\nssl->s3->used_hello_retry_request = true;\nhs->tls13_state = state_send_second_client_hello;\nif (hs->in_early_data) {\n    ssl->s3->early_data_reason = ssl_early_data_hello_retry_request;\n    if (!close_early_data(hs, ssl_encryption_initial)) {\n      return ssl_hs_error;\n    }\n    return ssl_hs_early_data_rejected;\n}\nreturn ssl_hs_ok;', 'explanation': ""This segment sets the internal state (tls13_state) to 'state_send_second_client_hello' and schedules the next message, ensuring that a second updated ClientHello will be sent, which fulfills the action requirement.""}}]",The function do_read_hello_retry_request clearly implements the key aspects mandated by the spec. It processes all extensions present in the HelloRetryRequest by explicitly calling ssl_parse_extensions with the relevant extension objects (C1) and it then transitions the handshake state to send a second updated ClientHello (A1). This logic within the function itself satisfies both the conditions and actions specified by the RFC.,success,
8459,do_read_hello_retry_request,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function is focused on processing the HelloRetryRequest during the TLS handshake, such as parsing the server hello message, validating cipher suites, updating transcripts, and so on. It does not contain any logic that addresses the RFC specification stating that ""Application Data MUST NOT be sent prior to sending the Finished message,"" nor any associated conditions or actions (e.g., C1, A1) related to that constraint. Therefore, this function does not implement the specified constraint.",success,
8459,do_read_hello_retry_request,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Fully Matches,"[{'A1': {'code': 'if (ssl->method->has_unprocessed_handshake_data(ssl)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);\n    OPENSSL_PUT_ERROR(SSL, SSL_R_EXCESS_HANDSHAKE_DATA);\n    return ssl_hs_error;\n  }', 'explanation': ""This segment checks if there is any additional handshake data (i.e. an unexpected message order) after processing the HelloRetryRequest. On detecting unexpected data, it sends an 'unexpected_message' alert and aborts the handshake, fully addressing the specified RFC requirement.""}}]","The specification mandates that if a handshake message is received out-of-order, the handshake must be aborted with an 'unexpected_message' alert. The function explicitly implements this behavior by checking for unprocessed handshake messages and, if found, sending the appropriate alert and aborting the handshake. This logic fully meets the specified constraint within the function itself.",success,
8459,do_read_hello_retry_request,"A client which receives a cipher suite that was not offered MUST abort the handshake with an ""illegal_parameter"" alert.",33,Fully Matches,"[{'C1': {'code': 'const SSL_CIPHER *cipher = SSL_get_cipher_by_value(server_hello.cipher_suite);\nif (cipher == nullptr ||\n    SSL_CIPHER_get_min_version(cipher) > ssl_protocol_version(ssl) ||\n    SSL_CIPHER_get_max_version(cipher) < ssl_protocol_version(ssl) ||\n    !ssl_tls13_cipher_meets_policy(SSL_CIPHER_get_protocol_id(cipher), ssl->config->compliance_policy)) {', 'explanation': 'This block verifies that the cipher suite received from the server was indeed one that was offered. It checks for a null cipher, mismatched protocol versions, and compliance with policy.'}}, {'A1': {'code': 'OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CIPHER_RETURNED);\nssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\nreturn ssl_hs_error;', 'explanation': ""When the check fails, the function sends an 'illegal_parameter' alert and aborts the handshake, fulfilling the requirement that unoffered cipher suites must be rejected.""}}]","The function contains explicit logic that checks if the received cipher suite is among those the client offered. If not, it reports an error and issues an 'illegal_parameter' alert, thus fully addressing the specification stating that a client must abort the handshake upon receiving a cipher suite that was not offered.",success,
8459,do_read_hello_retry_request,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function does not contain any logic addressing the specific RFC requirement regarding the ""supported_groups"" information. The spec states that clients must not act upon any info from ""supported_groups"" before a completed handshake, but the function only handles extensions such as key_share, cookie, supported_versions, and ECH-related processing. There is no code segment that deals with ""supported_groups"", hence the function does not fulfill the spec constraint.",success,
8459,do_read_hello_retry_request,"Upon receipt of this extension in a HelloRetryRequest, the client MUST verify that (1) the selected_group field corresponds to a group which was provided in the ""supported_groups"" extension in the original ClientHello and (2) the selected_group field does not correspond to a group which was provided in the ""key_share"" extension in the original ClientHello.",126,Fully Matches,"[{'C1': {'code': 'if (!tls1_check_group_id(hs, group_id)) {\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n      OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CURVE);\n      return ssl_hs_error;\n    }', 'explanation': 'This snippet checks that the selected group (extracted from the key_share extension) is supported. Although the function tls1_check_group_id likely verifies that the group was originally provided in the supported_groups extension of the ClientHello, it directly enforces that the selected group is valid as required by the spec.'}}, {'C2': {'code': 'if (hs->key_shares[0]->GroupID() == group_id ||\n        (hs->key_shares[1] && hs->key_shares[1]->GroupID() == group_id)) {\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n      OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CURVE);\n      return ssl_hs_error;\n    }', 'explanation': 'This check ensures that the selected group does not match any group previously provided in the key_share extension of the original ClientHello, thereby satisfying the second requirement of the RFC.'}}]","The function do_read_hello_retry_request implements the two critical requirements from the RFC. It validates that the selected_group in the HelloRetryRequest is among the supported groups (by calling tls1_check_group_id, which presumably checks against the supported_groups extension) and also confirms that this group was not already provided in the original key_share extension. Both checks are performed within the function, ensuring that the RFC specification is fully addressed in the implementation.",success,
8459,do_read_hello_retry_request,"If either of these checks fails, then the client MUST abort the handshake with an ""illegal_parameter"" alert.",127,Fully Matches,"[{'C1': {'code': 'if (cipher == nullptr ||\n          SSL_CIPHER_get_min_version(cipher) > ssl_protocol_version(ssl) ||\n          SSL_CIPHER_get_max_version(cipher) < ssl_protocol_version(ssl) ||\n          !ssl_tls13_cipher_meets_policy(SSL_CIPHER_get_protocol_id(cipher), ssl->config->compliance_policy)) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CIPHER_RETURNED);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n      return ssl_hs_error;\n    }', 'explanation': 'This segment checks that the cipher suite is one that was offered and satisfies the version and policy requirements. If the check fails, it sends an SSL_AD_ILLEGAL_PARAMETER alert and aborts the handshake, as required by the spec.'}}, {'C1': {'code': 'if (!cookie.present && !key_share.present) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_EMPTY_HELLO_RETRY_REQUEST);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n      return ssl_hs_error;\n    }', 'explanation': 'This code ensures that at least one of the required extensions (cookie or key_share) is present in the HelloRetryRequest. If both are missing, it sends an illegal_parameter alert and aborts the handshake per the spec.'}}, {'C1': {'code': 'if (hs->key_shares[0]->GroupID() == group_id ||\n          (hs->key_shares[1] && hs->key_shares[1]->GroupID() == group_id)) {\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n      OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CURVE);\n      return ssl_hs_error;\n    }', 'explanation': 'This check verifies that the HelloRetryRequest does not request a key share that was already provided in the initial ClientHello. On failure, an illegal_parameter alert is sent and the handshake is aborted, which directly matches the specified requirement.'}}]","The function do_read_hello_retry_request implements several checks related to the TLS handshake, specifically for HelloRetryRequest messages. In each instance where a check fails (such as an invalid cipher suite, missing required extensions, or a repeated key share group), the function sends an 'illegal_parameter' alert and aborts the handshake. This behavior directly mirrors the RFC specification requirement that mandates aborting the handshake with an 'illegal_parameter' alert if any check fails. All of these conditions are enforced within the function itself, meaning that the code fully meets the specified RFC constraint.",success,
8459,do_read_hello_retry_request,"Otherwise, when sending the new ClientHello, the client MUST",128,Does Not Match,[],"The provided function implements a TLS 1.3 handshake procedure related to processing a HelloRetryRequest message, including parsing extensions, handling cookies and key shares, and updating handshake transcripts. None of the code within this function addresses any HTTP RFC requirements such as handling Range header fields or any constraints related to sending a new ClientHello in an HTTP context. Therefore, no spec constraints (e.g., C1, A1) are fulfilled by this function.",success,
8459,do_read_hello_retry_request,"If this check fails, the client MUST abort the handshake with an ""illegal_parameter"" alert.",132,Fully Matches,"[{'C1': {'code': 'if (cipher == nullptr ||\n      SSL_CIPHER_get_min_version(cipher) > ssl_protocol_version(ssl) ||\n      SSL_CIPHER_get_max_version(cipher) < ssl_protocol_version(ssl) ||\n      !ssl_tls13_cipher_meets_policy(SSL_CIPHER_get_protocol_id(cipher),\n                                     ssl->config->compliance_policy)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CIPHER_RETURNED);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n  }', 'explanation': ""This segment checks that the cipher suite selected by the server is one that was offered and complies with version and policy requirements. If the check fails, it aborts the handshake by sending an 'illegal_parameter' alert as specified.""}}, {'C2': {'code': 'if (!cookie.present && !key_share.present) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_EMPTY_HELLO_RETRY_REQUEST);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n  }', 'explanation': ""This check ensures that either a cookie or a key_share is present in the HelloRetryRequest. If neither is present, the function aborts the handshake with an 'illegal_parameter' alert, matching the RFC requirement.""}}, {'C3': {'code': 'if (hs->key_shares[0]->GroupID() == group_id ||\n    (hs->key_shares[1] && hs->key_shares[1]->GroupID() == group_id)) {\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n  OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CURVE);\n  return ssl_hs_error;\n}', 'explanation': ""This block verifies that the key share requested in the HelloRetryRequest is not one that was already provided in the initial ClientHello. On detecting an invalid or redundant key share, it aborts the handshake with an 'illegal_parameter' alert, satisfying the specification.""}}]","The function do_read_hello_retry_request contains several explicit checks where, if a condition fails (for example, an unacceptable cipher suite, missing required extensions, or an invalid key share), it immediately aborts the handshake by sending an 'illegal_parameter' alert. Since each of these safeguards is implemented directly within this function, it is clear that all the aspects of the RFC requirement—‘if this check fails, the client MUST abort the handshake with an ""illegal_parameter"" alert’—are visibly addressed in the code. Thus, the function fully matches the specified constraint.",success,
8459,do_read_hello_retry_request,"If it is not, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.",146,Partially Matches,"[{'A1': {'code': 'if (hs->in_early_data) {\n    ssl->s3->early_data_reason = ssl_early_data_hello_retry_request;\n    if (!close_early_data(hs, ssl_encryption_initial)) {\n      return ssl_hs_error;\n    }\n    return ssl_hs_early_data_rejected;\n}', 'explanation': 'This block explicitly rejects 0-RTT (early data) when a HelloRetryRequest is received. This corresponds to the RFC requirement to proceed with the handshake but reject 0-RTT.'}}]","The provided function implements the TLS 1.3 HelloRetryRequest processing. In doing so, it includes logic to reject early data (0-RTT) when a HelloRetryRequest is received, which matches the part of the RFC spec that states the server SHOULD reject 0-RTT if the ClientHello is not fresh. However, the additional HTTP-related details (e.g., handling a 206 response with Content-Range headers) mentioned in the specification context are not addressed at all in this function. Since only a subset of the overall spec constraints (namely the 0-RTT rejection) is implemented here within the function body, the overall assessment is that it partially matches the specified RFC.",success,
8459,do_read_hello_retry_request,"When sending a HelloRetryRequest, the server MAY provide a ""cookie"" extension to the client (this is an exception to the usual rule that the only extensions that may be sent are those that appear in the ClientHello).",77,Fully Matches,"[{'C1': {'code': 'SSLExtension cookie(TLSEXT_TYPE_cookie);\n...\nif (!ssl_parse_extensions(\n          &server_hello.extensions, &alert,\n          {&cookie, &key_share, &supported_versions, &ech_unused},\n          /*ignore_unknown=*/false)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n    return ssl_hs_error;\n}\n...\nif (cookie.present) {\n    CBS cookie_value;\n    if (!CBS_get_u16_length_prefixed(&cookie.data, &cookie_value) ||\n        CBS_len(&cookie_value) == 0 ||\n        CBS_len(&cookie.data) != 0) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n      return ssl_hs_error;\n    }\n\n    if (!hs->cookie.CopyFrom(cookie_value)) {\n      return ssl_hs_error;\n    }\n}', 'explanation': 'The code explicitly creates an SSLExtension for the cookie (using TLSEXT_TYPE_cookie), parses the extensions, checks if the cookie extension is present, validates its contents, and copies it into the handshake state. This directly implements the RFC behavior allowing the server to include a cookie extension in HelloRetryRequest messages.'}}]","The function do_read_hello_retry_request visibly addresses the RFC specification for handling the 'cookie' extension in a HelloRetryRequest. It contains all the necessary logic within the function body to check the presence of the cookie extension, validate its structure, and process it accordingly. Therefore, the function fully implements the relevant condition (C1) from the spec.",success,
8461,do_read_server_hello,Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection.,241,Fully Matches,"[{'C1': {'code': 'if (ssl->session->cipher->algorithm_prf != hs->new_cipher->algorithm_prf) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_OLD_SESSION_PRF_HASH_MISMATCH);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n}', 'explanation': 'This code verifies that, when resuming a session (indicated by the presence of the pre_shared_key), the cipher suite’s PRF (which represents the KDF hash algorithm) of the resumed session matches that of the new connection. This directly enforces the RFC requirement that any ticket must only be resumed with a cipher suite using the same KDF hash algorithm as originally used.'}}]","The function includes an explicit check comparing the algorithm_prf of the resumed session's cipher to that of the new_cipher. When the values differ, it triggers an error, thereby ensuring that a session ticket is only resumed if the KDF hash algorithm is consistent with that used in the original connection. This directly and completely implements the stated RFC requirement within the function itself.",success,
8461,do_read_server_hello,"If the ""supported_versions"" extension is present, the server MUST negotiate using that extension as described in Section 4.2.1.",380,Fully Matches,"[{'C1': {'code': 'if (!supported_versions.present ||                       //\n      !CBS_get_u16(&supported_versions.data, &version) ||  //\n      CBS_len(&supported_versions.data) != 0 ||            //\n      version != ssl->s3->version) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_SECOND_SERVERHELLO_VERSION_MISMATCH);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n  }', 'explanation': ""This segment checks that the 'supported_versions' extension is present and that the negotiated version matches the expected version (ssl->s3->version). This directly implements the RFC requirement that if the supported_versions extension is present, the server must negotiate using it.""}}]","The function do_read_server_hello clearly inspects and validates the supported_versions extension. By ensuring that the extension is both present and that its version matches the expected protocol version, the code fulfills the RFC specification that mandates negotiation using the supported_versions extension. All logic is implemented within the function itself, hence the overall outcome is 'Fully Matches'.",success,
8461,do_read_server_hello,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function implements the TLS 1.3 ServerHello processing and contains extensive logic to validate and process various extensions and handshake parameters. However, there is no visible logic within the function that specifically checks for or prevents the use of the Truncated HMAC extension as required by the RFC specification. The function does not mention HMAC or truncated HMAC in any part of its implementation, and therefore it does not implement the RFC constraint.",success,
8461,do_read_server_hello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'uint8_t alert = SSL_AD_DECODE_ERROR;\nif (!parse_server_hello_tls13(hs, &server_hello, &alert, msg)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n    return ssl_hs_error;\n}', 'explanation': 'This segment checks if the ServerHello message fails to parse. It pre-sets the alert to SSL_AD_DECODE_ERROR and, upon parse failure, sends an alert and terminates the connection as required by the spec.'}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, alert);', 'explanation': 'This call sends a fatal alert (in this case, decode_error) when a parsing error is detected, thereby terminating the connection in accordance with the spec.'}}]","The function 'do_read_server_hello' explicitly checks if the ServerHello message cannot be parsed by invoking 'parse_server_hello_tls13'. Upon a parsing failure, it sends an alert (initialized to SSL_AD_DECODE_ERROR) and returns an error state, which effectively terminates the connection. This directly corresponds to the spec requirement that peers receiving a message with a syntax error must terminate the connection with a decode_error alert. Therefore, the function fully meets the specified RFC constraint within its own implementation.",success,
8461,do_read_server_hello,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (SSL_CIPHER_get_protocol_id(hs->new_cipher) != server_hello.cipher_suite) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CIPHER_RETURNED);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n}', 'explanation': ""When the negotiated cipher suite does not match the expected value from ServerHello, the connection is terminated with an 'illegal_parameter' alert, which implements the RFC action to close the connection on a semantically invalid parameter.""}}, {'A1': {'code': 'if (!supported_versions.present ||\n    !CBS_get_u16(&supported_versions.data, &version) ||\n    CBS_len(&supported_versions.data) != 0 ||\n    version != ssl->s3->version) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_SECOND_SERVERHELLO_VERSION_MISMATCH);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n}', 'explanation': ""On detecting an unexpected or mismatched supported_versions extension, the connection is terminated with an 'illegal_parameter' alert. This is another instance where semantically invalid messages are handled according to the specification.""}}, {'A1': {'code': 'if (ssl->session->ssl_version != ssl->s3->version) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_OLD_SESSION_VERSION_NOT_RETURNED);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n}', 'explanation': ""A mismatch between the session's SSL version and the negotiated version triggers a termination with an 'illegal_parameter' alert, again addressing the RFC requirement on semantically invalid parameters.""}}]","The RFC requires that when a peer receives a syntactically correct but semantically invalid message, it must terminate the connection using an 'illegal_parameter' alert. The function implements several checks—for example, for cipher suite mismatches, version mismatches, and session consistency—each of which results in a call to ssl_send_alert with an 'illegal_parameter' alert. However, not every error path is uniformly handled with that alert (some errors use different alert codes), meaning that though several conditions are correctly addressed, the implementation only partially matches the complete RFC requirement. Note that while the function covers multiple cases internally, additional semantic verifications might be handled elsewhere, so only the logic within this function counts.",success,
8461,do_read_server_hello,"All TLS 1.3 ServerHello messages MUST contain the ""supported_versions"" extension.",36,Fully Matches,"[{'C1': {'code': 'SSLExtension supported_versions(TLSEXT_TYPE_supported_versions);\n...\nif (!supported_versions.present ||\n    !CBS_get_u16(&supported_versions.data, &version) ||\n    CBS_len(&supported_versions.data) != 0 ||\n    version != ssl->s3->version) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_SECOND_SERVERHELLO_VERSION_MISMATCH);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n}', 'explanation': ""The code creates an extension object for 'supported_versions', passes it to the extension parser, and then verifies that the extension is present and that its value matches the expected version. This directly implements the RFC requirement that all TLS 1.3 ServerHello messages must contain the supported_versions extension.""}}]","The function explicitly handles the 'supported_versions' extension by initializing it, parsing it from the server's extensions, and verifying its presence and content. Since this logic is contained solely within the function and fulfills the specified RFC constraint, the implementation fully matches the requirement.",success,
8461,do_read_server_hello,"The server's extensions MUST contain ""supported_versions""",45,Fully Matches,"[{'C1': {'code': 'SSLExtension supported_versions(TLSEXT_TYPE_supported_versions);\n...\nif (!supported_versions.present ||\n      !CBS_get_u16(&supported_versions.data, &version) ||\n      CBS_len(&supported_versions.data) != 0 ||\n      version != ssl->s3->version) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_SECOND_SERVERHELLO_VERSION_MISMATCH);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n  }', 'explanation': ""The function creates a supported_versions extension object, parses it, and then verifies that the extension is present and contains a valid version matching the expected protocol. This directly addresses the RFC requirement that the server's extensions MUST contain 'supported_versions'.""}}]","Within do_read_server_hello, the code explicitly initializes the supported_versions extension and validates its presence and content, thereby implementing the RFC specification. The check ensures that the supported_versions extension exists and that its value equals the protocol version, which fulfills the spec constraint as an implementation within this function.",success,
8461,do_read_server_hello,"Clients MUST abort the handshake with an ""illegal_parameter"" alert if the HelloRetryRequest would not result in any change in the ClientHello.",49,Does Not Match,[],"The provided function does not implement the spec requirement. The spec states that the client must abort the handshake with an 'illegal_parameter' alert if the HelloRetryRequest would not result in any change in the ClientHello. However, the code merely checks for a HelloRetryRequest via the condition 'if (is_hello_retry_request(server_hello))' and, if true, sends an alert with SSL_AD_UNEXPECTED_MESSAGE rather than SSL_AD_ILLEGAL_PARAMETER. There is no logic in this function that verifies whether the subsequent ClientHello would change compared to the earlier one, which is the core condition described in the spec. Other checks that send an 'illegal_parameter' alert in different contexts exist, but none address this specific spec requirement within the function itself.",success,
8461,do_read_server_hello,"If a client receives a second HelloRetryRequest in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest), it MUST abort the handshake with an ""unexpected_message"" alert.",50,Fully Matches,"[{'C1': {'code': 'if (is_hello_retry_request(server_hello)) {', 'explanation': 'This check detects if the received ServerHello is a HelloRetryRequest, which by context indicates a second HelloRetryRequest.'}}, {'A1': {'code': '  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);\n  OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_MESSAGE);\n  return ssl_hs_error;', 'explanation': ""On detecting a HelloRetryRequest, the code aborts the handshake by sending an 'unexpected_message' alert, as required by the RFC.""}}]",The function directly implements the RFC requirement by checking if the received ServerHello is a HelloRetryRequest and then aborting the handshake with an 'unexpected_message' alert. This logic addresses both the condition (C1) and the action (A1) specified in the RFC constraint.,success,
8461,do_read_server_hello,"Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello (if the server selects the cipher suite as the first step in the negotiation, then this will happen automatically).",53,Fully Matches,"[{'C1': {'code': 'if (SSL_CIPHER_get_protocol_id(hs->new_cipher) != server_hello.cipher_suite) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CIPHER_RETURNED);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n  }', 'explanation': 'This code segment verifies that the cipher suite negotiated during the handshake (as represented by hs->new_cipher) matches the cipher suite provided in the ServerHello message. By checking for equality and sending an alert if mismatched, it enforces the RFC mandate that the same cipher suite must be negotiated. This directly implements the specified requirement within the function.'}}]","The specification mandates that servers ensure the negotiated cipher suite remains consistent when processing an updated ClientHello. The analyzed function contains a direct check comparing the expected cipher suite with the one provided by the server in the ServerHello message. If these do not match, it triggers an error alert, thereby fulfilling the condition outlined in the RFC. Since this logic is implemented directly within the function, it fully meets the specified constraint.",success,
8461,do_read_server_hello,"Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an ""illegal_parameter"" alert.",54,Fully Matches,"[{'C1': {'code': 'if (SSL_CIPHER_get_protocol_id(hs->new_cipher) != server_hello.cipher_suite) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CIPHER_RETURNED);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n  }', 'explanation': ""This code checks whether the cipher suite in the ServerHello matches the expected cipher suite (as would have been signaled in the earlier HelloRetryRequest) and aborts the handshake by sending an 'illegal_parameter' alert if they differ. This directly fulfills the RFC requirement.""}}]","The function contains a code segment that verifies the cipher suite supplied in the ServerHello against the expected cipher suite. If the cipher suite does not match, it sends an illegal_parameter alert, which is the precise behavior mandated by the RFC. Thus, the function fully matches the specified constraint related to the cipher suite check.",success,
8461,do_read_server_hello,"The value of selected_version in the HelloRetryRequest ""supported_versions"" extension MUST be retained in the ServerHello, and a client MUST abort the handshake with an ""illegal_parameter"" alert if the value changes.",56,Fully Matches,"[{'C1': {'code': 'if (!supported_versions.present ||\n      !CBS_get_u16(&supported_versions.data, &version) ||\n      CBS_len(&supported_versions.data) != 0 ||\n      version != ssl->s3->version) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_SECOND_SERVERHELLO_VERSION_MISMATCH);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n  }', 'explanation': ""This code segment checks that the 'supported_versions' extension is present and that its contained version value matches the version stored in ssl->s3->version (which reflects the selected_version retained from the previous HelloRetryRequest). If there is a mismatch, it aborts the handshake with an 'illegal_parameter' alert, thus fully addressing the spec requirement.""}}]","The function directly verifies that the version provided in the ServerHello's 'supported_versions' extension remains the same as the version selected previously (presumably during a HelloRetryRequest). This meets the RFC specification's requirement to retain the selected_version and abort the handshake with an 'illegal_parameter' alert if it changes. No other aspects outside this verification are required by the specification, and all relevant checks are contained within this function.",success,
8461,do_read_server_hello,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest.",59,Does Not Match,[],"The RFC specification requires that implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests (except for the ""cookie"" extension in the HelloRetryRequest). In the provided function body, which handles the processing of a TLS1.3 ServerHello message, there is no logic that verifies whether an extension was requested by the remote endpoint before including its response. The code parses and checks for various extensions (such as key_share, pre_shared_key, supported_versions, and pake_share) and verifies their validity, but it does not implement any mechanism to suppress sending extension responses that were not requested by the remote endpoint. Therefore, no part of the function visibly implements the RFC constraint.",success,
8461,do_read_server_hello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The provided function 'do_read_server_hello' is dedicated to processing the ServerHello message in a TLS 1.3 handshake. The RFC specification, however, concerns the ordering of extensions – specifically that the 'pre_shared_key' extension MUST be the last extension in the ClientHello (while it can appear anywhere in a ServerHello) – as well as HTTP HEAD method semantics. This function does not implement any logic related to enforcing ordering rules in a ClientHello nor does it deal with the HTTP HEAD method. All extension handling logic here is focused on parsing the ServerHello and appropriately processing its extensions without any checks on ordering as required for ClientHello. Consequently, from the perspective of the specified RFC constraints, the function does not visibly address any labeled conditions or actions.",success,
8461,do_read_server_hello,The ServerHello MUST only include extensions which are required to establish the cryptographic context and negotiate the protocol version.,35,Fully Matches,"[{'C1': {'code': 'if (!ssl_parse_extensions(\n          &server_hello.extensions, &alert,\n          {&key_share, &pre_shared_key, &supported_versions, &pake_share},\n          /*ignore_unknown=*/false)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n    return ssl_hs_error;\n  }', 'explanation': 'This code segment explicitly parses and only accepts a fixed set of extensions (key_share, pre_shared_key, supported_versions, and pake_share), rejecting any unknown or unsolicited extensions. This aligns with the RFC requirement that the ServerHello must only include extensions necessary for establishing the cryptographic context and negotiating the protocol version.'}}]","The function do_read_server_hello implements logic to strictly filter the extensions included in the ServerHello message by only accepting a defined set of extensions that are essential for key agreement, protocol version negotiation, and related cryptographic operations. By using ssl_parse_extensions with ignore_unknown set to false and by enforcing valid combinations of extensions, the function ensures that no extraneous extension is processed, thereby fully matching the RFC specification.",success,
8461,do_read_server_hello,"A client which receives a cipher suite that was not offered MUST abort the handshake with an ""illegal_parameter"" alert.",33,Fully Matches,"[{'C1': {'code': 'if (SSL_CIPHER_get_protocol_id(hs->new_cipher) != server_hello.cipher_suite) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CIPHER_RETURNED);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n  }', 'explanation': ""This code segment verifies that the cipher suite returned by the server matches the one the client offered. If they do not match, it aborts the handshake by sending an 'illegal_parameter' alert, which is exactly what the RFC specifies.""}}]","The function explicitly checks the cipher suite received from the server against the expected cipher suite (offered in the ClientHello). Upon detecting a mismatch, it calls 'ssl_send_alert' with the 'illegal_parameter' alert and terminates the handshake, thereby fully implementing the specified requirement from the RFC.",success,
8461,do_read_server_hello,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function solely processes the ServerHello message in a TLS 1.3 handshake and manages related extensions and state transitions. There is no logic in this function that checks or enforces the rule that 'Application Data MUST NOT be sent prior to sending the Finished message' (i.e., no code ensures that application data is withheld until after the Finished message is sent). Therefore, none of the spec constraints (e.g., conditions such as C1 or actions like A1) that relate to preventing application data from being transmitted prematurely are addressed within this function.",success,
8461,do_read_server_hello,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Fully Matches,"[{'C1': {'code': 'if (is_hello_retry_request(server_hello)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);\n    OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_MESSAGE);\n    return ssl_hs_error;\n  }', 'explanation': ""This segment checks if the received ServerHello is an unexpected HelloRetryRequest (i.e. a handshake message out-of-order) and aborts the handshake with an 'unexpected_message' alert, as required by the RFC.""}}]",The provided function implements the specific spec requirement by identifying an unexpected handshake message (a second HelloRetryRequest) and immediately aborting the handshake with an 'unexpected_message' alert. This direct check satisfies the constraint that a peer receiving a handshake message in an unexpected order must abort the handshake accordingly.,success,
8461,do_read_server_hello,"A server which negotiates TLS 1.3 MUST respond by sending a ""supported_versions"" extension containing the selected version value (0x0304).",72,Fully Matches,"[{'C1': {'code': 'if (!supported_versions.present ||                       \n    !CBS_get_u16(&supported_versions.data, &version) ||  \n    CBS_len(&supported_versions.data) != 0 ||            \n    version != ssl->s3->version) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_SECOND_SERVERHELLO_VERSION_MISMATCH);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n  return ssl_hs_error;\n}', 'explanation': ""This code block checks that the 'supported_versions' extension is present, retrieves its value, confirms that no extra bytes remain, and verifies that the version matches the expected TLS version (typically 0x0304 for TLS 1.3). This directly fulfills the requirement stated in the spec that a TLS 1.3 server must include this extension with the correct version.""}}]","The analyzed function processes the ServerHello message during a TLS 1.3 handshake. It explicitly verifies the presence and correctness of the 'supported_versions' extension by extracting the advertised version and comparing it against the expected version. This check is performed entirely within the function, and thus the code function fully matches the specification requirement.",success,
8461,do_read_server_hello,"In this mode, the client and server MUST supply ""key_share"" values as described in Section 4.2.8.",142,Fully Matches,"[{'C1': {'code': 'SSLExtension key_share(TLSEXT_TYPE_key_share, hs->key_shares[0] != nullptr);\n...\nif (hs->pake_prover == nullptr && !key_share.present) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_MISSING_KEY_SHARE);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_MISSING_EXTENSION);\n    return ssl_hs_error;\n}', 'explanation': 'The code explicitly creates a key_share extension based on the existence of a key share value (hs->key_shares[0] != nullptr) and later verifies that for non-PAKE handshakes, the key_share extension is present. This implementation reflects the RFC requirement that both client and server must supply key_share values.'}}]","The function do_read_server_hello implements the required logic for handling the key_share extension as mandated by the RFC specification. It constructs, parses, and validates the presence of the key_share value, ensuring that if a key share is not provided (and the handshake is not using PAKE), an error is raised. This demonstrates that the function fully addresses the RFC constraint regarding key_share.",success,
8461,do_read_server_hello,"In addition, it MUST verify that the following values are the same as those associated with the selected PSK:",150,Does Not Match,[],"The provided code function is concerned with processing a TLS ServerHello message, including some logic for handling pre_shared_key extension elements. Although it does perform certain verifications (such as checking that the TLS version and PRF algorithm of the session match expected values), these verifications are part of the TLS handshake logic rather than the HTTP RFC requirement. In addition, the spec context describes multipart/byteranges content in a 206 response and explicitly requires the verification of values against those associated with a selected PSK, which is not visibly implemented in this function. Therefore, within this function there is no code that fully meets the labeled conditions (e.g., C1, C2) or actions (e.g., A1, A2) as specified by the RFC.",success,
8461,do_read_server_hello,"If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the ""supported_versions"" extension to determine the selected version.",75,Fully Matches,"[{'C1': {'code': 'if (!supported_versions.present ||                       \n    !CBS_get_u16(&supported_versions.data, &version) ||  \n    CBS_len(&supported_versions.data) != 0 ||            \n    version != ssl->s3->version) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_SECOND_SERVERHELLO_VERSION_MISMATCH);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n  return ssl_hs_error;\n}', 'explanation': ""This segment exclusively uses the 'supported_versions' extension to obtain the negotiated version. By not referencing ServerHello.legacy_version at all, the function effectively ignores it, thereby fulfilling the RFC mandate that the client should use only the 'supported_versions' extension to determine the selected version.""}}]","The function clearly implements the RFC requirement by solely relying on the 'supported_versions' extension to derive the protocol version. The code checks that the extension is present and that its value is valid, which implies that any legacy_version field is disregarded. This direct handling satisfies the specified condition (C1) from the RFC.",success,
8461,do_read_server_hello,"If the ""supported_versions"" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an ""illegal_parameter"" alert.",76,Fully Matches,"[{'C1': {'code': 'if (!supported_versions.present ||\n      !CBS_get_u16(&supported_versions.data, &version) ||\n      CBS_len(&supported_versions.data) != 0 ||\n      version != ssl->s3->version) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_SECOND_SERVERHELLO_VERSION_MISMATCH);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n  }', 'explanation': ""This block checks that the 'supported_versions' extension is present, correctly parsed, contains no extra data, and that the version value exactly matches the expected TLS version. On failure, it sends an illegal_parameter alert and aborts the handshake, matching the RFC requirement.""}}]","The function explicitly validates the supported_versions extension from the ServerHello message. It ensures that the version provided matches the expected TLS version (implicitly assuming only TLS 1.3 is acceptable) and aborts the handshake with an 'illegal_parameter' alert if the check fails. This directly addresses the RFC specification that mandates aborting the handshake when an unsupported or out‐of‐range version is received, thus fully matching the constraint.",success,
8461,do_read_server_hello,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The RFC specification mandates that clients must not act upon any information found in the ""supported_groups"" extension before the handshake is successfully completed. However, in the provided function, there is no processing or reference to the supported_groups extension. The code deals with other extensions (such as key_share, pre_shared_key, supported_versions, and PAKE) but does not include any logic that addresses the handling of supported_groups as required by the spec. Therefore, the function does not fulfill the specified constraint.",success,
8462,do_read_encrypted_extensions,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (hs->early_session->cipher != hs->new_session->cipher) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_CIPHER_MISMATCH_ON_EARLY_DATA);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n      return ssl_hs_error;\n    }\n\n    if (Span(hs->early_session->early_alpn) != ssl->s3->alpn_selected) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_ALPN_MISMATCH_ON_EARLY_DATA);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n      return ssl_hs_error;\n    }\n\n    if (hs->channel_id_negotiated ||\n        hs->new_session->has_application_settings) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_EXTENSION_ON_EARLY_DATA);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n      return ssl_hs_error;\n    }', 'explanation': ""The function checks for semantic mismatches in early data parameters such as cipher differences, ALPN mismatches, and unexpected extensions. In each case, it sends an 'illegal_parameter' alert as required by the RFC when a semantically invalid message is detected. However, these checks cover only specific scenarios and do not address all possible semantic invalidity cases as described in the RFC specification.""}}]","The provided function does incorporate logic to detect certain semantic invalidity conditions in the TLS handshake—specifically in the context of early data parameters—and reacts by sending an 'illegal_parameter' alert, which fulfills part of the RFC requirements. However, the implementation is limited to these early data checks and does not cover all cases of semantically invalid messages the RFC might consider (for instance, there is a branch for decode errors that results in a different alert type, and many potential error conditions are handled elsewhere). Therefore, the function only partially matches the RFC's requirements as implemented within its own scope.",success,
8462,do_read_encrypted_extensions,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16_length_prefixed(&body, &extensions) || CBS_len(&body) != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    return ssl_hs_error;\n  }', 'explanation': 'This segment checks whether the encrypted extensions message is correctly formatted (e.g. the length prefix is valid and no extra data remains). If parsing fails, it sends a decode_error alert and terminates further processing, which is exactly what the RFC specifies.'}}]","The function directly implements the requirement by ensuring that if the received message cannot be parsed according to its expected syntax, it sends a 'decode_error' alert and terminates the connection. This logic is entirely contained within the function_body, fully satisfying the constraint as outlined in the RFC specification.",success,
8462,do_read_encrypted_extensions,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16_length_prefixed(&body, &extensions) ||  CBS_len(&body) != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    return ssl_hs_error;\n}', 'explanation': 'This block checks the structure of the encrypted extensions message. If the expected length-prefixed field is not correctly parsed or if there is trailing data, it aborts the handshake by sending a fatal alert with the decode error, as mandated by the spec.'}}]","The RFC requires that if the encrypted extensions cannot be correctly decoded then the handshake must be aborted with a 'decode_error' alert. The function explicitly performs this check by verifying the length-prefixed data and ensuring no extra data remains, then calling ssl_send_alert with SSL_AD_DECODE_ERROR and returning an error state. This code segment fully implements the required behavior within the function_body.",success,
8462,do_read_encrypted_extensions,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function do_read_encrypted_extensions processes the Encrypted Extensions handshake message and performs various validations and message parsing specific to a TLS handshake. However, it does not contain any logic that checks or enforces that Application Data is not sent before the Finished message, as required by the spec. Although there is early data related logic, it does not address the ordering constraint described in the RFC specification. Therefore, no part of the function can be seen as implementing any of the labeled conditions or actions regarding the application data ordering requirement.",success,
8462,do_read_encrypted_extensions,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'A1': {'code': 'if (hs->in_early_data && !ssl->s3->early_data_accepted) {\n    if (!close_early_data(hs, ssl_encryption_handshake)) {\n      return ssl_hs_error;\n    }\n    return ssl_hs_early_data_rejected;\n  }', 'explanation': 'This segment ensures that if early data (0-RTT) is in progress but not accepted, early data is not automatically resent. Instead, it cleanly closes the early data context, leaving the decision of retransmission to the application, which aligns with the TLS specification requirement.'}}]","The function 'do_read_encrypted_extensions' contains explicit logic to handle cases in which early data is not accepted by checking if the handshake is occurring in early data mode and then closing early data without attempting to resend it. This directly adheres to the TLS specification requirement that early data should not be automatically retransmitted by the TLS implementation, thus fully matching the provided constraint.",success,
8463,do_read_certificate_request,"Implementations which have the same policy in both cases MAY omit the ""signature_algorithms_cert"" extension.",85,Does Not Match,[],"The specified RFC constraint states that implementations with identical policy may omit the ""signature_algorithms_cert"" extension. However, within the function_body, there is no logic handling or allowing for the omission of the ""signature_algorithms_cert"" extension. The function only handles the ""signature_algorithms"" (sigalgs) extension and requires its presence, with no branch that considers omitting an analogous signature_algorithms_cert extension. Therefore, this function does not visibly address the RFC constraint as specified.",success,
8463,do_read_certificate_request,"The ""certificate_authorities"" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which SHOULD be used by the receiving endpoint to guide certificate selection.",104,Partially Matches,"[{'C1': {'code': 'if (ca.present) {\n    hs->ca_names = SSL_parse_CA_list(ssl, &alert, &ca.data);\n    if (!hs->ca_names) {\n      ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n      return ssl_hs_error;\n    }\n  } else {\n    hs->ca_names.reset(sk_CRYPTO_BUFFER_new_null());\n    if (!hs->ca_names) {\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n      return ssl_hs_error;\n    }\n  }', 'explanation': 'This segment implements handling of the certificate_authorities extension as specified, by either parsing the provided CA list when present or setting up an empty list if not. This directly addresses the use of the certificate_authorities extension per the RFC. However, the function does not address the evaluation of an If-None-Match header field specified in the additional context.'}}]","The function do_read_certificate_request contains logic to process a CertificateRequest message and specifically handles the certificate_authorities extension by extracting and parsing the list of certificate authorities, which aligns with the RFC requirement about indicating supported CAs. However, it does not incorporate any logic pertaining to evaluating an If-None-Match header field as described in the specification context. Since only part of the specified conditions/actions are handled within this function, it is classified as partially matching the RFC constraints.",success,
8463,do_read_certificate_request,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function, do_read_certificate_request, is dedicated to processing the CertificateRequest message during the TLS handshake and managing handshake state transitions. It does not include any logic to ensure that Application Data is not sent prior to the Finished message, as required by the RFC specification. Therefore, no part of the function visibly implements the constraint that Application Data MUST NOT be sent before the Finished message (e.g., conditions C1, actions A1, etc.).",success,
8463,do_read_certificate_request,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u8_length_prefixed(&body, &context) ||\n      CBS_len(&context) != 0 ||\n      !CBS_get_u16_length_prefixed(&body, &extensions) ||\n      CBS_len(&body) != 0 ||\n      !ssl_parse_extensions(&extensions, &alert, {&sigalgs, &ca},\n                            /*ignore_unknown=*/true) ||\n      !sigalgs.present ||\n      !CBS_get_u16_length_prefixed(&sigalgs.data, &supported_signature_algorithms) ||\n      !tls1_parse_peer_sigalgs(hs, &supported_signature_algorithms)) { ... }', 'explanation': 'This code block verifies the structure of the certificate request message. It checks that the lengths and format conform to expectations. If any part of the parsing fails, it indicates a malformed message.'}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\nOPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\nreturn ssl_hs_error;', 'explanation': 'Upon detecting any parsing error, the function sends a fatal alert with the decode_error (SSL_AD_DECODE_ERROR) and returns an error state, terminating the connection in accordance with the RFC.'}}]","The function explicitly checks for correct parsing of the certificate request message and, if any part fails, it sends a decode_error alert before terminating the connection. This behavior directly implements the RFC requirement that peers must terminate the connection with a decode_error alert when a message cannot be parsed correctly.",success,
8463,do_read_certificate_request,"The ""signature_algorithms"" extension MUST be specified, and other extensions may optionally be included if defined for this message.",182,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u8_length_prefixed(&body, &context) ||\n      CBS_len(&context) != 0 ||\n      !CBS_get_u16_length_prefixed(&body, &extensions) ||\n      CBS_len(&body) != 0 ||\n      !ssl_parse_extensions(&extensions, &alert, {&sigalgs, &ca},\n                             /*ignore_unknown=*/true) ||\n      !sigalgs.present ||\n      !CBS_get_u16_length_prefixed(&sigalgs.data, &supported_signature_algorithms) ||\n      !tls1_parse_peer_sigalgs(hs, &supported_signature_algorithms)) { ... }', 'explanation': ""The code enforces that the 'signature_algorithms' extension (sigalgs) must be present by explicitly checking for 'sigalgs.present'. If the extension is missing, it sends an alert and returns an error. This directly implements the spec requirement that the 'signature_algorithms' extension must be specified. Additionally, the optional 'certificate_authorities' extension is processed if present.""}}]","The function directly implements the specified RFC requirement by ensuring that a 'signature_algorithms' extension is present in the CertificateRequest message. It checks for the mandatory presence and processes other extensions (like certificate_authorities) optionally, which fulfills both parts of the RFC specification. No dependency logic is used; the implementation is entirely contained within the function.",success,
8465,do_read_server_certificate_verify,The receiver of a CertificateVerify message MUST verify the signature field.,230,Fully Matches,"[{'C1': {'code': 'if (!ssl_check_message_type(ssl, msg, SSL3_MT_CERTIFICATE_VERIFY) ||\n      !tls13_process_certificate_verify(hs, msg) ||\n      !ssl_hash_message(hs, msg)) { ... }', 'explanation': 'This code segment directly ensures that the CertificateVerify message is correctly processed by first checking its message type, then calling tls13_process_certificate_verify(hs, msg) to verify the signature field (as required by the RFC), and finally incorporating the message into the handshake hash. This fulfills the requirement that the receiver MUST verify the signature field.'}}]","The function do_read_server_certificate_verify retrieves the CertificateVerify message, validates that it is of the correct type, explicitly processes the certificate verify message via tls13_process_certificate_verify (which encapsulates the signature verification logic), and then updates the handshake hash. This sequence of operations directly addresses the specification requirement that the receiver of a CertificateVerify message MUST verify the signature field, thereby fully satisfying the constraint.",success,
8467,do_read_server_finished,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Fully Matches,"[{'A1': {'code': 'if (ssl->method->has_unprocessed_handshake_data(ssl)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);\n    OPENSSL_PUT_ERROR(SSL, SSL_R_EXCESS_HANDSHAKE_DATA);\n    return ssl_hs_error;\n}', 'explanation': ""This code segment checks if there is unprocessed handshake data remaining (i.e. an unexpected message order) and, if so, aborts the handshake by sending an 'unexpected_message' alert and returns an error status, which directly implements the action required by the RFC.""}}]","The function inspects if there is any additional handshake data after processing the finished message. If such data exists, it sends an unexpected_message alert (using SSL_AD_UNEXPECTED_MESSAGE) and aborts the handshake, precisely matching the RFC requirement that a handshake message received out of order must result in an immediate handshake abort with the appropriate alert.",success,
8467,do_read_server_finished,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function processes the Finished message and checks for extra handshake data (ensuring that no additional handshake messages are present after the Finished message), but it does not explicitly address the RFC requirement: 'Application Data MUST NOT be sent prior to sending the Finished message.' There is no logic within the function that verifies or prevents premature sending of Application Data. Therefore, the function does not implement the specified spec constraint by itself.",success,
8468,do_send_end_of_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'C1': {'code': 'if (ssl->s3->early_data_accepted) {\n    // DTLS and QUIC omit the EndOfEarlyData message. See RFC 9001, section 8.3,\n    // and RFC 9147, section 5.6.\n    if (!SSL_is_quic(ssl) && !SSL_is_dtls(ssl)) {\n      ScopedCBB cbb;\n      CBB body;\n      if (!ssl->method->init_message(ssl, cbb.get(), &body,\n                                     SSL3_MT_END_OF_EARLY_DATA) ||\n          !ssl_add_message_cbb(ssl, cbb.get())) {\n        return ssl_hs_error;\n      }\n    }\n\n    if (!close_early_data(hs, ssl_encryption_handshake)) {\n      return ssl_hs_error;\n    }\n  }', 'explanation': 'The function explicitly checks if early data was accepted and then, rather than attempting to resend it, sends an EndOfEarlyData message (except for protocols that omit it) and properly closes out the early data state. This behavior ensures that early data is not automatically resent, which directly complies with the RFC recommendation.'}}]","The provided function focuses solely on finalizing early data by sending the EndOfEarlyData message and closing out the early data session. There is no logic included that would automatically trigger a retransmission of early data. Thus, the function visibly implements the RFC's guideline that a TLS implementation should not automatically resend early data, handling the condition completely within its own code.",success,
8469,do_send_client_encrypted_extensions,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided code function is dedicated to sending an EncryptedExtensions message that contains application settings, selecting between new or old code points based on the configuration. It does not include any logic to examine, ignore, or prevent the processing or inclusion of the status_request_v2 extension in any messages. Since the RFC explicitly requires that servers must not send the status_request_v2 extension in certain messages, and the function does not address or check for this condition within its own implementation, it does not fulfill the specified RFC constraints by itself.",success,
8471,do_send_client_certificate,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The RFC specification requires that application data must not be sent before the Finished message. However, the function 'do_send_client_certificate' is solely responsible for processing and sending a client certificate during the TLS handshake. There is no logic in the function that addresses the ordering of application data versus the Finished message. As such, none of the labeled conditions or actions from the spec constraints are visibly implemented within this function.",success,
8473,do_complete_second_flight,Any records following a Finished message MUST be encrypted under the appropriate application traffic key as described in Section 7.2.,234,Fully Matches,"[{'A1': {'code': 'if (!tls13_add_finished(hs)) {\n    return ssl_hs_error;\n}\n\n// Derive the final keys and enable them.\nif (!tls13_set_traffic_key(ssl, ssl_encryption_application, evp_aead_seal,\n                           hs->new_session.get(),\n                           hs->client_traffic_secret_0) ||\n    !tls13_set_traffic_key(ssl, ssl_encryption_application, evp_aead_open,\n                           hs->new_session.get(),\n                           hs->server_traffic_secret_0) ||\n    !tls13_derive_resumption_secret(hs)) {\n  return ssl_hs_error;\n}', 'explanation': 'This segment shows that immediately after sending the Finished message, the function derives and enables the application traffic keys (for both sealing and opening). This ensures that any records following the Finished message will be encrypted under the appropriate application traffic keys as required by the RFC.'}}]",The provided function explicitly implements the requirement of encrypting records following the Finished message by first sending the Finished message (via tls13_add_finished) and then deriving/enabling the application traffic keys. This meets the RFC specification since subsequent records will use these keys for encryption.,success,
8473,do_complete_second_flight,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Fully Matches,"[{'A1': {'code': '  // Send a Finished message.\n  if (!tls13_add_finished(hs)) {\n    return ssl_hs_error;\n  }\n\n  // Derive the final keys and enable them.\n  if (!tls13_set_traffic_key(ssl, ssl_encryption_application, evp_aead_seal,\n                             hs->new_session.get(),\n                             hs->client_traffic_secret_0) ||\n      !tls13_set_traffic_key(ssl, ssl_encryption_application, evp_aead_open,\n                             hs->new_session.get(),\n                             hs->server_traffic_secret_0) ||\n      !tls13_derive_resumption_secret(hs)) {\n    return ssl_hs_error;\n  }', 'explanation': 'This code sends the Finished message (via tls13_add_finished) before derivation and activation of the application traffic keys. By enabling application data encryption only after sending the Finished message, it enforces the RFC requirement that application data MUST NOT be sent prior to the Finished message.'}}]","The function correctly orders operations so that the Finished message is sent before any application data can be transmitted. The finished message is added and checked before the application traffic keys are set, ensuring that application data is not sent before the Finished message. Thus, this function’s logic visibly implements the specified RFC requirement.",success,
8473,do_complete_second_flight,A Finished message MUST be sent regardless of whether the Certificate message is empty.,188,Fully Matches,"[{'A1': {'code': 'if (!tls13_add_finished(hs)) {\n    return ssl_hs_error;\n}', 'explanation': 'This code segment unconditionally sends the Finished message, thereby meeting the specification that a Finished message MUST be sent regardless of whether the Certificate message is empty.'}}]",The function ensures that a Finished message is sent by calling tls13_add_finished(hs) without any precondition based on the certificate or its content. This direct implementation fulfills the core requirement of the RFC specification.,success,
8474,tls13_client_handshake,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function implements a state machine for the TLS 1.3 client handshake, managing various handshake stages (e.g., reading messages and sending responses) based on its internal state. However, it does not contain any explicit logic to enforce the rule from the RFC specification that ""Application Data MUST NOT be sent prior to sending the Finished message."" There is no condition or check within the function_body that verifies whether application data is being sent before the Finished message. Furthermore, while the function does process handshake messages such as server_finished, it does not take any explicit action to ensure application data is withheld until after the Finished message is exchanged. Therefore, no segment of the code addresses the specified condition (labeled, for example, as C1) or an action (labeled, for example, as A1) associated with this RFC requirement. All protocol order and integrity handling related to the Finished message and subsequent application data appears to be handled elsewhere outside this function.",success,
8474,tls13_client_handshake,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided code function implements a TLS 1.3 client handshake state machine by switching between various handshake states and executing corresponding functions. However, there is no visible logic within this function that addresses the specific TLS specification requirement that early data should not be automatically resent (i.e., the implementation of preventing automatic retransmission of early data). The function does not include any conditions or actions (labeled as C1, A1, etc.) that enforce this constraint, as it merely calls other functions in response to state changes without decision-making for retransmission. Therefore, the function does not meet any of the spec conditions or actions related to the early data retransmission policy.",success,
8475,tls13_client_handshake_state,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function tls13_client_handshake_state only maps an internal TLS 1.3 state to a corresponding string description. It does not include any logic that addresses the RFC specification constraint regarding the automatic resending of early data. There is no conditional check or mechanism to prevent retransmission of early data, nor any handling related to the application’s decision on retransmission. Therefore, none of the spec constraints (e.g., C1 or A1) are visibly implemented within this function.",success,
8476,tls13_process_new_session_ticket,"Servers MAY send multiple tickets on a single connection, either immediately after each other or after specific events (see Appendix C.4).",240,Does Not Match,[],"The RFC states that servers MAY send multiple tickets on a single connection, implying that implementations need to be prepared to handle multiple new session ticket messages—either in sequence or triggered by certain events. In the provided function, the code is focused solely on processing a single new session ticket message (contained within 'msg') and does not include any logic to iterate over or handle multiple tickets in one invocation. All the handling in this function assumes that one ticket is processed at a time, and there is no explicit mechanism within this function to support the receipt of consecutive or multiple tickets as per the RFC's guidance. Therefore, the function does not visibly address the specified RFC constraint with respect to multiple tickets.",success,
8477,tls13_create_session_with_ticket,"The server MAY also send unsolicited extensions in the NewSessionTicket, though the client does not respond directly to these.",58,Fully Matches,"[{'A1': {'code': 'if (!ssl_parse_extensions(&extensions, &alert, {&early_data, &flags}, /*ignore_unknown=*/true)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n    return nullptr;\n}', 'explanation': 'This segment processes unsolicited extensions from the NewSessionTicket by parsing any present extensions and ignoring unknown ones, in accordance with the RFC requirement that the server may send unsolicited extensions which the client does not directly respond to.'}}]","The function 'tls13_create_session_with_ticket' fully addresses the aspect of the RFC that permits the server to send unsolicited extensions in the NewSessionTicket. It does so by attempting to parse the extensions using ssl_parse_extensions with the ignore_unknown flag set to true, thereby ensuring that any unsolicited extensions are handled (or ignored) appropriately without requiring a direct client response. This implementation detail is self-contained in the function and meets the relevant specification.",success,
8477,tls13_create_session_with_ticket,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (SSL_is_quic(ssl) && session->ticket_max_early_data != 0xffffffff) {\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n      OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n      return nullptr;\n    }', 'explanation': ""This segment checks the early_data extension for QUIC. If the ticket_max_early_data is semantically invalid (i.e., not equal to the fixed value 0xffffffff), it terminates the connection by sending an 'illegal_parameter' alert as required by the RFC.""}}]","The function partially implements the RFC specification by handling one key scenario. It verifies incoming parameters and, in the case of a semantically invalid early_data parameter for QUIC, it sends an 'illegal_parameter' alert and terminates the session. However, other error conditions (such as those resulting in a DECODE_ERROR alert) do not use the specified 'illegal_parameter' alert. Therefore, only a part of the RFC's requirement to terminate connections with an 'illegal_parameter' alert is addressed within this function, leading to a 'Partially Matches' outcome.",success,
8477,tls13_create_session_with_ticket,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u32(body, &server_timeout) ||\n      !CBS_get_u32(body, &session->ticket_age_add) ||\n      !CBS_get_u8_length_prefixed(body, &ticket_nonce) ||\n      !CBS_get_u16_length_prefixed(body, &ticket) ||\n      CBS_len(&ticket) == 0 ||\n      !session->ticket.CopyFrom(ticket) ||\n      !CBS_get_u16_length_prefixed(body, &extensions) ||\n      CBS_len(body) != 0) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    return nullptr;\n  }', 'explanation': ""This segment checks multiple parts of the message for correct parsing. If any of the expected parsed elements are missing or extra data remains, it sends a 'decode_error' alert and terminates processing by returning nullptr, which directly implements the RFC requirement.""}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);', 'explanation': ""This call is used to send the 'decode_error' alert upon detecting a parsing error, directly fulfilling the RFC mandate to terminate the connection with a decode_error alert when message parsing fails.""}}]","The function actively verifies the structure and contents of the received message. When a parsing error is detected—be it from an incorrect length, out-of-bound data, or extra data remaining—it immediately calls ssl_send_alert with the 'decode_error' alert, and returns nullptr to terminate further processing. This directly mirrors the RFC’s requirement to terminate the connection on parsing errors, thereby fully meeting the specified condition and action as implemented within the function_body.",success,
8477,tls13_create_session_with_ticket,"In TLS 1.3, a client receiving a CertificateRequest or NewSessionTicket MUST also ignore all unrecognized extensions.",359,Fully Matches,"[{'A1': {'code': 'if (!ssl_parse_extensions(&extensions, &alert, {&early_data, &flags}, /*ignore_unknown=*/true)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n    return nullptr;\n}', 'explanation': ""This code segment processes the extensions in a NewSessionTicket message and explicitly passes 'ignore_unknown' as true to ssl_parse_extensions, which ensures that any unrecognized extensions are ignored as required by the RFC.""}}]","The provided function 'tls13_create_session_with_ticket' implements the processing of a NewSessionTicket in TLS 1.3. In doing so, it correctly calls ssl_parse_extensions with the flag 'ignore_unknown' set to true. This directly addresses the RFC requirement that, upon receiving a CertificateRequest or NewSessionTicket, a client must ignore all unrecognized extensions. Therefore, the function's internal logic fully meets the specified RFC constraint.",success,
8477,tls13_create_session_with_ticket,A server MAY treat a ticket as valid for a shorter period of time than what is stated in the ticket_lifetime.,248,Fully Matches,"[{'C1': {'code': 'if (session->timeout > server_timeout) {\n    session->timeout = server_timeout;\n}', 'explanation': ""This segment directly implements the RFC requirement by capping the session's timeout to the server_timeout value, which allows a ticket to be treated as valid for a shorter period than indicated by the ticket_lifetime.""}}]","The function extracts a server-advertised timeout (server_timeout) from the ticket data and compares it with the session's current timeout. When the current timeout is greater than the server_timeout, it resets the session's timeout to the lower value. This logic directly corresponds to the RFC specification that permits a server to treat a ticket as valid for a shorter period than stated. The implementation is localized within the function_body, fulfilling the relevant constraint (labeled C1).",success,
8477,tls13_create_session_with_ticket,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function focuses solely on creating a TLS 1.3 session from a ticket, processing parameters like server timeout, ticket nonce, and early data, but it does not contain any logic addressing the prohibition of offering or negotiating RC4 cipher suites. No code segments in the function check for, filter out, or otherwise manage RC4 ciphers as required by the RFC specification, so the function does not meet the specified constraints.",success,
8477,tls13_create_session_with_ticket,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function is focused on creating a TLS session from a ticket and parsing various ticket-related extensions, including early data. Although it does parse the early data extension and extracts parameters like ticket_max_early_data, it does not implement any logic regarding whether early data should be automatically resent or not. The RFC specification requires that a TLS implementation should not automatically resend early data and leave that decision up to the application. This function does not contain any explicit mechanism to prevent automatic resending of early data. As such, none of the spec constraints (e.g., related to the decision logic for resending early data) are visibly implemented within this function.",success,
8477,tls13_create_session_with_ticket,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u32(body, &server_timeout) ||\n    !CBS_get_u32(body, &session->ticket_age_add) ||\n    !CBS_get_u8_length_prefixed(body, &ticket_nonce) ||\n    !CBS_get_u16_length_prefixed(body, &ticket) ||\n    CBS_len(&ticket) == 0 ||\n    !session->ticket.CopyFrom(ticket) ||\n    !CBS_get_u16_length_prefixed(body, &extensions) ||\n    CBS_len(body) != 0) {\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n  OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n  return nullptr;\n}', 'explanation': 'This code segment verifies all expected parameters from the ticket body. If any decoding step fails (i.e. the conditions are not met), it leads directly to aborting the handshake, which matches the condition requirement of the RFC.'}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);', 'explanation': 'When any of the data decoding checks fail, the function calls ssl_send_alert with SSL_AD_DECODE_ERROR, thus aborting the handshake as required by the RFC.'}}]","The function implements the RFC requirement stating that if the provided data does not meet expected structure or content, the handshake must be aborted with a 'decode_error' alert. This is directly visible in multiple error-checking branches where, upon detecting invalid or unexpected data (both in the main ticket parameters and in the early_data extension), the function immediately calls ssl_send_alert with the decode error alert. Thus, within its own logic (and independent of its dependencies), the function fully addresses the labeled RFC condition (C1) and action (A1).",success,
8484,ssl_parse_cert_chain,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Does Not Match,[],"The RFC specification requires that when an implementation sends an alert (e.g., to terminate the connection or abort the handshake), it MUST include the specific alert value. The function ssl_parse_cert_chain only sets the out_alert variable on error conditions (such as decode error or internal error) without actually performing any logic to send an alert or manage connection closure. In other words, while the function does set alert values when errors occur, it does not implement the higher-level protocol behavior mandated by the RFC (i.e., sending the X alert to terminate connection or abort handshake). Therefore, within its own logic, the function does not address any of the labeled conditions (like C1) or actions (like A1) specified in the RFC constraints.",success,
8484,ssl_parse_cert_chain,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u24_length_prefixed(cbs, &certificate_list)) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    return false;\n}', 'explanation': 'This segment checks if the overall certificate list length prefix is valid. Failing to parse the expected length (which might occur if the length extends beyond the message boundary) immediately sets the decode_error alert, fulfilling the RFC requirement.'}}, {'A1': {'code': 'if (!CBS_get_u24_length_prefixed(&certificate_list, &certificate) || CBS_len(&certificate) == 0) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_CERT_LENGTH_MISMATCH);\n    return false;\n}', 'explanation': ""Within the loop, this segment similarly validates each certificate's length and rejects certificates with a zero-length. This error handling, which sets the decode_error alert, directly implements the action of terminating the connection on a parsing error.""}}]","The function 'ssl_parse_cert_chain' directly implements RFC behavior by performing length-prefixed parsing of the certificate chain. It verifies that the encoded lengths (both for the overall list and individual certificates) are within bounds. On detecting a parsing error—whether caused by a length that extends beyond what is available or an out-of-range value—it sets the alert to SSL_AD_DECODE_ERROR and returns false. This ensures that any message that cannot be parsed correctly results in an immediate error as mandated by the RFC, thereby fully meeting the specified conditions and actions in the context of message parsing.",success,
8491,SSL_parse_CA_list,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16_length_prefixed(cbs, &child)) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_LENGTH_MISMATCH);\n    return nullptr;\n}\n\nwhile (CBS_len(&child) > 0) {\n    CBS distinguished_name;\n    if (!CBS_get_u16_length_prefixed(&child, &distinguished_name)) {\n        *out_alert = SSL_AD_DECODE_ERROR;\n        OPENSSL_PUT_ERROR(SSL, SSL_R_CA_DN_TOO_LONG);\n        return nullptr;\n    }\n    ...\n}\n\nif (!ssl->ctx->x509_method->check_CA_list(ret.get())) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    return nullptr;\n}', 'explanation': 'The function checks for proper message length parsing and if any length constraint is violated (i.e. parsing fails due to invalid or dangling length fields), it sets the decode error alert (SSL_AD_DECODE_ERROR) and returns a null pointer, which signals the connection should be terminated.'}}]","The provided function implements parsing of a CA list by checking the lengths of the message segments using u16-prefixed length checks. In every scenario where the syntax of the message could be interpreted as invalid—whether due to an overall length mismatch, an out-of-bound length in the inner loop, or an invalid CA list as determined by check_CA_list—the function sets the 'decode_error' alert (SSL_AD_DECODE_ERROR) and returns a null pointer. This behavior directly corresponds to the spec requirement that peers must terminate the connection with a 'decode_error' alert if the message cannot be parsed according to the syntax. Therefore, the function visibly addresses the necessary condition and action as prescribed by the RFC specification.",success,
8498,ssl_check_leaf_certificate,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'assert(ssl_protocol_version(hs->ssl) < TLS1_3_VERSION);', 'explanation': 'This assertion explicitly checks that the negotiated TLS version is less than TLS 1.3, hence enforcing the RFC specification that TLS 1.3 must not be negotiated.'}}]","The function begins by asserting that the SSL protocol version is lower than TLS 1.3, which directly meets the specification constraint. Although the rest of the function deals with certificate type and key validity, the central requirement about TLS 1.3 is completely and visibly implemented in the function body.",success,
8919,tls_new,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specifies that implementations MUST NOT use the Truncated HMAC extension for AEAD algorithms. The provided function does not contain any logic that checks or enforces this requirement. While the function does create AEAD contexts with CreateNullCipher() when SSL is not DTLS, there is no evidence in the code that it prevents or manages the Truncated HMAC extension usage. Therefore, the function does not visibly address any spec constraints related to disallowing the Truncated HMAC extension.",success,
10029,CreateSessionWithTicket,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The RFC specification indicates that the OpenPGP certificate type MUST NOT be used with TLS 1.3. However, the function 'CreateSessionWithTicket' does not perform any checks or validations regarding the use of the OpenPGP certificate type in relation to the TLS protocol version. It simply creates an SSL session, sets the protocol version based on the provided parameter, and applies a ticket. There is no logic in the function that identifies or blocks the OpenPGP certificate type when TLS 1.3 is in use. The code addressing Transfer-Encoding in HTTP contexts also does not relate to the OpenPGP certificate type constraint, and no part of the function directly implements the specified condition or action from the RFC.",success,
10031,GetClientHelloLen,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The RFC specification requires that OpenPGP certificate types MUST NOT be used with TLS 1.3. However, in the provided function, there is no logic that checks or prohibits the use of OpenPGP certificate types in conjunction with TLS 1.3. The function primarily constructs a ClientHello message by setting up an SSL context, session, and configuring cipher lists and protocol version, but it does not reference or enforce any rules about certificate types. Therefore, no labeled condition (e.g., C1) or action (e.g., A1) from the spec constraints is implemented within this function.",success,
10031,GetClientHelloLen,Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.,79,Does Not Match,[],"The function 'GetClientHelloLen' is focused on setting up a TLS context, session, and obtaining a ClientHello message, with no logic addressing HTTP headers or cookies, nor does it incorporate any handling of the '100-continue' expectation. There is no visible implementation within the function that prevents the use of cookies in the initial ClientHello in subsequent connections, nor does it check or handle the 'Expect: 100-continue' condition as defined by the RFC specification.",success,
10032,TEST,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function 'ST(SSLTest, Padding)' focuses solely on testing the padding behavior of TLS ClientHello messages under various scenarios (e.g., differences between TLS 1.2 and TLS 1.3). There is no logic within the function that addresses the RFC6091 requirement concerning the prohibition of the OpenPGP certificate type with TLS 1.3. No code segment checks, rejects, or handles OpenPGP certificate types, and thus the function does not visibly implement any constraints related to the provided spec. Dependencies or external configuration may exist elsewhere, but within this function itself, there is no implementation of the RFC condition.",success,
10036,GetTestCertificate,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The function GetTestCertificate() only returns a test certificate created from a hard-coded PEM string and does not contain any logic that addresses the TLS 1.3 requirement regarding the status_request_v2 extension. There is no implementation in the function that checks for or acts upon the ClientHello message, nor does it enforce the rules stated in the RFC specification. Therefore, no part of the code function implements any of the labeled conditions or actions.",success,
10037,GetTestCertificateBuffer,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function GetTestCertificateBuffer() simply returns a certificate buffer generated from a hard-coded PEM string. It does not implement or include any logic related to processing ClientHello messages, ignoring status_request_v2 extensions, or handling Transfer-Encoding versus Content-Length fields. In other words, no part of the function addresses the TLS 1.3 or HTTP message framing constraints specified.",success,
10045,GetChainTestIntermediateBuffer,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided code function simply returns a CRYPTO_BUFFER constructed from a statically defined PEM certificate. It does not contain any logic that addresses any of the spec constraints related to TLS 1.3 servers ignoring the status_request_v2 extension or handling HTTP Content-Length and Transfer-Encoding header fields. There is no visible code in the function that checks for, manipulates, or omits any information related to the conditions (C1, C2, etc.) or actions (A1, A2, etc.) specified. Therefore, no part of the function meets any of the given constraints.",success,
10059,MakeECHConfig,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The specified RFC constraint requires that a TLS implementation SHOULD NOT automatically resend early data. In contrast, the provided code function, MakeECHConfig, solely constructs an ECH configuration binary blob by assembling various parameters with the CBB API. It does not address any logic related to the decision of resending early data or handling TLS early data retransmission. Additionally, the function has no connection to redirection behavior mentioned in the spec context regarding the 302 (Found) status, confirming that it does not implement any of the labeled conditions or actions.",success,
10059,MakeECHConfig,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification requires that implementations must not use the Truncated HMAC extension. The provided function MakeECHConfig constructs an ECH configuration by encoding various parameters such as the version, cipher suites, and public key, but it does not contain any logic that prevents or checks for the use of the truncated HMAC extension. There is no code in the function that directly addresses the requirement, so in isolation this function does not implement the specification constraint.",success,
10059,MakeECHConfig,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The provided code function 'MakeECHConfig' constructs an ECH configuration using the parameters provided, including version, config_id, kem_id, public key, cipher suites, name, and extensions. However, there is no logic in this function that checks for or prevents the inclusion of a 'psk_key_exchange_modes' extension. The function simply adds the extensions from params without filtering or excluding any particular ones. Therefore, it does not address the spec constraint that specifies 'The server MUST NOT send a ""psk_key_exchange_modes"" extension.'",success,
10059,MakeECHConfig,Servers MUST NOT send this extension.,115,Does Not Match,[],"The provided function, MakeECHConfig, is responsible for building an ECH configuration structure by encoding various fields into a byte buffer. There is no logic in this function that checks whether the code is running in a server context or prevents the server from sending the extension, as required by the spec (""Servers MUST NOT send this extension.""). Additionally, although the sr_context provided details how an If-Unmodified-Since header should be evaluated, the function does not reference any logic related to HTTP headers or timestamp evaluations. Therefore, no part of the function implements or enforces the spec conditions or actions.",success,
10062,TEST,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The provided code function is concerned with marshaling ECH configurations, generating keys, and constructing an ECHConfigList. It does not contain any logic that addresses the RFC specification stating that ""The server MUST NOT send a 'psk_key_exchange_modes' extension."" There is no reference to 'psk_key_exchange_modes' or any logic that explicitly prevents its transmission. Therefore, no condition or action (e.g., C1, A1) from the RFC constraint is implemented within this function.",success,
10062,TEST,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided code function is focused on the marshaling and testing of ECH configurations using HPKE keys. It does not include any logic, checks, or references regarding the use or prohibition of the Truncated HMAC extension as specified by the RFC. Since no part of the function implements any condition or action related to excluding the Truncated HMAC extension, the function does not meet the spec constraint.",success,
10062,TEST,Servers MUST NOT send this extension.,115,Does Not Match,[],"The provided function is focused on constructing and marshaling ECH (Encrypted Client Hello) configurations for testing purposes. It neither contains logic nor conditions that enforce or check the RFC requirement that “Servers MUST NOT send this extension.” There is no visible code addressing any condition (e.g., C1) or action (e.g., A1) related to preventing the server from sending the extension. Consequently, the function does not implement the specified spec constraints.",success,
10066,TEST,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided code function does not contain any logic that addresses the RFC specification regarding the prohibition of the Truncated HMAC extension. Instead, the function focuses on testing various unsupported ECH (Encrypted ClientHello) configurations (such as unsupported versions, cipher suites, extensions, and invalid public names). There is no visible implementation attempting to enforce or check that the Truncated HMAC extension is not used, so it does not fulfill the specified condition.",success,
10093,TEST_P,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Fully Matches,"[{'C1': {'code': 'EXPECT_EQ(-1, SSL_write(ssl.get(), ""a"", 1));\nEXPECT_EQ(SSL_ERROR_SSL, SSL_get_error(ssl.get(), -1));\nEXPECT_EQ(err, ERR_get_error());', 'explanation': 'The RFC specifies that application data must not be sent prior to the Finished message. In this function, after the handshake fails (and an alert is sent), an attempt is made to send application data using SSL_write. The test verifies that this call fails, returns the same error as the handshake error, and that nothing extra is written. This directly enforces the requirement.'}}]","The function explicitly tests that after a failed handshake (with a fatal alert already sent), any attempt to write application data results in an error and no extra data is transmitted. By doing this, it ensures that application data is not sent before the Finished message, which is in accordance with the RFC specification.",success,
10094,TEST,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'C1': {'code': 'EXPECT_EQ(-1, SSL_write(client.get(), ""a"", 1));\nEXPECT_EQ(SSL_ERROR_SSL, SSL_get_error(client.get(), -1));\nEXPECT_TRUE(ErrorEquals(ERR_get_error(), ERR_LIB_SSL, SSL_R_WRONG_VERSION_ON_EARLY_DATA));', 'explanation': 'This segment confirms that after a handshake error due to a TLS version mismatch when early data was used, no data is automatically retransmitted. The write fails with the expected error, indicating that the implementation does not automatically resend early data.'}}, {'A1': {'code': 'ASSERT_TRUE(BIO_mem_contents(mem.get(), &unused, &len));\nEXPECT_EQ(0u, len);', 'explanation': 'This portion of the test checks that nothing has been written to the underlying transport (i.e., no early data was resent), thereby ensuring that the application controls retransmission decisions as mandated by the specification.'}}]","The function sets up an early-data-capable session and deliberately triggers a TLS 1.2 negotiation, which is incompatible with early data. It then verifies that the handshake fails and that subsequent write attempts fail with the specific error SSL_R_WRONG_VERSION_ON_EARLY_DATA. Moreover, it confirms that no data is automatically sent to the transport. These checks directly address and implement the spec constraint that a TLS implementation should not automatically resend early data, leaving retransmission decisions to the application.",success,
10094,TEST,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Partially Matches,"[{'A1': {'code': 'EXPECT_EQ(-1, SSL_write(client.get(), ""a"", 1));\nEXPECT_EQ(SSL_ERROR_SSL, SSL_get_error(client.get(), -1));\nEXPECT_TRUE(ErrorEquals(ERR_get_error(), ERR_LIB_SSL, SSL_R_WRONG_VERSION_ON_EARLY_DATA));\n\nASSERT_TRUE(BIO_mem_contents(mem.get(), &unused, &len));\nEXPECT_EQ(0u, len);', 'explanation': 'The RFC requires that if 0-RTT data is rejected, the TLS implementation MUST NOT automatically resend it. This test intentionally causes early data to be rejected (by negotiating TLS 1.2, which does not support 0-RTT) and then verifies that subsequent writes (SSL_write) fail with the expected error, and no data is written to the transport. This directly verifies the behavior described by that action.'}}]","The function sets up early data contexts and deliberately causes a scenario where early data is rejected (by forcing TLS 1.2 on the server). It then checks that after the rejection, attempts to write data fail, and nothing is sent. This behavior confirms that 0-RTT data is not automatically resent, fulfilling the RFC requirement related to resending rejected early data (labeled here as A1). However, the other part of the RFC (that TLS implementations MUST NOT enable 0-RTT unless explicitly requested) is not directly addressed by additional checks within this function. Therefore, while the test covers one major aspect of the requirement, it only partially matches the overall specification.",success,
10094,TEST,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The RFC specification requires that SSL 2.0 MUST NOT be negotiated, but the provided function_body solely tests for a wrong version error in an early data context using TLS 1.2. There is no code present that verifies the prohibition of SSL 2.0 negotiation or explicitly prevents its usage. None of the labeled conditions (e.g., C1) or actions (e.g., A1) related to disallowing SSL 2.0 negotiation are implemented in this function itself.",success,
10094,TEST,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Does Not Match,[],"The provided function does not implement or test any logic related to preventing the negotiation of SSL 3.0 as required by the RFC. The RFC specifies that SSL 3.0 must not be negotiated, but the code instead focuses on setting up early data contexts and testing the error condition SSL_R_WRONG_VERSION_ON_EARLY_DATA when an inappropriate version (TLS 1.2 used with early data) is encountered. There is no visible handling or rejection of SSL 3.0 within this function, so the function does not address any labeled spec constraints related to SSL 3.0.",success,
10094,TEST,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function tests behavior related to early data and protocol version mismatches, specifically handling errors when early data is used with TLS 1.2. There is no code in this function that addresses the RFC requirement to not offer or negotiate RC4 cipher suites. Therefore, none of the spec constraints (e.g., C1 for the RC4 prohibition) are met within this function body.",success,
10094,TEST,A client that attempts to send 0-RTT data MUST fail a connection if it receives a ServerHello with TLS 1.2 or older.,384,Fully Matches,"[{'C1': {'code': 'EXPECT_EQ(-1, SSL_do_handshake(client.get()));\nEXPECT_TRUE(ErrorEquals(ERR_get_error(), ERR_LIB_SSL, SSL_R_WRONG_VERSION_ON_EARLY_DATA));', 'explanation': 'The code explicitly tests that when a client configured for early data receives a ServerHello indicating TLS1.2 (set via SSL_set_max_proto_version(server.get(), TLS1_2_VERSION)), the handshake fails with the error SSL_R_WRONG_VERSION_ON_EARLY_DATA. This directly implements the requirement that a client attempting 0-RTT must fail the connection if the server is TLS 1.2 or older.'}}, {'A1': {'code': 'EXPECT_EQ(-1, SSL_write(client.get(), ""a"", 1));\nEXPECT_TRUE(ErrorEquals(ERR_get_error(), ERR_LIB_SSL, SSL_R_WRONG_VERSION_ON_EARLY_DATA));', 'explanation': 'Following the failed handshake, the test verifies that any subsequent data write (attempting 0-RTT) fails with the same error, reinforcing that the connection is invalid for early data use.'}}]","The function sets up a 0-RTT enabled client and server, forces the server to use TLS 1.2, and then checks that the client's handshake fails when processing the ServerHello message due to the use of an unsupported protocol version for 0-RTT. It also confirms that writing application data fails with the same error, which satisfies the RFC that mandates connection failure under these conditions. All pertinent behaviors are implemented directly within this function.",success,
10094,TEST,Note that 0-RTT data is not compatible with older servers and SHOULD NOT be sent absent knowledge that the server supports TLS 1.3,378,Fully Matches,"[{'C1': {'code': 'EXPECT_TRUE(SSL_in_early_data(client.get()));\nEXPECT_EQ(-1, SSL_do_handshake(server.get()));\nEXPECT_EQ(SSL_ERROR_WANT_READ, SSL_get_error(server.get(), -1));\nEXPECT_EQ(TLS1_2_VERSION, SSL_version(server.get()));', 'explanation': ""This part of the code sets up an early data–capable session but forces the server to negotiate TLS 1.2 (an older version) rather than TLS 1.3. This directly tests the condition that early (0-RTT) data should not be sent when the server does not support TLS 1.3, meeting the specification's condition.""}}, {'A1': {'code': 'EXPECT_EQ(-1, SSL_write(client.get(), ""a"", 1));\nEXPECT_EQ(SSL_ERROR_SSL, SSL_get_error(client.get(), -1));\nEXPECT_TRUE(ErrorEquals(ERR_get_error(), ERR_LIB_SSL, SSL_R_WRONG_VERSION_ON_EARLY_DATA));', 'explanation': 'After initiating a handshake with early data, the code confirms that attempting to write data fails with the specific error SSL_R_WRONG_VERSION_ON_EARLY_DATA. This check ensures that no early data is actually sent when TLS 1.3 is not negotiated, fulfilling the spec action.'}}]","The function creates early-data enabled SSL contexts and a session, then deliberately forces the server to operate under TLS 1.2. By doing so, the function verifies that the client remains in the early data state initially but eventually fails the handshake and rejects data writes with the error 'WRONG_VERSION_ON_EARLY_DATA'. This behavior implements the RFC specification that 0-RTT (early data) should not be sent in the absence of a server's confirmed TLS 1.3 support. The condition (C1) and action (A1) are directly addressed within the target function.",success,
10094,TEST,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Fully Matches,"[{'A1': {'code': 'EXPECT_EQ(-1, SSL_write(client.get(), ""a"", 1));\nEXPECT_EQ(SSL_ERROR_SSL, SSL_get_error(client.get(), -1));\nEXPECT_TRUE(ErrorEquals(ERR_get_error(), ERR_LIB_SSL, SSL_R_WRONG_VERSION_ON_EARLY_DATA));\n\n// Nothing should be written to the transport.\nASSERT_TRUE(BIO_mem_contents(mem.get(), &unused, &len));\nEXPECT_EQ(0u, len);', 'explanation': 'The code verifies that after a handshake error due to using TLS 1.2 (wrong version on early data), an attempt to write application data fails and nothing is sent. This directly enforces the specification requirement that application data MUST NOT be sent prior to sending the Finished message.'}}]","The provided function explicitly tests that after a handshake anomaly involving early data (i.e., wrong protocol version), any attempt to send application data is rejected. The critical code segments enforce that a write operation (SSL_write) fails and that no data is transmitted, which addresses the spec constraint that application data must not precede the Finished message in the handshake.",success,
10101,TEST_P,"If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either continue the handshake without client authentication or abort the handshake with a ""certificate_required"" alert.",218,Fully Matches,"[{'C1': {'code': 'bssl::UniquePtr<X509> peer(SSL_get_peer_certificate(server_.get()));\nASSERT_FALSE(peer);\nASSERT_FALSE(SSL_get0_peer_certificates(server_.get()));', 'explanation': 'These lines check that no peer certificate is received, thereby directly addressing the case where the client sends an empty Certificate message.'}}, {'A1': {'code': 'ASSERT_TRUE(Connect());', 'explanation': 'This confirms that the handshake successfully continues even though the client did not provide a certificate.'}}]","The function sets up the SSL contexts with certificate verification callbacks and then initiates a connection. It then explicitly verifies that the server does not receive a client certificate by asserting that both SSL_get_peer_certificate and SSL_get0_peer_certificates return false. This directly implements the specified behavior in the RFC where if a client sends an empty Certificate message, the server may choose to continue the handshake without client authentication. All relevant conditions and actions from the RFC are visibly addressed within this function.",success,
10103,TEST,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided code function is a test for generating ClientHello messages for various TLS versions (TLS 1.0, TLS 1.1, TLS 1.2) and does not contain any logic that checks or enforces the constraint that the OpenPGP certificate type MUST NOT be used with TLS 1.3 as required by RFC6091. There is a TODO comment regarding TLS 1.3, but no implementation exists within this function to address the OpenPGP certificate type restriction.",success,
10103,TEST,Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less.,395,Fully Matches,"[{'C1': {'code': 'ASSERT_TRUE(SSL_CTX_set_min_proto_version(ctx.get(), TLS1_VERSION));\nASSERT_TRUE(SSL_CTX_set_max_proto_version(ctx.get(), t.max_version));\n\n// In kTests the expected ClientHello messages contain a legacy version byte sequence of 0x03,0x01 (for TLS1_VERSION), 0x03,0x02 (for TLS1_1_VERSION) and 0x03,0x03 (for TLS1_2_VERSION).\n// These values are all greater than 0x0300, ensuring that a legacy version of 0x0300 or less is never sent.', 'explanation': 'The RFC requires that implementations MUST NOT send a ClientHello with a legacy_version of 0x0300 or below. The function sets the minimum protocol version to TLS1_VERSION (which is 0x0301) and validates the generated ClientHello against expected vectors that embed appropriate version values. This logic in the function ensures that the legacy_version field in ClientHello is always set to a value higher than 0x0300.'}}]","The provided function generates and tests ClientHello messages by configuring the SSL context to use protocol versions TLS1.0 (TLS1_VERSION), TLS1.1, and TLS1.2, and then comparing the generated messages against predetermined expected byte sequences. The expected sequences embed legacy_version bytes (0x03,0x01 for TLS 1.0, etc.) that are all above 0x0300. This satisfies the RFC’s requirement to not send a legacy_version of 0x0300 or less in ClientHello. Since the function directly addresses the client side message (the part of the RFC concerning ClientHello) within its own logic, it fully meets the relevant constraint.",success,
10108,TEST_P,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function manipulates session ID contexts and tests session reuse by changing contexts and invoking callbacks; it does not include any logic that addresses the RFC specification which states that a TLS implementation SHOULD NOT automatically resend early data. There is no visible handling or decision-making regarding retransmission of early data – the function focuses solely on session reuse behavior rather than on managing early data retransmission as advised by the RFC. Therefore, none of the conditions (e.g., C1) or actions (e.g., A1) related to early data retransmission are implemented within this function.",success,
10113,TEST_P,A server MAY treat a ticket as valid for a shorter period of time than what is stated in the ticket_lifetime.,248,Fully Matches,"[{'C1': {'code': 'g_current_time.tv_sec += timeout - 1;\\nTRACED_CALL(ExpectSessionReused(client_ctx_.get(), server_ctx_.get(), session.get(), true /* expect session reused */));\\n\\n// Advance the clock one more second.\\ng_current_time.tv_sec++;\\nTRACED_CALL(ExpectSessionReused(client_ctx_.get(), server_ctx_.get(), session.get(), false /* expect session not reused */));', 'explanation': ""The function simulates the passage of time relative to the configured session timeout, checking that a session ticket is reused when the current time is just before the 'timeout' and is rejected once the time exceeds the timeout. This behavior shows that the server is enforcing a ticket lifetime that is shorter than the maximal ticket_lifetime, in line with the spec which states that a server MAY treat a ticket as valid for a shorter period than stated.""}}]","The code function directly implements logic to enforce session timeouts by advancing a simulated clock and verifying the session’s usability before and after the timeout deadline. This matches the RFC specification requirement that a server may treat a ticket as valid for a shorter period than indicated by the ticket_lifetime. All the necessary logic is contained within the function, without relying on external dependencies, hence it fully addresses the labeled constraint (C1).",success,
10117,TEST_P,The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages.,229,Fully Matches,"[{'C1': {'code': 'ASSERT_TRUE(SSL_CTX_set_signing_algorithm_prefs(server_ctx2.get(),\n                                                &kECDSAWithSHA256, 1));', 'explanation': 'The code explicitly forces the server context to use only the SHA256 signing algorithm (kECDSAWithSHA256) for signatures, thereby preventing the use of the SHA-1 algorithm in CertificateVerify messages.'}}]","The RFC requires that SHA-1 must not be used in any signatures of CertificateVerify messages. In this function, the signing algorithm preferences are set to only allow SHA256, as seen in the use of SSL_CTX_set_signing_algorithm_prefs with kECDSAWithSHA256. This directly addresses the requirement within the function's own logic, independent of any dependency, and therefore the function fully matches the specified constraint.",success,
10118,TEST,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'SSL_CTX_set_select_certificate_cb(\n    server_ctx.get(),\n    [](const SSL_CLIENT_HELLO *client_hello) -> ssl_select_cert_result_t {\n      if (!SSL_set_max_proto_version(client_hello->ssl, TLS1_2_VERSION)) {\n        return ssl_select_cert_error;\n      }\n      return ssl_select_cert_success;\n    });\nEXPECT_EQ(TLS1_2_VERSION, SSL_version(client.get()));', 'explanation': 'The callback registered by SSL_CTX_set_select_certificate_cb forces the max protocol version to TLS1_2_VERSION during the handshake. Additionally, the final check asserts that TLS1_2 is negotiated, thereby explicitly preventing negotiation of TLS1_3 as required by the specification.'}}]","The function initially sets the maximum protocol version to TLS1_3 for both the client and server contexts, but then uses a certificate selection callback to forcibly downgrade the maximum version to TLS1_2 during the handshake. This ensures that even if TLS1_3 is allowed in configuration, the actual negotiated protocol is TLS1_2, fully addressing the spec constraint that TLS1_3 must not be negotiated.",success,
10118,TEST,Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2.,69,Fully Matches,"[{'C1': {'code': 'EXPECT_EQ(TLS1_2_VERSION, SSL_version(client.get()));', 'explanation': 'This line confirms that, after a TLS 1.3 context is created, the negotiated protocol falls back to TLS 1.2. This behavior directly demonstrates that the implementation supports TLS 1.2 even when TLS 1.3 is available, satisfying the RFC requirement.'}}, {'A1': {'code': 'if (!SSL_set_max_proto_version(client_hello->ssl, TLS1_2_VERSION)) { return ssl_select_cert_error; }', 'explanation': 'Inside the certificate selection callback the server explicitly sets the maximum protocol version to TLS 1.2, which is an action enforcing support for TLS 1.2 as per the spec.'}}]","The function first creates TLS contexts that are initially set to support TLS 1.3. During the certificate selection via a callback, the code forces the maximum protocol version to be TLS 1.2. This is then verified with an assertion ensuring that the negotiated protocol is indeed TLS 1.2. These code segments directly address the spec constraint that implementations of TLS 1.3 supporting prior versions SHOULD support TLS 1.2. Hence, the functionality in this function fully implements the specified condition and action.",success,
10119,TEST,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Fully Matches,"[{'C1': {'code': 'EXPECT_FALSE(SSL_CTX_set_max_proto_version(ctx.get(), 0x0200));\nEXPECT_FALSE(SSL_CTX_set_max_proto_version(ctx.get(), 0x1234));\n\nEXPECT_FALSE(SSL_CTX_set_min_proto_version(ctx.get(), 0x0200));\nEXPECT_FALSE(SSL_CTX_set_min_proto_version(ctx.get(), 0x1234));', 'explanation': 'The specification requires that values from the obsolete_RESERVED ranges (i.e. those not appropriate for TLS 1.3) must not be offered or negotiated. These lines verify that when an attempt is made to set such version numbers (0x0200 and 0x1234, which represent values from previous TLS versions or reserved ranges), the operation fails. This directly tests that TLS 1.3 implementations reject these invalid version numbers.'}}, {'A1': {'code': 'EXPECT_TRUE(SSL_CTX_set_max_proto_version(ctx.get(), 0));\nEXPECT_EQ(TLS1_3_VERSION, SSL_CTX_get_max_proto_version(ctx.get()));', 'explanation': 'By setting the maximum protocol version to 0 and then verifying that TLS1_3_VERSION is returned, the code confirms that the highest allowed version in a TLS context falls back to TLS 1.3. This ensures that obsolete or reserved values are not inadvertently selected.'}}]","The function is a test routine that sets protocol version limits for both TLS and DTLS contexts. For TLS, it verifies that only valid TLS versions (specifically TLS 1.3 as the maximum) can be accepted. It explicitly tests and rejects version numbers (like 0x0200 and 0x1234) that likely fall into the obsolete_RESERVED range as described by the RFC specification. Thus, the code visibly implements the requirement that an implementation must not offer or negotiate protocol versions from these reserved ranges, satisfying the RFC spec constraint directly within the function.",success,
10120,GetVersionName,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The RFC specification requires that values within 'obsolete_RESERVED' ranges must not be offered or negotiated by TLS 1.3 implementations. However, the provided function simply maps version numbers to their corresponding string names without any logic to check or enforce that reserved or obsolete values are not used. There is no code in the function addressing the specific condition regarding values from obsolete_RESERVED ranges. Therefore, this function does not implement the required spec constraint.",success,
10123,TEST_P,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Fully Matches,"[{'C1': {'code': 'if (is_tls13()) {\n    return;\n}', 'explanation': 'The function explicitly checks if the TLS version is 1.3 and exits early, ensuring that no session resumption logic (which would send older session tickets) is executed. This adheres to the RFC requirement that TLS 1.3 implementations MUST NOT send them.'}}]","The provided function clearly avoids attempting session resumption for TLS 1.3 by checking the TLS version with 'is_tls13()' and returning immediately, which fully complies with the specification stating that TLS 1.3 implementations must not send session tickets (or related objects). Other parts of the function proceed with session resumption tests only for earlier TLS versions. Therefore, the function visibly implements the required condition (labeled C1) from the spec constraints within its own body.",success,
10123,TEST_P,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The provided function only tests session resumption behavior and explicitly skips execution when TLS 1.3 is in use (using the if (is_tls13()) check). However, the RFC specification requires that values within the ""obsolete_RESERVED"" ranges must not be offered or negotiated in TLS 1.3, and there is no logic within this function that checks for, prevents, or otherwise manages these obsolete values. As a result, the function does not visibly address the RFC constraint regarding ""obsolete_RESERVED"" ranges.",success,
10123,TEST_P,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (is_tls13()) {\n    return;\n  }', 'explanation': 'The code explicitly checks if TLS 1.3 is in use and immediately returns if true, thereby preventing the function from negotiating TLS 1.3 as required by the spec.'}}]","The function directly implements the requirement to not negotiate TLS 1.3 by checking with is_tls13() and aborting further processing when TLS 1.3 is detected. No TLS 1.3 negotiation logic is executed, which fully meets the constraint specified in the RFC.",success,
10133,TEST_P,"At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message.",238,Fully Matches,"[{'C1': {'code': 'ASSERT_TRUE(CompleteHandshakes(client.get(), server.get()));\nif (version() >= TLS1_3_VERSION) {\n  EXPECT_FALSE(g_last_session);\n}', 'explanation': 'This segment ensures that the handshake has completed (i.e. the server has received the client Finished message) and verifies that no NewSessionTicket has been processed immediately after, which aligns with the RFC allowing the ticket to be sent later.'}}, {'A1': {'code': 'if (use_zero_write) {\n  ASSERT_TRUE(FlushNewSessionTickets(client.get(), server.get()));\n  EXPECT_TRUE(g_last_session);\n}', 'explanation': 'This part explicitly triggers the sending of a NewSessionTicket via a zero-sized write flush. It checks that after flushing, the NewSessionTicket callback has been invoked (g_last_session is set), thereby implementing the action of sending a ticket after the Finished message.'}}, {'A2': {'code': 'static const char kMessage[] = ""hello world"";\nchar buf[sizeof(kMessage)];\nfor (;;) {\n  int server_ret = SSL_write(server.get(), kMessage, sizeof(kMessage));\n  int server_err = SSL_get_error(server.get(), server_ret);\n  int client_ret = SSL_read(client.get(), buf, sizeof(buf));\n  int client_err = SSL_get_error(client.get(), client_ret);\n\n  if (server_ret > 0) {\n    EXPECT_EQ(server_ret, static_cast<int>(sizeof(kMessage)));\n    EXPECT_EQ(client_ret, static_cast<int>(sizeof(kMessage)));\n    EXPECT_EQ(Bytes(buf), Bytes(kMessage));\n    break;\n  }\n\n  ASSERT_EQ(server_ret, -1);\n  ASSERT_EQ(server_err, SSL_ERROR_WANT_WRITE);\n  ASSERT_EQ(client_ret, -1);\n  ASSERT_EQ(client_err, SSL_ERROR_WANT_READ);\n}\n\n// The NewSessionTickets should have been flushed and processed.\nEXPECT_TRUE(g_last_session);', 'explanation': 'This loop sends application data from the server to the client. In scenarios where the NewSessionTicket flush is triggered implicitly (via non-zero write), the code confirms that a session ticket has been processed by ensuring g_last_session is set. This implements the alternative action of flushing NewSessionTickets.'}}]","The function_body is a test routine that verifies the TLS 1.3 behavior regarding the sending of NewSessionTicket messages after the Finished message. It ensures that no ticket is sent immediately after the handshake (as seen in the check for g_last_session before flushing) and then tests two pathways to flush the ticket: one via a zero-sized write and one via sending data. Both pathways confirm that after the flush, the server has sent the NewSessionTicket (indicated by g_last_session being non-null). Thus, the function fully addresses the specified condition (post-handshake timing) and the actions (explicit and implicit flush triggering of NewSessionTicket), matching the RFC's allowance for sending such tickets any time after the Finished message.",success,
10133,TEST_P,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided code function does not attempt to address the spec constraint that a TLS implementation should not automatically resend early data. Instead, the function tests handshake completion, session ticket flushing with both zero-sized and non-zero-sized writes, and data transmission between client and server. There is no logic in this function that checks or prevents automatic retransmission of early data. Therefore, none of the labeled conditions (C1, etc.) or actions (A1, etc.) related to the spec constraint are implemented within this function.",success,
10143,TEST,"-If the ""certificate_authorities"" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.",214,Fully Matches,"[{'C1': {'code': 'bssl::UniquePtr<STACK_OF(CRYPTO_BUFFER)> chain_subjects(\n    sk_CRYPTO_BUFFER_new_null());\nASSERT_TRUE(chain_subjects);\nASSERT_TRUE(PushToStack(chain_subjects.get(), std::move(chain_subject)));\nchain_subject_config.ca_names = chain_subjects.get();\nchain_subjects.release();\n\n// If we ask for the chain ca subject, we should get it\nASSERT_TRUE(ConnectClientAndServer(&client3, &server3, ctx.get(), ctx.get(), chain_subject_config));\nEXPECT_TRUE(BuffersEqual(SSL_get0_peer_certificates(client3.get()), {leaf.get(), ca.get()}));\n\n// Conversely, using a bogus issuer (i.e. a non-matching certificate authority) causes connection failure\nASSERT_FALSE(ConnectClientAndServer(&client2, &server2, ctx.get(), ctx.get(), bogus_subject_config));', 'explanation': ""This code configures the client to send certificate_authorities (CA names) by setting the 'ca_names' field in the client configuration. It then verifies that when the presented chain includes a certificate whose issuer matches one of the CA names (chain_subject), a secure connection is established. Conversely, when a bogus CA name is provided, the connection fails. Together, these tests enforce the RFC requirement that if the certificate_authorities extension is present, the certificate chain must include at least one certificate issued by one of the listed CAs.""}}]",The function implements test logic that directly examines whether the certificate chain provided by the server complies with the requirement that one of its certificates is issued by a certificate authority listed in the client's certificate_authorities extension. It does this by configuring various client scenarios – one with a properly matching CA and one with a bogus issuer – and then verifying connection success or failure accordingly. This clearly demonstrates that the function alone addresses the RFC spec condition.,success,
10153,ssl_test_ticket_aead_get_ex_index,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function solely deals with registering and retrieving an ex_index using CRYPTO_once and SSL_get_ex_new_index. It does not contain any logic that addresses the RFC specification regarding the prohibition of using the Truncated HMAC extension for AEAD algorithms. There is no check, conditional, or reference in the function_body that relates to the spec constraints, so it does not meet any of the labeled conditions or actions from the RFC.",success,
10154,ssl_test_ticket_aead_max_overhead,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function 'ssl_test_ticket_aead_max_overhead' only returns a constant value (1) and does not include any logic to check, validate, or enforce the prohibition of the Truncated HMAC extension as specified in the RFC. There is no code within this function that implements or refers to any condition (e.g., C1) or action (e.g., A1) related to the spec constraint regarding the insecure and inapplicable use of the Truncated HMAC extension. Therefore, it does not address any of the labeled conditions or actions.",success,
10154,ssl_test_ticket_aead_max_overhead,An AEAD algorithm used in TLS 1.3 MUST NOT produce an expansion greater than 255 octets.,294,Does Not Match,[],"The provided function simply returns a constant value of 1 without any logic to determine or enforce that the AEAD algorithm's expansion does not exceed the maximum allowed 255 octets as specified in the RFC. There is no code within the function that corresponds to checking, calculating, or validating the expansion size, so it does not address any of the labeled conditions or actions.",success,
10155,ssl_test_ticket_aead_seal,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function, ssl_test_ticket_aead_seal, does not contain any logic that references or addresses the RFC specification regarding the prohibition of using the Truncated HMAC extension for AEAD algorithms. The function strictly performs a memory copy and appends a constant byte to the output buffer, without any operations related to truncated HMAC handling or its omission. Therefore, there is no portion of the function that implements any labeled condition or action from the spec constraints.",success,
10155,ssl_test_ticket_aead_seal,An AEAD algorithm used in TLS 1.3 MUST NOT produce an expansion greater than 255 octets.,294,Does Not Match,[],"The RFC states that an AEAD algorithm used in TLS 1.3 MUST NOT produce an expansion greater than 255 octets. In the provided function, the output is formed by copying the input and appending a single byte (producing an expansion of +1 octet). The function only verifies that the provided output buffer (max_out_len) is large enough to hold the input plus one byte (by checking if max_out_len < in_len + 1), but it does not explicitly enforce or check that the expansion is less than or equal to 255 octets. There is no code segment that compares the expansion against the 255 octet limit. Thus, the function does not visibly address the constraint from the specification within its own code.",success,
10157,TEST_P,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided code function is concerned with ticket AEAD testing and handling of session tickets, including negotiating protocol versions and testing ticket-based session resumption. It neither checks nor implements any restrictions regarding the use of the OpenPGP certificate type with TLS 1.3 as dictated by RFC6091. There is no logic within the function that references the OpenPGP certificate type or makes any decision based on its presence together with TLS 1.3. Therefore, no labeled spec constraint (e.g., C1, A1) related to the prohibition of using the OpenPGP certificate type is addressed in this function.",success,
10157,TEST_P,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification requires that implementations must not use the Truncated HMAC extension. The provided function is a test for the AEAD ticket method and does not contain any logic addressing or verifying the absence of the truncated HMAC extension. There is no code in the function_body that references or prevents the use of the truncated HMAC extension (the specific behavior mentioned in the RFC). Therefore, in isolation, this function does not implement the specified constraint.",success,
10161,TEST,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function focuses on creating an SSL context with a specific TLS protocol (TLS 1.1) and a restricted cipher list, and then expects a handshake failure due to the absence of matching ciphers. There is no logic in the function addressing the OpenPGP certificate type or ensuring that it is not used with TLS 1.3, which is the core of the RFC6091 specification. Therefore, the function does not attempt to implement the specified constraint from the RFC.",success,
10164,TEST,"This alert SHOULD be followed by a ""close_notify"".",314,Fully Matches,"[{'A1': {'code': 'EXPECT_EQ(0, SSL_shutdown(server.get()));\nEXPECT_EQ(0, SSL_shutdown(client.get()));', 'explanation': 'These lines initiate the TLS shutdown, which sends the close_notify alert as required by the spec.'}}, {'A2': {'code': 'EXPECT_EQ(1, SSL_shutdown(server.get()));\nEXPECT_EQ(1, SSL_shutdown(client.get()));', 'explanation': ""These lines complete the shutdown by waiting for the peer's close_notify, thereby verifying that the alert is correctly followed by a close_notify.""}}]","The function explicitly performs the shutdown handshake by first sending a close_notify alert (as indicated by the first pair of SSL_shutdown calls that return 0) and then waiting to receive the peer's close_notify (confirmed by the second pair of SSL_shutdown calls returning 1). This behavior directly addresses the RFC requirement that 'this alert SHOULD be followed by a close_notify', fully matching the specification constraint within the function itself.",success,
10164,TEST,"Either party MAY initiate a close of its write side of the connection by sending a ""close_notify"" alert.",315,Fully Matches,"[{'C1': {'code': 'EXPECT_EQ(0, SSL_shutdown(server.get()));\nEXPECT_EQ(0, SSL_shutdown(client.get()));', 'explanation': ""These calls initiate the shutdown by sending a close_notify alert from both server and client, aligning with the RFC's provision that either party may initiate a graceful close.""}}, {'A1': {'code': 'EXPECT_EQ(1, SSL_shutdown(server.get()));\nEXPECT_EQ(1, SSL_shutdown(client.get()));', 'explanation': ""These subsequent calls check that each side receives the peer's close_notify alert, ensuring a complete graceful shutdown of both ends as required.""}}]","The function explicitly performs_ssl_shutdown() operations on both the client and server. The first shutdown call sends the close_notify alert (returning 0), and the second call confirms receipt of the peer's alert (returning 1). This sequence directly implements the RFC requirement for a graceful close via close_notify alerts, thereby fully matching the specified constraints.",success,
10164,TEST,"Each party MUST send a ""close_notify"" alert before closing its write side of the connection, unless it has already sent some error alert",317,Partially Matches,"[{'C1': {'code': 'EXPECT_EQ(0, SSL_shutdown(server.get()));\nEXPECT_EQ(0, SSL_shutdown(client.get()));', 'explanation': 'These calls to SSL_shutdown simulate the sending of the close_notify alert, fulfilling the requirement that each party MUST send the alert before closing its write side.'}}, {'A1': {'code': 'EXPECT_EQ(1, SSL_shutdown(server.get()));\nEXPECT_EQ(1, SSL_shutdown(client.get()));', 'explanation': 'The second pair of SSL_shutdown calls verifies that the close_notify alert from the peer is received, addressing the expected bidirectional shutdown process.'}}]","The function demonstrates logic for a normal shutdown sequence in TLS by calling SSL_shutdown twice: the first call sends the close_notify alert (C1) and the second confirms receipt of the peer's alert (A1). However, it does not handle the scenario of an error alert being sent (the exception clause in the spec), so it only partially covers the complete RFC requirement.",success,
10164,TEST,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Does Not Match,[],"The provided function does not contain any visible logic that directly addresses the RFC requirement that SSL 3.0 must not be negotiated. Although the function sets both the minimum and maximum protocol versions to TLS1_3, this enforcement is aimed at guaranteeing the use of TLS1.3 rather than explicitly rejecting or handling SSL 3.0 negotiation. Furthermore, the rest of the test focuses on shutdown behavior and session ticket callbacks rather than any SSL 3.0 negotiation logic. Thus, within the function_body itself, there is no clear implementation addressing the specified RFC condition.",success,
10164,TEST,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Fully Matches,"[{'C1': {'code': 'ASSERT_TRUE(SSL_CTX_set_min_proto_version(ctx.get(), TLS1_3_VERSION));\nASSERT_TRUE(SSL_CTX_set_max_proto_version(ctx.get(), TLS1_3_VERSION));', 'explanation': 'By explicitly setting both the minimum and maximum protocol versions to TLS1.3, the code ensures that only TLS1.3 is allowed, thereby implicitly prohibiting the negotiation of any lower protocols such as SSL2, in accordance with the RFC requirement.'}}]","The RFC specifies that SSL 2.0 MUST NOT be negotiated due to its insufficient security. The function establishes an SSL context and restricts the protocol version to TLS1.3 exclusively, which effectively prevents SSL2 from being negotiated. Since the logic directly addresses the RFC's requirement within the function itself, the provided code fully implements the constraint.",success,
10168,TEST,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The RFC specifies that the OpenPGP certificate type MUST NOT be used with TLS 1.3. However, the provided function configures both the client and server contexts to use TLS 1.3 (via SSL_CTX_set_max_proto_version with TLS1_3_VERSION) and further sets up certificate compression algorithms. There is no logic within this function to check the certificate type or to reject the use of an OpenPGP certificate type when using TLS 1.3. Therefore, the function does not visibly address any labeled spec condition or action related to the RFC.",success,
10170,VerifyHandoff,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'A1': {'code': 'if (early_data && is_resume) {\n    ASSERT_EQ(client_err, 0);\n    EXPECT_TRUE(SSL_in_early_data(client.get()));\n    // Attempt to write early data.\n    byte_written = 43;\n    EXPECT_EQ(SSL_write(client.get(), &byte_written, 1), 1);\n} else {\n    ASSERT_EQ(client_err, SSL_ERROR_WANT_READ);\n}', 'explanation': 'The RFC requires that a TLS implementation SHOULD NOT automatically resend early data, leaving the decision to the application. In this code, early data is sent only when the test explicitly enables it (early_data == true and on a resumed session). There is no logic that automatically resends early data. Instead, the call to SSL_write is deliberately made only when early data is meant to be sent, ensuring that the mechanism is under application control.'}}]","The function 'VerifyHandoff' tests various handshake scenarios including ones where early data is enabled. The code explicitly checks if early data should be sent (by the condition 'if (early_data && is_resume)') and then manually writes it; in the alternate branch it expects a read-wait condition rather than any automatic transmission. This ensures that early data is not automatically resent, thereby meeting the RFC requirement that the TLS implementation should leave retransmission decisions to the application. Since this behavior is fully handled within the function and no automatic logic is present, the function fully matches the specified constraint.",success,
10172,TEST,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function does not implement logic to enforce the RFC6091 requirement that the OpenPGP certificate type MUST NOT be used with TLS 1.3. While the function explicitly limits the server’s maximum protocol version to TLS1.2 (thereby implicitly avoiding TLS1.3), it does not check or handle the OpenPGP certificate type. The code is focused on testing SSL handoff decline and related behaviors, and does not visibly address the specific condition related to certificate types as mandated by the RFC.",success,
10182,TEST_P,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (is_tls13()) {\n    // Our TLS 1.3 implementation does not support stateful resumption.\n    ASSERT_FALSE(CreateClientSession(client_ctx_.get(), server_ctx_.get()));\n    return;\n}', 'explanation': 'This code explicitly checks if TLS 1.3 is active via is_tls13() and, if so, asserts that creating a client session (i.e. using stateful session resumption) fails, then aborts further processing. In doing so, it enforces the RFC requirement that TLS 1.3 must not be negotiated using stateful session resumption.'}}]","The primary RFC specification mandates that the implementation MUST NOT negotiate TLS 1.3. The function directly addresses this by testing the condition with is_tls13() and ensuring that any attempt to create a client session (which would involve stateful resumption) in a TLS 1.3 context fails. Consequently, the function alone visibly enforces the spec constraint without relying on external dependencies.",success,
10185,TEST_P,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function checks for TLS 1.3 (e.g. with the if (is_tls13()) block) and adjusts session resumption behavior accordingly, but it does not reference or enforce any rule regarding the OpenPGP certificate type as required by RFC6091. There is no code within this function that verifies, restricts, or handles the use of the OpenPGP certificate type with TLS 1.3, which is the primary requirement of the spec. Therefore, the function does not attempt to address the labeled constraints.",success,
10185,TEST_P,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (is_tls13()) {\n    // Our TLS 1.3 implementation does not support stateful resumption.\n    ASSERT_FALSE(CreateClientSession(client_ctx_.get(), server_ctx_.get()));\n    return;\n}', 'explanation': 'This segment directly checks for TLS 1.3 usage and prevents creating a client session when TLS 1.3 is active, thereby enforcing the RFC requirement that TLS 1.3 must not be negotiated.'}}]","The function explicitly verifies if TLS 1.3 is being used and immediately returns if true, which stops the TLS 1.3 session from being established. This implementation detail satisfies the specified RFC constraint that it MUST NOT negotiate TLS 1.3.",success,
10188,LevelToString,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function simply converts an encryption level enum to its corresponding string representation. It does not contain any logic that addresses the TLS behavior specified in the RFC (i.e., not automatically resending early data) or any of the related spec constraints (such as conditions like C1 or actions like A1). The function's logic is isolated to a string lookup and does not implement any decision-making or control mechanisms concerning early data retransmission.",success,
10199,SetWriteSecret,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'C1': {'code': 'if (role_ == Role::kServer && level == ssl_encryption_early_data) {\n      ADD_FAILURE() << ""Unexpected early data write secret"";\n      return false;\n    }', 'explanation': 'This code explicitly checks if an early data write secret is being set in server mode and rejects it, thereby preventing an automatic early data retransmission. This directly addresses the RFC recommendation that a TLS implementation SHOULD NOT automatically resend early data.'}}]","The function validates the write secret before it is configured. In particular, it has a condition that prevents the setting of an early data write secret when running in server mode, which aligns directly with the RFC specification that advises against automatically resending early data. As the logic to enforce this behavior is implemented within the function itself, it fully meets the given spec constraint.",success,
10208,SetUp,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Fully Matches,"[{'C1': {'code': 'SSL_CTX_set_min_proto_version(server_ctx_.get(), TLS1_3_VERSION);\nSSL_CTX_set_max_proto_version(server_ctx_.get(), TLS1_3_VERSION);\nSSL_CTX_set_min_proto_version(client_ctx_.get(), TLS1_3_VERSION);\nSSL_CTX_set_max_proto_version(client_ctx_.get(), TLS1_3_VERSION);', 'explanation': 'These lines explicitly restrict both the client and server SSL contexts to TLS 1.3. Since obsolete_RESERVED values are associated with earlier TLS versions, limiting the protocol to TLS 1.3 ensures that such obsolete values are neither offered nor negotiated, thereby fully addressing the RFC requirement.'}}]","The function sets both the minimum and maximum protocol versions for the client and server contexts to TLS1_3_VERSION. This restriction ensures that only TLS 1.3 is used, and therefore obsolete_RESERVED values from previous TLS versions are not offered or negotiated. The implementation within the function itself clearly meets the specified RFC requirement.",success,
10208,SetUp,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The RFC specification prohibits the use of an OpenPGP certificate type with TLS 1.3. However, the provided function solely sets up TLS contexts and explicitly restricts the TLS version to TLS1.3 without any logic to check for or exclude the use of OpenPGP certificate types. There is no code segment that detects, prevents, or configures the certificate type according to the spec constraint. All operations in this function are confined to establishing TLS 1.3 contexts and setting up ALPN, which does not address the RFC requirement regarding the OpenPGP certificate type.",success,
10208,SetUp,"To avoid a downgrade attack, the client SHOULD NOT disable TLS 1.3, only 0-RTT.",385,Partially Matches,"[{'C1': {'code': 'SSL_CTX_set_min_proto_version(server_ctx_.get(), TLS1_3_VERSION);\nSSL_CTX_set_max_proto_version(server_ctx_.get(), TLS1_3_VERSION);\nSSL_CTX_set_min_proto_version(client_ctx_.get(), TLS1_3_VERSION);\nSSL_CTX_set_max_proto_version(client_ctx_.get(), TLS1_3_VERSION);', 'explanation': 'These lines enforce that both the client and server only use TLS 1.3, ensuring that TLS 1.3 is not disabled. This partially satisfies the spec requirement by preserving TLS 1.3, thus helping to avoid downgrade attacks.'}}]","The RFC specification indicates that to avoid downgrade attacks the client SHOULD NOT disable TLS 1.3, but instead only disable 0-RTT. The function enforces TLS 1.3 by setting both the minimum and maximum protocol versions to TLS1_3_VERSION on the client (and server), ensuring TLS 1.3 remains enabled. However, the function does not implement any logic pertaining to the handling or disabling of 0-RTT, meaning only part of the spec's constraints are addressed within this function.",success,
10212,CreateClientAndServer,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function initializes and configures the TLS/QUIC client and server contexts, including setting an early data context with SSL_set_quic_early_data_context. However, it does not contain any logic that prevents automatic resending of early data or that puts the decision of retransmission in the hands of the application, as specified by the RFC. No part of the code function directly addresses the condition that a TLS implementation SHOULD NOT automatically resend early data. Therefore, the function does not visibly implement the required spec constraint.",success,
10212,CreateClientAndServer,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Does Not Match,[],"The provided function does not implement any specific logic to check if 0-RTT is specifically requested by the application, nor does it include any conditional logic to prevent automatic resend of 0-RTT data if rejected. The code always sets the QUIC transport parameters and, notably, sets the 0-RTT early data context via SSL_set_quic_early_data_context without conditions. Therefore, it does not visibly address the RFC requirement to disable or manage 0-RTT unless explicitly requested.",success,
10217,DefaultQUICMethod,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Does Not Match,[],"The provided function, DefaultQUICMethod, simply returns a structure with several callback pointers and does not contain any logic that prevents the use or negotiation of SSL 3.0. The RFC specification requires that SSL 3.0 must not be negotiated under any circumstances, but there is no visible code within this function that checks for or enforces this requirement. Since the function does not implement any condition (e.g., C1) or action (e.g., A1) related to disallowing SSL 3.0, the function does not address the RFC specification.",success,
10217,DefaultQUICMethod,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, DefaultQUICMethod, solely returns an SSL_QUIC_METHOD structure containing various callback functions. There is no logic that inspects, enforces, or prevents the use of RC4 cipher suites. Therefore, the function does not visibly address the RFC specification that implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS. No part of the function corresponds to any labeled constraint (e.g., C1, A1) regarding RC4 handling.",success,
10223,TEST_F,"At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message.",238,Fully Matches,"[{'C1': {'code': 'EXPECT_FALSE(g_last_session);\nASSERT_TRUE(ProvideHandshakeData(client_.get()));\nEXPECT_EQ(SSL_process_quic_post_handshake(client_.get()), 1);\nEXPECT_TRUE(g_last_session);', 'explanation': 'These lines assert that before processing, no NewSessionTicket (g_last_session) is set, then after providing handshake data and processing post-handshake messages, a ticket is received. This implements the condition that after the client Finished message, the server may send a NewSessionTicket message.'}}, {'A1': {'code': 'bssl::UniquePtr<SSL_SESSION> session = std::move(g_last_session);\nSSL_set_session(client_.get(), session.get());\nASSERT_TRUE(CompleteHandshakesForQUIC());\nEXPECT_TRUE(SSL_session_reused(client_.get()));\nEXPECT_TRUE(SSL_session_reused(server_.get()));', 'explanation': 'These lines use the received session (from NewSessionTicket) to initiate a resumed connection, verifying that the session ticket is correctly applied and that resumption succeeds. This action aligns with using the ticket as per the RFC.'}}]","The function explicitly verifies that after completing the initial handshake the server sends a NewSessionTicket message (as required by C1), and then uses the received session ticket to resume a connection (A1). Although the surrounding dependencies manage lower-level details, the function itself contains the logic to process and utilize a NewSessionTicket message in accordance with the RFC specification.",success,
10224,TEST_F,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function_body configures QUIC handshake parameters by setting group preferences to trigger a HelloRetryRequest, but it does not include any logic related to the RFC specification concerning the 'supported_groups' information handling during handshake or the evaluation of an If-Unmodified-Since header. No segments in the function address the labeled conditions (C1, etc.) or actions (A1, etc.) from the spec constraints.",success,
10226,TEST_F,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Partially Matches,"[{'C1': {'code': 'EXPECT_FALSE(transport_->server()->HasReadSecret(ssl_encryption_application));', 'explanation': ""This check verifies that before the client's Finished message is received, the server does not possess the 1-RTT read key used for decrypting application data. This indirectly supports the RFC requirement that application data must not be sent before the Finished message is completed.""}}]","The function sets up a QUIC handshake and specifically verifies that, until the client sends its Finished message, the server does not have its 1-RTT read key available (as seen in the EXPECT_FALSE check). This design is an indirect enforcement of the RFC mandate that application data is not processed (or sent) before the Finished message is completed. However, the function does not explicitly test for any attempted transmission of application data prior to the Finished message but relies on key availability as a proxy. Therefore, while the function does address one of the spec constraints (C1) through in-function logic, it only partially matches the complete intent of the HTTP RFC requirement.",success,
10227,TEST_F,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function primarily tests the 0-RTT handshake, verifying early data states and key establishment for both client and server in a controlled manner. It does not include any logic to decide whether or not to retransmit early data automatically, nor does it prevent automatic retransmission. Thus, it does not visibly implement the RFC requirement stating that a TLS implementation SHOULD NOT automatically resend early data.",success,
10228,TEST_F,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'A1': {'code': 'for (;;) {\n    ASSERT_TRUE(ProvideHandshakeData(client_.get()));\n    ASSERT_EQ(-1, SSL_do_handshake(client_.get()));\n    int err = SSL_get_error(client_.get(), -1);\n    if (err == SSL_ERROR_EARLY_DATA_REJECTED) {\n      break;\n    }\n    ASSERT_EQ(SSL_ERROR_WANT_READ, err);\n  }\n\n  // As in TLS over TCP, 0-RTT rejection is sticky.\n  ASSERT_EQ(-1, SSL_do_handshake(client_.get()));\n  ASSERT_EQ(SSL_ERROR_EARLY_DATA_REJECTED, SSL_get_error(client_.get(), -1));', 'explanation': 'This segment demonstrates that once early data is rejected, the handshake loop detects SSL_ERROR_EARLY_DATA_REJECTED and does not automatically retransmit early data. It confirms that the client will not automatically resend early data, which is what the RFC specifies.'}}]","The function explicitly implements logic to prevent automatic resending of early data: after initiating a handshake that uses early data, it enters a loop to detect rejection and confirms that further handshake attempts continue to indicate early data rejection. This ensures that the TLS implementation does not automatically resend early data, and the application must decide whether to reset and retransmit. All of this behavior is implemented directly within this function.",success,
10228,TEST_F,"If it is not, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.",146,Fully Matches,"[{'C1': {'code': 'static const uint8_t new_context[] = {4};\nASSERT_TRUE(SSL_set_quic_early_data_context(server_.get(), new_context, sizeof(new_context)));\n\nASSERT_TRUE(ProvideHandshakeData(server_.get()));\nASSERT_EQ(SSL_do_handshake(server_.get()), -1);\nEXPECT_FALSE(SSL_in_early_data(server_.get()));\nEXPECT_FALSE(transport_->server()->HasReadSecret(ssl_encryption_early_data));', 'explanation': 'This segment sets a mismatched early data context on the server and confirms that the server does not enter early data mode, which implements the condition that if the ClientHello is not fresh, 0-RTT must be rejected.'}}, {'A1': {'code': 'for (;;) {\n    ASSERT_TRUE(ProvideHandshakeData(client_.get()));\n    ASSERT_EQ(-1, SSL_do_handshake(client_.get()));\n    int err = SSL_get_error(client_.get(), -1);\n    if (err == SSL_ERROR_EARLY_DATA_REJECTED) {\n      break;\n    }\n    ASSERT_EQ(SSL_ERROR_WANT_READ, err);\n}\n\n/* Later: Ensure that 0-RTT remains rejected and handshake completes normally */\nSSL_reset_early_data_reject(client_.get());\nASSERT_TRUE(CompleteHandshakesForQUIC());', 'explanation': 'This loop on the client side waits for the SSL_ERROR_EARLY_DATA_REJECTED error, thereby verifying that the client properly recognizes the 0-RTT rejection from the server as specified. It then resets the state and completes the handshake.'}}]","The function explicitly sets up a scenario where the server's early data context does not match the client's expectations. It then proceeds with the handshake while rejecting 0-RTT data, as indicated by the absence of early data state and key usage on the server, and by the client handling the early data rejection error. This directly implements the RFC requirement that if the ClientHello is not fresh the server should continue the handshake only after rejecting 0-RTT, with no further processing that assumes the ClientHello is fresh.",success,
10228,TEST_F,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Fully Matches,"[{'C1': {'code': 'SSL_CTX_set_early_data_enabled(client_ctx_.get(), 1);\nSSL_CTX_set_early_data_enabled(server_ctx_.get(), 1);', 'explanation': 'These calls explicitly enable 0-RTT (early data) on both client and server, meaning that 0-RTT is not enabled by default but only when the application explicitly requests it.'}}, {'A1': {'code': 'for (;;) {\n  ASSERT_TRUE(ProvideHandshakeData(client_.get()));\n  ASSERT_EQ(-1, SSL_do_handshake(client_.get()));\n  int err = SSL_get_error(client_.get(), -1);\n  if (err == SSL_ERROR_EARLY_DATA_REJECTED) {\n    break;\n  }\n  ASSERT_EQ(SSL_ERROR_WANT_READ, err);\n}\n\n// As in TLS over TCP, 0-RTT rejection is sticky.\nASSERT_EQ(-1, SSL_do_handshake(client_.get()));\nASSERT_EQ(SSL_ERROR_EARLY_DATA_REJECTED, SSL_get_error(client_.get(), -1));', 'explanation': 'This segment simulates the scenario where 0-RTT is rejected due to mismatched parameters, then verifies that once rejected, the client does not automatically resend the 0-RTT data without explicit instruction. This behavior aligns with the RFC requirement.'}}]","The function explicitly enables 0-RTT only when requested by the application (fulfilling the requirement not to enable it accidentally) and then tests that 0-RTT data is not automatically resent if rejected by the server. Both parts directly address the specified RFC constraints within the function's own logic, leading to the conclusion that the code fully matches the RFC constraints.",success,
10229,TEST_F,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'C1': {'code': 'server_quic_early_data_context_ = {};\n...\nEXPECT_FALSE(SSL_SESSION_early_data_capable(session.get()));', 'explanation': 'The code explicitly sets an empty early data context and then verifies that the created session is not early data capable. This corresponds directly to the spec requirement that a TLS implementation should not automatically resend early data.'}}]","The function sets up the environment by initializing an empty early data context and enabling early data on both client and server contexts. It then creates a session and asserts that it is not early data capable, thereby ensuring that early data is not automatically retransmitted. This aligns with the spec requirement, so the function fully addresses the constraint within its own logic.",success,
10229,TEST_F,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Partially Matches,"[{'C1': {'code': 'server_quic_early_data_context_ = {};\n...\nEXPECT_FALSE(SSL_SESSION_early_data_capable(session.get()));', 'explanation': ""The code resets the server's early data context and then creates a session for QUIC, asserting that the session is not early data capable. This demonstrates that 0-RTT data is not enabled in the absence of an appropriate early data context, matching the requirement to not enable 0-RTT unless specifically requested.""}}]","The function verifies one key aspect of the RFC specification by ensuring that a QUIC session does not become 0-RTT capable when there is no appropriate early data context (fulfilling the condition similar to C1). However, it does not address the other aspect of the spec (i.e., not automatically resending 0-RTT data if rejected by the server), and there is no logic ensuring that enabling early data only occurs when explicitly requested. Thus, the function only partially implements the specified RFC requirements in its own logic.",success,
10230,TEST_F,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Partially Matches,"[{'C1': {'code': 'SSL_CTX_set_early_data_enabled(client_ctx_.get(), 1);\nSSL_CTX_set_early_data_enabled(server_ctx_.get(), 1);\n...\n// Disable 0-RTT on the server, so it will reject it.\nSSL_set_early_data_enabled(server_.get(), 0);', 'explanation': 'This code shows that enabling 0‐RTT is explicitly controlled by the application. The client context is enabled for 0‐RTT only because the application explicitly calls SSL_CTX_set_early_data_enabled. Furthermore, the test manipulates the server state (either by disabling early data or via HelloRetryRequest) to control when 0‐RTT is accepted. This addresses the requirement that 0‐RTT MUST NOT be enabled unless specifically requested by the application.'}}, {'A1': {'code': 'for (;;) {\n  ASSERT_TRUE(ProvideHandshakeData(client_.get()));\n  ASSERT_EQ(-1, SSL_do_handshake(client_.get()));\n  int err = SSL_get_error(client_.get(), -1);\n  if (err == SSL_ERROR_EARLY_DATA_REJECTED) {\n    break;\n  }\n  ASSERT_EQ(SSL_ERROR_WANT_READ, err);\n}\n\n// As in TLS over TCP, 0-RTT rejection is sticky.\nASSERT_EQ(-1, SSL_do_handshake(client_.get()));\nASSERT_EQ(SSL_ERROR_EARLY_DATA_REJECTED, SSL_get_error(client_.get(), -1));\n\n// Finish up by requiring an explicit reset:\nSSL_reset_early_data_reject(client_.get());', 'explanation': 'This loop and subsequent checks verify that once 0‐RTT data is rejected, the client continues to see a rejection state (i.e. does not automatically resend 0‐RTT data) until an explicit call resets this state. This behavior enforces the requirement that TLS MUST NOT automatically resend 0‐RTT data if it is rejected by the server unless explicitly instructed by the application.'}}]","The function_body deliberately configures the client and server contexts for 0‐RTT data and then simulates conditions where the server rejects early data—either by disabling early data or via a HelloRetryRequest scenario. It then confirms that after rejection, the implementation remains in a rejection state (0‐RTT rejection is 'sticky') until an explicit reset is applied. While the test demonstrates application-controlled enabling/disabling of 0‐RTT and ensures that rejected early data is not automatically retried, it does so within a test harness that mimics the RFC requirements. Thus, it partially matches the constraints by visibly addressing the conditions for enabling 0‐RTT and the actions to prevent automatic resending, but it does not cover all aspects of a full implementation of the RFC within this function alone.",success,
10230,TEST_F,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'C1': {'code': 'ASSERT_EQ(-1, SSL_do_handshake(client_.get()));\nASSERT_EQ(SSL_ERROR_EARLY_DATA_REJECTED, SSL_get_error(client_.get(), -1));', 'explanation': 'This code confirms that once 0-RTT (early data) is rejected by the server, subsequent calls to SSL_do_handshake on the client remain in the early data rejection state. This means that early data is not automatically resent, leaving the decision to the application, which is in line with the RFC specification.'}}]","The function explicitly tests that after a 0-RTT early data rejection, the handshake does not automatically retry sending early data. The segment that checks for SSL_ERROR_EARLY_DATA_REJECTED demonstrates that the implementation enforces the requirement that automatic resending of early data is disabled. This meets the spec requirement that a TLS implementation SHOULD NOT automatically resend early data, and thus the function fully matches the given constraint.",success,
10231,TEST_F,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Partially Matches,"[{'C1': {'code': 'EXPECT_FALSE(transport_->client()->HasWriteSecret(ssl_encryption_early_data));', 'explanation': 'This check ensures that before certificate re‐verification completes, the early (0‑RTT) write secret is not available, thereby preventing automatic use of early data.'}}, {'A1': {'code': 'SSL_set_reverify_on_resume(client_ctx_.get(), 1);', 'explanation': 'Setting the client context to require re‐verification on resume delays the release of early data keys. This enforces that early data is only enabled when re‐verification is complete, aligning with the intent of not automatically resending early data.'}}]","While the TLS specification advises that implementations should not automatically resend early data so that applications can determine when to retransmit, the function focuses on the timing of key release. It ensures that early data keys (0‑RTT keys) are not made available until after certificate re‐verification completes. This logic partially matches the spec by preventing premature early data transmission, but it does not fully implement all aspects of managing retransmission decisions within the TLS implementation itself.",success,
10231,TEST_F,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Partially Matches,"[{'C1': {'code': 'SSL_CTX_set_reverify_on_resume(client_ctx_.get(), 1);\n...\nASSERT_EQ(SSL_do_handshake(client_.get()), -1);\nASSERT_EQ(SSL_get_error(client_.get(), -1), SSL_ERROR_WANT_CERTIFICATE_VERIFY);\n...\nEXPECT_FALSE(transport_->client()->HasWriteSecret(ssl_encryption_early_data));\n...\nSSL_set_custom_verify(client_.get(), SSL_VERIFY_PEER, [](SSL *ssl, uint8_t *out_alert) -> ssl_verify_result_t { return ssl_verify_retry; });\n...\n// Later, after verification completes:\nSSL_set_custom_verify(client_.get(), SSL_VERIFY_PEER, [](SSL *ssl, uint8_t *out_alert) -> ssl_verify_result_t { return ssl_verify_ok; });\nASSERT_EQ(SSL_do_handshake(client_.get()), 1);\nEXPECT_TRUE(SSL_in_early_data(client_.get()));\nEXPECT_TRUE(transport_->client()->HasWriteSecret(ssl_encryption_early_data));', 'explanation': 'This test verifies that the 0-RTT (early data) keys are not released before re-verification of the certificate completes. The expectation that no early data key exists before certificate verification—in combination with its later release after explicit approval—implements the requirement that TLS must not enable 0-RTT unless specifically requested. However, the test does not cover the clause regarding auto-resending 0-RTT data if rejected by the server.'}}]","The function is designed to test that 0-RTT keys (used for early data) are not enabled until after certificate re-verification is complete, which aligns with the spec requirement not to enable 0-RTT unless explicitly requested by the application (C1). It does so by initially setting up a handshake that intentionally delays certificate verification, confirming that no early data keys are available, and then completes verification to release the keys. Despite this, the function does not implement or test the behavior related to automatically resending 0-RTT data if it is rejected by the server, leading to a partial match of the RFC specification.",success,
10234,TEST_F,"Implementations MUST verify that all messages immediately preceding a key change align with a record boundary; if not, then they MUST terminate the connection with an ""unexpected_message"" alert.",278,Fully Matches,"[{'C1': {'code': 'ASSERT_EQ(SSL_do_handshake(client_.get()), -1);\nASSERT_EQ(SSL_get_error(client_.get(), -1), SSL_ERROR_SSL);\nEXPECT_TRUE(ErrorEquals(ERR_get_error(), ERR_LIB_SSL, SSL_R_EXCESS_HANDSHAKE_DATA));', 'explanation': 'These lines detect that extra handshake data (i.e. data that does not align with a record boundary preceding key change) has been received, fulfilling the verification of alignment.'}}, {'A1': {'code': 'ASSERT_TRUE(transport_->client()->has_alert());\nEXPECT_EQ(transport_->client()->alert_level(), ssl_encryption_handshake);\nEXPECT_EQ(transport_->client()->alert(), SSL_AD_UNEXPECTED_MESSAGE);', 'explanation': ""The test then checks that the client terminates the connection by sending an 'unexpected_message' alert, which satisfies the action requirement.""}}]","The function simulates a scenario where handshake data is improperly grouped (hence, not aligned with a record boundary immediately preceding a key change). It then verifies that the implementation reacts correctly by detecting the excess data and terminating the connection with an 'unexpected_message' alert. This behavior directly implements both the condition (C1) of verifying record boundary alignment and the action (A1) of terminating the connection via an alert as specified.",success,
10234,TEST_F,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Does Not Match,[],"The provided code function is a QUIC handshake test (ExcessProvidedData) and does not contain any logic that addresses the requirement of disallowing SSL 3.0, as specified in RFC6101 and RFC7568. There is no code within this function that prevents SSL 3.0 from being negotiated, so it does not meet any labeled condition or action related to the specified RFC.",success,
10234,TEST_F,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided code function is a test for QUIC handshake behavior related to handling excess handshake data and key transitions. There is no logic within the function that addresses the RFC specification constraint regarding not offering or negotiating RC4 cipher suites for any version of TLS. No code segment in this function checks, prevents, or mentions RC4, so the specification is not implemented here.",success,
10234,TEST_F,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Fully Matches,"[{'C1': {'code': 'ASSERT_TRUE(ProvideHandshakeData(client_.get()));\nASSERT_EQ(SSL_do_handshake(client_.get()), -1);\nASSERT_TRUE(ErrorEquals(ERR_get_error(), ERR_LIB_SSL, SSL_R_EXCESS_HANDSHAKE_DATA));', 'explanation': 'This segment simulates receiving handshake messages in an unexpected order by providing all handshake data in one chunk. The resulting error SSL_R_EXCESS_HANDSHAKE_DATA demonstrates that the unexpected message condition (C1) is met.'}}, {'A1': {'code': 'EXPECT_EQ(transport_->client()->alert(), SSL_AD_UNEXPECTED_MESSAGE);', 'explanation': ""After detecting the error condition, the code verifies that the client aborts the handshake by sending an alert with the value SSL_AD_UNEXPECTED_MESSAGE. This directly implements the action of aborting the handshake with the 'unexpected_message' alert (A1).""}}]",The function simulates a scenario where handshake messages are received out-of-order by injecting handshake data improperly. It then confirms that the handshake operation aborts with the error SSL_R_EXCESS_HANDSHAKE_DATA and that the client sends an alert with the unexpected_message code. This direct in-function check covers both the condition (handshake message in an unexpected order) and the action (sending an 'unexpected_message' alert) as specified by the RFC.,success,
10234,TEST_F,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Partially Matches,"[{'C1': {'code': 'ASSERT_EQ(SSL_do_handshake(client_.get()), -1);\nASSERT_EQ(SSL_get_error(client_.get(), -1), SSL_ERROR_SSL);\nEXPECT_TRUE(ErrorEquals(ERR_get_error(), ERR_LIB_SSL, SSL_R_EXCESS_HANDSHAKE_DATA));', 'explanation': 'This segment confirms that if extra handshake data (which can be interpreted as data sent before the Finished message is properly handled) is delivered, the handshake fails with the appropriate error. This check aligns with the RFC requirement that application data must not be sent prematurely.'}}, {'A1': {'code': 'ASSERT_TRUE(transport_->client()->has_alert());\nEXPECT_EQ(transport_->client()->alert_level(), ssl_encryption_handshake);\nEXPECT_EQ(transport_->client()->alert(), SSL_AD_UNEXPECTED_MESSAGE);', 'explanation': 'This segment verifies that an alert is sent upon detecting out‐of-order data, implementing the action expected (sending an alert) when the protocol requirement is violated.'}}]","The function tests a scenario in which extra handshake data—interpretable as application data sent before the Finished message—is introduced. It then asserts that such an occurrence is correctly flagged with an error (SSL_R_EXCESS_HANDSHAKE_DATA) and that an alert is generated. While these checks address key elements of the RFC requirement (the disallowance of premature application data and the issuance of an alert), the function only covers these specific error-handling behaviors and not the entire spectrum of related protocol logic, resulting in a partial match.",success,
10237,TEST_F,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The RFC specification requires that the OpenPGP certificate type MUST NOT be used with TLS 1.3. The provided function, however, is a QUIC method test that focuses on handling post-handshake junk data and verifying session handshakes. There is no code in this function that checks, prevents, or otherwise handles the use of the OpenPGP certificate type with TLS 1.3. Therefore, the function does not visibly address any conditions or actions related to the RFC6091 requirement.",success,
10237,TEST_F,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Does Not Match,[],"The RFC requires that TLS implementations must not automatically enable or resend 0-RTT data unless explicitly requested by the application. This function, however, solely tests the response to invalid post-handshake data and does not contain any logic addressing 0-RTT enablement or retransmission behavior. Therefore, none of the specified conditions or actions are visible within this function's body.",success,
10237,TEST_F,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function focuses on the post-handshake QUIC data processing by deliberately sending junk data and checking that it triggers an error. It does not contain any logic that prevents early data from being automatically resent, as specified in the RFC requirement ('A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate'). None of the code segments address any labeled condition or action related to early data handling. Therefore, in isolation, this function does not visibly implement any of the specified constraints.",success,
10252,TEST_P,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function primarily establishes SSL connections and handles the handshake process, including deliberately rejecting the server certificate to trigger a certificate verification failure. It does not contain any logic to enforce or verify that Application Data is not sent before the Finished message, which is the requirement specified in the RFC constraint. No segments in this function demonstrate checks or prevention mechanisms regarding sending application data prior to the Finished message; thus, it does not address the labeled constraint.",success,
10259,TEST,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function does not address the RFC6091 requirement regarding the prohibition of using the OpenPGP certificate type with TLS 1.3. In this function, the protocol version is explicitly restricted to TLS 1.2 by setting both the minimum and maximum protocol versions, and there is no logic or condition handling the use or checking of certificate types (specifically OpenPGP certificates). The code focuses on SSL/TLS explicit renegotiation behavior rather than evaluating or enforcing certificate type restrictions as outlined by the RFC.",success,
10261,TEST,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Partially Matches,"[{'A1': {'code': 'bssl::UniquePtr<SSL_SESSION> session2(\n      SSL_SESSION_copy_without_early_data(session.get()));\n...\nEXPECT_EQ(ssl_early_data_unsupported_for_session,\n            SSL_get_early_data_reason(client.get()));', 'explanation': 'This segment creates a copy of an SSL session without early data, and then verifies that even when early data is enabled on the client, the handshake does not use 0-RTT (as indicated by the early data reason), effectively ensuring that early data is not automatically resent if rejected. This behavior aligns with the RFC requirement that 0-RTT data is not automatically resent unless explicitly permitted by the application.'}}]","The function tests the scenario of a session copy that disables early data, ensuring that even though the client has early data enabled, it will not automatically resend 0-RTT data when the session has been modified to disallow it. This directly addresses the portion of the RFC that forbids automatic resending of 0-RTT data (action A1). However, the function also explicitly enables early data on contexts and the initial session, which does not enforce the restriction that 0-RTT MUST NOT be enabled unless specifically requested. As a result, while the function demonstrates a method to avoid automatic early data retransmission, it only partially matches the overall RFC constraints.",success,
10261,TEST,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'C1': {'code': 'bssl::UniquePtr<SSL_SESSION> session2(\n    SSL_SESSION_copy_without_early_data(session.get()));\nASSERT_TRUE(session2);\n...\nSSL_set_session(client.get(), session2.get());\nSSL_set_early_data_enabled(client.get(), 1);\nEXPECT_TRUE(CompleteHandshakes(client.get(), server.get()));\nEXPECT_TRUE(SSL_session_reused(client.get()));\nEXPECT_EQ(ssl_early_data_unsupported_for_session,\n          SSL_get_early_data_reason(client.get()));', 'explanation': ""This code segment explicitly creates a copy of a session without early data using SSL_SESSION_copy_without_early_data, then verifies that early data is not resumed by checking that the early data reason is 'ssl_early_data_unsupported_for_session'. This ensures that the TLS implementation does not automatically resend early data, fulfilling the spec requirement.""}}]","The function implements the intended behavior by first allowing early data on the original session and then creating a copy of the session with early data disabled. It then performs a handshake to confirm that the session is resumed without automatically sending early data. These measures directly enforce the RFC specification that a TLS implementation SHOULD NOT automatically resend early data, demonstrating that the code function fully matches the constraint labeled C1.",success,
10265,SetUp,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The function 'SetUp()' solely initializes TLS contexts using TLS_method() and creates a test certificate. There is no logic within this function that checks or restricts the use of the OpenPGP certificate type with TLS 1.3, as required by the spec (RFC6091). No sections of the code address any constraints (e.g., C1, A1) regarding forbidding the OpenPGP certificate type with TLS 1.3.",success,
10273,GetExtensionOrder,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function, GetExtensionOrder, is focused on recording the order of ClientHello extensions by parsing them from the client_hello structure and storing them in a vector. There is no visible logic within this function that checks for or prevents the usage of the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages, as mandated by the TLS 1.3 specification. Therefore, the function does not implement or enforce the specified TLS 1.3 constraint regarding the status_request_v2 extension.",success,
10276,TEST,"Servers MAY send multiple tickets on a single connection, either immediately after each other or after specific events (see Appendix C.4).",240,Fully Matches,"[{'C1': {'code': 'EXPECT_EQ(count_tickets(), 2u);\n\nfor (size_t num_tickets : {0, 1, 2, 3, 4, 5}) {\n    SCOPED_TRACE(num_tickets);\n    ASSERT_TRUE(SSL_CTX_set_num_tickets(server_ctx.get(), num_tickets));\n    EXPECT_EQ(SSL_CTX_get_num_tickets(server_ctx.get()), num_tickets);\n    EXPECT_EQ(count_tickets(), num_tickets);\n}\n\n// Configuring too many tickets causes us to stop at some point.\nASSERT_TRUE(SSL_CTX_set_num_tickets(server_ctx.get(), 100000));\nEXPECT_EQ(SSL_CTX_get_num_tickets(server_ctx.get()), 16u);\nEXPECT_EQ(count_tickets(), 16u);', 'explanation': 'This test function explicitly verifies that the server is capable of sending multiple session tickets on a single connection. It checks the default behavior (expecting two tickets) and then various configurations by setting the number of tickets. The code thereby demonstrates that the server MAY send multiple tickets, fully addressing the spec requirement.'}}]","The provided function tests TLS session ticket behavior by setting and validating the number of tickets sent over a connection. By checking both the default (two tickets) and several configurable amounts (including a cap when too many are configured), the function directly implements the RFC specification that a server may send multiple tickets on a single connection. The logic for counting and verifying the tickets is self-contained within the function, which fully matches the spec condition labeled as C1.",success,
10276,TEST,"At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message.",238,Partially Matches,"[{'A1': {'code': 'static size_t ticket_count;\nSSL_CTX_sess_set_new_cb(client_ctx.get(), [](SSL *, SSL_SESSION *) -> int {\n    ticket_count++;\n    return 0;\n});\n\n... \nEXPECT_EQ(count_tickets(), 2u);\n\nfor (size_t num_tickets : {0, 1, 2, 3, 4, 5}) {\n    SCOPED_TRACE(num_tickets);\n    ASSERT_TRUE(SSL_CTX_set_num_tickets(server_ctx.get(), num_tickets));\n    EXPECT_EQ(SSL_CTX_get_num_tickets(server_ctx.get()), num_tickets);\n    EXPECT_EQ(count_tickets(), num_tickets);\n}\n\nASSERT_TRUE(SSL_CTX_set_num_tickets(server_ctx.get(), 100000));\nEXPECT_EQ(SSL_CTX_get_num_tickets(server_ctx.get()), 16u);\nEXPECT_EQ(count_tickets(), 16u);', 'explanation': ""The code installs a callback to count new session tickets and verifies that after the handshake the server sends a configured number of NewSessionTicket messages. This logic partially addresses the spec’s allowance for sending such tickets (i.e. the 'may send' behavior), even though it does not explicitly check that this happens only after receiving the client's Finished message.""}}]","The function tests the behavior of sending NewSessionTicket messages by configuring the ticket count and verifying the number of tickets sent via a callback after a handshake. This addresses part of the RFC requirement regarding NewSessionTicket messages. However, the specific timing condition stated in the RFC (i.e. that the ticket may be sent after the server has received the client's Finished message) is not explicitly enforced or verified by this function. Consequently, while the function embodies a partial implementation of the spec, it does not fully implement all aspects of the RFC constraint.",success,
10279,TEST,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The code function does not include any logic to address the RFC6091 requirement that the OpenPGP certificate type MUST NOT be used with TLS 1.3. The function is focused on testing behavior related to empty writes and handshake-related ticket flushing in TLS 1.3, but it does not check or enforce any constraints regarding the use of certificate types (such as OpenPGP). There is no corresponding code segment that implements any conditions (e.g., C1) or actions (e.g., A1) related to the OpenPGP certificate type constraint.",success,
10279,TEST,"At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message.",238,Fully Matches,"[{'C1': {'code': 'ASSERT_TRUE(CompleteHandshakes(client.get(), server.get()));\n// We defer NewSessionTicket to the first write, so the server has a pending\nint ret = SSL_write(server.get(), nullptr, 0);\nASSERT_EQ(ret, -1);\nASSERT_EQ(SSL_get_error(server.get(), ret), SSL_ERROR_WANT_WRITE);', 'explanation': ""After the handshake completes (which, by implication, means the server has received the Client Finished message), the code performs an empty write on the server. This triggers the flush of a pending NewSessionTicket in accordance with the RFC, which stipulates that the server MAY send a NewSessionTicket after the client's Finished message.""}}]","The function establishes a TLS 1.3 connection and completes the handshake, thereby satisfying the condition that the server has received the client Finished message. It then explicitly tests the behavior of deferring the NewSessionTicket until the first write operation. The empty write attempt causes the server to try to flush the pending ticket, matching the RFC's allowance for sending a NewSessionTicket at any time post-handshake. Thus, the code function visibly implements the spec constraint within its own logic.",success,
10279,TEST,"Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure.",283,Does Not Match,[],"The provided function is a test for TLS handshake and I/O behavior in scenarios with pending handshake data and new session ticket processing. Although it does issue an empty write (i.e. SSL_write with a length of 0), this action is taken to verify error handling (SSL_ERROR_WANT_WRITE) in that specific context, rather than to implement the RFC specification that suggests zero‐length fragments MAY be sent as a traffic analysis countermeasure. Moreover, the function does not contain any logic that relates to HTTP preconditions or cache evaluations described in the specification context. Hence, there is no visible logic in the function that directly implements any labeled condition (C1, C2, etc.) or action (A1, A2, etc.) from the provided RFC spec.",success,
10280,TEST,"If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation MUST receive a ""close_notify"" alert before indicating end-of-data to the application layer.",318,Partially Matches,"[{'C1': {'code': ""  // Send a close_notify from the server. It should return 0 because\n  // close_notify was sent, but not received. Confusingly, this is a success\n  // output for |SSL_shutdown|'s API.\n  EXPECT_EQ(SSL_shutdown(server.get()), 0);\n\n  // Read the close_notify on the client.\n  uint8_t buf[1];\n  ret = SSL_read(client.get(), buf, sizeof(buf));\n  EXPECT_EQ(ret, 0);\n  EXPECT_EQ(SSL_get_error(client.get(), ret), SSL_ERROR_ZERO_RETURN);\n\n  // Further calls to |SSL_read| continue to report |SSL_ERROR_ZERO_RETURN|.\n  ret = SSL_read(client.get(), buf, sizeof(buf));\n  EXPECT_EQ(ret, 0);\n  EXPECT_EQ(SSL_get_error(client.get(), ret), SSL_ERROR_ZERO_RETURN);"", 'explanation': 'This segment tests that the TLS implementation does not indicate end‐of‐data until a close_notify alert is received. It verifies that after the server initiates a shutdown (and sends close_notify), the client’s SSL_read returns 0 with SSL_ERROR_ZERO_RETURN, matching the requirement that close_notify must be received before end-of-data is indicated.'}}]","The function tests part of the TLS shutdown behavior specified in the RFC: it ensures that a close_notify alert is processed (as evidenced by SSL_read returning 0 with SSL_ERROR_ZERO_RETURN) before the connection is treated as closed. However, the RFC and its context also discuss HTTP-level connection handling (such as not sending further requests after a 'close' option) which is not addressed in this function. Therefore, while the code visibly implements the TLS close_notify handling requirement (C1), it does not address the complete HTTP RFC context, and thus only partially matches the specification.",success,
10280,TEST,"Either party MAY initiate a close of its write side of the connection by sending a ""close_notify"" alert.",315,Fully Matches,"[{'C1': {'code': 'EXPECT_EQ(SSL_shutdown(server.get()), 0);', 'explanation': 'This call initiates the sending of a close_notify alert from the server side, which aligns directly with the spec that either party may initiate a close on its write side with a close_notify alert.'}}, {'A1': {'code': 'ret = SSL_read(client.get(), buf, sizeof(buf));\nEXPECT_EQ(ret, 0);\nEXPECT_EQ(SSL_get_error(client.get(), ret), SSL_ERROR_ZERO_RETURN);', 'explanation': 'These lines read from the client side and verify that the close_notify alert was received (indicated by SSL_ERROR_ZERO_RETURN), fulfilling the action of detecting and acting upon a graceful shutdown.'}}]","The function demonstrates the sending of a close_notify alert by invoking SSL_shutdown on the server, and subsequently the client correctly receives this alert as validated by SSL_read returning 0 with SSL_ERROR_ZERO_RETURN. This matches the RFC specification requirement that either party may close its write side of the connection using a close_notify alert. Additionally, the function tests that write operations continue to produce a SSL_ERROR_SYSCALL even after the alert has been received, further confirming proper handling of connection closure.",success,
10280,TEST,"Each party MUST send a ""close_notify"" alert before closing its write side of the connection, unless it has already sent some error alert",317,Partially Matches,"[{'C1': {'code': '  // Send a close_notify from the server. It should return 0 because\n  // close_notify was sent, but not received. ...\n  EXPECT_EQ(SSL_shutdown(server.get()), 0);\n\n  // Read the close_notify on the client.\n  uint8_t buf[1];\n  ret = SSL_read(client.get(), buf, sizeof(buf));\n  EXPECT_EQ(ret, 0);\n  EXPECT_EQ(SSL_get_error(client.get(), ret), SSL_ERROR_ZERO_RETURN);', 'explanation': ""This segment demonstrates that the server sends a close_notify alert (via SSL_shutdown returning 0) and that the client subsequently detects the alert (with SSL_read returning 0 and SSL_ERROR_ZERO_RETURN). This addresses the requirement that a party must send a close_notify before closing its write side. However, since the function's primary focus is on error conditions manifesting as write failures and ensuring proper error reporting after close_notify, it only partially implements the overall spec concerning close_notify handling.""}}]","The function tests behavior related to close_notify alerts by forcing a write error and then performing a shutdown that sends a close_notify alert from the server. It verifies that the client correctly recognizes the alert even when subsequent write attempts continue to fail. While this logic addresses part of the RFC requirement (namely that a close_notify is sent and eventually observed), the function does not comprehensively cover all aspects of the spec. Therefore, the implementation is considered a partial match.",success,
10280,TEST,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided code function is a test case that focuses on simulating and handling error conditions during SSL/TLS operations (e.g., write failures, shutdown behavior, close_notify handling). It does not contain any logic to disable or avoid the use of RC4 cipher suites. The RFC specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites, but the code does not appear to address or enforce this constraint. Therefore, no part of this function visibly implements the specified requirement.",success,
10280,TEST,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Does Not Match,[],"The provided function 'ErrorSyscallAfterCloseNotify' focuses on testing error handling behavior when write operations fail and managing shutdown notifications. It does not contain any logic or code that explicitly prevents SSL 3.0 from being negotiated, as required by the RFC which disallows the use of SSL 3.0 due to its insufficient security. There is no reference to SSL 3.0 or its prohibition in the function_body. Therefore, the function does not implement the specified RFC constraints.",success,
10286,TEST_P,"In particular, it MUST NOT negotiate TLS 1.3.",14,Does Not Match,[],"The provided function is a test case for various certificate/key/chain configurations, but it does not contain any logic that enforces or checks the prohibition of negotiating TLS 1.3 as required by the spec constraint. Although the comments mention TLS 1.3 error codes (SSL_R_NO_CERTIFICATE_SET) to handle different TLS version behaviors, the function does not take any action to disable or prevent TLS 1.3 negotiation. Therefore, the code function does not visibly address the 'MUST NOT negotiate TLS 1.3' constraint.",success,
10290,TEST,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'A1': {'code': 'EXPECT_EQ(-1, SSL_do_handshake(client.get()));\nEXPECT_EQ(SSL_ERROR_SSL, SSL_get_error(client.get(), -1));\nEXPECT_TRUE(ErrorEquals(ERR_get_error(), ERR_LIB_SSL, SSL_R_WRONG_VERSION_ON_EARLY_DATA));', 'explanation': 'These code segments simulate a client sending early data while the server is forced to use TLS 1.2 (disabling TLS1.3’s 0-RTT support). The test verifies that when the client receives a ServerHello indicating a version mismatch, the early data is rejected and no automatic resend is attempted. This behavior is in line with the RFC requirement that a TLS implementation SHOULD NOT automatically resend early data.'}}]","The test function 'EarlyDataVersionMismatch' creates a scenario where a client configured to offer early data (in TLS 1.3) communicates with a server restricted to TLS 1.2. The ensuing handshake produces a version mismatch that leads to the early data being rejected, as verified by the handshake failure and error checks. This demonstrates that the implementation does not automatically resend early data, thereby directly addressing the RFC specification.",success,
10290,TEST,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function does not implement any logic related to the RFC specification regarding the OpenPGP certificate type MUST NOT be used with TLS 1.3. Instead, the function tests TLS 1.3 early data handling and version mismatch behavior when the server is explicitly restricted to TLS 1.2. No code within the function checks for or prevents the use of the OpenPGP certificate type with TLS 1.3.",success,
10290,TEST,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Partially Matches,"[{'C1': {'code': 'SSL_CTX_set_early_data_enabled(client_ctx.get(), 1);\nSSL_CTX_set_early_data_enabled(server_ctx.get(), 1);', 'explanation': 'The test explicitly enables early data on both client and server contexts. Since the RFC mandates that 0-RTT should not be enabled unless the application requests it, calling these functions simulates an explicit application request.'}}, {'A1': {'code': 'EXPECT_EQ(-1, SSL_do_handshake(server.get()));\nEXPECT_EQ(SSL_ERROR_WANT_READ, SSL_get_error(server.get(), -1));\n\nEXPECT_EQ(-1, SSL_do_handshake(client.get()));\nEXPECT_EQ(SSL_ERROR_SSL, SSL_get_error(client.get(), -1));\nEXPECT_TRUE(ErrorEquals(ERR_get_error(), ERR_LIB_SSL, SSL_R_WRONG_VERSION_ON_EARLY_DATA));', 'explanation': 'The function tests that when the server—configured to use TLS 1.2—receives a ClientHello that offers 0-RTT data based on a TLS 1.3 session, the early data is rejected. This behavior confirms that early data is not automatically resent, which aligns with the RFC requirement.'}}]","This test function simulates an application explicitly requesting early (0-RTT) data by directly enabling it. It then forces a scenario (version mismatch by having the server only support TLS 1.2) where the early data should be rejected. The subsequent failure of the handshake with a fatal error indicates that early data is not being automatically resent after rejection. While these checks cover aspects of the RFC (enabling early data only upon explicit request and not automatically resending it upon rejection), the function only simulates one scenario and does not implement all possible conditions implied by the specification. Hence, it partially matches the specified constraints.",success,
10290,TEST,"To avoid a downgrade attack, the client SHOULD NOT disable TLS 1.3, only 0-RTT.",385,Fully Matches,"[{'C1': {'code': 'EXPECT_EQ(SSL_version(client.get()), TLS1_3_VERSION);', 'explanation': 'This check confirms that even after a version mismatch (with the server forcing TLS 1.2), the client continues reporting TLS1.3. It directly ensures that the client does not disable TLS1.3.'}}, {'A1': {'code': 'SSL_CTX_set_early_data_enabled(client_ctx.get(), 1);', 'explanation': 'By enabling early data on the client (and not disabling TLS1.3), the code ensures that only 0-RTT (early data) may be negotiated and potentially rejected, which satisfies the requirement to avoid a downgrade attack by not disabling TLS1.3.'}}]","The provided function sets up and tests a scenario where early data is enabled and later rejected because the server deliberately disables TLS 1.3 by capping its maximum protocol version to TLS1.2. Despite the rejection of early data, the client continues to operate as TLS1.3, as confirmed by the SSL_version checks. This behavior directly implements the RFC specification requirement that to avoid a downgrade attack, the client should not disable TLS1.3 but only disable early data (0‑RTT). All relevant logic is contained within the function_body.",success,
10290,TEST,A client that attempts to send 0-RTT data MUST fail a connection if it receives a ServerHello with TLS 1.2 or older.,384,Fully Matches,"[{'C1': {'code': 'SSL_CTX_set_max_proto_version(server_ctx.get(), TLS1_2_VERSION);', 'explanation': 'This line forces the server to use TLS 1.2 by setting its maximum protocol version, thereby creating the condition where a client that attempted 0-RTT (a TLS 1.3 feature) will receive a ServerHello from a TLS 1.2 server.'}}, {'A1': {'code': 'EXPECT_EQ(-1, SSL_do_handshake(client.get()));\nEXPECT_EQ(SSL_ERROR_SSL, SSL_get_error(client.get(), -1));\nEXPECT_TRUE(ErrorEquals(ERR_get_error(), ERR_LIB_SSL, SSL_R_WRONG_VERSION_ON_EARLY_DATA));', 'explanation': 'These checks verify that after receiving a TLS 1.2 ServerHello, the client fails the handshake with the correct error (indicating wrong version on early data) as required by the spec.'}}]","The function sets up a client and server where the server is deliberately limited to TLS 1.2. Since the client enables 0-RTT (a TLS 1.3 feature), it anticipates a TLS 1.3 handshake. When the server responds with a TLS 1.2 ServerHello, the function verifies that the client fails the connection with a specific error code (SSL_R_WRONG_VERSION_ON_EARLY_DATA). This implementation directly addresses the spec requirement that a client attempting to send 0-RTT data must fail when receiving a ServerHello with TLS 1.2 or older.",success,
10290,TEST,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'SSL_CTX_set_max_proto_version(server_ctx.get(), TLS1_2_VERSION);', 'explanation': 'This line explicitly limits the server’s maximum protocol version to TLS1.2, thereby ensuring that TLS1.3 is not negotiated. This directly satisfies the RFC requirement that it MUST NOT negotiate TLS 1.3.'}}]","The function's core logic sets up the client and server contexts with early data enabled and then explicitly disables TLS1.3 on the server by setting its maximum protocol version to TLS1.2. This ensures that even though the client may predict TLS1.3, the server will only negotiate TLS1.2, leading to an early data version mismatch. Hence, the function fully implements the spec constraint concerning TLS versions independently of any external dependencies.",success,
10291,TEST,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The code function focuses on setting up DTLS 1.3 contexts with early data enabled and verifies that early data is disabled in an SSL session. It does not implement any checks, restrictions, or logic related to the use of the OpenPGP certificate type with TLS 1.3 as specified in RFC6091. There is no logic within this function that addresses any conditions or actions pertaining to the OpenPGP certificate type limitation.",success,
10292,TEST,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The RFC specification requires that the OpenPGP certificate type MUST NOT be used with TLS 1.3. However, the provided function_body does not contain any logic or checks related to the OpenPGP certificate type. It primarily sets up and manipulates a TLS 1.3 session (e.g., configuring session caching, setting the maximum protocol version to TLS 1.3, and testing session resumability) with no reference to certificate types or constraints from RFC6091. Therefore, the function does not visibly address any condition or action related to the specified RFC.",success,
10295,TEST,"As servers MAY require the presence of the ""server_name"" extension, clients SHOULD send this extension, when applicable.",207,Partially Matches,"[{'C1': {'code': 'ASSERT_TRUE(SSL_early_callback_ctx_extension_get(&client_hello, TLSEXT_TYPE_server_name, &data, &len));\nEXPECT_EQ(Bytes(data, len), Bytes(kServerName));', 'explanation': ""This segment verifies that the 'server_name' extension is present in the parsed ClientHello, which aligns with the RFC requirement that clients SHOULD send this extension when applicable.""}}]","The function explicitly checks for the presence and correctness of the 'server_name' extension in the ClientHello message (meeting condition C1). However, the RFC also discusses the use and handling of trailer sections for HTTP chunked messages, which this function does not address. Since only part of the specification (the server_name extension requirement) is implemented in the function, the overall outcome is 'Partially Matches'.",success,
10295,TEST,"The ""signature_algorithms"" extension MUST be specified, and other extensions may optionally be included if defined for this message.",182,Partially Matches,[],"The RFC requires that the ""signature_algorithms"" extension must be specified. In this test function the input ClientHello messages (both TLS and DTLS versions) include the signature_algorithms extension. The function causes SSL_parse_client_hello to process the entire ClientHello including its extensions and then verifies that the parsed block of extensions (which implicitly contains the signature_algorithms extension) exactly matches the trailing bytes of the input message. However, there is no explicit logic in the function that individually checks or interprets the signature_algorithms extension. Instead, it only does a byte‐for‐byte equality check on the overall extensions field. Because of this, although the input message complies with the RFC (by having the mandatory signature_algorithms extension), the function does not visibly single out or enforce that particular constraint. Thus, the function partially addresses the specification requirement.",success,
10295,TEST,"A client MUST NOT include the ""early_data"" extension in its followup ClientHello.",148,Does Not Match,[],"The RFC specification requires that a client MUST NOT include the 'early_data' extension in its followup ClientHello. In the provided code, the only check regarding extensions is an EXPECT_FALSE call on SSL_early_callback_ctx_extension_get with TLSEXT_TYPE_encrypted_client_hello. This does not correspond to checking for an 'early_data' extension. There is no visible logic in the function that inspects or rejects an 'early_data' extension as specified. Therefore, the code function does not address the given constraint.",success,
10295,TEST,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The provided code function ParseClientHello is focused on parsing the ClientHello message, including extracting fields such as random, session_id, server_name, and various extensions. Although it processes a psk_key_exchange_modes extension from the ClientHello input, it does not implement any logic to enforce the RFC requirement that ""the server MUST NOT send a 'psk_key_exchange_modes' extension."" The function does not include any decision-making or handling that prevents sending this extension in server responses. Therefore, no part of the function's logic addresses the specified constraint (labeled here as C1/A1) from the RFC.",success,
10295,TEST,"-If not containing a ""pre_shared_key"" extension, it MUST contain both a ""signature_algorithms"" extension and a ""supported_groups"" extension.",348,Does Not Match,[],"The RFC requires that if the 'pre_shared_key' extension is not present, the message MUST include both 'signature_algorithms' and 'supported_groups' extensions. In the function_body, although the client hello messages include these extensions in the test vectors, there is no visible logic in the function that verifies or enforces this requirement. The function simply parses the client hello message and validates fields such as server_name and cookie, but it does not perform any conditional checks to ensure that when a 'pre_shared_key' extension is absent, both 'signature_algorithms' and 'supported_groups' are present. Therefore, there is no code segment that directly implements this specific RFC constraint.",success,
10295,TEST,Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less.,395,Does Not Match,[],"The RFC constraint requires that implementations must not send a ClientHello with a legacy_version set to 0x0300 or less. In the function, while test vectors are used with legacy_version values (0x03,0x03 for TLS and 0xfe,0xfd for DTLS) that conform to the RFC, there is no logic within the function that enforces or checks that a legacy_version of 0x0300 or less is not sent. The function only parses the provided client hello messages and verifies their contents, without implementing any mechanism that prevents the sending of invalid legacy_version values. Thus, the constraint is not visibly addressed within the function_body.",success,
10295,TEST,"-If containing a ""supported_groups"" extension, it MUST also contain a ""key_share"" extension, and vice versa.",349,Does Not Match,[],"The provided function_body tests the parsing of client hello messages using fixed test vectors that already include both the supported_groups and key_share extensions. However, there is no explicit internal logic or verification within the function that checks the RFC requirement: that if a message contains a supported_groups extension then it MUST also contain a key_share extension, and vice versa. The function merely verifies that the overall parsed output matches the expected bytes, without confirming that the two extensions are conditionally interdependent. Therefore, in isolation, the function does not visibly enforce the specified RFC constraint.",success,
10295,TEST,Such a ClientHello message MUST meet the following requirements:,347,Fully Matches,"[{'C1': {'code': 'EXPECT_EQ(client_hello.version, dtls ? DTLS1_2_VERSION : TLS1_2_VERSION);', 'explanation': 'This line verifies that the legacy_version field in the ClientHello message matches the expected TLS or DTLS version as mandated by the RFC.'}}, {'C2': {'code': 'EXPECT_EQ(Bytes(client_hello.random, client_hello.random_len), Bytes(kRandom));', 'explanation': 'This check confirms that the random field in the ClientHello message is parsed correctly and matches the expected bytes.'}}, {'C3': {'code': 'EXPECT_EQ(Bytes(client_hello.session_id, client_hello.session_id_len), Bytes(kSessionID));', 'explanation': 'This verifies that the legacy_session_id is correctly extracted from the message as required by the spec.'}}, {'A1': {'code': 'if (dtls) {\n  static const uint8_t kCookie[] = {0x01, 0x02, 0x03, 0x04};\n  EXPECT_EQ(Bytes(client_hello.dtls_cookie, client_hello.dtls_cookie_len), Bytes(kCookie));\n} else {\n  EXPECT_EQ(client_hello.dtls_cookie, nullptr);\n  EXPECT_EQ(client_hello.dtls_cookie_len, 0u);\n}', 'explanation': 'This code branch conditionally checks the DTLS-specific legacy_cookie (dtls_cookie), ensuring that when DTLS is used the cookie is parsed correctly, and when not, it is absent. This matches the RFC requirement for DTLS ClientHello messages.'}}, {'A2': {'code': 'std::vector<uint8_t> trailing_data(in.begin(), in.end());\ntrailing_data.push_back(0);\nEXPECT_FALSE(SSL_parse_client_hello(ssl.get(), &client_hello, trailing_data.data(), trailing_data.size()));\nEXPECT_TRUE(ErrorEquals(ERR_get_error(), ERR_LIB_SSL, SSL_R_CLIENTHELLO_PARSE_FAILED));', 'explanation': 'This segment ensures that any trailing or extra data beyond the valid ClientHello message is rejected, which is a required behavior by the RFC.'}}]","The provided function is a test routine that verifies the parsing of a ClientHello message against the expected RFC requirements. It checks critical fields including the legacy version, random, session_id, and DTLS cookie handling, as well as the proper processing of extensions (such as the server_name extension) and rejection of malformed input (e.g. trailing data or invalid bytes). Each check corresponds directly to specific conditions (C1, C2, C3) and actions (A1, A2) as might be specified in the RFC constraints. As such, the function alone visibly implements all the intended spec constraints within its logic.",success,
10295,TEST,"For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS.",22,Partially Matches,"[{'C1': {'code': 'static const uint8_t kCompressionMethods[] = {0x00};\nEXPECT_EQ(Bytes(client_hello.compression_methods, client_hello.compression_methods_len), Bytes(kCompressionMethods));', 'explanation': 'This segment verifies that the parsed ClientHello message’s legacy_compression_methods field is exactly one byte containing 0x00, which is the TLS 1.3 requirement. However, the function does not address the Max-Forwards related conditions from the provided spec context.'}}]","The function directly tests the TLS 1.3 ClientHello parsing and specifically checks that the compression methods vector contains exactly one zero byte, thereby implementing that part of the RFC. It does not include any logic to handle conditions or actions related to a Max-Forwards header or other HTTP-related context, so while it addresses the TLS compression method check (C1), it only partially matches the full spec constraints provided.",success,
10295,TEST,"In TLS 1.3, the client indicates its version preferences in the ""supported_versions"" extension (Section 4.2.1) and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.",15,Partially Matches,"[{'A1': {'code': 'EXPECT_EQ(client_hello.version, dtls ? DTLS1_2_VERSION : TLS1_2_VERSION);', 'explanation': ""This line verifies that the legacy_version field in the parsed ClientHello is set to TLS1_2_VERSION (0x0303 for TLS) or the corresponding DTLS version, which addresses the RFC requirement that legacy_version must be set to 0x0303 in TLS 1.3. However, while the test input includes a supported_versions extension indicating version preferences, the function does not explicitly validate or extract the client's version advertised in that extension.""}}]","The provided code function includes logic that checks the legacy_version field against the expected TLS1_2_VERSION, thus fulfilling the RFC requirement that legacy_version is set to 0x0303 (for TLS). However, although the test vector contains the supported_versions extension which should indicate the client's version preference in TLS 1.3, the function does not explicitly check the contents of this extension. Therefore, the function only partially implements the RFC specification related to version negotiation by itself.",success,
10295,TEST,"Clients which desire the server to authenticate itself via a certificate MUST send the ""signature_algorithms"" extension.",82,Does Not Match,[],"The provided function is a test case that parses a ClientHello message and verifies various fields such as random, session_id, cipher_suites, and extensions. Although the constructed ClientHello messages include a signature_algorithms extension, the function does not contain any explicit logic that addresses the RFC requirement stating that clients desiring server certificate authentication MUST send the signature_algorithms extension. In other words, there is no code that checks for or enforces this specific constraint within the function_body itself; it merely processes a pre-constructed message that already contains the extension without validating the necessity of its presence. Consequently, the function does not visibly implement the specified RFC constraint.",success,
10295,TEST,"Implementations which have the same policy in both cases MAY omit the ""signature_algorithms_cert"" extension.",85,Does Not Match,[],"The spec requires that implementations may omit the ""signature_algorithms_cert"" extension if the policy is the same in both cases. The provided function_body, however, is focused on parsing a ClientHello message by validating various fields, including the ""signature_algorithms"" extension, and does not contain any logic to address or implement the optional omission of the ""signature_algorithms_cert"" extension. No part of this function explicitly handles or checks the condition specified in the RFC. Therefore, the function does not visibly address the labeled spec constraint.",success,
10299,NewClientContext,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function focuses on creating a TLS client context by setting up credentials using a SPAKE2+ client protocol and does not contain any logic that checks or prevents the use of the OpenPGP certificate type with TLS 1.3. There is no visible code addressing any condition (e.g., C1) or action (e.g., A1) that relates to the RFC6091 specification regarding the OpenPGP certificate type in TLS 1.3. The function does not perform any checks about the certificate type being used, and thus it does not implement the specified RFC constraint.",success,
10300,NewServerContext,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function solely creates an SSL context using TLS_method() and sets up credentials using SSL_CREDENTIAL_new_spake2plusv1_server. There is no logic within the function that checks or prevents the use of the OpenPGP certificate type with TLS 1.3, as mandated by RFC6091. None of the spec constraints (e.g., any conditions like C1 or actions like A1) are addressed in the function body.",success,
10304,TEST_F,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function tests handshake limits and client-server interactions related to password verification and brute-force resistance, but it does not contain any code that explicitly addresses the RFC requirement to not offer or negotiate RC4 cipher suites. There is no logic disabling or checking for RC4 or handling cipher negotiation within this function.",success,
10304,TEST_F,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The RFC specification requires that application data is not sent prior to sending the Finished message. The function_body is focused on testing handshake limits and credential validations (e.g., counting unfinished handshakes against a limit and validating credentials using PAKE), rather than enforcing or checking the ordering of message transmission related to the Finished message. There is no visible logic within the function_body that ensures that application data is not sent before the Finished message. Therefore, none of the labeled conditions (e.g., C1) or actions (e.g., A1) corresponding to the RFC constraint are implemented in this code function.",success,
10308,Init,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification requires that implementations must not use the Truncated HMAC extension. The given function only initializes AEAD contexts by creating null cipher objects for read and write epochs. It does not contain any logic that checks for, prevents, or even references the Truncated HMAC extension. Thus, within this function's own code, there is no implementation addressing the spec constraint related to the Truncated HMAC extension.",success,
10325,ssl_free,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function 'ssl_free' only handles shutdown and freeing of an SSL object and does not address any logic related to prohibiting or negotiating RC4 cipher suites as required by the specification. No part of its code inspects, rejects, or filters out RC4 usage.",success,
10329,dtls1_open_app_data,"Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure.",283,Fully Matches,"[{'C1': {'code': 'if (record.empty()) {\n    return ssl_open_record_discard;\n}', 'explanation': 'This code segment explicitly checks if the application data record is empty and then discards it, which is in line with the RFC specification that allows zero‐length fragments of Application Data. By not treating an empty fragment as an error and simply discarding it, the function adheres to the permitted behavior as described in the spec.'}}]","The RFC states that zero-length fragments of Application Data may be sent, and the function dtls1_open_app_data implements corresponding logic by checking for an empty record and discarding it. No additional handling is necessary since the RFC only requires acceptance of such fragments, not further processing. Therefore, the function fully meets the relevant specification constraint.",success,
10329,dtls1_open_app_data,"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",272,Fully Matches,"[{'C1': {'code': 'if (type != SSL3_RT_APPLICATION_DATA) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_RECORD);\n    *out_alert = SSL_AD_UNEXPECTED_MESSAGE;\n    return ssl_open_record_error;\n  }', 'explanation': 'This code segment checks if the received record type is not SSL3_RT_APPLICATION_DATA, and if so, it issues an error by setting the alert to SSL_AD_UNEXPECTED_MESSAGE and terminating the connection—directly implementing the RFC requirement.'}}]","The function explicitly detects unexpected record types. When a record type other than the expected application data is received, it responds by setting the 'unexpected_message' alert and terminating the connection. This behavior exactly fulfills the RFC specification that mandates termination with an unexpected_message alert upon receipt of an unexpected record type.",success,
10329,dtls1_open_app_data,-Handshake messages MUST NOT be interleaved with other record types.,275,Partially Matches,"[{'C1': {'code': 'if (type == SSL3_RT_HANDSHAKE) {\n    // Process handshake fragments for DTLS 1.3 post-handshake messages.\n    if (ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n      if (!dtls1_process_handshake_fragments(ssl, out_alert, record_number, record)) {\n        return ssl_open_record_error;\n      }\n      return ssl_open_record_discard;\n    }\n    ...\n}', 'explanation': 'The function explicitly checks if the incoming record is of type handshake and then processes or discards it rather than passing it to the application. This handling ensures that handshake messages are kept separate from application data, which partially addresses the RFC requirement that handshake messages MUST NOT be interleaved with other record types.'}}]","The function distinguishes records by type. When a handshake message is received, it is processed internally (or discarded) instead of being delivered as application data. This behavior partially meets the specification that handshake messages must not be interleaved with other record types. However, the function does not perform a full verification of record ordering or interleaving beyond this type‐based segregation, so it only partially matches the constraint.",success,
10330,dtls1_write_app_data,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Does Not Match,[],"The function dtls1_write_app_data deals solely with writing application data records in DTLS and does not include any logic that addresses the RFC requirement for alert messages, i.e. ensuring that alert messages are not fragmented across records and that multiple alert messages are not coalesced into a single TLSPlaintext record. The comment ""// DTLS does not split the input across records."" pertains only to application data and does not implement handling of alert messages as specified by the RFC.",success,
10330,dtls1_write_app_data,"Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure.",283,Fully Matches,"[{'C1': {'code': 'if (in.empty()) {\n    *out_bytes_written = 0;\n    return 1;\n}', 'explanation': 'This segment explicitly handles the case of zero-length fragments of Application Data by returning success (with 0 bytes written), which aligns with the RFC specification that such fragments MAY be sent.'}}]","The function checks if the input data is empty and, if so, returns success without error. This behavior directly addresses the RFC requirement that zero-length fragments of Application Data may be sent. No other parts of the RFC are required to be handled within this function, and by itself, it fully implements the relevant constraint.",success,
10330,dtls1_write_app_data,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Does Not Match,[],"The RFC specifies that TLS implementations must not enable 0-RTT (either sending or accepting) unless explicitly requested by the application and must not automatically resend 0-RTT data if rejected. In the provided function, there is only a TODO comment regarding the use of the 0-RTT epoch, but there is no implemented logic to check if 0-RTT has been specifically requested or to prevent automatic resending. This function does not include any conditional code addressing these requirements, hence it does not visibly implement the specified RFC conditions.",success,
10330,dtls1_write_app_data,-Handshake messages MUST NOT be interleaved with other record types.,275,Does Not Match,[],"The specified RFC states that handshake messages MUST NOT be interleaved with other record types. The provided function, dtls1_write_app_data, only writes application data (SSL3_RT_APPLICATION_DATA) and does not include any logic to handle or check handshake messages. There is no code in this function ensuring that handshake messages are kept separate from other record types. Thus, the function does not visibly address the RFC constraint.",success,
10330,dtls1_write_app_data,Application protocols MUST NOT use 0-RTT data without a profile that defines its use.,406,Does Not Match,[],"The RFC states that application protocols must not use 0-RTT data without a profile that defines its use. In the provided function, there is merely a TODO comment (""// TODO(crbug.com/381113363): Use the 0-RTT epoch if writing 0-RTT"") indicating that the handling for 0-RTT is not yet implemented. The function currently does not include any logic to verify whether 0-RTT data is allowed or whether an appropriate profile exists. Thus, within the function_body itself, none of the constraints from the RFC are fully addressed.",success,
10331,dtls1_write_record,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Does Not Match,[],"The provided dtls1_write_record function does not include any explicit logic related to the optional padding of the TLSCiphertext record as specified by the RFC ('implementations MAY choose to pad'). The function simply checks the input size, prepares a buffer, and calls dtls_seal_record to seal the record without any conditional or explicit handling of padding. Therefore, none of the labeled conditions (e.g., C1) or actions (e.g., A1) related to the option of padding are visibly implemented within this function.",success,
10332,dtls1_dispatch_alert,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, dtls1_dispatch_alert, is solely responsible for dispatching alert messages and does not include any logic related to the negotiation or exclusion of the RC4 cipher suites. The RFC specification mandates that implementations MUST NOT offer or negotiate RC4 cipher suites for any TLS version, but the code function does not reference, check, or handle any logic regarding cipher suites at all. Therefore, no part of the function addresses this requirement, resulting in an overall judgment of 'Does Not Match'.",success,
10334,Record,Servers SHOULD provide that level of replay safety by implementing one of the methods described in this section or by equivalent means.,334,Fully Matches,"[{'C1': {'code': 'if (seq_num > max_seq_num_) {\n    uint64_t shift = seq_num - max_seq_num_;\n    if (shift >= kWindowSize) {\n      map_.reset();\n    } else {\n      map_ <<= shift;\n    }\n    max_seq_num_ = seq_num;\n}', 'explanation': 'This segment checks whether the incoming sequence number is higher than the current maximum and adjusts the replay window accordingly. It directly implements the required replay safety method by shifting/resetting the window, which is one of the means to provide replay protection as required by the RFC.'}}, {'A1': {'code': 'uint64_t idx = max_seq_num_ - seq_num;\nif (idx < kWindowSize) {\n    map_[idx] = true;\n}', 'explanation': 'This part records the occurrence of the sequence number within the valid replay window. By marking the corresponding bit in the bitmap, it fulfills the action of marking a message as seen, thereby preventing replay.'}}]","The DTLSReplayBitmap::Record function implements a replay protection mechanism by maintaining a sliding window of sequence numbers using a bitmap. It checks if the new sequence number is beyond the current maximum (C1) and then appropriately shifts or resets the window. Finally, it records the sequence number within that window (A1). This approach directly addresses the RFC requirement for replay safety by implementing one of the recommended methods.",success,
10335,dtls_record_version,Implementations MUST NOT send any records with a version less than 0x0300.,397,Does Not Match,[],"The RFC requires that implementations MUST NOT send any records with a version less than 0x0300. However, in the function dtls_record_version, there is no explicit check to ensure that the returned record version is at least 0x0300. The function selects a version based solely on ssl->s3->version and the result of ssl_protocol_version(ssl) without verifying the lower bound. Thus, no part of the function's logic visibly enforces the constraint, and it does not meet the specified requirement.",success,
10341,parse_dtls13_record,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification requires that implementations MUST NOT use the Truncated HMAC extension. In this code function, there is no evidence of any handling, checking, or decision logic that relates to the truncated HMAC extension. The function solely focuses on parsing DTLS 1.3 records (reconstructing epoch, processing sequence numbers, decrypting record headers, etc.) and does not implement or reference any behavior that would prevent the use of a truncated HMAC extension. Therefore, the function does not address the specified RFC requirement.",success,
10344,dtls_open_record,The presence of padding does not change the overall record size limitations: the full encoded TLSInnerPlaintext MUST NOT exceed 2^14 + 1 octets.,304,Partially Matches,"[{'C1': {'code': 'size_t plaintext_limit = SSL3_RT_MAX_PLAIN_LENGTH + (has_padding ? 1 : 0);\nif (out->size() > plaintext_limit) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DATA_LENGTH_TOO_LONG);\n    *out_alert = SSL_AD_RECORD_OVERFLOW;\n    return ssl_open_record_error;\n}', 'explanation': 'This code segment enforces that the plaintext length, including the effect of padding (by adding 1 in TLS1.3), does not exceed the maximum TLSInnerPlaintext size of 2^14 + 1 octets, which directly implements the TLS record size limitation specified. However, the additional HTTP message framing and Content-Length conditions specified in the overall RFC context are not addressed in this function.'}}]","The function includes logic to check that the decrypted plaintext (TLSInnerPlaintext) does not exceed SSL3_RT_MAX_PLAIN_LENGTH plus an extra octet for padding when applicable, which corresponds to the TLS record size limitation given in the RFC specification regarding padding. Nonetheless, none of the HTTP framing concerns (such as invalid Content-Length or close-delimited responses) described in the specification context are addressed within the function. Thus, the function partially matches the specification by handling only the TLS inner plaintext size constraint.",success,
10344,dtls_open_record,Implementations MUST limit their scanning to the cleartext returned from the AEAD decryption.,302,Fully Matches,"[{'C1': {'code': 'if (!record.read_epoch->aead->Open(out, record.type, record.version,\n                                     dtls_aead_sequence(ssl, record.number),\n                                     record.header,\n                                     cbs_to_writable_bytes(record.body))) {\n    ...\n}\n\nif (out->size() > plaintext_limit) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DATA_LENGTH_TOO_LONG);\n    *out_alert = SSL_AD_RECORD_OVERFLOW;\n    return ssl_open_record_error;\n}\n\nif (has_padding) {\n    do {\n      if (out->empty()) {\n        OPENSSL_PUT_ERROR(SSL, SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n        *out_alert = SSL_AD_DECRYPT_ERROR;\n        return ssl_open_record_error;\n      }\n      record.type = out->back();\n      *out = out->subspan(0, out->size() - 1);\n    } while (record.type == 0);\n}', 'explanation': ""The function first decrypts the incoming ciphertext using the AEAD decryption (via a call to aead->Open) into the 'out' buffer and then performs all subsequent checks—such as verifying the plaintext length and scanning for padding—strictly on the decrypted 'out' data. This limits all scanning to the cleartext returned from the AEAD decryption, fully implementing the specified constraint.""}}]","The function decrypts the record using AEAD decryption and then limits all processing (length checks, padding removal, and extraction of the record type) exclusively to the plaintext stored in the 'out' buffer. Thus, the implementation directly addresses the RFC specification requiring that scanning be confined to the cleartext output of the decryption, and it does so entirely within the function body.",success,
10344,dtls_open_record,"Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure.",283,Does Not Match,[],"The RFC requirement states that zero‐length fragments of Application Data MAY be sent as a countermeasure, but the code function does not visibly implement logic to allow such fragments. In the case of an empty input (in.empty()), the function immediately returns ssl_open_record_partial, which is different from explicitly processing a valid zero‐length fragment. In the TLS1.3 path, the padding removal loop expects at least one byte to extract the record type; if the decrypted payload (out) is empty, it triggers an error (ssl_open_record_error). Therefore, within this function there is no logic that explicitly acknowledges or permits legitimate zero‐length Application Data fragments as described in the RFC spec.",success,
10344,dtls_open_record,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided code function does not contain any logic addressing the spec constraint regarding the Truncated HMAC extension from RFC6066. There is no verification, check, or implementation detail in the function that explicitly prevents or avoids the use of the Truncated HMAC extension. All the logic in the function relates to DTLS record processing and AEAD decryption rather than implementing any restriction on truncated HMAC; therefore, the function does not visibly address the specified constraint.",success,
10347,dtls_max_seal_overhead,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function calculates the maximum seal overhead for DTLS records by summing the record header length and AEAD overhead (with a DTLS 1.3 adjustment), but it does not include any logic that addresses or enforces the prohibition against using the Truncated HMAC extension as specified. There is no reference to truncated HMAC in the code, and thus the function does not visibly implement the spec’s requirement.",success,
10348,dtls_seal_prefix_len,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided code function does not include any logic related to ensuring that the Truncated HMAC extension is not used, as required by the RFC specification. Instead, it only calculates and returns the length of the DTLS seal prefix by summing the DTLS record header length and the explicit nonce length from the AEAD. There is no visible reference or check against using the Truncated HMAC extension in this function.",success,
10350,dtls_seal_record,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification requires that implementations must not use the Truncated HMAC extension. Within the function_body, there is no logic that checks for, prevents, or otherwise addresses the use of the Truncated HMAC extension. Although the function uses AEAD algorithms (which by their nature do not involve HMAC), there is no explicit code enforcing the exclusion of the Truncated HMAC extension. Since no labeled condition (e.g., C1) or action (e.g., A1) addressing the TRUNCATED HMAC extension is implemented within this function, it is concluded that the function does not attempt to implement the provided RFC constraint.",success,
10352,tls_set_read_state,Each sequence number is set to zero at the beginning of a connection and whenever the key is changed; the first record transmitted under a particular traffic key MUST use sequence number 0.,296,Fully Matches,"[{'C1': {'code': 'ssl->s3->read_sequence = 0;', 'explanation': 'This line resets the read sequence number to 0 whenever a new encryption state (or key) is set. This directly implements the RFC requirement that the first record transmitted under a particular traffic key must use sequence number 0.'}}]","The function tls_set_read_state includes explicit logic to reset the sequence number (via 'ssl->s3->read_sequence = 0;') when installing a new key. This behavior fulfills the specified RFC requirement that each sequence number is set to zero at the beginning of a connection and whenever the key changes. Other aspects of the RFC (such as additional robust handling of HTTP message formatting) are not relevant to this function, and thus in the context of the sequence number initialization the function fully meets the constraint.",success,
10352,tls_set_read_state,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Partially Matches,"[{'C1': {'code': 'if (level == ssl_encryption_early_data) {\n      return true;\n    }', 'explanation': 'In the QUIC branch, the function checks if the encryption level is early data and then immediately returns true without installing any early data key. This behavior prevents the automatic installation (and by implication, automatic resending) of early data, which aligns with the guideline that applications should decide when to retransmit early data. However, note that this check only exists in the QUIC-specific path, so the protection is not universal across all TLS paths.'}}]","The provided function includes a mechanism to avoid automatically installing early data keys in QUIC connections by returning early when the encryption level is for early data. This directly addresses the RFC’s recommendation that TLS implementations SHOULD NOT automatically resend early data. However, since this protective behavior is confined to the QUIC branch and does not appear to be applied for non‐QUIC TLS connections, we judge the implementation as partially matching the specification.",success,
10352,tls_set_read_state,"That is, if a handshake message is split over two or more records, there MUST NOT be any other records between them.",276,Does Not Match,[],"The RFC requires that if a handshake message is split over several records, no other records appear in between. In the provided function, the only relevant check is done by verifying if there are any unprocessed handshake data (via tls_has_unprocessed_handshake_data) and then aborting by issuing an error and alert. This logic does not explicitly verify or enforce the contiguity of handshake record segments as mandated by the RFC specification. Additionally, the other aspects of the spec (e.g., token68 syntax and authentication parameters handling) are not addressed within this function. Therefore, the function does not implement the specified RFC constraint.",success,
10352,tls_set_read_state,"Implementations MUST verify that all messages immediately preceding a key change align with a record boundary; if not, then they MUST terminate the connection with an ""unexpected_message"" alert.",278,Fully Matches,"[{'C1': {'code': 'if (tls_has_unprocessed_handshake_data(ssl)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_EXCESS_HANDSHAKE_DATA);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);\n    return false;\n}', 'explanation': ""This code explicitly checks if there is any unprocessed handshake data (indicating messages that do not align with a record boundary) immediately preceding a key change. If such data exists, it sends an 'unexpected_message' alert and terminates the function, directly fulfilling the RFC requirement.""}}]",The function 'tls_set_read_state' directly implements the specified RFC constraint by verifying that no leftover handshake data exists before a key change. The condition check using 'tls_has_unprocessed_handshake_data' and the subsequent call to 'ssl_send_alert' in case of violation fully match the requirement that all messages preceding a key change align with a record boundary.,success,
10352,tls_set_read_state,-Handshake messages MUST NOT be interleaved with other record types.,275,Fully Matches,"[{'C1': {'code': 'if (tls_has_unprocessed_handshake_data(ssl)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_EXCESS_HANDSHAKE_DATA);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);\n    return false;\n}', 'explanation': 'This code segment checks for any unprocessed handshake data before performing a cipher change. By rejecting the state change if handshake data remains, it prevents the interleaving of handshake messages with other record types as mandated by the RFC.'}}]","The function explicitly inspects for any leftover handshake data via tls_has_unprocessed_handshake_data. If such data exists, it aborts the operation to prevent any interleaved handshake messages with other record types, which directly implements the spec constraint. Since this check is self-contained in the function and no interleaving is allowed, the function fully addresses the specified requirement.",success,
10353,tls_set_write_state,Each sequence number is set to zero at the beginning of a connection and whenever the key is changed; the first record transmitted under a particular traffic key MUST use sequence number 0.,296,Fully Matches,"[{'A1': {'code': 'ssl->s3->write_sequence = 0;', 'explanation': 'This line resets the write sequence number to 0 after a new key (traffic key) is installed, ensuring that the first record transmitted under the new key uses sequence number 0, as required by the RFC specification.'}}]","The RFC specifies that the sequence number for records must be set to zero at the beginning of a connection and whenever the key is changed, so that the first record uses sequence number 0. In the provided function, the line 'ssl->s3->write_sequence = 0;' directly implements this requirement. There is no reliance on external dependencies for this behavior; the function itself resets the sequence number immediately after setting the new encryption context. Therefore, the function fully addresses the relevant specification constraint.",success,
10353,tls_set_write_state,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification prohibits the use of the Truncated HMAC extension. The function tls_set_write_state primarily focuses on setting up the AEAD encryption state, handling QUIC-specific cases, and managing write secrets for TLS. There is no logic in the function that checks, prevents, or otherwise deals with the Truncated HMAC extension. Therefore, none of the spec constraints (e.g., those labeled C1, A1, etc.) are visibly implemented within this function.",success,
10353,tls_set_write_state,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Partially Matches,"[{'C1': {'code': 'if (level == ssl_encryption_early_data) {\n      return true;\n    }', 'explanation': 'In the QUIC branch, the function checks if the encryption level is early data and returns immediately without installing a new write secret, thereby avoiding automatic retransmission of early data as per the spec. However, no similar handling is present in the non-QUIC code path.'}}]","The provided TLS function partially implements the RFC requirement 'SHOULD NOT automatically resend early data' by explicitly checking for the early data encryption level in the QUIC branch and returning early without setting up new keys. This avoids automatic retransmission in QUIC. However, for non-QUIC TLS connections, the function does not include logic to prevent automatic retransmission of early data, so it does not fully address the spec constraint on its own.",success,
10376,TLS_with_buffers_method,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The function 'TLS_with_buffers_method' only returns a pointer to a static SSL_METHOD structure and does not include any logic to check or enforce the RFC6091 constraint that the OpenPGP certificate type must not be used with TLS 1.3. There are no code segments within this function addressing any conditions (e.g., C1) or actions (e.g., A1) related to this RFC specification. All implementation details regarding certificate type usage or TLS version handling are absent.",success,
10382,TLSv1_server_method,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function, TLSv1_server_method, simply calls the TLSv1_method() without any logic that addresses the specified RFC requirement. The RFC states that the OpenPGP certificate type MUST NOT be used with TLS 1.3. There is no check or handling related to OpenPGP certificate types or TLS version 1.3 within this function. Therefore, none of the labeled conditions (e.g., C1) or actions (e.g., A1) from the spec constraints are implemented within this code function.",success,
10408,ssl_crypto_x509_ssl_auto_chain_if_needed,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function, ssl_crypto_x509_ssl_auto_chain_if_needed, deals solely with certificate chain building and validation during the TLS handshake. It contains no logic addressing the status_request_v2 extension nor does it implement any checks or behaviors related to ignoring its presence in ClientHello messages as required by the TLS 1.3 RFC specification. Therefore, this function does not visibly implement any of the labeled conditions or actions from the spec constraints.",success,
10414,SSL_get_peer_full_cert_chain,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Does Not Match,[],"The provided function only retrieves and returns the peer's certificate chain via an SSL session. It contains no logic addressing the specified RFC requirements such as sending an alert when terminating a connection or handling the 'close' connection option. No parts of the code implement any of the conditions (e.g., C1) or actions (e.g., A1) defined in the spec constraints.",success,
10505,ssl_negotiate_version,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function (ssl_negotiate_version) only implements logic for negotiating the TLS version and includes a workaround for a JDK 11 TLS 1.3 issue. It does not contain any code addressing the specific RFC requirement that TLS 1.3 servers must not act upon the status_request_v2 extension (i.e., it does not check for or conditionally omit sending the status_request_v2 extension in any messages). Therefore, no constraints labeled (e.g., C1, A1) from the spec constraints are implemented in this function.",success,
10505,ssl_negotiate_version,"In particular, it MUST NOT negotiate TLS 1.3.",14,Partially Matches,[],"The RFC specification requires that TLS 1.3 must not be negotiated under any circumstances. In the provided function, there is logic to skip TLS 1.3 (i.e. when (version == TLS1_3_VERSION && hs->apply_jdk11_workaround) is true), but that condition only kicks in for clients affected by the JDK 11 bug. This means that outside of that workaround scenario, TLS 1.3 might still be negotiated. Therefore, the function only partially addresses the spec constraint and does not fully implement the “MUST NOT negotiate TLS 1.3” requirement.",success,
10505,ssl_negotiate_version,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The provided function does not contain any explicit logic that addresses the RFC requirement stating that SSL 2.0 must not be negotiated. While the function iterates through versions and applies specific workarounds (such as for TLS 1.3), there is no visible condition or check related to SSL 2.0. All version filtering is delegated to functions like get_method_versions and ssl_supports_version, and no in-function code directly rejects or prohibits SSL 2.0 negotiation. Therefore, from the function_body alone, none of the labeled conditions or actions concerning the prohibition of SSL 2.0 are implemented.",success,
10505,ssl_negotiate_version,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS. The provided function, ssl_negotiate_version, is solely concerned with negotiating TLS protocol versions (and includes workarounds for specific TLS 1.3 issues) and does not contain any logic related to selecting or excluding RC4 cipher suites. Therefore, the function does not address any part of the given RFC constraint.",success,
10505,ssl_negotiate_version,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Does Not Match,[],"The RFC mandates that SSL 3.0 MUST NOT be negotiated. This function does not contain any explicit logic to reject or filter out SSL 3.0. Although the function iterates over available versions and checks for support, it does not implement a check (for example, an if-statement comparing against SSL 3.0) that would prevent SSL 3.0 from being negotiated. Therefore, in isolation, the code does not visibly implement the RFC constraint regarding SSL 3.0.",success,
10505,ssl_negotiate_version,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16(&copy, &peer_version)) {\n        OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n        *out_alert = SSL_AD_DECODE_ERROR;\n        return false;\n      }', 'explanation': ""This segment handles the situation where the message cannot be parsed (for example, if the message length extends beyond its boundary or contains an out‐of‐range length), by setting the alert to 'decode_error' and terminating the connection as required by the RFC.""}}]","The function 'ssl_negotiate_version' iterates over possible TLS versions and, within the inner loop, attempts to parse the peer-provided version numbers from the message. If parsing fails (e.g., if the CBS_get_u16 call cannot retrieve a valid 16-bit value), the code sets the error via OPENSSL_PUT_ERROR, assigns the 'decode_error' alert to out_alert, and aborts by returning false. This behavior directly corresponds to the RFC requirement that a message which cannot be parsed must result in termination with a 'decode_error' alert. Therefore, the function fully implements the behavior stipulated in the specification.",success,
10522,ssl_credential_matches_requested_issuers,"-If the ""certificate_authorities"" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.",214,Fully Matches,"[{'C1': {'code': 'if (hs->ca_names != nullptr) {\n    for (const CRYPTO_BUFFER *ca_name : hs->ca_names.get()) {\n      if (cred->ChainContainsIssuer(Span(CRYPTO_BUFFER_data(ca_name), CRYPTO_BUFFER_len(ca_name)))) {\n        return true;\n      }\n    }\n  }', 'explanation': ""This block checks if the 'certificate_authorities' extension (hs->ca_names) is present, and if so, iterates over the CA names to verify that at least one certificate in the chain (as determined by ChainContainsIssuer) is issued by one of the listed CAs. This directly implements the RFC requirement.""}}]","The function explicitly inspects the presence of the certificate_authorities extension in the handshake structure. When present, it iterates through the list of CA names and validates whether the provided credential's certificate chain includes an issuer that matches one of these names. This is a direct implementation of the RFC specification that requires at least one of the certificates in the chain to come from one of the listed CAs. The additional trust anchor logic further supports the matching process, indicating a comprehensive approach to meet the specification within the function itself.",success,
10522,ssl_credential_matches_requested_issuers,"The ""certificate_authorities"" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which SHOULD be used by the receiving endpoint to guide certificate selection.",104,Partially Matches,"[{'C1': {'code': 'if (!cred->must_match_issuer) {\n    // This credential does not need to match a requested issuer, so\n    // it is good to use without a match.\n    return true;\n}', 'explanation': 'This segment implements the certificate_authorities extension behavior in that if a credential is not required to match an issuer, the function returns true immediately.'}}, {'A1': {'code': 'if (hs->ca_names != nullptr) {\n    for (const CRYPTO_BUFFER *ca_name : hs->ca_names.get()) {\n      if (cred->ChainContainsIssuer(\n              Span(CRYPTO_BUFFER_data(ca_name), CRYPTO_BUFFER_len(ca_name)))) {\n        return true;\n      }\n    }\n}', 'explanation': 'This code iterates over the provided CA names from the certificate_authorities extension and checks if any issuer in the credential chain matches one of these names, in line with the RFC requirement to use those names to guide certificate selection.'}}, {'C2': {'code': 'if (!cred->trust_anchor_id.empty() && hs->peer_requested_trust_anchors) {\n    CBS cbs = CBS(*hs->peer_requested_trust_anchors), candidate;\n    while (CBS_len(&cbs) > 0) {\n      if (!CBS_get_u8_length_prefixed(&cbs, &candidate) ||\n          CBS_len(&candidate) == 0) {\n        OPENSSL_PUT_ERROR(SSL, ERR_R_INTERNAL_ERROR);\n        return false;\n      }\n      if (candidate == Span(cred->trust_anchor_id)) {\n        hs->matched_peer_trust_anchor = true;\n        return true;\n      }\n    }\n}', 'explanation': ""This portion of the function further attempts to use an alternate mechanism by checking if the credential's trust anchor ID matches any provided by the peer, which enhances the certificate authority selection process.""}}]","The function implements core aspects of the certificate_authorities extension defined in the RFC by enforcing issuer matching through provided CA names and trust anchor IDs. However, the provided RFC context also includes requirements about evaluating an If-None-Match header (with specific cache handling and response rules), and none of that logic is present in this function. Thus, while the certificate authorities matching logic is visible, the function does not address all parts of the supplied specification, leading to a 'Partially Matches' outcome.",success,
10544,SSL_CREDENTIAL_set1_delegated_credential,"RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in ""signature_algorithms"".",228,Fully Matches,"[{'C1': {'code': 'if (SSL_get_signature_algorithm_key_type(dc_cert_verify_algorithm) ==\n      EVP_PKEY_RSA) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_INVALID_SIGNATURE_ALGORITHM);\n    return 0;\n  }', 'explanation': 'The function checks the delegated credential’s signature algorithm. If it detects an RSA algorithm—i.e. one that would rely on rsaEncryption rather than RSASSA-PSS—it rejects the credential, which enforces the RFC requirement that RSA signatures MUST use an RSASSA-PSS algorithm.'}}]","The code function parses a delegated credential and validates its components per RFC 9345, section 4. Critically, it inspects the signature algorithm field (dc_cert_verify_algorithm) via SSL_get_signature_algorithm_key_type, and if it detects that the algorithm is RSA, it returns an error. By doing so, the code effectively prevents usage of the insecure RSA (rsaEncryption) algorithm, ensuring that if RSA were to be used it would have to comply with RSASSA-PSS. This logic, implemented entirely within the function, fully meets the requirement specified in the RFC.",success,
10588,ssl_can_read,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function checks whether the SSL object is ready to read by determining if it is not in the initialization phase or if the handshake state permits early reading. However, the RFC specification states that a TLS implementation SHOULD NOT automatically resend early data, meaning there should be logic to prevent or control the automatic retransmission of early data. The code in the function does not contain any logic addressing the prevention or control of early data retransmission; it only assesses read readiness. Thus, no spec constraints (e.g., C1 or A1) related to preventing automatic early data resend are met by this function.",success,
10598,SSL_CTX_set_handoff_mode,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function only sets the 'handoff' field of the SSL_CTX structure to the value of 'on'. It does not contain any logic related to TLS early data retransmission decisions as stated in the RFC specification ('SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate'). There is no code addressing conditions (e.g., C1) or actions (e.g., A1) concerning early data or retransmission handling. Therefore, within the function_body itself, no part of the specified constraint is implemented.",success,
10606,ssl_session_hash,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function only computes and returns a hash based on the session ID using a helper function, and does not contain any logic related to the TLS early data retransmission specification or the HTTP 302 redirection requirements from the given RFC specification. None of the spec constraints (e.g., conditions like not automatically resending early data, or actions related to it) are addressed within this function.",success,
10610,SSL_CTX_new,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function, SSL_CTX_new, is responsible for initializing an SSL context and does not contain any logic that relates to processing the ClientHello message or handling TLS 1.3 specifics such as ignoring the status_request_v2 extension. None of the code segments within this function address the TLS 1.3 requirement that servers MUST NOT send the status_request_v2 extension in EncryptedExtensions, CertificateRequest, or Certificate messages. Therefore, this function does not visibly implement any of the spec constraints labeled (e.g., C1, A1) related to the specified RFC.",success,
10613,ssl_st,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Does Not Match,[],"The RFC specification requires that the TLS implementation must not enable 0-RTT unless specifically requested by the application and must not automatically resend 0-RTT data if rejected. The provided ssl_st constructor simply copies various fields from the SSL_CTX structure, including the enable_early_data field, without checking or enforcing whether 0-RTT data should be enabled based on the application’s explicit request. There is no logic present in the function_body that ensures the implementation meets either the condition to only enable 0-RTT upon request or the action to avoid resending rejected 0-RTT data. Therefore, the code does not address the specified RFC constraints.",success,
10613,ssl_st,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function_body is a constructor that initializes various fields of the ssl_st object by copying them from the provided SSL_CTX structure, including the 'enable_early_data' flag. However, it does not contain any logic that addresses the TLS RFC specification which states that a TLS implementation SHOULD NOT automatically resend early data. There is no conditional check, handling, or decision-making in the function regarding early data retransmission; it merely assigns the value from the context. Therefore, the function does not attempt to implement the spec constraint.",success,
10633,ssl_do_post_handshake,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (msg.type != SSL3_MT_HELLO_REQUEST || CBS_len(&msg.body) != 0) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_HELLO_REQUEST);\n    return 0;\n}', 'explanation': 'This segment checks that the incoming message conforms to the expected syntax by verifying both the message type and that its body is empty. A deviation from the expected format (e.g., an incorrect type or a nonempty body) is treated as a parsing error.'}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);', 'explanation': ""Upon detecting a parsing error, the function terminates the connection by sending a 'decode_error' alert, directly implementing the action required by the RFC specification.""}}]","The provided function inspects an incoming message and checks its syntax. If the message does not meet the expected format (incorrect type or non-zero length), it sends a decode_error alert and terminates the connection. This behavior directly implements the specified RFC requirement that peers must terminate the connection with a 'decode_error' alert when the message cannot be parsed according to the syntax.",success,
10633,ssl_do_post_handshake,"In particular, it MUST NOT negotiate TLS 1.3.",14,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    return tls13_post_handshake(ssl, msg);\n}', 'explanation': ""The function immediately checks if the connection's protocol version is TLS 1.3 or higher and, if so, delegates processing to tls13_post_handshake. This ensures that any renegotiation or post-handshake processing for TLS 1.3 is not handled by the legacy logic, thereby effectively not negotiating TLS 1.3 within this function.""}}]","The provided function begins by detecting whether the connection uses TLS 1.3 (or a later version) and, in that case, bypasses the renegotiation logic entirely by calling tls13_post_handshake. This design meets the RFC requirement that the implementation MUST NOT negotiate TLS 1.3 because it prevents the renegotiation process from proceeding for TLS 1.3 connections within this function. All logic related to enforcing this constraint is contained within the function itself.",success,
10634,SSL_process_quic_post_handshake,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided code function (SSL_process_quic_post_handshake) does not contain any logic addressing the specific RFC requirement that a TLS implementation SHOULD NOT automatically resend early data, nor does it include application-level decisions regarding retransmission. The function merely processes post-handshake messages for QUIC and does not address resending early data, so none of the labeled conditions (e.g., C1) or actions (e.g., A1) relevant to the early data resend spec are implemented within this function.",success,
10636,SSL_read,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Does Not Match,[],"The provided code function, SSL_read, does not contain any logic that directly addresses the RFC specification regarding alert messages not being fragmented across records or multiple alerts not being coalesced into a single record. The function merely peeks at incoming data, updates pending application data, and discards consumed buffer data without any checks or handling related to alert message fragmentation or coalescing. Although a comment regarding DTLS is present, it only questions whether the remainder of the record should be discarded and does not implement any behavior specific to the RFC conditions stated. Thus, no labeled condition or action (such as C1, A1, etc.) from the RFC constraints are visibly implemented within this function.",success,
10639,SSL_key_update,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Fully Matches,"[{'C1': {'code': 'if (ssl_protocol_version(ssl) < TLS1_3_VERSION) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_SSL_VERSION);\n    return 0;\n}', 'explanation': 'This code block enforces that any connection using a protocol version lower than TLS 1.3 (which includes SSL 3.0) is rejected, thereby directly implementing the RFC requirement that SSL 3.0 must not be negotiated.'}}]","The provided function contains a check that rejects any handshake with a protocol version lower than TLS 1.3. Since SSL 3.0 is one such version, the function directly addresses the RFC requirement by ensuring that SSL 3.0 is not negotiated. All logic necessary to meet this constraint is contained within the function_body without relying on any dependencies.",success,
10640,SSL_shutdown,"If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation MUST receive a ""close_notify"" alert before indicating end-of-data to the application layer.",318,Fully Matches,"[{'A1': {'code': 'if (ssl->s3->write_shutdown != ssl_shutdown_close_notify) {\n    // Send a close_notify.\n    if (ssl_send_alert_impl(ssl, SSL3_AL_WARNING, SSL_AD_CLOSE_NOTIFY) <= 0) {\n      return -1;\n    }\n}', 'explanation': ""This segment sends the 'close_notify' alert, fulfilling the action of notifying the peer that the connection is closing.""}}, {'C1': {'code': 'else if (ssl->s3->read_shutdown != ssl_shutdown_close_notify) {\n    if (SSL_is_dtls(ssl)) {\n      // For DTLS, set the shutdown state without waiting further.\n      if (ssl->s3->read_shutdown == ssl_shutdown_error) {\n        ERR_restore_state(ssl->s3->read_error.get());\n        return -1;\n      }\n      ssl->s3->read_shutdown = ssl_shutdown_close_notify;\n    } else {\n      // Process records until an error, close_notify, or application data is received.\n      if (ssl_read_impl(ssl) > 0) {\n        OPENSSL_PUT_ERROR(SSL, SSL_R_APPLICATION_DATA_ON_SHUTDOWN);\n        return -1;\n      }\n      if (ssl->s3->read_shutdown != ssl_shutdown_close_notify) {\n        return -1;\n      }\n    }\n}', 'explanation': ""This segment ensures that the function does not indicate end-of-data until a 'close_notify' alert is received, as required by the RFC specification.""}}]",The SSL_shutdown function explicitly implements both the sending and receiving of the 'close_notify' alert. It sends a 'close_notify' (action A1) to the peer and then waits for the corresponding alert from the remote side (condition C1) before proceeding. This directly addresses the specification which mandates that a 'close_notify' alert must be received before the application is notified of end-of-data.,success,
10640,SSL_shutdown,"Either party MAY initiate a close of its write side of the connection by sending a ""close_notify"" alert.",315,Fully Matches,"[{'C1': {'code': 'if (ssl->s3->write_shutdown != ssl_shutdown_close_notify) {\n    // Send a close_notify.\n    if (ssl_send_alert_impl(ssl, SSL3_AL_WARNING, SSL_AD_CLOSE_NOTIFY) <= 0) {\n      return -1;\n    }\n}', 'explanation': 'This code checks whether a close_notify has already been sent on the write side; if not, it sends the close_notify alert, which directly implements the RFC requirement that either party may initiate a graceful shutdown by sending a close_notify.'}}, {'A1': {'code': 'else if (ssl->s3->alert_dispatch) {\n    // Finish sending the close_notify.\n    if (ssl->method->dispatch_alert(ssl) <= 0) {\n      return -1;\n    }\n}\n... \nelse if (ssl->s3->read_shutdown != ssl_shutdown_close_notify) {\n    if (SSL_is_dtls(ssl)) {\n      // For DTLS, set the read shutdown directly.\n      ssl->s3->read_shutdown = ssl_shutdown_close_notify;\n    } else {\n      // Process records until close_notify is received.\n      if (ssl_read_impl(ssl) > 0) {\n        OPENSSL_PUT_ERROR(SSL, SSL_R_APPLICATION_DATA_ON_SHUTDOWN);\n        return -1;\n      }\n      if (ssl->s3->read_shutdown != ssl_shutdown_close_notify) {\n        return -1;\n      }\n    }\n}', 'explanation': 'This segment handles the second stage by ensuring that a close_notify is also received (or finished dispatching) from the peer, completing the bidirectional graceful shutdown as per the RFC.'}}]","The function SSL_shutdown implements the graceful shutdown of an SSL/TLS connection by first attempting to send a close_notify alert on the write side (if not already sent) and then waiting for a corresponding alert from the peer before finalizing the shutdown. This sequence directly addresses the RFC specification that mandates either party may initiate a close by sending a close_notify alert, fulfilling the required conditions and actions within this function.",success,
10640,SSL_shutdown,"This alert SHOULD be followed by a ""close_notify"".",314,Fully Matches,"[{'C1': {'code': 'if (ssl->quiet_shutdown) {\n    // Do nothing if configured not to send a close_notify.\n    ssl->s3->write_shutdown = ssl_shutdown_close_notify;\n    ssl->s3->read_shutdown = ssl_shutdown_close_notify;\n    return 1;\n}', 'explanation': 'This block checks if a quiet shutdown is configured. In a normal graceful shutdown the protocol requires a close_notify. Thus, when not quiet, the rest of the function issues and waits for a close_notify, which complies with the specification.'}}, {'A1': {'code': 'if (ssl->s3->write_shutdown != ssl_shutdown_close_notify) {\n    // Send a close_notify.\n    if (ssl_send_alert_impl(ssl, SSL3_AL_WARNING, SSL_AD_CLOSE_NOTIFY) <= 0) {\n      return -1;\n    }\n} else if (ssl->s3->alert_dispatch) {\n    // Finish sending the close_notify.\n    if (ssl->method->dispatch_alert(ssl) <= 0) {\n      return -1;\n    }\n} else if (ssl->s3->read_shutdown != ssl_shutdown_close_notify) {\n    ...\n}', 'explanation': 'The code explicitly sends a close_notify alert if it has not been sent already, then proceeds to finish dispatching it and to wait for the corresponding close_notify from the peer. This directly implements the action required by the spec.'}}]","The SSL_shutdown function implements the behavior defined in the specification by ensuring a close_notify alert is sent (unless quiet_shutdown is configured) and by waiting for a close_notify alert from the peer. This behavior directly corresponds to the spec’s requirement that the alert SHOULD be followed by a close_notify, thereby fully matching the labeled conditions and actions within the function itself.",success,
10640,SSL_shutdown,"Each party MUST send a ""close_notify"" alert before closing its write side of the connection, unless it has already sent some error alert",317,Partially Matches,"[{'C1': {'code': 'if (ssl->s3->write_shutdown != ssl_shutdown_close_notify) {\n    // Send a close_notify.\n    if (ssl_send_alert_impl(ssl, SSL3_AL_WARNING, SSL_AD_CLOSE_NOTIFY) <= 0) {\n      return -1;\n    }\n}', 'explanation': 'This code checks if a close_notify alert has not yet been sent and, if so, sends one. This addresses the RFC mandate that each party must send a close_notify alert before closing its write side.'}}]","The function implements the transmission of a close_notify alert by checking its internal state and calling the alert-sending function when appropriate. It also handles subsequent stages (such as finishing the alert dispatch or waiting for a peer’s close_notify) as part of a two-stage shutdown. However, it does not visibly verify whether an error alert was already sent (the exception condition stated in the RFC) but rather uses a configuration flag (quiet_shutdown) to potentially bypass sending a close_notify. Thus, while it visibly addresses the sending of close_notify in normal operation, it only partially complies with the full requirement stated by the RFC.",success,
10644,SSL_set_quic_early_data_context,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function, SSL_set_quic_early_data_context, simply sets or copies a context into the QUIC early data configuration without including any logic that addresses the specific RFC guideline that ""a TLS implementation SHOULD NOT automatically resend early data"". There is no check, condition, or mechanism within the function that prevents automatic resending of early data or defers the decision to the application. Additionally, the spec context regarding 302 redirection is not related to this function's behavior. Therefore, the function does not address any of the labeled constraints by itself.",success,
10645,SSL_CTX_set_early_data_enabled,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided code function only sets a flag in the SSL context to enable or disable early data by converting the provided integer to a boolean. It does not include any logic to determine, prevent, or retransmit early data as described in the RFC (i.e., not automatically resending early data). There is no handling within the function to decide when retransmission is appropriate, nor any implementation addressing HTTP 302 redirection behavior as mentioned in the specification context. Therefore, the function does not implement any of the spec constraints.",success,
10645,SSL_CTX_set_early_data_enabled,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Does Not Match,[],"The provided function simply sets the 'enable_early_data' flag based on the 'enabled' parameter (using a boolean conversion) without any additional checks or logic. It does not implement any mechanism that enforces the RFC requirement to disable 0-RTT unless explicitly requested by the application, nor does it address the prohibition on automatically resending 0-RTT data. Therefore, the function does not visibly address the labeled conditions or actions from the spec constraints.",success,
10646,SSL_set_early_data_enabled,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Does Not Match,[],"The spec requires that TLS 0-RTT is not enabled or resent unless specifically requested or instructed by the application. The function SSL_set_early_data_enabled merely sets an internal flag based on a parameter and does not include any logic to enforce these requirements. There is no check or control to restrict early data usage in accordance with the spec constraints, so no labeled condition (e.g., C1) or action (e.g., A1) is fully implemented within this function.",success,
10646,SSL_set_early_data_enabled,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],The provided function only sets the 'enable_early_data' flag based on the passed parameter. It does not contain any logic to prevent the automatic resending of early data as required by the RFC specification. There is no evidence in the code function that it implements any condition or action (such as preventing automatic retransmission) that would meet the spec constraints.,success,
10649,SSL_reset_early_data_reject,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'C1': {'code': 'if (hs == NULL || hs->wait != ssl_hs_early_data_rejected) { abort(); }', 'explanation': 'This check ensures that the function is called only in the proper state—when early data has been rejected. This aligns with the requirement that, upon rejection, the TLS implementation should not proceed with early data retransmission.'}}, {'A1': {'code': 'hs->in_early_data = false;\nhs->early_session.reset();\nssl->s3->pending_write = {};', 'explanation': 'By clearing the early data flag, resetting the early session, and discarding any pending write data, the function ensures that no automatic reattempt to send early data will occur. This resets the state so that the application is responsible for any retransmission decisions, matching the spec requirement.'}}]","The function 'SSL_reset_early_data_reject' directly implements the necessary logic to ensure that early data is not automatically resent. It first validates that the handshake is in the early data rejection state (C1) and then resets all early data related flags and data (A1). This behavior meets the specification requirement that a TLS implementation SHOULD NOT automatically resend early data, leaving the decision to the application.",success,
10650,SSL_get_early_data_reason,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The function SSL_get_early_data_reason simply returns the value of ssl->s3->early_data_reason. There is no logic within this function that implements any conditions (e.g., C1) or actions (e.g., A1) regarding the TLS early data handling specified in the RFC. It does not address the requirement to avoid automatically resending early data, which is the focus of the provided spec constraints.",success,
10674,SSL_get_finished,TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.,365,Fully Matches,"[{'C1': {'code': 'if (!ssl->s3->initial_handshake_complete ||\n      ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    return 0;\n  }', 'explanation': 'This code ensures that if the handshake is incomplete or if the protocol version is TLS 1.3 or higher, the finished message is not sent, which directly enforces the TLS 1.3 requirement that implementations MUST NOT send finished messages.'}}]","The function directly checks if the SSL connection is using TLS 1.3 (or higher) and, in that case, returns 0 instead of sending a finished message. This implementation meets the spec constraint that TLS 1.3 implementations must not send finished messages, hence the matching judgment is 'Fully Matches'.",success,
10691,SSL_ctrl,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The function 'SSL_get_max_cert_list' is a simple accessor that returns the value of the 'max_cert_list' field from the 'SSL' structure. It does not implement any logic to handle TLS 1.3-specific behavior (such as ignoring the status_request_v2 extension), nor does it address any conditions or actions related to the Content-Length header or Transfer-Encoding as described in the RFC specification and context. Therefore, none of the labeled constraints (e.g., C1, A1) are implemented within this function.",success,
10712,SSL_get_group_id,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function, SSL_get_group_id, simply retrieves the group_id from the SSL session without incorporating any logic related to checking whether the handshake was successfully completed or otherwise conditionally handling supported_groups or key_share information. None of the spec constraints (such as not acting upon supported_groups prior to handshake completion, or any conditional logic analogous to those described) are visible in this function's implementation. Therefore, the code does not meet any of the labeled constraints (e.g., C1, A1) defined in the RFC specification.",success,
10713,SSL_get_negotiated_group,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function simply retrieves a group ID and converts it to a corresponding NID value, returning NID_undef if the group ID equals 0. There is no logic addressing any spec constraint such as ensuring clients do not act upon 'supported_groups' information prior to handshake completion or altering 'key_share' groups following a completed handshake. As such, none of the conditions (e.g., C1) or actions (e.g., A1) specified in the RFC are implemented in this function's code.",success,
10726,SSL_CTX_set_custom_verify,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function 'SSL_CTX_set_custom_verify' only sets the SSL context's verify mode and a custom callback for verification. There is no logic or code within this function that prevents the offering or negotiation of RC4 cipher suites. The RFC specification requires that implementations must not offer or negotiate RC4 cipher suites, but this function does not address this requirement in any way.",success,
10727,SSL_set_custom_verify,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS. However, the provided code function (SSL_set_custom_verify) merely sets a custom verification callback and mode in an SSL configuration structure. There is no logic in this function that inspects, restricts, or alters the cipher suites (in particular, RC4), and therefore it does not address the RFC constraint within its body.",success,
10764,SSL_get_current_cipher,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function, SSL_get_current_cipher, only retrieves the current cipher from an SSL session and does not contain any logic related to checking or enforcing that the OpenPGP certificate type is not used with TLS 1.3. There is no evidence within the code of handling conditions (e.g., C1) or actions (e.g., A1) from the RFC specification. Thus, the function does not visibly address any of the spec constraints by itself.",success,
10776,SSL_set_SSL_CTX,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The RFC specification requires that the TLS implementation SHOULD NOT automatically resend early data, leaving that decision to the application. In the provided function, while there is a line that copies the early data flag from the new context (ssl->enable_early_data = ssl->ctx->enable_early_data), there is no logic that actively prevents or controls the automatic resending of early data. The function does not implement any decision-making logic or checks that align with the spec’s requirement for not automatically retransmitting early data. Therefore, the function does not visibly address the specified RFC constraint by itself.",success,
10809,SSL_in_false_start,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The RFC specification focuses on ensuring that TLS implementations do not automatically resend early data and leave retransmission decisions to the application. The provided code function, SSL_in_false_start, merely checks if the handshake pointer (hs) is NULL and then returns the value of the in_false_start field. There is no logic present in the function that addresses or implements the RFC constraint regarding early data retransmission. Therefore, none of the labeled conditions (e.g., C1) or actions (e.g., A1) are implemented in this function.",success,
10810,SSL_cutthrough_complete,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function simply returns the result of a call to SSL_in_false_start(ssl) and does not include any logic that pertains to the RFC specification regarding the prevention of automatic resending of early data or managing its retransmission. There is no implementation addressing any labeled condition (e.g., C1) or action (e.g., A1) from the spec constraints within this function.",success,
10854,SSL_CTX_set_ticket_aead_method,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification requires that implementations must NOT use the Truncated HMAC extension, indicating that there should be logic to prevent its use, particularly in relation to AEAD algorithms. The provided function SSL_CTX_set_ticket_aead_method merely assigns a value to the ctx->ticket_aead_method field without any checks or logic to prevent the usage of the Truncated HMAC extension. Since the function does not contain any code in isolation that addresses the RFC requirement (i.e., no condition labeled C1 or action labeled A1 related to this constraint is implemented here), it does not match the spec constraints.",success,
10855,SSL_process_tls13_new_session_ticket,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The RFC specification states that the OpenPGP certificate type MUST NOT be used with TLS 1.3. However, in the provided code function, there is no logic that inspects or enforces any checks related to the usage of the OpenPGP certificate type. The code only checks whether the SSL session is in initialization, whether the protocol version is TLS 1.3, and if the session is server/client (ensuring it is a client session). None of these checks address the constraint regarding the OpenPGP certificate type as required by the RFC. Therefore, the function does not attempt to implement the specified constraint.",success,
10864,SSL_get_curve_id,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function, which returns the result of SSL_get_group_id(), does not contain any logic that addresses the conditions or actions described in the specification constraints (e.g., handling handshake or conditional header evaluations). The function merely delegates to another function to retrieve a group identifier and does not implement any of the specified behaviors (such as acting upon supported_groups or evaluating If-Unmodified-Since header conditions). Dependencies are not considered, and within the function itself, there is no evidence of implementing any spec constraints.",success,
10865,SSL_get_curve_name,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The function 'SSL_get_curve_name' only calls 'SSL_get_group_name' with the given curve_id and returns its result. It does not implement any logic addressing the RFC specification or the provided conditions (such as ensuring that clients do not act on 'supported_groups' information before handshake completion, or the evaluation of an If-Unmodified-Since header). No code in the function_body implements any of the spec constraints, so it does not match any of the provided conditions or actions.",success,
10871,Configure,Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2.,69,Fully Matches,"[{'C1': {'code': 'SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION) &&\nSSL_CTX_set_max_proto_version(ctx, TLS1_3_VERSION)', 'explanation': 'These calls explicitly configure the SSL context to support only TLS 1.2 and TLS 1.3, thus ensuring that any TLS 1.3 implementation also supports TLS 1.2, which directly meets the spec requirement.'}}]","The function 'Configure' sets the minimum protocol version to TLS 1.2 and the maximum to TLS 1.3. This guarantees that an implementation supporting TLS 1.3 does not exclude TLS 1.2, thereby fulfilling the spec constraint stating that prior versions (TLS 1.2) should also be supported. Other configuration settings in the function are related to cipher lists and algorithm preferences and do not interfere with this requirement.",success,
10872,Configure,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The provided code function sets the minimum and maximum TLS protocol versions and applies cipher, group, and signature algorithm preferences, but it does not contain any logic to explicitly prevent or check for the negotiation of values within the ""obsolete_RESERVED"" ranges as required by the RFC specification. No part of the function directly addresses the exclusion of those values in TLS 1.3 implementations.",success,
10872,Configure,Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2.,69,Fully Matches,"[{'C1': {'code': 'SSL_set_min_proto_version(ssl, TLS1_2_VERSION)', 'explanation': ""This call sets the minimum protocol version to TLS 1.2, thereby ensuring that if TLS 1.3 is enabled and prior versions are supported, TLS 1.2 will be available, which directly addresses the requirement 'Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2.'""}}]","The function explicitly sets the minimum protocol version to TLS1.2 and the maximum to TLS1.3. By doing so, it visibly guarantees that TLS1.2 is supported in configurations supporting TLS1.3. This matches the RFC specification requirement that implementations supporting TLS 1.3 with former version support must support TLS 1.2, fulfilling the only constraint (C1) present in the input spec within the function body.",success,
10872,Configure,"In particular, it MUST NOT negotiate TLS 1.3.",14,Does Not Match,[],"The RFC specification states that TLS 1.3 MUST NOT be negotiated. However, within the function body, TLS1_3_VERSION is explicitly set as the maximum protocol version using SSL_set_max_proto_version, thereby allowing TLS 1.3. Since this logic directly contradicts the requirement (and no other part of the function counteracts it), the function does not meet the specified constraint.",success,
10873,Configure,"To avoid a downgrade attack, the client SHOULD NOT disable TLS 1.3, only 0-RTT.",385,Partially Matches,"[{'C1': {'code': 'SSL_CTX_set_max_proto_version(ctx, TLS1_3_VERSION)', 'explanation': ""This call explicitly sets the maximum protocol version to TLS 1.3, ensuring that TLS 1.3 is not disabled, which is aligned with the RFC's requirement to avoid disabling TLS 1.3.""}}]","The RFC specifies that client implementations should avoid a downgrade attack by not disabling TLS 1.3 and only disabling 0-RTT if needed. The function sets the maximum protocol version to TLS 1.3, thus visibly ensuring that TLS 1.3 is enabled. However, it does not contain any explicit logic regarding 0-RTT; as that aspect is not handled within this function, the overall implementation only partially matches the spec.",success,
10873,Configure,Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2.,69,Fully Matches,"[{'C1': {'code': 'SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION)', 'explanation': 'The function sets the minimum protocol version to TLS1.2, ensuring that if TLS1.3 is enabled, the implementation also supports TLS1.2 as required by the RFC specification.'}}]","The provided code function explicitly configures the SSL context to support TLS protocols from TLS1.2 to TLS1.3 by calling SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION) and SSL_CTX_set_max_proto_version(ctx, TLS1_3_VERSION). This direct configuration satisfies the RFC requirement that TLS 1.3 implementations which support prior versions should support TLS1.2. All logic addressing this specification is contained within the function itself, with no reliance on external dependencies.",success,
10873,Configure,TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it (see Section 4.4.2.2).,96,Does Not Match,[],"The RFC specification requires that TLS 1.3 servers must not offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it. In the code function, while various TLS parameters such as protocol versions, cipher lists, and signing algorithm preferences (through kSigAlgs) are set, there is no explicit logic that checks for or enforces the exclusion of SHA-1 signatures based on the certificate chain. The function does not contain any conditional logic or verification steps directly addressing the SHA-1 certificate usage requirement stated in the RFC. As a result, the specific constraint from the RFC is not implemented within this function.",success,
10874,Configure,"To avoid a downgrade attack, the client SHOULD NOT disable TLS 1.3, only 0-RTT.",385,Partially Matches,"[{'C1': {'code': 'SSL_set_max_proto_version(ssl, TLS1_3_VERSION)', 'explanation': ""This line ensures TLS 1.3 is available (i.e., not disabled), which aligns with the spec requirement to avoid disabling TLS 1.3. However, the spec's guidance regarding 0-RTT is not addressed in this function.""}}]","The provided function sets the maximum protocol version to TLS 1.3, thereby not disabling TLS 1.3 and partially addressing the spec requirement. However, the function does not contain any logic related to handling or restricting 0-RTT, so not all aspects of the spec constraint are implemented within this function.",success,
10874,Configure,Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2.,69,Fully Matches,"[{'C1': {'code': 'SSL_set_min_proto_version(ssl, TLS1_2_VERSION)', 'explanation': 'This line explicitly sets TLS 1.2 as the minimum protocol version, ensuring that implementations of TLS 1.3 also support TLS 1.2 as required by the RFC.'}}]","The function explicitly configures the SSL object to use TLS 1.2 as the minimum protocol version while supporting up to TLS 1.3. This directly addresses the RFC requirement that implementations of TLS 1.3 which choose to support prior versions must support TLS 1.2, fulfilling the condition (C1) entirely within the function body.",success,
10885,resolve_pake_secret,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (!hs->pake_verifier->ProcessProverShare(verifier_share, verifier_confirm, shared_secret, hs->pake_share->pake_message)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    ssl_send_alert(hs->ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return false;\n}', 'explanation': ""This code block checks the validity of the received PAKE share. If the processing fails—which indicates a semantically invalid message—it immediately sends an 'illegal_parameter' alert and terminates the process, fulfilling the RFC requirement.""}}]","The provided function implements the critical requirement of the RFC by detecting a semantically invalid PAKE share (e.g., through the result of ProcessProverShare) and then terminating the connection with an 'illegal_parameter' alert. This action is fully handled within the function itself, satisfying the specification completely.",success,
10885,resolve_pake_secret,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Does Not Match,[],"The RFC specifies that a message failing to parse should result in a 'decode_error' alert. The function, however, calls ssl_send_alert with SSL_AD_ILLEGAL_PARAMETER when ProcessProverShare fails. There is no logic addressing message boundary length or out‐of-range length issues. Consequently, the function does not implement the specified RFC requirement within its own logic.",success,
10885,resolve_pake_secret,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, resolve_pake_secret, is focused on processing PAKE shares and advancing the TLS 1.3 key schedule. It does not contain any logic or checks related to ensuring that RC4 cipher suites are not offered or negotiated. Therefore, no code segments in this function address the RFC specification constraint that implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS.",success,
10886,resolve_ecdhe_secret,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'C1': {'code': 'if (!found_key_share) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CURVE);\n    return false;\n  }', 'explanation': ""This block checks if a valid key share has been received. The absence of a key share (a semantic error) triggers an alert, which aligns with the spec requirement that semantically invalid messages must lead to connection termination via an 'illegal_parameter' alert.""}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);', 'explanation': ""When the key share is not found, the function sends an 'illegal_parameter' alert, directly matching the action mandated by the RFC when a semantically invalid message is encountered.""}}]","The function implements part of the RFC requirement by checking whether the client's key share is present and valid. If it detects a semantic error (i.e. absence of a proper key share), it terminates the connection with an 'illegal_parameter' alert. This behavior partially addresses the spec's condition and action for handling semantically invalid messages. However, the function does not tackle other aspects of connection persistence or additional conditions/actions from the broader spec context, so it only partially matches the full set of spec constraints.",success,
10886,resolve_ecdhe_secret,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!ssl_ext_key_share_parse_clienthello(hs, &found_key_share, &peer_key, &alert, client_hello)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n    return false;\n  }', 'explanation': ""This code branch checks if the client hello message cannot be parsed (i.e., an error occurs in parsing the key share extension) and then sends an alert. It directly implements the requirement to terminate the connection with a 'decode_error' alert when a message cannot be parsed.""}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, alert);', 'explanation': 'This call sends the fatal decode_error alert as specified by the RFC when a parsing error in the message is detected.'}}]","The function 'resolve_ecdhe_secret' attempts to resolve the ECDHE secret by parsing the client hello message. It specifically checks for parsing errors via a call to 'ssl_ext_key_share_parse_clienthello'. If parsing fails, the function immediately sends an alert (using 'ssl_send_alert') with the SSL_AD_DECODE_ERROR alert code and returns false, effectively terminating the connection. This behavior directly satisfies the RFC requirement that a peer receiving an unparseable message must terminate the connection with a 'decode_error' alert.",success,
10886,resolve_ecdhe_secret,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function 'resolve_ecdhe_secret' is focused on processing the key_share extension for ECDHE secret derivation. It does not contain any logic that deals with the 'supported_groups' information or conditions regarding when to act upon such information, as specified in the RFC. The function neither checks whether the handshake has been successfully completed before using group information nor does it implement any changes based on previously learned handshake outcomes. Thus, it does not visibly implement any of the labeled conditions or actions specified in the RFC.",success,
10886,resolve_ecdhe_secret,"Servers MAY check for violations of these rules and abort the handshake with an ""illegal_parameter"" alert if one is violated.",125,Partially Matches,"[{'C1': {'code': 'if (!found_key_share) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_CURVE);\n    return false;\n  }', 'explanation': ""This segment checks for a missing key share and aborts the handshake by sending an 'illegal_parameter' alert, which aligns with the spec statement allowing servers to abort on rule violations.""}}]","The function includes logic that checks for rule violations—in this case, confirming the presence of the key share—and responds by aborting the handshake with an 'illegal_parameter' alert. This behavior addresses one of the spec’s requirements (labeled here as C1). However, other parts of the spec related to the evaluation of preconditions and handling of HTTP request conditions are not implemented in this function. Consequently, the function only partially addresses the overall specification.",success,
10886,resolve_ecdhe_secret,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, resolve_ecdhe_secret, is responsible for handling ECDHE secret derivation and key share operations during the TLS handshake. It does not implement or check any RC4-related cipher suite selection or negotiation logic as required by the spec ('MUST NOT offer or negotiate RC4 cipher suites'). No part of the function's code addresses conditions related to prohibiting the use of RC4. Therefore, within the function_body, none of the labeled spec constraints (e.g., C1, A1) are met.",success,
10887,ssl_ext_supported_versions_add_serverhello,"The server's extensions MUST contain ""supported_versions""",45,Fully Matches,"[{'C1': {'code': 'CBB_add_u16(out, TLSEXT_TYPE_supported_versions)\n      ||  // writes the extension type\n      CBB_add_u16_length_prefixed(out, &contents)\n      ||  // begins the length-prefixed block\n      CBB_add_u16(&contents, hs->ssl->s3->version)', 'explanation': ""The function explicitly adds an extension of type 'supported_versions' by writing its type and the corresponding version value into the output. This directly implements the requirement from the RFC specification that the server's extensions must contain 'supported_versions'.""}}]","Within the function_body, the required logic to include the 'supported_versions' extension is present. It writes the extension type with CBB_add_u16 and then populates the extension data with the TLS version from hs->ssl->s3->version. Thus, the function fully meets the spec constraint that the server's extensions MUST contain 'supported_versions'. Dependencies and other context are not considered, as the logic is entirely contained within this function.",success,
10887,ssl_ext_supported_versions_add_serverhello,"All TLS 1.3 ServerHello messages MUST contain the ""supported_versions"" extension.",36,Fully Matches,"[{'C1': {'code': 'CBB_add_u16(out, TLSEXT_TYPE_supported_versions) ||  //\n      !CBB_add_u16_length_prefixed(out, &contents) ||       //\n      !CBB_add_u16(&contents, hs->ssl->s3->version)', 'explanation': ""The function explicitly adds the 'supported_versions' extension to the ServerHello message by writing the extension type (TLSEXT_TYPE_supported_versions) and including the version information. This directly implements the RFC requirement that all TLS 1.3 ServerHello messages must contain the supported_versions extension.""}}]","The code function directly addresses the requirement by adding the supported_versions extension to the ServerHello message. It uses a series of helper functions (CBB_add_u16, CBB_add_u16_length_prefixed, CBB_add_u16, and CBB_flush) to write the extension type and its content, ensuring that the extension is present as required by the RFC. All logic to implement this is contained within the function, meeting the specified constraint.",success,
10887,ssl_ext_supported_versions_add_serverhello,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The function ssl_ext_supported_versions_add_serverhello only constructs the 'supported_versions' extension for the TLS ServerHello message by adding the version value from hs->ssl->s3->version, and it does not include any checks or logic to enforce that the OpenPGP certificate type is not used with TLS 1.3 or any related actions as specified by RFC6091. There is no code in this function that references or restricts the OpenPGP certificate type, and the additional context regarding Transfer-Encoding does not apply. Therefore, none of the labeled conditions or actions (e.g., C1, A1) from the spec constraints are implemented within this function.",success,
10889,add_new_session_tickets,"Servers MAY send multiple tickets on a single connection, either immediately after each other or after specific events (see Appendix C.4).",240,Fully Matches,"[{'C1': {'code': 'for (size_t i = 0; i < ssl->session_ctx->num_tickets; i++) {\n    ...\n    if (!ssl_add_message_cbb(ssl, cbb.get())) {\n      return false;\n    }\n    sent_tickets = true;\n}', 'explanation': 'This loop iterates over the number of tickets allowed on the connection and attempts to build and send a new session ticket for each iteration. This directly implements the RFC requirement that ""Servers MAY send multiple tickets on a single connection, either immediately after each other or after specific events.""'}}]","The function 'add_new_session_tickets' clearly demonstrates the ability to issue multiple session tickets by iterating over 'ssl->session_ctx->num_tickets' and sending a ticket for each iteration. This meets the RFC specification regarding multiple ticket sending, and no part of the logic is delegated to external dependencies, thus fully addressing the required condition within the function itself.",success,
10889,add_new_session_tickets,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided code function, add_new_session_tickets, is responsible for creating and sending session ticket messages in a TLS 1.3 handshake. It contains logic related to session ticket issuance (e.g., checking PSK parameters, ticket encryption, adding early data parameters, and even inserting a GREASE ticket extension per RFC 8701). However, the TLS 1.3 RFC specification provided in the input requires that servers MUST NOT process or respond to the status_request_v2 extension from the ClientHello message. There is no code in this function that inspects, ignores, or otherwise responds to the status_request_v2 extension. Consequently, this function does not implement the specific constraint related to not sending or processing the status_request_v2 extension in subsequent handshake messages. As dependencies are not considered, and only the in-function logic is relevant, the function does not address the labeled spec constraint.",success,
10889,add_new_session_tickets,The server MUST generate a fresh value for each ticket it sends.,249,Fully Matches,"[{'C1': {'code': 'if (!RAND_bytes((uint8_t *)&session->ticket_age_add, 4)) {\n      return false;\n    }\n    session->ticket_age_add_valid = true;', 'explanation': ""This segment generates a fresh random value for 'ticket_age_add' for each ticket sent, thus implementing the RFC requirement that the server must generate a fresh value for each ticket.""}}]","The function iterates over each ticket to be sent and, for every ticket, it generates a new random value using RAND_bytes for ticket_age_add. This meets the specification requirement that the server MUST generate a fresh value for each ticket it sends.",success,
10889,add_new_session_tickets,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Partially Matches,"[{'C1': {'code': 'bool enable_early_data =\n    ssl->enable_early_data &&\n    (!SSL_is_quic(ssl) || !ssl->config->quic_early_data_context.empty()) &&\n    !SSL_is_dtls(ssl);', 'explanation': ""This segment checks that early data (0-RTT) is only enabled if the 'ssl->enable_early_data' flag is true (presumably set by the application), and further restricts its use under specific conditions (not for DTLS, and for QUIC only if a proper context is provided). This corresponds to the RFC requirement to not enable 0-RTT unless specifically requested.""}}]","The function partially implements the RFC. It contains logic to conditionally allow early data (0-RTT) only if the ssl->enable_early_data flag is true, thereby ensuring that 0-RTT is enabled only when the application has requested it (matching condition C1). However, the RFC also mandates that implementations MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application. The function does not contain any logic to handle the automatic resending of 0-RTT data, so that aspect of the RFC is not addressed within this function.",success,
10889,add_new_session_tickets,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The RFC specification requires that values within the 'obsolete_RESERVED' ranges are never offered or negotiated by TLS 1.3 implementations. Upon inspection, the function 'add_new_session_tickets' is concerned with constructing and sending session tickets for TLS 1.3, including handling early data and GREASE extensions. However, there is no logic within this function that checks for, avoids, or otherwise handles any 'obsolete_RESERVED' values. There is no condition or action implemented that ensures these values are not offered, meaning the function does not address the specific RFC constraint. As a result, it does not fulfill the given spec requirement.",success,
10889,add_new_session_tickets,"The server MAY also send unsolicited extensions in the NewSessionTicket, though the client does not respond directly to these.",58,Fully Matches,"[{'A1': {'code': '    // Add a fake extension. See RFC 8701.\n    if (!CBB_add_u16(&extensions,\n                     ssl_get_grease_value(hs, ssl_grease_ticket_extension)) ||\n        !CBB_add_u16(&extensions, 0 /* empty */)) {\n      return false;\n    }', 'explanation': 'This segment explicitly adds an unsolicited (fake) extension to the NewSessionTicket message, fulfilling the RFC requirement that the server MAY send unsolicited extensions in the NewSessionTicket. The client is not expected to respond to this extension, which aligns with the spec.'}}]","The function 'add_new_session_tickets' visibly includes logic to add unsolicited extensions into the NewSessionTicket—specifically by appending a fake GREASE extension. This matches the RFC specification stating that the server may send unsolicited extensions, even though the client does not respond to them. As such, within its own scope, the function fully meets the requirement.",success,
10889,add_new_session_tickets,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function 'add_new_session_tickets' is responsible for creating and sending new session tickets during a TLS handshake. Although it contains logic related to early data (for example, setting the ticket_max_early_data parameter when early data is enabled), it does not implement any logic that prevents the automatic resending of early data as specified by the RFC ('A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate'). There is no code in this function that explicitly restricts or controls the automatic retransmission of early data based on this spec. Therefore, no labeled condition or action (e.g., C1, A1) corresponding to the spec constraint is visibly addressed within the target code function.",success,
10892,do_select_parameters,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided code function do_select_parameters does not contain any logic related to the RFC requirement that states TLS 1.3 servers MUST NOT act upon the presence or information of the status_request_v2 extension in the ClientHello message. There is no code segment handling or explicitly ignoring such an extension (or even checking for it) within this function. As a result, it does not visibly address any labeled condition (e.g., C1) or action (e.g., A1) from the spec constraints, meaning it does not attempt to implement the specified RFC requirement.",success,
10892,do_select_parameters,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'C1': {'code': 'if (SSL_is_quic(ssl) && client_hello.session_id_len > 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_COMPATIBILITY_MODE);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n  }', 'explanation': 'This code block checks for a semantically invalid condition (a non-empty session ID in QUIC mode) that is not allowed. It addresses the requirement of detecting a message that is syntactically correct but semantically invalid.'}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);', 'explanation': ""Upon detecting the invalid parameter, this call sends an 'illegal_parameter' alert to terminate the connection, matching the RFC mandate.""}}]","The function contains logic that detects a specific semantically invalid condition (an unexpected session ID in QUIC) and responds by sending an 'illegal_parameter' alert, thereby partially implementing the given RFC requirement. However, other aspects mentioned in the specification (such as HTTP persistent connection handling and ensuring complete message body reading) are not addressed within this code function. As a result, while the code visibly implements the illegal_parameter alert requirement (conditions C1 and action A1) for one case, it does not cover the full scope of the RFC.",success,
10892,do_select_parameters,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6).",10,Fully Matches,"[{'C1': {'code': 'if (hs->credential == nullptr) {\n    assert(ERR_peek_error() != 0);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n    return ssl_hs_error;\n}\n\nhs->new_cipher = choose_tls13_cipher(ssl, &client_hello);\nif (hs->new_cipher == NULL) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_NO_SHARED_CIPHER);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n    return ssl_hs_error;\n}\n\nif (!ssl_negotiate_alpn(hs, &alert, &client_hello)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n    return ssl_hs_error;\n}', 'explanation': 'These code segments check that the negotiated parameters (credentials, cipher suite, and ALPN) between the client and server are valid. If none are found, the function aborts the handshake by sending a fatal alert (handshake_failure), as mandated by the RFC.'}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);', 'explanation': 'Throughout the function, when a required parameter is not negotiated (e.g., no acceptable credential or cipher suite), the abort mechanism is invoked by sending a fatal alert with handshake_failure. This action directly implements the RFC requirement to abort the handshake when a supported set of parameters cannot be negotiated.'}}]","The function clearly implements the specification requirement by checking if essential parameters (such as the credential and cipher suite) have been negotiated. In each failure branch, it aborts the handshake with a fatal alert (using handshake_failure), which satisfies the spec constraint. All logic for determining parameter mismatches and aborting the handshake is contained within this function, thereby fully addressing the RFC mandate.",success,
10893,select_session,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The RFC specification requires that the server MUST NOT send a 'psk_key_exchange_modes' extension. However, in this function, the code is focused on processing the client's hello message and verifying the presence of the client's 'psk_key_exchange_modes' extension when a pre_shared_key is offered. It does not contain any logic related to controlling what the server sends. Therefore, none of the code in this function attempts to implement the constraint regarding the server's behavior of NOT sending the 'psk_key_exchange_modes' extension.",success,
10893,select_session,"If clients offer ""pre_shared_key"" without a ""psk_key_exchange_modes"" extension, servers MUST abort the handshake.",137,Fully Matches,"[{'C1': {'code': 'CBS pre_shared_key;\n*out_offered_ticket = ssl_client_hello_get_extension(client_hello, &pre_shared_key, TLSEXT_TYPE_pre_shared_key);\nif (!*out_offered_ticket) {\n  return ssl_ticket_aead_ignore_ticket;\n}\n\n// Per RFC 8446, section 4.2.9, servers MUST abort the handshake if the client\n// sends pre_shared_key without psk_key_exchange_modes.\nCBS unused;\nif (!ssl_client_hello_get_extension(client_hello, &unused, TLSEXT_TYPE_psk_key_exchange_modes)) {\n  *out_alert = SSL_AD_MISSING_EXTENSION;\n  OPENSSL_PUT_ERROR(SSL, SSL_R_MISSING_EXTENSION);\n  return ssl_ticket_aead_error;\n}', 'explanation': 'The code first checks if the client has sent a pre_shared_key. If so, it then verifies the presence of the psk_key_exchange_modes extension. If that extension is missing, the handshake is aborted by setting an alert and returning an error, which directly implements the RFC specification.'}}]","Within the provided function, the code directly detects the scenario where a client offers the pre_shared_key extension without the accompanying psk_key_exchange_modes extension. According to the RFC, this condition mandates aborting the handshake, which the function achieves by triggering the appropriate error response. Thus, the function fully implements the required spec constraint.",success,
10893,select_session,"A client MUST provide a ""psk_key_exchange_modes"" extension if it offers a ""pre_shared_key"" extension.",136,Fully Matches,"[{'C1': {'code': 'CBS pre_shared_key;\n*out_offered_ticket = ssl_client_hello_get_extension(client_hello, &pre_shared_key, TLSEXT_TYPE_pre_shared_key);\nif (!*out_offered_ticket) {\n    return ssl_ticket_aead_ignore_ticket;\n}\n\nCBS unused;\nif (!ssl_client_hello_get_extension(client_hello, &unused, TLSEXT_TYPE_psk_key_exchange_modes)) {\n    *out_alert = SSL_AD_MISSING_EXTENSION;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_MISSING_EXTENSION);\n    return ssl_ticket_aead_error;\n}', 'explanation': 'This segment first checks if the client provided a pre_shared_key extension. If present, it then checks for the psk_key_exchange_modes extension. If the latter is missing, it aborts the handshake by setting an alert and returning an error as required by the RFC.'}}]","The function explicitly implements the RFC requirement by verifying the presence of the 'psk_key_exchange_modes' extension when a 'pre_shared_key' extension is offered. The logic within the function returns an error if the second extension is missing, thereby fully matching the specified condition (C1) from the RFC.",success,
10893,select_session,"In order to use PSKs, clients MUST also send a ""psk_key_exchange_modes"" extension.",135,Fully Matches,"[{'C1': {'code': 'if (!ssl_client_hello_get_extension(client_hello, &unused, TLSEXT_TYPE_psk_key_exchange_modes)) {\n    *out_alert = SSL_AD_MISSING_EXTENSION;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_MISSING_EXTENSION);\n    return ssl_ticket_aead_error;\n}', 'explanation': 'When a PSK is offered (pre_shared_key extension is present), this code verifies that the client also sent the psk_key_exchange_modes extension. By aborting the handshake with an alert if the extension is missing, it directly implements the RFC requirement.'}}]","The function explicitly checks for the presence of the psk_key_exchange_modes extension in the client hello if a pre_shared_key extension is detected. This fulfills the RFC specification that clients MUST include the psk_key_exchange_modes extension when using PSKs. Thus, the code function fully meets the specified constraint.",success,
10893,select_session,"Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value (see Section 4.2.11.2 below).",165,Fully Matches,"[{'C1': {'code': 'if (!tls13_verify_psk_binder(hs, session.get(), msg, &binders)) {\n    *out_alert = SSL_AD_DECRYPT_ERROR;\n    return ssl_ticket_aead_error;\n  }', 'explanation': 'This code segment validates the PSK binder before the session is accepted. According to the spec, before accepting PSK key establishment the server must validate the binder value. This check meets that requirement.'}}]","The function implements the required binder validation by explicitly calling tls13_verify_psk_binder and aborting the handshake if the binder does not verify. Therefore, the function fully meets the binder validation constraint described in the spec.",success,
10893,select_session,"For PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued (see Section 8).",145,Partially Matches,"[{'C1': {'code': 'client_ticket_age -= session->ticket_age_add;\nclient_ticket_age /= 1000;\n...\nassert(now.tv_sec >= session->time);\nuint64_t server_ticket_age = now.tv_sec - session->time;\n*out_ticket_age_skew = static_cast<int32_t>(client_ticket_age) - static_cast<int32_t>(server_ticket_age);', 'explanation': 'The RFC requires that the server validate that the ticket age is within a small tolerance. This function computes the client’s and server’s ticket age and then calculates a ticket age skew. However, it does not compare the skew to an allowed tolerance bound, meaning the validation step (ensuring the skew is within a small tolerance) is not fully implemented here.'}}]","The function partially addresses the RFC requirement by calculating the client ticket age (subtracting ticket_age_add and converting units) and the server ticket age, then determining the skew between them. However, it stops short of validating that the computed skew is within an acceptable small tolerance, which is a mandatory part of the RFC. As a result, the function only partially matches the specification.",success,
10895,do_select_session,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function, do_select_session, implements various parts of the TLS 1.3 handshake such as session selection, ALPS negotiation, early data handling, key schedule initialization, etc. However, it does not include any logic that checks for or explicitly ignores the status_request_v2 extension in ClientHello messages, nor does it implement a mechanism to ensure that the status_request_v2 information is not acted upon in subsequent messages (EncryptedExtensions, CertificateRequest, or Certificate). Therefore, it does not visibly address the specified TLS 1.3 RFC requirement regarding the status_request_v2 extension.",success,
10895,do_select_session,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS. The provided function does not contain any logic that inspects, filters, or rejects RC4 cipher suites. There is no code segment that references RC4 or prevents its negotiation. Therefore, the function does not visibly address the constraint, and the requirement is not implemented within its body.",success,
10895,do_select_session,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Partially Matches,"[{'C1': {'code': 'if (!ssl->enable_early_data) {\n    ssl->s3->early_data_reason = ssl_early_data_disabled;\n}', 'explanation': 'This segment checks whether 0-RTT (early data) is enabled and explicitly disables it by setting a reason if ssl->enable_early_data is false. This aligns with the requirement to not enable 0-RTT unless specifically requested by the application.'}}]","The provided function includes a check to ensure that 0-RTT is only accepted if enabled (e.g. ssl->enable_early_data is true) and then evaluates several criteria before accepting early data. This partially implements the spec requirement that TLS implementations must not enable 0-RTT unless requested. However, there is no visible logic within this function to ensure that 0-RTT data is not automatically resent if rejected by the server, which is also mandated by the specification. Therefore, while one aspect of the constraints (denying early data if not enabled) is addressed (labeled here as C1), the function does not implement measures corresponding to the action requirement (labeled here as A1), resulting in a ",success,
10895,do_select_session,"If there is no overlap between the received ""supported_groups"" and the groups supported by the server, then the server MUST abort the handshake with a ""handshake_failure"" or an ""insufficient_security"" alert.",7,Fully Matches,"[{'C1': {'code': 'if (!tls1_get_shared_group(hs, &hs->new_session->group_id)) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_NO_SHARED_GROUP);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n      return ssl_hs_error;\n    }', 'explanation': ""The code checks whether a shared group exists (i.e. an overlap between the client's supported_groups and server-supported groups) by calling tls1_get_shared_group. If no shared group is found, it sends a handshake_failure alert as required by the RFC, thereby directly implementing the specified behavior.""}}]","The function includes explicit logic to verify that an acceptable shared group is negotiated. On failure to obtain a shared group, the function aborts the handshake by sending a handshake_failure alert, which fully corresponds to the condition outlined in the RFC. Although the spec also permits an insufficient_security alert, sending handshake_failure is an acceptable alternative. Therefore, the function alone visibly addresses the labeled condition from the RFC specification.",success,
10895,do_select_session,"If the server selects an (EC)DHE group and the client did not offer a compatible ""key_share"" extension in the initial ClientHello, the server MUST respond with a HelloRetryRequest (Section 4.1.4) message.",9,Fully Matches,"[{'A1': {'code': 'bool found_key_share;\n    if (!ssl_ext_key_share_parse_clienthello(hs, &found_key_share, /*out_key_share=*/nullptr, &alert, &client_hello)) {\n      ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n      return ssl_hs_error;\n    }\n    need_hrr = !found_key_share;\n    \n    ...\n    \n    if (need_hrr) {\n      ssl->method->next_message(ssl);\n      if (!hs->transcript.UpdateForHelloRetryRequest()) {\n        return ssl_hs_error;\n      }\n      hs->tls13_state = state13_send_hello_retry_request;\n      return ssl_hs_ok;\n    }', 'explanation': ""The code first attempts to parse the client's key_share extension. It then sets 'need_hrr' to true if a compatible key_share was not provided. Later it checks 'if (need_hrr)' and transitions the handshake state to send a HelloRetryRequest, fully satisfying the spec requirement.""}}]","The function inspects the client-provided key_share extension and, in the absence of a compatible key_share (as determined by !found_key_share), it sets the need_hrr flag. Later, when need_hrr is true, it progresses to issue a HelloRetryRequest by updating the transcript and state (state13_send_hello_retry_request). This directly implements the requirement from the HTTP RFC specification.",success,
10895,do_select_session,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6).",10,Partially Matches,"[{'C1': {'code': 'if (!tls1_get_shared_group(hs, &hs->new_session->group_id)) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_NO_SHARED_GROUP);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n      return ssl_hs_error;\n    }', 'explanation': 'This segment checks if the server is unable to negotiate a key share group with the client (i.e. no overlap in supported parameters). When the negotiation fails, it sends a fatal handshake failure alert, thereby aborting the handshake per the RFC requirement.'}}]","The RFC requires that if no common set of parameters is found, the handshake must be aborted with either a handshake_failure or insufficient_security fatal alert. In this function, the negotiation of the key share group is one instance where parameters are checked. When tls1_get_shared_group fails, the function sends a handshake failure alert and aborts the handshake. However, while this error handling addresses a critical aspect of the parameter negotiation failure, the function also uses other alert types (eg, internal_error in other error paths) and not every parameter negotiation condition is handled in a uniform manner. Consequently, the function only partially matches the RFC specification as it demonstrates some of the required behavior (namely in the key share negotiation check) but does not comprehensively cover every aspect of the spec solely within this function.",success,
10895,do_select_session,"If it is not, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.",146,Fully Matches,"[{'C1': {'code': 'if (!ssl->enable_early_data) {\n    ssl->s3->early_data_reason = ssl_early_data_disabled;\n} else if (!offered_ticket) {\n    ssl->s3->early_data_reason = ssl_early_data_no_session_offered;\n} else if (!session) {\n    ssl->s3->early_data_reason = ssl_early_data_session_not_resumed;\n} else if (session->ticket_max_early_data == 0) {\n    ssl->s3->early_data_reason = ssl_early_data_unsupported_for_session;\n} else if (!hs->early_data_offered) {\n    ssl->s3->early_data_reason = ssl_early_data_peer_declined;\n} else if (hs->channel_id_negotiated) {\n    ssl->s3->early_data_reason = ssl_early_data_channel_id;\n} else if (Span(ssl->s3->alpn_selected) != session->early_alpn) {\n    ssl->s3->early_data_reason = ssl_early_data_alpn_mismatch;\n} else if (hs->new_session->has_application_settings != session->has_application_settings ||\n           Span(hs->new_session->local_application_settings) != session->local_application_settings) {\n    ssl->s3->early_data_reason = ssl_early_data_alps_mismatch;\n} else if (ssl->s3->ticket_age_skew < -kMaxTicketAgeSkewSeconds ||\n           kMaxTicketAgeSkewSeconds < ssl->s3->ticket_age_skew) {\n    ssl->s3->early_data_reason = ssl_early_data_ticket_age_skew;\n} else if (!quic_ticket_compatible(session.get(), hs->config)) {\n    ssl->s3->early_data_reason = ssl_early_data_quic_parameter_mismatch;\n} else if (need_hrr) {\n    ssl->s3->early_data_reason = ssl_early_data_hello_retry_request;\n} else {\n    ssl->s3->early_data_reason = ssl_early_data_accepted;\n    ssl->s3->early_data_accepted = true;\n}', 'explanation': ""This code block implements the decision logic for 0-RTT by checking multiple conditions that determine whether the ClientHello is fresh or not. It corresponds to the condition 'if it is not', setting reasons that effectively lead to rejecting 0-RTT data if any check fails.""}}, {'A1': {'code': 'if (ssl->s3->early_data_accepted) {\n    if (!tls13_derive_early_secret(hs)) {\n      return ssl_hs_error;\n    }\n} else if (hs->early_data_offered) {\n    ssl->s3->skip_early_data = true;\n}', 'explanation': ""This part ensures that if the early data is not accepted – i.e. when the ClientHello is not fresh – the handshake proceeds as normal but with 0-RTT data explicitly rejected (skipped). This behavior directly implements the specification's requirement not to take any further action based on a non-fresh ClientHello.""}}]","The function clearly evaluates whether early data (0-RTT) should be accepted by assessing various conditions (e.g., ticket presence, ALPN match, application settings, ticket age skew, etc.). If any condition indicates the ClientHello is not fresh, it rejects 0-RTT (by not deriving early secret and instead setting 'skip_early_data') while still proceeding with the handshake. Thus, the implementation in the function itself fully addresses the RFC requirement to continue the handshake but to reject 0-RTT data without assuming the ClientHello is fresh.",success,
10895,do_select_session,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'C1': {'code': 'else if (hs->early_data_offered) {\n    ssl->s3->skip_early_data = true;\n}', 'explanation': 'This code branch ensures that if early data has been offered by the client but the various conditions for safe early data usage are not met, the implementation will explicitly set the flag to skip early data. This prevents the TLS implementation from automatically resending early data, thereby aligning with the RFC requirement that applications—not the TLS layer—should decide when retransmission is appropriate.'}}]","The function performs detailed negotiation for early data, evaluating a series of conditions (such as whether early data is enabled, if a valid session and ticket exist, or if other parameters like ALPN/ALPS match) before accepting early data. In the scenario where early data is offered but should not be used automatically, the function sets 'ssl->s3->skip_early_data = true', ensuring that early data is not automatically resent. This logic, implemented entirely within the function as seen in the provided code, fully meets the spec constraint.",success,
10896,do_send_hello_retry_request,"In this mode, the client and server MUST supply ""key_share"" values as described in Section 4.2.8.",142,Fully Matches,"[{'C1': {'code': '...\n!CBB_add_u16(&extensions, TLSEXT_TYPE_key_share) ||\n!CBB_add_u16(&extensions, 2 /* length */) ||\n!CBB_add_u16(&extensions, hs->new_session->group_id)\n...', 'explanation': 'The function explicitly adds the key_share extension to the ServerHello message by inserting TLSEXT_TYPE_key_share along with its expected length and group identifier. This directly addresses the RFC requirement that the server supplies key_share values as described in Section 4.2.8.'}}]","The provided function constructs the ServerHello for a HelloRetryRequest and includes the key_share extension as mandated by the RFC. The insertion of the key_share extension (with its type, length, and group ID) is clearly visible within the function’s code, thereby fulfilling the requirement that in this mode, key_share values must be supplied. No additional dependency is needed for this feature, and thus the function fully matches the spec constraint.",success,
10896,do_send_hello_retry_request,They MUST NOT be offered or negotiated by any implementation.,100,Does Not Match,[],"The provided RFC specification and its context concern the evaluation of an If-Match header field (and related negotiation restrictions), but the function do_send_hello_retry_request is entirely focused on constructing a TLS HelloRetryRequest message. Although the code includes a comment and an assertion (assert(hs->pake_verifier == nullptr)) regarding not using PAKEs, this relates to a decision not to offer that mechanism; it does not address any of the conditions or actions described in the RFC specification context regarding HTTP header evaluation or the negotiation of features. As a result, the function does not visibly address any labeled spec constraints in isolation.",success,
10896,do_send_hello_retry_request,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The RFC specification states that the OpenPGP certificate type MUST NOT be used with TLS 1.3. In the provided code function, there is no logic handling or checking for OpenPGP certificate types, nor is there any enforcement of this requirement. The function focuses on constructing and sending a HelloRetryRequest message (including setting up TLS version, extensions, and related handshake data) without any conditions that verify or prevent the use of OpenPGP certificates in TLS 1.3. Therefore, none of the conditions or actions (e.g., C1, A1) related to the RFC constraint are implemented in this function.",success,
10896,do_send_hello_retry_request,Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less.,395,Fully Matches,"[{'C1': {'code': 'CBB_add_u16(&body, SSL_is_dtls(ssl) ? DTLS1_2_VERSION : TLS1_2_VERSION)', 'explanation': 'This line sets the legacy_version field for the ServerHello message. It uses TLS1_2_VERSION for TLS (typically 0x0303) and DTLS1_2_VERSION for DTLS, thereby ensuring a version value greater than 0x0300 as required by the specification.'}}]","The RFC requires that implementations do not send a legacy_version of less than or equal to 0x0300 for ClientHello or ServerHello messages. In this function, the legacy_version is explicitly set using the call to CBB_add_u16 with either TLS1_2_VERSION or DTLS1_2_VERSION, both of which are above 0x0300. This logic is self-contained within the function, so it fully meets the requirement.",success,
10896,do_send_hello_retry_request,"-If containing a ""supported_groups"" extension, it MUST also contain a ""key_share"" extension, and vice versa.",349,Does Not Match,[],"The provided code function constructs a HelloRetryRequest message and explicitly adds the key_share extension (using TLSEXT_TYPE_key_share), but it does not add or reference a supported_groups extension anywhere in the function. The RFC specification requires that if one of these extensions is included then the other must also be present. Since the function only includes the key_share extension without including the supported_groups extension, it does not address the bidirectional requirement specified in the RFC.",success,
10896,do_send_hello_retry_request,"The server's extensions MUST contain ""supported_versions""",45,Fully Matches,"[{'C1': {'code': '…\n      !CBB_add_u16_length_prefixed(&body, &extensions) ||\n      !CBB_add_u16(&extensions, TLSEXT_TYPE_supported_versions) ||\n      !CBB_add_u16(&extensions, 2 /* length */) ||\n      !CBB_add_u16(&extensions, ssl->s3->version) ||\n      …', 'explanation': ""The code explicitly adds the 'supported_versions' extension by calling CBB_add_u16 with TLSEXT_TYPE_supported_versions, followed by setting its length and value from ssl->s3->version. This directly implements the RFC requirement that the server's extensions must include 'supported_versions'.""}}]","Within the function, the mandatory 'supported_versions' extension is clearly added to the server's extensions block. This direct implementation satisfies the spec constraint, so the function fully matches the RFC requirement regarding supported_versions. Dependencies and other header management logic do not affect this conclusion because the implementation is contained entirely in this function.",success,
10896,do_send_hello_retry_request,"All TLS 1.3 ServerHello messages MUST contain the ""supported_versions"" extension.",36,Fully Matches,"[{'C1': {'code': '...\n  !CBB_add_u16_length_prefixed(&body, &extensions) ||\n  !CBB_add_u16(&extensions, TLSEXT_TYPE_supported_versions) ||\n  !CBB_add_u16(&extensions, 2 /* length */) ||\n  !CBB_add_u16(&extensions, ssl->s3->version) ||\n...', 'explanation': 'The function explicitly appends the supported_versions extension to the HelloRetryRequest message by calling CBB_add_u16 with TLSEXT_TYPE_supported_versions, along with setting its length and value (ssl->s3->version). This directly satisfies the requirement that all TLS 1.3 ServerHello messages include the supported_versions extension.'}}]","The provided function constructs a HelloRetryRequest message, which in TLS 1.3 is encoded as a ServerHello. Within its body it adds the supported_versions extension as mandated by the RFC. This logic is contained entirely within the function_body, and thus it fully matches the specified constraint.",success,
10896,do_send_hello_retry_request,The ServerHello MUST only include extensions which are required to establish the cryptographic context and negotiate the protocol version.,35,Does Not Match,[],"The RFC specification requires that the ServerHello include only the extensions that are necessary for establishing the cryptographic context and negotiating the protocol version. In this function, while the supported_versions extension is added (which is required), the function also unconditionally adds the key_share extension and, in some cases, the ECH confirmation extension. These additional extensions go beyond what the RFC mandates for a ServerHello (or HelloRetryRequest) message. There is no filtering logic in the function to restrict the extensions to only those necessary per the RFC. Consequently, the function does not fully implement the RFC’s requirement.",success,
10896,do_send_hello_retry_request,"In TLS 1.3, the TLS server indicates its version using the ""supported_versions"" extension (Section 4.2.1), and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.",29,Fully Matches,"[{'C1': {'code': 'if (!CBB_add_u16(&body,\n                     SSL_is_dtls(ssl) ? DTLS1_2_VERSION : TLS1_2_VERSION) || ...', 'explanation': 'The code sets the legacy_version field to TLS1_2_VERSION (0x0303) for non-DTLS connections, which fulfills the RFC requirement that the legacy_version MUST be set to 0x0303.'}}, {'A1': {'code': 'if (!CBB_add_u16(&extensions, TLSEXT_TYPE_supported_versions) ||\n    !CBB_add_u16(&extensions, 2 /* length */) ||\n    !CBB_add_u16(&extensions, ssl->s3->version)) { ... }', 'explanation': 'The function adds the supported_versions extension by writing its type, length (2 bytes) and the version from ssl->s3->version, thus visibly addressing the requirement for TLS 1.3 to indicate its version using this extension.'}}]","The function implements the necessary aspects of the RFC by ensuring that the legacy_version field is set to TLS1_2_VERSION (0x0303) and by constructing the supported_versions extension with the appropriate values. These code segments directly address the spec constraints within the function body, fulfilling both the condition for the legacy_version and the action to send the supported_versions extension as specified.",success,
10896,do_send_hello_retry_request,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The provided function is part of the TLS handshake process, constructing a HelloRetryRequest message for the server side. The RFC specification provided relates to HTTP behavior or TLS extension ordering (specifically regarding the pre_shared_key extension) in the ClientHello. This function does not include any logic handling ordering constraints or related actions for the pre_shared_key extension in a ClientHello, nor does it address the HTTP HEAD method behavior described in the spec context. Since none of the labeled conditions (e.g., C1) or actions (e.g., A1) are visibly addressed in this function’s code, it does not match the specified RFC constraints.",success,
10897,do_read_second_client_hello,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function does not contain any logic that directly addresses the TLS 1.3 requirement regarding the status_request_v2 extension. The specification mandates that servers MUST NOT act upon the presence or information in the status_request_v2 extension (i.e., not sending it in EncryptedExtensions, CertificateRequest, or Certificate messages). In the function_body, all logic is focused on handling the second ClientHello message, including processing of ECH (Encrypted ClientHello) extension, PSK binders, and ECDHE secret resolution. There is no segment in the function that checks for, ignores, or avoids acting on the status_request_v2 extension. Therefore, the function does not visibly implement any of the spec constraints related to the status_request_v2 extension.",success,
10897,do_read_second_client_hello,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function, do_read_second_client_hello, implements logic for processing the second ClientHello message in TLS 1.3, including handling encrypted_client_hello, PSK binder verification, and ECDHE secret resolution. However, there is no code within this function that checks or enforces that the OpenPGP certificate type is not used with TLS 1.3, as required by RFC6091. Therefore, the function does not address any of the labeled conditions or actions (such as C1 or A1) related to the prohibition of the OpenPGP certificate type.",success,
10897,do_read_second_client_hello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!SSL_parse_client_hello(ssl, &client_hello, CBS_data(&msg.body), CBS_len(&msg.body))) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    return ssl_hs_error;\n}\n\n...\n\nif (!CBS_get_u8(&ech_body, &type) ||\n    type != ECH_CLIENT_OUTER ||\n    !CBS_get_u16(&ech_body, &kdf_id) ||\n    !CBS_get_u16(&ech_body, &aead_id) ||\n    !CBS_get_u8(&ech_body, &config_id) ||\n    !CBS_get_u16_length_prefixed(&ech_body, &enc) ||\n    !CBS_get_u16_length_prefixed(&ech_body, &payload) ||\n    CBS_len(&ech_body) != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    return ssl_hs_error;\n}', 'explanation': ""This code segment ensures that if the ClientHello message, or parts of its extensions (such as the encrypted_client_hello extension), cannot be parsed correctly, the function sends a 'decode_error' alert and terminates the handshake. This behavior directly implements the RFC requirement that unparseable messages result in a terminate connection with a decode_error alert.""}}]","The function implements explicit checks on the ClientHello message parsing. It verifies the integrity and boundaries of the message (and its extensions) and, when a parsing error is detected, immediately sends a 'decode_error' alert and terminates the connection. This direct handling of malformed messages fully meets the specified RFC constraint.",success,
10897,do_read_second_client_hello,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Fully Matches,"[{'C1': {'code': 'if (kdf_id != EVP_HPKE_KDF_id(EVP_HPKE_CTX_kdf(hs->ech_hpke_ctx.get())) ||\n    aead_id != EVP_HPKE_AEAD_id(EVP_HPKE_CTX_aead(hs->ech_hpke_ctx.get())) ||\n    config_id != hs->ech_config_id || CBS_len(&enc) > 0) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n  return ssl_hs_error;\n}', 'explanation': ""This segment explicitly validates semantic parameters (kdf_id, aead_id, config_id) after parsing the second ClientHello message. If any of these do not match the expected values, it triggers an 'illegal_parameter' alert, which aligns exactly with the RFC requirement to terminate the connection with that alert when a syntactically correct but semantically invalid message is received.""}}]","The function contains an explicit check on the cryptographic parameters extracted from the second ClientHello message. When these parameters are semantically invalid, it sends an 'illegal_parameter' alert as required by the RFC specification. This logic is embedded directly within the function, satisfying the condition as defined.",success,
10897,do_read_second_client_hello,"Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value (see Section 4.2.11.2 below).",165,Fully Matches,"[{'C1': {'code': 'if (ssl->s3->session_reused) {\n    CBS pre_shared_key;\n    if (!ssl_client_hello_get_extension(&client_hello, &pre_shared_key, TLSEXT_TYPE_pre_shared_key)) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_INCONSISTENT_CLIENT_HELLO);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n      return ssl_hs_error;\n    }\n\n    CBS ticket, binders;\n    uint32_t client_ticket_age;\n    uint8_t alert = SSL_AD_DECODE_ERROR;\n    if (!ssl_ext_pre_shared_key_parse_clienthello(hs, &ticket, &binders, &client_ticket_age, &alert, &client_hello, &pre_shared_key)) {\n      ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n      return ssl_hs_error;\n    }\n\n    if (!tls13_verify_psk_binder(hs, hs->new_session.get(), msg, &binders)) {\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECRYPT_ERROR);\n      return ssl_hs_error;\n    }\n  }', 'explanation': 'The code checks for the presence of the pre_shared_key extension, parses the PSK binder, and validates it by calling tls13_verify_psk_binder() before proceeding with the connection, which fully implements the requirement that the server MUST validate the corresponding binder value prior to accepting PSK key establishment.'}}]","The function_body explicitly handles the PSK binder validation step by extracting the pre_shared_key extension, parsing its components, and verifying the binder value using tls13_verify_psk_binder(). This logic directly addresses the RFC specification that mandates binder validation before PSK key establishment, so the function fully meets the given spec constraint.",success,
10897,do_read_second_client_hello,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest.",59,Partially Matches,"[{'C1': {'code': 'if (ssl->s3->ech_status == ssl_ech_accepted) {\n    // If we previously accepted the ClientHelloInner, the second ClientHello\n    // must contain an outer encrypted_client_hello extension.\n    CBS ech_body;\n    if (!ssl_client_hello_get_extension(&client_hello, &ech_body, TLSEXT_TYPE_encrypted_client_hello)) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_MISSING_EXTENSION);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_MISSING_EXTENSION);\n      return ssl_hs_error;\n    }\n    ...\n  }', 'explanation': ""This code block enforces that when the inner ClientHello (ECH) is accepted, the client must include the corresponding outer encrypted_client_hello extension. In doing so, it partially meets the spec's intent to only send extension responses when the client has sent the corresponding extension request. However, the function itself does not handle the logic of sending extension responses based on the absence of requests.""}}]","The function validates incoming ClientHello messages and ensures that if a particular extension state (ECH accepted) is active, then the client must have supplied the corresponding extension. This check is in line with the spirit of the RFC requirement which mandates that servers should not send extension responses in the absence of a matching extension request. However, the function does not directly implement logic to control or prevent sending of extension responses; it only validates the incoming request. Thus, the code partially matches the specified constraint.",success,
10897,do_read_second_client_hello,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The RFC specification states that application data must not be sent before the Finished message is sent. However, the function do_read_second_client_hello only processes handshake messages (specifically the second ClientHello) and related extensions; it does not include any logic concerning the ordering or rejection of application data before the Finished message. Therefore, no part of the function implements the constraint regarding application data.",success,
10897,do_read_second_client_hello,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Fully Matches,"[{'A1': {'code': 'if (ssl->method->has_unprocessed_handshake_data(ssl)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);\n    OPENSSL_PUT_ERROR(SSL, SSL_R_EXCESS_HANDSHAKE_DATA);\n    return ssl_hs_error;\n}', 'explanation': ""This code segment checks for any unprocessed handshake data, which indicates that a handshake message was received in an unexpected order, and responds by sending an 'unexpected_message' alert and aborting the handshake, as required by the RFC.""}}]","The function reads and processes handshake messages, and it explicitly checks if any extra or unexpected handshake data remains. When such unexpected data is detected, it aborts the handshake by sending the 'unexpected_message' alert. This behavior directly implements the specified RFC requirement, and the logic is contained entirely within this function, fulfilling the requirement fully.",success,
10898,do_send_server_hello,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Fully Matches,"[{'A1': {'code': '/* In the construction of the EncryptedExtensions message: */\nif (!ssl->method->init_message(ssl, cbb.get(), &body, SSL3_MT_ENCRYPTED_EXTENSIONS) ||\n    !ssl_add_serverhello_tlsext(hs, &body) ||\n    !ssl_add_message_cbb(ssl, cbb.get())) {\n  return ssl_hs_error;\n}\n\n/* In the CertificateRequest message construction, only signature_algorithms and, optionally, certificate_authorities are added: */\nif (!ssl->method->init_message(ssl, cbb.get(), &body, SSL3_MT_CERTIFICATE_REQUEST) ||\n    !CBB_add_u8(&body, 0 /* no certificate_request_context. */) ||\n    !CBB_add_u16_length_prefixed(&body, &cert_request_extensions) ||\n    !CBB_add_u16(&cert_request_extensions, TLSEXT_TYPE_signature_algorithms) ||\n    !CBB_add_u16_length_prefixed(&cert_request_extensions, &sigalg_contents) ||\n    !CBB_add_u16_length_prefixed(&sigalg_contents, &sigalgs_cbb) ||\n    !tls12_add_verify_sigalgs(hs, &sigalgs_cbb)) {\n  return ssl_hs_error;\n}\n', 'explanation': 'The RFC requirement states that TLS 1.3 servers MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. In this function, the handshake messages are built using helper routines that add only a predefined set of extensions. There is no invocation or data handling that would add the status_request_v2 extension, thereby fulfilling the requirement.'}}]","The provided code function constructs the TLS 1.3 handshake messages without including any logic to process or add the status_request_v2 extension. By exclusively calling helper functions that do not involve status_request_v2 (and by omitting any explicit reference to it), the function adheres to the RFC constraint that TLS 1.3 servers must not act on or send the status_request_v2 extension in the specified messages.",success,
10898,do_send_server_hello,The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK).,185,Fully Matches,"[{'C1': {'code': 'if (!ssl->s3->session_reused && !hs->pake_verifier) {\n    if (!tls13_add_certificate(hs)) {\n      return ssl_hs_error;\n    }\n\n    hs->tls13_state = state13_send_server_certificate_verify;\n    return ssl_hs_ok;\n  }', 'explanation': 'This code segment explicitly checks that the connection is not a session resumption and that the PAKE verifier is not used (ensuring a certificate‐based key exchange). In such cases, it sends the server Certificate message as required by the RFC.'}}]",The function directly implements the requirement by inspecting if the key exchange method necessitates certificates (i.e. when the connection isn't resumed and isn't using a PAKE-based approach) and then sending a Certificate message by calling tls13_add_certificate. This meets the RFC specification that mandates the server to send a Certificate message whenever certificates are used for authentication.,success,
10898,do_send_server_hello,"The ""signature_algorithms"" extension MUST be specified, and other extensions may optionally be included if defined for this message.",182,Fully Matches,"[{'C1': {'code': 'if (hs->cert_request) {\n  CBB cert_request_extensions, sigalg_contents, sigalgs_cbb;\n  if (!ssl->method->init_message(ssl, cbb.get(), &body, SSL3_MT_CERTIFICATE_REQUEST) ||\n      !CBB_add_u8(&body, 0 /* no certificate_request_context. */) ||\n      !CBB_add_u16_length_prefixed(&body, &cert_request_extensions) ||\n      !CBB_add_u16(&cert_request_extensions, TLSEXT_TYPE_signature_algorithms) ||\n      !CBB_add_u16_length_prefixed(&cert_request_extensions, &sigalg_contents) ||\n      !CBB_add_u16_length_prefixed(&sigalg_contents, &sigalgs_cbb) ||\n      !tls12_add_verify_sigalgs(hs, &sigalgs_cbb)) {\n    return ssl_hs_error;\n  }\n  ...\n}', 'explanation': ""The RFC requirement specifies that the 'signature_algorithms' extension MUST be included. In the CertificateRequest message construction, the code explicitly adds the signature_algorithms extension (using TLSEXT_TYPE_signature_algorithms and tls12_add_verify_sigalgs) when hs->cert_request is true, thereby satisfying the spec.""}}]","The function contains explicit logic to add the 'signature_algorithms' extension as part of the CertificateRequest message when a client certificate is requested. This directly addresses the RFC mandate that the 'signature_algorithms' extension must be specified. Additionally, the function includes logic for appending other related extensions, supporting the optional inclusion of further extensions. As all required actions defined in the RFC pertaining to this extension are visibly implemented within the function body, the code fully meets the given spec constraints.",success,
10898,do_send_server_hello,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification mandates that implementations MUST NOT use the Truncated HMAC extension. However, in the provided function_body there is no logic or code segment that checks for, disables, or otherwise addresses the use of the Truncated HMAC extension. All operations in this function focus on sending the ServerHello, handling random generation, and setting up various TLS messages, but none target the specific requirement regarding the truncated HMAC extension. Thus, the function does not visibly implement this RFC constraint by itself.",success,
10898,do_send_server_hello,Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less.,395,Fully Matches,"[{'C1': {'code': 'CBB_add_u16(&body, SSL_is_dtls(ssl) ? DTLS1_2_VERSION : TLS1_2_VERSION)', 'explanation': 'This code segment sets the legacy_version field for the ServerHello message to either DTLS1_2_VERSION or TLS1_2_VERSION. Since TLS1_2_VERSION is typically defined as 0x0303 (and DTLS1_2_VERSION is also above 0x0300), this directly ensures that the ServerHello.legacy_version is not 0x0300 or less, thereby fulfilling the specification.'}}]","The function do_send_server_hello explicitly handles the version field for the ServerHello message by hardcoding it to TLS1_2_VERSION (or DTLS1_2_VERSION when applicable). This prevents the legacy_version from being set to a value of 0x0300 or less, which is exactly what the RFC specification prohibits. There is no reliance on any external dependency or conditional logic that would bypass this check, so within this function the constraint is fully implemented.",success,
10898,do_send_server_hello,"This message, if sent, MUST follow EncryptedExtensions.",179,Fully Matches,"[{'A1': {'code': 'if (!ssl->method->init_message(ssl, cbb.get(), &body,\n                                 SSL3_MT_ENCRYPTED_EXTENSIONS) ||\n      !ssl_add_serverhello_tlsext(hs, &body) ||\n      !ssl_add_message_cbb(ssl, cbb.get())) {\n    return ssl_hs_error;\n  }', 'explanation': 'This block clearly constructs and sends the EncryptedExtensions message. According to the RFC specification (""This message, if sent, MUST follow EncryptedExtensions.""), any subsequent message (e.g. CertificateRequest or Certificate) is sent only after EncryptedExtensions has been sent. The function later sends certificate-related messages only after this block, thereby enforcing the required ordering solely within the function.'}}]","The function's implementation includes logic for constructing and sending the EncryptedExtensions message and then follows with subsequent messages such as CertificateRequest and Certificate (when applicable). This enforces that any message sent after EncryptedExtensions indeed comes later, thus fully matching the spec constraint as implemented within this function without relying on external dependencies.",success,
10898,do_send_server_hello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Fully Matches,"[{'C1': {'code': '…\n!CBB_add_u16_length_prefixed(&body, &extensions) ||\n!ssl_ext_pre_shared_key_add_serverhello(hs, &extensions) ||\n!ssl_ext_pake_add_serverhello(hs, &extensions) ||\n!ssl_ext_key_share_add_serverhello(hs, &extensions) ||\n!ssl_ext_supported_versions_add_serverhello(hs, &extensions)…', 'explanation': ""The RFC states that while extensions can appear in any order, the 'pre_shared_key' extension must appear last in the ClientHello. However, in the ServerHello it may appear anywhere. In this function, the pre_shared_key extension is added along with other extensions without enforcing any special ordering, which is compliant with the RFC for the ServerHello message.""}}]","This function builds the ServerHello message by adding various extensions, including the pre_shared_key extension. The RFC specifically requires that in a ClientHello message the pre_shared_key extension must be the last one, but it allows any order in the ServerHello. Because the function is constructing a ServerHello and places the pre_shared_key extension along with others (without additional ordering constraints), it is correctly and fully compliant with the specified behavior of the RFC.",success,
10898,do_send_server_hello,The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message.,57,Partially Matches,"[{'C1': {'code': 'if (hs->cert_request) {\n    CBB cert_request_extensions, sigalg_contents, sigalgs_cbb;\n    if (!ssl->method->init_message(ssl, cbb.get(), &body,\n                                   SSL3_MT_CERTIFICATE_REQUEST) ||\n        !CBB_add_u8(&body, 0 /* no certificate_request_context. */) ||\n        !CBB_add_u16_length_prefixed(&body, &cert_request_extensions) ||\n        !CBB_add_u16(&cert_request_extensions,\n                     TLSEXT_TYPE_signature_algorithms) ||\n        !CBB_add_u16_length_prefixed(&cert_request_extensions,\n                                     &sigalg_contents) ||\n        !CBB_add_u16_length_prefixed(&sigalg_contents, &sigalgs_cbb) ||\n        !tls12_add_verify_sigalgs(hs, &sigalgs_cbb)) {\n      return ssl_hs_error;\n    }\n\n    if (ssl_has_client_CAs(hs->config)) {\n      CBB ca_contents;\n      if (!CBB_add_u16(&cert_request_extensions,\n                       TLSEXT_TYPE_certificate_authorities) ||\n          !CBB_add_u16_length_prefixed(&cert_request_extensions,\n                                       &ca_contents) ||\n          !ssl_add_client_CA_list(hs, &ca_contents) ||\n          !CBB_flush(&cert_request_extensions)) {\n        return ssl_hs_error;\n      }\n    }\n\n    if (!ssl_add_message_cbb(ssl, cbb.get())) {\n      return ssl_hs_error;\n    }\n}', 'explanation': 'This segment shows that when hs->cert_request is true, the function constructs and sends a CertificateRequest message with extension requests (e.g., signature_algorithms and, if available, certificate_authorities). This directly corresponds to the RFC requirement that the server sends extension requests in its CertificateRequest message.'}}]","The provided function includes a branch that builds and sends a CertificateRequest message with the proper extension elements as specified by the RFC. However, the RFC also mentions that a client may respond with a Certificate message upon receiving such a request, and this function does not directly implement or handle client-side behavior related to that response. Since only the server‐side sending of the extension request is addressed within this function, the implementation partially matches the overall RFC requirement.",success,
10898,do_send_server_hello,"The server's extensions MUST contain ""supported_versions""",45,Fully Matches,"[{'C1': {'code': '...\n      !ssl_ext_pre_shared_key_add_serverhello(hs, &extensions) ||\n      !ssl_ext_pake_add_serverhello(hs, &extensions) ||\n      !ssl_ext_key_share_add_serverhello(hs, &extensions) ||\n      !ssl_ext_supported_versions_add_serverhello(hs, &extensions) ||\n...', 'explanation': ""The code function explicitly calls ssl_ext_supported_versions_add_serverhello with the server hello extensions. This call ensures that the 'supported_versions' extension is added to the server's extensions, fully meeting the spec requirement.""}}]","The function builds the server hello message and includes the necessary extensions. Among these, the supported_versions extension is added by invoking ssl_ext_supported_versions_add_serverhello, which directly satisfies the specification that the server's extensions MUST contain 'supported_versions'.",success,
10898,do_send_server_hello,"All TLS 1.3 ServerHello messages MUST contain the ""supported_versions"" extension.",36,Fully Matches,"[{'C1': {'code': '//! Inside the server hello message construction\n... !ssl_ext_supported_versions_add_serverhello(hs, &extensions) || ...', 'explanation': 'The code calls ssl_ext_supported_versions_add_serverhello() while constructing the ServerHello message. This function call ensures that the supported_versions extension is added to the ServerHello as required by TLS 1.3.'}}]","The provided function explicitly invokes ssl_ext_supported_versions_add_serverhello(), which is responsible for adding the supported_versions extension to the ServerHello message. Since TLS 1.3 requires that every ServerHello includes this extension, the function meets the RFC specification by itself.",success,
10898,do_send_server_hello,The ServerHello MUST only include extensions which are required to establish the cryptographic context and negotiate the protocol version.,35,Fully Matches,"[{'C1': {'code': '...\n  if (!CBB_add_u16_length_prefixed(&body, &extensions) ||\n      !ssl_ext_pre_shared_key_add_serverhello(hs, &extensions) ||\n      !ssl_ext_pake_add_serverhello(hs, &extensions) ||\n      !ssl_ext_key_share_add_serverhello(hs, &extensions) ||\n      !ssl_ext_supported_versions_add_serverhello(hs, &extensions) ||\n      !ssl->method->finish_message(ssl, cbb.get(), &server_hello)) {\n    return ssl_hs_error;\n  }\n...', 'explanation': 'The ServerHello message is constructed by explicitly adding only those extensions that are required for establishing the cryptographic context (e.g., key share, pre‐shared key, PAKE) and for negotiating the protocol version (supported versions). No extra or non‐essential extensions are inserted into the ServerHello itself, which complies with the RFC specification.'}}]","Within function_body, the ServerHello message is built by adding a length-prefixed block for extensions and then calling specific helper functions (ssl_ext_pre_shared_key_add_serverhello, ssl_ext_pake_add_serverhello, ssl_ext_key_share_add_serverhello, ssl_ext_supported_versions_add_serverhello) to include only the necessary extensions for TLS 1.3. This shows that the function deliberately limits the extensions in the ServerHello message to those required, thereby fully matching the spec constraint.",success,
10898,do_send_server_hello,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The RFC specification requires that application data should not be sent prior to the Finished message. However, the function provided (do_send_server_hello) is responsible for constructing and sending various handshake messages (such as ServerHello, EncryptedExtensions, CertificateRequest, Certificate, etc.), and there is no explicit logic in this function that governs or prevents the sending of application data before the Finished message is transmitted. The function does not contain any mechanisms that enforce the RFC condition related to the ordering of application data and Finished messages; rather, it focuses on building handshake message sequences. Therefore, in isolation, this function does not implement the specified HTTP RFC requirement.",success,
10898,do_send_server_hello,"Implementations which have the same policy in both cases MAY omit the ""signature_algorithms_cert"" extension.",85,Does Not Match,[],"The RFC specifies that if the same policy applies in both cases, implementations MAY omit the ""signature_algorithms_cert"" extension. In the provided function, during the construction of the CertificateRequest message, the code unconditionally adds the signature algorithms extension (using TLSEXT_TYPE_signature_algorithms) and does not include any conditional logic to omit this extension based on policy sameness. Therefore, no part of the function visibly implements the optional omission condition specified in the RFC.",success,
10898,do_send_server_hello,"In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message.",176,Partially Matches,"[{'A1': {'code': 'if (!ssl->method->init_message(ssl, cbb.get(), &body, SSL3_MT_ENCRYPTED_EXTENSIONS) ||\n      !ssl_add_serverhello_tlsext(hs, &body) ||\n      !ssl_add_message_cbb(ssl, cbb.get())) {\n    return ssl_hs_error;\n  }', 'explanation': 'This code segment constructs and sends the EncryptedExtensions message. However, according to the RFC specification, EncryptedExtensions MUST be sent immediately after the ServerHello message. In this function, additional messages (such as ChangeCipherSpec and handshake secret derivation) are sent between the ServerHello and the EncryptedExtensions, which means that while the message is sent, its ordering does not fully conform to the specified requirement.'}}]","The provided function does include logic to send an EncryptedExtensions message; however, it does so only after sending the ServerHello message and then performing further steps like possibly sending a ChangeCipherSpec and deriving keys. This means that the EncryptedExtensions message is not dispatched immediately following the ServerHello, thus only partially matching the RFC requirement that it be sent immediately after the ServerHello message.",success,
10898,do_send_server_hello,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The RFC specification requires that the server MUST NOT send a ""psk_key_exchange_modes"" extension. Upon inspection, the function do_send_server_hello does not contain any logic – such as condition checks, exclusions, or explicit omissions – to ensure that a psk_key_exchange_modes extension is not added. The function adds several other extensions (pre_shared_key, pake, key_share, and supported_versions) but makes no reference to psk_key_exchange_modes. As the logic for excluding that extension is not visibly implemented within this function, it does not address the specified condition.",success,
10898,do_send_server_hello,The server MAY send it in the CertificateRequest message.,106,Partially Matches,"[{'A1': {'code': 'if (hs->cert_request) {\n    CBB cert_request_extensions, sigalg_contents, sigalgs_cbb;\n    if (!ssl->method->init_message(ssl, cbb.get(), &body, SSL3_MT_CERTIFICATE_REQUEST) ||\n        !CBB_add_u8(&body, 0 /* no certificate_request_context. */) ||\n        !CBB_add_u16_length_prefixed(&body, &cert_request_extensions) ||\n        !CBB_add_u16(&cert_request_extensions, TLSEXT_TYPE_signature_algorithms) ||\n        !CBB_add_u16_length_prefixed(&cert_request_extensions, &sigalg_contents) ||\n        !CBB_add_u16_length_prefixed(&sigalg_contents, &sigalgs_cbb) ||\n        !tls12_add_verify_sigalgs(hs, &sigalgs_cbb)) {\n      return ssl_hs_error;\n    }\n\n    if (ssl_has_client_CAs(hs->config)) {\n      CBB ca_contents;\n      if (!CBB_add_u16(&cert_request_extensions, TLSEXT_TYPE_certificate_authorities) ||\n          !CBB_add_u16_length_prefixed(&cert_request_extensions, &ca_contents) ||\n          !ssl_add_client_CA_list(hs, &ca_contents) ||\n          !CBB_flush(&cert_request_extensions)) {\n        return ssl_hs_error;\n      }\n    }\n\n    if (!ssl_add_message_cbb(ssl, cbb.get())) {\n      return ssl_hs_error;\n    }\n}', 'explanation': ""This segment implements the optional sending of a CertificateRequest message, which aligns with the RFC specification stating that 'The server MAY send it in the CertificateRequest message.' When hs->cert_request is true, the code constructs and sends the CertificateRequest message with appropriate extensions.""}}]","The function includes explicit logic to send a CertificateRequest message when a client certificate is required, thereby addressing the RFC’s optional behavior. However, it does not incorporate other spec context details (such as HTTP header handling) mentioned in the input, so while the CertificateRequest aspect (action A1) is implemented, not all aspects of the provided specification are addressed within this function alone.",success,
10898,do_send_server_hello,"The ""certificate_authorities"" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which SHOULD be used by the receiving endpoint to guide certificate selection.",104,Does Not Match,[],"The provided function is part of the TLS handshake process (e.g., generating server random, constructing the ServerHello, handling ECH, and sending certificate messages) and includes logic to add a certificate_authorities extension in a CertificateRequest if client CAs are available. However, none of this logic implements the HTTP RFC requirements regarding the evaluation of the If-None-Match header field (such as comparing entity tags or handling GET/HEAD/other methods for 304/412 responses). Therefore, the code function does not address the specified HTTP RFC.",success,
10900,do_send_server_finished,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Partially Matches,"[{'A1': {'code': 'if (!tls13_add_finished(hs) ||\n    // Update the secret to the master secret and derive traffic keys.\n    !tls13_advance_key_schedule(hs, Span(kZeroes, hs->transcript.DigestLen())) ||\n    !tls13_derive_application_secrets(hs) ||\n    !tls13_set_traffic_key(ssl, ssl_encryption_application, evp_aead_seal,\n                           hs->new_session.get(),\n                           hs->server_traffic_secret_0)) {\n    return ssl_hs_error;\n}', 'explanation': 'This segment shows that the function first attempts to add the Finished message (via tls13_add_finished) and then proceeds to advance the key schedule and derive application secrets. This ordering implies that the Finished message is sent before application data encryption keys (and hence application data) are used. However, no explicit check prevents application data from being sent before the Finished message.'}}]","The function does implement key parts of the TLS handshake by sending the Finished message and then updating the key schedule to derive application traffic keys, which in effect enforces that application data (protected by the new keys) is not sent until after the Finished message. However, the function does not contain explicit logic to verify or block application data transmission prior to sending the Finished message, relying on operation ordering alone. Therefore, while it partially meets the requirement of the RFC, the protection against premature application data transmission is not fully enforced within this function alone.",success,
10901,do_send_half_rtt_ticket,"Note: Although the resumption master secret depends on the client's second flight, a server which does not request client authentication MAY compute the remainder of the transcript independently and then send a NewSessionTicket immediately upon sending its Finished rather than waiting for the client Finished.",245,Fully Matches,"[{'C1': {'code': 'hs->expected_client_finished.Resize(hs->transcript.DigestLen());\nif (!tls13_finished_mac(hs, hs->expected_client_finished.data(), &finished_len, false /* client */)) {\n  return ssl_hs_error;\n}\nif (finished_len != hs->expected_client_finished.size()) {\n  OPENSSL_PUT_ERROR(SSL, ERR_R_INTERNAL_ERROR);\n  return ssl_hs_error;\n}\n\n// Feed the predicted Finished into the transcript. This allows us to derive\n// the resumption secret early and send half-RTT tickets.\nassert(!SSL_is_dtls(hs->ssl));\nassert(hs->expected_client_finished.size() <= 0xff);\nuint8_t header[4] = {SSL3_MT_FINISHED, 0, 0, static_cast<uint8_t>(hs->expected_client_finished.size())};', 'explanation': 'This segment computes a predicted client Finished message and integrates it into the transcript. It mirrors the spec’s allowance for computing the remainder of the transcript independently (without waiting for the client’s Finished) when client authentication is not requested.'}}, {'A1': {'code': 'if (!hs->transcript.Update(header) ||\n    !hs->transcript.Update(hs->expected_client_finished) ||\n    !tls13_derive_resumption_secret(hs) ||\n    !add_new_session_tickets(hs, &unused_sent_tickets)) {\n  return ssl_hs_error;\n}', 'explanation': 'This segment derives the resumption secret early and immediately sends a NewSessionTicket, satisfying the RFC spec requirement to send a ticket immediately upon sending Finished rather than waiting for the client Finished.'}}]","The function implements the RFC note regarding early sending of the NewSessionTicket by computing the transcript independently via a predicted Finished message, deriving the resumption secret early, and then dispatching the NewSessionTicket. All the required logic is present within this function, thus it fully meets the spec constraints.",success,
10901,do_send_half_rtt_ticket,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function is part of a TLS 1.3 handshake implementation dealing with half‑RTT ticket sending. It computes a predicted Finished message and updates the transcript in order to derive the resumption secret early. However, the RFC specification under review concerns the ordering of HTTP application data relative to the Finished message – specifically, that application data must not be sent before the Finished message (except as specified). This function does not implement any logic that checks or enforces that application data is not sent before the Finished message. In addition, while the function does send session tickets early, these are handshake messages, not application data. Thus, no part of the function’s logic directly addresses the specified constraint, and its behavior does not align with the HTTP RFC requirement.",success,
10901,do_send_half_rtt_ticket,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function deals with sending half-RTT tickets when early data is accepted, including computing the expected client Finished message and deriving resumption secrets. However, the RFC specification requires that a TLS implementation SHOULD NOT automatically resend early data, leaving the decision of retransmission to the application. There is no logic within this function that prevents or controls the automatic resending of early data. Therefore, no part of the target code function implements any condition or action corresponding to the RFC constraint.",success,
10903,do_read_second_client_flight,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function focuses on processing the second client flight during a TLS handshake. It sets up early and handshake traffic keys and flags based on whether early data was accepted, but it does not implement any logic to decide on retransmission or to prevent automatic resending of early data. The RFC requirement that a TLS implementation SHOULD NOT automatically resend early data is not addressed by any specific logic within this function. Consequently, within the scope of the code provided, none of the labeled spec constraints (such as actions or conditions related to preventing automatic retransmission) are implemented.",success,
10904,do_process_end_of_early_data,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (CBS_len(&msg.body) != 0) {\n        ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n        OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n        return ssl_hs_error;\n      }', 'explanation': 'This section verifies that the received EndOfEarlyData message contains no extra data. If extra data is found (i.e., the message cannot be parsed per expected syntax), it triggers the alert logic, addressing the condition that a message which cannot be parsed should lead to termination.'}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);', 'explanation': ""Upon detecting an improperly parsed message (non-zero length), the function sends a 'decode_error' alert, which corresponds to the action required by the RFC to terminate the connection on such parsing failures.""}}]","The function explicitly checks if the EndOfEarlyData message’s body has any length (indicating an unparseable message) and, if so, sends a decode_error alert before terminating processing. This behavior directly implements the RFC requirement that peers must terminate the connection with a 'decode_error' alert when encountering a message that cannot be correctly parsed. All logic for this condition is contained within the function itself.",success,
10904,do_process_end_of_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The RFC specification states that a TLS implementation SHOULD NOT automatically resend early data and that applications are better suited to decide on retransmission. In the provided function, the code only processes the end-of-early-data message by reading, validating, and consuming it, and then updating the encryption keys. There is no logic that addresses preventing automatic resending of early data or deferring such a decision to the application. Therefore, the function does not implement the specified RFC constraint.",success,
10904,do_process_end_of_early_data,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The RFC specification requires that application data must not be sent before the Finished message. In the provided code, the function 'do_process_end_of_early_data' is concerned with processing the EndOfEarlyData message in the TLS 1.3 handshake. It verifies that the EndOfEarlyData message is correctly received and empty, and then updates the encryption keys. However, there is no logic in this function that explicitly enforces or checks that application data is not sent prior to sending the Finished message. The function solely focuses on handling the EndOfEarlyData phase and does not implement any mechanism to prevent premature application data transmission. Thus, the function does not address the specified RFC constraint by itself.",success,
10904,do_process_end_of_early_data,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Does Not Match,[],"The provided code function, do_process_end_of_early_data, is focused on processing the EndOfEarlyData message during a TLS handshake. It checks if early data was accepted, reads the message, validates that the message type is SSL3_MT_END_OF_EARLY_DATA, and verifies that the message body is empty before proceeding. There is no implementation or logic in this function that addresses the RFC specification related to alert message fragmentation (i.e., ensuring that alert messages are not fragmented across records and that multiple alerts are not coalesced into a single TLSPlaintext record). As such, no part of the function directly implements any of the spec constraints related to alert message fragmentation.",success,
10905,do_read_client_encrypted_extensions,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Does Not Match,[],"The provided function handles the parsing and processing of TLS 1.3 EncryptedExtensions messages, and it includes logic to send a decode_error alert if the TLS message cannot be properly parsed. However, the RFC specification in question pertains to HTTP message parsing (and the handling of HTTP persistent connections) which is entirely different in context. While the function does implement error handling that terminates processing upon encountering parse errors by sending a 'decode_error' alert, this behavior is specific to TLS handshake processing and not to HTTP message parsing as specified by the RFC. Therefore, the function does not address the HTTP RFC requirements.",success,
10905,do_read_client_encrypted_extensions,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The specified RFC requires that TLS 1.3 servers must not act upon the status_request_v2 extension in certain messages. However, the provided function only processes an application_settings extension and does not contain any logic that references or ignores the status_request_v2 extension. Moreover, no handling related to the HTTP Transfer-Encoding or Content-Length context is present in this function. Since no part of the function's logic addresses the labeled conditions or actions from the RFC spec constraints, it does not match the specification.",success,
10905,do_read_client_encrypted_extensions,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided RFC specification mandates that 'Application Data MUST NOT be sent prior to sending the Finished message', but the code function 'do_read_client_encrypted_extensions' does not contain any logic that directly enforces or validates this requirement. Instead, the function processes the Encrypted Extensions message (specifically handling application settings) as part of the TLS handshake. There is no code within this function that checks for the premature sending of application data relative to the Finished message, and therefore no visible implementation addressing the specified constraint.",success,
10905,do_read_client_encrypted_extensions,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS. The provided function only processes client EncryptedExtensions and related application settings, and does not contain any logic regarding the selection, negotiation, or rejection of RC4 cipher suites. Therefore, it does not address any of the labeled conditions or actions specified by the RFC related to RC4.",success,
10906,do_read_client_certificate,The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2).,186,Fully Matches,"[{'C1': {'code': 'if (!hs->cert_request) {\n    if (!ssl->s3->session_reused) {\n      hs->new_session->verify_result = X509_V_OK;\n    }\n    hs->tls13_state = state13_read_channel_id;\n    return ssl_hs_ok;\n  }', 'explanation': ""This segment checks if the server did not request client authentication (i.e. hs->cert_request is false) and skips further processing of a client certificate, thereby implementing the 'if and only if' semantic required by the RFC.""}}, {'A1': {'code': 'if (!ssl->method->get_message(ssl, &msg)) {\n    return ssl_hs_read_message;\n  }\n  if (!ssl_check_message_type(ssl, msg, SSL3_MT_CERTIFICATE) ||\n      !tls13_process_certificate(hs, msg, allow_anonymous) ||\n      !ssl_hash_message(hs, msg)) {\n    return ssl_hs_error;\n  }', 'explanation': 'This part of the code is executed only when hs->cert_request is true, indicating that the server has requested client authentication. The function then reads, verifies, processes, and hashes the certificate message, thus ensuring that a certificate is only handled when expected.'}}]","The function do_read_client_certificate implements the RFC requirement by conditionally processing the client certificate. It first checks whether a certificate was requested by examining hs->cert_request. If not requested, it skips certificate processing. Otherwise, it obtains, verifies, and processes the certificate message. This logic fulfills the 'if and only if' requirement described in the RFC specification.",success,
10906,do_read_client_certificate,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Does Not Match,[],"The provided function is responsible for processing the client certificate during a TLS handshake. It does not include any logic to send an alert or to terminate/abort the connection based on receiving or sending a 'close' option, as described in the RFC specification. Specifically, the RFC constraints that require the connection to be terminated or the handshake to be aborted with an X alert if any alert is sent are not addressed in this function. All connection closing and alert logic appear to be handled elsewhere (if at all), meaning no labeled condition (such as C1) or action (such as A1) from the specification appears in the code body of this function.",success,
10907,do_read_client_certificate_verify,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The RFC specification requires that TLS 1.3 servers MUST NOT act upon the status_request_v2 extension during the handling of certain messages. The provided function, do_read_client_certificate_verify, is responsible for processing the Certificate Verify message and makes no reference to, nor does it implement any logic regarding, the status_request_v2 extension. Therefore, within its own code, it does not address the specified condition nor perform any related action.",success,
10907,do_read_client_certificate_verify,The receiver of a CertificateVerify message MUST verify the signature field.,230,Does Not Match,[],"The RFC constraint requires that the receiver of a CertificateVerify message MUST verify the signature field. In this function, although there is a call to tls13_process_certificate_verify (and ssl_verify_peer_cert), the actual verification logic is delegated to that helper function rather than being implemented directly in this function’s body. Since only logic within the function_body counts, this function does not visibly implement the signature verification of the CertificateVerify message.",success,
10909,do_read_client_finished,"At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message.",238,Fully Matches,"[{'C1': {'code': 'if (!ssl->s3->early_data_accepted) {\n    ...\n    hs->tls13_state = state13_send_new_session_ticket;\n} else {\n    hs->tls13_state = state13_done;\n}', 'explanation': 'This code block is executed after the client Finished message is processed. It checks whether early data was accepted and, if not, sets the state to send a new session ticket, directly addressing the condition that new session tickets MAY be sent after the Finished message.'}}, {'A1': {'code': 'hs->tls13_state = state13_send_new_session_ticket;', 'explanation': ""By assigning the state to 'state13_send_new_session_ticket', the function implements the action of sending a NewSessionTicket as permitted by the RFC after receiving the client Finished message.""}}]","The function explicitly processes the client Finished message and, based on whether early data was accepted, transitions to a state where a NewSessionTicket is sent. This behavior directly corresponds to the RFC specification which allows the server to send a NewSessionTicket after receiving the client Finished message. The implementation in the function addresses both the condition (C1) of being after the client Finished message and the action (A1) of sending a new session ticket, and therefore it fully matches the specified constraints.",success,
10909,do_read_client_finished,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The RFC specifies that application data MUST NOT be sent before the Finished message. This function only deals with receiving and processing the Finished message (e.g., checking its type, processing it, updating handshake states) without any code that verifies or enforces that no application data has been sent prior to this point. There is no explicit check for premature application data within this function; all logic pertains solely to the Finished message processing. Therefore, no portion of the function directly implements the given RFC constraint.",success,
10910,do_send_new_session_ticket,"Servers MAY send multiple tickets on a single connection, either immediately after each other or after specific events (see Appendix C.4).",240,Partially Matches,"[{'A1': {'code': 'bool should_flush = sent_tickets && (SSL_is_dtls(ssl) || SSL_is_quic(ssl));\nreturn should_flush ? ssl_hs_flush : ssl_hs_ok;', 'explanation': 'This segment implements the action of immediately flushing the session tickets when using DTLS or QUIC, which corresponds to one way of sending multiple tickets immediately as allowed by the RFC.'}}]","The function does include logic that directly flushes tickets immediately for DTLS or QUIC transports, addressing the RFC's allowance to send tickets immediately (Action A1). However, the overall logic for adding or sending multiple tickets is delegated to the dependency 'add_new_session_tickets', and therefore this function does not itself fully implement all aspects of the specific RFC requirement regarding multiple ticket transmission (Condition C1). Consequently, only part of the initiative (namely the immediate flush action) is visibly handled within this function.",success,
10911,tls13_server_handshake,"At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message.",238,Fully Matches,"[{'C1': {'code': 'case state13_read_client_finished:\n        ret = do_read_client_finished(hs);\n        break;', 'explanation': 'This segment shows that the function explicitly processes the client Finished message (reading it) before proceeding, satisfying the condition that actions occur after the client Finished message is received.'}}, {'A1': {'code': 'case state13_send_new_session_ticket:\n        ret = do_send_new_session_ticket(hs);\n        break;', 'explanation': 'This segment implements the action by calling do_send_new_session_ticket in the state machine after the client Finished message has been processed, directly addressing the spec’s mandate that the server may send a NewSessionTicket message.'}}]","The provided function implements a TLS 1.3 handshake state machine. It clearly processes the client's Finished message (in state13_read_client_finished) and then proceeds to the state where a NewSessionTicket message may be sent (state13_send_new_session_ticket). This ordering satisfies the RFC specification that after receiving the client Finished message, the server may send a NewSessionTicket message. All of the necessary logic is present within the function itself, with no reliance on external dependencies for this specific behavior.",success,
10911,tls13_server_handshake,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function is a TLS 1.3 handshake state machine that processes various handshake states including one related to early data (state13_process_end_of_early_data). However, the RFC specification requires that a TLS implementation SHOULD NOT automatically resend early data, leaving the decision to the application. There is no explicit logic within this function that addresses or prevents the automatic retransmission of early data. The handling of early data is relegated to a specific state transition rather than incorporating any decision-making logic related to not automatically resending early data. As a result, no part of the function visibly implements any condition (e.g., C1) or action (e.g., A1) corresponding to the spec constraints.",success,
10921,ssl_handle_open_record,"If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation MUST receive a ""close_notify"" alert before indicating end-of-data to the application layer.",318,Partially Matches,"[{'C1': {'code': 'case ssl_open_record_close_notify:\n      ssl->s3->rwstate = SSL_ERROR_ZERO_RETURN;\n      return 0;', 'explanation': 'This segment processes the close_notify alert by setting the state to SSL_ERROR_ZERO_RETURN and returning 0. It demonstrates an attempt to enforce receiving a close_notify before ending data processing, which is part of the RFC requirement.'}}]","The function handles several TLS record states and explicitly handles the case when a close_notify alert is received (C1). However, while it implements the reaction to a close_notify alert by setting a terminal state and halting further processing by returning 0, it does not address the complete HTTP connection 'close' semantics described in the specification context. Since only part of the spec (the TLS close_notify handling) is implemented in this function, the overall match is only partial.",success,
10946,TEST,An AEAD algorithm used in TLS 1.3 MUST NOT produce an expansion greater than 255 octets.,294,Does Not Match,[],"The provided function is a test routine that evaluates whether various AEAD implementations (for both TLS1.2 and TLS1.3) produce expected ciphertext lengths for given plaintext inputs. However, it does not include any logic to check that an AEAD algorithm used in TLS1.3 produces an output expansion of no more than 255 octets. In other words, while it verifies specific ciphertext sizes against predetermined expected values, there is no code that enforces or verifies the RFC requirement (labeled here as C1) that the expansion must not exceed 255 octets. Thus, the function does not visibly address the spec constraint within its own implementation.",success,
10947,get_ech_aead,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function, get_ech_aead, does not include any logic that addresses the spec constraint of not using the Truncated HMAC extension. The function simply iterates through a list of supported AEAD algorithms and returns a matching algorithm based on a provided identifier. There is no code within this function that checks for or disallows the use of a truncated HMAC extension. Therefore, it does not visibly address any of the labeled conditions or actions from the spec constraints.",success,
10948,ssl_client_hello_write_without_extensions,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The RFC specification requires that the OpenPGP certificate type must not be used with TLS 1.3. However, the provided function 'ssl_client_hello_write_without_extensions' is solely responsible for serializing parts of the ClientHello message, such as version, random, session_id, and other fields, without any logic checking or enforcing restrictions on certificate types or TLS version (specifically TLS 1.3). No conditions or actions related to not using the OpenPGP certificate type with TLS 1.3 (e.g., C1, A1, etc.) are present within the code function. Therefore, from the function's code alone, there is no implementation addressing the spec constraint.",success,
10948,ssl_client_hello_write_without_extensions,"A client MUST NOT include the ""early_data"" extension in its followup ClientHello.",148,Fully Matches,"[{'C1': {'code': 'static bool ssl_client_hello_write_without_extensions(\n    const SSL_CLIENT_HELLO *client_hello, CBB *out) {\n  CBB cbb;\n  if (!CBB_add_u16(out, client_hello->version) ||\n      !CBB_add_bytes(out, client_hello->random, client_hello->random_len) ||\n      !CBB_add_u8_length_prefixed(out, &cbb) ||\n      !CBB_add_bytes(&cbb, client_hello->session_id,\n                     client_hello->session_id_len)) {\n    return false;\n  }\n  if (SSL_is_dtls(client_hello->ssl)) {\n    if (!CBB_add_u8_length_prefixed(out, &cbb) ||\n        !CBB_add_bytes(&cbb, client_hello->dtls_cookie,\n                       client_hello->dtls_cookie_len)) {\n      return false;\n    }\n  }\n  if (!CBB_add_u16_length_prefixed(out, &cbb) ||\n      !CBB_add_bytes(&cbb, client_hello->cipher_suites,\n                     client_hello->cipher_suites_len) ||\n      !CBB_add_u8_length_prefixed(out, &cbb) ||\n      !CBB_add_bytes(&cbb, client_hello->compression_methods,\n                     client_hello->compression_methods_len) ||\n      !CBB_flush(out)) {\n    return false;\n  }\n  return true;\n}', 'explanation': ""The function is purposefully named 'ssl_client_hello_write_without_extensions' and its implementation does not include any logic for adding TLS extensions. Since the early_data extension is a TLS extension, its omission directly fulfills the RFC requirement that a client MUST NOT include the 'early_data' extension in its followup ClientHello.""}}]","By deliberately omitting any code that writes a TLS extensions block, this function ensures that no extensions—including the early_data extension—are added to the ClientHello message. Thus, in isolation, the function fully addresses the RFC specification requiring that the early_data extension must not be included.",success,
10948,ssl_client_hello_write_without_extensions,"Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the ""cookie"" extension in the HelloRetryRequest.",59,Partially Matches,"[{'C1': {'code': 'if (SSL_is_dtls(client_hello->ssl)) {\n    if (!CBB_add_u8_length_prefixed(out, &cbb) ||\n        !CBB_add_bytes(&cbb, client_hello->dtls_cookie, client_hello->dtls_cookie_len)) {\n      return false;\n    }\n  }', 'explanation': 'The function deliberately avoids adding any extension responses by using a variant that writes a ClientHello without extensions. The only exception is the conditional inclusion of the DTLS cookie, which corresponds to the allowed exception (i.e. the cookie extension) stated in the RFC. However, the function does not check whether the remote endpoint actually requested any extension, so it relies solely on its naming and structure to avoid sending unsolicited extensions.'}}]","The provided code function 'ssl_client_hello_write_without_extensions' is designed to write a ClientHello message without including the standard extensions, which aligns with the RFC's mandate to not send extension responses if the remote endpoint did not send a corresponding extension request. The only exception built into the code is the conditional addition of the DTLS cookie via the dtls_cookie field when SSL_is_dtls is true, reflecting the permitted exception for a cookie extension. Since the function does not perform any explicit check against remote requests and assumes that no extensions (except the allowed cookie) should be sent, it only partially meets the spec's constraints by its design, rather than by actively verifying the remote endpoint's input.",success,
10949,is_valid_client_hello_inner,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided code function does not implement any logic related to the TLS 1.3 requirement that servers must not process or act upon a ClientHello's status_request_v2 extension. The function focuses solely on validating the presence and content of the encrypted_client_hello and supported_versions extensions, and it does not address any conditions or actions related to the status_request_v2 extension as specified. Additionally, the HTTP Content-Length context provided is not referenced in the function. Therefore, no part of the function visibly meets the specified RFC constraints.",success,
10949,is_valid_client_hello_inner,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Fully Matches,"[{'C1': {'code': 'if (version == SSL3_VERSION || version == TLS1_VERSION || \\\n        version == TLS1_1_VERSION || version == TLS1_2_VERSION || \\\n        version == DTLS1_VERSION || version == DTLS1_2_VERSION) {\n      *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n      OPENSSL_PUT_ERROR(SSL, SSL_R_INVALID_CLIENT_HELLO_INNER);\n      return false;\n    }', 'explanation': 'This code segment iterates over the supported_versions presented in the ClientHello and explicitly rejects SSL 3.0 (and other older versions) by comparing each version to SSL3_VERSION. By doing so, it enforces the RFC requirement that SSL 3.0 must not be negotiated.'}}]","The function inspects the ClientHello message and its supported_versions extension. In the while loop, it checks each version and rejects the handshake if SSL3_VERSION (or other legacy versions) is detected. This directly implements the requirement from RFC6101 and RFC7568 that SSL 3.0 is not to be negotiated. All validation logic addressing this specific spec constraint is contained within this function, satisfying the constraint solely by the function_body.",success,
10949,is_valid_client_hello_inner,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Partially Matches,"[{'C1': {'code': 'while (CBS_len(&versions) != 0) {\n    uint16_t version;\n    if (!CBS_get_u16(&versions, &version)) {\n      *out_alert = SSL_AD_DECODE_ERROR;\n      OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n      return false;\n    }\n    if (version == SSL3_VERSION || version == TLS1_VERSION ||\n        version == TLS1_1_VERSION || version == TLS1_2_VERSION ||\n        version == DTLS1_VERSION || version == DTLS1_2_VERSION) {\n      *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n      OPENSSL_PUT_ERROR(SSL, SSL_R_INVALID_CLIENT_HELLO_INNER);\n      return false;\n    }\n  }', 'explanation': ""This segment iterates over the versions provided in the supported_versions extension and explicitly rejects well-known older TLS versions (TLS 1.2 and below, including DTLS). This addresses part of the RFC requirement by preventing the negotiation of obsolete protocol versions, though it only covers a fixed set of values and does not check an entire range of 'obsolete_RESERVED' values.""}}]","The function implements logic to parse and check the supported_versions extension and rejects any version that is known to be obsolete (i.e. TLS versions older than TLS 1.3). This matches part of the RFC specification that states obsolete values must not be offered or negotiated. However, since the RFC specifies that all values within the 'obsolete_RESERVED' ranges must be avoided and the function only checks for certain known older versions, the implementation only partially meets the full intent of the RFC requirement.",success,
10949,is_valid_client_hello_inner,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!CBS_get_u8_length_prefixed(&extension, &versions) ||\n      CBS_len(&extension) != 0 ||\n      CBS_len(&versions) == 0) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    return false;\n  }\n\n  while (CBS_len(&versions) != 0) {\n    uint16_t version;\n    if (!CBS_get_u16(&versions, &version)) {\n      *out_alert = SSL_AD_DECODE_ERROR;\n      OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n      return false;\n    }', 'explanation': ""These code segments check for various parsing errors (such as issues with length fields and inability to fetch a u16 version number) and, in such cases, set the out_alert to SSL_AD_DECODE_ERROR. This reflects the RFC requirement that a message failing to parse syntactically should result in a 'decode_error' alert.""}}]","The RFC specifies that unparseable messages should lead to termination with a 'decode_error' alert. The function attempts to implement this behavior by checking for particular parsing errors and setting the decode_error alert when they occur. However, not all error conditions in the function result in a decode_error alert (some use SSL_AD_ILLEGAL_PARAMETER), meaning that while part of the RFC constraint is implemented, it is not fully comprehensive. Therefore, the match is only partial.",success,
10949,is_valid_client_hello_inner,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'C1': {'code': 'if (!SSL_parse_client_hello(ssl, &client_hello, body.data(), body.size()) ||\n    !ssl_client_hello_get_extension(&client_hello, &extension,\n                                    TLSEXT_TYPE_encrypted_client_hello) ||\n    CBS_len(&extension) != 1 ||\n    CBS_data(&extension)[0] != ECH_CLIENT_INNER) {\n  *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n  OPENSSL_PUT_ERROR(SSL, SSL_R_INVALID_CLIENT_HELLO_INNER);\n  return false;\n}', 'explanation': ""This segment checks that the expected ECH extension is present, has exactly 1 byte, and that the byte matches the expected ECH_CLIENT_INNER identifier. Failing this, the function terminates by setting an 'illegal_parameter' alert, addressing a core aspect of the RFC requirement regarding semantically invalid messages.""}}, {'A1': {'code': 'while (CBS_len(&versions) != 0) {\n  uint16_t version;\n  if (!CBS_get_u16(&versions, &version)) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    return false;\n  }\n  if (version == SSL3_VERSION || version == TLS1_VERSION ||\n      version == TLS1_1_VERSION || version == TLS1_2_VERSION ||\n      version == DTLS1_VERSION || version == DTLS1_2_VERSION) {\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_INVALID_CLIENT_HELLO_INNER);\n    return false;\n  }\n}', 'explanation': ""This loop inspects the supported_versions extension. It flags the presence of any older (unsupported) TLS or DTLS versions by setting an 'illegal_parameter' alert. This is another instance where semantically invalid input (despite being syntactically correct) is rejected as per the RFC.""}}]","The RFC specification mandates that peers encountering a syntactically correct but semantically invalid message must terminate the connection with an 'illegal_parameter' alert. In the function, some semantic checks (such as verifying the ECH extension and rejecting older protocol versions) are conducted, and in cases of semantic errors the function sets an 'illegal_parameter' alert and returns false. However, not all error conditions (for example, issues encountered during length‐prefixed parsing) result in an 'illegal_parameter' alert—some trigger a 'decode_error' alert instead. Additionally, aspects of the HTTP persistent connection context from the provided spec are not addressed here. Therefore, the implementation only partially meets the overall spec constraints.",success,
10949,is_valid_client_hello_inner,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'A1': {'code': 'if (!CBS_get_u8_length_prefixed(&extension, &versions) ||\n      CBS_len(&extension) != 0 ||\n      CBS_len(&versions) == 0) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    return false;\n}', 'explanation': ""This segment aborts the handshake with a decode_error alert when the supported_versions extension cannot be properly parsed, which partially implements the spec’s requirement to abort with 'decode_error' on failure. However, other error cases in the function (e.g. when the encrypted_client_hello extension is missing or invalid) use a different alert (SSL_AD_ILLEGAL_PARAMETER) rather than decode_error, meaning the spec’s mandate is only partially addressed.""}}]","The function contains logic to abort the handshake with a decode_error alert when a specific parsing error occurs (i.e. when supported_versions is incorrectly formatted), which aligns with one part of the specification. However, not all error conditions abort with a decode_error alert (some use an illegal_parameter alert), and other aspects of the broader RFC context (such as case-insensitive header matching or protocol order requirements) are not handled in this function. Thus, while the function visibly addresses one key action (A1) of aborting with a decode_error under some conditions, it does not fully implement the specification.",success,
10950,ssl_decode_client_hello_inner,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function is focused on decoding and processing the ClientHelloInner message (particularly related to TLS ECH) and does not contain any logic that addresses the specific RFC requirement that TLS 1.3 servers must not act upon the presence or information of the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. There is no handling of the status_request_v2 extension or of any HTTP header-related framing (such as Content-Length or Transfer-Encoding) within this function. Therefore, none of the spec constraints (e.g., C1, A1, etc.) are visibly implemented in this code function.",success,
10950,ssl_decode_client_hello_inner,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided spec requires that implementations MUST NOT use the Truncated HMAC extension. However, within the function_body there is no visible logic addressing this requirement. No checks, conditions, or handling related to preventing the use of the Truncated HMAC extension are present in this function. Therefore, in isolation, the function does not implement the specified constraint.",success,
10950,ssl_decode_client_hello_inner,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'C1': {'code': 'while (CBS_get_u8(&cbs, &padding)) {\n    if (padding != 0) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n      *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n      return false;\n    }\n  }', 'explanation': ""This segment verifies that any extra padding bytes are zero. If a non-zero byte is encountered (i.e. a semantically invalid message), it terminates processing by setting the alert to SSL_AD_ILLEGAL_PARAMETER, in line with the spec requirement to terminate the connection with an 'illegal_parameter' alert.""}}, {'C2': {'code': 'if (want == TLSEXT_TYPE_encrypted_client_hello) {\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_INVALID_OUTER_EXTENSION);\n    return false;\n  }', 'explanation': 'When an invalid reference to the ECH extension is detected (i.e. encountering the TLSEXT_TYPE_encrypted_client_hello in a context where it should not appear), the function sets the out_alert to SSL_AD_ILLEGAL_PARAMETER and terminates processing, thereby enforcing the required behavior from the RFC.'}}]","The function contains explicit checks for semantically invalid parameters – for example, it ensures that padding bytes are zero and that certain extensions (such as TLSEXT_TYPE_encrypted_client_hello) are not misused. In these cases, it sets the alert to SSL_AD_ILLEGAL_PARAMETER and returns false, which implements the RFC mandate to terminate the connection when a validly formatted but semantically invalid message is received. However, while these parts of the RFC are addressed, the provided spec also includes HTTP persistent connection details which are outside the scope of this function. Thus, the function partially matches the overall specification by addressing the illegal_parameter alert requirement but not the persistent connection aspects.",success,
10950,ssl_decode_client_hello_inner,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!ssl_parse_client_hello_with_trailing_data(ssl, &cbs, &client_hello_inner)) {\n    return false;\n}\n...\nuint8_t padding;\nwhile (CBS_get_u8(&cbs, &padding)) {\n    if (padding != 0) {\n        OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n        *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n        return false;\n    }\n}\n...\nif (client_hello_inner.extensions_len == 0 ||\n    client_hello_inner.session_id_len != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    return false;\n}', 'explanation': 'The function checks whether parts of the ClientHello message have been parsed correctly. It validates trailing padding (ensuring that non-zero bytes are rejected) and ensures required fields (such as the presence of extensions) are correct. When an error is detected, it calls OPENSSL_PUT_ERROR with SSL_R_DECODE_ERROR and returns false, which is an attempt to adhere to the RFC clause that requires termination with a decode error. However, in some branches (e.g. on non-zero padding) it sets the alert to SSL_AD_ILLEGAL_PARAMETER rather than a dedicated ""decode_error"" alert.'}}]","The RFC specification requires that a peer terminate the connection with a ""decode_error"" alert when a message cannot be parsed according to the syntax. The function implements several checks on the message (such as validating padding and required fields) and calls OPENSSL_PUT_ERROR with SSL_R_DECODE_ERROR on error conditions. It then returns false to indicate a failure in decoding. However, the function does not consistently set an alert that precisely corresponds to a ""decode_error"" (for instance, it uses SSL_AD_ILLEGAL_PARAMETER in some cases) and some parsing aspects are handled by other functions. Thus, while the function addresses many of the parsing error conditions, it only partially meets the spec’s requirement by not fully standardizing the alert mechanism as specified.",success,
10950,ssl_decode_client_hello_inner,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'C1': {'code': ""  // TLS 1.3 ClientHellos must have extensions, and EncodedClientHelloInners use\n  // ClientHelloOuter's session_id.\n  if (client_hello_inner.extensions_len == 0 ||\n      client_hello_inner.session_id_len != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    return false;\n  }"", 'explanation': ""The function checks that the ClientHelloInner has non-zero extensions and a zero-length session_id. This ensures that, if the condition is not met, the handshake is aborted – addressing the requirement to abort (though not all error paths use the expected 'decode_error' alert value).""}}]","The function implements internal validation logic that aborts the handshake if the ClientHelloInner message does not meet expected conditions (for example, if there are no extensions or if the session_id is non-zero), which is in line with the RFC’s requirement of aborting the handshake on error. However, while it does abort on error conditions by returning false and logging a decode error, the function does not consistently set the alert to the literal 'decode_error' as stipulated in the spec (for example, some error paths set the alert to SSL_AD_ILLEGAL_PARAMETER). Thus, the implementation only partially matches the specified constraint.",success,
10950,ssl_decode_client_hello_inner,Servers MUST NOT send this extension.,115,Fully Matches,"[{'C1': {'code': 'if (want == TLSEXT_TYPE_encrypted_client_hello) {\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_INVALID_OUTER_EXTENSION);\n    return false;\n}', 'explanation': ""This code segment explicitly checks for the disallowed extension TLSEXT_TYPE_encrypted_client_hello and aborts processing if it is encountered. This directly implements the RFC requirement (i.e. 'Servers MUST NOT send this extension.') by ensuring that if this extension is found within the client hello inner message, it results in an error.""}}]","The function 'ssl_decode_client_hello_inner' processes the inner client hello, and during its handling of outer extensions, it looks for the extension whose type is TLSEXT_TYPE_encrypted_client_hello. Encountering this extension causes the function to set an alert and return an error, effectively preventing the server from sending (or acting upon) that extension. This check, implemented entirely within the function, satisfies the RFC constraint by ensuring that the forbidden extension is not allowed.",success,
10951,ssl_client_hello_decrypt,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Does Not Match,[],"The provided RFC specification requires enforcing a specific ordering for HKDF-Extract and HKDF-Expand operations, specifically ensuring an HKDF-Expand occurs between two uses of HKDF-Extract. The given function (ssl_client_hello_decrypt) does not include any logic related to HKDF operations; instead, it focuses on decrypting a ClientHello message using HPKE and processing associated AAD adjustments. Therefore, none of the labeled spec constraints (e.g., C1, A1) corresponding to the HKDF ordering requirement are implemented in this function.",success,
10951,ssl_client_hello_decrypt,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification prohibits offering or negotiating RC4 cipher suites for any version of TLS. The provided function, ssl_client_hello_decrypt, is solely focused on decrypting the ClientHello message using HPKE decryption and handling associated data for the ESNI extension. There is no logic within this function that references RC4 cipher suites or their negotiation, which means that none of the spec constraints (e.g., C1, A1, etc.) related to RC4 removal are addressed in this function.",success,
10951,ssl_client_hello_decrypt,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided spec requires that implementations MUST NOT use the Truncated HMAC extension. In the function body, there is no logic or code segments that address or enforce the avoidance of the Truncated HMAC extension. The code is focused on decrypting the ClientHelloInner using HPKE and manipulating the AAD, and it does not contain any checks or constraints related to truncated HMAC usage. Therefore, no part of the function directly implements the specified RFC condition.",success,
10955,parse_ech_config,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!CBS_get_u16(cbs, &version) ||\n    !CBS_get_u16_length_prefixed(cbs, &contents)) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n  return false;\n}\n...\nif (!CBS_get_u16_length_prefixed(&contents, &extensions) ||\n    CBS_len(&contents) != 0) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n  return false;\n}', 'explanation': ""The function checks for several syntax and length conditions when parsing the ECHConfig. Whenever these conditions are violated, it calls OPENSSL_PUT_ERROR with SSL_R_DECODE_ERROR and returns false. This behavior directly matches the requirement to generate a 'decode_error' alert when a message cannot be parsed according to the syntax.""}}]","The RFC specifies that peers must terminate the connection with a 'decode_error' alert when a message cannot be parsed. This function performs detailed parsing checks and, on detecting any irregularities (such as insufficient data or invalid lengths), it calls OPENSSL_PUT_ERROR with the decode error code and returns false. While this clearly handles the detection of malformed messages and signals an error as required (thus matching the condition for raising the alert), it does not itself terminate the connection—the act of termination is expected to be performed by the caller based on the error return. Moreover, aspects related to HTTP/1.1 persistent connection handling are not addressed here. Therefore, the function partially matches the RFC: it implements the error signalling for parsing errors but does not directly implement connection termination.",success,
10956,Init,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Does Not Match,[],"The provided function is concerned with parsing and validating an ECH configuration in the context of TLS (specifically, ECH server configuration) rather than parsing an HTTP message. Although the function does check for parsing errors (e.g., extra bytes in the buffer lead to an error via OPENSSL_PUT_ERROR with SSL_R_DECODE_ERROR), this logic is specific to ECH configuration parsing. The RFC specification under review requires that if an HTTP message cannot be parsed according to its syntax, the connection must be terminated with a 'decode_error' alert. Moreover, the spec context (persistent connections in HTTP/1.1, Connection header field, etc.) is not addressed at all by this function. Since only logic within the function itself is considered and it neither handles HTTP message parsing nor the persistent connection context, the code function does not implement the specified HTTP RFC.",success,
10957,SetupContext,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function is responsible for setting up an HPKE context and verifying supported cipher suites based on kdf_id and aead_id. It primarily focuses on ensuring that the offered cipher suite is among those supported and on constructing an 'info' buffer before calling EVP_HPKE_CTX_setup_recipient. There is no visible logic that checks or enforces that the OpenPGP certificate type is not used with TLS 1.3. Therefore, none of the spec constraints (regarding not using the OpenPGP certificate type with TLS 1.3) are addressed within this function.",success,
10960,ssl_select_ech_config,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The RFC specification requires that the OpenPGP certificate type MUST NOT be used with TLS 1.3. In the provided function, the only check related to TLS version is the condition that returns early if the maximum version is below TLS 1.3, and then proceeds with ECH configuration processing (which implicitly assumes TLS 1.3 or above). There is no logic in the function that inspects or disables the use of the OpenPGP certificate type when TLS 1.3 is in use. Therefore, no part of the function's code addresses the specified constraint.",success,
10960,ssl_select_ech_config,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided code function focuses on selecting and processing an ECH configuration for TLS 1.3 and setting up an HPKE context. It does not include any logic that directly prevents the use of the Truncated HMAC extension as specified by RFC6066. There is no code addressing the requirement that 'Implementations MUST NOT use the Truncated HMAC extension', either for AEAD algorithms or in any other context. Therefore, this function does not visibly address the labeled constraint from the RFC specification.",success,
10963,setup_ech_grease,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function 'setup_ech_grease' does not contain any logic addressing the spec constraint from RFC6091 ('The OpenPGP certificate type MUST NOT be used with TLS 1.3'). Instead, its logic is focused entirely on setting up GREASE for ECH during a TLS handshake. It checks for TLS version compatibility and whether GREASE is enabled but makes no reference to OpenPGP certificate types. Thus, no part of this function implements any condition (like C1) or action (like A1) related to the OpenPGP certificate type restriction.",success,
10963,setup_ech_grease,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The RFC spec requires that the server MUST NOT send a 'psk_key_exchange_modes' extension. In the code function, although there is a comment listing 'psk_key_exchange_modes' as one of the extensions in the payload construction, the function does not include any logic to prevent or filter out sending this extension. Instead, it blindly constructs a random payload (GREASE) that appears to include this extension among others. Therefore, there is no visible implementation in this function that enforces the constraint, meaning the function does not meet the specification.",success,
10963,setup_ech_grease,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification requires that implementations MUST NOT use the Truncated HMAC extension. The provided function 'setup_ech_grease' does not contain any logic addressing or enforcing this constraint—it neither references the Truncated HMAC extension nor includes checks or mechanisms related to its usage. The code focuses on setting up parameters for GREASE in the context of ECH, such as selecting appropriate AEAD algorithms and generating key material, without any handling of the truncated HMAC extension. Therefore, no part of the function directly implements any of the labeled conditions or actions from the specification.",success,
10963,setup_ech_grease,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The RFC spec requires that values within the 'obsolete_RESERVED' ranges not be offered or negotiated in TLS 1.3. The provided function does not contain any logic that checks or enforces that constraint. While it does check the TLS version (skipping the ECH grease setup for versions below TLS 1.3), there is no code that specifically prevents the use of values from the obsolete_RESERVED ranges. Therefore, none of the labeled conditions (e.g., C1) or actions (e.g., A1) related to this RFC requirement are fully implemented within this function.",success,
10963,setup_ech_grease,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function, setup_ech_grease, is responsible for generating GREASE values for the Encrypted ClientHello (ECH) during a TLS handshake, and it focuses on constructing binary representations with random payloads. It does not address any of the spec constraints regarding the handling of the 'supported_groups' information or the evaluation of an If-Unmodified-Since header field as described in the HTTP RFC specification. There is no logic within this function that checks handshake completion before acting on 'supported_groups' or handles precondition logic for HTTP date comparisons, hence it does not visibly implement any of the labeled conditions (C1, C2, etc.) or actions (A1, A2, etc.).",success,
10964,ssl_encrypt_client_hello,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The RFC specification requires that the OpenPGP certificate type MUST NOT be used with TLS 1.3. However, the function ssl_encrypt_client_hello only addresses constructing and encrypting the ClientHelloInner and ClientHelloOuter messages for ESNI (Encrypted ClientHello) and does not include any logic that checks or prohibits the use of the OpenPGP certificate type. There is no reference, validation, or enforcement of the OpenPGP certificate type in the code. Therefore, none of the labeled spec constraints (e.g., C1, A1) related to the OpenPGP certificate type are implemented in this function.",success,
10964,ssl_encrypt_client_hello,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided code function implements various aspects of encrypting a ClientHello message (including operations related to ECH and PSK binder adjustments) but does not contain any visible logic that explicitly addresses the RFC requirement of not using the Truncated HMAC extension. There is no code segment checking for or prohibiting usage of a truncated HMAC mechanism. As the function does not contain any logic specifically targeting this constraint, it does not match the RFC specification regarding the truncated HMAC extension.",success,
10964,ssl_encrypt_client_hello,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Fully Matches,"[{'A1': {'code': 'size_t padding_len = 0;\nsize_t maximum_name_length = hs->selected_ech_config->maximum_name_length;\nif (ssl->hostname) {\n  size_t hostname_len = strlen(ssl->hostname.get());\n  if (hostname_len <= maximum_name_length) {\n    padding_len = maximum_name_length - hostname_len;\n  }\n} else {\n  // No SNI. Pad up to |maximum_name_length|, including server_name extension overhead.\n  padding_len = 9 + maximum_name_length;\n}\n// Pad the whole thing to a multiple of 32 bytes.\npadding_len += 31 - ((CBB_len(encoded_cbb.get()) + padding_len - 1) % 32);\nif (!CBB_add_zeros(encoded_cbb.get(), padding_len) ||\n    !CBBFinishArray(encoded_cbb.get(), &encoded)) {\n  return false;\n}', 'explanation': ""This segment of code calculates the necessary padding length based on the maximum name length and then pads the EncodedClientHelloInner (which will be encrypted) by adding zeros. This implements the RFC’s allowance ('MAY choose to pad') when generating a TLSCiphertext record.""}}]","The function 'ssl_encrypt_client_hello' contains explicit logic to determine and add appropriate padding to the data that will eventually be encrypted, which directly addresses the specification stating that implementations may choose to add padding when generating a TLSCiphertext record. All of the padding logic is implemented inside this function, making it fully self-contained in handling that requirement.",success,
10967,SSL_get0_ech_name_override,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function only handles an override for the ECH public name when ECH is rejected. It does not include any logic related to the RFC specification about early data retransmission (i.e., not automatically resending early data) or the handling of HTTP 302 redirection as provided in the specification context. Therefore, no part of the function_body visibly addresses any labeled conditions or actions from the spec constraints.",success,
10969,SSL_marshal_ech_config,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided code function 'SSL_marshal_ech_config' is concerned with constructing an ECH configuration (referring to draft-ietf-tls-esni-13) and does not include any logic to address the spec constraint from RFC6091, which mandates that the OpenPGP certificate type MUST NOT be used with TLS 1.3. There is no code checking for the usage of the OpenPGP certificate type or ensuring it is not used with TLS 1.3. Therefore, no labeled conditions or actions in the spec constraints (e.g., C1, A1) are visibly implemented in the function.",success,
10977,SSL_ech_accepted,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function checks whether early data is accepted by inspecting internal state (such as checking if ssl->s3->hs->selected_ech_config is not null or comparing ssl->s3->ech_status with ssl_ech_accepted). This does not implement any logic related to the spec constraint that a TLS implementation SHOULD NOT automatically resend early data, nor does it provide an application decision mechanism for retransmission. No part of the function addresses the TLS retransmission decision requirement as stated in the specification.",success,
10978,~SSLAEADContext,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Does Not Match,[],"The provided code function is an empty destructor (SSLAEADContext::~SSLAEADContext() {}) with no implementation logic. It does not include any processing, ordering, or checks related to HKDF-Extract, HKDF-Expand, or any other condition or action specified in the RFC. Therefore, it does not visibly address any of the labeled spec constraints.",success,
10978,~SSLAEADContext,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided code function is an empty destructor (SSLAEADContext::~SSLAEADContext() {}) and contains no logic addressing any of the specifications or constraints (e.g., the prohibition of the Truncated HMAC extension) outlined in the RFC spec. There are no code segments within this function that implement or reference any labeled conditions (C1, C2, etc.) or actions (A1, A2, etc.), and therefore it does not meet the requirements by itself.",success,
10979,CreateNullCipher,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function only creates an SSLAEADContext with a null cipher and does not contain any logic related to the RFC specification, which mandates that implementations MUST NOT use the Truncated HMAC extension. There is no code within this function that addresses any condition or action related to avoiding the use of the Truncated HMAC extension as required by the spec constraints.",success,
10980,Create,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Fully Matches,"[{'C1': {'code': 'if (mac_key.empty()) {\n    // This is an actual AEAD.\n    aead_ctx->fixed_nonce_.CopyFrom(fixed_iv);\n    ...\n} else {\n    // This is a CBC cipher suite that implements the |EVP_AEAD| interface. The\n    // |EVP_AEAD| takes the MAC key, encryption key, and fixed IV concatenated\n    // as its input key.\n    OPENSSL_memcpy(merged_key, mac_key.data(), mac_key.size());\n    OPENSSL_memcpy(merged_key + mac_key.size(), enc_key.data(), enc_key.size());\n    OPENSSL_memcpy(merged_key + mac_key.size() + enc_key.size(),\n                   fixed_iv.data(), fixed_iv.size());\n    ...\n}', 'explanation': ""The RFC specification forbids using the truncated HMAC extension. In this function the code path clearly differentiates between an actual AEAD implementation (when 'mac_key' is empty) and a CBC-based cipher suite. In neither branch is truncated HMAC used. The code inherently avoids implementing or invoking any truncated HMAC logic, thereby satisfying the requirement.""}}]","The RFC constraint requires that truncated HMAC extensions are not used because they are insecure and not applicable to AEAD algorithms. The function solely focuses on setting up an AEAD context—branching based on whether the mac_key is empty—and in doing so, it never introduces or invokes any truncated HMAC functionality. Therefore, even though there is no explicit check for a truncated HMAC, by not including any such logic the function visibly meets the specification.",success,
10981,CreatePlaceholderForQUIC,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Does Not Match,[],"The function SSLAEADContext::CreatePlaceholderForQUIC simply creates a new SSLAEADContext instance using the provided cipher and does not include any logic that addresses the specification constraints regarding alert message fragmentation or coalescing. There is no code handling alert messages (such as preventing their fragmentation across TLSPlaintext records), so none of the spec conditions (e.g., C1) or actions (e.g., A1) are implemented in this function.",success,
10981,CreatePlaceholderForQUIC,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function simply creates and returns a new SSLAEADContext object using MakeUnique with the given cipher. There is no logic within this function that checks for or prohibits the use of the Truncated HMAC extension, as specified by the RFC requirement. No part of this code addresses any of the relevant conditions or actions relating to the RFC specification.",success,
10983,SuffixLen,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification mandates that implementations MUST NOT use the Truncated HMAC extension for AEAD algorithms. The provided function SSLAEADContext::SuffixLen, however, does not include any logic related to preventing the use or checking for the Truncated HMAC extension. The function only handles suffix length determination based on conditions such as null cipher or fuzzer mode, and otherwise defers to EVP_AEAD_CTX_tag_len for tag length computation. As there is no specific code addressing the RFC requirement about not using the Truncated HMAC extension, no corresponding constraint (e.g., C1, A1) is met by this function.",success,
10987,GetAdditionalData,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function simply constructs additional data for AEAD operations by copying various fields (sequence number, type, version, and optionally length) into a storage buffer and returning a span over it. There is no logic within this function that relates to or prevents the use of the Truncated HMAC extension as required by the RFC specification. Since the spec constraint (i.e., not using the Truncated HMAC extension) is not addressed anywhere in this function, the function does not visibly implement or enforce the specified requirement.",success,
10988,Open,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Fully Matches,"[{'C1': {'code': 'if (!EVP_AEAD_CTX_open(ctx_.get(), in.data(), &len, in.size(), nonce, nonce_len, in.data(), in.size(), ad.data(), ad.size())) { return false; }', 'explanation': 'The RFC requires that implementations MUST NOT use the Truncated HMAC extension, which is applicable only when using traditional MAC‑then‑encrypt methods. This function implements decryption using an AEAD construction via EVP_AEAD_CTX_open and related setup, and it does not invoke or reference any truncated HMAC functionality. By relying solely on AEAD decryption operations, the function inherently avoids using the insecure (and disallowed) truncated HMAC extension.'}}]","The function implements AEAD decryption by constructing the additional data, nonce, and then invoking the EVP_AEAD_CTX_open API. Because AEAD algorithms do not use HMAC (and specifically do not use any truncated HMAC extension), the function effectively complies with the RFC specification that mandates implementations MUST NOT use the Truncated HMAC extension. All the necessary logic for decryption is contained within the function, and no code related to HMAC or its truncated variant is present.",success,
10989,SealScatter,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function is focused on the AEAD encryption process including nonce assembly, additional data formation, and output handling. There is no logic addressing the prohibition against using the Truncated HMAC extension as specified in RFC6066. The function does not contain any conditional checks or logic related to avoiding truncated HMAC, so thus it does not visibly address the given RFC constraint within its implementation.",success,
10990,Seal,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Fully Matches,"[{'C1': {'code': 'if (!SuffixLen(&suffix_len, in_len, 0)) { ... }\n...\nif (!SealScatter(out, out + prefix_len, out + prefix_len + in_len, type, record_version, seqnum, header, in, in_len, 0, 0)) { ... }', 'explanation': 'The RFC specifies that implementations MUST NOT use the Truncated HMAC extension. In this function, the suffix length and SealScatter are both invoked with a parameter of 0 in the positions where a truncated HMAC might be enabled (the last argument in both SuffixLen and SealScatter). By explicitly passing 0, the function indicates that the truncated HMAC extension is not used, thereby meeting the spec requirement.'}}]","In isolation, the Seal function sets up buffers and calls SuffixLen and SealScatter with fixed parameters (0 for the truncated HMAC related arguments). This indicates that the function disables or bypasses any logic that would implement the Truncated HMAC extension, in accordance with the RFC specification. No other part of the function suggests any further support or usage of truncated HMAC. Therefore, the function visibly addresses the constraint and fully matches the spec requirement.",success,
10990,Seal,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Fully Matches,"[{'C1': {'code': 'size_t suffix_len;\nif (!SuffixLen(&suffix_len, in_len, 0)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_RECORD_TOO_LARGE);\n    return false;\n}\n...\n*out_len = prefix_len + in_len + suffix_len;', 'explanation': 'The RFC states that when generating a TLSCiphertext record, implementations MAY choose to pad. This function calls SuffixLen to obtain a padding (suffix) length and then incorporates that value into the final output length. By doing so, it explicitly allows for optional padding in the generated TLSCiphertext record.'}}]","The function implements the optional padding behavior required by the RFC. It calculates a suffix length—allowing for padding—and adds it to the overall output length, which is in direct accordance with the specification that implementations MAY choose to pad when generating a TLSCiphertext record. Since the optional nature of padding is satisfied by the dynamic calculation (which may yield zero when no padding is desired), the function fully addresses the specified RFC constraint within its own logic.",success,
10992,serialize_features,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function 'serialize_features' is focused on serializing TLS features such as cipher suites, named groups, and ALPS values into an ASN.1 structure. It does not contain any logic that addresses the specification constraint regarding the prohibition of using the OpenPGP certificate type with TLS 1.3 as stated in RFC6091. There are no checks or conditions related to certificate types or TLS version within this function. Therefore, no labeled condition or action (e.g., C1, A1) from the specification is implemented in the function.",success,
10998,SSL_serialize_handback,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification requires that implementations MUST NOT use the Truncated HMAC extension. An inspection of the function body of SSL_serialize_handback reveals no explicit logic either to detect, disable, or otherwise address the use of the truncated HMAC extension. While there is a check using uses_disallowed_feature(ssl), this function is not defined here and its behavior is not part of the visible code; therefore, by itself, the code function does not implement any condition (such as a labeled C1) or action (such as a labeled A1) that directly ensures the truncated HMAC extension is not used. Thus, the function does not fulfill the specified constraint.",success,
10998,SSL_serialize_handback,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function SSL_serialize_handback serializes various TLS handshake parameters and includes branches to capture early data state. However, there is no code within this function that prevents or controls the automatic resending of early data, which is the core requirement specified by the RFC. In other words, while it records early data conditions (e.g., early_data_accepted, early_data_rejected_hrr, early_data_skipped), it does not implement any mechanism to ensure that early data is not resent automatically. Thus, none of the spec’s conditions or actions (here labeled as C1, A1, etc. in the constraints example) are fully implemented within the function.",success,
11000,SSL_apply_handback,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided code function, SSL_apply_handback, is focused on parsing and restoring the state for an SSL/TLS session, including key derivation, state transitions, and secret copying. It does not contain any logic—either a check, restriction, or explicit reference—that forbids or otherwise handles the use of the Truncated HMAC extension as required by the RFC specification. Therefore, based solely on the function body, it does not attempt to implement the spec constraint that mandates not using the Truncated HMAC extension.",success,
11000,SSL_apply_handback,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The RFC specification requires that a TLS implementation SHOULD NOT automatically resend early data and that applications should have control over retransmission decisions. This function, SSL_apply_handback, processes a handback blob and sets various flags related to early data (for example, setting hs->can_early_write, hs->can_early_read, and hs->in_early_data when early_data_type is early_data_accepted). However, it does not include any logic to ensure that early data is not automatically resent; it simply transfers state from the handback blob without imposing any additional decision-making or restrictions related to early data retransmission. Since there is no visible logic within the function that implements the requirement described in the spec constraint, the function does not address the constraint by itself.",success,
11000,SSL_apply_handback,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The provided function 'SSL_apply_handback' is responsible for restoring and configuring the TLS handshake state from a serialized (handback) message. It handles state restoration, reconfiguration of encryption keys, and other handshake-related parameters. However, it does not contain any explicit logic or checks related to the 'psk_key_exchange_modes' extension. Specifically, there is no code segment that verifies or prevents the server from sending a 'psk_key_exchange_modes' extension as required by the spec. Since only logic within this function is considered and no part of it implements the spec's prohibition against sending the 'psk_key_exchange_modes' extension, the function does not match the constraint.",success,
11002,SSL_request_handshake_hints,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function does not contain any logic that addresses the specified RFC requirement for TLS 1.3 servers to ignore the status_request_v2 extension when processing ClientHello messages, nor does it reference any handling related to the HTTP framing context (Content-Length vs Transfer-Encoding). The code solely focuses on processing handshake hints and setting internal state without checking for or acting upon the status_request_v2 extension. Therefore, no labeled conditions or actions (e.g., C1, A1) from the spec constraints are visibly implemented within the function body.",success,
11003,SSL_serialize_handshake_hints,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function, SSL_serialize_handshake_hints, solely serializes various handshake hints (such as server_random_tls13, key_share, signature, etc.) into an ASN.1 sequence. There is no code within this function that checks, validates, or restricts the use of the OpenPGP certificate type, nor is there any handling to ensure that it is not used with TLS 1.3 in accordance with RFC6091. Thus, the function does not address any of the labeled conditions or actions from the specification.",success,
11013,tls_write_app_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'C1': {'code': 'if (hs->early_data_written >= hs->early_session->ticket_max_early_data) {\n    ssl->s3->unreported_bytes_written = total_bytes_written;\n    hs->can_early_write = false;\n    *out_needs_handshake = true;\n    return -1;\n  }', 'explanation': 'This code prevents automatic resending of early data by checking if the amount of early data written has reached the permitted limit. When the limit is exceeded, it disables early write and signals that a handshake is needed, thereby leaving the decision to the application as required by the RFC.'}}]","The function directly implements the specified behavior for early data handling. Rather than automatically retrying or resending early data, the function checks the early data count against a permitted limit and, if reached, sets a flag to require a handshake and returns an error. This ensures that early data is not automatically resent, which is in full compliance with the RFC requirement that TLS implementations must let the application decide on retransmission, satisfying the labeled constraint (C1) within this function's code.",success,
11013,tls_write_app_data,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specifies that implementations MUST NOT use the Truncated HMAC extension. The provided function tls_write_app_data does not include any logic related to checking for, disabling, or otherwise handling the Truncated HMAC extension. Its focus is on writing application data, managing handshake state, and handling early data write limits, with no visible code addressing any constraint regarding the use (or non-use) of the Truncated HMAC extension. Therefore, the function does not visibly implement the required specification.",success,
11013,tls_write_app_data,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Does Not Match,[],"The RFC specification requires that alert messages MUST NOT be fragmented across records and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record. The provided function, tls_write_app_data, is designed for handling application data (using the SSL3_RT_APPLICATION_DATA record type) and is not concerned with alert message processing. There is no logic in this function that specifically handles or enforces constraints regarding the fragmentation or coalescing of alert messages as stated in the spec. Therefore, the function does not visibly address any of the specified conditions or actions from the RFC.",success,
11013,tls_write_app_data,-Handshake messages MUST NOT be interleaved with other record types.,275,Does Not Match,[],"The RFC specifies that 'Handshake messages MUST NOT be interleaved with other record types.' However, the function tls_write_app_data only processes application data records (as indicated by its use of SSL3_RT_APPLICATION_DATA) and does not contain any logic that ensures handshake messages are not interleaved with application data or any other record type. There is no code segment within tls_write_app_data that verifies or enforces the non-interleaving of handshake messages. Therefore, in isolation, the function does not address this RFC constraint.",success,
11014,tls_seal_align_prefix_len,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification requires that implementations must not use the Truncated HMAC extension. The provided function, tls_seal_align_prefix_len, only computes a prefix length for TLS records based on the header length, explicit nonce length, and potential record splitting overhead. There is no logic in this function that checks for or actively disables the Truncated HMAC extension. Consequently, no part of the function addresses the spec constraint regarding Truncated HMAC, and thus it does not match the constraint.",success,
11015,do_tls_write,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Does Not Match,[],"The RFC specifies that when generating a TLSCiphertext record, implementations MAY choose to pad. In the provided function_body, there is no explicit logic or decision-making regarding optional padding. The function delegates record creation to tls_seal_record and calculates overhead using SSL_max_seal_overhead, but it does not conditionally add padding or offer any branch specifically implementing the padding option as per the spec. Therefore, within the function_body itself, there is no visible implementation of the specified behavior.",success,
11015,do_tls_write,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function implements a TLS write operation by handling pending writes, flushing buffers, sealing records, and ensuring write retries are consistent. However, none of its internal logic explicitly or implicitly enforces the RFC requirement that “a TLS implementation SHOULD NOT automatically resend early data.” In other words, the function does not include any code that distinguishes early data from other types of data or that prevents its automatic retransmission. The checks for consistent retries simply ensure that a pending write is retried with identical parameters, but this is a generic mechanism and does not address the specific constraint regarding early data. As a result, in isolation, the function does not visibly implement the specified RFC constraint.",success,
11015,do_tls_write,"Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure.",283,Does Not Match,[],"The RFC specification requires that zero-length fragments of Application Data MAY be sent as a countermeasure, yet within the function do_tls_write there is no explicit logic that creates or sends a zero-length fragment. In the code, when the input data (in) is empty, the function simply returns success (by setting out_bytes_written to 0) without calling the record sealing function (tls_seal_record) to actually produce a zero-length record. Therefore, this function does not visibly address the specified RFC requirement within its own logic.",success,
11016,tls_open_app_data,"A server receiving more than max_early_data_size bytes of 0-RTT data SHOULD terminate the connection with an ""unexpected_message"" alert.",252,Fully Matches,"[{'C1': {'code': 'if (is_early_data_read) {\n    if (body.size() > kMaxEarlyDataAccepted - ssl->s3->hs->early_data_read) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_TOO_MUCH_READ_EARLY_DATA);\n      *out_alert = SSL3_AD_UNEXPECTED_MESSAGE;\n      return ssl_open_record_error;\n    }\n\n    ssl->s3->hs->early_data_read += body.size();\n  }', 'explanation': ""This segment checks if the SSL connection is in early data mode and ensures that the total early data (including the current chunk) does not exceed the allowed maximum (kMaxEarlyDataAccepted). If it does, the function terminates the connection by returning an error and setting the alert to 'unexpected_message', directly implementing the specification that the server should abort the connection when more than max_early_data_size bytes of 0-RTT data are received.""}}]","The provided function includes a conditional block that specifically handles early data mode. It calculates whether the incoming data would push the total early data beyond the maximum allowed. If so, it immediately triggers an error with an 'unexpected_message' alert, which is exactly what the RFC mandates. Since this logic is directly in the target function (and not deferred to another component), the function fully meets the constraint as specified.",success,
11016,tls_open_app_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function tls_open_app_data() processes incoming TLS records and does include a check when reading early data—specifically, it verifies that the amount of early data read does not exceed a permitted maximum, and it subsequently updates an early data counter. However, the RFC specification in question mandates that a TLS implementation should not automatically resend early data and should leave any retransmission decisions to the application. There is no logic in this function that controls or triggers any automatic resending of early data. In other words, the function does not implement retransmission behavior at all; its sole focus is on reading and validating incoming record data. Therefore, no part of the function’s code visibly addresses the labeled condition or action implied by the RFC constraint.",success,
11016,tls_open_app_data,"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",272,Fully Matches,"[{'C1': {'code': 'if (type != SSL3_RT_APPLICATION_DATA) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_RECORD);\n    *out_alert = SSL_AD_UNEXPECTED_MESSAGE;\n    return ssl_open_record_error;\n}', 'explanation': 'This code segment checks if the record type is unexpected (i.e. not application data) and accordingly terminates the connection by setting the alert to SSL_AD_UNEXPECTED_MESSAGE, thus fulfilling the spec requirement.'}}]","The provided function inspects the incoming record type. When the record type is not application data, it raises an error with an unexpected_message alert, fully satisfying the spec constraint that demands termination of the connection upon receipt of an unexpected record type.",success,
11019,ssl_send_alert_impl,"Either party MAY initiate a close of its write side of the connection by sending a ""close_notify"" alert.",315,Fully Matches,"[{'C1': {'code': 'if (level == SSL3_AL_WARNING && desc == SSL_AD_CLOSE_NOTIFY) {\n    ssl->s3->write_shutdown = ssl_shutdown_close_notify;\n}', 'explanation': ""This segment directly checks for a 'close_notify' alert (with warning level) and then sets the write shutdown state to graceful close_notify. It implements the RFC requirement that either party MAY initiate a close by sending a close_notify alert.""}}]","The code function implements the logic for initiating a graceful shutdown via a 'close_notify' alert by checking the alert level and description. It prevents a new alert from being sent if the connection is already in a shutdown state, ensuring proper handling as per the RFC. This visible logic within the function alone meets the specified condition.",success,
11019,ssl_send_alert_impl,"Each party MUST send a ""close_notify"" alert before closing its write side of the connection, unless it has already sent some error alert",317,Fully Matches,"[{'C1': {'code': 'if (ssl->s3->write_shutdown != ssl_shutdown_none) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_PROTOCOL_IS_SHUTDOWN);\n    return -1;\n}', 'explanation': 'This check prevents sending an alert if a closing alert has already been sent, ensuring that once any error (or close_notify) has been transmitted, no additional alert is sent. This aligns with the spec requirement to send a close_notify alert unless an error alert has already been sent.'}}, {'A1': {'code': 'if (level == SSL3_AL_WARNING && desc == SSL_AD_CLOSE_NOTIFY) {\n    ssl->s3->write_shutdown = ssl_shutdown_close_notify;\n} else {\n    assert(level == SSL3_AL_FATAL);\n    assert(desc != SSL_AD_CLOSE_NOTIFY);\n    ssl->s3->write_shutdown = ssl_shutdown_error;\n}', 'explanation': 'This branch distinguishes between a proper close_notify alert and an error alert. When a close_notify alert is sent (SSL3_AL_WARNING with SSL_AD_CLOSE_NOTIFY), the state is set accordingly. This directly implements the action of sending a close_notify alert prior to closing the write side, as required by the spec.'}}]","The function explicitly checks that no alert has already been sent before allowing a new alert, and it differentiates between sending a close_notify alert and an error alert by setting the shutdown state accordingly. This behavior visibly addresses the RFC requirement that each party MUST send a close_notify alert before closing its write side, unless an error alert has been sent. The logic for immediately dispatching the alert when possible further reinforces that it is handling the alert sending appropriately within the function itself.",success,
11037,hkdf_extract_to_secret,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Does Not Match,[],"The provided RFC requires that the output of an HKDF_Extract is not reused as an input for another HKDF_Extract without an intervening HKDF_Expand. In the function hkdf_extract_to_secret, the same buffer (hs->secret.data()) is used as both input (salt) and output for HKDF_extract. This shows that the extraction result is potentially being fed back into HKDF_extract directly, violating the intended ordering rule described in the RFC. There is no evidence within the function itself that an HKDF_Expand is applied between HKDF_Extract operations. Therefore, the function does not visibly address the RFC’s specified ordering constraint.",success,
11042,tls13_advance_key_schedule,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Fully Matches,"[{'C1': {'code': 'hkdf_expand_label(Span(hs->secret), hs->transcript.Digest(), hs->secret, kTLS13LabelDerived, Span(derive_context, derive_context_len), SSL_is_dtls(hs->ssl))', 'explanation': 'This call to hkdf_expand_label performs an HKDF-Expand operation between two HKDF-Extract operations. It ensures that an HKDF-Extract output (hs->secret) is not used directly as input to another HKDF-Extract, satisfying the RFC requirement regarding the ordering.'}}]","The function tls13_advance_key_schedule explicitly executes an HKDF-Expand via hkdf_expand_label before proceeding with hkdf_extract_to_secret. This ordering adheres to the RFC specification stating that an output from HKDF-Extract should not be reused as input for another HKDF-Extract without an intermediate HKDF-Expand. All relevant logic to enforce this ordering is contained within the function itself, so the implementation fully meets the given condition.",success,
11043,derive_secret_with_transcript,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Fully Matches,"[{'C1': {'code': 'return hkdf_expand_label(Span(*out), transcript.Digest(), hs->secret, label,\n                           Span(context_hash, context_hash_len),\n                           SSL_is_dtls(hs->ssl));', 'explanation': 'This code calls hkdf_expand_label, which implements the HKDF-Expand step. In accordance with the RFC specification that mandates an HKDF-Expand in between uses of HKDF-Extract outputs, the function explicitly performs the expansion operation. This ensures that an output from a previous HKDF-Extract (embedded in hs->secret or derived transcript.Digest()) is not directly reused as input into another HKDF-Extract without interposing an HKDF-Expand.'}}]","The function 'derive_secret_with_transcript' retrieves a context hash from the transcript and then resizes the output buffer accordingly. Its key operation is the invocation of hkdf_expand_label, which serves as the necessary HKDF-Expand step. This directly aligns with the RFC requirement that an HKDF-Extract output must not be used directly as an input to another HKDF-Extract; instead, an HKDF-Expand must be applied in between. As a result, by directly embedding the HKDF-Expand call, the function fully meets the specified RFC requirement.",success,
11045,tls13_set_traffic_key,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Fully Matches,"[{'C1': {'code': 'if (!hkdf_expand_label(key, digest, traffic_secret, ""key"", {}, is_dtls) ||\n    !hkdf_expand_label(iv, digest, traffic_secret, ""iv"", {}, is_dtls)) {\n  return false;\n}', 'explanation': 'This code clearly uses hkdf_expand_label to derive both the key and IV from the provided traffic_secret. By doing so, it avoids reusing the output of any HKDF-Extract as an input to another extraction. This precisely enforces the required ordering stipulated in the spec.'}}, {'A1': {'code': 'traffic_aead = SSLAEADContext::Create(direction, session->ssl_version, session->cipher, key, {}, iv);', 'explanation': 'After deriving the key and IV using HKDF-Expand, the code immediately uses them to create the AEAD context. This demonstrates that once the proper HKDF-Expand is applied following the extract, the derived material is used directly, complying with the spec’s requirement.'}}]","The function tls13_set_traffic_key correctly implements the required ordering by using hkdf_expand_label to derive key and IV from the traffic_secret, thereby ensuring that an output from HKDF-Extract is not re-used as input for another HKDF-Extract without an intervening HKDF-Expand. The subsequent creation of the AEAD context using these derived values confirms that the function adheres to the specification.",success,
11045,tls13_set_traffic_key,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided RFC specification requires that implementations must not use the Truncated HMAC extension. In the function 'tls13_set_traffic_key', there is no logic that checks for, prevents, or otherwise handles the truncated HMAC extension. The function focuses on setting up the AEAD context and deriving keys for TLS traffic without any mention or safeguard related to the truncated HMAC extension. Therefore, it does not address the RFC constraint within its own logic.",success,
11053,Create,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Fully Matches,"[{'A1': {'code': 'if (!hkdf_expand_label(rne_key, digest, traffic_secret, ""sn"", {},\n                         /*is_dtls=*/true) ||\n      !ret->SetKey(rne_key)) {\n    return nullptr;\n  }', 'explanation': 'The function calls hkdf_expand_label to perform an HKDF-Expand operation on the traffic_secret (presumably the output from a prior HKDF-Extract). This ensures that the output from HKDF-Extract is not directly used in another HKDF-Extract, satisfying the ordering requirement specified in the RFC.'}}]","The code function implements the required ordering from the RFC by explicitly calling hkdf_expand_label. This step guarantees that the output of an HKDF-Extract is not used directly in a subsequent extraction step, but rather is processed through an HKDF-Expand call. As the key derivation logic visible in the function enforces this separation, the function fully meets the RFC constraint.",success,
11054,tls13_derive_early_secret,Implementations MUST NOT combine external PSKs with certificate-based authentication of either the client or the server unless negotiated by some extension.,400,Does Not Match,[],"The provided function, tls13_derive_early_secret, focuses on deriving and logging the early traffic secret based on the transcript (switching for ECH on the client), and does not contain any logic to address or enforce the RFC specification that prohibits combining external PSKs with certificate-based authentication unless a specific extension has been negotiated. There is no condition or check in the function body that verifies whether an external PSK is combined with certificate-based authentication, nor any logic to enforce this restriction. Thus, the function does not visibly address the labeled constraints from the spec.",success,
11056,tls13_derive_application_secrets,Future specifications MUST NOT define a use of exporters that permit both an empty context and no context with the same label.,332,Does Not Match,[],"The provided function does not contain any code that enforces or checks the condition specified by the RFC—that is, preventing the definition of exporters that allow both an empty context and no context with the same label. The function simply derives various secrets (including the exporter secret) using hardcoded labels and logs them, with no logic that verifies context usage or distinguishes between an empty context and a missing context. Therefore, none of the explicitly labeled constraints (C1, A1, etc.) are implemented within this function.",success,
11056,tls13_derive_application_secrets,Implementations MUST NOT combine external PSKs with certificate-based authentication of either the client or the server unless negotiated by some extension.,400,Does Not Match,[],"The provided function tls13_derive_application_secrets solely implements the derivation and logging of TLS 1.3 application traffic secrets and an exporter secret. There is no logic in the function that checks or prevents the combination of external PSKs and certificate-based authentication, as required by the RFC specification. Since the function does not contain any condition checks or mechanisms to enforce the constraint regarding the combination of external PSKs with certificate-based authentication (e.g., no negotiation of an extension is verified), it does not address the labeled spec requirement.",success,
11057,tls13_rotate_traffic_key,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Fully Matches,"[{'C1': {'code': 'return hkdf_expand_label(secret, digest, secret,\n                           kTLS13LabelApplicationTraffic, {},\n                           SSL_is_dtls(ssl)) &&', 'explanation': ""The function uses hkdf_expand_label to perform an HKDF-Expand operation on the current traffic secret. By doing so, it ensures that if the secret originated from a previous HKDF-Extract, it is not being used directly as input to another HKDF-Extract without an intervening HKDF-Expand, which satisfies the RFC's ordering requirement.""}}]","This function retrieves the current traffic secret and then applies an HKDF-Expand operation (via hkdf_expand_label) on it before using the result in further key update operations. This approach conforms to the RFC requirement to insert an HKDF-Expand between successive HKDF-Extract operations, thereby fully addressing the specified constraint.",success,
11059,tls13_verify_data,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided RFC requirement is that the OpenPGP certificate type MUST NOT be used with TLS 1.3. The tls13_verify_data function focuses exclusively on performing a TLS 1.3 finished message verification using HKDF expansion and HMAC. It does not include any logic or checks regarding the certificate type (specifically OpenPGP certificates). There is no examination of the certificate type or logic to prevent the use of an OpenPGP certificate with TLS 1.3 within this function. Therefore, none of the labeled constraints (e.g., C1, A1) that would enforce the restriction are implemented in this code function.",success,
11059,tls13_verify_data,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Fully Matches,"[{'C1': {'code': 'if (!hkdf_expand_label(key, digest, secret, kTLS13LabelFinished, {}, is_dtls) ||\n      HMAC(digest, key.data(), key.size(), context.data(), context.size(), out, &len) == nullptr) {', 'explanation': ""The RFC specifies that one should never use the output of HKDF-Extract as the input to another HKDF-Extract without performing an HKDF-Expand in between. This code calls hkdf_expand_label (an HKDF-Expand function) on the 'secret' before using the resulting key in HMAC. This ensures the proper ordering as required by the RFC.""}}]","The function implements the required ordering by applying an HKDF-Expand (via hkdf_expand_label) on the provided secret before using it in the HMAC calculation. There is no instance where an HKDF-Extract output is reused as input to another HKDF-Extract without an intervening HKDF-Expand. Thus, within the function_body, the RFC condition is fully addressed.",success,
11061,tls13_derive_session_psk,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Fully Matches,"[{'C1': {'code': 'return hkdf_expand_label(Span(session->secret), digest, session->secret, kTLS13LabelResumptionPSK, nonce, is_dtls);', 'explanation': 'This call to hkdf_expand_label ensures that the output from the prior HKDF-Extract (stored in session->secret) is not directly reused in another HKDF-Extract. Instead, it is passed through an HKDF-Expand operation as required by the RFC specification.'}}]","The function implements the required ordering as specified in the RFC by explicitly invoking an HKDF-Expand (via hkdf_expand_label) on the output of an earlier HKDF-Extract. By doing so, it guarantees that the extracted secret is properly transformed before further use, thus satisfying the constraint that an HKDF-Extract output should not be used directly as input for another HKDF-Extract without an intervening HKDF-Expand.",success,
11062,tls13_export_keying_material,Future specifications MUST NOT define a use of exporters that permit both an empty context and no context with the same label.,332,Does Not Match,[],"The provided function does not include any explicit logic for checking or enforcing the RFC specification that prohibits exporters from permitting both an empty context and no context with the same label. There is no conditional check or validation regarding the use of an empty context relative to the label within the function. While the function processes the 'context' parameter by computing its digest, it does not distinguish or enforce requirements against using an empty context. Therefore, the function does not visibly implement the given spec constraint.",success,
11062,tls13_export_keying_material,Implementations MUST NOT combine external PSKs with certificate-based authentication of either the client or the server unless negotiated by some extension.,400,Does Not Match,[],"The RFC specification requires that implementations must not combine external PSKs with certificate-based authentication unless negotiated by some extension. There is no indication anywhere in the function tls13_export_keying_material that addresses this requirement. The function focuses on exporting keying material via HKDF expansion and does not include any logic for checking or enforcing the separation of PSKs and certificate-based authentication. Therefore, the function does not visibly implement the specified RFC constraint.",success,
11063,tls13_psk_binder,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Fully Matches,"[{'C1': {'code': 'if (!HKDF_extract(early_secret, &early_secret_len, digest,\n                    session->secret.data(), session->secret.size(), nullptr,\n                    0) ||\n      !hkdf_expand_label(binder_key, digest,\n                         Span(early_secret, early_secret_len),\n                         kTLS13LabelPSKBinder,\n                         Span(binder_context, binder_context_len), is_dtls)) {\n    return false;\n  }', 'explanation': 'The code first performs an HKDF-Extract to derive an early secret, and then immediately uses that secret as input to hkdf_expand_label (HKDF-Expand), which complies with the RFC constraint that prohibits using the output of an HKDF-Extract directly as input to another HKDF-Extract without interposing an HKDF-Expand.'}}]","The function implements the binder key calculation for TLS 1.3 by correctly ordering the HKDF operations in accordance with the spec. It extracts an early secret via HKDF_Extract and then properly expands that secret with HKDF-Expand via hkdf_expand_label, thereby fully addressing the specified ordering requirement within the function itself.",success,
11065,tls13_verify_psk_binder,"Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value (see Section 4.2.11.2 below).",165,Fully Matches,"[{'C1': {'code': 'if (!tls13_psk_binder(verify_data, &verify_data_len, session, hs->transcript,\n                        msg.raw, 2 + CBS_len(binders), SSL_is_dtls(hs->ssl)) ||\n      !CBS_get_u8_length_prefixed(binders, &binder)) {\n    OPENSSL_PUT_ERROR(SSL, ERR_R_INTERNAL_ERROR);\n    return false;\n  }', 'explanation': 'This segment first computes the expected binder value and then extracts the binder from the message, establishing the necessary precondition for validating the PSK binder as required by the spec.'}}, {'A1': {'code': 'bool binder_ok =\n      CBS_len(&binder) == verify_data_len &&\n      CRYPTO_memcmp(CBS_data(&binder), verify_data, verify_data_len) == 0;\n...\nif (!binder_ok) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DIGEST_CHECK_FAILED);\n    return false;\n  }', 'explanation': 'This code performs the actual validation by comparing the computed binder with the extracted binder, which directly implements the requirement to validate the binder value prior to accepting the PSK key establishment.'}}]","The function clearly implements the binder validation process by first computing the expected binder value and then comparing it with the binder received in the message. This check ensures that the binder is valid before proceeding with PSK key establishment, directly addressing the RFC requirement.",success,
11065,tls13_verify_psk_binder,"Servers SHOULD NOT attempt to validate multiple binders; rather, they SHOULD select a single PSK and validate solely the binder that corresponds to that PSK.",167,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u8_length_prefixed(binders, &binder)) { ... }\n\nbool binder_ok = CBS_len(&binder) == verify_data_len &&\n                  CRYPTO_memcmp(CBS_data(&binder), verify_data, verify_data_len) == 0;', 'explanation': 'The RFC specifies that servers should select and validate a single binder corresponding to the chosen PSK, and not attempt to validate multiple binders. The code explicitly extracts only the first binder using CBS_get_u8_length_prefixed and compares it against the computed PSK binder. This confirms that only a single PSK binder is being validated, which fully implements the spec constraint.'}}]","The function tls13_verify_psk_binder adheres to the RFC requirement by explicitly selecting and validating only the first binder provided. The logic clearly ensures that only the binder corresponding to the PSK is used in the verification process, without checking subsequent binders, thereby fully meeting the constraint outlined in the specification.",success,
11067,ssl_ech_accept_confirmation,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Fully Matches,"[{'C1': {'code': 'if (!HKDF_extract(secret, &secret_len, transcript.Digest(),\n                    client_random.data(), client_random.size(), kZeros,\n                    transcript.DigestLen())) {\n    return false;\n}\n...\nreturn hkdf_expand_label(\n    out, transcript.Digest(), Span(secret, secret_len),\n    is_hrr ? ""hrr ech accept confirmation"" : ""ech accept confirmation"",\n    Span(context, context_len), SSL_is_dtls(hs->ssl));', 'explanation': ""The RFC specifies that one should not use the output of HKDF-Extract directly as an input for another HKDF-Extract without an intervening HKDF-Expand. This function first calls HKDF_extract to derive 'secret' and then immediately passes that output to hkdf_expand_label (which performs the HKDF-Expand operation). This ordering fully complies with the constraint.""}}]","The function implements the specific ordering required by the RFC. It first computes the extraction step using HKDF_extract and then uses the result in a subsequent HKDF-Expand via hkdf_expand_label. Thus, the function does not violate the constraint against using a HKDF-Extract output as input to another HKDF-Extract without an HKDF-Expand in between. All logic addressing the ordering is directly contained within the function.",success,
11069,negotiate_version,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function 'negotiate_version' is solely focused on negotiating protocol versions and handling fallback scenarios. It does not contain any logic related to the RFC requirement that TLS 1.3 servers MUST NOT process or send the status_request_v2 extension in their responses. Hence, no code segments address the status_request_v2 constraint as specified by the RFC.",success,
11069,negotiate_version,"The server MUST NOT send a ""psk_key_exchange_modes"" extension.",140,Does Not Match,[],"The RFC specification requires that the server must not send a 'psk_key_exchange_modes' extension. However, the provided function handles version negotiation and processes the 'supported_versions' extension from the client hello message. It does not include any logic that relates to or prevents sending a 'psk_key_exchange_modes' extension. Therefore, there is no code within this function that addresses the specified RFC constraint.",success,
11069,negotiate_version,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification requires that implementations must not use the Truncated HMAC extension. The provided code function 'negotiate_version' is solely concerned with negotiating TLS and DTLS versions and handling the FALLBACK_SCSV mechanism. There is no logic within this function that checks for or prevents the usage of the Truncated HMAC extension, nor does it otherwise reference truncated HMAC. As such, none of the labeled conditions or actions from the spec constraints are addressed in the function.",success,
11069,negotiate_version,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The RFC specification requires that SSL 2.0 MUST NOT be negotiated, implying that any function implementing this RFC must explicitly reject or prevent SSL 2.0. In the provided function_body, although version negotiation logic is implemented, there is no explicit check for SSL 2.0 (or any similar condition) to ensure that it is not accepted. All version negotiation logic focuses on TLS and DTLS versions, and no code segment within this function explicitly prevents SSL 2.0 negotiation. Therefore, the function does not visibly address the RFC constraint.",success,
11069,negotiate_version,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites. In the provided function, there is no code segment that checks for or prevents the use of RC4. The function is focused on negotiating TLS/DTLS versions and handling FALLBACK_SCSV, but it does not implement any logic that disallows RC4 cipher suites. Therefore, within this function's body, the RFC constraint is not addressed at all.",success,
11069,negotiate_version,"If the ""supported_versions"" extension is present, the server MUST negotiate using that extension as described in Section 4.2.1.",380,Fully Matches,"[{'C1': {'code': 'if (ssl_client_hello_get_extension(client_hello, &supported_versions, TLSEXT_TYPE_supported_versions)) {\n    if (!CBS_get_u8_length_prefixed(&supported_versions, &versions) ||\n        CBS_len(&supported_versions) != 0 ||\n        CBS_len(&versions) == 0) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n      *out_alert = SSL_AD_DECODE_ERROR;\n      return false;\n    }\n} else { ... }', 'explanation': 'The code checks for the presence of the supported_versions extension. If found, it parses the extension according to length‐prefixed encoding and verifies that its contents are well formed. This corresponds directly to the specification’s condition that mandates negotiation using the supported_versions extension if present.'}}, {'A1': {'code': 'if (!ssl_negotiate_version(hs, out_alert, &ssl->s3->version, &versions)) {\n    return false;\n}', 'explanation': 'After obtaining and validating the supported_versions data (or emulating it when missing), the code calls ssl_negotiate_version to perform the actual version negotiation. This action complies with the RFC requirement to negotiate using the extension as described in Section 4.2.1.'}}]","The function explicitly handles the supported_versions extension as required by the RFC. It checks for the extension’s presence (fulfilling condition C1) and then processes and negotiates the TLS version (fulfilling action A1). The implementation in function_body covers both the retrieval and use of the extension, thereby fully addressing the spec requirement.",success,
11069,negotiate_version,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!CBS_get_u8_length_prefixed(&supported_versions, &versions) ||  \n        CBS_len(&supported_versions) != 0 ||                            \n        CBS_len(&versions) == 0) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n      *out_alert = SSL_AD_DECODE_ERROR;\n      return false;\n    }', 'explanation': 'This segment checks for parsing errors (e.g., length issues) in the supported_versions extension of the ClientHello message. If any parsing issue is detected, it sets the out_alert to SSL_AD_DECODE_ERROR and aborts the handshake, which corresponds to the requirement that a decode_error alert be sent when a message is not parsed correctly.'}}, {'A1': {'code': '*out_alert = SSL_AD_DECODE_ERROR;', 'explanation': 'This line ensures that upon detecting a parsing error, the function sets the alert to decode_error, thereby triggering termination of the connection as specified.'}}]","The provided function implements logic to detect parsing errors (such as incorrect length fields in the supported_versions extension) and to respond by setting a decode_error alert and aborting the handshake. This addresses the spec constraint that peers receiving an unparsable message must terminate the connection with a decode_error alert. However, although the function correctly applies this behavior for the TLS handshake, it does not address the complete context of the HTTP/1.1 persistent connection behavior described in the specification context. As such, while the code meets the key condition regarding parse errors, it only partially matches the overall RFC requirements as provided.",success,
11069,negotiate_version,"If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later.",65,Fully Matches,"[{'C1': {'code': 'if (ssl_client_hello_get_extension(client_hello, &supported_versions, TLSEXT_TYPE_supported_versions)) { ... } else {\n    // Convert the ClientHello version to an equivalent supported_versions extension.\n    static const uint8_t kTLSVersions[] = {\n        0x03, 0x03,  // TLS 1.2\n        0x03, 0x02,  // TLS 1.1\n        0x03, 0x01,  // TLS 1.0\n    };\n    ...\n    if (client_hello->version >= TLS1_2_VERSION) {\n        versions_len = 6;\n    } else if (client_hello->version >= TLS1_1_VERSION) {\n        versions_len = 4;\n    } else if (client_hello->version >= TLS1_VERSION) {\n        versions_len = 2;\n    }\n    versions = Span(kTLSVersions).last(versions_len);\n}', 'explanation': 'This branch handles the case when the supported_versions extension is not present. It converts the legacy ClientHello version into a supported_versions list that only includes TLS 1.2 or lower, in accordance with the RFC requirement.'}}, {'A1': {'code': 'if (!ssl_negotiate_version(hs, out_alert, &ssl->s3->version, &versions)) {\n    return false;\n}', 'explanation': 'This call negotiates the actual protocol version using the derived versions list, thereby ensuring the connection will use TLS 1.2 or an earlier version as mandated by the specification, even if the legacy version (such as 0x0304) is provided.'}}]","The function 'negotiate_version' checks whether the supported_versions extension is present. If it is absent, it manually converts the ClientHello legacy version into an equivalent supported_versions list that only contains TLS 1.2, TLS 1.1, and TLS 1.0. This directly addresses the RFC requirement that servers supporting TLS 1.2 must negotiate TLS 1.2 or prior, even if the ClientHello.legacy_version is higher. The subsequent call to ssl_negotiate_version() finalizes the negotiation based on the selected versions.",success,
11069,negotiate_version,"If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the ""supported_versions"" extension to determine client preferences.",67,Fully Matches,"[{'C1': {'code': 'if (ssl_client_hello_get_extension(client_hello, &supported_versions, TLSEXT_TYPE_supported_versions)) {\n    if (!CBS_get_u8_length_prefixed(&supported_versions, &versions) ||  \n        CBS_len(&supported_versions) != 0 ||\n        CBS_len(&versions) == 0) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n      *out_alert = SSL_AD_DECODE_ERROR;\n      return false;\n    }\n  }', 'explanation': 'This section checks whether the supported_versions extension is present in the ClientHello. When it is present, the function extracts and uses only this extension to negotiate the version. This behavior adheres to the requirement that if the extension is present, the legacy_version value must not be used at all for negotiation.'}}, {'A1': {'code': '// Convert the ClientHello version to an equivalent supported_versions extension.\nstatic const uint8_t kTLSVersions[] = {\n    0x03, 0x03,  // TLS 1.2\n    0x03, 0x02,  // TLS 1.1\n    0x03, 0x01,  // TLS 1\n};\n\nstatic const uint8_t kDTLSVersions[] = {\n    0xfe, 0xfd,  // DTLS 1.2\n    0xfe, 0xff,  // DTLS 1.0\n};\n\nif (!ssl_client_hello_get_extension(client_hello, &supported_versions, TLSEXT_TYPE_supported_versions)) {\n  size_t versions_len = 0;\n  if (SSL_is_dtls(ssl)) {\n    if (client_hello->version <= DTLS1_2_VERSION) {\n      versions_len = 4;\n    } else if (client_hello->version <= DTLS1_VERSION) {\n      versions_len = 2;\n    }\n    versions = Span(kDTLSVersions).last(versions_len);\n  } else {\n    if (client_hello->version >= TLS1_2_VERSION) {\n      versions_len = 6;\n    } else if (client_hello->version >= TLS1_1_VERSION) {\n      versions_len = 4;\n    } else if (client_hello->version >= TLS1_VERSION) {\n      versions_len = 2;\n    }\n    versions = Span(kTLSVersions).last(versions_len);\n  }\n}', 'explanation': ""In the absence of the supported_versions extension, this block converts the ClientHello's legacy version into an equivalent supported_versions extension format. This ensures that when the extension is missing, the function still determines the client version preferences in a consistent manner.""}}]","The negotiate_version function implements the specified RFC requirement regarding TLS version negotiation. It ensures that if the supported_versions extension is present in the ClientHello, it is used exclusively for version negotiation and the legacy_version value is not consulted. Additionally, when the extension is absent, it converts the legacy version value into a supported_versions format. This direct handling within the function fully meets the RFC constraints provided.",success,
11069,negotiate_version,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Partially Matches,"[{'C1': {'code': 'if (!CBS_get_u8_length_prefixed(&supported_versions, &versions) ||  \n        CBS_len(&supported_versions) != 0 ||                            \n        CBS_len(&versions) == 0) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n      *out_alert = SSL_AD_DECODE_ERROR;\n      return false;\n    }', 'explanation': 'This code segment checks that the supported_versions extension is correctly formatted. If the extension fails to decode properly or contains extra/unexpected data, the handshake is aborted with a decode_error alert, satisfying the spec’s requirement to abort the handshake with a ""decode_error"" alert when conditions are not met.'}}]","The provided function implements a check on the format of the supported_versions extension and aborts the handshake with a decode_error alert when the extension is malformed. This corresponds to the specified behavior in the RFC requirement that, if the conditions are not met, the handshake MUST be aborted with a decode_error alert. However, the rest of the spec context—involving aspects like case-insensitive matching of protocol names and HTTP upgrade header processing—is not addressed within this function. Therefore, while one of the key conditions (C1) is implemented, the function does not cover the complete scope of the provided RFC specification, leading to a partially matching outcome.",success,
11069,negotiate_version,Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.,70,Fully Matches,"[{'C1': {'code': 'if (ssl_client_hello_get_extension(client_hello, &supported_versions, TLSEXT_TYPE_supported_versions)) {\n    if (!CBS_get_u8_length_prefixed(&supported_versions, &versions) ||\n        CBS_len(&supported_versions) != 0 ||\n        CBS_len(&versions) == 0) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n      *out_alert = SSL_AD_DECODE_ERROR;\n      return false;\n    }\n  } else {\n    // Convert the ClientHello version to an equivalent supported_versions\n    // extension.\n    static const uint8_t kTLSVersions[] = {\n        0x03, 0x03,  // TLS 1.2\n        0x03, 0x02,  // TLS 1.1\n        0x03, 0x01,  // TLS 1.0\n    };\n\n    ...\n    versions = Span(kTLSVersions).last(versions_len);\n  }', 'explanation': 'This segment inspects whether the ClientHello includes the supported_versions extension. It validates its content without assuming that TLS 1.3 (0x0304) is necessarily present. Thus, the server is prepared to process a ClientHello that includes the extension but omits 0x0304, exactly as required by the RFC.'}}]","The function 'negotiate_version' explicitly checks for the presence of the supported_versions extension in the ClientHello and validates its content. In the absence of the extension, it synthesizes an equivalent list based on the ClientHello version. This design confirms that the function is prepared to handle cases where the extension is present yet does not include TLS 1.3 (0x0304), thereby fulfilling the RFC requirement.",success,
11069,negotiate_version,"Clients MUST NOT act upon any information found in ""supported_groups"" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their ""key_share"" extension in subsequent connections.",116,Does Not Match,[],"The provided function 'negotiate_version' only deals with negotiating the TLS/DTLS version and handling fallback cipher validation. It does not contain any logic concerning 'supported_groups' or the processing of 'key_share' extensions as described in the RFC specification, nor does it involve the evaluation of an If-Unmodified-Since header field condition as outlined in the specification context. In isolation, this function does not address any of the labeled conditions (e.g., C1) or actions (e.g., A1) from the spec constraints.",success,
11069,negotiate_version,Servers MUST NOT send this extension.,115,Does Not Match,[],"The provided function is concerned primarily with negotiating the TLS/DTLS version and handling fallback SCSV during the handshake. There is no logic within the function that addresses the RFC specification stating that ""Servers MUST NOT send this extension."" In particular, there is no code that checks for the presence of an extension that should not be sent, nor does it prevent the server from sending any such extension. As a result, the function does not attempt to enforce or implement the specified HTTP RFC constraint.",success,
11069,negotiate_version,-TLS 1.2 ClientHellos MAY omit this extension.,99,Fully Matches,"[{'C1': {'code': 'if (ssl_client_hello_get_extension(client_hello, &supported_versions, TLSEXT_TYPE_supported_versions)) {\n    if (!CBS_get_u8_length_prefixed(&supported_versions, &versions) ||\n        CBS_len(&supported_versions) != 0 ||\n        CBS_len(&versions) == 0) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n      *out_alert = SSL_AD_DECODE_ERROR;\n      return false;\n    }\n} else {\n    // Convert the ClientHello version to an equivalent supported_versions extension.\n    static const uint8_t kTLSVersions[] = {\n        0x03, 0x03,  // TLS 1.2\n        0x03, 0x02,  // TLS 1.1\n        0x03, 0x01,  // TLS 1\n    };\n\n    static const uint8_t kDTLSVersions[] = {\n        0xfe, 0xfd,  // DTLS 1.2\n        0xfe, 0xff,  // DTLS 1.0\n    };\n\n    size_t versions_len = 0;\n    if (SSL_is_dtls(ssl)) {\n      if (client_hello->version <= DTLS1_2_VERSION) {\n        versions_len = 4;\n      } else if (client_hello->version <= DTLS1_VERSION) {\n        versions_len = 2;\n      }\n      versions = Span(kDTLSVersions).last(versions_len);\n    } else {\n      if (client_hello->version >= TLS1_2_VERSION) {\n        versions_len = 6;\n      } else if (client_hello->version >= TLS1_1_VERSION) {\n        versions_len = 4;\n      } else if (client_hello->version >= TLS1_VERSION) {\n        versions_len = 2;\n      }\n      versions = Span(kTLSVersions).last(versions_len);\n    }\n}', 'explanation': ""The code checks whether the ClientHello message includes the supported_versions extension. If the extension is omitted (which is allowed for TLS 1.2), the function converts the ClientHello version into a default list of supported versions according to the protocol's specifications. This directly implements the RFC requirement that TLS 1.2 ClientHellos MAY omit this extension.""}}]","The function 'negotiate_version' explicitly handles both the presence and absence of the supported_versions extension in the ClientHello. In the absence of the extension, it constructs a default_versions list based on the client_hello->version, which is precisely what the TLS 1.2 RFC requires when a ClientHello omits the extension. Thus, the function fully matches the specified constraint.",success,
11075,is_probably_jdk11_with_tls13,"The ""signature_algorithms"" extension MUST be specified, and other extensions may optionally be included if defined for this message.",182,Partially Matches,"[{'C1': {'code': 'constexpr struct { uint16_t id; bool required; } kJavaExtensions[] = {\n    ...\n    {TLSEXT_TYPE_signature_algorithms, true},\n    ...\n};\n\n...\ncase TLSEXT_TYPE_signature_algorithms:\n  sigalgs = body;\n  break;', 'explanation': ""The code explicitly requires that the 'signature_algorithms' extension is present by marking it as required in the kJavaExtensions[] array and checking for it during parsing. If missing, the function returns false. This satisfies the condition from the spec that the 'signature_algorithms' extension MUST be specified.""}}]","The function inspects a TLS ClientHello message to verify a set of expected extensions in a specific order, and explicitly enforces the requirement for the 'signature_algorithms' extension. However, it does not address other aspects of the RFC or the additional HTTP proxy and origin server behavior described in the spec context. Therefore, only one of the conditions (C1 regarding the 'signature_algorithms' extension) is visibly implemented in this function, resulting in a 'Partially Matches' outcome.",success,
11075,is_probably_jdk11_with_tls13,"-If containing a ""supported_groups"" extension, it MUST also contain a ""key_share"" extension, and vice versa.",349,Fully Matches,"[{'C1': {'code': 'static constexpr struct {\n    uint16_t id;\n    bool required;\n} kJavaExtensions[] = {\n    {TLSEXT_TYPE_server_name, false},\n    {kMaxFragmentLength, false},\n    {TLSEXT_TYPE_status_request, false},\n    {TLSEXT_TYPE_supported_groups, true},\n    {TLSEXT_TYPE_ec_point_formats, false},\n    {TLSEXT_TYPE_signature_algorithms, true},\n    {TLSEXT_TYPE_signature_algorithms_cert, true},\n    {TLSEXT_TYPE_application_layer_protocol_negotiation, false},\n    {kStatusRequestV2, false},\n    {TLSEXT_TYPE_extended_master_secret, false},\n    {TLSEXT_TYPE_supported_versions, true},\n    {TLSEXT_TYPE_cookie, false},\n    {TLSEXT_TYPE_psk_key_exchange_modes, true},\n    {TLSEXT_TYPE_key_share, true},\n    {TLSEXT_TYPE_renegotiate, false},\n    {TLSEXT_TYPE_pre_shared_key, false},\n};', 'explanation': ""The function defines an ordered list of expected TLS extensions where both 'supported_groups' and 'key_share' are marked as required (true). The subsequent loop iterates through these expected extensions, returning false if a required extension is missing. This logic directly enforces the RFC specification that if one ('supported_groups' or 'key_share') is present, the other must also be present.""}}]","The function 'is_probably_jdk11_with_tls13' explicitly checks for a fixed order of TLS extensions defined in the kJavaExtensions array, where both 'supported_groups' and 'key_share' are marked as required. This means that the function will only return true if both extensions are present in the client hello, thereby fully implementing the RFC requirement that these two extensions must coexist.",success,
11075,is_probably_jdk11_with_tls13,"Clients which desire the server to authenticate itself via a certificate MUST send the ""signature_algorithms"" extension.",82,Partially Matches,"[{'C1': {'code': 'constexpr uint16_t kMaxFragmentLength = 0x0001;\nconstexpr uint16_t kStatusRequestV2 = 0x0011;\nstatic constexpr struct {\n  uint16_t id;\n  bool required;\n} kJavaExtensions[] = {\n  {TLSEXT_TYPE_server_name, false},\n  {kMaxFragmentLength, false},\n  {TLSEXT_TYPE_status_request, false},\n  {TLSEXT_TYPE_supported_groups, true},\n  {TLSEXT_TYPE_ec_point_formats, false},\n  {TLSEXT_TYPE_signature_algorithms, true},\n  {TLSEXT_TYPE_signature_algorithms_cert, true},\n  {TLSEXT_TYPE_application_layer_protocol_negotiation, false},\n  {kStatusRequestV2, false},\n  {TLSEXT_TYPE_extended_master_secret, false},\n  {TLSEXT_TYPE_supported_versions, true},\n  {TLSEXT_TYPE_cookie, false},\n  {TLSEXT_TYPE_psk_key_exchange_modes, true},\n  {TLSEXT_TYPE_key_share, true},\n  {TLSEXT_TYPE_renegotiate, false},\n  {TLSEXT_TYPE_pre_shared_key, false},\n};\n...\ncase TLSEXT_TYPE_signature_algorithms:\n  sigalgs = body;\n...\nif (sigalgs != sigalgs_cert || ... ) {\n  return false;\n}', 'explanation': ""The RFC specifies that clients which desire the server to authenticate via a certificate MUST send the 'signature_algorithms' extension. In this function the kJavaExtensions array includes TLSEXT_TYPE_signature_algorithms as required, and later the logic retrieves its body. This demonstrates that the function checks for the presence of the signature_algorithms extension, thereby partially meeting the specification constraint.""}}]","The function inspects the client's hello message to verify a fixed ordering and presence of several TLS extensions expected from JDK 11, including the required signature_algorithms extension. By iterating through an expected sequence (with the signature_algorithms extension marked as required) and validating its contents, the function addresses the spec constraint that clients intending server certificate authentication must include the extension. However, because the function also performs other JDK 11–specific checks and does not implement the entirety of the certificate authentication process defined in the RFC, it only partially matches the RFC specification.",success,
11076,decrypt_ech,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u8(&body, &type)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n  }\n  \n  ...\n  if (!CBS_get_u16(&body, &kdf_id) ||\n      !CBS_get_u16(&body, &aead_id) ||\n      !CBS_get_u8(&body, &config_id) ||\n      !CBS_get_u16_length_prefixed(&body, &enc) ||\n      !CBS_get_u16_length_prefixed(&body, &payload) ||\n      CBS_len(&body) != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n  }', 'explanation': 'The code explicitly checks that the message is correctly parsed. If any required element is missing or if extra data is present (i.e., parse errors occur), it sets the decode_error alert (SSL_AD_DECODE_ERROR) and terminates further processing by returning false, which aligns with the RFC specification requirement.'}}]","The function 'decrypt_ech' processes the encrypted client hello message and performs strict parsing of its fields. When the message does not conform to the expected syntax (e.g., a missing field or extra bytes), it sets a decode_error alert and returns false to terminate the connection, as mandated by the RFC. Thus, the code function visibly addresses the spec constraint regarding handling of unparseable messages by itself.",success,
11076,decrypt_ech,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS. The provided function 'decrypt_ech' is solely responsible for decrypting the ECH (Encrypted ClientHello) extension and does not contain any logic related to cipher suite selection, negotiation, or any explicit handling or blocking of RC4. Therefore, no part of this function addresses the specified RFC constraint.",success,
11076,decrypt_ech,"-A server receiving a ClientHello MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters",358,Partially Matches,"[{'C1': {'code': 'if (!ssl_client_hello_get_extension(client_hello, &body, TLSEXT_TYPE_encrypted_client_hello)) {\n    return true;\n}\n...\nif (type != ECH_CLIENT_OUTER) {\n    return true;\n}', 'explanation': 'The code explicitly checks for the presence of the ECH extension and its expected type. If the extension is missing or its type is not ECH_CLIENT_OUTER, the function returns true, effectively ignoring the unrecognized extension. This partially implements the requirement to ignore unrecognized parameters as specified in the RFC. However, the full RFC requirement also covers unrecognized cipher suites and other parameters, which are not addressed by this function.'}}]","The decrypt_ech function deals specifically with the ECH extension by checking for its presence and verifying its type. When the extension is not present or does not match the expected type (ECH_CLIENT_OUTER), it simply returns a success code (true), effectively ignoring unrecognized data within the ECH context. This directly aligns with part of the RFC specification about ignoring unrecognized extensions. Nevertheless, the RFC also mandates that unrecognized cipher suites and other parameters be ignored—a requirement that is not handled within this function. Therefore, the function only partially matches the full RFC requirement.",success,
11076,decrypt_ech,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Does Not Match,[],"The provided function is responsible for processing and decrypting the Encrypted ClientHello (ECH) extension during a TLS handshake. It checks for proper formatting and returns a decode_error alert when it encounters malformed fields. However, the RFC specification provided in the input is related to HTTP protocol upgrade handling (e.g., sending a 101 Switching Protocols response and managing the Upgrade header) and explicitly states that if a condition is not met, the handshake MUST abort with a 'decode_error' alert. The code in this function does not address any HTTP upgrade or protocol negotiation logic, nor does it manage the Upgrade header as required by the HTTP RFC specification. Therefore, the function does not implement the specified HTTP RFC constraints.",success,
11076,decrypt_ech,-TLS 1.2 ClientHellos MAY omit this extension.,99,Does Not Match,[],"The provided code function implements the decryption of an Encrypted ClientHello (ECH) in a TLS handshake. While it does check for the presence of an ECH extension and returns successfully if the extension is absent (which superficially aligns with the concept that TLS 1.2 ClientHellos may omit the extension), the specification context provided concerns evaluating an HTTP If‐Match header field. None of the labeled conditions or actions (such as evaluating entity tags, returning a 412 status, or even handling state‐changing operations) from the HTTP RFC are implemented within this function. The logic in the function only pertains to TLS ECH decryption and does not address the HTTP RFC conditions. Therefore, no constraint from the given HTTP RFC (including any that might be labeled C1, A1, etc.) is visibly or fully implemented in this function.",success,
11077,extract_sni,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16_length_prefixed(&sni, &server_name_list) ||  \n      !CBS_get_u8(&server_name_list, &name_type) ||             \n      !CBS_get_u16_length_prefixed(&server_name_list, &host_name) ||  \n      CBS_len(&server_name_list) != 0 ||                              \n      CBS_len(&sni) != 0) {', 'explanation': 'This segment checks that the SNI extension has exactly the expected structure and content. If any component of the parsing fails or if extra bytes are found, it indicates a malformed extension, fulfilling the condition that improper formatting aborts the handshake.'}}, {'A1': {'code': '*out_alert = SSL_AD_DECODE_ERROR;\nreturn false;', 'explanation': ""This code sets the alert to 'decode_error' and aborts the handshake if the SNI extension fails validation, directly implementing the requirement in the RFC specification.""}}]","The function 'extract_sni' implements the RFC requirement by validating the structure of the SNI extension from the ClientHello message. It verifies that the extension is correctly formatted and, if not, sets the alert value to SSL_AD_DECODE_ERROR and aborts the process. This directly corresponds to the spec which mandates that if the SNI extension is not valid, the handshake is aborted with a 'decode_error' alert.",success,
11077,extract_sni,"Additionally, all implementations MUST support the use of the ""server_name"" extension with applications capable of using it",351,Fully Matches,"[{'C1': {'code': 'if (!ssl_client_hello_get_extension(client_hello, &sni, TLSEXT_TYPE_server_name)) {\n    // No SNI extension to parse.\n    ssl->s3->hostname.reset();\n    return true;\n}', 'explanation': 'This segment demonstrates that the function explicitly checks for the server_name extension as required by the RFC. If absent, it resets any previously set state, thereby indicating support (or proper handling) of the extension as per the requirement.'}}, {'A1': {'code': 'if (!CBS_get_u16_length_prefixed(&sni, &server_name_list) ||\n    !CBS_get_u8(&server_name_list, &name_type) ||\n    !CBS_get_u16_length_prefixed(&server_name_list, &host_name) ||\n    CBS_len(&server_name_list) != 0 ||\n    CBS_len(&sni) != 0) {\n  *out_alert = SSL_AD_DECODE_ERROR;\n  return false;\n}\n\nif (name_type != TLSEXT_NAMETYPE_host_name ||\n    CBS_len(&host_name) == 0 ||\n    CBS_len(&host_name) > TLSEXT_MAXLEN_host_name ||\n    CBS_contains_zero_byte(&host_name)) {\n  *out_alert = SSL_AD_UNRECOGNIZED_NAME;\n  return false;\n}\n\nchar *raw = nullptr;\nif (!CBS_strdup(&host_name, &raw)) {\n  *out_alert = SSL_AD_INTERNAL_ERROR;\n  return false;\n}\nssl->s3->hostname.reset(raw);', 'explanation': 'This code parses, validates, and extracts the server name (SNI) from the ClientHello message. It ensures that the hostname provided is of the correct type and within valid length limits, and then assigns it to the internal state. This behavior directly supports the RFC’s mandate to support the server_name extension.'}}]","The function 'extract_sni' fully implements the processing of the server_name (SNI) extension as specified by the RFC. It first checks for the extension, handles its absence properly by resetting previous state, and then validates and extracts the hostname when present. This logic within the function directly addresses the requirement to support 'server_name' extensions, fulfilling both the conditional (C1) and action (A1) aspects of the spec.",success,
11077,extract_sni,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16_length_prefixed(&sni, &server_name_list) ||\n      !CBS_get_u8(&server_name_list, &name_type) ||\n      !CBS_get_u16_length_prefixed(&server_name_list, &host_name) ||\n      CBS_len(&server_name_list) != 0 ||\n      CBS_len(&sni) != 0) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    return false;\n}', 'explanation': ""This code block checks for syntax errors (e.g. invalid length fields or extra data) in the SNI extension. If any check fails, it sets the 'decode_error' alert and returns false, thereby addressing the RFC requirement that a malformed message must result in termination with a decode_error alert.""}}]","The function 'extract_sni' implements the RFC requirement by performing detailed parsing of the SNI extension. It validates lengths and structure, and if any parsing error is detected, it sets the decode_error alert (and also handles additional error conditions for unrecognized names) before returning false. This behavior matches the specified condition to terminate the connection upon receiving an unparseable message.",success,
11078,do_read_client_hello,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function focuses on reading and parsing the ClientHello message (including aspects like ECH and SNI extraction) and does not include any logic that addresses the RFC specification requirement. In particular, it does not contain any code that ignores or suppresses processing of the status_request_v2 extension, nor does it implement any behavior to ensure that TLS 1.3 servers do not act on this extension when generating the EncryptedExtensions, CertificateRequest, or Certificate messages. As such, no visible implementation exists within this function for the specified constraints.",success,
11078,do_read_client_hello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!SSL_parse_client_hello(ssl, &client_hello, CBS_data(&msg.body),\n                              CBS_len(&msg.body))) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    return ssl_hs_error;\n}', 'explanation': 'This code checks whether the ClientHello message can be parsed. If not, it directly handles the error path, which is required when a message cannot be parsed due to syntax issues.'}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);', 'explanation': ""When parsing fails, the function sends an alert with the 'decode_error' code as mandated by the RFC.""}}]","The RFC requires that if a message cannot be parsed according to its syntax — for example, due to an out‐of‐range length or exceeding the message boundary — the connection should be terminated with a 'decode_error' alert. The function implements this behavior directly within its code by checking if the parse failed and, if so, calling ssl_send_alert with SSL_AD_DECODE_ERROR before terminating the handshake. Therefore, the function visibly addresses the required condition and action.",success,
11078,do_read_client_hello,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Fully Matches,"[{'C1': {'code': 'if (ssl->method->has_unprocessed_handshake_data(ssl)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);\n    OPENSSL_PUT_ERROR(SSL, SSL_R_EXCESS_HANDSHAKE_DATA);\n    return ssl_hs_error;\n  }', 'explanation': ""This code segment checks if there is any unprocessed handshake data (indicating that a handshake message was received in an unexpected order) and aborts the handshake by sending an 'unexpected_message' alert, which directly implements the requirement.""}}]","The function inspects the order of handshake messages by checking for any remaining unprocessed handshake data. When such data is detected, it immediately sends an unexpected_message alert and terminates the handshake process, fully addressing the RFC's specification that a peer must abort upon receiving a handshake message out of order. No additional logic is required for this constraint within the function itself.",success,
11078,do_read_client_hello,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function do_read_client_hello is focused on receiving and processing the ClientHello message during the TLS handshake. The RFC requirement states that ""Application Data MUST NOT be sent prior to sending the Finished message,"" but this function does not implement any logic to check or enforce that application data is withheld until after a Finished message is sent. Instead, the function verifies the message type, parses the ClientHello, checks for excess handshake data, and handles ECH (Encrypted ClientHello) processing. None of these operations directly address the constraint regarding application data scheduling, nor does it reference the sending of a Finished message. Therefore, no labeled constraints (like C1, A1, etc.) have been fully implemented within the function, and the implementation does not appear to address the specified RFC requirement.",success,
11079,do_read_client_hello_after_ech,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function 'do_read_client_hello_after_ech' does not include any logic that directly addresses the specific RFC requirement regarding the TLS 1.3 behavior of ignoring or not acting upon the presence of the status_request_v2 extension. There is no code segment that checks for, filters, or prevents the use of the status_request_v2 extension in EncryptedExtensions, CertificateRequest, or Certificate messages as dictated by the RFC. Although the function processes the ClientHello and TLS extensions, it does not reference or implement any condition (like C1) or action (like A1) related to the RFC specification. Consequently, the function does not match the spec constraints.",success,
11079,do_read_client_hello_after_ech,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (OPENSSL_memchr(client_hello.compression_methods, 0, client_hello.compression_methods_len) == NULL ||\n      (ssl_protocol_version(ssl) >= TLS1_3_VERSION &&\n       client_hello.compression_methods_len != 1)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_INVALID_COMPRESSION_LIST);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n  }', 'explanation': ""This code segment detects a semantically invalid ClientHello (invalid compression methods) and responds by sending an 'illegal_parameter' alert as required by the RFC specification. This directly implements the action of terminating the connection on such an error.""}}]","The function partially implements the RFC requirement by handling one instance of semantically invalid input (i.e., an invalid compression_methods list) by sending an 'illegal_parameter' alert, thereby terminating the connection. However, it does not cover other potential semantic errors (such as a DHE share of p -1 or an invalid enum) mentioned in the specification. Therefore, the implementation in the function itself only partially addresses the full scope of the constraints.",success,
11079,do_read_client_hello_after_ech,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'A1': {'code': 'uint8_t alert = SSL_AD_DECODE_ERROR;\n  if (!negotiate_version(hs, &alert, &client_hello)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n    return ssl_hs_error;\n  }', 'explanation': 'This snippet demonstrates that when negotiate_version fails (i.e. a parsing issue is detected), the function sends an alert whose default is set to SSL_AD_DECODE_ERROR and then terminates the connection. This aligns with the spec requirement that a message that cannot be parsed should result in a termination with a decode_error alert.'}}]","The RFC specifies that if a message cannot be parsed according to syntax, the connection MUST be terminated with a decode_error alert. In the function_body, one branch (the negotiate_version failure) addresses this by setting alert to SSL_AD_DECODE_ERROR and then sending that alert via ssl_send_alert. However, other parsing failures (such as a failure from GetClientHello, an unexpected client_hello.random_len, or errors during compression methods or TLS extension parsing) either immediately return an error or use a different alert (e.g. SSL_AD_ILLEGAL_PARAMETER) without explicitly sending the decode_error alert. Because the functionality is not uniformly implemented for all parse errors within this function, it only partially matches the spec constraints.",success,
11079,do_read_client_hello_after_ech,"For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the ""null"" compression method in prior versions of TLS.",22,Partially Matches,"[{'C1': {'code': 'if (OPENSSL_memchr(client_hello.compression_methods, 0, client_hello.compression_methods_len) == NULL ||\n    (ssl_protocol_version(ssl) >= TLS1_3_VERSION && client_hello.compression_methods_len != 1)) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_INVALID_COMPRESSION_LIST);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n  return ssl_hs_error;\n}', 'explanation': ""This segment checks that the ClientHello's compression_methods vector contains the null (0) byte, and for TLS 1.3 (when ssl_protocol_version(ssl) >= TLS1_3_VERSION), it enforces that the length of the compression_methods array is exactly one, thereby meeting the RFC requirement.""}}]","The function implements the TLS 1.3 compression method requirement by ensuring that the compression_methods vector contains the required null byte and that, in the TLS 1.3 case, the vector contains exactly one byte. However, the provided specification input also includes HTTP Max-Forwards header processing requirements, which this function does not address. Thus, in isolation, the function only partially meets the provided spec constraints.",success,
11079,do_read_client_hello_after_ech,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6).",10,Partially Matches,"[{'C1': {'code': 'if (!negotiate_version(hs, &alert, &client_hello)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n    return ssl_hs_error;\n}\n\nif (OPENSSL_memchr(client_hello.compression_methods, 0, client_hello.compression_methods_len) == NULL ||\n    (ssl_protocol_version(ssl) >= TLS1_3_VERSION &&\n     client_hello.compression_methods_len != 1)) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_INVALID_COMPRESSION_LIST);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n  return ssl_hs_error;\n}', 'explanation': ""The code checks the negotiation of protocol versions and acceptable compression methods. If a mismatch is detected (i.e. failure to meet the supported parameters), it aborts the handshake by sending a fatal alert. This partially implements the condition 'if the server is unable to negotiate a supported set of parameters' from the spec.""}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\nreturn ssl_hs_error;', 'explanation': 'In the select_certificate_cb error branch, the code sends a fatal alert (handshake_failure) and aborts the handshake. This reflects the action of aborting the handshake when parameter negotiation fails.'}}]","The function processes the ClientHello message and checks parameters such as the protocol version and compression methods. Upon detecting a failure (either during version negotiation or invalid compression method configuration), it initiates handshake abortion by sending a fatal alert. This behavior addresses the spec's requirement to abort the handshake when the server cannot negotiate a supported set of parameters. However, the implementation covers only some parameter checks (e.g. version and compression) and uses fatal alerts (mostly handshake_failure), without an explicit mechanism for the alternative 'insufficient_security' alert. Therefore, the code only partially meets the spec constraint.",success,
11079,do_read_client_hello_after_ech,"If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST abort the handshake with an ""illegal_parameter"" alert.",23,Fully Matches,"[{'C1': {'code': 'if (OPENSSL_memchr(client_hello.compression_methods, 0, client_hello.compression_methods_len) == NULL ||\n      (ssl_protocol_version(ssl) >= TLS1_3_VERSION &&\n       client_hello.compression_methods_len != 1)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_INVALID_COMPRESSION_LIST);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_hs_error;\n  }', 'explanation': ""This code explicitly checks that for TLS 1.3, the compression methods field contains only the allowed single null value. If the condition is not met, it aborts the handshake with an 'illegal_parameter' alert, which is exactly what the RFC spec requires.""}}]","The function inspects the TLS ClientHello message and specifically validates the compression_methods field. For TLS 1.3, it permits only a single null compression value. When any other value is detected, it triggers an error and sends an 'illegal_parameter' alert. This behavior directly implements the constraint from the RFC specification.",success,
11080,do_cert_callback,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The function does not contain any logic that addresses the specific TLS 1.3 requirement regarding the status_request_v2 extension mentioned in the RFC specification. None of the code segments in this function check for or deliberately avoid acting upon the status_request_v2 extension in any ClientHello, EncryptedExtensions, CertificateRequest, or Certificate messages. The function primarily handles certificate callbacks and OCSP stapling requests, and transitions to the TLS 1.3 state machine as needed, with no visible effort towards the specified constraint.",success,
11080,do_cert_callback,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Fully Matches,"[{'A1': {'code': 'if (rv == 0) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_CERT_CB_ERROR);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n  return ssl_hs_error;\n}\n...\ncase default:\n  OPENSSL_PUT_ERROR(SSL, SSL_R_OCSP_CB_ERROR);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n  return ssl_hs_error;', 'explanation': 'The RFC requirement states that all alerts must be sent with AlertLevel=fatal. This function handles error cases in both the certificate callback and OCSP stapling callback by calling ssl_send_alert with SSL3_AL_FATAL. This ensures that in error conditions the alerts are sent with the fatal level, satisfying the spec.'}}]","The function explicitly sends alerts using the SSL3_AL_FATAL constant in two error paths: one following a certificate callback failure and the other following an OCSP stapling callback failure. By doing so, it guarantees that all alerts it generates adhere to the RFC mandate that alerts must be sent with AlertLevel=fatal. No other parts of the RFC related to alerts are relevant within the scope of this function, and its in-function logic fully meets the specified constraint.",success,
11080,do_cert_callback,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Does Not Match,[],"The provided function primarily handles certificate callback processing during the SSL/TLS handshake and only sends alerts in error situations (using SSL_AD_INTERNAL_ERROR) when the certificate callback or OCSP stapling callback fails. The RFC specification provided describes behaviors related to terminating a connection with a specific alert (denoted as X alert) and handling a 'close' connection option, which involve sending a specific alert in that context. There is no visible logic in this function that implements the requirement to terminate the connection with a particular X alert as dictated by the spec constraints (e.g., managing a final response with a 'close' connection option or aborting the handshake using a specific alert). Thus, within the function_body itself, none of the labeled conditions or actions (such as those corresponding to sending a specific termination alert upon closing the connection) are implemented.",success,
11080,do_cert_callback,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Does Not Match,[],"The function_body, do_cert_callback, does not implement any logic related to handling the 'close' connection option as specified in the RFC context. It solely manages certificate and OCSP callback processing during the SSL/TLS handshake, including sending alerts on errors, but it does not address the connection termination or the request processing cessation that are required when a 'close' connection option is involved. As a result, no labeled spec constraints (e.g., C1, A1) regarding connection closure are implemented within this function.",success,
11080,do_cert_callback,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The provided function primarily handles certificate callbacks, OCSP stapling, and state transitions for TLS1.3 and TLS1.2. There is no logic within the function that addresses the prohibition of negotiating SSL 2.0 as required by the RFC specification. Since none of the conditions or actions related to secure protocol negotiation (specifically the prohibition of SSL2) are implemented in this code snippet, the function does not meet the specified RFC constraint.",success,
11080,do_cert_callback,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Does Not Match,[],"The provided function, do_cert_callback, is focused on handling certificate callbacks and OCSP stapling logic, as well as selecting state transitions for TLS 1.3 and TLS 1.2. There is no segment of code that checks for or prevents the negotiation of SSL 3.0. Since the RFC specification states that SSL 3.0 must not be negotiated, and this function does not contain any logic that directly implements this requirement, it does not meet the specified constraint.",success,
11082,do_select_parameters,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The RFC spec requires that if a ClientHello includes the status_request_v2 extension, TLS 1.3 servers must ignore its presence and must not send that extension in subsequent messages. In the provided function_body, there is no logic that processes or explicitly ignores the status_request_v2 extension, nor is there any code that prevents sending it in the EncryptedExtensions, CertificateRequest, or Certificate messages. All logic present in the function relates to selecting parameters for the handshake, session resumption, and cryptographic decisions, and does not address the specific RFC constraint regarding the status_request_v2 extension. Therefore, no labeled condition or action (such as C1 or A1) from the spec constraints is visibly implemented within this function.",success,
11082,do_select_parameters,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The RFC specification mandates that the OpenPGP certificate type MUST NOT be used with TLS 1.3. However, the provided function_body does not contain any logic or conditional checks related to the OpenPGP certificate type or its prohibition with TLS 1.3. All the operations in the function focus on parameter selection, session management, and handshake transcript handling without referencing or rejecting OpenPGP certificate types. Therefore, none of the labeled conditions or actions (e.g., C1, A1) related to the RFC constraint are addressed in this function.",success,
11082,do_select_parameters,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function 'do_select_parameters' is focused on selecting cryptographic parameters, negotiating session settings, and setting up the TLS handshake (e.g., processing the ClientHello, choosing cipher suites, and initializing handshake hashes). It does not contain any logic that addresses the specific RFC requirement that ""Application Data MUST NOT be sent prior to sending the Finished message"". There is no code in this function that ensures application data is withheld, as it deals solely with handshake parameter negotiation and does not manage the sending of application data.",success,
11082,do_select_parameters,"If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a ""handshake_failure"" or ""insufficient_security"" fatal alert (see Section 6).",10,Fully Matches,"[{'C1': {'code': 'if (!params.ok()) {\n    assert(ERR_peek_error() != 0);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n    return ssl_hs_error;\n}', 'explanation': 'This code detects if a supported set of parameters could not be negotiated (i.e. when params.ok() is false) and then aborts the handshake as required.'}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);', 'explanation': ""This segment sends the fatal alert 'handshake_failure', fulfilling the action requirement to abort the handshake if parameter negotiation fails.""}}]","The function explicitly checks for an unsuccessful negotiation of supported parameters via the params.ok() call. In the event of failure, it sends a fatal alert using ssl_send_alert with 'SSL_AD_HANDSHAKE_FAILURE', thereby aborting the handshake as specified. This directly implements the RFC requirement to abort with a handshake_failure alert when the server cannot negotiate a supported set of parameters.",success,
11084,do_send_server_hello,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The TLS 1.3 specification requires that servers MUST NOT act upon the presence or information of the status_request_v2 extension in ClientHello messages, and MUST NOT send it in subsequent messages. In the provided function, there is no logic that specifically checks for or excludes the status_request_v2 extension. The function builds and sends the ServerHello message and calls ssl_add_serverhello_tlsext to add TLS extensions, but there is no visible code ensuring that the status_request_v2 extension is omitted. Therefore, the function does not visibly address the specified condition/action from the RFC.",success,
11084,do_send_server_hello,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function does not contain any logic addressing the RFC specification that the OpenPGP certificate type MUST NOT be used with TLS 1.3. The function focuses on constructing the ServerHello message, handling channel IDs, session IDs, server random generation, and implementing TLS 1.3 anti‐downgrade signals. There is no conditional or explicit check that prevents the use of OpenPGP certificate type with TLS 1.3 within this function. Therefore, none of the spec constraints (e.g., C1 or any action specifying the prohibition of using the OpenPGP certificate type with TLS 1.3) are implemented in the function body.",success,
11084,do_send_server_hello,"If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of their Random value to the bytes:",39,Fully Matches,"[{'C1': {'code': 'if (hs->max_version >= TLS1_3_VERSION) {\n    if (ssl_protocol_version(ssl) == TLS1_2_VERSION) {\n        if (hs->apply_jdk11_workaround) {\n            copy_suffix(ssl->s3->server_random, kJDK11DowngradeRandom);\n        } else {\n            copy_suffix(ssl->s3->server_random, kTLS13DowngradeRandom);\n        }\n    } else {\n        copy_suffix(ssl->s3->server_random, kTLS12DowngradeRandom);\n    }\n}', 'explanation': 'This block explicitly sets the last 8 bytes of the server_random value using the copy_suffix() function with the proper downgrade constant. It distinguishes between the TLS 1.2 handshake path (even in a negotiated TLS 1.3 connection) and others, which directly implements the RFC requirement that TLS 1.3 servers negotiating TLS 1.2 MUST set the random suffix accordingly.'}}]","The function do_send_server_hello() incorporates logic that adjusts the last 8 bytes of the server_random field via a call to copy_suffix() based on the negotiated protocol version and whether a workaround is active. This directly implements the specified requirement from the RFC regarding the TLS anti-downgrade mechanism. No other parts of the RFC constraint need to be handled by this function, so by itself it fully meets the given RFC constraint.",success,
11084,do_send_server_hello,TLS 1.3 servers which negotiate TLS 1.2 or below in response to a ClientHello MUST set the last 8 bytes of their Random value specially in their ServerHello.,38,Partially Matches,"[{'C1': {'code': 'if (hs->max_version >= TLS1_3_VERSION) {\n    if (ssl_protocol_version(ssl) == TLS1_2_VERSION) {\n      if (hs->apply_jdk11_workaround) {\n        copy_suffix(ssl->s3->server_random, kJDK11DowngradeRandom);\n      } else {\n        copy_suffix(ssl->s3->server_random, kTLS13DowngradeRandom);\n      }\n    } else {\n      copy_suffix(ssl->s3->server_random, kTLS12DowngradeRandom);\n    }\n  }', 'explanation': 'This code segment attempts to implement the RFC requirement by modifying the last 8 bytes of the server_random. It checks if the maximum supported version is TLS 1.3 and then, if the negotiated version is TLS 1.2, applies one of two downgrade signals. However, it also applies a downgrade signal (kTLS12DowngradeRandom) when TLS 1.3 is negotiated, which goes beyond the RFC mandate that specifies this handling only for TLS 1.2 or below.'}}]","The RFC requires that TLS 1.3 servers which negotiate TLS 1.2 or below must specially set the last 8 bytes of their Random value. This function includes logic (via the copy_suffix calls) to modify these bytes in cases of a TLS 1.2 negotiation—addressing a key part of the spec constraint (C1). However, the function also applies a downgrade signal when TLS 1.3 is negotiated, which is not called for by the RFC. Therefore, the code only partially matches the RFC requirement.",success,
11084,do_send_server_hello,This structure is generated by the server and MUST be generated independently of the ClientHello.random.,31,Does Not Match,[],"The provided function implements a TLS ServerHello message generation routine. Its logic focuses on aspects such as channel ID handling, server random generation (including anti‐downgrade signaling), session resumption considerations, and message packing. None of these elements addresses the HTTP RFC constraints specified in the context (for example, handling the HTTP Upgrade header field, sending appropriate connection header options, managing the GET /hello and websocket upgrade behavior, etc.). In other words, although the function does generate a server structure independently of client data (which is a correct behavior for TLS), it makes no attempt by itself to implement any of the HTTP conditions (e.g., C1, C2) or actions (e.g., A1, A2) described in the provided spec constraints. Dependencies and calling functions might handle HTTP aspects, but this function’s internal logic does not visibly meet those HTTP RFC requirements.",success,
11084,do_send_server_hello,"The last 8 bytes MUST be overwritten as described below if negotiating TLS 1.2 or TLS 1.1, but the remaining bytes MUST be random.",30,Partially Matches,[],"The provided function does include logic to generate a server random value – it produces a series of random bytes (or, alternatively, uses provided hints) and then calls a function (copy_suffix) to overwrite a suffix of the random value. This is in line with the requirement of having the bulk of the server_random be random and overwriting some final bytes with a constant marker. However, the implementation only applies the suffix‐overwriting logic in a branch that checks for hs->max_version >= TLS1_3_VERSION and then differentiates behavior based on whether the negotiated protocol version is TLS1_2. In doing so, it does not explicitly cover the case of negotiating TLS 1.1, as required by the spec (“if negotiating TLS 1.2 or TLS 1.1”). Also, while the remainder of the random value is produced via RAND_bytes (or taken from a hint assumed to be random), the treatment does not clearly separate the generation of random bytes from the mandatory suffix overwrite as the spec requires. Because the function only partially and conditionally applies the needed overwrite logic and does not address TLS1.1 specifically, it only partially meets the spec constraint.",success,
11084,do_send_server_hello,"In particular, it MUST NOT negotiate TLS 1.3.",14,Partially Matches,"[{'C1': {'code': 'if (hs->max_version >= TLS1_3_VERSION) {\n    if (ssl_protocol_version(ssl) == TLS1_2_VERSION) {\n        if (hs->apply_jdk11_workaround) {\n            copy_suffix(ssl->s3->server_random, kJDK11DowngradeRandom);\n        } else {\n            copy_suffix(ssl->s3->server_random, kTLS13DowngradeRandom);\n        }\n    } else {\n        copy_suffix(ssl->s3->server_random, kTLS12DowngradeRandom);\n    }\n}\nCBB_add_u16(&body, ssl->s3->version);', 'explanation': 'This segment addresses the constraint by inserting downgrade signals into the server_random field when TLS1.3 support is present (hs->max_version >= TLS1_3_VERSION). The use of kTLS13DowngradeRandom (or a JDK11 workaround variant) indicates an effort to signal that, despite the client’s TLS1.3 capability, the connection is being downgraded (i.e. TLS1.3 is not being negotiated). However, the function itself does not actively block TLS1.3 negotiation; it relies on external context (such as the prior selection of ssl->s3->version) to ensure that TLS1.3 is not used. Therefore, the implementation is only partial.'}}]","The provided function includes logic to modify the server random value with a downgrade signal when a TLS1.3-capable handshake is detected (i.e. hs->max_version >= TLS1_3_VERSION), which is consistent with preventing the inadvertent negotiation of TLS1.3. However, the function does not explicitly enforce the prohibition of TLS1.3; it assumes that the negotiated protocol version (ssl->s3->version) is set externally (and remains TLS1.2). As such, while the anti‐downgrade mechanism is implemented here, it only partially meets the spec constraint that 'MUST NOT negotiate TLS 1.3' solely within the context of this function.",success,
11084,do_send_server_hello,"When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of ""pre_shared_key"" (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block).",62,Does Not Match,[],"The provided code function does not visibly address the RFC specification constraint regarding the ordering of extensions (specifically, ensuring that the 'pre_shared_key' extension is the last in the ClientHello). The function is responsible for constructing a ServerHello message and simply calls the helper function ssl_add_serverhello_tlsext to add extensions, without any logic that enforces or checks the order of extensions. Therefore, no labeled condition or action related to the given spec constraint is implemented within this function.",success,
11085,do_send_server_certificate,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function sends a certificate status extension when hs->certificate_status_expected is true. According to the specification, TLS 1.3 servers MUST NOT send the status_request_v2 extension (i.e. certificate status information) in the Certificate messages. Since the function unconditionally generates and sends this extension within the server certificate message, it does not comply with the RFC specification as given. No labeled conditions or actions from the input spec are fully met in this function's implementation.",success,
11085,do_send_server_certificate,The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK).,185,Fully Matches,"[{'C1': {'code': 'if (ssl_cipher_uses_certificate_auth(hs->new_cipher)) { ... }', 'explanation': 'This code checks if the agreed-upon key exchange method uses certificate authentication (i.e. not PSK), meeting the RFC condition that the server must send a Certificate message when using certificates.'}}, {'A1': {'code': 'if (!ssl_send_tls12_certificate(hs)) {\n      return ssl_hs_error;\n    }', 'explanation': 'This code segment sends the TLS 1.2 Certificate message when certificate authentication is in use, fulfilling the RFC action requirement.'}}]",The function do_send_server_certificate directly implements the RFC requirement for certificate-based key exchange by first checking if the cipher uses certificate authentication (C1) and then sending the Certificate message (A1). The controlled logic within the function fully addresses the specified condition and action as required by the RFC.,success,
11085,do_send_server_certificate,"These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2.",86,Does Not Match,[],"The provided code function is focused on performing TLS handshake operations—specifically sending the server certificate, handling certificate status (OCSP), and assembling ServerKeyExchange parameters for ciphers that require it. The RFC specification and context provided refer to HTTP header requirements (such as a valid From header for a robotic user agent) and signature handling for certificates in a TLS context. There is no visible logic within this function that addresses the HTTP From header or any similar aspects of the RFC. Therefore, the function does not attempt to implement the specified HTTP RFC.",success,
11085,do_send_server_certificate,"This extension, if provided by the server, MUST only be sent in the CertificateRequest message.",107,Does Not Match,[],"The RFC specification requires that the extension must only be sent in the CertificateRequest message. In this function, however, the code sends the certificate status (an extension) as part of the server certificate processing (when hs->certificate_status_expected is true). There is no logic here to restrict the extension to a CertificateRequest message; in fact, the extension is constructed and added in the server certificate path. Therefore, the function does not visibly implement the specified constraint.",success,
11086,do_send_server_key_exchange,"Implementations which have the same policy in both cases MAY omit the ""signature_algorithms_cert"" extension.",85,Does Not Match,[],"The provided function does not address the RFC requirement concerning the ""signature_algorithms_cert"" extension. Specifically, the RFC states that implementations with the same policy in both cases MAY omit this extension, meaning that the implementation should consider omitting the extension when the policies match. In the code, there is no check or logic comparing policies, nor is there any conditional branch that omits or includes a ""signature_algorithms_cert"" extension based on such a comparison. Instead, the function always adds the signature algorithm value (for TLS 1.2 and above) when certificate authentication is used. Therefore, no part of this function fulfills any condition or action corresponding to the spec's clause regarding the signature_algorithms_cert extension.",success,
11086,do_send_server_key_exchange,"These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in ""signature_algorithms"" and ""signature_algorithms_cert"" for backward compatibility with TLS 1.2.",86,Partially Matches,"[{'A1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_2_VERSION) {\n      if (!CBB_add_u16(&body, signature_algorithm)) {\n        OPENSSL_PUT_ERROR(SSL, ERR_R_INTERNAL_ERROR);\n        ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n        return ssl_hs_error;\n      }\n    }', 'explanation': 'This segment adds the signature algorithm field for TLS 1.2, which addresses the need for backward compatibility as stated in the RFC spec. It ensures that although these signature values are primarily meant for certificate signatures (and not for TLS handshake messages), they appear appropriately when TLS 1.2 is in use.'}}]","The function implements part of the RFC requirement by conditionally including the signature algorithm field when the protocol version is TLS 1.2. This directly addresses the backward‐compatibility aspect mentioned in the spec. However, the RFC also discusses usage and meaning of signature values in certificates (and related concerns such as those implied by the context of a valid From header in a robotic user agent), none of which are addressed within this function’s body. Therefore, while one part of the spec is handled (labeled here as A1), not all aspects are implemented, resulting in a 'Partially Matches' judgment.",success,
11086,do_send_server_key_exchange,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function, do_send_server_key_exchange, is dedicated to sending the Server Key Exchange handshake message during the TLS handshake process. The RFC specification requires that Application Data MUST NOT be sent prior to sending the Finished message. This function does not contain any logic that checks, prevents, or manages the premature sending of Application Data; it solely constructs and sends a handshake message, including preparation and signature generation. Therefore, no part of the function addresses the specified RFC constraint regarding Application Data, and the function does not attempt to implement the stated requirement.",success,
11086,do_send_server_key_exchange,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The provided code function does not include any logic that specifically checks for or prohibits the negotiation of SSL 2.0 as required by the RFC specification. The RFC prohibits SSL 2.0 negotiation, but the function solely handles the construction and sending of a Server Key Exchange message in a TLS/SSL handshake (using constructs such as SSL3_MT_SERVER_KEY_EXCHANGE and version checks for TLS1_2_VERSION) without enforcing any explicit rule against SSL 2.0. Therefore, there are no visible code segments within this function that address any corresponding condition (e.g., C1) or action (e.g., A1) that would implement the security prohibition of SSL 2.0 negotiation.",success,
11086,do_send_server_key_exchange,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites. In the provided function, there is no visible logic that inspects, filters out, or forbids the use of RC4 cipher suites. The function primarily handles the server key exchange message preparation and signing without any conditional check or removal of RC4 ciphers. As such, no part of this function addresses the stated RFC requirement.",success,
11087,do_send_server_hello_done,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function does not implement any logic to check for or exclude the status_request_v2 extension when processing messages such as CertificateRequest, EncryptedExtensions, or Certificate. The spec requires that TLS 1.3 servers must not act upon the status_request_v2 extension in ClientHello messages (and consequently must not include it in subsequent messages). However, this function merely constructs a CertificateRequest message (when hs->cert_request is true) without any handling to ensure that the status_request_v2 extension is not sent. There is no visible code segment addressing that specific constraint; hence, the target RFC requirement is not implemented by this function alone.",success,
11087,do_send_server_hello_done,The server MAY send it in the CertificateRequest message.,106,Partially Matches,"[{'C1': {'code': 'if (hs->cert_request) {\n    CBB cert_types, sigalgs_cbb;\n    if (!ssl->method->init_message(ssl, cbb.get(), &body,\n                                   SSL3_MT_CERTIFICATE_REQUEST) ||\n        !CBB_add_u8_length_prefixed(&body, &cert_types) ||\n        !CBB_add_u8(&cert_types, SSL3_CT_RSA_SIGN) ||\n        !CBB_add_u8(&cert_types, TLS_CT_ECDSA_SIGN) ||\n        (ssl_protocol_version(ssl) >= TLS1_2_VERSION &&\n         (!CBB_add_u16_length_prefixed(&body, &sigalgs_cbb) ||\n          !tls12_add_verify_sigalgs(hs, &sigalgs_cbb))) ||\n        !ssl_add_client_CA_list(hs, &body) ||\n        !ssl_add_message_cbb(ssl, cbb.get())) {\n      OPENSSL_PUT_ERROR(SSL, ERR_R_INTERNAL_ERROR);\n      return ssl_hs_error;\n    }\n  }', 'explanation': ""This code segment checks if a certificate request should be sent and then builds the CertificateRequest message, which corresponds to the RFC allowance that 'The server MAY send it in the CertificateRequest message.'""}}]","The function implements part of the TLS handshake that constructs a CertificateRequest message when requested (controlled by hs->cert_request). This directly addresses the RFC clause that the server MAY send a certificate request. However, the additional HTTP conditions and actions described in the spec context (e.g., handling of If-Modified-Since and If-None-Match headers) are not addressed in this function, since it is focused on TLS handshake message construction. Thus, only part of the overall spec is visibly implemented here.",success,
11088,do_read_client_certificate,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Does Not Match,[],"The provided function, do_read_client_certificate, is solely concerned with reading and processing the client certificate during the SSL/TLS handshake. It includes checks for message types, parses the certificate chain, and sends alerts upon errors related to certificate processing. However, none of the code addresses the RFC specification regarding handling the 'close' connection option (e.g., initiating connection termination after sending the final response, or ceasing further request processing). Because no visible logic in the function implements any of the conditions or actions related to connection closure as outlined in the spec context, the function does not meet any of the specified constraints.",success,
11088,do_read_client_certificate,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Partially Matches,"[{'A1': {'code': 'if (!ssl_parse_cert_chain(&alert, &hs->new_session->certs, &hs->peer_pubkey,\n                            hs->config->retain_only_sha256_of_client_certs\n                                ? hs->new_session->peer_sha256\n                                : nullptr,\n                            &certificate_msg, ssl->ctx->pool)) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n    return ssl_hs_error;\n}', 'explanation': 'This code segment handles an error when parsing the certificate chain fails. In doing so it sends a fatal alert (using the alert value determined by the error condition) which aligns with the RFC’s specification that if an error occurs that terminates the connection the implementation MUST send the specified alert.'}}, {'A2': {'code': 'if (sk_CRYPTO_BUFFER_num(hs->new_session->certs.get()) == 0) {\n    // No client certificate so the handshake buffer may be discarded.\n    hs->transcript.FreeBuffer();\n\n    if (hs->config->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n      return ssl_hs_error;\n    }\n\n    hs->new_session->verify_result = X509_V_OK;\n}', 'explanation': 'This segment sends a fatal handshake failure alert when no certificate is provided (and a certificate is required) thereby aborting the handshake. This is consistent with the RFC’s mandate to abort the handshake with a specified alert.'}}]","The function addresses error conditions by sending fatal alerts when problems arise during client certificate processing. Specifically, it sends an appropriate alert when the certificate chain parsing fails (A1) and when a required client certificate is missing (A2). These actions correspond to the RFC’s requirement to send an alert (the specified X alert) if the connection is to be terminated or the handshake aborted. However, the function does not cover all aspects of connection closure (such as managing the 'close' connection option described in the specification context). Thus, while the error‐alerting mechanism is correctly implemented in the function, the overall behavior required by the RFC is only partially addressed here.",success,
11088,do_read_client_certificate,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Partially Matches,"[{'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n...\nssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n...\nssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);', 'explanation': 'The code ensures that when an alert is sent (for decode errors or handshake failures), it is always sent using the fatal alert level (SSL3_AL_FATAL). This matches the RFC requirement that alerts must be sent with AlertLevel=fatal. However, the RFC also requires that received alerts be treated as error alerts regardless of the reported level, which is not addressed in this function.'}}]","The function contains multiple invocations of ssl_send_alert where the alert level is consistently set to SSL3_AL_FATAL, thereby satisfying the sending aspect of the RFC specification. However, the RFC also mandates that alerts, when received, must be treated as errors regardless of the AlertLevel. Since this function does not handle incoming alerts, only part of the specification is implemented here.",success,
11088,do_read_client_certificate,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function focuses entirely on processing the client certificate during the TLS handshake, including reading, parsing, and validating the certificate message. It does not contain any logic that checks or enforces the rule that ""Application Data MUST NOT be sent prior to sending the Finished message"". Therefore, no part of this function addresses the RFC constraint, and it does not implement any of the labeled conditions or actions associated with that specification.",success,
11088,do_read_client_certificate,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The code function 'do_read_client_certificate' focuses on processing and verifying client certificates during a TLS handshake. It deals with fetching, parsing, and validating the client certificate, as well as handling related errors. However, there is no section of the code that checks, prevents, or negotiates RC4 cipher suites in any version of TLS. Since the RFC specification explicitly prohibits offering or negotiating RC4 cipher suites, and no corresponding logic (e.g., conditions like C1 or actions like A1 regarding RC4) is implemented within this function, the function does not address the spec constraints.",success,
11089,do_verify_client_certificate,"If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either continue the handshake without client authentication or abort the handshake with a ""certificate_required"" alert.",218,Fully Matches,"[{'C1': {'code': 'if (sk_CRYPTO_BUFFER_num(hs->new_session->certs.get()) > 0) { ... }', 'explanation': 'This segment checks whether any client certificates were provided. According to the spec, if no certificate is sent (i.e., the Certificate message is empty), the server MAY continue without client authentication. Here, the function verifies the presence of certificates (C1) to decide the next steps.'}}, {'A1': {'code': 'hs->state = state12_read_client_key_exchange;\nreturn ssl_hs_ok;', 'explanation': ""This part of the code implements the continuation of the handshake when no client certificate is provided, aligning with the spec's action that the server may continue the handshake without client authentication.""}}]","The function 'do_verify_client_certificate' clearly addresses the RFC specification by checking if the client sent any certificates. If certificates are present, it proceeds with certificate verification; if not, it continues the handshake without client authentication by setting the next state and returning success. This behavior fully meets the specified conditions (C1) and actions (A1) stated in the RFC.",success,
11090,do_read_client_key_exchange,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function 'do_read_client_key_exchange' is focused on processing the ClientKeyExchange message, handling key exchange methods (RSA, ECDHE, PSK) and related decryption and validation tasks. It does not include any logic that checks for, processes, or deliberately ignores the 'status_request_v2' extension as required by the TLS 1.3 specification outlined in the spec. Likewise, no part of the function addresses HTTP message framing using Content-Length or Transfer-Encoding as mentioned in the spec context. Thus, within this function, none of the spec constraints (e.g., regarding not acting upon the status_request_v2 extension) are visibly implemented.",success,
11090,do_read_client_key_exchange,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification states that implementations MUST NOT offer or negotiate RC4 cipher suites. However, in the provided function_body, there is no logic that checks for, rejects, or prevents the negotiation of RC4 cipher suites. The function focuses primarily on processing and validating the client's key exchange message and handling various key exchange mechanisms (RSA, ECDHE, PSK) but does not include any conditions or actions that address the RC4 mandate.",success,
11090,do_read_client_key_exchange,"Sending this alert is OPTIONAL; servers MAY instead choose to send a ""decrypt_error"" alert to merely indicate an invalid PSK identity.",324,Does Not Match,[],"The RFC specification provided concerns closure alerts and the optional behavior to send a 'decrypt_error' alert in case of an invalid PSK identity. In the function do_read_client_key_exchange the logic is focused on processing the ClientKeyExchange message (including handling PSK identities) and sending error alerts (for example, SSL_AD_DECODE_ERROR, SSL_AD_UNKNOWN_PSK_IDENTITY, or SSL_AD_DECRYPT_ERROR) when parsing or decryption fails. However, it does not implement any logic related to sending or coordinating closure alerts, nor does it include a code‐path that optionally sends a 'decrypt_error' alert in lieu of a different alert when a PSK identity is invalid. Since none of the specific conditions or actions from the RFC constraints appear in this function (they are neither handled here for connection closure nor is the optional alert behavior for PSK identity implemented in this isolated function), the function does not visibly address the required specification constraints.",success,
11090,do_read_client_key_exchange,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (CBS_len(&psk_identity) > PSK_MAX_IDENTITY_LEN ||\n    CBS_contains_zero_byte(&psk_identity)) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_DATA_LENGTH_TOO_LONG);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n  return ssl_hs_error;\n}', 'explanation': 'The RFC requires that when a semantically invalid message is detected the connection is terminated with an ""illegal_parameter"" alert. In the PSK branch of the ClientKeyExchange processing, the function validates the PSK identity and, if it exceeds the maximum length or contains a zero byte, it sends SSL_AD_ILLEGAL_PARAMETER. This directly implements the action of terminating the connection with an illegal_parameter alert for that error case. However, similar semantic invalidities in other branches (e.g. decryption errors, decode errors) trigger different alerts rather than the required ""illegal_parameter"" alert, meaning that only part of the RFC condition is met within this function.'}}]","The function attempts to address the RFC requirement by validating incoming ClientKeyExchange messages and, in the PSK case, terminating the connection with an ""illegal_parameter"" alert when the PSK identity is semantically invalid. Nonetheless, the function uses different alert codes (such as SSL_AD_DECODE_ERROR and SSL_AD_DECRYPT_ERROR) in other error conditions that represent different kinds of failures. Because it does not uniformly send an ""illegal_parameter"" alert for all semantically invalid messages, the implementation only partially matches the RFC specification.",success,
11091,do_read_client_certificate_verify,"-The certificate MUST allow the key to be used for signing (i.e., the digitalSignature bit MUST be set if the Key Usage extension is present) with a signature scheme indicated in the client's ""signature_algorithms""/""signature_algorithms_cert"" extensions (see Section 4.2.3).",206,Fully Matches,"[{'C1': {'code': 'if (!ssl_cert_check_key_usage(&leaf_cbs, key_usage_digital_signature)) {\n    return ssl_hs_error;\n}', 'explanation': ""This code verifies that the certificate's key usage includes the digitalSignature bit, ensuring that the key is allowed for signing, as required by the spec.""}}, {'A1': {'code': 'if (ssl_protocol_version(ssl) >= TLS1_2_VERSION) {\n    if (!CBS_get_u16(&certificate_verify, &signature_algorithm)) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n      ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n      return ssl_hs_error;\n    }\n    uint8_t alert = SSL_AD_DECODE_ERROR;\n    if (!tls12_check_peer_sigalg(hs, &alert, signature_algorithm, hs->peer_pubkey.get())) {\n      ssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n      return ssl_hs_error;\n    }\n    hs->new_session->peer_signature_algorithm = signature_algorithm;\n}', 'explanation': ""This code extracts the signature algorithm from the CertificateVerify message and uses it to check that the client's key is used with an acceptable signature scheme, as indicated in the client's 'signature_algorithms' extension.""}}]","The function 'do_read_client_certificate_verify' directly addresses the RFC requirement by first checking that the certificate key has the digitalSignature usage (C1) and then verifying that the signature algorithm provided in the message is allowed by the client's negotiated 'signature_algorithms' extension (A1). All necessary validations are performed within this function, satisfying the specified constraints.",success,
11091,do_read_client_certificate_verify,The receiver of a CertificateVerify message MUST verify the signature field.,230,Fully Matches,"[{'C1': {'code': 'if (!ssl_public_key_verify(ssl, signature, signature_algorithm,\n                             hs->peer_pubkey.get(), hs->transcript.buffer())) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_SIGNATURE);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECRYPT_ERROR);\n    return ssl_hs_error;\n  }', 'explanation': ""This code segment directly performs the required verification of the signature field of the CertificateVerify message by using the peer's public key, the signature, and the handshake transcript. It ensures that if the signature does not verify correctly, the process aborts with an error, thus fully satisfying the RFC mandate.""}}]","The function 'do_read_client_certificate_verify' includes explicit logic to verify the signature field of the CertificateVerify message, as required by the RFC. It extracts the signature from the message, determines the appropriate signature algorithm based on the protocol version, and uses the 'ssl_public_key_verify' function to verify the signature. This evidence, contained within the code function itself and independent of dependencies, shows a full implementation of the requirement, and therefore the function fully matches the specified RFC constraint.",success,
11091,do_read_client_certificate_verify,"If the verification fails, the receiver MUST terminate the handshake with a ""decrypt_error"" alert.",231,Partially Matches,"[{'A1': {'code': 'if (!ssl_public_key_verify(ssl, signature, signature_algorithm,\n                             hs->peer_pubkey.get(), hs->transcript.buffer())) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_SIGNATURE);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECRYPT_ERROR);\n    return ssl_hs_error;\n}', 'explanation': 'This block directly checks the result of the signature verification. On failure, it sends a fatal alert with the decrypt_error (SSL_AD_DECRYPT_ERROR) and terminates the handshake, which addresses the RFC requirement \'if the verification fails, the receiver MUST terminate the handshake with a ""decrypt_error"" alert.\''}}]","The function addresses the RFC-specified behavior for handling a verification failure by sending a 'decrypt_error' alert in the case of a bad signature. However, while this critical action is implemented, other potential aspects or conditions implied by the spec (and any additional constraints) are either handled indirectly or outside the scope of this function. Therefore, only some of the labeled conditions/actions are visibly implemented within this function.",success,
11091,do_read_client_certificate_verify,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The RFC specification states that 'Application Data MUST NOT be sent prior to sending the Finished message,' which is a requirement related to the ordering of messages during the handshake. The provided function, do_read_client_certificate_verify, is focused on verifying the client's certificate and its signature as part of the TLS handshake and does not contain any logic to address the prevention of sending Application Data before the Finished message. Therefore, no part of the function's code fulfills the RFC's constraint regarding Application Data ordering.",success,
11091,do_read_client_certificate_verify,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16(&certificate_verify, &signature_algorithm)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    return ssl_hs_error;\n}', 'explanation': 'This code segment checks whether the expected 2-byte signature algorithm can be parsed from the message. If parsing fails, it logs a decode error and sends a decode_error alert to terminate the connection, directly addressing the RFC requirement regarding syntax parsing errors.'}}, {'C1': {'code': 'if (!CBS_get_u16_length_prefixed(&certificate_verify, &signature) || CBS_len(&certificate_verify) != 0) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECODE_ERROR);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    return ssl_hs_error;\n}', 'explanation': 'This segment checks that the signature is correctly parsed as a length‐prefixed field and that no extra data remains (ensuring boundaries are respected). On failure, it issues a decode_error alert, fulfilling the RFC mandate for handling syntactically malformed messages.'}}]","The provided function includes multiple checks on the format and length of the incoming message, and when a parsing error is detected it immediately logs the error and sends a decode_error alert. These actions ensure that any message which fails to parse according to the expected syntax causes the connection to be terminated, which is in full compliance with the RFC specification.",success,
11097,do_send_server_finished,"At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message.",238,Fully Matches,"[{'C1': {'code': 'if (hs->ticket_expected) {\n    ...\n}', 'explanation': 'The function checks if a new session ticket is expected (hs->ticket_expected) after the client Finished message, which aligns with the spec condition that the server MAY send a NewSessionTicket at that point.'}}, {'A1': {'code': 'ssl->method->init_message(ssl, cbb.get(), &body, SSL3_MT_NEW_SESSION_TICKET) ||\nCBB_add_u32(&body, session->timeout) ||\nCBB_add_u16_length_prefixed(&body, &ticket) ||\nssl_encrypt_ticket(hs, &ticket, session) ||\nssl_add_message_cbb(ssl, cbb.get())', 'explanation': 'This sequence constructs the NewSessionTicket message, encrypts the ticket, and adds the message to the output buffer. It directly implements the action of sending a NewSessionTicket message as allowed by the RFC.'}}]","The function do_send_server_finished explicitly implements the logic for sending a NewSessionTicket message when a ticket is expected, as per the specification. It performs necessary session management (rebasing the session time and handling session duplication), builds the message using the SSL method's init_message call and related CBB functions, and then sends it. This fulfills both the condition (C1) to send the ticket when appropriate and the action (A1) to actually construct and send the ticket message, thereby fully matching the specified constraint within its own logic.",success,
11098,do_finish_server_handshake,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided code function is focused on finalizing the server handshake by completing the session setup and updating caches. It does not contain any logic that verifies, inspects, or filters the 'status_request_v2' extension, nor does it implement any conditions or actions related to the TLS 1.3 requirement specified in the RFC (i.e., not acting upon that extension in ClientHello messages or sending it in subsequent messages). As a result, none of the labeled constraints (such as C1, A1, etc.) are addressed within this function's own code.",success,
11104,setup_ctx,"RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in ""signature_algorithms"".",228,Partially Matches,"[{'C1': {'code': 'if (alg->is_rsa_pss) {\n    if (!EVP_PKEY_CTX_set_rsa_padding(pctx, RSA_PKCS1_PSS_PADDING) ||\n        !EVP_PKEY_CTX_set_rsa_pss_saltlen(pctx, -1 /* salt len = hash len */)) {\n      return false;\n    }\n  }', 'explanation': ""The RFC requires that RSA signatures MUST use an RSASSA-PSS algorithm. In this code, when the flag 'alg->is_rsa_pss' is set the function configures the EVP_PKEY_CTX to use RSASSA-PSS (by setting RSA_PKCS1_PSS_PADDING and the proper salt length). This shows an attempt to implement the spec but only when the algorithm indicates RSA-PSS. If the flag is not set, the function does not force RSASSA-PSS, so the enforcement is only partial.""}}]","The function checks whether the provided algorithm supports RSA-PSS and configures the context accordingly. However, it only applies RSASSA-PSS settings when the algorithm flag 'is_rsa_pss' is true, and does not enforce RSASSA-PSS universally for RSA signatures as required by the specification. Therefore, while the function contains logic that addresses the use of RSASSA-PSS, it only partially meets the full requirement of the RFC.",success,
11139,ssl_cipher_get_evp_aead,An AEAD algorithm where N_MAX is less than 8 bytes MUST NOT be used with TLS.,298,Does Not Match,[],"The RFC specification requires that an AEAD algorithm with N_MAX less than 8 bytes MUST NOT be used with TLS. The provided function, ssl_cipher_get_evp_aead, selects and configures various AEAD algorithms (e.g., AES_GCM with fixed IV lengths of 4 or 12 bytes, Chacha20-Poly1305, etc.) based solely on the cipher's encoding and version. However, it does not check or enforce any constraint on the AEAD algorithm's N_MAX value, nor does it reject AEAD algorithms whose maximum nonce length (N_MAX) is less than 8 bytes. In other words, there is no logic in the function that addresses the specified condition, so it does not visibly implement the requirement outlined in the RFC specification.",success,
11139,ssl_cipher_get_evp_aead,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function does not contain any logic that explicitly checks for or prevents the use of the truncated HMAC extension as mandated by the RFC specification. While the function sets up different cipher algorithms and selects corresponding EVP_AEAD objects or CBC routines, it does not address the requirement to avoid the truncated HMAC extension (the spec requirement). There is no code segment that inspects, disables, or makes any decision based on the use of the truncated HMAC extension within the function body.",success,
11153,ssl_create_cipher_list,"Implementations negotiating the use of older versions of TLS SHOULD prefer forward secret and AEAD cipher suites, when available.",388,Fully Matches,"[{'C1': {'code': '/* We prefer ECDHE ciphers over non-PFS ciphers. Then we prefer AEAD over non-AEAD. */\nstatic const uint16_t kAESCiphers[] = {\n    TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 & 0xffff,\n    TLS1_CK_ECDHE_RSA_WITH_AES_128_GCM_SHA256 & 0xffff,\n    TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 & 0xffff,\n    TLS1_CK_ECDHE_RSA_WITH_AES_256_GCM_SHA384 & 0xffff,\n};\nstatic const uint16_t kChaChaCiphers[] = {\n    TLS1_CK_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 & 0xffff,\n    TLS1_CK_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 & 0xffff,\n    TLS1_CK_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 & 0xffff,\n};\n...\nif (has_aes_hw) {\n  for (uint16_t id : kAESCiphers) {\n    co_list[num++].cipher = SSL_get_cipher_by_value(id);\n    assert(co_list[num - 1].cipher != nullptr);\n  }\n}\nfor (uint16_t id : kChaChaCiphers) {\n  co_list[num++].cipher = SSL_get_cipher_by_value(id);\n  assert(co_list[num - 1].cipher != nullptr);\n}\nif (!has_aes_hw) {\n  for (uint16_t id : kAESCiphers) {\n    co_list[num++].cipher = SSL_get_cipher_by_value(id);\n    assert(co_list[num - 1].cipher != nullptr);\n  }\n}', 'explanation': 'This segment defines cipher groups that are both forward secret (using ECDHE) and AEAD (AES GCM and ChaCha20-Poly1305) and orders them to be preferred before the legacy cipher suites, directly addressing the requirement.'}}]",The function clearly implements the spec by first defining and ordering cipher suites that provide forward secrecy (ECDHE) and AEAD properties. It places these high-priority cipher suites (from kAESCiphers and kChaChaCiphers) ahead of legacy ciphers. This ordering logic within the function meets the specification's requirement to prefer forward secret and AEAD cipher suites when negotiating older TLS versions.,success,
11153,ssl_create_cipher_list,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function, ssl_create_cipher_list, is focused on constructing and ordering the list of SSL ciphers based on various parameters (e.g., AES hardware availability, cipher preference order) and does not include any logic or checks related to the Truncated HMAC extension as mandated by the RFC specification. There are no code segments that verify or disable the usage of the Truncated HMAC extension, which is the core requirement stated in the RFC. Therefore, the function does not visibly address the specified RFC constraint.",success,
11177,SSL_CIPHER_get_bits,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function, SSL_CIPHER_get_bits, only computes the bit lengths of various encryption algorithms based on the cipher->algorithm_enc field. It does not contain any logic to check or enforce that the OpenPGP certificate type (RFC6091) is disallowed with TLS 1.3. There is no reference or condition related to certificate types or TLS versions anywhere in the code, so it does not visibly address any of the specified conditions or actions.",success,
11178,SSL_CIPHER_description,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The spec constraint requires that implementations MUST NOT use the Truncated HMAC extension as defined in Section 7 of RFC6066. The provided function, SSL_CIPHER_description, is solely responsible for formatting and returning a descriptive string for a given cipher and does not contain any logic related to handling or checking the use of the truncated HMAC extension. Consequently, no part of the function addresses any labeled condition or action from the spec constraints.",success,
11179,SSL_CIPHER_get_version,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function simply returns the constant string ""TLSv1/SSLv3"" and does not contain any logic that checks or prevents the use of the OpenPGP certificate type with TLS 1.3. There is no handling of conditions (e.g., checking TLS version or certificate type) or actions related to the RFC6091 requirement. Therefore, the function does not address any of the specified conditions or actions.",success,
11188,ssl_record_prefix_len,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function does not address any of the specified RFC constraints regarding the non-use of the Truncated HMAC extension. Instead, it only computes the SSL record prefix length by adding a predefined header length to the explicit nonce length, and asserts that the connection is not DTLS. There is no code within this function that checks for or disables the Truncated HMAC extension (or any related security feature), so it does not attempt to implement the RFC requirement.",success,
11189,skip_early_data,"A server receiving more than max_early_data_size bytes of 0-RTT data SHOULD terminate the connection with an ""unexpected_message"" alert.",252,Fully Matches,"[{'C1': {'code': 'if (ssl->s3->early_data_skipped > kMaxEarlyDataSkipped) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_TOO_MUCH_SKIPPED_EARLY_DATA);\n    *out_alert = SSL_AD_UNEXPECTED_MESSAGE;\n    return ssl_open_record_error;\n}', 'explanation': ""This code segment checks whether the cumulative early data skipped exceeds the maximum allowed (kMaxEarlyDataSkipped), and if so, it terminates the connection by setting an 'unexpected_message' alert and returning an error, directly matching the RFC's requirement.""}}]","The function 'skip_early_data' implements the specified RFC by checking if more than the allowed 0-RTT data (max_early_data_size) has been received. Upon detecting an excess, it triggers an error by setting an unexpected_message alert, which fulfills the condition (C1) that requires termination of the connection when too much early data is received. This logic is fully self-contained within the function_body.",success,
11189,skip_early_data,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'C1': {'code': 'ssl->s3->early_data_skipped += consumed;\nif (ssl->s3->early_data_skipped > kMaxEarlyDataSkipped) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_TOO_MUCH_SKIPPED_EARLY_DATA);\n    *out_alert = SSL_AD_UNEXPECTED_MESSAGE;\n    return ssl_open_record_error;\n}\n\nreturn ssl_open_record_discard;', 'explanation': ""The RFC requires that a TLS implementation must not automatically resend early data. This function achieves that by simply tracking and discarding the early data (using the 'ssl_open_record_discard' return) rather than attempting any retransmission. Its logic to increment a counter and abort if too much data is skipped confirms that early data is not automatically resent.""}}]","The function 'skip_early_data' directly handles early data by marking it as skipped and then discarding it; it does not attempt to resend any early data. This behavior aligns with the TLS RFC specification that advises against automatically resending early data, ensuring that decision making for retransmission is left to the application. Therefore, the code visibly addresses the RFC constraint.",success,
11190,tls_record_version,Implementations MUST NOT send any records with a version less than 0x0300.,397,Does Not Match,[],The RFC requires that implementations MUST NOT send any records with a version less than 0x0300. The function tls_record_version does not enforce any check or condition to ensure the record version is not below 0x0300. It simply returns TLS1_VERSION when ssl->s3->version is 0 and otherwise returns either ssl->s3->version or TLS1_2_VERSION based on the protocol version. There is no evident logic in this function that prevents sending records with a version value less than 0x0300.,success,
11191,tls_open_record,"Implementations MUST NOT send Handshake and Alert records that have a zero-length TLSInnerPlaintext.content; if such a message is received, the receiving implementation MUST terminate the connection with an ""unexpected_message"" alert.",301,Does Not Match,[],"The RFC specifies that if a handshake or alert record is received with a zero-length TLSInnerPlaintext.content, the connection must be terminated with an 'unexpected_message' alert. In the function_body, although there are checks related to empty records (such as incrementing empty_record_count and eventually returning an error), there is no explicit logic that immediately identifies a handshake or alert record with zero-length inner plaintext and then issues an 'unexpected_message' alert. The handling of empty records here does not directly enforce the RFC requirement; instead, it treats empty records by counting them and only triggers an error after exceeding a maximum count. Therefore, there is no visible implementation of the labeled condition or action fully within this function.",success,
11191,tls_open_record,Implementations MUST limit their scanning to the cleartext returned from the AEAD decryption.,302,Fully Matches,"[{'C1': {'code': 'if (has_padding) {\n    do {\n      if (out->empty()) {\n        OPENSSL_PUT_ERROR(SSL, SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n        *out_alert = SSL_AD_DECRYPT_ERROR;\n        return ssl_open_record_error;\n      }\n      type = out->back();\n      *out = out->subspan(0, out->size() - 1);\n    } while (type == 0);\n  }', 'explanation': ""The code limits its scanning to the cleartext content produced by the AEAD decryption by manipulating and inspecting only the 'out' span. This loop removes padding and extracts the inner content type exclusively from the decrypted data, thereby adhering to the requirement that scanning be limited to the cleartext returned from the AEAD decryption.""}}]","The function processes a TLS record by first decrypting the encrypted body using an AEAD decryption context and then, if padding is present, it scans only the resulting cleartext (stored in 'out') to extract the inner content type. This approach ensures that any scanning or parsing is confined strictly to the decrypted output, which fully meets the spec constraint.",success,
11191,tls_open_record,"An endpoint that receives a record from its peer with TLSCiphertext.length larger than 2^14 + 256 octets MUST terminate the connection with a ""record_overflow"" alert.",295,Fully Matches,"[{'C1': {'code': 'if (ciphertext_len > SSL3_RT_MAX_ENCRYPTED_LENGTH) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\n    *out_alert = SSL_AD_RECORD_OVERFLOW;\n    return ssl_open_record_error;\n}', 'explanation': ""This code segment checks if the received TLSCiphertext length exceeds the maximum allowed value (interpreted as 2^14 + 256 octets), and if so, it sets the alert to 'record_overflow' and terminates processing, thus directly fulfilling the spec requirement.""}}]","The function contains a direct check against the maximum allowed ciphertext length (using SSL3_RT_MAX_ENCRYPTED_LENGTH) and, if exceeded, sets the alert (*out_alert = SSL_AD_RECORD_OVERFLOW) and returns an error state (ssl_open_record_error). This implementation satisfies the specified constraint from the RFC by fully addressing the condition and required action within the function's body.",success,
11191,tls_open_record,"An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.",288,Fully Matches,"[{'C1': {'code': 'if (ciphertext_len > SSL3_RT_MAX_ENCRYPTED_LENGTH) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\n    *out_alert = SSL_AD_RECORD_OVERFLOW;\n    return ssl_open_record_error;\n}', 'explanation': ""This code segment checks whether the ciphertext length exceeds the maximum allowed length and, if so, it sets the alert to 'record_overflow' and terminates further processing, fulfilling the RFC requirement.""}}]",The function explicitly verifies the record length against a maximum limit and immediately terminates the connection with a 'record_overflow' alert when the condition is met. This directly addresses the spec requirement that an endpoint must terminate the connection if the record received exceeds the prescribed length.,success,
11191,tls_open_record,"An endpoint that receives a record that exceeds this length MUST terminate the connection with a ""record_overflow"" alert.",292,Fully Matches,"[{'C1': {'code': 'if (ciphertext_len > SSL3_RT_MAX_ENCRYPTED_LENGTH) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\n    *out_alert = SSL_AD_RECORD_OVERFLOW;\n    return ssl_open_record_error;\n}', 'explanation': ""This code segment checks whether the incoming record’s ciphertext length exceeds the maximum allowed value and, if so, sets the alert to 'record_overflow' and terminates processing by returning an error. This directly addresses the condition in the spec that a record exceeding the permitted length must result in notifying the client with a 'record_overflow' alert.""}}, {'A1': {'code': 'if (out->size() > plaintext_limit) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DATA_LENGTH_TOO_LONG);\n    *out_alert = SSL_AD_RECORD_OVERFLOW;\n    return ssl_open_record_error;\n}', 'explanation': ""This segment confirms that, after decryption, if the resulting plaintext length exceeds the maximum allowed (with padding considerations), the function sets the 'record_overflow' alert and terminates processing. This fulfills the action requirement of terminating the connection upon receiving an oversized record.""}}]","The function includes explicit checks for record length both in its encrypted form and after decryption. In each case, if the record exceeds the set limits, it triggers an error, sets the alert to SSL_AD_RECORD_OVERFLOW (which corresponds to 'record_overflow'), and terminates processing. This directly implements the RFC specification that requests termination of the connection with a record_overflow alert when an oversized record is received.",success,
11191,tls_open_record,"Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure.",283,Fully Matches,"[{'C1': {'code': 'if (out->empty()) {\n    ssl->s3->empty_record_count++;\n    if (ssl->s3->empty_record_count > kMaxEmptyRecords) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_TOO_MANY_EMPTY_FRAGMENTS);\n      *out_alert = SSL_AD_UNEXPECTED_MESSAGE;\n      return ssl_open_record_error;\n    }\n    // Apart from the limit, empty records are returned up to the caller. This\n    // allows the caller to reject records of the wrong type.\n  } else {\n    ssl->s3->empty_record_count = 0;\n  }', 'explanation': 'This code explicitly handles the case when the decrypted application data record is empty. It permits empty application data records (which the RFC allows as a countermeasure) while also enforcing a maximum consecutive empty record count.'}}]","The provided function processes TLS records and includes a code branch that checks for empty decrypted content. With this branch, the function accepts zero‐length (empty) fragments of Application Data, in accordance with the RFC specification. The empty data is counted and allowed to pass up to a configured threshold, thereby fully addressing the specified behavior within the function itself.",success,
11191,tls_open_record,"That is, if a handshake message is split over two or more records, there MUST NOT be any other records between them.",276,Fully Matches,"[{'C1': {'code': 'if (type != SSL3_RT_HANDSHAKE &&  //\n      tls_has_unprocessed_handshake_data(ssl)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_RECORD);\n    *out_alert = SSL_AD_UNEXPECTED_MESSAGE;\n    return ssl_open_record_error;\n  }', 'explanation': 'This code explicitly checks if there is unprocessed handshake data (indicating that a handshake message is split across records) and then ensures that any subsequent record is of type HANDSHAKE. If it isn’t, it returns an error, thus preventing other records from interleaving with the handshake fragments as required by the RFC.'}}]","The function implements the RFC requirement by using tls_has_unprocessed_handshake_data to determine if a handshake message is still in process and then verifying that incoming records are of type HANDSHAKE. This in-function logic prevents interleaving of non-handshake records when a handshake message is split over multiple records, thereby fully matching the constraint.",success,
11191,tls_open_record,-Handshake messages MUST NOT be interleaved with other record types.,275,Fully Matches,"[{'C1': {'code': '// Handshake messages may not interleave with any other record type.\n  if (type != SSL3_RT_HANDSHAKE &&  //\n      tls_has_unprocessed_handshake_data(ssl)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_RECORD);\n    *out_alert = SSL_AD_UNEXPECTED_MESSAGE;\n    return ssl_open_record_error;\n  }', 'explanation': 'This code explicitly checks if the current record type is not a handshake while there is unprocessed handshake data. If so, it raises an error, thereby enforcing the RFC requirement that handshake messages must not be interleaved with other record types.'}}]",The function contains a specific block that ensures that a non-handshake record will not be processed if there is pending handshake data. This logic directly implements the RFC specification that handshake messages must not be interleaved with other record types.,success,
11191,tls_open_record,"Handshake messages MAY be coalesced into a single TLSPlaintext record or fragmented across several records, provided that:",274,Partially Matches,"[{'C1': {'code': 'if (!tls_can_accept_handshake_data(ssl, out_alert)) {\n    return ssl_open_record_error;\n}\n...\n// Handshake messages may not interleave with any other record type.\nif (type != SSL3_RT_HANDSHAKE &&  tls_has_unprocessed_handshake_data(ssl)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_RECORD);\n    *out_alert = SSL_AD_UNEXPECTED_MESSAGE;\n    return ssl_open_record_error;\n}', 'explanation': 'The RFC states that handshake messages may be sent either coalesced in one record or fragmented across multiple records. The above code checks whether there are already unprocessed handshake messages (via tls_can_accept_handshake_data and tls_has_unprocessed_handshake_data) and prevents interleaving of other record types with handshake messages. This indicates an attempt to enforce ordering and limits on fragmented/coalesced handshake processing.'}}]","The function contains logic that inspects the record type and ensures that if a handshake message is partially received or buffered, no other record type is allowed to interleave. This behavior aligns with the underlying RFC requirement by validating proper handling of handshake messages that might be received in a fragmented (or coalesced) form. However, explicit reassembly logic for handshake fragments is not present within this function; rather it primarily manages record acceptance and error signalling. As such, while it visibly addresses some aspects of the constraint (C1) regarding handshake message processing, it only partially implements the full specification within this context.",success,
11191,tls_open_record,"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",272,Fully Matches,"[{'C1': {'code': 'if (type != SSL3_RT_HANDSHAKE &&  tls_has_unprocessed_handshake_data(ssl)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_RECORD);\n    *out_alert = SSL_AD_UNEXPECTED_MESSAGE;\n    return ssl_open_record_error;\n  }', 'explanation': ""This block checks if the record type is not expected (i.e. not a handshake record) when there is unprocessed handshake data. In such a case, it sets the alert to 'unexpected_message' (SSL_AD_UNEXPECTED_MESSAGE) and terminates the connection by returning an error, which is exactly what the RFC requires.""}}, {'A1': {'code': '*out_alert = SSL_AD_UNEXPECTED_MESSAGE;', 'explanation': ""The code sets the alert to 'unexpected_message' when an unexpected record type is encountered. This action fulfills the spec's mandate to alert the client with an 'unexpected_message' alert.""}}]","The function 'tls_open_record' contains explicit logic to check for an unexpected record type by verifying that, during a handshake, any record that is not of the expected type (handshake) is treated as an error. It sets the 'out_alert' to SSL_AD_UNEXPECTED_MESSAGE and terminates processing by returning an error. This behavior directly addresses the TLS RFC requirement that a TLS implementation must terminate the connection with an 'unexpected_message' alert when an unexpected record type is received. Therefore, the function fully matches the specified conditions and actions.",success,
11191,tls_open_record,"An implementation which receives any other change_cipher_spec value or which receives a protected change_cipher_spec record MUST abort the handshake with an ""unexpected_message"" alert.",269,Partially Matches,[],"The RFC specification requires that if a change_cipher_spec record is received in a context where it is not expected – either because its value is not the one anticipated or because it is a protected change_cipher_spec record – the implementation MUST abort the handshake with an 'unexpected_message' alert. In the provided function, there is explicit logic (starting at the line ""if (ssl_has_final_version(ssl) && ssl_protocol_version(ssl) >= TLS1_3_VERSION && SSL_in_init(ssl) && type == SSL3_RT_CHANGE_CIPHER_SPEC && Span<const uint8_t>(body) == kChangeCipherSpec)"") which handles change_cipher_spec records during TLS 1.3 handshakes. In this block the code increments an empty record count and, only when this count exceeds kMaxEmptyRecords, does it abort the handshake by setting *out_alert to SSL_AD_UNEXPECTED_MESSAGE and returning an error. Otherwise, if the count is not exceeded, the function simply discards the record (returning ssl_open_record_discard).

Thus, while the function does explicitly check for change_cipher_spec records and eventually aborts the handshake with an unexpected_message alert, it only does so conditionally (after a threshold is exceeded) rather than immediately, as the RFC requires. Since the logic addresses the issue to some extent but does not fully implement the requirement as specified, the function is considered to partially match the specification constraint.",success,
11191,tls_open_record,"If the decryption fails, the receiver MUST terminate the connection with a ""bad_record_mac"" alert.",293,Fully Matches,"[{'A1': {'code': 'if (!ssl->s3->aead_read_ctx->Open(\n          out, type, version, ssl->s3->read_sequence, header,\n          Span(const_cast<uint8_t *>(CBS_data(&body)), CBS_len(&body)))) {\n    if (ssl->s3->skip_early_data && !ssl->s3->aead_read_ctx->is_null_cipher()) {\n      ERR_clear_error();\n      return skip_early_data(ssl, out_alert, *out_consumed);\n    }\n\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n    *out_alert = SSL_AD_BAD_RECORD_MAC;\n    return ssl_open_record_error;\n}', 'explanation': 'This code block checks if decryption fails. When the Open() call fails, it explicitly sets *out_alert to SSL_AD_BAD_RECORD_MAC and returns an error, thereby terminating the connection as required by the RFC specification.'}}]","The function directly implements the RFC requirement by terminating the connection with a 'bad_record_mac' alert when decryption fails. The if-block for the decryption failure clearly captures the necessary behavior, fulfilling the spec constraint within the function itself.",success,
11191,tls_open_record,"If the version chosen by the server is not supported by the client (or is not acceptable), the client MUST abort the handshake with a ""protocol_version"" alert.",379,Fully Matches,"[{'C1': {'code': 'bool version_ok;\n  if (ssl->s3->aead_read_ctx->is_null_cipher()) {\n    // Only check the first byte... \n    version_ok = (version >> 8) == SSL3_VERSION_MAJOR;\n  } else {\n    version_ok = version == tls_record_version(ssl);\n  }\n\n  if (!version_ok) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_WRONG_VERSION_NUMBER);\n    *out_alert = SSL_AD_PROTOCOL_VERSION;\n    return ssl_open_record_error;\n  }', 'explanation': 'This segment verifies that the version chosen by the server is acceptable. In the event that it is not acceptable, it sets the alert to protocol_version and aborts the handshake, directly implementing the RFC specification requirement.'}}]","The function contains explicit logic to check the protocol version and, if the version is not acceptable (i.e., does not meet expectations), it aborts the handshake by issuing a protocol_version alert. This matches the specific spec constraint which mandates that the handshake must be aborted with a 'protocol_version' alert when an unsupported version is encountered.",success,
11191,tls_open_record,"A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ""unexpected_message"" alert.",6,Fully Matches,"[{'C1': {'code': 'if (type != SSL3_RT_HANDSHAKE && tls_has_unprocessed_handshake_data(ssl)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_RECORD);\n    *out_alert = SSL_AD_UNEXPECTED_MESSAGE;\n    return ssl_open_record_error;\n  }', 'explanation': 'This code segment checks if a record is received while there is still unprocessed handshake data (i.e., the handshake messages are arriving in an unexpected order) and then aborts the handshake by triggering an unexpected_message alert, which directly implements the specification requirement.'}}]","The function explicitly verifies that non-handshake messages do not interleave with expected handshake messages by checking tls_has_unprocessed_handshake_data(ssl). When such a condition is detected, it sets the alert to SSL_AD_UNEXPECTED_MESSAGE and returns an error, thereby fully addressing the RFC specification that requires an unexpected handshake message to abort the handshake.",success,
11191,tls_open_record,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'A1': {'code': 'if (ssl->s3->skip_early_data &&                  \n      ssl->s3->aead_read_ctx->is_null_cipher() &&  \n      type == SSL3_RT_APPLICATION_DATA) {\n    return skip_early_data(ssl, out_alert, *out_consumed);\n  }', 'explanation': 'This code explicitly checks whether early data should be skipped (i.e. not processed/resend) when a second ClientHello is expected after rejecting 0RTT. By invoking the skip_early_data function, it ensures that early data is not automatically retransmitted, in line with the RFC requirement.'}}]","The provided function contains a clear branch that detects early data based on the ssl->s3->skip_early_data flag and avoids automatically processing/resending it by calling skip_early_data. This directly implements the intent of the spec ('A TLS implementation SHOULD NOT automatically resend early data'), so the function fully meets the constraint within its own logic.",success,
11191,tls_open_record,"Specifically, if the server fails to decrypt a 0-RTT record following an accepted ""early_data"" extension, it MUST terminate the connection with a ""bad_record_mac"" alert as per Section 5.2.",154,Fully Matches,"[{'C1': {'code': 'if (!ssl->s3->aead_read_ctx->Open(\n          out, type, version, ssl->s3->read_sequence, header,\n          Span(const_cast<uint8_t *>(CBS_data(&body)), CBS_len(&body)))) {\n    if (ssl->s3->skip_early_data && !ssl->s3->aead_read_ctx->is_null_cipher()) {\n      ERR_clear_error();\n      return skip_early_data(ssl, out_alert, *out_consumed);\n    }\n\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n    *out_alert = SSL_AD_BAD_RECORD_MAC;\n    return ssl_open_record_error;\n  }', 'explanation': ""This segment ensures that if decryption (including of 0-RTT records following early_data) fails, the function either skips the early data or, as required by the RFC, terminates the connection by setting the 'bad_record_mac' alert.""}}, {'A1': {'code': 'OPENSSL_PUT_ERROR(SSL, SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n*out_alert = SSL_AD_BAD_RECORD_MAC;\nreturn ssl_open_record_error;', 'explanation': 'On a decryption failure, the function sets the alert value to SSL_AD_BAD_RECORD_MAC and returns an error, thereby fulfilling the action of terminating the connection with the specified alert.'}}]","The function contains explicit logic to check for decryption failure in the record processing path. When decryption fails — including in the context of early data (0-RTT) — the function either skips the early data (if applicable) or sets the alert to 'bad_record_mac' and returns an error. This behavior directly implements the RFC requirement to terminate the connection with a 'bad_record_mac' alert on a decryption failure, thereby fully matching the provided specification constraint.",success,
11191,tls_open_record,"If the server chooses to accept the ""early_data"" extension, then it MUST comply with the same error-handling requirements specified for all records when processing early data records.",153,Partially Matches,"[{'C1': {'code': 'if (ssl->s3->skip_early_data &&                  \n      ssl->s3->aead_read_ctx->is_null_cipher() &&  \n      type == SSL3_RT_APPLICATION_DATA) {\n    return skip_early_data(ssl, out_alert, *out_consumed);\n  }', 'explanation': 'This block checks if the early_data flag is set and, if so, diverts processing to a helper (skip_early_data) that handles early data records. This indicates an intention to process early data with error‐handling similar to normal records. However, while the branch exists, it does not visibly duplicate all regular record error‐handling in its own code but instead offloads to another function, making the implementation only partially self-contained.'}}]","The RFC requires that if early_data is accepted, then the error-handling for early data records must follow the same requirements as for other records. In the function, there is an explicit check for early_data (via the skip_early_data flag) and a corresponding branch that calls skip_early_data() when the record is identified as early data. This indicates that the function attempts to handle early data records' errors similarly. However, since the detailed error-handling logic is delegated to skip_early_data() rather than being fully implemented within this function, the code only partially meets the requirement when considered in isolation.",success,
11192,do_seal_record,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Does Not Match,[],"The provided function is responsible for constructing and sealing TLS records by computing header values, ciphertext lengths, and invoking the AEAD SealScatter method. Although it queries for a suffix length via a call to aead->SuffixLen (which might be used internally to append extra bytes), there is no explicit logic in the function that chooses to pad the TLSCiphertext record in accordance with the RFC specification. Moreover, the function does not implement any handling related to the second context (absolute-form request-target Host header handling). Because the function defers any padding behavior to underlying methods and does not visibly implement the optional padding decision itself, it does not meet the specification constraints solely by its own internal code.",success,
11192,do_seal_record,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Fully Matches,"[{'C1': {'code': 'if (!aead->is_null_cipher() && ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    // TLS 1.3 hides the actual record type inside the encrypted data.\n    extra_in = &type;\n    extra_in_len = 1;\n}\n...\nif (extra_in_len) {\n    out_prefix[0] = SSL3_RT_APPLICATION_DATA;\n} else {\n    out_prefix[0] = type;\n}', 'explanation': ""The RFC specifies that values in the obsolete_RESERVED ranges must not be offered or negotiated in TLS 1.3. The code checks if the protocol version is TLS1.3 (and the cipher is not a null cipher) and then, regardless of the input 'type' (which might be in the obsolete_RESERVED range), it forces the record type in the record header to SSL3_RT_APPLICATION_DATA. This ensures that any obsolete_RESERVED value is not exposed or negotiated in TLS 1.3.""}}]","The function examines the protocol version and, for TLS 1.3, deliberately hides the actual record type (which could potentially be within the obsolete_RESERVED ranges) by setting it to SSL3_RT_APPLICATION_DATA. This logic directly implements the RFC requirement that obsolete_RESERVED values MUST NOT be offered or negotiated by TLS 1.3 implementations, thereby fully matching the specified constraint.",success,
11192,do_seal_record,The value of TLSCiphertext.legacy_record_version is included in the additional data for deprotection but MAY otherwise be ignored or MAY be validated to match the fixed constant value,373,Fully Matches,"[{'C1': {'code': 'uint16_t record_version = tls_record_version(ssl);\nout_prefix[1] = record_version >> 8;\nout_prefix[2] = record_version & 0xff;', 'explanation': 'The code computes the legacy record version using tls_record_version(ssl) and places it into the header (out_prefix bytes 1 and 2). This ensures that the TLSCiphertext.legacy_record_version is included as additional data for deprotection, which complies with the spec that it MAY be ignored or validated.'}}]","The function constructs the TLS record header by including the legacy_record_version in the header via out_prefix[1] and out_prefix[2]. The RFC requirement that this value be included in the additional data for deprotection is thus visibly addressed here. Since the RFC permits either ignoring the value or validating it against a fixed constant, the function's approach of simply including the version without further validation fully meets the specification.",success,
11192,do_seal_record,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function 'do_seal_record' handles sealing of TLS records using an AEAD context. It does not contain any logic that explicitly addresses the RFC requirement to not use the Truncated HMAC extension. There is no code segment that checks for or disables Truncated HMAC, nor does it mention HMAC at all, meaning that none of the spec constraints (e.g., pertaining to truncated HMAC) are visibly implemented within this function.",success,
11192,do_seal_record,Note that Application Data records MUST NOT be written to the wire unprotected (see Section 2 for details).,290,Fully Matches,"[{'C1': {'code': 'if (!aead->is_null_cipher() && ssl_protocol_version(ssl) >= TLS1_3_VERSION) {\n    // TLS 1.3 hides the actual record type inside the encrypted data.\n    extra_in = &type;\n    extra_in_len = 1;\n  }', 'explanation': 'This segment checks that when a non-null cipher is used (i.e. when encryption is in effect) and the protocol is TLS 1.3, the record type is embedded as extra data. This hides the actual record type inside the encrypted payload so that application data is not sent unprotected.'}}, {'A1': {'code': 'if (!aead->SealScatter(out_prefix + SSL3_RT_HEADER_LENGTH, out, out_suffix,\n                           out_prefix[0], record_version, ssl->s3->write_sequence,\n                           header, in, in_len, extra_in, extra_in_len)) {\n    return false;\n  }', 'explanation': 'This call to SealScatter encrypts the record (including the application data) before writing it to the wire. It embodies the action of ensuring the data is protected, thereby meeting the RFC requirement that application data records MUST NOT be written unprotected.'}}]","The function do_seal_record directly addresses the RFC requirement that application data records must not be sent unprotected. It conditionally embeds the record type within the encrypted data for TLS 1.3 and then uses an AEAD SealScatter call to encrypt the record. These measures ensure that application data is always written in a protected, encrypted form, thus fulfilling both the condition and the action dictated by the specification.",success,
11195,tls_seal_scatter_record,"In other words, a record with an Alert type MUST contain exactly one message.",282,Does Not Match,[],"The provided function is concerned with encrypting and possibly splitting TLS records for application data (SSL3_RT_APPLICATION_DATA) based on record splitting logic. It does not contain any code that checks or enforces that an Alert record contains exactly one message as specified by the RFC. There is no condition or check in the function addressing record type 'Alert' or validating the number of messages for an Alert record. Therefore, none of the labeled spec constraints (such as C1, A1, etc.) appear to be implemented within this function.",success,
11195,tls_seal_scatter_record,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Does Not Match,[],"The RFC requirement specifically mandates that alert messages MUST NOT be fragmented (nor coalesced) across TLSPlaintext records. The function tls_seal_scatter_record only applies record splitting logic when the record type is SSL3_RT_APPLICATION_DATA, and for other types (such as alerts) it simply calls do_seal_record without any additional handling. There is no visible logic within the function that explicitly ensures alert messages are not fragmented or coalesced, so the function does not implement the specified RFC constraints within its own code.",success,
11195,tls_seal_scatter_record,-Handshake messages MUST NOT be interleaved with other record types.,275,Does Not Match,[],"The RFC specification requires that handshake messages MUST NOT be interleaved with other record types. The provided function, tls_seal_scatter_record, focuses on application data record handling and splitting logic (as seen in the condition checking 'if (type == SSL3_RT_APPLICATION_DATA)' and subsequent record splitting), but it does not contain any logic to detect or prevent handshake messages from being interleaved with other record types. Therefore, within the code of this function itself, there is no implementation addressing the specified RFC constraint.",success,
11195,tls_seal_scatter_record,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification prohibits the use of the Truncated HMAC extension for AEAD algorithms. In the provided function, there is no logic checking for or preventing the use of the Truncated HMAC extension. The function is focused on record sealing and splitting for AEAD ciphers (evidenced by calls to functions like do_seal_record and assertions on the explicit nonce length), but it does not address the specific requirement outlined in the RFC. Therefore, there is no visible code segment within this function that implements or enforces the constraint against using the Truncated HMAC extension.",success,
11196,tls_seal_record,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Partially Matches,"[{'A1': {'code': 'size_t suffix_len;\nif (!tls_seal_scatter_suffix_len(ssl, &suffix_len, type, in_len)) {\n    return false;\n}\n...\n*out_len = prefix_len + in_len + suffix_len;', 'explanation': 'The RFC states that when generating a TLSCiphertext record, implementations MAY choose to pad. In this function, the call to tls_seal_scatter_suffix_len(…) retrieves a suffix length that is added to the record. This suffix can serve as padding. Although the decision-making (i.e. whether to pad or not) is delegated to a helper function, the function itself visibly reserves space (via suffix_len) for optional padding as allowed by the RFC.'}}]","The function tls_seal_record assembles a TLSCiphertext record by computing a prefix, copying the body, and adding a suffix determined via a helper function. The RFC requirement is that implementations MAY choose to pad when generating the record. By obtaining and applying a suffix length (which may correspond to padding), the function indirectly supports optional padding. However, the logic for deciding how much—or even whether—to pad is handled externally, and no explicit reference is made to any HTTP server behavior from the provided sr_context. As only part of the RFC constraint (the padding aspect) is visibly implemented here, the overall result is that the function partially matches the specification.",success,
11197,ssl_process_alert,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (in.size() != 2) {\n    *out_alert = SSL_AD_DECODE_ERROR;\n    OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_ALERT);\n    return ssl_open_record_error;\n  }', 'explanation': ""This segment checks the received message length. If the length is not exactly 2 (i.e., it extends beyond the expected boundary), it sets the alert to 'decode_error' and terminates the connection. This directly implements the RFC requirement that malformed messages (e.g., with out-of-range length) result in a decode_error alert.""}}]","The function directly verifies a fundamental syntactic rule from the RFC by checking if the alert record's length is exactly 2. If not, it configures the appropriate 'decode_error' alert and terminates processing. This behavior aligns with the spec condition that peers must terminate the connection with a decode_error alert upon receiving improperly parsed messages, thus fully matching the specified requirement.",success,
11197,ssl_process_alert,"Either party MAY initiate a close of its write side of the connection by sending a ""close_notify"" alert.",315,Fully Matches,"[{'C1': {'code': 'if (alert_level == SSL3_AL_WARNING) {\n    if (alert_descr == SSL_AD_CLOSE_NOTIFY) {\n      ssl->s3->read_shutdown = ssl_shutdown_close_notify;\n      return ssl_open_record_close_notify;\n    }\n    ...\n}', 'explanation': 'This segment checks if the incoming alert is a warning and specifically if it is a close_notify alert. It then marks the connection state (read_shutdown) as having received a close_notify, thereby implementing the graceful shutdown as specified.'}}]","The provided function processes incoming alert records and explicitly handles the close_notify alert by updating the connection state, which directly addresses the specification's requirement that a close_notify alert may be used to gracefully close a connection. All logic required to handle the receipt of a close_notify alert (i.e., condition C1 and the associated action) is contained within this function.",success,
11198,SSL_max_seal_overhead,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The provided function, SSL_max_seal_overhead, computes the maximum overhead for record sealing in TLS/DTLS, adjusting for the header length, AEAD overhead, TLS 1.3 extra byte, and possible record splitting. However, there is no logic within this function that checks for or prevents the use of the Truncated HMAC extension as required by the spec. Consequently, the function does not address the spec constraint regarding the Truncated HMAC extension.",success,
11201,dtls1_set_read_state,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, dtls1_set_read_state, is responsible for setting the read state and handling encryption context transitions, primarily focusing on epoch transitions and cipher context initialization for DTLS. It does not contain any logic that checks or filters out RC4 cipher suites, which is a requirement per the RFC specification. The code does not visibly address any condition or action related to ensuring that RC4 cipher suites are not offered or negotiated, and therefore does not implement the specified RFC constraint within this function.",success,
11201,dtls1_set_read_state,-Handshake messages MUST NOT be interleaved with other record types.,275,Fully Matches,"[{'C1': {'code': 'if (dtls_has_unprocessed_handshake_data(ssl)) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_EXCESS_HANDSHAKE_DATA);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);\n    return false;\n}', 'explanation': 'This segment ensures that if there is any unprocessed handshake data present (i.e. handshake messages left over), the function aborts the state change by returning an error. This directly enforces the RFC requirement that handshake messages must not be interleaved with other record types.'}}]","The function explicitly checks for pending handshake data by calling dtls_has_unprocessed_handshake_data(ssl) and aborts if such data exists. This prevents the possibility of interleaving handshake messages with other record types, which is exactly what the RFC specification requires.",success,
11201,dtls1_set_read_state,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The code function dtls1_set_read_state does not include any checks or logic to ensure that the Truncated HMAC extension is not used, which is the requirement specified by the RFC. The function focuses on setting the DTLS read state and managing AEAD contexts and epochs, but it does not implement any measures that correspond to the RFC constraint regarding the truncated HMAC extension. As such, within the logic of the function itself, no aspect of the RFC requirement is addressed.",success,
11202,dtls1_set_write_state,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification requires that implementations must not use the Truncated HMAC extension. In the provided function_body, there is no evidence that it checks for or avoids the use of the Truncated HMAC extension. There is no logic or code segment addressing this specific constraint within the function; thus, the code does not visibly implement the RFC specification regarding the Truncated HMAC extension.",success,
11202,dtls1_set_write_state,"This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between",402,Does Not Match,[],"The provided function dtls1_set_write_state does not implement any logic related to the HKDF ordering requirement specified in the RFC. There is no evidence in the code of any use of HKDF-Extract or HKDF-Expand, nor is there any mechanism to ensure that an output of HKDF-Extract is not reused as an input to another HKDF-Extract without an intervening HKDF-Expand. The function mainly handles DTLS write epoch state management, setting up record numbers, and configuring record number encrypters, which is unrelated to the HKDF constraint.",success,
11220,dtls1_get_incoming_message,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (frag->type != msg_hdr->type ||  \n    frag->msg_len() != msg_hdr->msg_len) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_FRAGMENT_MISMATCH);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return NULL;\n}', 'explanation': ""This segment checks whether the new handshake fragment is consistent with prior fragments. If a mismatch is detected—implying the message is semantically invalid—it sets the alert to SSL_AD_ILLEGAL_PARAMETER and aborts processing, effectively terminating the connection, which aligns with the RFC requirement to use an 'illegal_parameter' alert when an invalid message is received.""}}]","The function implements a check for semantic validity by comparing the fragment's type and length with previously received data. When a mismatch is found, it signals an illegal_parameter alert and returns NULL, indicating connection termination in response to a semantically invalid message. However, the RFC example includes other potential invalid parameters (e.g., invalid DHE share values or enum errors), and this function only accounts for one type of semantic inconsistency. Thus, while it addresses part of the RFC requirement, the implementation is only partial.",success,
11221,dtls1_process_handshake_fragments,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Partially Matches,"[{'C1': {'code': 'if (!dtls1_parse_fragment(&cbs, &msg_hdr, &body)) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_HANDSHAKE_RECORD);\n      *out_alert = SSL_AD_DECODE_ERROR;\n      return false;\n    }', 'explanation': 'This snippet sets the alert to decode_error when the parsing of a handshake fragment fails, addressing part of the spec requirement that a message failing syntax parsing should lead to a decode_error alert.'}}]","The RFC specifies that any message that cannot be parsed—either because its syntax is incorrect or because it contains an out‐of‐range length—must result in terminating the connection with a decode_error alert. Within the function, if dtls1_parse_fragment fails, a decode_error alert is correctly set. However, when the fragment's length fields are out-of-range (i.e., when frag_off > msg_len or frag_len > msg_len - frag_off), the function sets an SSL_AD_ILLEGAL_PARAMETER alert instead of a decode_error alert. Thus, while the function addresses part of the requirement, it does not fully implement the RFC constraint as specified.",success,
11222,dtls1_open_handshake,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'case SSL3_RT_CHANGE_CIPHER_SPEC:\n      if (record.size() != 1u || record[0] != SSL3_MT_CCS) {\n        OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_CHANGE_CIPHER_SPEC);\n        *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n        return ssl_open_record_error;\n      }', 'explanation': 'This segment checks a ChangeCipherSpec record for semantic validity. When the record does not consist of exactly one byte equal to SSL3_MT_CCS, the function sets the alert to SSL_AD_ILLEGAL_PARAMETER and returns an error, thereby terminating the connection as required by the RFC for semantically invalid messages.'}}]","The RFC requires that upon receiving a syntactically correct but semantically invalid message, a connection must be terminated with an 'illegal_parameter' alert. In this function, the case handling for SSL3_RT_CHANGE_CIPHER_SPEC contains logic that does exactly this for ChangeCipherSpec records. However, the function does not handle all potential cases of semantically invalid messages (for example, those involving other record types like handshake or application data), and so only partially addresses the overall RFC constraint.",success,
11222,dtls1_open_handshake,"An implementation which receives any other change_cipher_spec value or which receives a protected change_cipher_spec record MUST abort the handshake with an ""unexpected_message"" alert.",269,Partially Matches,"[{'C1': {'code': 'if (record_number.epoch() != 0) {\n        OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_RECORD);\n        *out_alert = SSL_AD_UNEXPECTED_MESSAGE;\n        return ssl_open_record_error;\n      }', 'explanation': ""The code checks if a ChangeCipherSpec record is protected (i.e. its record_number.epoch() is not 0) and aborts the handshake with an 'unexpected_message' alert. This fulfills the spec requirement for handling protected ChangeCipherSpec records.""}}]","The function attempts to implement the RFC requirement by verifying the ChangeCipherSpec records. It correctly handles the case when a protected ChangeCipherSpec (non-zero epoch) is received and aborts with an 'unexpected_message' alert. However, for the case of receiving any other ChangeCipherSpec value (e.g. with an incorrect record size or value), the function aborts using an 'illegal_parameter' alert instead of an 'unexpected_message' alert as specified. Therefore, only part of the spec constraints is fully addressed within this function.",success,
11222,dtls1_open_handshake,"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",272,Fully Matches,"[{'C1': {'code': 'default:\n      OPENSSL_PUT_ERROR(SSL, SSL_R_UNEXPECTED_RECORD);\n      *out_alert = SSL_AD_UNEXPECTED_MESSAGE;\n      return ssl_open_record_error;', 'explanation': ""This code segment handles any record type not specifically implemented in the switch-case. By logging an unexpected record error, setting the alert to SSL_AD_UNEXPECTED_MESSAGE, and returning an error, it enforces that any unexpected record type (per the spec) terminates the connection with an 'unexpected_message' alert.""}}]","The provided function explicitly checks the record type and in the default case — when the record type is unexpected — it logs an error, sets the alert to SSL_AD_UNEXPECTED_MESSAGE, and returns an error, thereby directly and visibly implementing the requirement from the RFC spec. This makes the function fully match the specified condition and its corresponding action.",success,
11222,dtls1_open_handshake,-Handshake messages MUST NOT be interleaved with other record types.,275,Partially Matches,[],"The RFC requires that ‘Handshake messages MUST NOT be interleaved with other record types.’ In the function, we see a switch statement that handles different record types separately: handshake records are processed via dtls1_process_handshake_fragments, while application data and change cipher spec records are either discarded or trigger errors. This indicates an attempt to manage different record types in isolation. However, the function does not explicitly check or enforce that handshake records are not interleaved with non-handshake records over the course of a connection (i.e. it does not verify ordering or ensure that no other types occur between handshake messages). In other words, while it distinguishes between record types, it does not fully implement the constraint of preventing interleaving. Therefore, based solely on the logic present in this function body (and not in its dependencies), the implementation only partially matches the specified RFC constraint.",success,
11236,seal_next_record,"Handshake messages MAY be coalesced into a single TLSPlaintext record or fragmented across several records, provided that:",274,Fully Matches,"[{'C1': {'code': '  // Pack as many handshake fragments into one record as we can. We stage the\n  // fragments in the output buffer, to be sealed in-place.\n  const bool allow_multiple_messages = first_msg.epoch != 0;\n  ...\n  while (ssl->d1->outgoing_written < ssl->d1->outgoing_messages.size()) {\n    const auto &msg = ssl->d1->outgoing_messages[ssl->d1->outgoing_written];\n    if (msg.epoch != first_msg.epoch || msg.is_ccs) {\n      should_continue = true;\n      break;\n    }\n    ...\n  }', 'explanation': 'This segment checks whether multiple handshake messages can be packed into a single record (when not in epoch 0) and enters a loop to attempt to coalesce fragments, directly addressing the RFC condition that handshake messages MAY be coalesced or fragmented.'}}, {'A1': {'code': '    for (;;) {\n      auto range = msg.acked.NextUnmarkedRange(ssl->d1->outgoing_offset);\n      if (range.empty()) {\n        ssl->d1->outgoing_offset = 0;\n        ssl->d1->outgoing_written++;\n        break;\n      }\n      size_t capacity = fragments.size() - CBB_len(&cbb);\n      if (capacity < DTLS1_HM_HEADER_LENGTH + 1) {\n        goto packet_full;\n      }\n      size_t todo = std::min(range.size(), capacity - DTLS1_HM_HEADER_LENGTH);\n      ...\n      if (!CBB_add_u8(&cbb, hdr.type) ||\n          !CBB_add_u24(&cbb, hdr.msg_len) ||\n          !CBB_add_u16(&cbb, hdr.seq) ||\n          !CBB_add_u24(&cbb, range.start) ||\n          !CBB_add_u24_length_prefixed(&cbb, &child) ||\n          !CBB_add_bytes(&child, frag.data(), frag.size()) ||\n          !CBB_flush(&cbb)) {\n        OPENSSL_PUT_ERROR(SSL, ERR_R_INTERNAL_ERROR);\n        return seal_error;\n      }\n', 'explanation': 'This part manages the fragmentation of a handshake message by iterating over the unacknowledged ranges, assembling each fragment with appropriate headers and content, thereby implementing the action of fragmenting handshake messages when the complete message cannot fit into a single record.'}}]","The function seal_next_record addresses the RFC requirement by implementing logic to either coalesce multiple handshake messages into one TLSPlaintext record or fragment a handshake message into multiple fragments. Specifically, it determines when multiple messages can be packed (via the 'allow_multiple_messages' flag) and uses a loop to process and fragment handshake messages into a record buffer, checking capacity and preparing each fragment with its proper header. This demonstrates that the code function visibly implements the specified RFC constraints on fragmenting and coalescing handshake messages.",success,
11236,seal_next_record,-Handshake messages MUST NOT be interleaved with other record types.,275,Fully Matches,"[{'C1': {'code': 'if (msg.epoch != first_msg.epoch || msg.is_ccs) {\n      // We can only pack messages if the epoch matches. There may be more room in the packet, so tell the caller to keep going.\n      should_continue = true;\n      break;\n    }', 'explanation': 'This code segment ensures that during the message packing process, only messages from the same epoch and not of a different record type (e.g., ChangeCipherSpec indicated by msg.is_ccs) are packed into a single record. This behavior prevents the interleaving of handshake messages with other record types as required by the RFC.'}}]","The function explicitly checks that each outgoing message has the same epoch as the first message and is not a CCS record. By breaking out of the loop when a different epoch or a non-handshake record is encountered, it prevents interleaving handshake messages with other record types. This visible implementation directly addresses the RFC specification that handshake messages must not be interleaved with other record types.",success,
11236,seal_next_record,"That is, if a handshake message is split over two or more records, there MUST NOT be any other records between them.",276,Fully Matches,"[{'C1': {'code': '...\n    for (;;) {\n      auto range = msg.acked.NextUnmarkedRange(ssl->d1->outgoing_offset);\n      if (range.empty()) {\n        // Advance to the next message.\n        ssl->d1->outgoing_offset = 0;\n        ssl->d1->outgoing_written++;\n        break;\n      }\n      size_t todo = std::min(range.size(), capacity - DTLS1_HM_HEADER_LENGTH);\n      ...\n      ssl->d1->outgoing_offset = range.start + todo;\n      if (todo < range.size()) {\n        // The packet was the limiting factor.\n        goto packet_full;\n      }\n    }\n...\n    // When a handshake message is not completely sent, the same message is retained for the next record.\n', 'explanation': ""This code checks how much of the current handshake message can be placed in the record. If the handshake message cannot be completed (i.e. when 'todo < range.size()'), the function finishes the record (via 'goto packet_full') without advancing to the next handshake message. In subsequent calls, the same message (via the unchanged ssl->d1->outgoing_written and ssl->d1->outgoing_offset) is processed, ensuring that if a handshake message is split over multiple records, no other record intervenes.""}}]","The provided function builds DTLS records by packing handshake message fragments and is careful not to advance to the next message until the current handshake message is completely transmitted. This behavior—keeping track of the outgoing offset and refraining from mixing different messages when a handshake message is only partially sent—implements the RFC requirement that if a handshake message is split over two or more records, there must not be any intervening records. Thus, within the function itself, the relevant spec constraint is fully addressed.",success,
11238,send_flight,"When generating a TLSCiphertext record, implementations MAY choose to pad.",299,Does Not Match,[],"The RFC specification requires that implementations MAY choose to pad when generating a TLSCiphertext record. In the provided send_flight function, there is no visible logic that implements or decides upon adding padding to the generated TLSCiphertext records. The function focuses on tasks such as checking shutdown status, validating the BIO, updating the MTU, and sending packets. There is no conditional branch or mechanism that corresponds to the optional padding behavior. Therefore, the function does not meet any condition (such as C1 or similar) that explicitly addresses the RFC’s specification regarding TLSCiphertext padding.",success,
11241,send_ack,"Values within ""obsolete_RESERVED"" ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations.",366,Does Not Match,[],"The provided function 'send_ack' is focused on sending ACK messages in TLS 1.3. It does include an assert to verify that the protocol version is TLS1.3 or greater, but there is no logic within the function that checks for or prohibits values within the 'obsolete_RESERVED' ranges as specified by the RFC. Therefore, this function does not visibly implement the RFC constraint regarding obsolete_RESERVED values.",success,
11241,send_ack,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Fully Matches,"[{'C1': {'code': '/* The function does not invoke any logic for the Truncated HMAC extension. Instead, it uses dtls_seal_record with AEAD algorithms and there is no reference to HMAC truncation. */', 'explanation': 'The RFC requires implementations MUST NOT use the Truncated HMAC extension. The code in send_ack does not call or enable any truncated HMAC functionality and instead relies solely on AEAD-based record sealing, thereby complying with the spec.'}}]","The provided send_ack function does not include any operations that enable or use the Truncated HMAC extension. It uses dtls_seal_record to seal records with AEAD algorithms and does not contain any logic pertaining to HMAC truncation. As the specification strictly requires that the truncated HMAC extension must not be used, and since the function entirely avoids it, the function is fully compliant with the specified RFC requirement.",success,
11241,send_ack,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Does Not Match,[],"The RFC specification provided concerns the treatment of alert messages—specifically, that alert messages must not be fragmented across records and that multiple alerts must not be coalesced into a single TLSPlaintext record. The function send_ack, however, is focused on constructing and sending ACK messages, ensuring they fit within the available MTU and sorting record numbers, but it does not handle any logic related to alert message fragmentation or coalescing. As such, none of the internal logic in the function corresponds to any condition (e.g., C1) or action (e.g., A1) associated with the specified RFC constraint.",success,
11244,SSL_SESSION_to_bytes_full,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The provided function 'SSL_SESSION_to_bytes_full' serializes an SSL session into ASN.1 format but does not include any checks or conditional logic regarding the use of the OpenPGP certificate type with TLS 1.3 as specified in RFC6091. There is no logic that inspects the certificate type or the TLS version to enforce that the OpenPGP certificate type MUST NOT be used with TLS 1.3. Therefore, the function does not implement the RFC constraint.",success,
11244,SSL_SESSION_to_bytes_full,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function is solely responsible for serializing an SSL session into bytes and does not contain any logic to address the TLS RFC specification which states that a TLS implementation SHOULD NOT automatically resend early data. There is no conditional logic or mechanism within this function that prevents the automatic retransmission of early data, and thus none of the labeled conditions or actions (e.g., C1, A1) appear to be implemented here.",success,
11251,SSL_SESSION_parse,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function is responsible for parsing an SSL session from an ASN.1 encoded input. Although it processes fields related to early data (such as ticket_max_early_data, early_alpn, and quic_early_data_context), it does not include any logic that directly enforces the RFC specification stating that a TLS implementation SHOULD NOT automatically resend early data. There is no mechanism in the function that determines or prevents automatic retransmission of early data. Therefore, no part of the function visibly addresses the labeled condition or action related to the spec constraint.",success,
11258,GetClientHello,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'A1': {'code': 'if (!SSL_parse_client_hello(ssl, out_client_hello, CBS_data(&out_msg->body), CBS_len(&out_msg->body))) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    return false;\n}', 'explanation': ""This segment checks if the client hello message cannot be parsed correctly, and if so, it immediately calls ssl_send_alert with SSL_AD_DECODE_ERROR and terminates the processing by returning false. This directly implements the RFC requirement to terminate the connection with a 'decode_error' alert when a message cannot be parsed.""}}]","The function attempts to parse the client hello message. Upon a parsing failure, it sends a decode_error alert, thereby ensuring that unparseable messages trigger the correct error handling as specified in the RFC. All required logic for this constraint is contained within the function, so it fully meets the spec.",success,
11258,GetClientHello,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The RFC specification requires that SSL2 not be negotiated under any circumstances. In the provided function, there is no explicit logic that checks for or rejects SSL2 handshakes. The function merely handles the ClientHello message by checking an internal buffer condition and invoking methods like get_message and SSL_parse_client_hello without any visible enforcement of the SSL2 prohibition. Therefore, the function does not visibly address any of the spec constraints (e.g., a condition like C1 stating that SSL2 must not be negotiated) solely within its code body.",success,
11258,GetClientHello,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (!SSL_parse_client_hello(ssl, out_client_hello, CBS_data(&out_msg->body),\n                              CBS_len(&out_msg->body))) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n    return false;\n  }', 'explanation': 'This code segment checks if parsing the ClientHello fails and, if it does, sends a decode_error alert and aborts the handshake, directly implementing the RFC requirement.'}}]","The GetClientHello function explicitly checks the result of SSL_parse_client_hello. If parsing fails, it immediately sends a 'decode_error' alert and aborts the handshake by returning false. This direct handling satisfies the specification requirement that the handshake must be aborted in case of a decode error, thus fully matching the constraint.",success,
11258,GetClientHello,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided code function, SSL_HANDSHAKE::GetClientHello, is focused on retrieving and parsing the ClientHello message and does not include any logic that addresses the spec constraint which states that ""Application Data MUST NOT be sent prior to sending the Finished message."" There is no check or enforcement in this function to ensure that application data is not sent before the Finished message, so the constraint is not visibly implemented in the target code function.",success,
11260,ssl_check_message_type,"If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an ""unexpected_message"" alert.",272,Fully Matches,"[{'C1': {'code': 'if (msg.type != type) {', 'explanation': 'The function checks if the received message type is not equal to the expected type (i.e. an unexpected record type is detected), which directly addresses the condition in the RFC.'}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_UNEXPECTED_MESSAGE);', 'explanation': ""On detecting the unexpected record type, the function sends an alert ('unexpected_message') to terminate the connection in accordance with the RFC.""}}]","The provided function inspects the type of the SSL message. If the type does not match the expected type, it immediately sends an 'unexpected_message' alert and logs the error before returning false. This logic directly implements the specified RFC requirement by both recognizing the condition (unexpected record type) and taking the required action (terminating the connection with the appropriate alert), thereby fully meeting the spec constraint.",success,
11264,ssl_parse_extensions,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'A1': {'code': 'if (found->present) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DUPLICATE_EXTENSION);\n    *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n    return false;\n}', 'explanation': ""The RFC requires that when a semantically invalid message is encountered the connection is terminated with an 'illegal_parameter' alert. This code segment detects a duplicate extension (a semantic error) and sets the alert accordingly. However, it only covers this specific case and does not address other potential semantic errors (like an invalid enum or DHE share check) by itself.""}}]","The function attempts to implement part of the RFC's requirement by handling the specific case of duplicate extensions and triggering an 'illegal_parameter' alert, which aligns with part of the spec constraint. However, the RFC specifies termination for any semantically invalid message, whereas this function only visibly addresses a duplicate extension. Thus, the function only partially matches the full specification.",success,
11264,ssl_parse_extensions,"Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a ""decode_error"" alert",311,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16(&copy, &type) ||\n    !CBS_get_u16_length_prefixed(&copy, &data)) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_PARSE_TLSEXT);\n  *out_alert = SSL_AD_DECODE_ERROR;\n  return false;\n}', 'explanation': 'This code block explicitly checks whether the message can be parsed (by verifying that enough data exists to extract a uint16 value and its length‐prefixed data). If parsing fails, it sets the alert to SSL_AD_DECODE_ERROR and returns false, thereby terminating processing as required by the RFC when a message cannot be parsed.'}}]","The function directly implements the RFC requirement by checking for parsing errors and terminating the connection with a decode_error alert when such an error is encountered. The logic that verifies the message boundaries and handles out-of-range or malformed length values is contained entirely within this function, fully matching the intended spec constraint.",success,
11264,ssl_parse_extensions,There MUST NOT be more than one extension of the same type in a given extension block.,63,Fully Matches,"[{'C1': {'code': 'if (found->present) {\n      OPENSSL_PUT_ERROR(SSL, SSL_R_DUPLICATE_EXTENSION);\n      *out_alert = SSL_AD_ILLEGAL_PARAMETER;\n      return false;\n    }', 'explanation': ""This code segment verifies that no extension type appears more than once by checking if the extension has already been marked as 'present'. If it has, then it triggers an error and returns false. This directly implements the RFC requirement that there MUST NOT be more than one extension of the same type in a given extension block.""}}]","The function 'ssl_parse_extensions' iterates through all provided extensions, resets their state, parses each extension, and crucially checks for duplicates. The duplicate check (C1) is explicitly implemented by examining if an extension’s 'present' flag is already set, which is in direct compliance with the RFC specification regarding duplicate extensions. Thus, the function fully addresses the specified constraint.",success,
11264,ssl_parse_extensions,"If not, then it MUST abort the handshake with a ""decode_error"" alert.",27,Fully Matches,"[{'C1': {'code': 'if (!CBS_get_u16(&copy, &type) ||\n    !CBS_get_u16_length_prefixed(&copy, &data)) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_PARSE_TLSEXT);\n  *out_alert = SSL_AD_DECODE_ERROR;\n  return false;\n}', 'explanation': ""This segment implements the requirement from the spec that if the extension data cannot be properly decoded, the handshake must be aborted with a 'decode_error' alert.""}}]","The provided function checks the validity of the extension data and, upon a parsing failure, sets the alert to SSL_AD_DECODE_ERROR and aborts the handshake. This directly addresses the spec constraint which mandates aborting the handshake with a 'decode_error' alert when decoding fails. All relevant logic within this function is self-contained and meets the labeled constraint.",success,
11265,ssl_verify_peer_cert,"The phrases ""terminate the connection with an X alert"" and ""abort the handshake with an X alert"" mean that the implementation MUST send alert X if it sends any alert.",322,Does Not Match,[],"The provided function is dedicated to verifying peer certificates during a TLS handshake and handling certificate-related errors by sending alerts. It does call ssl_send_alert with various alert codes under error conditions. However, none of the logic in this function addresses the RFC’s requirements regarding HTTP connection handling (such as processing a ""close"" connection option, terminating the connection after a final response, or aborting the handshake with an X alert in the context of HTTP). The spec constraints are specific to the HTTP context and mandate actions upon receiving or sending a ""close"" connection option, which are not implemented here. Consequently, no part of the code function implements any of the labeled conditions or actions from the HTTP RFC specification.",success,
11265,ssl_verify_peer_cert,"In the rest of this specification, when the phrases ""terminate the connection"" and ""abort the handshake"" are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below.",321,Does Not Match,[],"The provided function, ssl_verify_peer_cert, is solely focused on verifying SSL peer certificates, including handling renegotiation and OCSP callbacks. It does not implement any logic related to server connection closure, such as processing a ""close"" connection option, sending a final response with that option, or terminating the connection after such a response. Therefore, none of the spec constraints regarding connection termination and handling of ""close"" connection options (as described in the spec context) are addressed within this function.",success,
11265,ssl_verify_peer_cert,All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message.,309,Fully Matches,"[{'C1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n... \nssl_send_alert(ssl, SSL3_AL_FATAL, alert);\n... \nssl_send_alert(ssl, SSL3_AL_FATAL, (cb_ret == 0 ? SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE : SSL_AD_INTERNAL_ERROR));', 'explanation': 'Every instance where an alert is sent in this function uses the fatal alert level (SSL3_AL_FATAL). This directly addresses the RFC requirement that all alerts must be sent with AlertLevel=fatal, regardless of other factors.'}}]","The provided function consistently issues alerts with the fatal alert level by invoking ssl_send_alert with SSL3_AL_FATAL in all error-handling cases (such as certificate changes, verification failures, and OCSP callback failures). This behavior shows that the function itself is attempting to meet the specification requirement that alerts must be sent as fatal. All necessary alert calls are implemented directly within the function, thereby fully matching the given RFC constraint.",success,
11265,ssl_verify_peer_cert,"Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p -1, or an invalid enum) MUST terminate the connection with an ""illegal_parameter"" alert.",312,Partially Matches,"[{'C1': {'code': 'if (sk_CRYPTO_BUFFER_num(prev_session->certs.get()) !=\n    sk_CRYPTO_BUFFER_num(hs->new_session->certs.get())) {\n  OPENSSL_PUT_ERROR(SSL, SSL_R_SERVER_CERT_CHANGED);\n  ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n  return ssl_verify_invalid;\n}\n\nfor (size_t i = 0; i < sk_CRYPTO_BUFFER_num(hs->new_session->certs.get()); i++) {\n  const CRYPTO_BUFFER *old_cert =\n      sk_CRYPTO_BUFFER_value(prev_session->certs.get(), i);\n  const CRYPTO_BUFFER *new_cert =\n      sk_CRYPTO_BUFFER_value(hs->new_session->certs.get(), i);\n  if (Span(CRYPTO_BUFFER_data(old_cert), CRYPTO_BUFFER_len(old_cert)) !=\n      Span(CRYPTO_BUFFER_data(new_cert), CRYPTO_BUFFER_len(new_cert))) {\n    OPENSSL_PUT_ERROR(SSL, SSL_R_SERVER_CERT_CHANGED);\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n    return ssl_verify_invalid;\n  }\n}', 'explanation': 'This segment verifies that during renegotiation the server certificate remains identical. If the certificate count or content differs (i.e. a semantic invalidity is detected), it terminates the connection by sending an alert with the value SSL_AD_ILLEGAL_PARAMETER, which aligns with the spec condition for handling semantically invalid messages.'}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);', 'explanation': ""This call is used in the code upon detection of a semantically invalid message (specifically in the certificate mismatch case) to force termination of the connection with the 'illegal_parameter' alert, as specified by the RFC.""}}]","The function includes logic to identify when a message (in this case a renegotiated peer certificate) is semantically invalid and then responds by sending an 'illegal_parameter' alert before terminating the connection. This behavior is visible in the code segments that compare the certificate chains. However, while one branch explicitly uses SSL_AD_ILLEGAL_PARAMETER for certificate mismatches, other semantic error cases (such as those arising from certificate chain verification via callbacks) may trigger alerts with different codes. Therefore, although the function does address the RFC requirement in part (for the specific case of certificate changes on renegotiation), it does not uniformly apply the 'illegal_parameter' alert in all semantically invalid scenarios. This results in a partial match with the specified constraints.",success,
11269,ssl_get_finished,"If the verification fails, the receiver MUST terminate the handshake with a ""decrypt_error"" alert.",231,Fully Matches,"[{'C1': {'code': 'if (!finished_ok) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECRYPT_ERROR);\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DIGEST_CHECK_FAILED);\n    return ssl_hs_error;\n  }', 'explanation': 'This segment checks if the Finished verification fails, which is the condition outlined in the RFC (i.e., if verification fails, the receiver must take corrective action).'}}, {'A1': {'code': 'ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECRYPT_ERROR);', 'explanation': ""This line terminates the handshake by sending the 'decrypt_error' alert, directly fulfilling the RFC requirement on action when verification fails.""}}]","The function implements the RFC requirement by first verifying the finished message; when verification fails, it sends a 'decrypt_error' alert and terminates the handshake, all within the function itself. This direct implementation of both the condition (verification failure) and the associated action (sending the decrypt_error alert) demonstrates that the function fully addresses the specified constraints.",success,
11269,ssl_get_finished,"Recipients of Finished messages MUST verify that the contents are correct and if incorrect MUST terminate the connection with a ""decrypt_error"" alert.",232,Fully Matches,"[{'C1': {'code': 'int finished_ok = CBS_mem_equal(&msg.body, finished, finished_len);\n#if defined(BORINGSSL_UNSAFE_FUZZER_MODE)\n  finished_ok = 1;\n#endif\nif (!finished_ok) {', 'explanation': ""This segment verifies that the contents of the Finished message match the expected MAC derived from the handshake transcript. It directly compares the message body to the computed 'finished' value, thereby checking message correctness.""}}, {'A1': {'code': 'if (!finished_ok) {\n    ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_DECRYPT_ERROR);\n    OPENSSL_PUT_ERROR(SSL, SSL_R_DIGEST_CHECK_FAILED);\n    return ssl_hs_error;\n}', 'explanation': ""Upon detection of an incorrect Finished message (when finished_ok is false), the code sends a 'decrypt_error' alert and terminates the handshake by returning an error code, precisely fulfilling the action requirement in the RFC.""}}]","The function 'ssl_get_finished' explicitly implements RFC requirements for processing Finished messages by verifying the message integrity and, if the verification fails, terminating the connection with a 'decrypt_error' alert. Both the condition for message correctness (C1) and the required action on failure (A1) are handled within this function.",success,
11270,ssl_send_finished,"Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",1,Does Not Match,[],"The provided function is responsible for constructing and sending the Finished handshake message (via code segments that generate the Finished MAC, log the secret, and build the handshake message). However, the specific RFC requirement—that application data MUST NOT be sent prior to sending the Finished message—is not addressed by any checks or logic within this function. There is no code here that prevents or verifies that application data is withheld until after the Finished message is sent. Consequently, this function by itself does not implement the spec constraint.",success,
11273,ssl_run_handshake,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Fully Matches,"[{'C1': {'code': 'case ssl_hs_read_end_of_early_data: {\n        if (ssl->s3->hs->can_early_read) {\n          // While we are processing early data, the handshake returns early.\n          *out_early_return = true;\n          return 1;\n        }\n        hs->wait = ssl_hs_ok;\n        break;\n      }', 'explanation': 'This section detects the receipt of early data and immediately returns (via *out_early_return) instead of automatically resending it, thus deferring the decision to the application.'}}, {'A1': {'code': 'case ssl_hs_early_return: {\n        if (!ssl->server) {\n          // On ECH reject, the handshake should never complete.\n          assert(ssl->s3->ech_status != ssl_ech_rejected);\n        }\n        *out_early_return = true;\n        hs->wait = ssl_hs_ok;\n        return 1;\n      }', 'explanation': 'This segment also handles early data by returning early and setting the out parameter, ensuring that the handshake does not automatically resend early data but instead informs the higher-level application to decide on retransmission.'}}]","The provided TLS handshake routine explicitly handles cases involving early data. In the ssl_hs_read_end_of_early_data and ssl_hs_early_return cases, it returns early and sets a flag (*out_early_return) rather than automatically retransmitting early data. This meets the specification requirement that a TLS implementation SHOULD NOT automatically resend early data and should let the application decide when retransmission is appropriate.",success,
11720,NextProtosAdvertisedCallback,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, NextProtosAdvertisedCallback, only handles next protocol negotiation advertisement logic (NPN). It does not contain any code that verifies, rejects, or otherwise handles the RC4 cipher suites as required by the RFC specification. Therefore, it does not address the spec constraint regarding disallowing RC4 cipher suites.",success,
11721,MessageCallback,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Fully Matches,"[{'C1': {'code': 'case SSL3_RT_ALERT:\n  if (len != 2) {\n    fprintf(stderr, ""Invalid alert.\\n"");\n    state->msg_callback_ok = false;\n    return;\n  }\n  char text[16];\n  snprintf(text, sizeof(text), ""alert %d %d\\n"", buf_u8[0], buf_u8[1]);\n  state->msg_callback_text += text;\n  return;', 'explanation': 'This snippet ensures that an alert message is exactly 2 bytes long. If the alert message is either fragmented (less than 2 bytes) or if multiple alert messages are coalesced (resulting in a length greater than 2 bytes), the function triggers an error. This directly implements the RFC requirement that alert messages must not be fragmented across records and that multiple alert messages must not be coalesced into a single TLSPlaintext record.'}}]","The function contains specific logic in the case for SSL3_RT_ALERT that checks whether the length of the alert message is exactly 2 bytes. This check directly enforces that an alert must be complete and not fragmented or combined with others, thereby addressing the entire RFC specification as provided. No other parts of the function obscure or contradict this check, so the function fully meets the provided RFC constraint regarding alert message fragmentation and coalescing.",success,
11721,MessageCallback,"In other words, a record with an Alert type MUST contain exactly one message.",282,Fully Matches,"[{'C1': {'code': 'case SSL3_RT_ALERT:\n  if (len != 2) {\n    fprintf(stderr, ""Invalid alert.\\n"");\n    state->msg_callback_ok = false;\n    return;\n  }', 'explanation': 'This segment explicitly ensures that if the record is of Alert type, its length must be exactly 2 bytes, which in the TLS protocol corresponds to a single alert message. This directly implements the constraint that a record with an Alert type MUST contain exactly one message.'}}]","The function 'MessageCallback' directly handles Alert records by verifying that the record length is exactly 2 bytes. Since a valid alert message is encoded in exactly 2 bytes (one for level and one for description), this check ensures that the record contains exactly one alert message. Thus, the function fully implements the specified RFC constraint within its own logic.",success,
11734,AsyncPrivateKeySign,"RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in ""signature_algorithms"".",228,Partially Matches,[],"The RFC requires that RSA signatures always use an RSASSA-PSS algorithm irrespective of the values present in signature_algorithms. In the function, there is logic to set RSASSA-PSS parameters (using RSA_PKCS1_PSS_PADDING and setting the salt length) but this only occurs when SSL_is_signature_algorithm_rsa_pss(signature_algorithm) returns true. This means the function configures RSASSA-PSS only when the signature algorithm explicitly indicates PSS rather than unconditionally enforcing PSS for all RSA signatures. Consequently, while the function does address the PSS configuration in one branch, it does not fully implement the RFC requirement in all cases, leading to a partially matching implementation.",success,
11737,AsyncTicketMaxOverhead,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Does Not Match,[],"The RFC specification disallows the use of the Truncated HMAC extension for AEAD algorithms. The function provided only calculates the maximum overhead by using EVP_AEAD_max_overhead and EVP_AEAD_nonce_length for the AES-128-GCM-SIV algorithm. There is no logic in the function that checks for or prevents the use of the Truncated HMAC extension. Thus, none of the specified conditions or actions (e.g., C1, A1) are addressed within the function's implementation.",success,
11738,AsyncTicketSeal,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Fully Matches,"[{'C1': {'code': 'static const uint8_t kKey[16] = {0};\nconst EVP_AEAD *aead = EVP_aead_aes_128_gcm_siv();\n... \nif (!EVP_AEAD_CTX_init(ctx.get(), EVP_aead_aes_128_gcm_siv(), kKey, sizeof(kKey), EVP_AEAD_DEFAULT_TAG_LENGTH, nullptr) ||\n      !EVP_AEAD_CTX_seal(ctx.get(), out_span.data(), &len, out_span.size(),\n                         nonce.data(), nonce.size(), in, in_len,\n                         /*ad=*/nullptr, /*ad_len=*/0)) { ... }', 'explanation': 'The RFC specifies that implementations MUST NOT use the Truncated HMAC extension. In this function, an AEAD algorithm (AES_128_GCM_SIV) is used for ticket sealing, and there is no logic introducing any truncated HMAC processing. The omission of any HMAC-related computation shows compliance with the specification.'}}]","The function implements ticket sealing by using an AEAD mechanism without resorting to any truncated HMAC extension. Since the RFC strongly advises against using the truncated HMAC extension, and the function’s code exclusively uses an AEAD algorithm (thus not employing any truncated HMAC), the code fully matches the specification constraint.",success,
11738,AsyncTicketSeal,An AEAD algorithm where N_MAX is less than 8 bytes MUST NOT be used with TLS.,298,Does Not Match,[],"The provided code function does not contain any logic that checks for or disallows the use of an AEAD algorithm where the maximum nonce length (N_MAX) is less than 8 bytes. There is no condition or enforcement in the function that addresses the spec requirement stating that an AEAD algorithm with N_MAX < 8 bytes MUST NOT be used with TLS. The function simply initializes and uses the EVP_aead_aes_128_gcm_siv algorithm, retrieves its nonce length, and performs encryption without validating the nonce length against the specified constraint.",success,
11739,AsyncTicketOpen,"Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.",399,Fully Matches,"[{'C1': {'code': 'const EVP_AEAD *aead = EVP_aead_aes_128_gcm_siv();\n...\nif (!EVP_AEAD_CTX_init(ctx.get(), EVP_aead_aes_128_gcm_siv(), kKey, sizeof(kKey), EVP_AEAD_DEFAULT_TAG_LENGTH, nullptr)) {', 'explanation': 'The RFC specifies that implementations must not use the Truncated HMAC extension. The function uses an AEAD algorithm (AES_128_GCM_SIV) with its default tag length and does not incorporate any logic to use or enable truncated HMAC. This approach satisfies the RFC requirement by eliminating any possibility of using the truncated HMAC extension.'}}]","The function explicitly chooses an AEAD algorithm (AES_128_GCM_SIV) and initializes the context with EVP_AEAD_DEFAULT_TAG_LENGTH. This design inherently avoids any use of truncated HMAC, thereby fully matching the RFC's mandate to not use the Truncated HMAC extension. No other portions of the function contradict this constraint.",success,
11739,AsyncTicketOpen,An AEAD algorithm where N_MAX is less than 8 bytes MUST NOT be used with TLS.,298,Does Not Match,[],"The RFC specification requires that an AEAD algorithm with N_MAX less than 8 bytes MUST NOT be used with TLS. The provided function uses the AEAD algorithm EVP_aead_aes_128_gcm_siv() and computes the nonce length, but it does not check whether its N_MAX (or any equivalent nonce size constraint) is less than 8 bytes. There is no logic in the function that explicitly disallows usage of an AEAD algorithm based on the N_MAX size, nor does it reflect any of the HTTP-related conditions mentioned in the spec context. Therefore, the function does not visibly address any of the labeled conditions or actions from the RFC specification.",success,
11741,GetCertificate,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided function GetCertificate is focused on loading certificates, private keys, and potentially setting an OCSP response. It does not contain any logic related to processing TLS 1.3 ClientHello messages or avoiding the use of the status_request_v2 extension, nor does it handle any HTTP header field logic (such as Transfer-Encoding or Content-Length). Consequently, none of the labeled spec constraints (e.g., C1 or A1) regarding TLS 1.3 behavior or HTTP header validations are implemented within this function.",success,
11750,SelectCertificateCallback,"Servers MAY require clients to send a valid ""server_name"" extension",352,Partially Matches,"[{'C1': {'code': 'const char *server_name = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);\n\nif (!config->expect_server_name.empty()) {\n    if (server_name == nullptr || std::string(server_name) != config->expect_server_name) {\n        fprintf(stderr,\n                ""Server name mismatch in early callback (got %s; want %s).\\n"",\n                server_name, config->expect_server_name.c_str());\n        return ssl_select_cert_error;\n    }\n}', 'explanation': ""This code retrieves the 'server_name' extension from the client hello and, when an expected server name is provided via configuration, it validates that the extension is present and matches the expected value. This directly addresses the RFC notion that servers MAY require a valid 'server_name' extension from clients. However, the check is conditional based on configuration, and additional related logic (such as further handling or enforcement) may exist elsewhere. Hence, the implementation within this function only partially fulfills the spec requirement.""}}]","The RFC specifies that servers MAY require a valid 'server_name' extension. In this function, when configuration indicates an expectation for a server name (and conversely, when no server name is expected), the function validates the extension by comparing it against an expected value and returns an error if there is a mismatch. However, because this logic is only active based on specific configuration settings and does not comprehensively cover all potential aspects of the RFC, it only partially matches the specification.",success,
11757,SetupCtx,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Partially Matches,"[{'C1': {'code': 'if (enable_early_data) {\n    SSL_CTX_set_early_data_enabled(ssl_ctx.get(), 1);\n  }', 'explanation': ""This segment enables early data (0-RTT) only when the 'enable_early_data' flag is set, which corresponds to the requirement that 0-RTT must only be enabled if explicitly requested by the application.""}}]","The RFC requires that TLS implementations MUST NOT enable 0-RTT unless specifically requested by the application and must not automatically resend 0-RTT data if rejected. In the function, early data is enabled only when the 'enable_early_data' flag is true, satisfying the first part of the requirement (C1). However, there is no logic addressing the scenario where 0-RTT data is rejected and must not be automatically resent, so the second part of the RFC is not handled by this function. Therefore, the function only partially matches the RFC specification.",success,
11757,SetupCtx,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Fully Matches,"[{'C1': {'code': 'bssl::UniquePtr<SSL_CTX> ssl_ctx(\n      SSL_CTX_new(is_dtls ? DTLS_method() : TLS_method()));', 'explanation': 'The RFC requires that SSL 3.0, which is considered insecure, MUST NOT be negotiated. By creating the SSL context with TLS_method() (or DTLS_method() when applicable), the function ensures that SSL 3.0 is not enabled, as TLS_method() excludes SSL 3.0. This directly meets the intended constraint.'}}]","The function initializes the SSL context exclusively using TLS_method() (or DTLS_method()), thereby inherently preventing the negotiation of SSL 3.0. This design decision directly implements the specification that SSL 3.0 is disallowed per RFC7568, and the relevant logic is self-contained within the function_body.",success,
11757,SetupCtx,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The RFC specification requires that implementations MUST NOT offer or negotiate RC4 cipher suites. However, in this function the cipher list defaults to ""ALL:TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"" if no custom cipher is provided. Using ""ALL"" does not exclude RC4 cipher suites and there is no explicit filtering or exclusion of RC4. Therefore, the function does not visibly implement the necessary constraint within its own logic.",success,
11757,SetupCtx,"Implementations which have the same policy in both cases MAY omit the ""signature_algorithms_cert"" extension.",85,Does Not Match,[],"The RFC specification requires that implementations that have the same policy in both cases MAY omit the 'signature_algorithms_cert' extension. In this function, there is no visible logic that checks or handles the signature_algorithms_cert extension. The function configures many SSL_CTX options and callbacks, but none of its code segments reference or conditionally enable or disable the 'signature_algorithms_cert' extension. Therefore, the function does not address the specified RFC constraint within its own implementation.",success,
11757,SetupCtx,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function configures various SSL_CTX options and callbacks, including an option to enable early data (via SSL_CTX_set_early_data_enabled) when the flag is set. However, the TLS RFC requirement specifies that the implementation SHOULD NOT automatically resend early data, leaving that decision to the application. There is no visible logic in this function that implements a safeguard or decision logic to prevent automatic retransmission of early data. Thus, the function does not visibly address the specified RFC constraint.",success,
11757,SetupCtx,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The RFC specification requires that TLS 1.3 servers must not act upon the status_request_v2 extension when processing ClientHello messages, and in particular must not send that extension in specific messages. The function provided is concerned with setting up an SSL_CTX with various options, callbacks, and configuration for testing purposes. It does not contain any logic that explicitly disables or ignores the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. No part of the function’s implementation addresses the conditions or actions specified by the RFC related to status_request_v2, and therefore it does not match the RFC constraints.",success,
11757,SetupCtx,The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.,197,Does Not Match,[],"The specified RFC constraint states that the OpenPGP certificate type MUST NOT be used with TLS 1.3. In the provided function_body, there is no logic that references certificate types (especially OpenPGP), nor is there any conditional check to block or handle the OpenPGP certificate type when TLS 1.3 is in use. The function is primarily focused on setting various SSL options, cipher lists, callbacks, and other related configurations. As such, none of the spec constraints (e.g., C1) are fully or partially addressed within this function.",success,
11760,PskServerCallback,"Any unknown PSKs (e.g., ones not in the PSK database or encrypted with an unknown key) SHOULD simply be ignored.",162,Fully Matches,"[{'C1': {'code': 'if (strcmp(identity, config->psk_identity.c_str()) != 0) {\n    fprintf(stderr, ""Client PSK identity did not match.\\n"");\n    return 0;\n}', 'explanation': 'This segment checks the provided PSK identity against the expected identity. If they do not match (i.e., for any unknown PSK), the function returns 0, effectively ignoring it in line with the RFC requirement.'}}]","The function directly implements the RFC specification by verifying the client-supplied PSK identity. When the identity is unknown, it logs the mismatch and returns 0 to ignore the PSK. No other part of the function performs actions attributed to dependencies, so the implementation within this function fully addresses the specified constraint.",success,
11763,NewSSL,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Does Not Match,[],"The provided function configures numerous TLS options but does not implement any logic that specifically addresses the RFC requirement regarding 0-RTT usage. There is no visible check to ensure that 0-RTT is enabled only when explicitly requested by the application, nor is there logic to control the automatic resending of 0-RTT data if rejected. As such, none of the spec constraints (e.g., labeled as C1 or A1 related to 0-RTT control) are fulfilled within this function.",success,
11763,NewSSL,"TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",200,Does Not Match,[],"The provided code function, TestConfig::NewSSL, does not include any logic addressing the TLS 1.3 requirement specified in the RFC (i.e., that servers MUST NOT send the status_request_v2 extension in certain messages). There is no code segment in the function that inspects, modifies, or excludes the status_request_v2 extension as mandated by the spec. All configuration code present relates to various TLS options and callbacks, but none target the handling of the status_request_v2 extension. Therefore, within this function's scope, none of the labeled conditions (e.g., C1) or actions (e.g., A1) related to the status_request_v2 extension are implemented.",success,
11763,NewSSL,"In particular, it MUST NOT negotiate TLS 1.3.",14,Partially Matches,"[{'C1': {'code': 'if (no_tls13) {\n    SSL_set_options(ssl.get(), SSL_OP_NO_TLSv1_3);\n}', 'explanation': ""This code segment disables TLS 1.3 when the flag 'no_tls13' is set. It demonstrates an effort to prevent negotiation of TLS 1.3, which aligns with the RFC requirement. However, since the disabling is conditional rather than enforced unconditionally, it only partially fulfills the spec requirement.""}}]","The RFC specification mandates that TLS 1.3 must not be negotiated. The function attempts to comply by disabling TLS 1.3 via a call to SSL_set_options with SSL_OP_NO_TLSv1_3 if the 'no_tls13' flag is true. This shows an attempt to enforce the RFC requirement, but because the disabling depends on a configuration flag rather than being unconditionally applied, the function only partially matches the spec on this point.",success,
12547,LevelToString,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function, LevelToString, only maps TLS encryption level enumerations to corresponding string representations. It does not contain any logic addressing the TLS specification requirement that early data should not be automatically resent (i.e., it does not implement any controls or conditions related to retransmission of early data). As such, none of the spec constraints (e.g., C1, A1) related to not automatically resending early data are visible in this function.",success,
12549,ReadHandshake,-Handshake messages MUST NOT be interleaved with other record types.,275,Fully Matches,"[{'C1': {'code': 'if (type != SSL3_RT_HANDSHAKE) {\n    return false;\n}', 'explanation': 'This code segment checks the record type immediately after reading the header, ensuring that only handshake records (SSL3_RT_HANDSHAKE) are processed. This directly implements the RFC requirement that handshake messages must not be interleaved with other record types.'}}]","The function begins by reading the header and immediately verifies the record type. By returning false when the record type is not a handshake, it prevents processing of non-handshake records, thereby fulfilling the RFC specification that handshake messages must not be interleaved with other record types. All the enforcement for this constraint is contained within this function, so it fully matches the specified requirement.",success,
12550,ReadApplicationData,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Does Not Match,[],"The RFC specification states that alert messages MUST NOT be fragmented across records and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record. In the provided function, there is no handling or logic that checks or enforces conditions regarding alert message fragmentation or coalescence. The function only distinguishes between application data and handshake data, and returns an error for any other record type. Therefore, the code function does not implement the specific RFC requirement as per the spec constraints.",success,
12550,ReadApplicationData,-Handshake messages MUST NOT be interleaved with other record types.,275,Fully Matches,"[{'C1': {'code': ""while (true) {\n    if (!ReadHeader(&type, &level, &len)) {\n      // Assume that a failure to read the header means there's no more to read,\n      // not an error reading.\n      return 0;\n    }\n    if (type == SSL3_RT_APPLICATION_DATA) {\n      break;\n    }\n    if (type != SSL3_RT_HANDSHAKE) {\n      return -1;\n    }\n\n    std::vector<uint8_t> buf(len);\n    if (!ReadAll(bio_.get(), bssl::Span(buf))) {\n      return -1;\n    }\n    if (SSL_provide_quic_data(ssl_, level, buf.data(), buf.size()) != 1) {\n      return -1;\n    }\n    if (SSL_in_init(ssl_)) {\n      int ret = SSL_do_handshake(ssl_);\n      if (ret < 0) {\n        int ssl_err = SSL_get_error(ssl_, ret);\n        if (ssl_err == SSL_ERROR_WANT_READ) {\n          continue;\n        }\n        return -1;\n      }\n    } else if (SSL_process_quic_post_handshake(ssl_) != 1) {\n      return -1;\n    }\n}"", 'explanation': 'The code repeatedly reads record headers and only accepts records of type SSL3_RT_HANDSHAKE or SSL3_RT_APPLICATION_DATA. Any record that is not one of these results in an error. This enforces that handshake messages are processed separately and are not interleaved with other types, directly addressing the spec requirement.'}}]","The function inspects incoming record headers in a loop. When it encounters a handshake message (SSL3_RT_HANDSHAKE), it processes it independently, and when application data (SSL3_RT_APPLICATION_DATA) is found, it subsequently exits the loop to process that data exclusively. This design prevents the interleaving of handshake messages with other record types, thereby fully implementing the specified HTTP RFC requirement.",success,
12552,WriteHandshakeData,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Does Not Match,[],"The provided function only delegates the task of writing handshake data by calling WriteRecord with the handshake record type. There is no logic in this function that addresses the RFC requirement that alert messages must not be fragmented across records or that multiple alert messages must not be coalesced into a single TLSPlaintext record. This check is specific to alert messages, and the function solely handles handshake data, so none of the labeled spec constraints (e.g., C1 or A1) are implemented within this function.",success,
12553,WriteApplicationData,"In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application.",407,Does Not Match,[],"The provided function only checks whether the SSL context is in early data mode (using SSL_in_early_data) and that the side is not a server (using SSL_is_server) to decide the encryption level. It does not implement any logic to ensure that 0-RTT is enabled only when specifically requested by the application, nor does it contain any mechanism to prevent automatic resending of 0-RTT data if rejected by the server. Therefore, no parts of the function address the requirements stated in the RFC specification.",success,
12553,WriteApplicationData,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided function simply selects the encryption level based on whether the connection is using early data and then writes application data. It does not contain any logic to prevent the automatic retransmission of early data, which is the requirement of the RFC specification. In other words, there is no visible logic within this function that checks or disables automatic resending of early data. Consequently, none of the labeled conditions or actions related to the spec constraint are addressed in this function.",success,
12553,WriteApplicationData,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Does Not Match,[],"The provided function, MockQuicTransport::WriteApplicationData, simply determines the encryption level and then calls WriteRecord to send application data. It does not include any logic to handle alert messages (e.g., ensuring they are not fragmented across records or coalesced) as required by the RFC specification. Therefore, no part of the function visibly addresses any of the labeled conditions or actions relating to alert message fragmentation and coalescence.",success,
12553,WriteApplicationData,"In other words, a record with an Alert type MUST contain exactly one message.",282,Does Not Match,[],"The provided function, WriteApplicationData, deals with writing application data records and optionally handles early data based on the SSL state. There is no logic present in this function that addresses the RFC specification which requires that a record with an Alert type must contain exactly one message. The code neither checks for an Alert type nor enforces the single message constraint. Therefore, no spec constraint (such as C1 or A1) is implemented in this function.",success,
12555,SendAlert,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The provided function does not implement any logic addressing the SSL2 negotiation restriction specified by the RFC. The spec requires that SSL 2.0 must not be negotiated; however, the function only constructs an alert message and calls WriteRecord without checking for or preventing any negotiation of SSL2. No part of the function specifically implements the necessary conditions (e.g., C1) or actions (e.g., A1) related to prohibiting SSL2, therefore it does not meet the spec constraints.",success,
12555,SendAlert,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, SendAlert, constructs and sends an alert message by invoking WriteRecord. There is no logic or mechanism within the function that checks for RC4, prevents the negotiation of RC4 cipher suites, or any related cipher suite specification. Since the RFC requirement is to not offer or negotiate RC4 cipher suites, and this function does not address this at all within its own code, it does not match any constraints related to the RFC.",success,
12555,SendAlert,"The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.",391,Does Not Match,[],The RFC specification requires that SSL 3.0 must not be negotiated due to its insufficient security. The function SendAlert merely constructs and sends an alert message by calling WriteRecord and does not include any logic to prevent the negotiation of SSL 3.0. There is no code segment in the function body that enforces the prohibition of SSL 3.0 as mandated by the RFC constraints.,success,
12613,DoRead,Future specifications MUST NOT define a use of exporters that permit both an empty context and no context with the same label.,332,Does Not Match,[],"The provided function does call SSL_export_keying_material with NULL context parameters, but it does not implement any logic that specifically addresses the spec constraint which prohibits using exporters that permit both an empty context and no context with the same label. There is no code that distinguishes or validates the difference between an empty context and no context, nor any logic that enforces the prohibition stated in the RFC specification. Therefore, the function does not attempt to implement the specified constraint within its own logic.",success,
12614,WriteAll,"Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record.",281,Does Not Match,[],"The provided code function, WriteAll, is a generic data writing routine that loops over SSL_write and does not contain any logic specific to the handling of TLS alert messages. It does not implement checks to prevent alert messages from being fragmented across records or to prevent multiple alert messages from being coalesced into a single TLSPlaintext record. Therefore, none of the constraints from the RFC specification (regarding alert message fragmentation and coalescing) are addressed within the function.",success,
12615,DoShutdown,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function 'DoShutdown' does not address the specified RFC requirement of not offering or negotiating RC4 cipher suites. The function simply handles the shutdown process for an SSL connection using SSL_shutdown in a loop. There is no logic within this function that implements any restrictions or negotiation related to RC4, hence it does not meet any labeled constraint from the spec.",success,
12616,DoSendFatalAlert,"The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.",392,Does Not Match,[],"The RFC specification states that SSL 2.0 must not be negotiated, yet the given function does not contain any logic to enforce or check this condition. The function 'DoSendFatalAlert' solely focuses on sending a fatal alert via SSL_send_fatal_alert and retrying if necessary using RetryAsync, with no visible code addressing any SSL version checks or disabling SSL2. Consequently, none of the spec constraints (C1, A1, etc.) related to prohibiting SSL 2.0 negotiation are implemented in this function.",success,
12616,DoSendFatalAlert,Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.,389,Does Not Match,[],"The provided function, DoSendFatalAlert, simply sends a fatal alert in a retry loop and does not include any logic related to disabling or negotiating cipher suites. Specifically, none of the code addresses the RFC requirement that implementations MUST NOT offer or negotiate RC4 cipher suites. As a result, there is no visible logic in the function that addresses any labeled conditions or actions from the RFC spec constraints.",success,
12621,CheckHandshakeProperties,A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate.,156,Does Not Match,[],"The provided RFC spec mandates that a TLS implementation SHOULD NOT automatically resend early data, leaving the decision of retransmission to the application. The CheckHandshakeProperties function primarily validates handshake parameters and early data status (for example, checking if early data was accepted or rejected) but does not implement any logic to enforce that early data is not automatically resent. There is no visible code in the function that handles retransmission decisions or prevents automatic resending of early data. Therefore, this function does not visibly address the RFC constraint.",success,
