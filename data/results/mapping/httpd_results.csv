function_id,function_name,sr_content,sr_index,outcome,met_constrains,explanation,status,api_response
1457,get_line,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function get_line is solely responsible for reading a line from a file and does not contain any logic that deals with protocol roles, syntax alternatives, or generation of protocol elements. There is no code that restricts a sender from generating protocol elements that are allowed only by other roles as described in the RFC specification. Therefore, no parts of the function address the specified conditions or actions.",success,
1457,get_line,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': ""while (i < (n - 2) && ((rv = apr_file_getc(&ch, f)) == APR_SUCCESS) && (ch != '\\n')) { s[i++] = ch; }"", 'explanation': 'This loop checks that there are at least two bytes remaining in the buffer before reading a character, which defensively prevents buffer overflow. This addresses the requirement to only marginally expect that the protocol element fits within a reasonable buffer size.'}}]","The function implements a basic defensive parsing mechanism by ensuring that it does not exceed the provided buffer size while reading a line from a file, which meets part of the RFC's guidance. However, it simply reads until a newline without actually validating conformity to the ABNF grammar or handling variations in protocol element lengths in a more nuanced way. As such, the function only partially matches the defensive parsing requirement as specified.",success,
1457,get_line,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Does Not Match,[],"The RFC requires that the line terminator be CRLF, but that a recipient may also recognize a single LF while ignoring any preceding CR, and that bare CR characters be handled specially. The provided function simply reads characters until it encounters '\n' and does not inspect or ignore a preceding '\r' (CR). There is no logic to replace a bare CR with a space or to otherwise validate or process CR characters as required. Thus, the function does not contain any visible logic that implements the specified RFC constraints.",success,
6779,write_request,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'A1': {'code': 'if (tnow > c->connect + aprtimeout) {\n    printf(""Send request timed out!\\n"");\n    abort_connection(c);\n    return;\n}', 'explanation': 'This segment forces the connection closure if the request sending exceeds the timeout, which is one instance of closing the transport connection as allowed by the RFC.'}}, {'A2': {'code': 'if (c->keptalive) {\n    shutdown_connection(c);\n} else {\n    worker->metrics.epipe++;\n    printf(""Send request failed!\\n"");\n    abort_connection(c);\n}', 'explanation': 'This segment handles error conditions during write operations by shutting down the connection gracefully (for kept-alive scenarios) or aborting it outright, thereby permitting connection closure as per the specification.'}}]","The function contains explicit logic to close the connection when a timeout occurs or when errors are encountered during the write operation. These actions (calling shutdown_connection and abort_connection) align with the RFC's allowance to close a connection at any time, particularly in response to timeouts or errors. However, the function only covers specific scenarios for connection termination and does not comprehensively implement every possible condition outlined by the RFC, so the implementation is only partially matching the spec.",success,
6790,finalize_connection,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'C1': {'code': 'if (!reuse || !good) {\n    close_connection(c);\n    reuse = 0;\n}\n...\nif (!reuse) {\n    start_connection(c);\n}\nelse if (worker_can_connect(worker)) {\n    c->keptalive++;\n    worker->metrics.doneka++;\n\n    c->read = 0;\n    c->bread = 0;\n    c->length = 0;\n    c->keepalive = 0;\n    c->cbx = 0;\n    c->gotheader = 0;\n    c->rwrite = 0;\n\n    write_request(c);\n}\nelse {\n    close_connection(c);\n}', 'explanation': ""This segment of the code implements logic to either close or reuse a connection. When conditions permit (i.e., 'reuse' is true and the connection is valid), the connection is reset and reused (persistent connection) by eventually calling write_request(c). This behavior directly supports the HTTP/1.1 requirement of persistent connections.""}}]","The function 'finalize_connection' inspects the current state of the connection and decides whether to reuse it (thus supporting persistent connections) or close it. The logic resetting connection parameters and calling write_request(c) when 'worker_can_connect(worker)' is true demonstrates the persistent connection behavior desired by the HTTP/1.1 specification. Therefore, within its own scope, the function fully implements the requirement that HTTP implementations SHOULD support persistent connections.",success,
6791,read_response,A recipient MAY employ such workarounds while remaining conformant to this protocol if the workarounds are limited to the implementations at fault.,216,Fully Matches,"[{'A1': {'code': '/* this next line is so that we talk to NCSA 1.5 which blatantly\n         breaks the http specifaction */\n        if (!s) {\n            s = strstr(c->cbuff, ""\\n\\n"");\n            l = 2;\n        }', 'explanation': ""The RFC permits recipients to employ workarounds when communicating with known faulty implementations. This code explicitly checks for a nonstandard header termination (i.e. '\\n\\n' instead of '\\r\\n\\r\\n') to handle responses from servers such as NCSA 1.5 that do not follow the specification.""}}]","The function implements a workaround that directly addresses the RFC's allowance for recipients to adjust behavior when facing non‐conformant implementations. By searching for an alternative header delimiter and including a comment that references the noncompliant NCSA 1.5 server behavior, the function visibly addresses the guidance provided in the RFC. Therefore, within the scope of this function, the specified condition (i.e., using a workaround limited to the faulty implementation) is fully met.",success,
6791,read_response,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (!s) {\n    /* read rest next time */\n    if (space) {\n        set_conn_state(c, STATE_READ, APR_POLLIN);\n    } else {\n        /* header is in invalid or too big - close connection */\n        if (++worker->metrics.err_response > 10) {\n            fprintf(stderr, ""\\nTest aborted after 10 failures\\n\\n"");\n            graceful_error(""Response header too long\\n"");\n        }\n        abort_connection(c);\n    }\n    return;\n}\n\n...\n\ns = strstr(c->cbuff, ""\\r\\n\\r\\n"");\nif (!s) {\n    s = strstr(c->cbuff, ""\\n\\n"");\n    l = 2;\n}', 'explanation': 'The code demonstrates a defensive parsing approach by checking the header termination using both ""\\r\\n\\r\\n"" and a fallback ""\\n\\n"". It further handles the scenario where the header exceeds the available buffer space by aborting the connection if the header is too long, aligning with the idea of parsing defently with only marginal expectations.'}}, {'A1': {'code': 'part = strstr(c->cbuff, ""HTTP"");\nif (part && strlen(part) > strlen(""HTTP/1.x_"")) {\n    strncpy(respcode, (part + strlen(""HTTP/1.x_"")), 3);\n    respcode[3] = \'\\0\';\n} else {\n    strcpy(respcode, ""500"");\n}', 'explanation': 'The function extracts the response code from the received header in a safe manner—if the expected HTTP version prefix is not present or is too short, it defaults to a 500 error code. This is a defensive measure to handle nonconforming responses.'}}]","The function implements a basic defensive parsing strategy: it reads data into a bounded buffer, checks for header termination with multiple markers and handles cases where the header is either incomplete or too long by aborting the connection. In addition, it defensively extracts the HTTP response code, defaulting to a safe value if necessary. However, the parsing is rudimentary and explicitly noted as 'not even remotely HTTP compliant', which means only some aspects of the RFC's defensive parsing requirements are addressed by the function itself. Therefore, the implementation only partially matches the spec's guidance.",success,
6791,read_response,HTTP implementations SHOULD support persistent connections.,311,Partially Matches,"[{'C1': {'code': 'c->keepalive = (keepalive && xstrcasestr(c->cbuff, ""Keep-Alive""));\n...\nfinalize_connection(c, c->keepalive != 0);', 'explanation': ""The function examines the received HTTP header for the 'Keep-Alive' token and uses it to set the c->keepalive flag, which then determines whether the connection is reused via finalize_connection. This logic shows an attempt to support persistent connections as specified, but it only relies on the presence of 'Keep-Alive' rather than defaulting persistent connections for HTTP/1.1 as required by the spec.""}}]","The code function includes logic that detects the 'Keep-Alive' header in the HTTP response and accordingly marks the connection as persistent. However, the HTTP/1.1 standard mandates that connections be persistent by default unless explicitly closed (i.e. via Connection: close), but the function only enables persistence when the 'Keep-Alive' string is found. As a result, while there is visible support for persistent connections, it only partially meets the specification's intent.",success,
6791,read_response,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Partially Matches,"[{'C1': {'code': 's = strstr(c->cbuff, ""\\r\\n\\r\\n"");\n/* this next line is so that we talk to NCSA 1.5 which blatantly\n * breaks the http specifaction\n */\nif (!s) {\n    s = strstr(c->cbuff, ""\\n\\n"");\n    l = 2;\n}', 'explanation': 'This segment shows that the function first attempts to detect the header termination using the standard CRLF pair. If that fails, it then searches for a double LF, thereby accepting a single LF as the line terminator, which partially meets the RFC requirement.'}}]","The function implements logic to detect header termination by checking for both ""\r\n\r\n"" and ""\n\n"" sequences, which corresponds to the RFC's allowance for a single LF as a line terminator if the preceding CR is ignored. However, other aspects of the RFC, such as properly handling bare CR characters or ensuring the message is parsed solely as an octet stream based on a US-ASCII superset, are not directly addressed in this function. Thus, the implementation only partially matches the RFC requirements.",success,
6796,test,HTTP implementations SHOULD support persistent connections.,311,Partially Matches,"[{'A1': {'code': 'snprintf_res = apr_snprintf(request, sizeof(_request),\n            ""%s %s HTTP/1.0\\r\\n""\n            ""%s"" ""%s"" ""%s""\n            ""%s"" ""\\r\\n"",\n            method_str[method],\n            (isproxy) ? fullurl : path,\n            keepalive ? ""Connection: Keep-Alive\\r\\n"" : """",\n            cookie, auth, hdrs);', 'explanation': ""This code segment conditionally adds the 'Connection: Keep-Alive' header into the outgoing HTTP request when the 'keepalive' flag is true, which is a partial implementation toward supporting persistent connections as suggested by the RFC.""}}]","The RFC requires HTTP implementations to support persistent connections. Although HTTP/1.1 defaults to persistent connections, this function constructs HTTP/1.0 requests and conditionally adds the 'Connection: Keep-Alive' header if the keepalive flag is set. This indicates an attempt to support persistent connections. However, since it does not handle the full persistent connection behavior (such as maintaining a persistent connection across multiple requests/responses or using HTTP/1.1 defaults) and is limited to simply adding a header, the implementation within this function only partially matches the RFC requirement.",success,
6796,test,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'snprintf_res = apr_snprintf(request, sizeof(_request),\n            ""%s %s HTTP/1.0\\r\\n""\n            ""%s"" ""%s"" ""%s""\n            ""%s"" ""\\r\\n"",\n            method_str[method],\n            (isproxy) ? fullurl : path,\n            keepalive ? ""Connection: Keep-Alive\\r\\n"" : """",\n            cookie, auth, hdrs);\n\n... and similar for the case with a request body ...', 'explanation': 'This segment constructs the HTTP request line and headers using literal strings and explicit CRLF sequences. In this way it attempts to generate protocol elements that conform to the ABNF grammar for HTTP (e.g., ""HTTP/1.0\\r\\n""). However, the function does not validate or ensure that every component (especially user‐supplied parts such as hostname, cookie, auth, etc.) strictly follow the grammar rules; it simply concatenates them into the request. This represents a partial implementation of the spec requirement that a sender MUST NOT generate protocol elements that deviate from the defined grammar.'}}]","The function builds the HTTP request using fixed format strings (including proper CRLF terminators) which indicate an effort to adhere to the expected HTTP/1.0 grammar. However, it does not perform any explicit validation of variable parts (e.g., host names, cookies, etc.) against the ABNF rules. Consequently, while some elements of the spec (such as using the fixed header formats) are addressed, not all aspects required by the RFC (ensuring all protocol elements fully conform to ABNF rules) are verified in the function itself. Thus, the implementation partially matches the spec.",success,
6796,test,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The RFC requirement mandates that a sender must not generate multiple header fields with the same name unless the field’s definition explicitly allows combining them. In the provided function, while default headers (Host, User-Agent, Accept) are only appended conditionally (i.e., only when the corresponding option flag is not set), there is no explicit logic to enforce or validate that multiple header fields are not created inadvertently (for example if the user‐supplied hdrs already contains such fields) or to preserve the order of header lines. The function simply concatenates different header components without checking for duplicates or handling recombination. Therefore, no parts of this function visibly implement the detailed RFC constraint regarding multiple header lines.",success,
6796,test,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function constructs an HTTP request by selecting headers and building the request string based on the parameters (e.g., isproxy, use_html, send_body). However, it does not include any logic that restricts the generation of protocol elements based on role (i.e., ensuring that elements allowed only for other roles are not generated). The code does not perform any checks against the RFC mandate that 'a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles,' nor does it adapt the output based on the sender's role. Therefore, the function does not address the given spec constraint.",success,
6796,test,A sender SHOULD limit generated product identifiers to what is necessary to identify the product; a sender MUST NOT generate advertising or other nonessential information within the product identifier.,274,Fully Matches,"[{'C1': {'code': 'if (!opt_useragent) {\n    /* User-Agent: header not overridden, add default value to hdrs */\n    hdrs = apr_pstrcat(cntxt, hdrs, ""User-Agent: ApacheBench/"", AP_AB_BASEREVISION, ""\\r\\n"", NULL);\n}', 'explanation': ""This code explicitly sets the User-Agent header to 'ApacheBench/' with a version number, thereby limiting the product identifier to only the necessary information without including any advertising or nonessential details.""}}]","The function contains logic that sets the User-Agent header when no override is provided. By constructing the header as ""User-Agent: ApacheBench/"" followed by a version identifier, it adheres to the RFC requirement of including only essential product identifier information and avoiding any advertising content. Thus, the function fully meets the specified constraints within its own code.",success,
6796,test,"A sender SHOULD NOT generate information in product-version that is not a version identifier (i.e., successive versions of the same product name ought to differ only in the product-version portion of the product identifier).",275,Fully Matches,"[{'C1': {'code': 'if (!opt_useragent) {\n    /* User-Agent: header not overridden, add default value to hdrs */\n    hdrs = apr_pstrcat(cntxt, hdrs, ""User-Agent: ApacheBench/"", AP_AB_BASEREVISION, ""\\r\\n"", NULL);\n}', 'explanation': 'This code generates the User-Agent header using a fixed product name ""ApacheBench/"" plus AP_AB_BASEREVISION as the version identifier. By doing so, it ensures that only necessary identifying information is included in the product-version field, thereby complying with the RFC requirement that a sender should not generate non-version information in product-version.'}}]","The function_body visibly implements the necessary logic for constructing the User-Agent header (when not overridden) in accordance with the RFC. It generates a header that includes only the product name and a version identifier, and does not add any nonessential information, thus fully addressing the condition (C1) from the spec constraints.",success,
6796,test,"In order to improve the server's guess, a user agent MAY send request header fields that describe its preferences.",278,Does Not Match,[],"The RFC specifies that a user agent may include request header fields to describe its preferences to improve the server's guess during content negotiation. In this function, while default headers like 'User-Agent', 'Host', and 'Accept' are set, there is no logic to include additional negotiation headers (e.g., headers that describe language, content coding, etc.) that would assist the server in proactively selecting a representation. None of the spec constraints (e.g., labeled C1, A1) are visibly implemented within this function's logic.",success,
6796,test,"Note that the coding named ""identity"" is reserved for its special role in Accept-Encoding and thus SHOULD NOT be included.",38,Does Not Match,[],"The provided function 'test' does not implement any logic related to the HTTP RFC specifications regarding Content-Encoding. The RFC requires that when encodings (like gzip) are applied, a Content-Encoding header be generated listing the applied codings in order, and that the 'identity' coding must not be included. However, the function only builds the HTTP request string by concatenating method, URL/path, headers such as Host, User-Agent, Accept, and optionally Content-length and Content-type. There is no code addressing the construction or validation of a Content-Encoding header, no handling of gzip or any other encoding, and no logic to exclude the 'identity' encoding. Therefore, none of the spec constraints labeled (e.g., C1, A1) are implemented in the function body.",success,
6804,parse_url,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'if (port == 0) {        /* no port specified */\n#ifdef USE_SSL\n    if (is_ssl)\n        port = 443;\n    else\n#endif\n    port = 80;\n}', 'explanation': 'The code checks if no port was provided (port == 0) and then assigns the default port based on whether SSL is used. This directly implements the RFC requirement that if a port is not provided, the recipient may interpret it as being received on the default port for the protocol.'}}]","The function examines the URL, extracts the host and port, and explicitly checks whether the port is zero. In that case, it sets the default port to 80 or 443 based on the protocol (HTTP or HTTPS). This logic internally implements the requirement specified in the RFC that a missing port should be interpreted as the default port for the received protocol.",success,
6804,parse_url,"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",225,Fully Matches,"[{'C1': {'code': 'rv = apr_parse_addr_port(&hostname, &scope_id, &port, h, cntxt);\n    if (rv != APR_SUCCESS || !hostname || scope_id) {\n        return 1;\n    }', 'explanation': ""This segment attempts to parse the URL's authority component (host and port) and explicitly checks if the hostname is missing. If hostname is NULL (i.e., an empty host identifier), the function returns an error, thereby preventing the generation or acceptance of a URI with an empty host as specified by the RFC.""}}]","The function's logic inspects the URL by first extracting the host component and then using apr_parse_addr_port to validate it. By checking for a NULL hostname and returning an error if found, the function directly enforces the RFC requirement that a sender must not generate (and a recipient must reject) an https URI with an empty host identifier.",success,
6807,main,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function mainly parses command-line arguments, sets configuration parameters, and initializes SSL if enabled. There is no explicit logic that checks or restricts the generation of protocol elements based on the sender's role per the specified RFC requirement. In other words, it does not contain any code that prevents the sender from generating protocol elements or syntax alternatives that are only allowed for other roles, which is the core of the RFC spec. Therefore, no labeled conditions or actions (e.g., C1, A1) addressing this requirement can be identified in the function body.",success,
6807,main,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC specification requires that a sender must not generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. In the provided function, there is no visible logic or code specifically checking, validating, or enforcing that the generated HTTP protocol elements conform to any ABNF grammar. The function is mainly involved in parsing command-line arguments, setting up SSL contexts, and preparing requests, but it does not implement any logic to validate or restrict the protocol elements against the ABNF rules. Therefore, this function does not address the spec constraint.",success,
6980,cgi_query_string,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided code function retrieves the QUERY_STRING environment variable using apr_env_get and returns it. There is no logic in the function that addresses the RFC requirement about not using context information (such as Content-Location) to alter request semantics. No part of the function implements any condition or action related to the spec constraints (e.g., C1, A1, etc.), so it does not visibly address the specified HTTP RFC requirement.",success,
6981,init_body,"If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value).",201,Partially Matches,[],"The function_body does check the Content-Length header by attempting a strict parse with ap_parse_strict_length and sets an error (APREQ_ERROR_BADHEADER) if the header value is invalid. This addresses part of the spec requirement regarding an invalid Content-Length header when no Transfer-Encoding is present. However, the spec mandates that if the invalid value can be successfully parsed as a comma‐separated list of identical valid values, the message should be processed using that value. The function does not contain any logic to parse a comma-separated list or to handle the exception where that list is valid. Furthermore, there is no explicit check for the presence of Transfer-Encoding. Thus, while the code partially implements the necessary check for an invalid Content-Length header, it does not fully implement the complete behavior as specified in the RFC constraint.",success,
6981,init_body,"Since there is no predefined limit to the length of content, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer conversion (Section 17.5).",261,Partially Matches,"[{'C1': {'code': 'if (cl_header != NULL) {\n    apr_off_t content_length;\n\n    if (!ap_parse_strict_length(&content_length, cl_header)) {\n        req->body_status = APREQ_ERROR_BADHEADER;\n        cgi_log_error(CGILOG_MARK, CGILOG_ERR, req->body_status, handle,\n                      ""Invalid Content-Length header (%s)"", cl_header);\n        return;\n    }\n    if ((apr_uint64_t)content_length > req->read_limit) {\n        req->body_status = APREQ_ERROR_OVERLIMIT;\n        cgi_log_error(CGILOG_MARK, CGILOG_ERR, req->body_status, handle,\n                      ""Content-Length header (%s) exceeds configured max_body limit (%"" APR_UINT64_T_FMT "")"",\n                      cl_header, req->read_limit);\n        return;\n    }\n}', 'explanation': 'This code segment checks if the Content-Length header exists, strictly parses it to avoid conversion errors (by using ap_parse_strict_length), and compares the parsed value against a configured limit. This logic addresses the RFC requirement to anticipate large decimal numerals and prevent errors due to integer conversion issues. However, the function delegates the detailed prevention of overflows or precision loss to ap_parse_strict_length, and does not handle all aspects by itself.'}}]","The function includes logic to strictly parse the Content-Length header and compare the value to a read limit, which is an attempt to handle potentially large decimal numerals as required by the RFC. It does so by checking for parsing errors and by limiting the parsed value, which corresponds to condition C1 in the spec. However, since the detailed prevention of integer conversion overflows or precision loss is deferred to the helper function (ap_parse_strict_length) and the function does not address all aspects of the RFC independently, the implementation is considered a partial match.",success,
6981,init_body,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'C1': {'code': 'if (cl_header != NULL) {\n    apr_off_t content_length;\n\n    if (!ap_parse_strict_length(&content_length, cl_header)) {\n        req->body_status = APREQ_ERROR_BADHEADER;\n        cgi_log_error(CGILOG_MARK, CGILOG_ERR, req->body_status, handle,\n                      ""Invalid Content-Length header (%s)"", cl_header);\n        return;\n    }\n    if ((apr_uint64_t)content_length > req->read_limit) {\n        req->body_status = APREQ_ERROR_OVERLIMIT;\n        cgi_log_error(CGILOG_MARK, CGILOG_ERR, req->body_status, handle,\n                      ""Content-Length header (%s) exceeds configured max_body limit (%"" APR_UINT64_T_FMT "")"",\n                      cl_header, req->read_limit);\n        return;\n    }\n}', 'explanation': 'This segment validates the Content-Length header using a strict parser (ap_parse_strict_length) and rejects the request by setting an error status when the header is invalid or exceeds a limit. This directly addresses the need to not forward a message with an incorrect Content-Length header as per the specification. However, it does not cover the allowed exception for duplicate identical decimal values.'}}]","The function_body contains logic to validate the Content-Length header value. Specifically, it checks whether the header is present, parses it strictly, and stops processing if the value is invalid or exceeds a configured limit. This partially meets the RFC requirement that a sender must not forward a message with a known incorrect Content-Length. However, it does not implement the exception for a header value consisting of identical comma-separated duplicates. Hence, the implementation only partially matches the specification constraints.",success,
6983,cgi_jar,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that within a given message, a sender must not generate protocol elements or syntax alternatives that are reserved for other roles. In the provided cgi_jar function, there is no logic present that verifies or restricts the generation of protocol elements based on the sender’s role. Instead, the code is concerned with interactively gathering cookie input and parsing existing cookie headers without any checks against role-specific protocol element generation. Therefore, the code function does not visibly address any of the labeled conditions or actions as required by the RFC.",success,
6986,cgi_args_get,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'cgi_args_get' primarily retrieves CGI arguments and, in interactive mode, prompts for a parameter and creates it. There is no logic in the code that enforces role-based restrictions on generating protocol elements, nor does it check that only the allowed role generates certain syntax alternatives, as required by the RFC specification. Therefore, none of the spec constraints (e.g., the one requiring a sender to refrain from generating protocol elements or syntax alternatives reserved for other roles) are implemented within this function.",success,
6989,cgi_parser_get,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function simply retrieves a parser from a given handle and returns a success status. It does not generate any protocol elements nor does it incorporate any checks, validations, or generation logic that would ensure that the protocol elements conform to the ABNF grammar defined by the RFC. Consequently, there is no visible logic within this function that addresses any condition (e.g., C1) or action (e.g., A1) related to the RFC specification.",success,
6989,cgi_parser_get,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function simply retrieves a parser pointer from a handle and returns a success status. It contains no logic to enforce or check any sender role responsibilities or protocol element generation rules as specified in the RFC constraints (e.g., ensuring that a sender does not generate protocol elements reserved for other roles). Thus, none of the constraints (C1, A1, etc.) are addressed within this function.",success,
7033,log_server_name,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that within a given message, a sender must not generate protocol elements or syntax alternatives that are reserved only for other roles. The provided function, log_server_name, simply logs or retrieves the server name from the request record and does not contain any logic to enforce role-based restrictions or to check against the ABNF grammar for allowed protocol elements. No part of the function directly implements any condition (e.g., C1) or action (e.g., A1) related to the role-based constraints described in the RFC, hence it does not visibly address the specified RFC requirement.",success,
7189,ap_bucket_error_create,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (!ap_is_HTTP_VALID_RESPONSE(error)) {\n    error = HTTP_INTERNAL_SERVER_ERROR;\n}', 'explanation': ""This segment validates the HTTP error code by ensuring the provided 'error' is valid per the HTTP protocol. If it is not valid, it replaces it with a defined error code (HTTP_INTERNAL_SERVER_ERROR). This check partially implements the spec requirement that a sender must not generate protocol elements that deviate from the ABNF grammar by ensuring at least the error code is valid, though it does not cover the full grammar of all protocol elements.""}}]","The function checks whether the provided HTTP error code is valid using the ap_is_HTTP_VALID_RESPONSE() call, and if it isn't, it replaces it with a default internal server error. This mechanism partially addresses the spec requirement that no protocol elements outside of the allowed grammar be generated. However, the function only deals with the error code aspect of an HTTP response rather than fully validating the entire protocol element per the ABNF rules. Therefore, it only partially matches the given HTTP RFC specification.",success,
7189,ap_bucket_error_create,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (!ap_is_HTTP_VALID_RESPONSE(error)) {\n        error = HTTP_INTERNAL_SERVER_ERROR;\n    }', 'explanation': ""This code segment checks whether the provided error code is a valid HTTP response. If it isn't, the function defaults it to HTTP_INTERNAL_SERVER_ERROR. This helps ensure that the function does not generate a protocol element (an error response) that might be reserved for a different role, which is in line with the RFC's requirement to avoid generating protocol elements or syntax alternatives reserved for other participants.""}}]","The function makes an attempt to enforce the RFC specification by verifying that the error code provided is a valid HTTP response, replacing it if necessary. This demonstrates that the function is trying to avoid generating protocol elements that are not allowed for its role. However, the function does not address the full scope of the RFC requirements such as explicit role determination or handling all syntax alternative concerns. Therefore, the function only partially matches the specification's constraints.",success,
7189,ap_bucket_error_create,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Fully Matches,"[{'C1': {'code': 'if (!ap_is_HTTP_VALID_RESPONSE(error)) {\n        error = HTTP_INTERNAL_SERVER_ERROR;\n    }', 'explanation': 'This segment checks whether the provided error code is valid. If not, it recovers by replacing it with HTTP_INTERNAL_SERVER_ERROR, which is in line with the RFC specification allowing a recipient to recover a usable protocol element from an invalid construct.'}}]","The function ap_bucket_error_create() directly implements the recovery behavior specified in the RFC by verifying if the error code represents a valid HTTP response and, if it does not, falling back to HTTP_INTERNAL_SERVER_ERROR. This recovery mechanism is precisely what the RFC permits, thereby ensuring that the function alone addresses the recovery requirement specified by the RFC.",success,
7191,apreq_param_decode,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (nlen == 0) {\n    *param = NULL;\n    return APR_EBADARG;\n}', 'explanation': 'This segment ensures that an empty name length is caught early, which is a basic defensive check against malformed input.'}}, {'A1': {'code': 'status = apreq_decode(v->data, &v->dlen, word + nlen + 1, vlen);\nif (status != APR_SUCCESS) {\n    *param = NULL;\n    return status;\n}\n\n...\n\nstatus = apreq_decode(v->name, &v->nlen, word, nlen);\nif (status != APR_SUCCESS) {\n    *param = NULL;\n    return status;\n}', 'explanation': 'These segments show that the function attempts to decode parts of the protocol element and returns errors if the decoding fails, thereby addressing error handling in a defensive manner.'}}]","The function implements partial defensive parsing by verifying that essential parameters (such as non-zero length for the name) are provided and by checking the success of decoding operations. However, it does not fully enforce all aspects of the RFC's defensive parsing guidelines—for example, it does not validate that the input conforms to an ABNF grammar or explicitly check that the input buffer size is within a 'reasonable' limit. Hence, while some defensive measures are present (matching constraints C1 and A1), the implementation only partially addresses the entire specification.",success,
7191,apreq_param_decode,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The code function apreq_param_decode is primarily concerned with decoding a parameter's name and value and setting character encodings. It does not include any logic to restrict or validate the generation of protocol elements based on the sender's role, as specified in the RFC. There is no check to ensure that protocol elements generated are only those permitted for the role of the sender. As required by the spec, any prevention of generating role-inappropriate protocol elements would need explicit conditional logic to compare the sender's role with allowed roles, which is absent in the function body. Therefore, this function does not visibly address the constraint provided in the RFC specification.",success,
7193,apreq_parse_query_string,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, apreq_parse_query_string, is solely focused on parsing a query string and decoding parameters. It does not incorporate any logic to enforce or check role-based constraints nor does it validate that protocol elements adhere to a particular sender's role as prescribed by the RFC specification. Since the RFC condition requires that a sender must not generate protocol elements or syntax alternatives reserved for other roles, and the function makes no attempt to implement such a check, the code does not visibly address any of the labeled constraints or actions.",success,
7202,consume_header_line,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Partially Matches,"[{'C1': {'code': ""for (off = 0; off < dlen; ++off) {\n    const char ch = data[off];\n    if (ch == '\\r' || ch == '\\n') {\n        /* Eat [CR]LF of continuation or end of line */\n        if (!vlen && ch == '\\n')\n            eol = 1; /* done */\n        continue;\n    }\n    assert(vlen > 0);\n    *dest = ch;\n    ++dest;\n    --vlen;\n}"", 'explanation': ""This code segment shows that the function ignores both '\\r' and '\\n' when copying the header field's value, which corresponds to the RFC's provision that a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR. However, it does not validate that a CR is immediately followed by an LF (or replace a bare CR with SP), so it only partially addresses the constraint.""}}]","The function attempts to implement the RFC requirement of processing header lines by consuming CR and LF characters and terminating the line on a LF under a specific condition. This fits the part of the spec that allows a recipient to treat a lone LF as the terminator and to ignore any preceding CR. However, it lacks logic to handle scenarios where a bare CR (not followed by LF) should be flagged as invalid or replaced with a space, as mandated by the spec for protocol elements. Thus, only part of the relevant spec constraint is addressed within this function.",success,
7203,apreq_parse_headers,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'if (APR_BUCKET_IS_EOS(e)) {\n    ctx->status = HDR_COMPLETE;\n    APR_BRIGADE_CONCAT(bb, ctx->bb);\n    return APR_SUCCESS;\n}', 'explanation': 'This segment shows that when the end‐of‐stream bucket is reached, the parser treats the header block as complete. In doing so, it attempts to continue processing even when no additional content is available, which is one way of recovering a usable protocol element from incomplete input.'}}, {'A1': {'code': ""switch (ctx->status) {\n\ncase HDR_NAME:\n    while (off < dlen) {\n        ch = data[off++];\n        switch (ch) {\n        case ':':\n            if (!ctx->nlen) {\n                ctx->status = HDR_ERROR;\n                return APREQ_ERROR_BADHEADER;\n            }\n            e = split_header_line(e, &off, &data, &dlen);\n            ++ctx->glen;\n            ctx->status = HDR_GAP;\n            goto parse_hdr_bucket;\n\n        default:\n            if (!IS_TOKEN_CHAR(ch)) {\n                ctx->status = HDR_ERROR;\n                return APREQ_ERROR_BADCHAR;\n            }\n            ++ctx->nlen;\n        }\n    }\n    break;\n\n// ... additional cases handling HDR_GAP, HDR_VALUE, HDR_NEWLINE, etc.\n"", 'explanation': 'This large state‐machine implementation shows a detailed attempt to interpret incoming header data according to defined semantics. It processes header names, gaps, and values (as well as folded lines) and uses bucket manipulation (via split_header_line and brigade concatenation) to continue parsing. This reflects an effort to follow the RFC’s requirement to interpret protocol elements, even though some errors lead to immediate rejection rather than soft recovery.'}}]","The function implements a state machine to parse header input and in certain cases (such as the end‐of-stream situation) takes steps that allow parsing to complete even if the input is incomplete. This can be seen as an attempt to recover a protocol element, which aligns with the RFC's suggestion that a recipient MAY attempt recovery. However, for other forms of invalid syntax—such as an empty header name or invalid token characters—the function immediately returns an error rather than attempting recovery. Because the function’s recovery is partial (it distinguishes between unfinished input and malformed input but does not recover from all invalid constructs), it only partially meets the listed RFC constraints.",success,
7203,apreq_parse_headers,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': ""case HDR_NAME:\n    while (off < dlen) {\n        ch = data[off++];\n        switch (ch) {\n        case ':' :\n            if (!ctx->nlen) {\n                ctx->status = HDR_ERROR;\n                return APREQ_ERROR_BADHEADER;\n            }\n            ...\n        default:\n            if (!IS_TOKEN_CHAR(ch)) {\n                ctx->status = HDR_ERROR;\n                return APREQ_ERROR_BADCHAR;\n            }\n            ++ctx->nlen;\n        }\n    }"", 'explanation': 'This segment verifies that each character in the header name is valid (using IS_TOKEN_CHAR) and returns an error if not. This is a defensive check on the received header element as it is parsed, which corresponds to the notion of defensive parsing in the specification.'}}]","The function demonstrates defensive parsing by iterating over the input data with multiple checks (e.g., ensuring header names contain only valid token characters, checking for unexpected control characters, and verifying line terminations). This corresponds to at least one element (C1) of the RFC requirement to parse protocol elements defensively. However, the code does not explicitly implement measures such as limiting header sizes or tolerating varied grammar deviations (e.g., not explicitly addressing reasonable buffer size constraints). Since only part of the spec’s defensive parsing expectations is visibly implemented, the overall judgment is that it partially matches the HTTP RFC as specified.",success,
7219,ap_xml_parse_input,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function ap_xml_parse_input is primarily focused on reading and parsing the XML body from a request, implementing error checking, body size limits, and XML parsing status management. It does not contain any logic that checks or enforces the constraint regarding the generation of protocol elements or syntax alternatives based on sender roles, as required by the spec. Consequently, there is no code segment within this function that addresses the role-based restrictions mentioned in the RFC specification.",success,
7219,ap_xml_parse_input,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'total_read += len;\nif (total_read > limit_xml_body) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00539)\n                  ""XML request body is larger than the configured limit of %lu"", (unsigned long)limit_xml_body);\n    result = HTTP_REQUEST_ENTITY_TOO_LARGE;\n    goto read_error;\n}', 'explanation': 'This segment implements a defensive check to ensure that the XML body being parsed does not exceed a predefined reasonable limit. It aligns with the RFC requirement to parse protocol elements defensively by enforcing a buffer size limit.'}}, {'A1': {'code': 'status = apr_xml_parser_feed(parser, data, len);\nif (status) {\n    goto parser_error;\n}\n...\nstatus = apr_xml_parser_done(parser, pdoc);\nif (status) {\n    if (!total_read) {\n        *pdoc = NULL;\n        return OK;\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00540)\n                  ""XML parser error (at end). status=%d"", status);\n    return HTTP_BAD_REQUEST;\n}', 'explanation': ""This code defers the XML syntax validation to the XML parser functions, and it gracefully handles parsing errors. By checking the parser's return status and managing errors, the function adheres to the 'defensive parsing' stance described in the RFC.""}}]","The function reads the XML input in a loop, carefully tracking the total amount read and enforcing a configurable limit, which satisfies the need to restrict protocol element size. It also uses the XML parser's feed and finalize routines while checking for errors and logging them appropriately. These measures ensure that the input is processed defensively, with low assumptions on its conformity, which is in line with the RFC specification.",success,
7245,dummy_connection,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The dummy_connection() function constructs and sends either an HTTP OPTIONS request or a TLS close_notify alert based solely on the listener's protocol configuration. It does not implement any logic to ensure that only protocol elements permitted for the sender’s role are generated. In other words, it does not check or enforce restrictions that prevent generating elements reserved for other roles, as required by the RFC specification. Therefore, no part of the function visibly addresses conditions (e.g., C1) or actions (e.g., A1) that enforce role-specific protocol element generation.",success,
7245,dummy_connection,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'data = apr_pstrcat(p, ""OPTIONS * HTTP/1.0\\r\\nUser-Agent: "",\n                       ap_get_server_description(),\n                       "" (internal dummy connection)\\r\\n\\r\\n"", NULL);\n\n/* ... */\n\nstatic const unsigned char tls10_close_notify[7] = {\n    \'\\x15\',         /* TLSPlainText.type = Alert (21) */\n    \'\\x03\', \'\\x01\', /* TLSPlainText.version = {3, 1} */\n    \'\\x00\', \'\\x02\', /* TLSPlainText.length = 2 */\n    \'\\x01\',         /* Alert.level = warning (1) */\n    \'\\x00\'          /* Alert.description = close_notify (0) */\n};', 'explanation': 'The function constructs protocol messages using well‐defined, hardcoded formats. In the non-SSL case it builds a complete HTTP request string (OPTIONS * HTTP/1.0 with appropriate headers) that conforms to the ABNF grammar for HTTP requests, and in the SSL case it sends a TLS 1.0 close_notify alert message that matches the expected binary format. This shows that the sender does not generate protocol elements that violate the specified grammar.'}}]","The dummy_connection function explicitly constructs and sends protocol messages using constant, prevalidated formats for both HTTP and TLS protocols. By hardcoding and using well‐formed request strings and TLS alert messages, the function ensures that it only produces protocol elements that conform to the corresponding ABNF grammars, thereby directly addressing the requirement from the RFC specification.",success,
7502,ap_parse_htaccess,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': '/* firstly, search cache */\nfor (cache = r->htaccess; cache != NULL; cache = cache->next) {\n    if (cache->override == override && strcmp(cache->dir, d) == 0) {\n        *result = cache->htaccess;\n        return OK;\n    }\n}\n\n...\n\n/* cache it */\nnew = apr_palloc(r->pool, sizeof(struct htaccess_result));\nnew->dir = parms.path;\nnew->override = override;\nnew->override_opts = override_opts;\nnew->htaccess = dc;\n\n/* add to head of list */\nnew->next = r->htaccess;\nr->htaccess = new;', 'explanation': 'This portion of the function implements a caching mechanism by checking a local cache (r->htaccess) to avoid reprocessing, which aligns with the RFC notion that a cache may be employed.'}}]","The function contains logic to utilize a cache through its search and update of the r->htaccess linked list, satisfying the part of the RFC that allows employing a cache. However, it does not implement any logic to prevent using the cache while acting as a tunnel, which is required by the RFC. Hence, the function only partially matches the specified RFC.",success,
7577,ap_scan_script_header_err_core_ex,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Fully Matches,"[{'C1': {'code': ""p = strlen(w);\n             if (p > 0 && w[p - 1] == '\\n') {\n                 if (p > 1 && w[p - 2] == CR) {\n                     w[p - 2] = '\\0';\n                 } else {\n                     w[p - 1] = '\\0';\n                 }\n             }"", 'explanation': ""This segment checks if the line ends with a '\\n'. If it does and if the preceding character is a CR, it removes both (implementing CRLF termination). Otherwise, it removes the lone LF. This behavior directly addresses the RFC specification that a recipient may recognize a single LF as a line terminator and ignore any preceding CR.""}}]",The function explicitly handles line termination by detecting a trailing '\n' and conditionally removing an optional preceding CR. This logic within the function demonstrates that it correctly implements the RFC requirement regarding line terminators in HTTP messages.,success,
7577,ap_scan_script_header_err_core_ex,"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.",57,Partially Matches,"[{'A1': {'code': 'else if (!ap_cstr_casecmp(w, ""ETag"")) {\n    apr_table_set(r->headers_out, w, l);\n}', 'explanation': ""This segment checks for an 'ETag' header from the CGI output and sets it into the outgoing headers. It directly handles the scenario described by the RFC spec, i.e. sending an ETag if one is available. However, the function does not compute or guarantee the generation of an ETag on its own, but merely passes it through if provided.""}}]","The function processes headers generated by a CGI script and includes a branch for handling the 'ETag' header. This behavior partially matches the RFC requirement that an origin server should send an ETag for the selected representation. The code does attempt to pass along an ETag header when present, but it does not itself generate or enforce the presence of such a header if absent.",success,
7578,ap_scan_script_header_err_core,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function simply delegates its work to ap_scan_script_header_err_core_ex and does not contain any logic that enforces or checks that a sender is not generating protocol elements reserved for another role (as required by the spec). There are no condition or action checks (e.g., for C1 or A1) implemented directly within the body of this function. Therefore, the code function does not visibly address any of the specified constraints.",success,
7578,ap_scan_script_header_err_core,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The function body simply acts as a thin wrapper that calls ap_scan_script_header_err_core_ex without any additional logic to enforce or check the RFC requirement that a sender must not generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. There are no visible code segments within this function that address any labeled conditions (e.g., C1) or actions (e.g., A1) from the spec constraints. All actual implementation is deferred to the called function, which does not count as this function implementing the spec in isolation.",success,
7580,ap_scan_script_header_err,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, ap_scan_script_header_err, does nothing more than wrap a call to ap_scan_script_header_err_core_ex and does not contain any logic that verifies whether the sender is generating appropriate protocol elements or syntax based on its role, as required by the RFC specification. There is no visible code in this function that directly checks or enforces the constraint that a sender must not generate protocol elements or syntax alternatives that are only allowed for other roles. Therefore, none of the labeled conditions (e.g., C1) or actions (e.g., A1) from the spec constraints are implemented solely within this function.",success,
7582,getsfunc_BRIGADE,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The code function is focused on reading data from an APR bucket brigade into a buffer, handling newlines, and managing bucket splitting and deletion. It does not contain any logic that checks or enforces role-based restrictions, such as ensuring that protocol elements are only generated by the appropriate sender role as required by the spec. There is no implementation within this function that restricts the generation of protocol elements to a particular role, so it does not address the condition (C1) or any related actions (e.g., A1) from the provided RFC specification.",success,
7582,getsfunc_BRIGADE,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'const char *dst_end = buf + len - 1; /* leave room for terminating null */\n...\nwhile ((dst < dst_end) && !done && e != APR_BRIGADE_SENTINEL(bb) && !APR_BUCKET_IS_EOS(e)) { ... }', 'explanation': 'This code segment ensures the function does not write beyond the provided buffer (leaving room for a terminating null), which is a defensive measure regarding buffer size.'}}, {'A1': {'code': ""while ((src < src_end) && (dst < dst_end) && !done) {\n    if (*src == '\\n') {\n        done = 1;\n    } else if (*src != '\\r') {\n        *dst++ = *src;\n    }\n    src++;\n}"", 'explanation': 'This snippet demonstrates defensive parsing by processing input one character at a time, stopping at a newline and ignoring carriage returns. This basic approach aligns with the expectation of handling protocol elements with only marginal assumptions about their format.'}}]","The function attempts to implement a defensive parsing strategy as advised by the RFC—by carefully processing input from a bucket brigade without presuming strict adherence to a detailed ABNF grammar and by enforcing buffer boundaries. However, while it manages buffer limits and basic protocol element termination, it does not undertake comprehensive grammar validation. Hence, it partially matches the defensive parsing requirement of the spec.",success,
7582,getsfunc_BRIGADE,A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.,173,Partially Matches,[],"The RFC specifies that a recipient, upon encountering a bare CR, must either treat the element as invalid or replace each bare CR with a SP before further processing. In the provided function, when iterating through the input data, the code explicitly checks for '\r' characters and omits them (i.e. if (*src != '\r') then copy; otherwise, ignore). This demonstrates that the function is aware of the bare CR, but it does not replace the CR with a space character (SP) nor does it consider the element invalid – it silently drops the CR. While the function does handle line termination correctly by stopping at a '\n', the treatment of bare CR values does not fully conform to the RFC requirement as stated in the spec. Therefore, the function only partially addresses the RFC specification on bare CR handling within its own logic.",success,
7582,getsfunc_BRIGADE,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Fully Matches,"[{'C1': {'code': ""if (*src == '\\n') {\n    done = 1;\n}\nelse if (*src != '\\r') {\n    *dst++ = *src;\n}"", 'explanation': 'The code explicitly checks for the newline character (LF) to terminate the line and discards any carriage return (CR) characters by not copying them. This behavior aligns with the RFC requirement that a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.'}}]","The function reads data from a bucket brigade into a buffer, and as it processes the stream, it checks each character. Upon encountering a LF, it sets a flag to end processing, while any CR characters are ignored (i.e. not written to the output). This directly implements the specified behavior from the HTTP RFC regarding line termination, fulfilling the relevant spec constraint in the function's own logic.",success,
7583,ap_scan_script_header_err_brigade,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function 'ap_scan_script_header_err_brigade' is merely a wrapper that delegates its work to 'ap_scan_script_header_err_core_ex' by passing along its parameters. There is no visible logic within this function that addresses any conditions or actions related to ensuring that a sender does not generate protocol elements reserved for other roles, as required by the RFC specification. All potential role validation or syntax checks, if any, are handled in other parts of the code (dependencies), not within this function itself.",success,
7584,ap_scan_script_header_err_brigade_ex,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function is a simple wrapper that delegates its functionality to another function (ap_scan_script_header_err_core_ex) without incorporating any logic that checks for or enforces the HTTP RFC specification regarding sender roles and generation of protocol elements. There is no code within this function that verifies if the sender is generating elements not allowed by its role (as specified in the RFC constraint). Therefore, this function does not address any of the labeled conditions or actions by itself.",success,
7586,ap_scan_script_header_err_strs_ex,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function body does not include any logic related to verifying that the sender does not generate protocol elements or syntax alternatives reserved for other roles, as required by the specification. The function is primarily focused on processing script header errors using variable arguments and calling another helper function (ap_scan_script_header_err_core_ex), without enforcing any role-based checks or grammar validations. Thus, no part of the function implements any of the specified conditions or actions (e.g., C1, A1) related to the RFC requirement.",success,
7586,ap_scan_script_header_err_strs_ex,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function mainly manages variadic argument extraction and delegates the scanning logic to ap_scan_script_header_err_core_ex. There is no visible logic within this function that verifies or enforces that protocol elements match the ABNF grammar (as required by the RFC specification). Although the function is involved in processing headers, it does not directly implement any check corresponding to the spec constraint (e.g., C1) that a sender MUST NOT generate protocol elements not adhering to the defined grammar. All actual protocol validation appears to be handled in the dependency, which does not count toward this function's implementation.",success,
7587,ap_scan_script_header_err_strs,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function is focused solely on scanning header error strings and processing variable arguments. There is no visible logic within the function that enforces any of the specified constraints about role-based generation of protocol elements as required by the HTTP RFC specification. The function does not validate or restrict the generation of protocol elements by roles, and therefore does not attempt to implement the constraint that a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles.",success,
7588,argstr_to_table,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'argstr_to_table' processes an input string by tokenizing it using '&' and '=' delimiters, then unescaping URL components before setting them in a table. It does not include any logic that checks whether the generated protocol elements conform to a specific role or that prevents the sender from generating elements reserved for other roles as required by the RFC specification. As a result, no visible code segment in this function addresses the RFC requirement that a sender must not generate protocol elements or syntax alternatives allowed only for other roles.",success,
7832,add_vary,"A recipient MAY combine multiple field lines within a field section that have the same field name into one field line, without changing the semantics of the message, by appending each subsequent field line value to the initial field line value in order, separated by a comma ("","") and optional whitespace (OWS, defined in Section 5.6.3).",231,Fully Matches,"[{'C1': {'code': 'if (*ctx->vary_this) {\n        *ctx->vary_this = apr_pstrcat(ctx->p, *ctx->vary_this, "", "", name, NULL);\n    } else {\n        *ctx->vary_this = name;\n    }', 'explanation': 'This segment implements the RFC requirement by checking if a header value already exists and, if so, appending the new value using a comma followed by a space (i.e., comma SP) for consistency. This directly reflects the specification to combine field lines with the same name by appending subsequent values with a comma and optional whitespace.'}}]","The function 'add_vary' directly addresses the RFC specification by combining multiple header field values into a single field line. It checks if a header value exists and, if true, concatenates the new header value with the existing one using a ', ' delimiter. This logic is self-contained within the function and thus fully meets the specified condition (C1) regarding combining header values using a comma and optional whitespace (in this case, a space).",success,
7838,escape_func,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function escape_func only calls the dependency function ap_escape_uri to perform URI escaping. There is no additional logic within escape_func that verifies or enforces that the generated protocol elements conform to the ABNF grammar as required by the specification. Thus, none of the conditions (e.g., C1) or actions (e.g., A1) related to ensuring compliance with the grammar are visibly addressed by this function alone.",success,
7838,escape_func,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function only calls ap_escape_uri to perform URI escaping and does not contain any logic addressing the role-based restrictions described in the RFC specification. There is no evidence in the function code that it checks or prevents the generation of protocol elements that are only allowed by participants in other roles. Therefore, no labeled condition or action from the spec constraints is implemented within this function.",success,
7873,create_multipart_context,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': ""attr = (content_type) ? strchr(content_type, ';') : NULL;\n    if (!attr)\n        return NULL; /* missing semicolon */"", 'explanation': 'This segment shows a defensive check on the content_type by looking for a semicolon, returning NULL if not found. This is a basic attempt to validate the protocol element format as suggested by the RFC.'}}, {'A1': {'code': 's = apreq_header_attribute(buf, ""boundary"", 8,\n                               (const char **)&ctx->bdry, &blen);\n    if (s != APR_SUCCESS || !blen)\n        return NULL; /* missing or empty boundary */', 'explanation': 'This code extracts the boundary attribute and verifies its existence and non-emptiness, which is part of handling received protocol elements defensively.'}}]","The function makes an effort to parse the content_type header defensively by checking for the presence of a semicolon and ensuring that a boundary is both present and non-empty. However, it does not incorporate broader defensive parsing features such as comprehensive handling of abnormal lengths or explicit ABNF conformance checks. Therefore, while some elements of defensive parsing (as indicated by C1 and A1) are implemented, the overall approach only partially meets the RFC's recommendations.",success,
7873,create_multipart_context,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function_body is focused on parsing the 'Content-Type' header to extract the boundary attribute and set up the multipart context. It performs tasks such as checking for a semicolon separator, invoking a helper to extract the boundary, and preparing the context used for multipart processing. However, none of these actions address the RFC specification constraint that requires a sender to not generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. There is no logic in the function_body that enforces role-based restrictions or validates the generation of protocol elements against grammatical rules (as defined by ABNF) for the sender. Thus, no labeled condition or action is implemented within this code, resulting in a 'Does Not Match' outcome.",success,
7874,apreq_parse_multipart,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function is a multipart parser that processes incoming HTTP message bodies. It contains logic to split the message on boundaries, parse headers, and handle file and form-data uploads. However, it does not address the specific requirement from the RFC specification: ensuring that a sender does not generate protocol elements or syntax alternatives that are only allowed for participants in other roles. No part of the function explicitly checks or prevents the generation of such role-specific protocol elements. Therefore, within the scope of this function alone, none of the labeled conditions (e.g., C1) or actions (e.g., A1) related to that specification are implemented.",success,
7874,apreq_parse_multipart,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function is a multipart parser whose logic is dedicated to consuming and interpreting incoming multipart message content. It splits boundaries, parses headers, and extracts parameters. However, the RFC specification under evaluation mandates that a sender MUST NOT generate protocol elements that do not match the grammar as defined by ABNF rules. This function does not generate (or compose) protocol elements at all; its responsibility lies in parsing and processing incoming data. Therefore, none of the labeled conditions or actions (e.g., C1, A1) that pertain to protocol element generation are addressed within this function’s body.",success,
7875,apreq_parser_make,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function simply allocates and initializes a parser object by setting its fields from the provided parameters. There is no logic within this function that validates or enforces that any generated protocol elements conform to the ABNF grammar or any other requirements specified in the RFC (such as preventing the generation of elements that are not allowed for the sender’s role). As such, the function does not implement any of the labeled conditions (e.g., C1) or actions (e.g., A1) required by the HTTP RFC specification.",success,
7886,apreq_parse_generic,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC requirement mandates that a sender must not generate protocol elements that do not match the grammar defined by the ABNF rules. In the provided function, there is no evident logic that checks or enforces that any generated protocol element conforms to an ABNF grammar. The function mainly processes bucket data, executes a hook, and performs data concatenation without performing any ABNF grammar validation. As such, it does not visibly address any constraint (e.g., C1, A1) related to ensuring the output follows the grammar, and the code does not implement any mechanism that fulfills the RFC specification requirement.",success,
7889,custom_parse_brigade,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (req->bytes_read > req->read_limit) {\n    req->body_status = APREQ_ERROR_OVERLIMIT;\n    break;\n}', 'explanation': ""This segment checks the cumulative bytes read against a pre-set limit, which is a defensive measure ensuring that the element does not exceed a 'reasonable' size. This contributes to the overall defensive parsing strategy as required by the spec.""}}]","The function demonstrates some aspects of defensive parsing as called for by the HTTP RFC: it manages incomplete data reads by partitioning the input, moves content into a temporary brigade for parsing, and importantly enforces a read limit to avoid overrun situations. However, the function relies on external calls (e.g., apreq_parser_run) for actual content parsing and validation against the element's expected ABNF grammar, and does not explicitly validate the protocol element's structure within itself. As such, while it partially meets the defensive parsing criteria—especially regarding buffer size management—it does not fully implement all the defensive expectations outlined in the RFC specification solely within its own logic.",success,
7905,apreq_handle_custom,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, apreq_handle_custom, is primarily focused on initializing a custom request handle, parsing cookie headers and query strings, and ensuring that the input bucket brigade has an end-of-stream marker. There is no visible handling or validation logic in the function that enforces the role-based restrictions as required by the RFC specification (i.e., ensuring a sender does not generate protocol elements or syntax alternatives that are reserved for other roles). No sections of the code check or enforce that only permitted elements (per the sender's role) are generated. Therefore, in isolation, this function does not address any of the spec constraints regarding role-restricted generation of protocol elements.",success,
7905,apreq_handle_custom,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC requires that a sender must not generate protocol elements that do not match the ABNF grammar. In the provided function, there is no explicit logic implemented to verify or enforce that any generated protocol elements conform to a specific ABNF grammar. The function primarily allocates a custom request handle, initializes various structures, and delegates parsing of cookies and query strings to other functions (apreq_parse_cookie_header and apreq_parse_query_string). However, since the grammar validation (if any) is not performed within this function itself, it does not visibly address the labeled spec constraint.",success,
7930,ap_hook_output_pending,"Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",308,Does Not Match,[],"The provided code function is a macro invocation (AP_IMPLEMENT_HOOK_RUN_FIRST) that registers a hook and does not contain any logic related to checking or enforcing rules regarding a parameter named ""q"" for transfer codings. There is no code in the function body that inspects parameters or performs any validation as mentioned in the spec constraints. Therefore, it does not address any of the specified conditions or actions.",success,
8027,ap_process_request_internal,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'A1': {'code': 'if (!ap_normalize_path(r->parsed_uri.path,\n                           normalize_flags |\n                           AP_NORMALIZE_DECODE_UNRESERVED)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10244)\n                  ""invalid URI path (%s)"", r->unparsed_uri);\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'This code segment checks the normalization of the URI path and, upon failure (which would occur if disallowed characters such as whitespace are present), logs an error and returns a 400 Bad Request response. This behavior complies with one acceptable branch of the spec requirement, which mandates that invalid request-lines should lead to either a 400 error or a 301 redirect. However, the function does not implement the alternative 301 redirect with the properly encoded request-target.'}}]","The function addresses part of the RFC specification by ensuring that an invalid request-line (specifically, one with an invalid URI path) results in a 400 Bad Request error. This meets one of the allowed responses according to the spec. However, it does not implement the alternate behavior of issuing a 301 (Moved Permanently) redirect with the correctly encoded request-target. Therefore, while the function partially implements the specification, it does not fully cover all of the allowed responses defined by the RFC.",success,
8027,ap_process_request_internal,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Fully Matches,"[{'C1': {'code': 'if (r->parsed_uri.path) {\n    if (!ap_normalize_path(r->parsed_uri.path,\n                           normalize_flags |\n                           AP_NORMALIZE_DECODE_UNRESERVED)) {\n        ap_log_rerror(..., ""invalid URI path (%s)"", r->unparsed_uri);\n        return HTTP_BAD_REQUEST;\n    }\n}\n...\nif (d->allow_encoded_slashes && d->decode_encoded_slashes) {\n    /* Decoding slashes might have created new // or /./ or /../ segments */\n    ap_normalize_path(r->parsed_uri.path, normalize_flags);\n}', 'explanation': 'The function explicitly performs normalization of the request URI path by calling ap_normalize_path with appropriate flags, handling decoding issues and re-normalizing if necessary. This directly addresses the RFC requirement that equivalent HTTP URIs are normalized to identify the same resource.'}}]","The provided function implements URI normalization logic internally. It normalizes the path using specific flags and conditions, which ensures that different but equivalent representations of a URI are handled consistently. This internal logic clearly meets the specification requirement from the RFC regarding the normalization of HTTP URIs.",success,
8028,prep_walk_cache,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided RFC requires that a cache may be employed by a client or server but not when acting as a tunnel. The function 'prep_walk_cache' solely handles retrieving or creating a walk cache for a request and managing inheritance from parent requests. It does not contain any logic that checks for, prevents, or addresses the use of a cache while acting as a tunnel or any similar behavior. Therefore, in isolation, the function does not address the specified RFC constraints.",success,
8031,ap_directory_walk,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The specified HTTP RFC detail concerns the use of a cache for response messages, and explicitly notes that a cache cannot be used while acting as a tunnel. In the provided function, while there is internal caching related to directory walk configurations (using a walk_cache_t structure), there is no logic that addresses HTTP response caching or any conditions related to a tunnel. The function solely deals with directory walk and configuration merging, and does not check or implement restrictions regarding caching when acting as a tunnel. Therefore, none of the spec constraints (e.g., C1 or any actions like A1) are visibly implemented in the function.",success,
8031,ap_directory_walk,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function ap_directory_walk is focused on processing file paths, canonicalizing them, merging per-directory configurations, and handling filesystem operations (such as resolving symlinks and processing htaccess files). There is no visible logic within the function that refers to or processes Content-Location header information or any transitory request context; specifically, it does not address the RFC requirement that an origin server MUST NOT use such context information to alter the request semantics. Therefore, this function does not implement the specified HTTP RFC constraint.",success,
8032,ap_location_walk,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The RFC specification specifies that while clients or servers may use a cache, they must not use it when acting as a tunnel. The provided function implements a caching mechanism for location configuration (using the walk_cache_t structure) but does not perform any check or implement logic to disable the cache when acting as a tunnel. Since the function does not address the specific restriction regarding tunneling, it does not fulfill the spec constraints.",success,
8033,ap_file_walk,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided code function, ap_file_walk, implements caching logic for file walk operations and configuration merging but does not address any part of the HTTP RFC specification stating that 'Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.' There is no logic in the function to handle HTTP caching for responses, nor is there any check regarding whether the function is operating as a tunnel. Therefore, the function does not implement any of the spec constraints (e.g., conditions C1 or actions A1) as described.",success,
8034,ap_if_walk_sub,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided function ap_if_walk_sub deals with processing conditional configuration blocks (e.g., <If> elements) and manages an internal cache used for merging per-directory configurations. However, it does not implement any logic relating to the HTTP caching specification that states 'Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.' There is no check or mechanism in the function to decide whether to use a cache based on whether the connection is acting as a tunnel, nor is there logic for handling client/server response caching as described in the spec. As such, the function does not visibly address the spec constraints.",success,
8037,ap_sub_req_output_filter,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The function 'ap_sub_req_output_filter' only manages bucket brigades by deleting end-of-stream (EOS) buckets and passing non-empty brigades onward. It does not include any logic to generate protocol elements or to validate them against ABNF grammar, as required by the RFC spec. Therefore, none of the conditions or actions (such as checking that protocol elements match the grammar) are addressed within this function.",success,
8037,ap_sub_req_output_filter,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function 'ap_sub_req_output_filter' deals solely with processing bucket brigades (e.g., deleting EOS buckets and passing non-empty brigades to the next filter). It does not contain any logic related to validating or restricting protocol elements based on the sender's role, as required by the RFC specification. No parts of the function implement conditions such as ensuring that a sender does not generate protocol elements reserved for other roles (e.g., no checks on syntax alternatives or role-based generation are present). Thus, this function does not visibly address any of the specified constraints.",success,
8055,apreq_param,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function apreq_param only retrieves a parameter from either the argument list or the body if not found in the arguments. It does not include any logic that verifies whether protocol elements are generated only by the appropriate sender role, as required by the RFC specification. There is no role checking or validation of syntax alternatives implemented in this function, so it does not address any of the labeled conditions or actions from the spec constraints.",success,
8055,apreq_param,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function apreq_param only retrieves a parameter from the request using apreq_args_get, or if that returns NULL, it retrieves the parameter from the request body using apreq_body_get. There is no logic within the function that validates or enforces that any generated protocol elements conform to the ABNF grammar as required by the RFC specification. No part of the code addresses any condition (e.g., C1) or action (e.g., A1) associated with ensuring only protocol elements matching the grammar are generated. Thus, within the function body, none of the spec constraints are implemented.",success,
8066,url_decode,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'for (; s < end; ++d, ++s) { ... switch (*s) { ... } }', 'explanation': ""The function processes the input in a loop, taking care to stay within the 'end' boundary (s < end) and examines each character defensively. It verifies that there are enough characters available (e.g., checking 's + 2 < end' before processing a percent-encoded sequence), which demonstrates a defensive approach to parsing the protocol element.""}}, {'A1': {'code': 'if (s + 2 < end && apr_isxdigit(s[1]) && apr_isxdigit(s[2])) { ... } else { *dlen = d - start; *slen = s - src; ... return APREQ_ERROR_BADSEQ; }', 'explanation': ""When encountering a '%' character, the code checks that the following characters validly form an escape sequence. If not, it returns specific error codes (APREQ_ERROR_BADSEQ or APR_INCOMPLETE), showing that it takes action on malformed input.""}}]","The function implements a defensive parsing mechanism by carefully checking buffer boundaries and the format of percent-encoded characters, fulfilling aspects of the RFC's requirement for defensive parsing. However, it does not address all nuances of the RFC—such as explicit handling of what constitutes a ""reasonable"" buffer size beyond the pointer arithmetic and lack of an explicit destination buffer size check—so it only partially matches the complete set of constraints implied by the RFC.",success,
8066,url_decode,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Fully Matches,"[{'C1': {'code': ""else {\n    *dlen = d - start;\n    *slen = s - src;\n    if (s + 5 < end\n        || (s + 2 < end && !apr_isxdigit(s[2]))\n        || (s + 1 < end && !apr_isxdigit(s[1]) && s[1] != 'u' && s[1] != 'U'))\n    {\n        *d = 0;\n        return APREQ_ERROR_BADSEQ;\n    }\n\n    memmove(d, s, end - s);\n    d[end - s] = 0;\n    return APR_INCOMPLETE;\n}"", 'explanation': ""This block handles situations where a '%' sequence may be incomplete or invalid. By either returning an error (APREQ_ERROR_BADSEQ) or copying the remaining characters and returning APR_INCOMPLETE, the code attempts to recover a usable protocol element from an invalid construct as allowed by the RFC.""}}, {'A1': {'code': ""case '%':\n    if (s + 2 < end && apr_isxdigit(s[1]) && apr_isxdigit(s[2])) {\n        *d = hex2_to_char(s + 1);\n        s += 2;\n    }\n    else if (s + 5 < end && (s[1] == 'u' || s[1] == 'U') &&\n             apr_isxdigit(s[2]) && apr_isxdigit(s[3]) &&\n             apr_isxdigit(s[4]) && apr_isxdigit(s[5])) {\n        apr_uint16_t c = hex4_to_bmp(s+2);\n\n        if (c < 0x80) {\n            *d = c;\n        }\n        else if (c < 0x800) {\n            *d++ = 0xC0 | (c >> 6);\n            *d   = 0x80 | (c & 0x3F);\n        }\n        else {\n            *d++ = 0xE0 | (c >> 12);\n            *d++ = 0x80 | ((c >> 6) & 0x3F);\n            *d   = 0x80 | (c & 0x3F);\n        }\n        s += 5;\n    }"", 'explanation': ""This segment implements the standard percent-decoding mechanism, converting valid '%'-encoded sequences into their corresponding characters. It demonstrates the function’s commitment to interpreting a protocol element according to its defined semantics.""}}]","The function 'url_decode' is designed to process and decode URL-encoded strings by converting '+' to space and handling '%'-encoded characters. It properly decodes valid sequences and, when encountering invalid or incomplete constructs, it either signals an error or attempts to recover by copying the remainder of the input (thus aligning with the RFC's allowance for recovery). Each of the key parts of the RFC—recovery from invalid constructs (C1) and proper decoding of protocol elements (A1)—is visibly addressed within this function, fulfilling the specified constraints without relying on external dependencies.",success,
8067,apreq_decode,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'apreq_decode' focuses solely on decoding URL-encoded data (i.e., checking for '%' and '+' characters and invoking a URL decode function) and does not implement any logic related to ensuring that protocol elements or syntax alternatives are generated only by participants with an appropriate role. There is no visible code that enforces sender role restrictions as required by the spec constraint. Thus, the function does not address the labeled condition/action concerning protocol element generation.",success,
8069,apreq_encode,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function is solely responsible for encoding a string into a percent-encoded format (with special handling for alphanumerics, space, etc.). It does not contain any logic to check or enforce role-based constraints, such as ensuring that protocol elements only generated by specific participants are not generated by the sender. Therefore, none of the spec constraints (e.g., condition C1 or action A1 implied by the RFC) are visibly addressed within this function.",success,
8077,apreq_header_attribute,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (!IS_TOKEN_CHAR(*hde))\n    return APREQ_ERROR_BADCHAR;\n...\nif (apr_iscntrl(*v))\n    return APREQ_ERROR_BADCHAR;', 'explanation': ""The function includes checks for valid token characters and control characters, which is an attempt to defensively parse according to the ABNF grammar. This defensive parsing approach corresponds to the RFC's recommendation for handling protocol elements. However, while these checks help validate the format, the function does not explicitly enforce any reasonable buffer size limits, a key aspect noted in the RFC context.""}}]","The provided function attempts to parse header attributes defensively by inspecting each character and returning error codes if unexpected or illegal characters are encountered. This behavior addresses part of the RFC requirement (defensive parsing against deviations from the ABNF grammar). Nonetheless, the function does not implement explicit safeguards for ensuring that the parsed element fits within a 'reasonable buffer size', which is part of the broader RFC specification context. Thus, the implementation only partially matches the overall spec constraints.",success,
8077,apreq_header_attribute,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': ""    while (IS_SPACE_CHAR(*v))\n        ++v;\n\n    ...\n\n            case ' ':\n            case '\\t':\n                if (*val == v)\n                    ++*val;\n                else\n                    ++tail;\n                ++v;\n                goto look_for_end_value;"", 'explanation': ""The RFC specifies that any allowed whitespace should be excluded before evaluating the field value. In this function, during the parsing of both the header name and value, whitespace is explicitly skipped. For instance, after encountering the '=' character, the code uses a loop 'while (IS_SPACE_CHAR(*v)) ++v;' to trim leading whitespace from the value. Similarly, in the unquoted value branch, the function adjusts the pointer (*val) and uses a 'tail' counter to effectively ignore whitespace. This demonstrates that the function meets the requirement described in the specification.""}}]","The function_body includes explicit logic to skip over whitespace characters both when parsing the header name and the header value, ensuring that any leading or trailing whitespace is removed before further evaluation. This directly addresses the requirement (labeled here as C1) from the HTTP RFC specification that mandates exclusion of such whitespace before processing the field value. All relevant logic is contained within the function, thereby fully matching the specified constraint.",success,
8077,apreq_header_attribute,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': ""case ' ':\\n    case '\\t':\\n        if (hde == hdr)\\n            ++hdr;\\n        else\\n            ++tail;\\n        ++hde;\\n        goto look_for_end_name;\\n\\n...\\nwhile (IS_SPACE_CHAR(*v))\\n    ++v;"", 'explanation': ""The code explicitly checks for spaces and tabs in both the header name (in the 'look_for_end_name' loop) and the header value (skipping leading spaces) and adjusts pointers accordingly—effectively removing unwanted whitespace before parsing the meaningful content. This directly implements the RFC requirement that a recipient must parse for and remove such bad whitespace.""}}]","The function 'apreq_header_attribute' processes header attributes by scanning through the provided header string and removing extraneous whitespace (spaces and tabs) before processing tokens and values. The removal logic is embedded directly in the function, addressing the RFC requirement that recipients remove any bad whitespace prior to interpreting protocol elements.",success,
8077,apreq_header_attribute,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': ""look_for_end_name:\n        switch (*hde) {\n        case ' ':\n        case '\\t':\n            if (hde == hdr)\n                ++hdr;\n            else\n                ++tail;\n            ++hde;\n            goto look_for_end_name;"", 'explanation': 'This segment processes optional whitespace (BWS) in the attribute name portion by skipping over space and tab characters, thus removing them before further interpretation.'}}, {'A1': {'code': ""look_for_end_value:\n                switch (*v) {\n                case ' ':\n                case '\\t':\n                    if (*val == v)\n                        ++*val;\n                    else\n                        ++tail;\n                    ++v;\n                    goto look_for_end_value;"", 'explanation': 'This segment processes optional whitespace (BWS) in the attribute value portion by adjusting the pointer, effectively removing the bad whitespace prior to using the value.'}}]","The function explicitly implements logic to remove the optional (or 'bad') whitespace as defined in the specification by scanning and skipping over space and tab characters both in the name and value parsing sections. This ensures that BWS is removed before interpretation, thereby fully addressing the relevant conditions of the HTTP RFC regarding BWS handling within the function itself.",success,
8077,apreq_header_attribute,"Specifications for newly defined fields SHOULD limit their values to visible US-ASCII octets (VCHAR), SP, and HTAB",2,Partially Matches,"[{'C1': {'code': 'if (apr_iscntrl(*v))\n    return APREQ_ERROR_BADCHAR;', 'explanation': 'This check ensures that control characters are rejected when parsing the field value. Since the RFC specifies that field values should be limited to visible US-ASCII (VCHAR), SP, and HTAB, rejecting control characters (which include CR, LF, NUL, and others) is one way to enforce that limit. However, it relies on the apr_iscntrl mechanism and does not explicitly validate against the allowed set.'}}, {'A1': {'code': ""while (IS_SPACE_CHAR(*v))\n    ++v;\n...\ncase ' ':\ncase '\\t':\n    if (*val == v)\n        ++*val;\n    else\n        ++tail;\n    ++v;\n    goto look_for_end_value;"", 'explanation': 'These segments remove or ignore leading and trailing whitespace from the field value, aligning with the RFC requirement that a field value does not include such whitespace prior to evaluation.'}}]","The function implements part of the RFC’s requirements by rejecting control characters (thereby disallowing CR, LF, NUL, etc.) and trimming whitespace from field values. This partially meets the specification that newly defined fields should be limited to visible US-ASCII octets (VCHAR), SP, and HTAB. However, the code does not explicitly verify that every character conforms to that whitelist (it instead rejects characters via control-character checks) and does not handle some alternatives such as replacing invalid characters with SP. Consequently, the function only partially addresses the listed RFC constraints within its own logic.",success,
8077,apreq_header_attribute,"Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message.",3,Partially Matches,"[{'C1': {'code': ""/* In quoted string processing */\nlook_for_end_quote:\n    switch (*v) {\n    case 0:\n    case '\\r':\n    case '\\n':\n        return APREQ_ERROR_BADSEQ;\n    case '\\\\':\n        if (v[1] != 0)\n            ++v;\n        ++v;\n        goto look_for_end_quote;\n    default:\n        if (apr_iscntrl(*v))\n            return APREQ_ERROR_BADCHAR;\n        ++v;\n        goto look_for_end_quote;\n    }\n\n/* In unquoted string processing */\nlook_for_end_value:\n    switch (*v) {\n    case 0:\n    case '\\r':\n    case '\\n':\n        done = 1;\n    case ';':\n    case ',':\n        *vlen = v - *val - tail;\n        break;\n    case ' ':\n    case '\\t':\n        if (*val == v)\n            ++*val;\n        else\n            ++tail;\n        ++v;\n        goto look_for_end_value;\n    default:\n        if (apr_iscntrl(*v))\n            return APREQ_ERROR_BADCHAR;\n        ++v;\n        tail = 0;\n        goto look_for_end_value;\n    }"", 'explanation': 'The function checks for CR, LF, and other control characters within the header attribute value. In quoted strings, encountering a CR or LF immediately results in an error (APREQ_ERROR_BADSEQ), and in unquoted values, control characters are detected (via apr_iscntrl) and trigger an error. This logic demonstrates an attempt to meet the constraint that fields containing CR, LF, or NUL characters are unsafe. However, the RFC allows either rejection or replacement with SP, and while quoted values are rejected, unquoted values are not explicitly replaced with SP but instead terminate the value parsing without an explicit replacement step.'}}]","The function partially implements the RFC requirement regarding dangerous characters in field values. It visibly checks for CR, LF, and other control characters by returning errors when they are encountered—thus effectively rejecting input with such characters in many cases. However, it does not provide an implementation to replace these characters with a space (SP) before further processing. Since the RFC allows either rejection or replacement, the function opts for rejection in quoted values and truncation in unquoted values. This approach only partially meets the RFC's specification because it does not uniformly handle the replacement action, and the logic is spread over different parsing branches.",success,
8077,apreq_header_attribute,"Field values containing other CTL characters are also invalid; however, recipients MAY retain such characters for the sake of robustness when they appear within a safe context (e.g., an application-specific quoted string that will not be processed by any downstream HTTP parser).",4,Partially Matches,"[{'C1': {'code': ""case '\\r':\ncase '\\n':\n    return APREQ_ERROR_BADSEQ;\n\n...\n\nif (apr_iscntrl(*v))\n    return APREQ_ERROR_BADCHAR;"", 'explanation': ""The RFC specifies that field values containing CR, LF, or other control characters are dangerous and must be either rejected or modified (e.g., replacing with SP). In the function, both in the quoted string parsing (via switch cases for '\\r' and '\\n') and in the unquoted value processing (via checking apr_iscntrl), the code rejects any such control characters. This matches the requirement to reject forbidden characters, though it does not implement the alternative behavior of replacing them with SP in safe contexts.""}}]","The function attempts to enforce the RFC requirements by validating header attribute values and rejecting those that contain control characters like CR, LF, or NUL. Since the spec allows for either rejection or replacement (with SP), the function's approach of returning an error when encountering invalid characters is a valid, though strict, interpretation. However, it does not attempt to preserve (retain) control characters in safe contexts (for instance, within an application‐specific quoted string), which is permitted by the RFC. As a result, while the code does address some of the labeled constraints (namely C1), it does not fully cover the optional robustness features specified, leading to a partial match.",success,
8094,ap_fcgi_header_to_array,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function 'ap_fcgi_header_to_array' simply copies values from a header structure 'h' into an array 'a' at predefined offsets. There is no logic that enforces or verifies the role-specific requirements as specified by the RFC (such as preventing the generation of protocol elements that should only be generated by other roles). Therefore, none of the labeled constraints or actions (e.g., C1, A1) related to role-based protocol element generation are addressed within this function's body.",success,
8098,ap_fcgi_fill_in_header,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function ap_fcgi_fill_in_header simply populates a FastCGI header structure by setting fixed values for version, type, request ID bytes, content length bytes, padding length, and reserved field. There is no logic in this function that checks or enforces any specific sender role or limits protocol element generation as outlined in the RFC specification. In other words, none of the conditions or actions (e.g., C1, A1) that require verifying that a sender does not generate protocol elements reserved for other roles are addressed here. All role-related validation or conformance to the HTTP messaging grammar is absent from this function.",success,
8123,ap_lingering_close,A client or server that wishes to time out SHOULD issue a graceful close on the connection.,314,Fully Matches,"[{'A1': {'code': 'if (ap_start_lingering_close(c)) {\n    apr_socket_close(csd);\n    return;\n}\n\n/* Read available data from the client whilst it continues sending\n * it, for a maximum time of MAX_SECS_TO_LINGER.  If the client\n * does not send any data within 2 seconds ... give up.\n */\napr_socket_timeout_set(csd, apr_time_from_sec(SECONDS_TO_LINGER));\napr_socket_opt_set(csd, APR_INCOMPLETE_READ, 1);\n\n/* ... loop reading until either no more data or the linger timeout has elapsed ... */\n\ndo {\n    nbytes = sizeof(dummybuf);\n    if (apr_socket_recv(csd, dummybuf, &nbytes) || nbytes == 0)\n        break;\n\n    now = apr_time_now();\n    if (timeup == 0) {\n        if (apr_table_get(c->notes, ""short-lingering-close"")) {\n            timeup = now + apr_time_from_sec(SECONDS_TO_LINGER);\n        }\n        else {\n            timeup = now + apr_time_from_sec(MAX_SECS_TO_LINGER);\n        }\n        continue;\n    }\n} while (now < timeup);\n\napr_socket_close(csd);', 'explanation': 'The function provides a graceful closure by first optionally checking whether to initiate a lingering close, then setting timeouts and reading any remaining client data in order to complete the connection shutdown gracefully before finally closing the socket.'}}]","The provided function 'ap_lingering_close' implements a graceful close of a connection, which is in line with the RFC specification that mandates a graceful shutdown when a timeout is desired. The code sets a timeout (using SECONDS_TO_LINGER and MAX_SECS_TO_LINGER), reads any remaining data, and then closes the socket. This behavior directly supports the requirement that a connection wishing to time out should issue a graceful close, thereby reclaiming resources promptly and aligning with the intended RFC behavior.",success,
8123,ap_lingering_close,"A client, server, or proxy MAY close the transport connection at any time.",316,Fully Matches,"[{'C1': {'code': 'if (ap_start_lingering_close(c)) {\n    apr_socket_close(csd);\n    return;\n}\n\n... \n\napr_socket_timeout_set(csd, apr_time_from_sec(SECONDS_TO_LINGER));\napr_socket_opt_set(csd, APR_INCOMPLETE_READ, 1);\n\n... \n\ndo {\n    nbytes = sizeof(dummybuf);\n    if (apr_socket_recv(csd, dummybuf, &nbytes) || nbytes == 0)\n        break;\n    \n    now = apr_time_now();\n    if (timeup == 0) {\n        if (apr_table_get(c->notes, ""short-lingering-close"")) {\n            timeup = now + apr_time_from_sec(SECONDS_TO_LINGER);\n        } else {\n            timeup = now + apr_time_from_sec(MAX_SECS_TO_LINGER);\n        }\n        continue;\n    }\n} while (now < timeup);\n\napr_socket_close(csd);', 'explanation': 'The function implements a graceful (lingering) close as specified by the RFC. It first checks if a lingering close should be executed immediately; if not, it sets up a timeout and attempts to read any remaining data from the connection. This behavior allows the connection to be closed gracefully even if data is still arriving, which aligns with the RFC’s allowance for a client, server, or proxy to close the transport connection at any time.'}}]","The function ap_lingering_close implements a graceful connection shutdown by either immediately closing the connection when appropriate or by engaging in a lingering process that waits (for a configurable period) to drain any pending data before closing the socket. This behavior addresses the spec requirement that a connection may be closed gracefully at any time, in accordance with the HTTP RFC.",success,
8129,etag_start,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function etag_start merely copies characters from the optional 'weak' string and appends a double quote to form an ETag. It does not include any logic to check or restrict protocol elements based on the sender’s role, as required by the RFC specification (which mandates that within a given message the sender MUST NOT generate protocol elements or syntax alternatives reserved for other roles). There is no implementation within this function that verifies role conformance or filters elements based on allowed syntax, so it does not address the labeled constraints from the provided spec.",success,
8132,ap_make_etag_ex,"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.",57,Fully Matches,"[{'C1': {'code': 'if ((er->request_time - er->finfo->mtime < (1 * APR_USEC_PER_SEC))) {\n    weak = ETAG_WEAK;\n    weak_len = sizeof(ETAG_WEAK);\n}', 'explanation': ""This code checks the time difference between the request and the file's last modification time. If the file might still be modified (within one second), it deliberately uses a weak validator, which helps ensure that the ETag reflects the ability to detect changes in a consistent manner.""}}, {'A1': {'code': 'if (er->finfo->filetype != APR_NOFILE) {\n    /* ETag gets set to [W/]\'inode-size-mtime\', modulo any FileETag keywords. */\n    etag = apr_palloc(r->pool, weak_len + sizeof(""""--"""") + 3 * CHARS_PER_UINT64 + vlv_len + 2);\n    etag_start(etag, weak, &next);\n\n    bits_added = 0;\n    if (etag_bits & ETAG_INODE) {\n        next = etag_uint64_to_hex(next, er->finfo->inode);\n        bits_added |= ETAG_INODE;\n    }\n    if (etag_bits & ETAG_SIZE) {\n        if (bits_added != 0) {\n            *next++ = \'-\';\n        }\n        next = etag_uint64_to_hex(next, er->finfo->size);\n        bits_added |= ETAG_SIZE;\n    }\n    if (etag_bits & ETAG_MTIME) {\n        if (bits_added != 0) {\n            *next++ = \'-\';\n        }\n        next = etag_uint64_to_hex(next, er->finfo->mtime);\n    }\n    etag_end(next, vlv, vlv_len);\n}', 'explanation': 'This segment creates the ETag header using file-specific attributes (inode, size, and modification time) to uniquely identify the representation. It directly implements the RFC’s recommendation to generate an entity tag that can be used for change detection and effective caching.'}}]","The function ap_make_etag_ex implements the RFC requirement by properly constructing an ETag header for a selected representation. It uses file attributes (inode, size, mtime) to generate a unique identifier, switches between strong and weak validators based on the timing of the request relative to the file's last modification, and even accounts for transparent content negotiation via a variant list validator. These implementations fully address the listed specification constraints within the function itself.",success,
8132,ap_make_etag_ex,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function, ap_make_etag_ex, is focused on generating and formatting ETag header values based on file metadata, variant list validators, and configuration flags. It does not incorporate any logic to determine or restrict the generation of protocol elements based on the sender's role, nor does it check or enforce that only elements appropriate to the sender’s role are generated. Consequently, no part of the function visibly addresses the RFC's requirement that a sender MUST NOT generate protocol elements or syntax alternatives reserved for other roles (i.e., it does not implement any constraints similar to C1, A1, etc., regarding role restrictions).",success,
8132,ap_make_etag_ex,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': '/* Constructing the ETag header with proper formatting */\n\netag = apr_palloc(r->pool, weak_len + sizeof(""\\""--\\"""") +\n                      3 * CHARS_PER_UINT64 + vlv_len + 2);\n\netag_start(etag, weak, &next);\n\nif (etag_bits & ETAG_INODE) {\n    next = etag_uint64_to_hex(next, er->finfo->inode);\n}\nif (etag_bits & ETAG_SIZE) {\n    if (bits_added != 0) {\n        *next++ = \'-\';\n    }\n    next = etag_uint64_to_hex(next, er->finfo->size);\n}\nif (etag_bits & ETAG_MTIME) {\n    if (bits_added != 0) {\n        *next++ = \'-\';\n    }\n    next = etag_uint64_to_hex(next, er->finfo->mtime);\n}\n\netag_end(next, vlv, vlv_len);', 'explanation': 'The function carefully constructs the ETag header value using helper functions (etag_start, etag_uint64_to_hex, etag_end) which encapsulate the creation of a string that obeys the protocol grammar (i.e., proper quoting, optional weak indicators, and correct separator usage). This visible logic ensures that the protocol element (ETag) adheres to the ABNF-defined grammar.'}}]","The RFC specification states that a sender must not generate protocol elements that do not match the ABNF grammar. In this function, the generation of the ETag header carefully builds a structured string (using quotes, weak tag markers like 'W/', and hex conversions) that conforms to the expected syntax. Even though some formatting details are handled by helper functions, the code in this function clearly attempts to construct a protocol element that is valid per the ABNF rules. Thus, concerning the spec constraint labeled C1, the function fully implements the necessary logic, and the outcome is 'Fully Matches'.",success,
8132,ap_make_etag_ex,"If an origin server provides an entity tag for a representation and the generation of that entity tag does not satisfy all of the characteristics of a strong validator (Section 8.8.1), then the origin server MUST mark the entity tag as weak by prefixing its opaque value with ""W/"" (case-sensitive).",266,Fully Matches,"[{'C1': {'code': 'if (er->force_weak) {\n        weak = ETAG_WEAK;\n        weak_len = sizeof(ETAG_WEAK);\n    }\n\n    ...\n\n    if ((er->request_time - er->finfo->mtime < (1 * APR_USEC_PER_SEC))) {\n        weak = ETAG_WEAK;\n        weak_len = sizeof(ETAG_WEAK);\n    }', 'explanation': 'These segments check conditions under which the ETag does not qualify as a strong validator (e.g. forced weak or proximity between request time and modification time) and therefore mark the tag as weak.'}}, {'A1': {'code': 'etag_start(etag, weak, &next);', 'explanation': ""This call uses the determined 'weak' flag (which, if set, contains the 'W/' prefix) when constructing the final ETag header, thereby ensuring that weak entity tags are properly prefixed.""}}]","The function incorporates logic to detect when the generated ETag should be considered weak by checking conditions such as a forced weak flag, a weak variant list validator, or a file modified too recently. In each case, it assigns a weak flag (ETAG_WEAK, which is expected to be 'W/') and uses it in constructing the ETag header. This directly addresses the spec requirement that non-strong validators must be marked weak by prefixing with 'W/', fulfilling the given constraints.",success,
8134,ap_set_etag,"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.",57,Fully Matches,"[{'C1': {'code': 'er.vlist_validator = r->vlist_validator;\n er.request_time = r->request_time;\n er.finfo = &r->finfo;\n er.pathname = r->filename;\n er.fd = NULL;\n er.force_weak = 0;\n\n etag = ap_make_etag_ex(r, &er);', 'explanation': 'This segment gathers representation metadata and calls ap_make_etag_ex to compute an ETag, addressing the requirement that an origin server should determine changes by producing an ETag.'}}, {'A1': {'code': 'if (etag && etag[0]) {\n    apr_table_setn(r->headers_out, ""ETag"", etag);\n}\nelse {\n    apr_table_setn(r->notes, ""no-etag"", ""omit"");\n}', 'explanation': 'This logic sends the computed ETag in the response header if available (or marks its absence), thereby directly implementing the action mandated by the RFC.'}}]","The function ap_set_etag directly implements the RFC’s guideline for providing an ETag for a selected representation. It collects all necessary metadata (addressing condition C1) and then computes an ETag via ap_make_etag_ex. Afterwards, it conditionally sets the ETag header (addressing action A1) if an ETag is generated, or notes its absence. This visible in-function logic confirms that the code function meets the specified constraints.",success,
8135,ap_set_etag_fd,"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.",57,Fully Matches,"[{'C1': {'code': 'etag = ap_make_etag_ex(r, &er);', 'explanation': 'This line computes the ETag from the request details and file information, addressing the requirement to detect changes in the selected representation.'}}, {'A1': {'code': 'if (etag && etag[0]) {\n    apr_table_setn(r->headers_out, ""ETag"", etag);\n}\nelse {\n    apr_table_setn(r->notes, ""no-etag"", ""omit"");\n}', 'explanation': 'This conditional sets the ETag header on the response if a valid ETag has been computed, or notes its omission otherwise, thus fulfilling the spec action to include an ETag if one can be determined.'}}]",The function 'ap_set_etag_fd' implements the core ETag logic according to the RFC by computing an ETag based on request and file attributes and conditionally setting it in the response headers (or marking its omission). This directly addresses the spec's recommendation that an origin server should send an ETag when changes in the representation can be reliably detected.,success,
8137,ap_make_content_type,The type/subtype MAY be followed by semicolon-delimited parameters (Section 5.6.6) in the form of name/value pairs.,259,Partially Matches,"[{'C1': {'code': 'if (apr_strmatch(charset_pattern, type, type_len) != NULL) {\n    /* already has parameter, do nothing */\n    ;\n}', 'explanation': 'This code checks if a charset parameter is already present in the type string, addressing the condition that parameters may already be appended as per the RFC.'}}, {'A1': {'code': 'else {\n    for (pcset = needcset_patterns; *pcset ; pcset++) {\n        if (apr_strmatch(*pcset, type, type_len) != NULL) {\n            struct iovec concat[3];\n            concat[0].iov_base = (void *)type;\n            concat[0].iov_len = type_len;\n            concat[1].iov_base = (void *)""; charset="";\n            concat[1].iov_len = sizeof(""; charset="") - 1;\n            concat[2].iov_base = (void *)(conf->add_default_charset_name);\n            concat[2].iov_len = strlen(conf->add_default_charset_name);\n            type = apr_pstrcatv(r->pool, concat, 3, NULL);\n            break;\n        }\n    }\n}', 'explanation': 'This segment implements the action of appending the default charset as a semicolon-delimited parameter when the type meets certain conditions (matches needcset_patterns) and does not already include a charset parameter.'}}]","The function attempts to implement part of the HTTP RFC regarding media types by verifying if a charset parameter is already provided and, if not, by appending a default charset parameter based on specific patterns. However, it only addresses the charset aspect and does not fully implement generic parameter parsing or handling as described in the complete RFC, thus resulting in a partial match.",success,
8138,ap_set_content_length,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Does Not Match,[],"The provided function only sets the Content-Length value within the request record and updates the response header with that value. It does not address any of the error checking, validation, or framing mechanisms described in the RFC specification or its constraints (such as checking Transfer-Encoding, validating Content-Length header values, or handling incomplete messages). Therefore, no labeled conditions (C1, C2, etc.) or actions (A1, A2, etc.) from the spec are implemented within the function itself.",success,
8139,ap_rationalize_mtime,"An origin server with a clock (as defined in Section 5.6.7) MUST NOT generate a Last-Modified date that is later than the server's time of message origination (Date, Section 6.6.1).",54,Fully Matches,"[{'C1': {'code': 'return (mtime > now) ? now : mtime;', 'explanation': 'This line ensures that if the supplied mtime is in the future relative to the server’s current time, it returns the current time instead. This directly addresses the requirement that the Last-Modified date must not be later than the message origination time.'}}, {'A1': {'code': 'now = (mtime < r->request_time) ? r->request_time : apr_time_now();', 'explanation': 'This segment appropriately chooses the time to compare against mtime. For static responses (where mtime is earlier than the request start time), it uses the request time; for dynamic responses, it fetches the current time. This supports obtaining a Last-Modified value as close as possible to the time the Date field is generated.'}}]","The function directly implements the RFC’s requirement by checking if the last modification time is later than the current message origination time and then replacing it with the current time if it is. Both the check and the time retrieval logic are done within the function, thereby fully addressing the constraints specified in the RFC.",success,
8139,ap_rationalize_mtime,"If the last modification time is derived from implementation-specific metadata that evaluates to some time in the future, according to the origin server's clock, then the origin server MUST replace that value with the message origination date.",265,Fully Matches,"[{'A1': {'code': 'return (mtime > now) ? now : mtime;', 'explanation': ""This line directly implements the RFC requirement by checking if the provided mtime is in the future relative to the server's current time (now) and, if so, replacing it with now (the message origination date).""}}]","The function 'ap_rationalize_mtime' calculates a reference time (now) and then checks if the input mtime is greater than this reference, indicating a future date. By returning 'now' when mtime is in the future, the function fully implements the action required by the RFC specification. No additional logic is needed in this function to meet the constraint, making the implementation self-contained and compliant.",success,
8140,ap_fgetline_core,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (n < bytes_handled + len) {\n    /* ... determine if LF falls at the edge ... */\n    if (saw_eol && !saw_nospc && ((len == 1 && ((*s)[bytes_handled - 1] == APR_ASCII_CR)) || (len > 1 && str[len - 2] == APR_ASCII_CR && n - bytes_handled + 1 == len))) {\n        saw_eol = 2;\n    } else {\n        rv = APR_ENOSPC;\n        saw_nospc = 1;\n    }\n    len = n - bytes_handled;\n    if (!len) {\n        if (saw_eol) {\n            break;\n        }\n        if (nospc_eol) {\n            continue;\n        }\n        goto cleanup;\n    }\n}', 'explanation': 'This segment shows that the function checks available buffer space before copying data and handles the situation when the incoming data might exceed the allocated buffer. In doing so, it defends against overrun and only makes marginal assumptions about the conformity and length of the input, addressing the defensive parsing requirement.'}}, {'A1': {'code': 'if (do_alloc) {\n    if (!*s) {\n        current_alloc = len;\n        *s = apr_palloc(p, current_alloc + 1);\n    } else if (bytes_handled + len > current_alloc) {\n        apr_size_t new_size = current_alloc * 2;\n        if (bytes_handled + len > new_size) {\n            new_size = (bytes_handled + len) * 2;\n        }\n        new_buffer = apr_palloc(p, new_size + 1);\n        memcpy(new_buffer, *s, bytes_handled);\n        current_alloc = new_size;\n        *s = new_buffer;\n    }\n}', 'explanation': ""This code dynamically allocates or expands the buffer as needed when appending additional data. This demonstrates that the function does not assume a fixed maximum size but rather adapts defensively to handle variable lengths, in line with the RFC's context of only marginal assumptions regarding the protocol element length.""}}]","The function ap_fgetline_core is designed to parse input defensively by carefully managing buffer sizes, checking for end-of-stream conditions, and only minimally assuming that the incoming data conforms to a specific format. The defensive checks for buffer overruns and the dynamic allocation strategies clearly address the RFC's emphasis on defensive parsing with marginal expectations of conformity and length limits. All key aspects of the spec are handled within the function itself without relying on external dependencies.",success,
8140,ap_fgetline_core,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Fully Matches,"[{'C1': {'code': 'if (last_char && (*last_char == APR_ASCII_LF)) {\n    saw_eol = 1;\n}\n\n... \n\nif (saw_eol < 2) {\n    if (last_char > *s && last_char[-1] == APR_ASCII_CR) {\n        last_char--;\n    }\n    else if (crlf) {\n        rv = APR_EINVAL;\n        goto cleanup;\n    }\n}', 'explanation': 'This code detects a LF character as the line terminator and, if the character immediately preceding it is a CR, it adjusts the termination point by moving back one character—effectively ignoring the preceding CR. This logic implements the RFC requirement that although the line terminator should be CRLF, a recipient may recognize a single LF and ignore any preceding CR.'}}]","The function contains explicit logic to detect LF as the end‐of‐line marker and, when encountered with a prior CR, to strip that CR out. This behavior directly fulfills the RFC specification regarding line terminators, and therefore the function visibly addresses the associated constraint within its own implementation.",success,
8141,ap_fgetline,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The code function ap_fgetline simply reads a line of input (delegated to ap_fgetline_core) and, in the case of EBCDIC environments, translates the input using ap_xlate_proto_from_ascii. There is no visible logic in this function that enforces or checks that protocol elements or syntax alternatives are limited to those allowed by the sender’s role as required by the RFC. In other words, it does not implement or enforce any role-based restrictions on generating protocol elements, and therefore it does not address the specified RFC constraint.",success,
8142,ap_rgetline_core,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The spec requires that within a given message, a sender must not generate protocol elements or syntax alternatives reserved for other roles. However, the function ap_rgetline only reads input lines from a protocol stream and, aside from handling character set translation for EBCDIC, does not involve logic that generates protocol elements or restricts the generation based on sender roles. There is no implementation within this function to check or enforce that the sender does not generate elements meant for another role. Therefore, no part of the code function alone addresses the labeled spec constraints.",success,
8144,ap_parse_uri,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Partially Matches,"[{'C1': {'code': ""while ((uri[0] == '/') && (uri[1] == '/')) {\n    ++uri ;\n}\n\n#if defined(OS2) || defined(WIN32)\n{\n    char *x;\n\n    for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n        *x = '/';\n}\n#endif /* OS2 || WIN32 */"", 'explanation': 'The function performs limited normalization by stripping extra leading slashes and by converting backslashes to forward slashes on OS/2 and WIN32. This addresses part of the RFC requirement that equivalent HTTP URIs (after normalization) are assumed to identify the same resource. However, the normalization is not comprehensive, so only partial credit is given.'}}]","The code function attempts to implement normalization as specified in the RFC by handling extra leading slashes and performing OS-specific path separator conversions, which partially addresses the normalization requirement of the spec. However, it does not fully implement a comprehensive URI normalization process according to the broader intent of the RFC, thus the overall match is only partial.",success,
8144,ap_parse_uri,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'C1': {'code': 'if (status == APR_SUCCESS) {\n    ...\n}\nelse {\n    r->args = NULL;\n    r->hostname = NULL;\n    r->status = HTTP_BAD_REQUEST;             /* set error status */\n    r->uri = apr_pstrdup(r->pool, uri);\n}', 'explanation': 'The spec requires that an invalid request-line be responded to with either a 400 (Bad Request) error or a 301 redirect with the request-target properly encoded. In the case where URI parsing fails (i.e. an invalid request-line), the function sets the status to HTTP_BAD_REQUEST, which meets one of the acceptable responses from the RFC.'}}]","The function attempts to implement part of the RFC by handling the error case for an invalid request-line through setting an HTTP_BAD_REQUEST status. This conforms to one of the RFC options; however, it does not address the alternative behavior (a 301 redirect with properly encoded request-target) nor does it explicitly sanitize or encode whitespace in the request-target. Since only part of the labeled conditions/actions is directly implemented within this function, the overall match is considered partial.",success,
8147,ap_check_request_header,A server that receives an Expect field value containing a member other than 100-continue MAY respond with a 417 (Expectation Failed) status code to indicate that the unexpected expectation cannot be met.,79,Fully Matches,"[{'C1': {'code': 'if (((expect = apr_table_get(r->headers_in, ""Expect"")) != NULL) && (expect[0] != \'\\0\')) {\n    if (ap_cstr_casecmp(expect, ""100-continue"") == 0) {\n        r->expecting_100 = 1;\n    }\n    else if (conf->http_expect_strict == AP_HTTP_EXPECT_STRICT_DISABLE) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02595)\n                      ""client sent an unrecognized expectation value ""\n                      ""of Expect (not fatal): %s"", expect);\n    }\n    else {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00570)\n                      ""client sent an unrecognized expectation value ""\n                      ""of Expect: %s"", expect);\n        r->status = HTTP_EXPECTATION_FAILED;\n        return 0;\n    }\n}', 'explanation': 'This segment checks for the presence of the Expect header, compares its value to ""100-continue"", and appropriately sets a flag if it matches. If not, and if strict checking is enabled, it logs the issue, sets the status code to HTTP_EXPECTATION_FAILED (417) as required by the spec.'}}]","The function explicitly inspects the Expect header. It accepts ""100-continue"" by setting a flag, while any other expectation value results in a 417 status code (if http_expect_strict is not disabled), thereby fulfilling the RFC requirement that a non-""100-continue"" expectation may be rejected with 417. All necessary logic for this specific RFC clause is implemented within the function.",success,
8147,ap_check_request_header,A recipient that processes such a URI reference MUST reject it as invalid.,224,Fully Matches,"[{'C1': {'code': 'if ((!r->hostname && (r->proto_num >= HTTP_VERSION(1, 1)))\n        || ((r->proto_num == HTTP_VERSION(1, 1))\n            && !apr_table_get(r->headers_in, ""Host""))) {\n    /* ... log error ... */\n    r->status = HTTP_BAD_REQUEST;\n    return 0;\n}', 'explanation': ""This code segment checks if the request's hostname is missing when the protocol is HTTP/1.1 or later. In those cases, it logs a message and rejects the request by setting a 400 Bad Request status. This directly implements the RFC requirement that a request with an empty host identifier must be rejected.""}}]","The provided function explicitly verifies that a hostname is present in HTTP/1.1 requests by inspecting the 'r->hostname' and the 'Host' header. If missing, it rejects the request as per the RFC's mandate. This logic is fully present within the function, addressing the condition outlined in the spec.",success,
8147,ap_check_request_header,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if ((!r->hostname && (r->proto_num >= HTTP_VERSION(1, 1)))\n        || ((r->proto_num == HTTP_VERSION(1, 1))\n            && !apr_table_get(r->headers_in, ""Host""))) {\n    ...\n    r->status = HTTP_BAD_REQUEST;\n    return 0;\n}', 'explanation': 'This segment ensures that an HTTP/1.1 request includes a Host header, in line with the requirement that a request (i.e. a sender) does not omit mandatory protocol elements. Although the RFC spec requires that a sender MUST NOT generate protocol elements that are reserved for other roles, here the function validates incoming messages by rejecting those without proper headers. Thus, it partially enforces the constraint by rejecting messages that violate the HTTP/1.1 header rules.'}}, {'A1': {'code': 'if (((expect = apr_table_get(r->headers_in, ""Expect"")) != NULL)\n    && (expect[0] != \'\\0\')) {\n    if (ap_cstr_casecmp(expect, ""100-continue"") == 0) {\n        r->expecting_100 = 1;\n    } else if (conf->http_expect_strict == AP_HTTP_EXPECT_STRICT_DISABLE) {\n        ap_log_rerror(..., ""client sent an unrecognized expectation value of Expect (not fatal): %s"", expect);\n    } else {\n        ap_log_rerror(..., ""client sent an unrecognized expectation value of Expect: %s"", expect);\n        r->status = HTTP_EXPECTATION_FAILED;\n        return 0;\n    }\n}', 'explanation': ""This block handles the Expect header by accepting only the recognized value '100-continue' or, depending on configuration, treating unrecognized expectations as errors. It reinforces protocol correctness by ensuring that only valid protocol elements (as dictated by role and configuration) are processed.""}}]","The function ap_check_request_header performs validations on incoming HTTP request headers. It checks for the mandatory Host header in HTTP/1.1 messages and validates the Expect header, rejecting requests that do not meet the protocol’s requirements. This behavior indirectly enforces the RFC requirement that a sender must not generate (or in this case, must not send) protocol elements that are invalid or reserved for other roles. However, because the RFC specification is focused on the sender’s obligation not to include inappropriately generated elements, and this function is part of the receiver‐side validation, its implementation only partially matches the spec by ensuring incoming messages conform to the header rules. Only the parts that validate required headers and restrict unexpected values can be said to fully implement aspects of the constraint.",success,
8148,table_do_fn_check_lengths,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (value == NULL || r->server->limit_req_fieldsize >= strlen(value) )\n    return 1;', 'explanation': 'This snippet checks that the header field is either NULL or its length does not exceed the configured limit, thus defensively ensuring the protocol element fits within a reasonable size.'}}, {'A1': {'code': 'r->status = HTTP_BAD_REQUEST;\napr_table_setn(r->notes, ""error-notes"", ""Size of a request header field exceeds server limit."");\nap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00560) ""Request header exceeds LimitRequestFieldSize after merging: %.*s"", field_name_len(key), key);\nreturn 0;', 'explanation': 'This section sets an error status, logs an informative message, and effectively rejects a request header that violates the size limit, aligning with the defensive handling of oversized protocol elements.'}}]","The function implements defensive checks regarding the length of a header field, ensuring that a protocol element does not exceed a reasonable buffer size (as determined by the server's configuration). This directly addresses the part of the RFC that advises defensive parsing based on expected sizes. However, it does not fully implement other aspects (like parsing according to the ABNF grammar) of the RFC specification. Thus, in isolation, the function only partially matches the complete specification requirements.",success,
8149,ap_get_mime_headers_core,"A recipient of ""message/http"" data MUST replace any obsolete line folding with one or more SP characters when the message is consumed.",213,Fully Matches,"[{'C1': {'code': ""if (*field == '\\t' || *field == ' ') {\n    /* Append any newly-read obs-fold line onto the preceding last_field line we are processing */\n    ...\n    /* Replace obs-fold w/ SP per RFC 7230 3.2.4 */\n    last_field[last_len] = ' '; \n    last_len += len;\n    continue;\n}"", 'explanation': ""The code checks for header lines starting with whitespace (indicating an obsolete folding line) and replaces the line break with a single space by explicitly setting last_field[last_len] to ' '. This directly implements the requirement from the HTTP RFC that mandates replacing obs-fold with SP.""}}]","The function 'ap_get_mime_headers_core' contains explicit logic to detect and process obsolete line folding. When a header line starts with a space or tab, the code appends the folded line to the previous header field and replaces the line break with a space, thereby fulfilling the RFC's requirement. This logic is fully contained within the function, ensuring that the specified constraint is met.",success,
8149,ap_get_mime_headers_core,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'if (strict) {\n    /* Using strict RFC7230 parsing */\n    value = (char *)ap_scan_http_token(last_field);\n    if ((value == last_field) || *value != \':\') {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02426)\n                      ""Request header field name is malformed: %.*s"", (int)LOG_NAME_MAX_LEN, last_field);\n        return;\n    }\n    *value++ = \'\\0\';\n\n    while (*value == \' \' || *value == \'\\t\') {\n        ++value;     /* Skip LWS of value */\n    }\n\n    tmp_field = (char *)ap_scan_http_field_content(value);\n\n    if (*tmp_field != \'\\0\') {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02427)\n                      ""Request header value is malformed: %.*s"", (int)LOG_NAME_MAX_LEN, value);\n        return;\n    }\n}', 'explanation': 'This segment implements strict parsing of header fields by invoking ap_scan_http_token and ap_scan_http_field_content. It validates that the header field name adheres to the token grammar and that the value contains only permitted characters. This directly enforces the requirement that generated protocol elements match the ABNF grammar as per RFC.'}}, {'A1': {'code': 'if (!strict) {\n    /* Legacy parser mode */\n    if (!(value = strchr(last_field, \':\'))) {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00564)\n                      ""Request header field is missing \':\' separator: %.*s"",\n                      (int)LOG_NAME_MAX_LEN, last_field);\n        return;\n    }\n    if (value == last_field) {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03453)\n                      ""Request header field name was empty"");\n        return;\n    }\n    *value++ = \'\\0\';\n\n    if (strpbrk(last_field, ""\\t\\n\\v\\f\\r "")) {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03452)\n                      ""Request header field name presented invalid whitespace"");\n        return;\n    }\n    while (*value == \' \' || *value == \'\\t\') {\n        ++value;\n    }\n    if (strpbrk(value, ""\\n\\v\\f\\r"")) {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03451)\n                      ""Request header field value presented bad whitespace"");\n        return;\n    }\n}', 'explanation': 'In legacy (non-strict) mode, this part of the function checks for the presence of a colon, makes sure the field name is not empty, and verifies that field names do not contain invalid whitespace. This enforces a basic adherence to the ABNF rules for token characters, aligning with the RFC requirement.'}}]","The function ap_get_mime_headers_core is responsible for processing HTTP header fields. It implements strict validations (in strict mode) using functions like ap_scan_http_token and ap_scan_http_field_content to ensure that header field names and values conform to the grammar defined by RFC7230. In legacy mode, it performs similar checks using simpler string operations. Through these validations, the function ensures that malformed or nonconforming protocol elements are rejected, thereby fully addressing the RFC requirement that a sender must not generate protocol elements that deviate from the ABNF grammar. Although the function does not generate headers, it enforces that only well-formed, grammar-compliant elements are accepted, which is in direct support of the underlying RFC specification.",success,
8149,ap_get_mime_headers_core,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'rv = ap_rgetline(&field, r->server->limit_req_fieldsize + 2,\n                         &len, r, strict ? AP_GETLINE_CRLF : 0, bb);\n\nif (rv != APR_SUCCESS) {\n    if (APR_STATUS_IS_TIMEUP(rv)) {\n        r->status = HTTP_REQUEST_TIME_OUT;\n    } else {\n        r->status = HTTP_BAD_REQUEST;\n    }\n\n    if (rv == APR_ENOSPC) {\n        apr_table_setn(r->notes, ""error-notes"",\n                       ""Size of a request header field exceeds server limit."");\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00561)\n                      ""Request header exceeds LimitRequestFieldSize%s""\n                      ""%.*s"",\n                      (field && *field) ? "": "" : """",\n                      (field) ? field_name_len(field) : 0,\n                      (field) ? field : """");\n    }\n    return;\n}', 'explanation': 'This segment enforces a limit on the size of a request header field. It reads a header line into a buffer with a maximum length (using r->server->limit_req_fieldsize), and if the limit is exceeded (APR_ENOSPC), it logs an error and returns a bad request. This aligns with the defensive parsing strategy described in the spec.'}}, {'A1': {'code': 'if (strict)\n{\n    /* Using strict RFC7230 parsing */\n    value = (char *)ap_scan_http_token(last_field);\n    if ((value == last_field) || *value != \':\') {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02426)\n                      ""Request header field name is malformed: %.*s"", (int)LOG_NAME_MAX_LEN, last_field);\n        return;\n    }\n    *value++ = \'\\0\';\n    while (*value == \' \' || *value == \'\\t\') {\n        ++value;\n    }\n    tmp_field = (char *)ap_scan_http_field_content(value);\n    if (*tmp_field != \'\\0\') {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02427)\n                      ""Request header value is malformed: %.*s"", (int)LOG_NAME_MAX_LEN, value);\n        return;\n    }\n}\nelse\n{\n    /* Legacy parser for non-strict mode */\n    if (!(value = strchr(last_field, \':\'))) {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00564)\n                      ""Request header field is missing \':\' separator: %.*s"", (int)LOG_NAME_MAX_LEN, last_field);\n        return;\n    }\n    if (value == last_field) {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03453)\n                      ""Request header field name was empty"");\n        return;\n    }\n    *value++ = \'\\0\';\n    if (strpbrk(last_field, ""\\t\\n\\v\\f\\r "")) {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03452)\n                      ""Request header field name presented invalid whitespace"");\n        return;\n    }\n    while (*value == \' \' || *value == \'\\t\') {\n         ++value;\n    }\n    if (strpbrk(value, ""\\n\\v\\f\\r"")) {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03451)\n                      ""Request header field value presented bad whitespace"");\n        return;\n    }\n}', 'explanation': ""This segment verifies that the header field name conforms at least minimally to the token rules (using ap_scan_http_token and ap_scan_http_field_content) and properly separates name and value with a colon. It represents a defensive approach by not assuming complete conformity to the ABNF grammar, in line with the spec's expectation.""}}]","The function implements a defensive parsing strategy for HTTP header fields. It specifically addresses the need for cautious validation by enforcing a size limit on header fields and performing careful parsing of the header name and value. Both the buffer size check and the minimal grammar enforcement demonstrate that the function is designed with only marginal expectations of conformity, thereby aligning with the HTTP RFC specification regarding defensive processing of protocol elements.",success,
8149,ap_get_mime_headers_core,"At a minimum, a recipient MUST be able to parse and process protocol element lengths that are at least as long as the values that it generates for those same protocol elements in other messages.",218,Partially Matches,"[{'C1': {'code': 'rv = ap_rgetline(&field, r->server->limit_req_fieldsize + 2, &len, r, strict ? AP_GETLINE_CRLF : 0, bb);\n...\nif (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {\n    r->status = HTTP_BAD_REQUEST;\n    /* report error and return */\n    return;\n}', 'explanation': 'This code segment reads header lines and checks that their lengths (including any folded continuations) do not exceed the server-configured limit (limit_req_fieldsize). This attempts to control and process protocol element lengths, addressing the RFC’s requirement that a recipient be able to handle header lengths it may generate. However, it does so only up to a preconfigured limit and does not inherently ensure that the recipient will accept header lengths as long as those it produces, hence it only partially matches the specification.'}}]","The function processes incoming MIME headers by reading each header line and handling continuation lines (obs-fold) while enforcing a maximum header field size based on the configuration. These length checks partially address the RFC requirement that a recipient must be capable of parsing protocol element lengths that are at least as long as those it generates. Since the function imposes a fixed limit rather than dynamically matching outgoing header lengths, it only partially implements the spec constraint.",success,
8149,ap_get_mime_headers_core,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Fully Matches,"[{'C1': {'code': 'while(1) {\n    apr_status_t rv;\n    field = NULL;\n    rv = ap_rgetline(&field, r->server->limit_req_fieldsize + 2, &len, r, strict ? AP_GETLINE_CRLF : 0, bb);\n    ...\n    if (*field == \'\\t\' || *field == \' \') {\n        ...\n        /* Replace obs-fold w/ SP per RFC 7230 3.2.4 */\n        last_field[last_len] = \' \';\n        last_len += len;\n        continue;\n    } else if (last_field != NULL) {\n        /* Process the previous last_field header line with all obs-folded\n         * segments already concatenated\n         */\n        if (strict) {\n            value = (char *)ap_scan_http_token(last_field);\n            if ((value == last_field) || *value != \':\') {\n                r->status = HTTP_BAD_REQUEST;\n                ...\n                return;\n            }\n            *value++ = \'\\0\';\n            while (*value == \' \' || *value == \'\\t\') { ++value; }\n            tmp_field = (char *)ap_scan_http_field_content(value);\n            if (*tmp_field != \'\\0\') {\n                r->status = HTTP_BAD_REQUEST;\n                ...\n                return;\n            }\n        } else {\n            if (!(value = strchr(last_field, \':\'))){\n                r->status = HTTP_BAD_REQUEST;\n                ...\n                return;\n            }\n            if (value == last_field) {\n                r->status = HTTP_BAD_REQUEST;\n                ...\n                return;\n            }\n            *value++ = \'\\0\';\n            while (*value == \' \' || *value == \'\\t\') { ++value; }\n            if (strpbrk(value, ""\\n\\v\\f\\r"")){\n                r->status = HTTP_BAD_REQUEST;\n                ...\n                return;\n            }\n        }\n        apr_table_addn(r->headers_in, last_field, value);\n    }\n    if (len == 0) { break; }\n    last_field = field;\n    last_len = len;\n}', 'explanation': 'This segment continuously reads header lines, processes header field folding (obs-fold), and validates the header field formatting in both strict (RFC 7230) and legacy modes. It embodies the requirement that the recipient MUST interpret the received protocol element according to the semantics defined in the specification.'}}, {'A1': {'code': 'apr_table_addn(r->headers_in, last_field, value);\napr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);', 'explanation': ""After validating and assembling header fields, the code adds them to the request's header table and compresses multiple occurrences, thereby recovering a usable protocol element even when the initial input might include continuations or nonstandard formatting.""}}]","The function 'ap_get_mime_headers_core' visibly addresses the RFC specification by implementing the logic required to interpret a received protocol element. It reads and processes header lines, handles continuation lines (obs-fold) by replacing them with a single space as per RFC 7230 Section 3.2.4, and conducts strict validations in its 'strict' mode branch. Errors are flagged immediately when a header field does not conform to the expected format. Additionally, it recovers a complete and usable header set by adding validated fields to the headers_in table. This comprehensive, in-function implementation fully meets the intended behavior described in the RFC specification.",success,
8149,ap_get_mime_headers_core,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': ""while (len > 1 && (field[len-1] == '\\t' || field[len-1] == ' ')) {\n    field[--len] = '\\0';\n}\n...\nwhile (*value == ' ' || *value == '\\t') {\n     ++value;\n}"", 'explanation': ""The RFC requires that any whitespace allowed in the message be excluded before evaluating the field value. In this function, trailing whitespace on the header line is removed (via the loop that null‐terminates after skipping '\\t' and ' ') and, in both strict and legacy parsing, leading whitespace after the colon is skipped (via the loop 'while (*value == ' ' || *value == '\\t')'). This shows that the implementation itself attempts to exclude unwanted whitespace before further evaluating the field value.""}}]","The function explicitly trims trailing whitespace from the header lines and skips leading whitespace after the colon delimiter, directly addressing the RFC's requirement to remove extraneous whitespace prior to field evaluation. Therefore, the logic within this function fully implements the constraint as described in the RFC.",success,
8149,ap_get_mime_headers_core,"If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.",202,Partially Matches,[],"The RFC requirement is that if an unrecoverable error occurs in a request message, the server must respond with a 400 (Bad Request) status code and then close the connection. In this function, several error conditions (for example, when ap_rgetline fails or when header fields are malformed) result in setting r->status to HTTP_BAD_REQUEST. This shows that the function is attempting to address the error response part of the RFC. However, the function does not include any explicit logic to send the 400 response or to close the connection – it simply sets the error status and returns. Since the complete action (sending a 400 response and closing the connection) is not fully handled within this function alone, the implementation only partially matches the specified RFC constraint.",success,
8149,ap_get_mime_headers_core,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': ""while (len > 1 && (field[len-1] == '\\t' || field[len-1] == ' ')) {\n    field[--len] = '\\0';\n}"", 'explanation': 'This loop trims any extra trailing whitespace from header lines, ensuring that bad whitespace is removed before further processing.'}}, {'A1': {'code': ""if (*field == '\\t' || *field == ' ') {\n    ...\n    while (field[1] == '\\t' || field[1] == ' ') {\n         ++field; --len;\n    }\n    ...\n    last_field[last_len] = ' ';\n    last_len += len;\n    continue;\n}"", 'explanation': 'This section handles obs-fold lines by discarding leading whitespace and replacing the folded newline (obs-fold) with a single space, thus normalizing the whitespace as specified.'}}]","The function explicitly removes unwanted extra whitespace by trimming trailing spaces/tabs and by normalizing line folding (obs-fold) into a single space. These code segments demonstrate that the function itself parses for bad whitespace and removes it before interpreting the header fields, thereby fully addressing the specified RFC requirement.",success,
8149,ap_get_mime_headers_core,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': ""while (len > 1 && (field[len-1] == '\\t' || field[len-1] == ' ')) {\n    field[--len] = '\\0';\n}"", 'explanation': 'This code segment removes trailing whitespace (BWS) from header lines, fulfilling the requirement to remove any extraneous BWS as per the spec.'}}, {'A1': {'code': ""/* Replace obs-fold w/ SP per RFC 7230 3.2.4 */\nlast_field[last_len] = ' ';"", 'explanation': ""This segment explicitly replaces obsolete line folding with a single space, directly addressing the spec's directive to ignore additional whitespace.""}}]",The function implements the HTTP RFC requirement concerning bad whitespace (BWS) by collapsing trailing whitespace from header fields and normalizing folded lines by replacing them with a single space. These implementations are directly within the function_body and meet the labeled conditions and actions specified in the RFC context.,success,
8149,ap_get_mime_headers_core,"A server MUST reject, with a response status code of 400 (Bad Request), any received request message that contains whitespace between a header field name and colon.",185,Fully Matches,"[{'C1': {'code': 'if (strpbrk(last_field, ""\\t\\n\\v\\f\\r "")) {\n    r->status = HTTP_BAD_REQUEST;\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03452)\n                  ""Request header field name presented invalid whitespace"");\n    return;\n}\n\n/* ... and in strict mode ... */\nvalue = (char *)ap_scan_http_token(last_field);\nif ((value == last_field) || *value != \':\') {\n    r->status = HTTP_BAD_REQUEST;\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02426)\n                  ""Request header field name is malformed: %.*s"", (int)LOG_NAME_MAX_LEN, last_field);\n    return;\n}', 'explanation': 'The RFC requires that any request header containing whitespace between the header field name and the colon be rejected with a 400 status. In the legacy (non‐strict) branch, the function checks for any whitespace in the header field name with strpbrk() and rejects the request if such whitespace is found. In strict mode, the use of ap_scan_http_token ensures that only valid token characters (i.e. no whitespace) are accepted. This directly implements the specification.'}}]","The provided function includes explicit checks to ensure that header field names do not contain whitespace (either via strpbrk in legacy mode or ap_scan_http_token in strict mode), which matches the RFC requirement to reject requests with whitespace between the header field name and colon. Thus, within the function, the constraint is fully addressed.",success,
8149,ap_get_mime_headers_core,"Specifications for newly defined fields SHOULD limit their values to visible US-ASCII octets (VCHAR), SP, and HTAB",2,Partially Matches,"[{'A1': {'code': ""/* Replace obs-fold w/ SP per RFC 7230 3.2.4 */\n            last_field[last_len] = ' ';"", 'explanation': 'When processing a header line that is a continuation (obs-fold), the function explicitly replaces the fold with a single SP as required by the RFC.'}}, {'C1': {'code': 'if (strpbrk(value, ""\\n\\v\\f\\r"")) {\n                    r->status = HTTP_BAD_REQUEST;\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03451)\n                                  ""Request header field value presented bad whitespace"");\n                    return;\n                }\n\n                /* In strict mode: validate field content */\n                tmp_field = (char *)ap_scan_http_field_content(value);\n                if (*tmp_field != \'\\0\') {\n                    r->status = HTTP_BAD_REQUEST;\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02427)\n                                  ""Request header value is malformed: %.*s"",\n                                  (int)LOG_NAME_MAX_LEN, value);\n                    return;\n                }', 'explanation': 'The function performs validations in both non-strict and strict modes to check that header field values do not contain invalid control characters such as CR, LF, and other CTLs. This is an attempt to enforce the RFC requirement that field values be composed only of acceptable characters (visible US-ASCII, SP, and HTAB), though it delegates part of this check to helper functions.'}}]","The function addresses parts of the HTTP RFC concerning header field line processing and validation. It explicitly replaces obs-fold sequences with a space (A1) and validates header values against forbidden control characters (C1) via direct checks and by calling ap_scan_http_field_content. However, it does not fully enforce the constraint that newly defined fields are limited only to visible US-ASCII octets (VCHAR), SP, and HTAB within this function alone. Some of that responsibility is deferred to its helper functions, which leads to the overall assessment of a partial match.",success,
8149,ap_get_mime_headers_core,"Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message.",3,Partially Matches,"[{'C1': {'code': 'if (strpbrk(value, ""\\n\\v\\f\\r"")) {\n    r->status = HTTP_BAD_REQUEST;\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03451)\n                  ""Request header field value presented bad whitespace"");\n    return;\n}\n\n/* ... In strict mode: */\n\ntmp_field = (char *)ap_scan_http_field_content(value);\nif (*tmp_field != \'\\0\') {\n    r->status = HTTP_BAD_REQUEST;\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02427)\n                  ""Request header value is malformed: %.*s"", (int)LOG_NAME_MAX_LEN, value);\n    return;\n}\n\n/* And for header folding, replacement with SP: */\n\nlast_field[last_len] = \' \';', 'explanation': 'The code function explicitly rejects header values containing CR and LF characters (using strpbrk in non‐strict mode and ap_scan_http_field_content in strict mode) and replaces the line-break from obs-fold lines with a space per RFC 7230. However, there is no explicit check for NUL characters. Thus, while it addresses part of the spec (CR and LF), it does not fully meet the requirement regarding NUL.'}}]","The function implements logic that handles dangerous control characters in header field values by rejecting or replacing CR and LF characters. It collapses trailing whitespace and replaces obs-fold newline breaks with a SP. However, the spec also requires that any NUL characters in field values must be rejected or replaced with a space, and the code does not show an explicit check for NUL. Consequently, the function partially matches the spec constraints by addressing CR and LF handling but not a full check or handling of NUL.",success,
8149,ap_get_mime_headers_core,"A server that receives an obs-fold in a request message that is not within a ""message/http"" container MUST either reject the message by sending a 400 (Bad Request), preferably with a representation explaining that obsolete line folding is unacceptable, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.",186,Fully Matches,"[{'C1': {'code': 'if (*field == \'\\t\' || *field == \' \') {\n    /* Append any newly-read obs-fold line onto the preceding\n     * last_field line we are processing\n     */\n    if (last_field == NULL) {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03442)\n                      ""Line folding encountered before first header line"");\n        return;\n    }\n    if (field[1] == \'\\0\') {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03443)\n                      ""Empty folded line encountered"");\n        return;\n    }\n    ...\n}', 'explanation': 'The function detects obs-fold lines (i.e. header lines starting with a space or tab), and if such a line occurs before any header (last_field is NULL) or if it is empty after the initial whitespace, the function rejects the request with a 400 status, thereby addressing the requirement to reject messages with inappropriate obs-fold usage.'}}, {'A1': {'code': ""/* Replace obs-fold w/ SP per RFC 7230 3.2.4 */\nlast_field[last_len] = ' ';\nlast_len += len;"", 'explanation': 'For valid obs-fold lines, the function replaces the line break (obs-fold) with a single space character, fulfilling the RFC mandate to replace each received obs-fold with one or more SP octets before further interpretation.'}}]","The function fully handles the RFC requirement for obs-fold processing in request messages. It immediately rejects cases where an obs-fold appears in an incorrect position (before any header line or as an empty folded line) by sending a 400 response, or it properly replaces valid obs-fold occurrences with a space prior to further processing of the header. This direct handling within the function meets both the condition (C1) of detecting obs-fold outside a proper context and the action (A1) of replacing the obs-fold with SP, thereby fully meeting the specified RFC constraint.",success,
8149,ap_get_mime_headers_core,"A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the ""message/http"" media type.",301,Fully Matches,"[{'C1': {'code': 'if (*field == \'\\t\' || *field == \' \') {\n    /* Append any newly-read obs-fold line onto the preceding\n     * last_field line we are processing\n     */\n    if (last_field == NULL) {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03442)\n                      ""Line folding encountered before first header line"");\n        return;\n    }\n\n    if (field[1] == \'\\0\') {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03443)\n                      ""Empty folded line encountered"");\n        return;\n    }\n\n    /* Leading whitespace on an obs-fold line can be\n     * similarly discarded */\n    while (field[1] == \'\\t\' || field[1] == \' \') {\n        ++field; --len;\n    }\n\n    /* Append the fold: replace the obs-fold with a single SP */\n    memcpy(last_field + last_len, field, len + 1); /* +1 for nul */\n    last_field[last_len] = \' \';\n    last_len += len;\n    continue;\n}', 'explanation': 'This segment detects lines starting with a horizontal tab or space, identifies them as obs-fold lines, and replaces the folding CRLF with a single space (SP), which directly implements the RFC requirement to either reject or normalize obs-fold by replacement.'}}]","The function explicitly handles header field folding by checking for lines that begin with whitespace. If an obs-fold line is detected, it either rejects the message (if encountered in an illegal position) or appends the line to the previous header value after replacing the obs-fold with a single SP. This behavior fulfills the RFC requirement to either reject a request containing an obs-fold (outside of a message/http packaging) or replace it with SP octets prior to processing.",success,
8149,ap_get_mime_headers_core,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",175,Fully Matches,"[{'C1': {'code': 'if (*field == \'\\t\' || *field == \' \') {\n    if (last_field == NULL) {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03442)\n                      ""Line folding encountered before first header line"");\n        return;\n    }\n\n    if (field[1] == \'\\0\') {\n        r->status = HTTP_BAD_REQUEST;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03443)\n                      ""Empty folded line encountered"");\n        return;\n    }', 'explanation': 'This code inspects header lines beginning with whitespace and rejects them (by setting r->status to HTTP_BAD_REQUEST) if they occur before any valid header is processed. This directly implements the RFC requirement that whitespace-only lines between the start-line and the first header should be either rejected or consumed.'}}, {'A1': {'code': 'if (rv != APR_SUCCESS) {\n    if (APR_STATUS_IS_TIMEUP(rv)) {\n        r->status = HTTP_REQUEST_TIME_OUT;\n    }\n    else {\n        r->status = HTTP_BAD_REQUEST;\n    }\n    return;\n}\n\n...\n\nif (!(value = strchr(last_field, \':\'))) {\n    r->status = HTTP_BAD_REQUEST;\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00564)\n                  ""Request header field is missing \':\' separator: %.*s"",\n                  (int)LOG_NAME_MAX_LEN, last_field);\n    return;\n}', 'explanation': 'Throughout the function, multiple checks verify that header fields meet the HTTP-message grammar. When any mismatch is detected (e.g., header field too long, missing colon, or invalid whitespace in field names/values), the status is set to HTTP_BAD_REQUEST, which fulfills the RFC direction to respond with a 400 error for non-compliant requests.'}}]","The function ap_get_mime_headers_core incorporates validation logic that parses the header fields and detects various grammar violations—including improper whitespace handling, missing colon delimiters, and header size overflows. In each case, it sets the request status to HTTP_BAD_REQUEST (or HTTP_REQUEST_TIME_OUT on timeout) and returns immediately. This behavior directly addresses the RFC specification requirement to respond with a 400 (Bad Request) when encountering octets that do not match the HTTP-message grammar, thereby fulfilling both the conditions (such as whitespace rules) and the action (issuing a 400 response) as specified.",success,
8151,ap_create_request,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function ap_create_request initializes a request_rec structure by allocating memory, setting default fields, and establishing table structures for headers and environment data. However, there is no logic within this function that checks or enforces role-based restrictions on generating protocol elements as required by the RFC spec (i.e., ensuring that a sender does not generate elements reserved for another role). There is no code that relates to validating or preventing the generation of prohibited protocol elements. Therefore, the function does not visibly address any conditions (such as C1, etc.) or actions (such as A1, etc.) as described in the specification context.",success,
8151,ap_create_request,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The provided function initializes several tables including 'headers_in', 'trailers_in', 'headers_out', and 'trailers_out', but it does not contain any logic addressing the RFC requirement regarding merging trailer fields into a header section. There is no check or validation that the trailer field is understood or that its merging is safe, which is the core of the specified requirement. Therefore, the function does not attempt to implement the specified constraint.",success,
8154,ap_assign_request_line,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'r->the_request = apr_pstrcat(r->pool, r->method, *uri ? "" "" : NULL, uri, *r->protocol ? "" "" : NULL, r->protocol, NULL);', 'explanation': 'This line reconstructs the request line using single SP characters between fields as required by the ABNF grammar. It shows an attempt to generate a properly formatted protocol element.'}}, {'A1': {'code': 'if (strict) {\n    if (r->parsed_uri.fragment) {\n        /* RFC3986 3.5: no fragment */\n        ...\n    }\n    if (r->parsed_uri.user || r->parsed_uri.password) {\n        ...\n    }\n}', 'explanation': 'Under strict conformance, the function checks for disallowed URI components (e.g., fragments, username/password), thereby enforcing parts of the syntax requirements defined by the corresponding ABNF rules.'}}]","The function attempts to generate and validate the request line according to the HTTP specification by ensuring that the protocol elements are constructed with appropriate spacing and by rejecting URIs with components (like fragments or credentials) that are not allowed. However, many of the details of ABNF-based grammar checks are performed in helper functions (such as r_assign_protocol and ap_parse_uri) or are implicitly handled. Thus, while the function visibly addresses some of the constraints (by reconstructing the request line and validating certain URI components), it only partially implements the full specification requirements within its own logic.",success,
8154,ap_assign_request_line,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (r->status == HTTP_OK\n        && (r->parsed_uri.path != NULL)\n        && (r->parsed_uri.path[0] != \'/\')\n        && (r->method_number != M_OPTIONS\n            || strcmp(r->parsed_uri.path, ""*"") != 0)) {\n    /* Invalid request-target per RFC 7230 section 5.3 */\n    r->status = HTTP_BAD_REQUEST;\n}', 'explanation': ""This segment ensures that the URI’s path conforms to a minimal expected format (begins with '/') unless the request target is '*' for OPTIONS. It is an example of defensive parsing of the protocol element as suggested by the RFC, though it does not check buffer sizes or cover the full margin of expectations.""}}]","The provided function attempts to implement a defensive parsing approach by validating the request line components (method, URI, protocol) and rejecting malformed inputs. For instance, it checks that the URI path starts with a '/' (or is acceptable per OPTIONS) and applies protocol conformity checks, which aligns partially with the RFC's recommendation to parse elements defensively. However, it does not include explicit validations regarding buffer size limits or completely ensure conformance to the ABNF grammar expectations stated in the RFC. Therefore, while some defensive measures are in place, the implementation only partially meets the spec constraints.",success,
8154,ap_assign_request_line,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Fully Matches,"[{'C1': {'code': 'int strict = (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE);\nhttp_error error = r_assign_protocol(r, protocol, strict);', 'explanation': 'This segment shows that the function immediately interprets the received protocol element using a strictness flag (derived from configuration). This aligns with the requirement to interpret the protocol element according to the defined semantics.'}}, {'A1': {'code': 'if (error != http_error_none) {\n    switch (error) {\n        case http_error_badprotocol:\n            ...\n            break;\n        case http_error_reject09:\n            ...\n            break;\n        case http_error_badmethod09:\n            ...\n            break;\n        default:\n            break;\n    }\n    r->status = HTTP_BAD_REQUEST;\n    goto failed;\n}\n...\nfailed:\n    if (error != http_error_none && r->proto_num == HTTP_VERSION(0, 9)) {\n        r->assbackwards = 0;\n        r->connection->keepalive = AP_CONN_CLOSE;\n        r->proto_num = HTTP_VERSION(1, 0);\n        r->protocol  = ""HTTP/1.0"";\n    }', 'explanation': 'This code block implements recovery when errors are detected in the protocol parsing. It handles error reporting and, specifically for HTTP/0.9 requests, adjusts the protocol to a viable HTTP/1.0 response. This meets the action requirement to attempt recovery from invalid constructs.'}}]","The provided function body processes the incoming request line by interpreting the protocol element, method, and URI. It uses a configuration-driven strictness mode to validate the protocol and applies error handling and recovery mechanisms inline (such as adjusting a malformed HTTP/0.9 request to HTTP/1.0). Both the interpretation step (C1) and the recovery mechanism (A1) are implemented directly within this function, thus fully meeting the constraints specified.",success,
8154,ap_assign_request_line,"A sender MUST NOT generate the userinfo subcomponent (and its ""@"" delimiter) when an ""http"" or ""https"" URI reference is generated within a message as a target URI or field value.",229,Fully Matches,"[{'C1': {'code': 'if (strict) {\n    if (r->parsed_uri.user || r->parsed_uri.password) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02422)\n                      ""HTTP Request Line; URI must not contain a username/password"");\n        r->status = HTTP_BAD_REQUEST;\n        goto failed;\n    }\n}', 'explanation': 'The RFC specifies that the sender must not generate a userinfo subcomponent (i.e. username or password) when creating an HTTP/HTTPS URI. In this function, when running in strict mode, the code checks for the presence of r->parsed_uri.user or r->parsed_uri.password. If either is found, it logs an error and rejects the request by setting HTTP_BAD_REQUEST. This directly addresses the requirement.'}}]","The function examines the parsed URI for any user or password components and rejects the request if they are present when in strict mode. This directly implements the constraint from the RFC that the userinfo subcomponent must not be generated (or received) in HTTP or HTTPS URI references. As the code implements this validation logic directly within the function, it fully meets the labeled constraint.",success,
8154,ap_assign_request_line,"Before making use of an ""http"" or ""https"" URI reference received from an untrusted source, a recipient SHOULD parse for userinfo and treat its presence as an error; it is likely being used to obscure the authority for the sake of phishing attacks.",230,Fully Matches,"[{'C1': {'code': 'if (strict) {\n        if (r->parsed_uri.user || r->parsed_uri.password) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02422)\n                          ""HTTP Request Line; URI must not contain a username/password"");\n            r->status = HTTP_BAD_REQUEST;\n            goto failed;\n        }\n    }', 'explanation': 'This code segment checks, when strict mode is enabled, whether the parsed URI contains a user or password, and if so, logs an error and marks the request as a bad request. This directly satisfies the RFC requirement to parse for userinfo and treat its presence as an error.'}}]","The function includes explicit logic to inspect the parsed URI for user and password components, and treats their presence as an error by updating the request status. This behavior directly matches the RFC specification which states that any userinfo in an http/https URI from an untrusted source should be treated as an error to prevent phishing attempts.",success,
8154,ap_assign_request_line,An origin server that receives a request method that is unrecognized or not implemented SHOULD respond with the 501 (Not Implemented) status code.,59,Fully Matches,"[{'C1': {'code': 'if (conf->http_methods == AP_HTTP_METHODS_REGISTERED\n        && r->method_number == M_INVALID) {\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02423)\n                  ""HTTP Request Line; Unrecognized HTTP method: \'%.*s\' ""\n                  ""(disallowed by RegisteredMethods)"",\n                  field_name_len(r->method), r->method);\n    r->status = HTTP_NOT_IMPLEMENTED;\n    /* This can\'t happen in an HTTP/0.9 request, we verified GET above */\n    goto failed;\n}', 'explanation': 'The code checks if the HTTP method is unrecognized (i.e. r->method_number is M_INVALID) and then assigns the status HTTP_NOT_IMPLEMENTED (501) as required by the RFC. This directly addresses the spec condition that an unrecognized or unimplemented method should result in a 501 response.'}}]","The provided code function includes explicit logic to handle an unrecognized HTTP method by verifying if the method number is M_INVALID and then setting the status code to HTTP_NOT_IMPLEMENTED (501). This directly meets the RFC requirement that an origin server should respond with a 501 status code for an unrecognized or not implemented request method. Hence, the function fully implements the relevant spec condition.",success,
8154,ap_assign_request_line,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'C1': {'code': 'ap_parse_uri(r, uri);\nif (r->status == HTTP_OK\n        && (r->parsed_uri.path != NULL)\n        && (r->parsed_uri.path[0] != \'/\')\n        && (r->method_number != M_OPTIONS\n            || strcmp(r->parsed_uri.path, ""*"") != 0)) {\n    /* Invalid request-target per RFC 7230 section 5.3 */\n    r->status = HTTP_BAD_REQUEST;\n}', 'explanation': ""This segment checks that the request-target is valid by ensuring the URI path starts with a '/' (except for the '*' option), and if not, it sets the status to HTTP_BAD_REQUEST. This implements part of the requirement to respond to an invalid request-line with an error response.""}}, {'A1': {'code': 'r->status = HTTP_BAD_REQUEST;', 'explanation': 'Throughout the function, when an inconsistency or invalid part of the request-line is detected, the function assigns HTTP_BAD_REQUEST to r->status. This addresses the spec directive that an invalid request-line must lead to a 400 error response.'}}]","The RFC specifies that recipients of an invalid request-line should respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded. This function enforces error handling by validating the request-target (e.g., ensuring it starts with a '/') and by assigning a 400 error in cases where the target is malformed. It does not attempt to perform a 301 redirect with proper encoding. Since the RFC permits the use of a 400 error as an acceptable response and the function avoids any form of autocorrection, the implementation partially meets the specification. However, because it does not implement the alternate 301 redirect behavior nor explicitly check for or encode whitespace in the request-target within the function itself, it only partially matches the spec constraints.",success,
8154,ap_assign_request_line,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",175,Partially Matches,"[{'C1': {'code': 'if (error != http_error_none) {\n    switch (error) {\n    case http_error_badprotocol:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(10388)\n                      ""HTTP Request: Unrecognized protocol \'%.*s\' ""\n                      ""(perhaps whitespace was injected?)"",\n                      field_name_len(r->protocol), r->protocol);\n        break;\n    case http_error_reject09:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02401)\n                      ""HTTP Request: Rejected HTTP/0.9 request"");\n        break;\n    case http_error_badmethod09:\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03444)\n                      ""HTTP Request: Invalid method token: \'%.*s\'""\n                      "" (only GET is allowed for HTTP/0.9 requests)"",\n                      field_name_len(r->method), r->method);\n        break;\n    default:\n        break;\n    }\n    r->status = HTTP_BAD_REQUEST;\n    goto failed;\n}', 'explanation': 'This segment checks for protocol and method errors and, when an error is detected (indicating the request does not match the expected HTTP-message grammar), it assigns a 400 (Bad Request) status.'}}, {'A1': {'code': 'if (error != http_error_none && r->proto_num == HTTP_VERSION(0, 9)) {\n    r->assbackwards = 0;\n    r->connection->keepalive = AP_CONN_CLOSE;\n    r->proto_num = HTTP_VERSION(1, 0);\n    r->protocol  = ""HTTP/1.0"";\n}', 'explanation': 'This code handles the error branch for HTTP/0.9 requests, ensuring that when a protocol error is detected, the connection is marked to close (by disabling keepalive), which aligns with the action of responding with 400 and closing the connection.'}}]","The function partially implements the RFC requirement by checking for parsing errors in the request line (such as invalid protocol, method, or URI issues) and assigning an HTTP 400 (Bad Request) status when these are detected. Additionally, for HTTP/0.9 requests, it further ensures the connection is closed. However, the provided RFC also specifies handling for cases like extraneous whitespace between the start-line and header fields (either by rejecting or ignoring such lines), and this function does not explicitly address that part. Thus, while the function addresses critical error handling that leads to a 400 response, it does not fully cover all robustness exceptions as detailed in the RFC.",success,
8154,ap_assign_request_line,"A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain.",298,Fully Matches,"[{'C1': {'code': 'if (r->status == HTTP_OK\n        && (r->parsed_uri.path != NULL)\n        && (r->parsed_uri.path[0] != \'/\')\n        && (r->method_number != M_OPTIONS || strcmp(r->parsed_uri.path, ""*"") != 0)) {\n        /* Invalid request-target per RFC 7230 section 5.3 */\n        r->status = HTTP_BAD_REQUEST;\n    }', 'explanation': 'This code verifies the format of the request-target by checking that the parsed URI path starts with a \'/\' (with an exception for OPTIONS with ""*""). It rejects malformed request-lines by setting the status to HTTP_BAD_REQUEST rather than trying to autocorrect the input, which is in line with the RFC requirement not to autocorrect and then process the request without redirecting.'}}, {'A1': {'code': 'if (r->status != HTTP_OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, ...);\n        goto failed;\n    }', 'explanation': ""Upon detecting an invalid request-line or URI, the function responds by logging the error and early exiting (using 'goto failed'), ensuring that malformed requests are not silently corrected but instead result in an error response (HTTP_BAD_REQUEST), which is compliant with the RFC's prescribed action.""}}]","The function examines the request-line by parsing the URI and ensuring that the request-target does not contain incorrect formatting (such as missing a leading '/'). It does not attempt to autocorrect malformed input but instead sets an error status, thereby strictly rejecting invalid requests. This behavior matches the HTTP RFC specification that instructs recipients not to autocorrect and process the request without a redirect, making the function a correct implementation of the spec's requirement within its own logic.",success,
8155,ap_read_request,"A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain.",298,Fully Matches,"[{'A1': {'code': 'if (!ap_assign_request_line(r, method, uri, protocol)) {\n    apr_brigade_cleanup(tmp_bb);\n    switch (r->status) {\n    case HTTP_REQUEST_URI_TOO_LARGE:\n    case HTTP_BAD_REQUEST:\n    case HTTP_VERSION_NOT_SUPPORTED:\n    case HTTP_NOT_IMPLEMENTED:\n        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00565)\n                          ""request failed: client\'s request-line exceeds LimitRequestLine (longer than %d)"",\n                          r->server->limit_req_line);\n        }\n        else if (!strcmp(""-"", r->method)) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00566)\n                          ""request failed: malformed request line"");\n        }\n        access_status = r->status;\n        goto die_unusable_input;\n    \n    case HTTP_REQUEST_TIME_OUT:\n        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, NULL);\n        if (!r->connection->keepalives)\n            ap_run_log_transaction(r);\n        break;\n    }\n    conn->keepalive = AP_CONN_CLOSE;\n    apr_pool_destroy(r->pool);\n    goto ignore;\n}', 'explanation': 'The function calls ap_assign_request_line to parse the request-line. If that fails—due to an invalid (possibly whitespace-containing) request-target or other malformation—it immediately skips any attempt at correction and instead logs the error, sets an appropriate error status, and aborts further processing. This directly implements the RFC requirement that a recipient SHOULD NOT autocorrect an invalid request-line but instead respond with an error.'}}]","Analyzing the function, we see that the request-line is validated via ap_assign_request_line. In the event of failure, no correction or re-encoding is attempted. Instead, the code cleanly aborts processing by logging the error and preparing an error response, thereby satisfying the RFC's requirement to avoid autocorrection. All necessary logic to enforce this behavior is contained within the function itself.",success,
8155,ap_read_request,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'if (breq) {\n    /* If there is a request, we always process it, as it defines\n     * the context in which a potential error bucket is handled. */\n    if (apr_pool_is_ancestor(r->pool, breq->pool)) {\n        method = breq->method;\n        uri = breq->uri;\n        protocol = breq->protocol;\n        headers = breq->headers;\n    }\n    else {\n        method = apr_pstrdup(r->pool, breq->method);\n        uri = apr_pstrdup(r->pool, breq->uri);\n        protocol = apr_pstrdup(r->pool, breq->protocol);\n        headers = breq->headers? apr_table_clone(r->pool, breq->headers) : NULL;\n    }\n\n    if (!method || !uri || !protocol) {\n        access_status = berr? ((ap_bucket_error *)(berr->data))->status :\n                          HTTP_INTERNAL_SERVER_ERROR;\n        goto die_unusable_input;\n    }\n\n    ...\n}', 'explanation': 'This segment of code shows that when a valid request bucket is present, the function attempts to extract (and if necessary, duplicate) the critical request elements. This behavior reflects the RFC provision that a recipient MAY try to recover a usable protocol element despite potentially invalid constructs. However, the recovery is implemented only in this context and other malformed constructs are not recovered, resulting in an overall partial match.'}}]","The function uses logic to extract and validate request data, including recovery steps (such as duplicating the request line when needed) that align with the RFC's allowance to recover usable protocol elements from invalid input. While this behavior partially covers the requirement of attempting recovery, not all error cases or malformed inputs are managed to recover a request element—in several cases the function directly logs an error and terminates processing. Therefore, the function only partially matches the spec constraint related to recovery.",success,
8155,ap_read_request,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'rv = ap_get_brigade(r->proto_input_filters, tmp_bb, AP_MODE_READBYTES, APR_BLOCK_READ, 0);\nif (rv != APR_SUCCESS || APR_BRIGADE_EMPTY(tmp_bb)) {\n    /* Not worth dying with. */\n    conn->keepalive = AP_CONN_CLOSE;\n    apr_pool_destroy(r->pool);\n    goto ignore;\n}', 'explanation': 'This segment demonstrates defensive parsing by checking that the bucket brigade is successfully read and not empty. It then safely terminates the connection if the expected protocol element is not present, in line with using only marginal expectations about the input.'}}, {'A1': {'code': 'if (!ap_assign_request_line(r, method, uri, protocol)) {\n    apr_brigade_cleanup(tmp_bb);\n    switch (r->status) {\n    case HTTP_REQUEST_URI_TOO_LARGE:\n    case HTTP_BAD_REQUEST:\n    case HTTP_VERSION_NOT_SUPPORTED:\n    case HTTP_NOT_IMPLEMENTED:\n        ...\n        access_status = r->status;\n        goto die_unusable_input;\n\n    case HTTP_REQUEST_TIME_OUT:\n        ...\n        break;\n    }\n    conn->keepalive = AP_CONN_CLOSE;\n    apr_pool_destroy(r->pool);\n    goto ignore;\n}', 'explanation': 'Here, the function validates the request line (method, URI, protocol) and handles error conditions defensively, consistent with the RFC requirement to parse protocol elements with minimal assumptions.'}}]","The function ap_read_request implements defensive parsing by verifying the integrity of incoming data using bucket brigades and by checking for essential protocol elements (like the request line components). It carefully handles abnormal conditions—such as missing or unexpected data—by logging errors, cleaning up resources, and closing connections. This strategy of cautious validation directly addresses the RFC specification that mandates the recipient to 'parse a received protocol element defensively' with only marginal assumptions about conformity and buffer size.",success,
8155,ap_read_request,"If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value).",201,Partially Matches,[],"The RFC specification dictates that if a message is received without Transfer-Encoding and with an invalid Content-Length header, then the message framing is invalid and MUST be treated as an error – except when the header value is a comma‐separated list in which all values are valid and identical. In the function, the check for Content-Length is done in the block:

    if (!r->assbackwards) {
        const char *clen = apr_table_get(r->headers_in, ""Content-Length"");
        if (clen) {
            apr_off_t cl;
            if (!ap_parse_strict_length(&cl, clen)) {
                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(10242)
                              ""client sent invalid Content-Length (%s): %s"", clen, r->uri);
                access_status = HTTP_BAD_REQUEST;
                goto die_unusable_input;
            }
        }
    }

This code attempts to enforce that an invalid Content-Length header leads to a 400 error, which is in line with the RFC’s requirement to treat such messages as unrecoverable errors. However, it does not implement the exception described in the spec where a comma‐separated list of Content-Length values that are valid and identical should be accepted. Since that exception condition is not checked, the function only partially implements the RFC constraint. No other parts of the provided spec (conditions or actions) are directly implemented in the function.

Thus, while the function does address an aspect of the spec by rejecting invalid Content-Length values, it does not fully implement the exception allowed for a comma‐separated list and therefore only partially matches the specification.",success,
8155,ap_read_request,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'A1': {'code': 'if (!ap_assign_request_line(r, method, uri, protocol)) {\n    apr_brigade_cleanup(tmp_bb);\n    switch (r->status) {\n    case HTTP_REQUEST_URI_TOO_LARGE:\n    case HTTP_BAD_REQUEST:\n    case HTTP_VERSION_NOT_SUPPORTED:\n    case HTTP_NOT_IMPLEMENTED:\n        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00565)\n                          ""request failed: client\'s request-line exceeds LimitRequestLine (longer than %d)"",\n                          r->server->limit_req_line);\n        }\n        else if (!strcmp(""-"", r->method)) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00566)\n                          ""request failed: malformed request line"");\n        }\n        access_status = r->status;\n        goto die_unusable_input;\n    case HTTP_REQUEST_TIME_OUT:\n        ap_update_child_status(conn->sbh, SERVER_BUSY_LOG, NULL);\n        if (!r->connection->keepalives)\n            ap_run_log_transaction(r);\n        break;\n    }\n    conn->keepalive = AP_CONN_CLOSE;\n    apr_pool_destroy(r->pool);\n    goto ignore;\n}', 'explanation': 'When the function fails to assign a valid request line (which could include invalid characters such as whitespace), it does not attempt to auto‐correct the request. Instead, it responds with an error through a 400 Bad Request (and related error statuses) by calling ap_die, which meets part of the spec requirement to respond with a 400 error on invalid request-lines.'}}]","The HTTP RFC specifies that a recipient of an invalid request-line must respond with either a 400 Bad Request error or a 301 redirect with a properly encoded request-target, and that no autocorrection should be applied. The provided function checks the validity of the request line via a call to ap_assign_request_line. In the event of a failure, it routes the processing to an error handler that eventually calls ap_die with a 400 (or related) error status. This behavior handles the 400 error response requirement. However, the code does not implement any logic for a 301 redirect with properly encoded request-target, and it does not perform any explicit request-target encoding. Therefore, while the function partially addresses the specified HTTP RFC (by ensuring invalid request-lines yield an error response without autocorrecting), it does not fully implement all the allowed behaviors (specifically the 301 redirect action).",success,
8155,ap_read_request,A server that receives a request-target longer than any URI it wishes to parse MUST respond with a 414 (URI Too Long) status code (see Section 15.5.15 of [HTTP]).,179,Fully Matches,"[{'C1': {'code': 'if (!ap_assign_request_line(r, method, uri, protocol)) {\n    ...\n    switch (r->status) {\n    case HTTP_REQUEST_URI_TOO_LARGE:\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00565)\n                      ""request failed: client\'s request-line exceeds LimitRequestLine (longer than %d)"",\n                      r->server->limit_req_line);\n        access_status = r->status;\n        goto die_unusable_input;\n    ...\n    } \n}', 'explanation': 'This segment detects a failure in parsing the request line (via ap_assign_request_line) and, when the status is HTTP_REQUEST_URI_TOO_LARGE (which corresponds to a 414 response), it logs the error and proceeds to an error handling routine. This is in line with the RFC requirement to return a 414 when the request-target exceeds the acceptable URI length.'}}, {'A1': {'code': 'ap_die(access_status, r);', 'explanation': 'After determining the error condition (including the 414 case), the function calls ap_die() with the error status, which results in the appropriate HTTP error response being sent to the client.'}}]","The function attempts to implement the RFC requirement regarding overlong request-targets by first delegating the parsing of the request-line to ap_assign_request_line. If that parsing fails, it checks the r->status; specifically, if the status is HTTP_REQUEST_URI_TOO_LARGE (indicative of a request-target longer than allowed), it logs the event and later calls ap_die() to send the corresponding 414 error response. Although the actual length check is performed in a dependency, the error handling (including logging and response sending) for the overlong request-target is implemented within this function, thereby fully meeting the specified constraint.",success,
8157,strip_headers_request_body,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The provided function unconditionally removes the 'Content-Length' header among others without validating whether its value is incorrect or matching the allowed format (including the exception for a repeated decimal value). The RFC requires that a sender MUST NOT forward a message with a Content-Length header value that is known to be incorrect, and while the function may prevent forwarding an incorrect value by stripping the header, it does not perform any checks to determine correctness. Therefore, the function does not visibly address the specific condition outlined in the RFC by itself.",success,
8157,strip_headers_request_body,"Likewise, a sender MUST NOT forward a message with a Content-Length header field value that does not match the ABNF above, with one exception: a recipient of a Content-Length header field value consisting of the same decimal value repeated as a comma-separated list (e.g, ""Content-Length: 42, 42"") MAY either reject the message as invalid or replace that invalid field value with a single instance of the decimal value, since this likely indicates that a duplicate was generated or combined by an upstream message processor.",49,Does Not Match,[],"The function simply removes a predetermined list of headers, including the Content-Length header, from the request. It does not contain any logic to validate the Content-Length header against the ABNF or to handle comma-separated duplicate Content-Length values as specified in the RFC. Therefore, none of the conditions (e.g., ensuring the header matches the proper format or handling duplicates) or actions (e.g., rejecting or replacing duplicate values) outlined in the RFC constraints are implemented in this function.",success,
8158,ap_set_sub_req_protocol,A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 requests (or later minor revisions); such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response.,196,Partially Matches,"[{'C1': {'code': 'if (!r->kept_body && (apr_table_get(r->headers_in, ""Content-Length"")\n        || apr_table_get(r->headers_in, ""Transfer-Encoding""))) {\n    strip_headers_request_body(rnew);\n}', 'explanation': ""This code segment checks for the existence of a body header, in particular 'Transfer-Encoding', and strips it from the subrequest. This helps to ensure that the subrequest does not inadvertently include a Transfer-Encoding header, which aligns with the RFC requirement of not sending such headers unless the server is known to handle HTTP/1.1 requests. However, it does not perform any check to confirm if the target server supports HTTP/1.1, so it only partially meets the specification.""}}]","The provided function makes an effort to avoid including the Transfer-Encoding header in a subrequest by stripping headers if a request body is present. This indirectly supports the RFC's guideline that a request should not include Transfer-Encoding unless the server can handle HTTP/1.1. However, the function does not include logic to determine if the server supports HTTP/1.1, and therefore, while it addresses part of the constraint (removing the header), it does not fully implement the requirement as specified in the RFC.",success,
8158,ap_set_sub_req_protocol,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC specification requires that a sender must not generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. In this function, while various fields of a subrequest (such as the method and protocol) are being set, there is no logic that validates or ensures that the generated protocol elements conform to the ABNF grammar. For example, the function sets rnew->protocol to ""INCLUDED"", which does not appear to be derived from any ABNF-based validation or generation mechanism. Thus, no part of the function visibly addresses the condition of only generating valid protocol elements according to ABNF.",success,
8158,ap_set_sub_req_protocol,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function ap_set_sub_req_protocol only adjusts the subrequest fields by copying values and setting predefined flags and static parameters (such as setting method to GET and protocol to ""INCLUDED""). It does not contain any logic that verifies or enforces that protocol elements are generated only by participants valid for those elements, as required by the RFC specification. There is no code that implements any checks or restrictions based on the sender's role, and therefore it does not address the RFC constraints directly within its scope.",success,
8158,ap_set_sub_req_protocol,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The function primarily copies existing header and trailer tables from the original request to the subrequest without any explicit logic to enforce the RFC requirements regarding multiple header fields (i.e., avoiding multiple field lines with the same name or ensuring their order is maintained unless a comma‐separated list is allowed). The code does not inspect, rearrange, or validate the handling of duplicate header fields, and thus it does not visibly address the specific conditions and actions stated in the spec constraints.",success,
8158,ap_set_sub_req_protocol,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The RFC requires that a sender must not forward a message with a Content-Length header value that is known to be incorrect (or improperly formatted). In this function, while there is a condition where if a Content-Length (or Transfer-Encoding) header exists and the request body is not retained, the code calls strip_headers_request_body(rnew), this only strips the header based on its presence rather than validating its correctness against the ABNF or ensuring that the value is accurate. The function does not include any logic to verify whether the Content-Length is correct, improperly formatted, or duplicated per the specification. Therefore, the function does not visibly handle the spec constraint regarding the Content-Length validation.",success,
8165,ap_get_basic_auth_pw,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'A1': {'code': ""while (*auth_line == ' ' || *auth_line == '\\t') {\n    auth_line++;\n}"", 'explanation': 'This loop explicitly skips over any leading spaces or horizontal tabs (i.e. bad whitespace, BWS) in the authorization header. This directly addresses the RFC requirement that a recipient must remove any BWS before interpreting the protocol element.'}}]",The function ap_get_basic_auth_pw demonstrates a clear intention to meet the RFC specification regarding the removal of bad whitespace (BWS) by including a loop that advances the pointer past any leading spaces or tabs. This implementation is self-contained within the function and fully meets the corresponding action (A1) as specified by the RFC context.,success,
8165,ap_get_basic_auth_pw,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': ""while (*auth_line == ' ' || *auth_line == '\\t') {\n    auth_line++;\n}"", 'explanation': ""This loop explicitly removes leading whitespace (spaces and tab characters) from the 'auth_line' string, which complies with the RFC requirement that any bad whitespace must be parsed and removed before further processing.""}}]","The function 'ap_get_basic_auth_pw' implements the specified RFC behavior by removing leading whitespace from the authorization header after confirming the 'Basic' scheme. The loop that skips over ' ' and '\t' characters directly addresses the spec constraint that a recipient MUST parse for such bad whitespace and remove it, thereby ensuring correct interpretation of the protocol element.",success,
8165,ap_get_basic_auth_pw,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': ""while (*auth_line == ' ' || *auth_line == '\\t') {\n    auth_line++;\n}"", 'explanation': 'This loop explicitly advances the pointer past any spaces or horizontal tabs before the field value is processed, thereby excluding leading whitespace as required by the RFC specification.'}}]","The provided function checks the Authorization header and, after verifying the 'Basic' scheme, removes any leading whitespace from the auth_line using a while loop. This functionality directly implements the RFC requirement to exclude any whitespace prior to evaluating the field value, fulfilling the relevant constraint entirely within this function.",success,
8166,ap_get_basic_auth_components,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (!credentials) {\n        /* No auth header. */\n        return APR_EINVAL;\n    }', 'explanation': 'This segment checks for the presence of an authentication header which is a basic requirement for interpreting the protocol element as described in the RFC.'}}, {'C2': {'code': 'if (ap_cstr_casecmp(ap_getword(r->pool, &credentials, \' \'), ""Basic"")) {\n        /* These aren\'t Basic credentials. */\n        return APR_EINVAL;\n    }', 'explanation': ""This segment verifies that the provided credentials use the 'Basic' scheme, ensuring the protocol element is interpreted as Basic authentication.""}}, {'A1': {'code': ""decoded = ap_pbase64decode(r->pool, credentials);\nuser = ap_getword_nulls(r->pool, &decoded, ':');\n\nif (username) {\n    *username = user;\n}\nif (password) {\n    *password = decoded;\n}"", 'explanation': 'This segment decodes the base64 credentials and splits them into username and password, which addresses the action of extracting the content per the protocol semantics.'}}]","The function demonstrates several aspects of protocol element interpretation as required by the RFC. It checks for the existence of an authentication header (C1), ensures that the authentication scheme is 'Basic' (C2), and decodes the base64 credentials to extract the username and password (A1). However, it lacks robust error recovery for malformed base64 strings and does not attempt to handle extensions or invalid constructs beyond simple token verification. As a result, while several constraints are addressed, the implementation does not fully cover all aspects implied by the RFC, leading to a 'Partially Matches' assessment.",success,
8167,ap_content_length_filter,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, ap_content_length_filter, focuses on processing the bucket brigade to compute and set the Content-Length header based on the transmitted data. It does not contain any logic that enforces or checks that protocol elements or syntax alternatives are only generated by participants with the appropriate role as specified in the RFC. There is no inspection or restriction of which protocol elements are generated relative to the sender's role, and hence no evidence that the function addresses the spec constraint requiring a sender not to generate elements reserved for other roles.",success,
8167,ap_content_length_filter,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function implements a content-length filter that calculates and sets the Content-Length header based on the data processed in a bucket brigade. However, it does not include any logic that verifies or enforces that the protocol elements it generates (e.g., header values or bucket elements) adhere to the ABNF grammar rules specified by HTTP. There is no visible check or transformation ensuring that only grammar-valid protocol elements are generated. Therefore, none of the labeled conditions or actions (e.g., C1, A1) from the spec constraints regarding the prohibition on generating protocol elements that do not match the defined grammar are implemented in the function.",success,
8167,ap_content_length_filter,A server MAY send a Content-Length header field in a response to a HEAD request (Section 9.3.2); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a response if the same request had used the GET method.,43,Fully Matches,"[{'C1': {'code': 'if (ctx->data_sent == 0 && eos) {\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n\n    if (!((r->header_only || AP_STATUS_IS_HEADER_ONLY(r->status))\n          && !r->bytes_sent\n          && (r->sent_bodyct\n              || conf->http_cl_head_zero != AP_HTTP_CL_HEAD_ZERO_ENABLE\n              || apr_table_get(r->headers_out, ""Content-Length"")))) {\n        ap_set_content_length(r, r->bytes_sent);\n    }\n}', 'explanation': 'This portion of the code checks if the complete response has been processed (eos reached and no data already sent) and conditionally sets the Content-Length header. It specifically avoids setting a Content-Length for HEAD responses (or in cases where the backend would have sent no payload) unless the computed byte count reflects what a GET response would have sent. This logic directly reflects the RFC requirement that a server MUST NOT send a Content-Length header in a HEAD response unless its value equals the decimal number of octets that would have been sent for a GET.'}}]","The function computes the total bytes (mimicking a GET response by summing bucket lengths) and then uses a conditional block to decide whether to set the Content-Length header. The check for header-only responses and the specific condition to avoid sending a 0 Content-Length unless appropriate clearly demonstrate it addresses the RFC specification. All necessary checks are performed within this function, fulfilling the labeled constraint.",success,
8167,ap_content_length_filter,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'C1': {'code': 'if (ctx->data_sent == 0 && eos) {\n    ...\n    if (!((r->header_only || AP_STATUS_IS_HEADER_ONLY(r->status))\n          && !r->bytes_sent\n          && (r->sent_bodyct\n              || conf->http_cl_head_zero != AP_HTTP_CL_HEAD_ZERO_ENABLE\n              || apr_table_get(r->headers_out, ""Content-Length"")))) {\n        ap_set_content_length(r, r->bytes_sent);\n    }\n}', 'explanation': 'This segment is responsible for setting the Content-Length header when the entire response is in memory (i.e. when an EOS bucket is encountered) and no data has yet been sent to the network. It computes the content length using the accumulated r->bytes_sent and calls ap_set_content_length, which is an attempt to implement the RFC’s requirement to send a Content-Length header when the content size is known.'}}]","The function attempts to implement part of the RFC: when the full response has been processed (EOS reached) and no part of the body has been sent yet, it calculates and sets the Content-Length header. However, it does not explicitly check for the absence of Transfer-Encoding nor does it verify that the response status isn’t one of those (such as 1xx or 204) for which the Content-Length header should not be sent as specified in the RFC context. As a result, while some aspects of the condition (i.e. sending the header when the content length is known) are addressed, not all detailed RFC constraints are fully implemented in this function, leading to a partial match.",success,
8167,ap_content_length_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The RFC mandates that the sender must not forward a message with a Content-Length header that is known to be incorrect. In the provided function, the logic centers on counting the bytes as the buckets flow through and, if no data has been sent and an end‐of‐stream is reached, calling ap_set_content_length() to set the Content-Length header based on the computed r->bytes_sent value. While this approach ensures that when possible the server sets a fresh Content-Length header to the computed value, the function does not verify or cross-check any pre‐existing Content-Length header for correctness or conformity with the ABNF. There is no logic that detects an incorrect or inconsistent Content-Length value before forwarding the message. Therefore, regarding the specific constraint from the RFC (i.e. not forwarding a message with a known incorrect Content-Length), the function does not visibly address that requirement on its own.",success,
8167,ap_content_length_filter,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Partially Matches,"[{'A1': {'code': 'if (ctx->data_sent == 0 && eos) {\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    if (!((r->header_only || AP_STATUS_IS_HEADER_ONLY(r->status))\n          && !r->bytes_sent\n          && (r->sent_bodyct\n              || conf->http_cl_head_zero != AP_HTTP_CL_HEAD_ZERO_ENABLE\n              || apr_table_get(r->headers_out, ""Content-Length"")))) {\n        ap_set_content_length(r, r->bytes_sent);\n    }\n}', 'explanation': 'This code segment accumulates the total number of bytes sent and, if the entire response has been processed (EOS seen) and no data has been sent downstream yet, it sets the Content-Length header. This addresses the RFC’s suggestion that a server SHOULD generate length-delimited messages whenever possible.'}}]","The function implements logic to accumulate the length of the response and conditionally sets the Content-Length header when the entire response body is available. This supports one part of the RFC specification—using length-delimited messages. However, it does not handle other aspects noted in the RFC context (such as error handling for invalid Content-Length headers, dealing with transfer-encoding cases, or managing incomplete message bodies). Therefore, only some of the spec constraints (in this case, the action of generating length-delimited messages) are visibly addressed by this code function.",success,
8180,ap_set_last_modified,"When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.",245,Fully Matches,"[{'C1': {'code': 'apr_rfc822_date(datestr, mod_time);', 'explanation': ""This function call formats the modification time using APR's rfc822_date function, which produces a date string that complies with the HTTP-date standard (IMF-fixdate) required by the RFC.""}}]","The function ap_set_last_modified generates the Last-Modified header by formatting the mod_time with apr_rfc822_date. This formatting is intended to produce a date string compliant with the IMF-fixdate specification for HTTP-date fields, thereby directly addressing the RFC constraint. All logic ensuring the timestamp is in the required format is contained within the function itself.",success,
8180,ap_set_last_modified,"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.",52,Fully Matches,"[{'C1': {'code': 'if (!r->assbackwards) { ... }', 'explanation': 'The code first checks that the request is not in a backward compatibility mode (r->assbackwards). This implies that the function will only proceed to set the Last-Modified header when it is appropriate to do so, fulfilling the condition that the last modification date can be reasonably determined.'}}, {'A1': {'code': 'apr_table_setn(r->headers_out, ""Last-Modified"", datestr);', 'explanation': ""After determining the modification time, the function formats it as an RFC822 date and sets the 'Last-Modified' header in the response. This directly implements the action of sending the Last-Modified header as recommended by the RFC.""}}]","The function ap_set_last_modified directly computes a normalized modification time and sets the Last-Modified header using a formatted date string. This meets the RFC's requirement that an origin server should send Last-Modified for any selected representation, making the implementation fully compliant with the provided spec constraints.",success,
8181,ap_set_std_response_headers,"When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.",245,Does Not Match,[],"The RFC specification requires that when generating HTTP-date timestamps, the sender MUST use the IMF-fixdate format. In this function, the Date header is generated using the function ap_recent_rfc822_date, which suggests that the date is produced in RFC822 format rather than the required IMF-fixdate format. There is no logic in the function that verifies or reformats the timestamp to comply with the IMF-fixdate specification. Thus, the function does not visibly address the constraint set forth in the specification.",success,
8181,ap_set_std_response_headers,An origin server MAY generate a Server header field in its responses.,89,Fully Matches,"[{'C1': {'code': 'if (!server)\n    server = ap_get_server_banner();\nif (server && *server)\n    apr_table_setn(r->headers_out, ""Server"", server);', 'explanation': ""This segment explicitly checks if the 'Server' header is absent and then assigns a server banner via ap_get_server_banner(), thereby ensuring a Server header field is generated as per the RFC specification.""}}]","The provided function implements the RFC requirement by ensuring that a 'Server' header is present in the response. Specifically, if the header is initially missing, the code retrieves a server banner with ap_get_server_banner() and sets the 'Server' header field. This directly addresses the specification that an origin server MAY generate a Server header in its responses, fulfilling the labeled constraint (C1) entirely within the function body.",success,
8181,ap_set_std_response_headers,A sender that generates a Date header field SHOULD generate its field value as the best available approximation of the date and time of message generation.,15,Fully Matches,"[{'C1': {'code': 's = apr_palloc(r->pool, APR_RFC822_DATE_LEN);\nap_recent_rfc822_date(s, r->request_time);\ndate = s;\napr_table_setn(r->headers_out, ""Date"", date);', 'explanation': 'This code segment generates a Date header field using the r->request_time value to approximate the message generation time, which is in line with the RFC specification that the Date field should be the best available approximation of the time at which the message is generated.'}}]","The function ap_set_std_response_headers directly addresses the RFC requirement by ensuring that a Date header field is set. It allocates memory, generates the date using a function (ap_recent_rfc822_date) based on the request_time, and sets the Date header in the outgoing headers. This logic within the function itself implements the spec condition that the Date header field value should be the best available approximation of the message generation time.",success,
8182,ap_send_interim_response,* A server that receives a 100-continue expectation in an HTTP/1.0 request MUST ignore that expectation.,80,Fully Matches,"[{'C1': {'code': ""if (r->proto_num < HTTP_VERSION(1,1)) {\n    /* don't send interim response to HTTP/1.0 Client */\n    return;\n}"", 'explanation': 'This code checks whether the request protocol is HTTP/1.0 (i.e., less than HTTP/1.1) and immediately returns without sending an interim (100 Continue) response. This directly implements the RFC requirement that a server ignore a 100-continue expectation in an HTTP/1.0 request.'}}]","The function_body explicitly handles the case for HTTP/1.0 requests by checking if the protocol is less than HTTP/1.1 and then returning early, thereby ignoring any 100-continue expectation. This satisfies the specified RFC requirement directly within the function itself.",success,
8182,ap_send_interim_response,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,[],"The provided function implements several checks before sending an interim HTTP response. It verifies that the protocol version is at least HTTP/1.1, that the status code is a valid informational (1xx) code, and in the case of a 100 Continue response, it ensures the request actually includes an Expect: 100-continue header. These checks are related to ensuring that the proper protocol elements are sent only under allowed circumstances. However, the RFC specification requires that a sender must not produce protocol elements that are only allowed to be generated by participants in other roles. The function does not explicitly check or enforce role restrictions – it conditions sending responses solely on protocol version and state (like the expecting_100 flag), rather than on the sender’s role per se. Since the RFC’s role-based restriction is only partially addressed through these state checks and not directly enforced in the function, the code only partially matches the spec constraint.",success,
8182,ap_send_interim_response,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': ""if (r->proto_num < HTTP_VERSION(1,1)) {\n    /* don't send interim response to HTTP/1.0 Client */\n    return;\n}"", 'explanation': 'This check prevents the function from sending interim responses to HTTP/1.0 clients. Since earlier versions might not support the full ABNF-defined grammar for interim responses, this helps avoid generating protocol elements that could be nonconformant.'}}, {'A1': {'code': 'if (!ap_is_HTTP_INFO(r->status)) {\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00575) ""Status is %d - not sending interim response"", r->status);\n    return;\n}', 'explanation': 'This condition ensures that only HTTP INFO statuses (which follow the proper definitions in the protocol) trigger an interim response. By rejecting unexpected statuses, it aims to keep the generated protocol elements within the prescribed grammar.'}}]","The function implements checks that restrict interim responses to only those cases which are likely to be valid under HTTP/1.1 (or higher) and for HTTP INFO statuses. These checks help in avoiding the generation of protocol elements that might not follow the ABNF grammar. However, the function does not explicitly validate every field against the ABNF rules; instead, it relies on helper functions (such as the routines that create response buckets) to construct the response. Thus, while the function does include logic that attempts to conform to the specification (by conditionally not sending responses in cases that may risk nonconformity), it only partially fulfills the RFC’s requirement from within its own code.",success,
8182,ap_send_interim_response,The origin server MUST NOT wait for the content before sending the 100 (Continue) response.,84,Fully Matches,"[{'C1': {'code': ""if (r->status == HTTP_CONTINUE) {\n    if (!r->expecting_100) {\n        /* Don't send 100-Continue when there was no Expect header */\n        return;\n    }\n\n    for (rr = r; rr != NULL; rr = rr->main) {\n        rr->expecting_100 = 0;\n    }\n}"", 'explanation': 'This segment checks that the request has the Expect: 100-continue header (via r->expecting_100) and immediately processes the 100 (Continue) response by clearing the expecting flag from the current and any parent requests. It thereby bypasses waiting for the request content, which is in direct alignment with the spec requirement that the origin server must not wait for content before sending the 100 response.'}}, {'A1': {'code': 'bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\nif (send_headers) {\n    ap_set_std_response_headers(r);\n}\nb = ap_bucket_response_create(r->status, reason,\n                              send_headers ? r->headers_out : NULL,\n                              r->notes, r->pool, r->connection->bucket_alloc);\nAPR_BRIGADE_INSERT_TAIL(bb, b);\n...\nap_pass_brigade(r->proto_output_filters, bb);', 'explanation': ""This block of code constructs and dispatches the interim (100 Continue) response using Apache's output filtering mechanism. It sends the response immediately after verifying conditions without waiting for any request body, fulfilling the action requirement.""}}]","The function checks if the request is HTTP/1.1 or later and whether it is expecting a 100-continue response. If the appropriate conditions are met, it immediately sends an interim response without waiting for the content. This behavior directly implements the specified RFC requirement. All the logic necessary for this functionality is contained within the function itself, hence it fully matches the requirement.",success,
8182,ap_send_interim_response,A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content).,193,Does Not Match,[],"The RFC constraint requires that the server MUST NOT send a Transfer-Encoding header field in any 1xx (Informational) or 204 response. In the provided function, there is logic to check if the response status is informational (1xx) before sending an interim response, but there is no explicit logic to inspect or remove the Transfer-Encoding header field. The function simply calls ap_set_std_response_headers when send_headers is true and then clears r->headers_out after creating the bucket, but it does not verify or ensure that a Transfer-Encoding header field is not present. Therefore, within this function there is no visible implementation specifically addressing the RFC requirement regarding the Transfer-Encoding header.",success,
8182,ap_send_interim_response,"Since HTTP/1.0 did not define any 1xx status codes, a server MUST NOT send a 1xx response to an HTTP/1.0 client.",139,Fully Matches,"[{'C1': {'code': ""if (r->proto_num < HTTP_VERSION(1,1)) {\n        /* don't send interim response to HTTP/1.0 Client */\n        return;\n    }"", 'explanation': ""This code segment checks if the client's protocol is less than HTTP/1.1 (i.e., HTTP/1.0) and immediately returns without sending any 1xx interim response, directly fulfilling the requirement that a server MUST NOT send a 1xx response to an HTTP/1.0 client.""}}]","The function explicitly ensures that if the client is using HTTP/1.0 (or any protocol version lower than 1.1), it will not send a 1xx interim response. This behavior directly implements the relevant HTTP/1.0 constraint from the RFC specification.",success,
8243,ap_recent_rfc822_date,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function solely formats a date string in the RFC 822 format from a given time. It does not contain any logic related to ensuring that the sender does not generate protocol elements or syntax alternatives reserved for other roles, as required by the specification. No portion of the function attempts to enforce role-based restrictions or grammar checks dictated by the HTTP RFC spec, so it does not address any of the labeled constraints.",success,
8379,create_core_dir_config,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The function 'create_core_dir_config' is strictly focused on memory allocation and initialization of a configuration structure with default values. There is no logic in the function that parses, validates, or enforces any grammar rules related to HTTP protocol elements as described in the RFC (i.e., ensuring protocol elements match the ABNF grammar). Therefore, none of the spec constraints (e.g., any conditions like C1 or actions like A1) are addressed within this function.",success,
8399,ap_response_code_string,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, ap_response_code_string, is concerned with selecting and returning a response code string based on configuration (custom responses or error documents). It does not implement any logic that checks or restricts the generation of protocol elements based on the sender's role. Therefore, the function does not address the RFC specification that requires a sender to not generate protocol elements or syntax alternatives that are allowed only for other roles.",success,
8399,ap_response_code_string,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function, ap_response_code_string, does not contain any logic to verify that protocol elements match the ABNF grammar as mandated by the RFC specification. Instead, the function retrieves error response strings from configuration structures and evaluates expressions set via configuration (e.g., ErrorDocument). There is no code segment here that checks or enforces the grammar rules for protocol elements. Therefore, none of the labeled spec constraints (e.g., C1, A1) are fully implemented within this function.",success,
8406,ap_get_server_port,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'r->parsed_uri.port_str ? r->parsed_uri.port : r->server->port ? r->server->port : ap_default_port(r)', 'explanation': 'The code explicitly checks if a port is provided (via the parsed URI or server configuration) and, if not, falls back to calling ap_default_port(r). This directly implements the RFC requirement that if a port is not provided, the recipient may use the default port for the protocol.'}}]","The function ap_get_server_port inspects different sources for a server port, and in all cases where a port is not explicitly provided, it calls ap_default_port(r) to obtain the default port. This logic clearly addresses the specified RFC constraint, fulfilling the requirement entirely within the function itself.",success,
8407,ap_construct_url,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Does Not Match,[],"The RFC specification requires that a sender MUST NOT generate an ""http"" URI with an empty host identifier. In the provided function, the host is obtained via ap_get_server_name_for_url(r) and then directly used in the URL string without any check for an empty value. There is no code within the function that verifies if the host is non-empty. As a result, the function does not visibly address the constraint that prevents generating a URL with an empty host, and thus it does not implement the specified RFC requirement.",success,
8407,ap_construct_url,"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",225,Does Not Match,[],"The specification requires that the function must not generate an https URI with an empty host identifier. However, the function ap_construct_url simply obtains the host via ap_get_server_name_for_url(r) and then concatenates it into the URL without checking whether the host is empty. This function does not visibly implement any safeguard or check to ensure the host is non-empty; therefore, it does not address the RFC requirement.",success,
8421,ap_custom_response,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function simply assigns a custom response string to a configuration structure, choosing whether to duplicate the string as-is or enclose it in quotes based on a check (e.g., if the string is a URL or begins with '/'). There is no logic that restricts the generation of protocol elements to a specific role or prevents the function from generating protocol elements that are reserved for another role. Therefore, the function does not visibly implement the RFC requirement that 'a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles.'",success,
8441,ap_limit_section,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC specification requires that a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. The provided function, ap_limit_section, is concerned with processing configuration directives (specifically for <Limit> and <LimitExcept>) and setting up method restrictions based on the parsed words. It performs sanity checks such as ensuring the closing '>' exists and that the container argument is not empty, but it does not address the generation of protocol elements nor does it enforce adherence to HTTP ABNF grammar for outgoing protocol elements. As a result, no parts of the function can be seen as implementing the specified RFC constraint (labeled conditions or actions), and dependencies or further processing elsewhere are not considered in this analysis.",success,
8444,filesection,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n\n    if (!arg[0]) {\n        return missing_container_arg(cmd);\n    }', 'explanation': ""This code verifies that a closing '>' exists and that the directive argument is non-empty, demonstrating defensive parsing. It checks the basic structure as required by the RFC (i.e. the protocol element should conform at least marginally to its expected syntax).""}}]","The RFC requires that a recipient parse a received protocol element defensively, expecting only marginal conformance to the grammar and a reasonable size. The function implements several defensive checks (e.g. verifying the closing delimiter and non-empty arguments), thereby addressing part of the specification. However, it does not include mechanisms for handling or validating against buffer size limitations or other more extensive parsing constraints explicitly mentioned in the RFC context. Thus, the function partially matches the requirements solely based on the logic within the function_body.",success,
8481,ap_get_server_description,A sender SHOULD limit generated product identifiers to what is necessary to identify the product; a sender MUST NOT generate advertising or other nonessential information within the product identifier.,274,Does Not Match,[],"The RFC specifies that a product identifier should be limited to what is necessary to identify the product and should not contain advertising or nonessential information. The provided function simply returns a pre-defined string (using server_description if available, or a combination of AP_SERVER_BASEVERSION and PLATFORM otherwise) without any logic that limits or filters out additional nonessential content. There is no code in this function that checks for or enforces minimal information disclosure as required by the RFC constraints. Therefore, within its own logic, the function does not address any of the labeled conditions or actions.",success,
8484,set_banner,"A sender SHOULD NOT generate information in product-version that is not a version identifier (i.e., successive versions of the same product name ought to differ only in the product-version portion of the product identifier).",275,Partially Matches,[],"The RFC requires that the sender SHOULD NOT generate any additional advertising or non‐version information in the product-version field. In this function, while some branches (e.g., when ap_server_tokens is SrvTk_PRODUCT_ONLY or SrvTk_MINIMAL) add only the base product or version identifier, other branches (notably the default case and the SrvTk_FULL path via the final else) append extra information such as the PLATFORM in parentheses. This extra information does not qualify as a version identifier and constitutes nonessential advertising. Since the function in some cases adheres to the constraint and in others does not, the implementation only partially matches the RFC’s requirements.",success,
8484,set_banner,A sender SHOULD limit generated product identifiers to what is necessary to identify the product; a sender MUST NOT generate advertising or other nonessential information within the product identifier.,274,Partially Matches,"[{'C1': {'code': 'if (ap_server_tokens == SrvTk_PRODUCT_ONLY) {\n    ap_add_version_component(pconf, AP_SERVER_BASEPRODUCT);\n}', 'explanation': 'In the SrvTk_PRODUCT_ONLY branch, the function adds only the base product identifier, which aligns with the requirement to limit the generated product identifier to the minimum necessary information.'}}]","The function conditionally adds version components based on the value of ap_server_tokens. In one branch (SrvTk_PRODUCT_ONLY), only the minimal product identifier is added, which complies with the spec's instruction to limit the information. However, other branches (e.g., SrvTk_MINIMAL, SrvTk_MINOR, SrvTk_MAJOR, and the unconditional server_description that appends platform details) add extra information that may be considered nonessential (or even advertising). Since the function itself, independent of its dependencies, includes both limited and extended information scenarios, it only partially implements the specification.",success,
8487,set_limit_req_fieldsize,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Does Not Match,[],"The RFC specifies that a recipient SHOULD parse a received protocol element defensively, with only marginal expectations of conformity to its ABNF and being within a reasonable buffer size. The provided function simply converts a configuration argument to an integer using atoi(), checks if it is negative, and returns an error if so. It does not implement any defensive parsing of a protocol element, does not verify conformance to any ABNF grammar, nor does it ensure that a received element fits within a reasonable buffer size. As such, no part of the code within this function meets any explicit labeled conditions (e.g., C1) or actions (e.g., A1) related to the RFC requirement.",success,
8488,set_limit_req_fields,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'lim = atoi(arg);\nif (lim < 0) {\n    return apr_pstrcat(cmd->temp_pool, ""LimitRequestFields \\"""", arg,\n                       ""\\"" must be a non-negative integer (0 = no limit)"",\n                       NULL);\n}', 'explanation': 'This segment performs minimal defensive parsing by converting the input to an integer and ensuring it is non-negative. It assumes that the provided value is a proper representation of an integer, which partially aligns with the idea of defensive parsing expected by the RFC.'}}]","The RFC requires that a recipient should parse a received protocol element defensively, with only marginal expectations about conformity to its ABNF grammar and a check against an unreasonable buffer size. In this function, while there is an attempt to validate the input by converting it to an integer and enforcing that it is not negative, the function does not perform comprehensive checking against the ABNF grammar nor does it verify that the input fits within a reasonable buffer size. Consequently, the function only partially meets the defensive parsing requirements specified in the RFC.",success,
8490,set_limit_xml_req_body,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (conf->limit_xml_body < 0)\n        return ""LimitXMLRequestBody requires a non-negative integer."";', 'explanation': 'This segment verifies that the limit is non-negative, which is a basic defensive check on the input.'}}, {'A1': {'code': 'if ((apr_size_t)conf->limit_xml_body > AP_MAX_LIMIT_XML_BODY)\n        return apr_psprintf(cmd->pool, ""LimitXMLRequestBody must not exceed ""%"" APR_SIZE_T_FMT, AP_MAX_LIMIT_XML_BODY);', 'explanation': 'This segment ensures the provided limit does not exceed a preset maximum value, thereby preventing an excessively large allocation which is part of handling reasonable buffer size expectations.'}}]","The code function implements some defensive validations by converting the input string into a numeric limit, ensuring it is non-negative and within an acceptable maximum range. These checks partially address the RFC requirement of accepting protocol elements with only minimal assumptions about their correctness (i.e., applying some basic range validation). However, it does not include thorough defensive parsing (such as verifying the input conforms to an expected ABNF grammar) or additional measures that might be expected for fully robust processing of protocol elements. As a result, while some defensive checks are visible within the function, it only partially matches the full spirit of the RFC's recommendations.",success,
8490,set_limit_xml_req_body,"Since there is no predefined limit to the length of content, recipients MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows.",285,Does Not Match,[],"The function converts the string argument to a long using atol and checks if the value is negative or exceeds a predefined maximum (AP_MAX_LIMIT_XML_BODY). However, the RFC requires that implementations anticipate very large decimal numeral inputs and prevent parsing errors due to integer conversion overflows. This function does not include logic to detect or properly handle potential overflows from very large inputs (e.g., using a safer conversion function with error checks), and as such it does not fully implement the specified requirement.",success,
8503,set_protocols_honor_order,"Although protocol names are registered with a preferred case, recipients SHOULD use case-insensitive comparison when matching each protocol-name to supported protocols.",257,Does Not Match,[],"The provided function only sets a configuration flag based on a case-insensitive check of the arguments 'on' or 'off'. It does not implement any logic related to matching protocol names or handling protocol negotiation as detailed in the RFC specification (e.g., comparing protocol names in a case-insensitive manner for the Upgrade header). Therefore, none of the spec constraints (such as those requiring case-insensitive comparison for protocol names) are addressed within the function itself.",success,
8510,parse_errorlog_misc_string,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': ""while (*s && *s != '%' && (*s != ' ' || at_start) && d < scratch + MAX_STRING_LEN) { ... }"", 'explanation': ""This loop shows defensive parsing by checking each input character and halting when a non-expected character or delimiter (such as a space after the start or a '%') is encountered. It does so without assuming full conformance to an ABNF grammar.""}}, {'A1': {'code': 'd < scratch + MAX_STRING_LEN', 'explanation': 'This condition limits the number of characters read, thereby enforcing a maximum buffer size. It is a safeguard meant to handle cases where the input does not necessarily conform to an explicit grammar but must be bounded to a reasonable length.'}}]","The function attempts to parse the string defensively by limiting read operations with a maximum buffer size and halting under certain conditions. This approach partially fulfills the RFC requirement of handling protocol elements with only marginal expectations on their exact format. However, the function does not fully validate adherence to any specific ABNF grammar, relying instead on a few termination checks, which is why it only partially matches the spec constraints.",success,
8512,parse_errorlog_string,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'while (s && *s) {\n    ap_errorlog_format_item *item =\n        (ap_errorlog_format_item *)apr_array_push(a);\n    memset(item, 0, sizeof(*item));\n    res = parse_errorlog_item(p, item, &s);\n    if (res) {\n        *err = res;\n        return NULL;\n    }\n    ...\n}', 'explanation': ""This loop defensively parses the input 's', checking that it is non-null and non-empty before processing each element. It relies on parse_errorlog_item to handle parts of the ABNF and returns an error if parsing fails, which aligns with the RFC recommendation of expecting the protocol element to only marginally conform to the grammar.""}}, {'A1': {'code': 'if (res) {\n    *err = res;\n    return NULL;\n}', 'explanation': 'The code immediately returns an error when parse_errorlog_item indicates a problem. This defensive error-checking is in line with the spec’s suggestion to not assume full conformance of the received protocol element.'}}]","The function implements some defensive parsing techniques. It iterates safely over the input string and performs several checks on each parsed item—such as verifying required conditions and range checks on log level modifiers—and returns error messages when things are amiss. However, it does not explicitly validate that the protocol element fits within a reasonable buffer size, nor does it fully handle all aspects of conformance to an ABNF grammar. Since some aspects of the RFC (such as buffer size limitations) are not directly addressed within this function, the implementation only partially matches the RFC's defensive parsing guidelines.",success,
8517,ap_core_translate,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'A1': {'code': 'if (!r->uri || ((r->uri[0] != \'/\') && strcmp(r->uri, ""*""))) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00126)\n                  ""Invalid URI in request \'%s\' \'%s\'"", r->uri, r->the_request);\n    return HTTP_BAD_REQUEST;\n}', 'explanation': ""This segment returns a 400 Bad Request error if the request URI does not start with '/' (or is not exactly '*' in a special case), which is aligned with one of the RFC options for handling an invalid request-line.""}}]","The function checks for a valid URI format and returns HTTP_BAD_REQUEST when the URI is not as expected. This corresponds to the RFC's allowance to respond with a 400 error. However, the RFC also specifies that no whitespace is allowed in the request-target and allows for a 301 redirect with proper encoding, neither of which is explicitly handled in this function. Therefore, only part of the spec constraints are implemented by the function.",success,
8519,do_nothing,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,44,Does Not Match,[],"The function 'do_nothing' simply returns OK without performing any operations related to the HTTP RFC specifications regarding the Content-Length header. There is no logic within this function that checks, sets, or validates the header as required by any of the conditions (C1, C2, etc.) or actions (A1, A2, etc.). All relevant functionality would need to be implemented within the function itself to be considered as matching the specification. Hence, the function does not match any of the specified constraints.",success,
8520,core_override_type,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'if (conf->mime_type && strcmp(conf->mime_type, ""none""))\n    ap_set_content_type_ex(r, (char*) conf->mime_type, 1);', 'explanation': 'This segment checks if a MIME type is specified (and not equal to ""none"") and then sets the Content-Type header field accordingly, directly addressing the RFC requirement to send a Content-Type header when the intended media type of the content is known.'}}]","The RFC requires that a message containing content should have a Content-Type header unless the media type is unknown. Within function_body, there is explicit logic to set the Content-Type header using the configured MIME type if present. This directly fulfills the RFC specification solely within this function, thus the outcome is Fully Matches.",success,
8521,default_handler,An origin server that receives a request method that is unrecognized or not implemented SHOULD respond with the 501 (Not Implemented) status code.,59,Fully Matches,"[{'C1': {'code': 'if (r->method_number == M_INVALID) {\n    if (r->the_request\n        && r->the_request[0] == 0x16\n        && (r->the_request[1] == 0x2 || r->the_request[1] == 0x3)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00134)\n                      ""Invalid method in request %s - possible attempt to establish SSL connection on non-SSL port"", r->the_request);\n    } else {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00135)\n                      ""Invalid method in request %s"", r->the_request);\n    }\n    return HTTP_NOT_IMPLEMENTED;\n}', 'explanation': 'This segment explicitly checks if the request method is invalid (i.e. unrecognized or not implemented) and returns HTTP_NOT_IMPLEMENTED (501), which meets the HTTP RFC specification regarding unrecognized methods.'}}]","The function explicitly handles unrecognized or invalid HTTP methods by checking if r->method_number equals M_INVALID and then returning HTTP_NOT_IMPLEMENTED, in agreement with the RFC that requires a 501 status code. Thus, within the function's implementation, the specified condition from the RFC is fully addressed.",success,
8521,default_handler,"An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",60,Fully Matches,"[{'C1': {'code': 'if (r->method_number != M_GET) {\n    core_request_config *req_cfg;\n    req_cfg = ap_get_core_module_config(r->request_config);\n    if (!req_cfg->deliver_script) {\n        /* The flag hasn\'t been set for this request. Punt. */\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00131)\n                      ""This resource does not accept the %s method."",\n                      r->method);\n        return HTTP_METHOD_NOT_ALLOWED;\n    }\n}', 'explanation': 'This code checks for a recognized method (POST) that is implemented but, based on the deliver_script flag, is not allowed for the target resource. It returns HTTP_METHOD_NOT_ALLOWED (405) as required by the RFC.'}}, {'A1': {'code': '/* unusual method (not GET or POST) */\nif (r->method_number == M_INVALID) {\n    ...\n    return HTTP_NOT_IMPLEMENTED;\n}\n\nif (r->method_number == M_OPTIONS) {\n    return ap_send_http_options(r);\n}\nreturn HTTP_METHOD_NOT_ALLOWED;', 'explanation': 'For methods that are unusual but recognized, the function explicitly returns HTTP_METHOD_NOT_ALLOWED (405) when no other special handling applies, fulfilling the RFC action for recognized and implemented methods that are not allowed.'}}]","The function implements the RFC requirement by checking the request method. For recognized methods such as GET and POST, it further assesses whether the resource allows the method using the deliver_script flag; when not allowed, it returns a 405 status code. In the branch handling unusual methods, if the method is recognized (but not GET, POST, or OPTIONS), the function again returns HTTP_METHOD_NOT_ALLOWED (405). This aligns with the spec which states that an origin server should respond with 405 when the method is recognized and supported but not permitted for the target resource.",success,
8521,default_handler,"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.",57,Fully Matches,"[{'A1': {'code': 'ap_set_etag_fd(r, fd);', 'explanation': 'This call directly sets the ETag for the representation using the file descriptor, addressing the RFC requirement that an origin server SHOULD send an ETag when change detection of the representation is possible.'}}]","The RFC specification mandates that an origin server should send an ETag for a representation to enable proper cache validation and reduce unnecessary transfers. Within the function, the call to ap_set_etag_fd(r, fd) visibly implements this requirement. No other RFC requirements are specified in the constraints; hence, by setting the ETag directly in the function, it fulfills the specification as required.",success,
8521,default_handler,"In 200 responses to GET or HEAD, an origin server SHOULD send any available validator fields (Section 8.8) for the selected representation, with both a strong entity tag and a Last-Modified date being preferred.",141,Fully Matches,"[{'A1': {'code': 'ap_update_mtime(r, r->finfo.mtime);\n        ap_set_last_modified(r);', 'explanation': ""These lines update the file's modification time and set the Last-Modified header, thereby providing one of the validator fields as specified by the RFC.""}}, {'A2': {'code': 'ap_set_etag_fd(r, fd);', 'explanation': 'This call sets the ETag header based on the file descriptor, ensuring that a strong entity tag is provided as recommended by the RFC.'}}]","The function addresses the RFC requirement for providing available validator fields in 200 responses to GET (and indirectly HEAD) by explicitly setting both the Last-Modified and ETag headers. The code segments that update the modification time and set the validators are contained entirely within the function, thereby fully meeting the specified actions from the RFC.",success,
8521,default_handler,"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.",52,Fully Matches,"[{'C1': {'code': 'ap_update_mtime(r, r->finfo.mtime);\n        ap_set_last_modified(r);', 'explanation': ""The function retrieves the file's last modification time using r->finfo.mtime, updates the request structure via ap_update_mtime(), and then explicitly sets the Last-Modified header by calling ap_set_last_modified(r). This directly addresses the requirement from the RFC that an origin server SHOULD send Last-Modified for a representation with a determinable modification time.""}}]","The provided function checks for file existence and, when handling GET or POST requests, retrieves the modification time from the file info, and then sets the Last-Modified header. The inclusion of ap_set_last_modified(r) clearly shows that the code function itself attempts to implement the RFC stipulation regarding the Last-Modified header, thereby fully matching the corresponding constraint.",success,
8521,default_handler,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'A1': {'code': 'ap_set_content_length(r, r->finfo.size);', 'explanation': 'The function sets the Content-Length header when serving GET/POST requests with a known file size, which partially implements the RFC requirement to send a Content-Length header when the content size is known.'}}]","The RFC specifies that, aside from certain exceptional cases, if Transfer-Encoding is not used and the content size is known, the server SHOULD send a Content-Length header field. The function includes a call to ap_set_content_length(r, r->finfo.size) in the GET/POST branch, which addresses this requirement. However, the function does not perform any checks to avoid sending a Content-Length header in the specific cases where it must not be present (such as responses with status codes 1xx, 204, or for CONNECT methods). Therefore, while the function attempts to implement the positive part of the RFC, it does not handle the exceptional cases described by the spec context, leading to a partial match.",success,
8521,default_handler,A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.,30,Partially Matches,"[{'A1': {'code': 'if (r->method_number == M_OPTIONS) {\n    return ap_send_http_options(r);\n}', 'explanation': 'This segment shows that when the request method is OPTIONS, the function immediately calls ap_send_http_options(r) to process it, which aligns with the RFC requirement that an OPTIONS request can be honored by any protocol.'}}]","The RFC requires that a server must not switch protocols unless the received message semantics can be honored by the new protocol, and explicitly states that an OPTIONS request can be honored by any protocol. The function provides logic to handle OPTIONS requests, fulfilling that part of the spec (labeled A1). However, there is no logic in the function addressing protocol switching or ensuring that the message semantics can be honored by a new protocol. As a result, only part of the RFC specification is visibly implemented in the function.",success,
8550,core_upgrade_handler,"A server MAY send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.",29,Fully Matches,"[{'C1': {'code': 'else if (!c->keepalives) {\n    const apr_array_header_t *upgrades;\n    ap_get_protocol_upgrades(c, r, NULL, 0, &upgrades);\n    if (upgrades && upgrades->nelts > 0) {\n        char *protocols = apr_array_pstrcat(r->pool, upgrades, \',\');\n        apr_table_setn(r->headers_out, ""Upgrade"", protocols);\n        apr_table_setn(r->headers_out, ""Connection"", ""Upgrade"");\n    }\n}', 'explanation': ""This block advertises the available upgrade protocols in the response by setting the 'Upgrade' and 'Connection' headers when it's appropriate (i.e. on a new master connection). This complies with the specification that a server MAY send an Upgrade header in any other response to inform the client of supported protocols.""}}, {'A1': {'code': 'if (upgrade && *upgrade) {\n    const char *conn = apr_table_get(r->headers_in, ""Connection"");\n    if (ap_find_token(r->pool, conn, ""upgrade"")) {\n        apr_array_header_t *offers = NULL;\n        const char *err;\n        err = ap_parse_token_list_strict(r->pool, upgrade, &offers, 0);\n        if (err) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02910)\n                          ""parsing Upgrade header: %s"", err);\n            return DECLINED;\n        }\n        if (offers && offers->nelts > 0) {\n            const char *protocol = ap_select_protocol(c, r, NULL, offers);\n            if (protocol && strcmp(protocol, ap_get_protocol(c))) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02909)\n                              ""Upgrade selects \'%s\'"", protocol);\n                apr_table_clear(r->headers_out);\n                apr_table_setn(r->headers_out, ""Upgrade"", protocol);\n                apr_table_setn(r->headers_out, ""Connection"", ""Upgrade"");\n                r->status = HTTP_SWITCHING_PROTOCOLS;\n                r->status_line = ap_get_status_line(r->status);\n                ap_send_interim_response(r, 1);\n                ap_switch_protocol(c, r, r->server, protocol);\n                c->keepalive = AP_CONN_CLOSE;\n                return DONE;\n            }\n        }\n    }\n}', 'explanation': ""This segment processes incoming requests that contain an Upgrade header. It validates the request, selects an appropriate protocol different from the current one, and then constructs a switching protocols response by setting the 'Upgrade' and 'Connection' headers. This is in line with the RFC’s guidance on handling upgrade attempts.""}}]","The function checks if the incoming request includes an Upgrade header and, if so, verifies and processes the upgrade request by selecting a protocol and sending a response with the appropriate headers and status. Additionally, on new master connections, it advertises available protocols by setting the Upgrade header in the response. Both behaviors directly implement the spec's provision for handling upgrade requests and advertising support for protocol upgrades, thereby fully matching the intended RFC constraints within the scope of this function.",success,
8550,core_upgrade_handler,"A sender of Upgrade MUST also send an ""Upgrade"" connection option in the Connection header field (Section 7.6.1) to inform intermediaries not to forward this field.",31,Fully Matches,"[{'C1': {'code': 'upgrade = apr_table_get(r->headers_in, ""Upgrade"");\nif (upgrade && *upgrade) {\n    const char *conn = apr_table_get(r->headers_in, ""Connection"");\n    if (ap_find_token(r->pool, conn, ""upgrade"")) { ... } }', 'explanation': ""The function checks that when an 'Upgrade' header is present, the 'Connection' header field includes the 'upgrade' token, in compliance with the spec requirement.""}}, {'A1': {'code': 'apr_table_setn(r->headers_out, ""Upgrade"", protocol);\napr_table_setn(r->headers_out, ""Connection"", ""Upgrade"");', 'explanation': ""After selecting the protocol for upgrade, the function explicitly sets the 'Connection: Upgrade' header in the response, informing intermediaries as required by the specification.""}}]","The provided function inspects the incoming request for an 'Upgrade' header and ensures that the 'Connection' header contains the 'upgrade' token. It then sends a response that sets both the 'Upgrade' and 'Connection: Upgrade' headers, thereby visibly addressing the RFC requirement within the function itself.",success,
8550,core_upgrade_handler,A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field.,27,Partially Matches,"[{'C1': {'code': 'upgrade = apr_table_get(r->headers_in, ""Upgrade"");\nif (upgrade && *upgrade) {\n    const char *conn = apr_table_get(r->headers_in, ""Connection"");\n    if (ap_find_token(r->pool, conn, ""upgrade"")) { ... }', 'explanation': 'The code checks for the presence of an Upgrade request header and verifies that the connection header includes the ""upgrade"" token, thus ensuring that an upgrade was requested by the client.'}}, {'A1': {'code': 'err = ap_parse_token_list_strict(r->pool, upgrade, &offers, 0);\nif (offers && offers->nelts > 0) {\n    const char *protocol = ap_select_protocol(c, r, NULL, offers);\n    if (protocol && strcmp(protocol, ap_get_protocol(c))) {\n        /* Respond with 101 Switching Protocols and include Upgrade header */\n        apr_table_clear(r->headers_out);\n        apr_table_setn(r->headers_out, ""Upgrade"", protocol);\n        apr_table_setn(r->headers_out, ""Connection"", ""Upgrade"");\n        r->status = HTTP_SWITCHING_PROTOCOLS;\n        r->status_line = ap_get_status_line(r->status);\n        ap_send_interim_response(r, 1);\n        ap_switch_protocol(c, r, r->server, protocol);\n        c->keepalive = AP_CONN_CLOSE;\n        return DONE;\n    }\n}', 'explanation': ""After parsing the client's Upgrade header, the function selects a new protocol (by calling an external helper, ap_select_protocol) and only proceeds with the protocol switch if the selected protocol is different from the current one. It then sets the appropriate response headers. This indicates an attempt to comply with the spec requirement regarding protocol selection and response signaling.""}}]","The function inspects the incoming request for the Upgrade header and verifies that the Connection header includes the 'upgrade' token, thus addressing the client's indication of supported protocols. It parses the header value and selects a protocol from the list provided by the client before initiating the protocol switch and setting the response headers as required. However, the actual check to ensure the protocol chosen is one of the client‐provided options is delegated to the external function ap_select_protocol, and case-insensitive protocol comparison is not explicitly handled in this function. Therefore, only part of the RFC requirements are visibly implemented within this function.",success,
8550,core_upgrade_handler,"A server that sends a 101 (Switching Protocols) response MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched; if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order.",26,Partially Matches,"[{'A1': {'code': 'apr_table_clear(r->headers_out);\n                    apr_table_setn(r->headers_out, ""Upgrade"", protocol);\n                    apr_table_setn(r->headers_out, ""Connection"", ""Upgrade"");', 'explanation': ""This code segment sets the 'Upgrade' response header along with the 'Connection' header and sends a 101 (Switching Protocols) status, directly addressing the requirement that a server issuing a 101 response must include an Upgrade header to indicate the new protocol.""}}]","The function inspects the client's 'Upgrade' header, selects a protocol, and when performing a protocol upgrade it clears and sets the appropriate headers, then sends a 101 (Switching Protocols) response. This meets the requirement for including an Upgrade header. However, the RFC also mandates that if multiple protocol layers are being switched, the protocols must be listed in layer-ascending order — this function does not explicitly enforce or check that ordering. As a result, while part of the spec is implemented in this function, not all required conditions (specifically the ordering of protocols) are handled solely within this code, leading to a 'Partially Matches' conclusion.",success,
8550,core_upgrade_handler,A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection.,25,Fully Matches,"[{'C1': {'code': 'if (upgrade && *upgrade) {\n    const char *conn = apr_table_get(r->headers_in, ""Connection"");\n    if (ap_find_token(r->pool, conn, ""upgrade"")) { ... } \n}\n\nreturn DECLINED;', 'explanation': 'This segment checks if an Upgrade header is present and valid, and if the conditions (e.g., the \'Connection\' header containing ""upgrade"") are not met for a protocol switch then the function simply returns DECLINED, effectively ignoring the Upgrade header, which aligns with the RFC\'s statement that a server MAY ignore the Upgrade header.'}}, {'A1': {'code': 'if (protocol && strcmp(protocol, ap_get_protocol(c))) {\n    ...\n    r->status = HTTP_SWITCHING_PROTOCOLS;\n    r->status_line = ap_get_status_line(r->status);\n    ap_send_interim_response(r, 1);\n\n    ap_switch_protocol(c, r, r->server, protocol);\n    c->keepalive = AP_CONN_CLOSE;\n    return DONE;\n}', 'explanation': 'This segment implements the action of upgrading the protocol when a valid, different protocol is selected. It sends the Switching Protocols response and calls ap_switch_protocol, thereby fulfilling the upgrade action mandated by the RFC.'}}]","The function core_upgrade_handler explicitly checks for the presence of an Upgrade header and validates it in conjunction with the Connection header. If no valid protocol is selected (or if conditions are otherwise not met), it returns DECLINED, effectively ignoring the Upgrade header as allowed by the RFC. Conversely, if a valid protocol upgrade is requested and selected, it sets up the response to switch the protocol. This behavior fully implements the relevant aspects of the HTTP RFC regarding the Upgrade header handling.",success,
8550,core_upgrade_handler,"When a field aside from Connection is used to supply control information for or about the current connection, the sender MUST list the corresponding field name within the Connection header field",21,Fully Matches,"[{'C1': {'code': 'if (upgrade && *upgrade) {\n    const char *conn = apr_table_get(r->headers_in, ""Connection"");\n    if (ap_find_token(r->pool, conn, ""upgrade"")) {', 'explanation': ""This segment checks that when the Upgrade header is present, the corresponding token 'upgrade' is found in the Connection header. This satisfies the requirement that any control header (here, Upgrade) must be accompanied by a listing in the Connection header.""}}, {'A1': {'code': 'apr_table_setn(r->headers_out, ""Upgrade"", protocol);\napr_table_setn(r->headers_out, ""Connection"", ""Upgrade"");', 'explanation': ""This segment sets the response headers such that the connection control field is explicitly listed by including 'Connection: Upgrade' along with the Upgrade header, fulfilling the RFC's action requirement.""}}]","The function explicitly checks for an Upgrade header in the incoming request and verifies the presence of the corresponding 'upgrade' token within the Connection header (C1). Upon successfully negotiating an upgrade, it sets both the Upgrade and the Connection headers in the response (A1). This directly addresses the relevant part of the HTTP RFC specification regarding connection control information.",success,
8550,core_upgrade_handler,The server MUST generate an Upgrade header field in the response that indicates which protocol(s) will be in effect after this response.,140,Fully Matches,"[{'C1': {'code': 'apr_table_setn(r->headers_out, ""Upgrade"", protocol);\napr_table_setn(r->headers_out, ""Connection"", ""Upgrade"");', 'explanation': ""The function explicitly sets the Upgrade header (and the Connection header to 'Upgrade') in the response when a protocol upgrade is selected. This directly implements the requirement for the server to generate an Upgrade header field indicating the protocol in effect after the response.""}}, {'A1': {'code': 'r->status = HTTP_SWITCHING_PROTOCOLS;\nr->status_line = ap_get_status_line(r->status);\nap_send_interim_response(r, 1);', 'explanation': ""The code changes the response status to HTTP_SWITCHING_PROTOCOLS (101) and sends an interim response. This satisfies the spec's requirement to indicate that the upgrade is taking place.""}}]","The function examines the incoming headers and, upon detecting a valid Upgrade request, parses the offered protocols and selects one through ap_select_protocol. It then sets the appropriate response headers (Upgrade and Connection) and status code (101 Switching Protocols), before calling the protocol switch function – all of which satisfy the RFC requirement. Therefore, the code function visibly implements the necessary conditions and actions as specified.",success,
8550,core_upgrade_handler,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function handles an HTTP/1.1 Upgrade by retrieving and processing the 'Upgrade' and 'Connection' headers and then setting corresponding single response header fields. However, the RFC specification under discussion requires that a sender MUST NOT generate multiple field lines with the same name (or must combine them appropriately) and that the order of these field lines is preserved when forwarded. This function does not contain any explicit logic to inspect, merge, or preserve the order of incoming header lines with duplicate names. It simply uses apr_table_get and apr_table_setn (after clearing headers_out) to set response headers, which does not address the RFC’s requirements concerning duplicate header fields. Therefore, no labeled condition (e.g., C1) or action (e.g., A1) is fully implemented within this function.",success,
8550,core_upgrade_handler,"A server MAY choose to ignore the order of preference indicated by the client and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.",258,Partially Matches,"[{'A1': {'code': 'apr_table_clear(r->headers_out);\napr_table_setn(r->headers_out, ""Upgrade"", protocol);\napr_table_setn(r->headers_out, ""Connection"", ""Upgrade"");\nr->status = HTTP_SWITCHING_PROTOCOLS;\nr->status_line = ap_get_status_line(r->status);\nap_send_interim_response(r, 1);\nap_switch_protocol(c, r, r->server, protocol);\nc->keepalive = AP_CONN_CLOSE;', 'explanation': 'This code segment builds a 101 Switching Protocols response by clearing outgoing headers, setting the Upgrade and Connection header fields to the selected protocol, and then initiating the protocol switch. It addresses the part of the spec requiring that a server sending a 101 response must indicate the new protocol by an Upgrade header field.'}}, {'A2': {'code': 'const char *protocol = ap_select_protocol(c, r, NULL, offers);', 'explanation': ""By invoking the protocol selection function with the list of client-offered protocols, this code indirectly allows the server to choose a protocol based on factors other than the client's preferred order, aligning with the spec's allowance to ignore client preference ordering.""}}]","The function handles Upgrade requests by parsing the client’s Upgrade header and, if valid protocols are provided, selecting one (via ap_select_protocol) and sending a proper 101 Switching Protocols response with the required Upgrade header. It also lists available protocols for first requests on master connections. However, it does not explicitly implement all aspects of the RFC, such as ensuring case‐insensitive protocol comparisons or ordering protocols in layer-ascending order when multiple layers are switched. Therefore, only some of the labeled conditions/actions from the spec are addressed within this function.",success,
8574,ap_cookie_write2,A sender MUST NOT generate BWS in messages.,239,Does Not Match,[],"The provided function constructs a cookie string by concatenating several components, but it does not contain any logic that directly addresses the RFC specification regarding BWS (Bad Whitespace). Specifically, the RFC requires that a sender MUST NOT generate BWS in messages, yet the function does not include any checks, modifications, or processing to prevent or remove extra whitespace. Therefore, this function does not visibly implement the required constraint solely within its own logic.",success,
8574,ap_cookie_write2,"A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the ""message/http"" media type.",301,Does Not Match,[],"The provided function ap_cookie_write2 constructs and logs a cookie string from provided parameter values and writes that cookie string to header tables. However, it does no processing or checking for line folding patterns (obs-fold) in the field values, nor does it implement any logic to reject or replace such patterns as mandated by the spec. Thus, none of the spec constraints (such as C1 or A1 related to line folding handling) are addressed within this function.",success,
8576,ap_cookie_remove2,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function builds an RFC2965 compliant cookie removal string and writes it to header tables, but it does not incorporate any logic that verifies or enforces that the generated protocol elements align with the sender’s role. There is no check or mechanism within the function to ensure that elements not permitted to be generated by the sender (as per the provided HTTP RFC constraint) are omitted or handled correctly. Therefore, the function does not visibly implement the spec constraint regarding role-specific generation of protocol elements.",success,
8577,extract_cookie_line,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Partially Matches,"[{'C1': {'code': 'while (apr_isspace(*trim)) {\n    trim++;\n}', 'explanation': 'This loop removes leading whitespace from each token. Since the RFC specifies that bad whitespace (BWS) must be removed before interpreting the protocol element, this segment indicates an attempt by the function to address that requirement. However, it only trims leading whitespace and does not comprehensively handle all possible instances of BWS (such as trailing or intermediate whitespace), hence it only partially meets the specification.'}}]","The function 'extract_cookie_line' processes a cookie header by tokenizing it and then iterating over individual tokens. In doing so, it uses a while loop to remove leading whitespace from each token, which corresponds to part of the RFC instruction that 'any content known to be defined as BWS MAY be removed.' While this shows an effort to remove BWS, the implementation is limited to only stripping leading whitespace. It does not fully implement all aspects of the requirement (for example, it neglects potential bad or extraneous whitespace elsewhere in the token). Therefore, the function only partially matches the specified RFC condition.",success,
8577,extract_cookie_line,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,"[{'C1': {'code': 'while (apr_isspace(*trim)) {\n    trim++;\n}', 'explanation': ""This snippet removes leading whitespace from each cookie token before further processing, which partially addresses the RFC's requirement to remove bad whitespace. However, it only handles leading whitespace and does not deal with other forms (e.g., trailing or extra internal whitespace), so the implementation is only partial.""}}]","The RFC specifies that a recipient MUST parse for bad whitespace and remove it before interpreting the protocol element. In this function, a while loop is used to skip over leading whitespace before comparing cookie names, thereby partially fulfilling the requirement. However, the approach is limited as it does not normalize or remove all bad whitespace as described in the spec. Thus, the function partially matches the specification.",success,
8577,extract_cookie_line,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': 'while (apr_isspace(*trim)) {\n    trim++;\n}', 'explanation': ""The code explicitly skips over leading whitespace in each token (stored in 'trim') before evaluating it. This directly implements the RFC requirement that any allowed whitespace be removed from the field value prior to processing.""}}]","The function 'extract_cookie_line' processes cookie components by tokenizing the input and, for each token, advances the pointer past any whitespace using a loop that checks for whitespace with 'apr_isspace'. This behavior directly meets the RFC specification that requires removal of unnecessary whitespace before field evaluation. Since this trimming logic is contained within the function (and not deferred to any dependency), the implementation fully matches the specified constraint.",success,
8577,extract_cookie_line,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function 'extract_cookie_line' primarily deals with parsing and manipulating cookie strings, with logic for tokenizing, trimming, and reconstructing cookie segments. There is no visible logic or checks related to ensuring that a sender does not generate protocol elements or syntax alternatives that are reserved for other roles, as required by the specified HTTP RFC conditions. Thus, this function does not implement any of the conditions (e.g., C1) or actions (e.g., A1) that enforce the sender role restrictions described in the spec.",success,
8579,ap_cookie_check_string,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': ""if (!string || !*string || ap_strchr_c(string, '=') || ap_strchr_c(string, '&') ||\n        ap_strchr_c(string, ';')) {\n    return APR_EGENERAL;\n}"", 'explanation': ""This code defensively checks the input by verifying that the string is not NULL, not empty, and does not contain certain characters ( '=', '&', ';' ) that may render the cookie string invalid. This aligns with a defensive parsing approach as suggested in the RFC, though only partially addressing the full expectations regarding conformance to an ABNF grammar and buffer length considerations.""}}]","The function implements a basic defensive parsing strategy as required by the RFC by checking for null inputs, empty strings, and disallowed characters. However, it does not fully implement all aspects of the specification—for example, there is no validation against a complete ABNF grammar or checks for buffer size constraints. Therefore, while some defensive techniques are present (meeting C1), the overall implementation only partially matches the RFC constraints.",success,
8580,ap_core_input_filter,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC specifies that a sender must not generate protocol elements that do not match the ABNF grammar. However, the provided function is an input filter that reads and processes incoming data from a client connection. The function does not contain any logic to validate or generate protocol elements according to ABNF rules. Its operations (e.g., handling different read modes, splitting lines, concatenating brigades) focus on data transfer rather than enforcing strict protocol grammar. Therefore, there is no visible implementation within the function_body that attempts to address the spec constraint.",success,
8580,ap_core_input_filter,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Partially Matches,"[{'C1': {'code': 'while (ch < str + len) {\n    if (*ch == APR_ASCII_LF)\n        ch++;\n    else if (*ch == APR_ASCII_CR && *(ch + 1) == APR_ASCII_LF)\n        ch += 2;\n    else\n        goto cleanup;\n}', 'explanation': 'This code excerpt in the AP_MODE_EATCRLF branch checks for line terminators by testing if a character is LF or a CR immediately followed by LF, which partially implements the RFC’s allowance to treat a single LF as a terminator and ignore any CR that precedes LF. However, it does not handle the situation of a bare CR (a CR not immediately followed by LF) by replacing it with a space or explicitly marking it as invalid, as the RFC specifies.'}}]","The function attempts to implement the specified HTTP RFC requirement by recognizing CRLF and LF sequences as valid line terminators. The AP_MODE_EATCRLF logic explicitly handles LF and CRLF, thereby partly satisfying constraint C1. However, it does not implement the required handling for a bare CR (i.e. replacing it with SP or marking it invalid). Therefore, while some of the labeled behavior is addressed within the function, the implementation is only partial as it does not fully comply with the RFC's handling of bare CR characters.",success,
8580,ap_core_input_filter,"In the interest of robustness, a server that is expecting to receive and parse a request-line SHOULD ignore at least one empty line (CRLF) received prior to the request-line.",174,Fully Matches,"[{'C1': {'code': 'if (mode == AP_MODE_EATCRLF) {\n    apr_bucket *e;\n    const char *ch;\n\n    /* The purpose of this loop is to ignore any CRLF (or LF) ... */\n    while (1) {\n        if (APR_BRIGADE_EMPTY(ctx->bb)) {\n            rv = APR_EOF;\n            goto cleanup;\n        }\n\n        e = APR_BRIGADE_FIRST(ctx->bb);\n        rv = apr_bucket_read(e, &str, &len, APR_NONBLOCK_READ);\n        if (rv != APR_SUCCESS) {\n            goto cleanup;\n        }\n\n        ch = str;\n        while (ch < str + len) {\n            if (*ch == APR_ASCII_LF)\n                ch++;\n            else if (*ch == APR_ASCII_CR && *(ch + 1) == APR_ASCII_LF)\n                ch += 2;\n            else\n                goto cleanup;\n        }\n\n        apr_bucket_delete(e);\n    }\n\n    ap_assert(0);\n}', 'explanation': 'This block detects when the filter is in the EATCRLF mode and iteratively reads through buckets, deleting those which contain only CRLF or LF characters. This effectively causes the function to ignore empty lines (CRLF) that may precede the request-line, as required by the RFC specification for robustness.'}}]","The provided function includes explicit logic under the AP_MODE_EATCRLF branch where it reads and discards any data that consists solely of CRLF or LF, thereby ignoring empty lines prior to processing the rest of the request. This directly addresses the RFC requirement stating that a server SHOULD ignore at least one empty line (CRLF) received prior to the request-line. The handling is implemented entirely within this function and does not rely on upstream dependencies, making the match fully compliant with the spec constraint.",success,
8584,ap_core_output_filter,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Fully Matches,"[{'C1': {'code': 'if (c->aborted) {\n    apr_brigade_cleanup(bb);\n    return APR_ECONNABORTED;\n}\n...\napr_socket_timeout_set(sock, 0); \n...\ndo {\n    rv = send_brigade_nonblocking(sock, bb, ctx, c);\n    if (APR_STATUS_IS_EAGAIN(rv)) {\n        ...\n        do {\n            rv = apr_poll(&pfd, 1, &nfd, sock_timeout);\n        } while (APR_STATUS_IS_EINTR(rv));\n    }\n} while (rv == APR_SUCCESS && !APR_BRIGADE_EMPTY(bb));', 'explanation': 'This segment of code ensures that the connection remains persistent. It does so by using non‑blocking socket writes and polling for writability when the socket cannot immediately accept data (indicated by APR_STATUS_IS_EAGAIN). This approach allows the underlying transport’s flow‑control mechanisms to resolve temporary network congestion instead of terminating the connection abruptly.'}}, {'A1': {'code': 'apr_socket_timeout_set(sock, 0);\n...\nif (APR_STATUS_IS_EAGAIN(rv)) {\n    /* Scan through the brigade and decide whether we must absolutely\n     * flush the remaining data, based on ap_filter_reinstate_brigade()\n     * rules. If so, wait for writability and retry, otherwise we did\n     * our best already and can wait for the next call.\n     */\n    apr_bucket *flush_upto;\n    ap_filter_reinstate_brigade(f, bb, &flush_upto);\n    if (flush_upto) {\n        apr_int32_t nfd;\n        apr_pollfd_t pfd;\n        memset(&pfd, 0, sizeof(pfd));\n        pfd.reqevents = APR_POLLOUT;\n        pfd.desc_type = APR_POLL_SOCKET;\n        pfd.desc.s = sock;\n        pfd.p = c->pool;\n        do {\n            rv = apr_poll(&pfd, 1, &nfd, sock_timeout);\n        } while (APR_STATUS_IS_EINTR(rv));\n    }\n}', 'explanation': 'This code implements the mechanism for handling temporary overloads by checking for a non‐blocking write (EAGAIN), then polling for the socket to become writable. This directly corresponds to the spec’s action to allow underlying transport flow‑control to resolve transient congestion without forcefully closing the connection.'}}]","The function ap_core_output_filter demonstrates the use of non‐blocking socket writes and a polling mechanism to manage situations when the network is temporarily unable to accept more data. By handling APR_STATUS_IS_EAGAIN properly and waiting for the socket to become writable, the code supports sustaining a persistent connection and leverages the transport’s flow control rather than terminating the connection immediately. Therefore, within its own logic, the function fully implements the specified conditions (C1) and actions (A1) from the RFC specification.",success,
8594,split_urlword,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function 'split_urlword' is dedicated to parsing and decoding URL parameter data from a bucket brigade and assembling the result into a parameter structure. It does not include any logic that restricts or verifies the generation of protocol elements based on a sender's role or checks that elements generated are within the grammar defined for a specific role, as required by the spec. Thus, no parts within this function address the spec constraint regarding role-based generation of protocol elements.",success,
8921,get_addresses,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'if (!port && !wild_port) {\n    port = default_port;\n}', 'explanation': ""This segment checks whether the port was provided. If not (and it's not a wildcard port), it assigns the default_port value, which directly implements the RFC requirement that if a port is not provided, it should be interpreted as the default for that protocol.""}}]","The function explicitly checks if the port is absent (zero) and, in the absence of any wildcard designation, assigns the default_port. This behavior fully addresses the RFC specification regarding port interpretation without relying on any external dependency. Therefore, the function visibly implements the labeled condition C1 from the spec.",success,
8935,fix_hostname_non_v6,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Partially Matches,"[{'C1': {'code': 'else if (apr_isupper(*dst)) {\n    *dst = apr_tolower(*dst);\n}', 'explanation': 'This segment converts any uppercase character in the hostname to lowercase, addressing the normalization of hostnames.'}}, {'A1': {'code': ""if (dst > host && dst[-1] == '.') {\n    dst[-1] = '\\0';\n}"", 'explanation': 'This segment strips a trailing dot from the hostname, further normalizing it as per the specification.'}}]","The spec requires that HTTP components may perform normalization so that equivalent URIs resolve to the same resource. The function fix_hostname_non_v6 shows efforts to normalize the hostname by converting uppercase letters to lowercase and removing a trailing dot. It also validates certain invalid patterns (such as double dots or disallowed characters) which help in ensuring a proper hostname. However, it addresses only a portion of the full URI normalization (focusing solely on non-IPv6 hostnames and not other URI components), and therefore the match is only partial.",success,
8936,strict_hostname_check,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': ""for (ch = host; *ch; ch++) {\n    if (apr_isalpha(*ch) || *ch == '-' || *ch == '_') {\n        is_dotted_decimal = 0;\n    }\n    else if (ch[0] == '.') {\n        dots++;\n        if (ch[1] == '0' && apr_isdigit(ch[2]))\n            leading_zeroes = 1;\n    }\n    else if (!apr_isdigit(*ch)) {\n       goto bad;\n    }\n}"", 'explanation': 'This loop iterates over every character in the host string and invalidates unexpected characters, which is an attempt to parse the input defensively as recommended by the RFC. It is a partial defensive parse since it assumes the host string is null‐terminated and does not enforce an overall buffer length.'}}, {'A1': {'code': ""if (is_dotted_decimal) {\n    if (host[0] == '.' || (host[0] == '0' && apr_isdigit(host[1])))\n        leading_zeroes = 1;\n    if (leading_zeroes || dots != 3) {\n        goto bad;\n    }\n}"", 'explanation': 'This segment validates dotted-decimal hostnames by ensuring there are exactly three dots and that improper leading zeroes are rejected, thus defensively handling one type of hostname format.'}}, {'A2': {'code': ""else {\n    while (ch > host && *ch != '.')\n        ch--;\n    if (ch[0] == '.' && ch[1] != '\\0' && !apr_isalpha(ch[1]))\n        goto bad;\n}"", 'explanation': 'This logic checks that the top-level domain (the substring after the last dot) starts with an alphabetic character, adhering to RFC 1123 requirements, another defensive measure.'}}]","The function implements a defensive parsing approach for hostname validation by iterating through each character and explicitly handling two formats: dotted-decimal and domain names. It checks that only expected characters appear, validates the structure of dotted-decimal addresses, and ensures that a domain name's top-level segment starts with a letter. While these checks are a defensive measure in line with the RFC recommendation to parse defensively, the function does not address all aspects mentioned in the specification (for example, it does not validate the input against a complete ABNF grammar or explicitly check buffer length limits). Thus, the implementation partially matches the spec constraints in its attempt at defensive parsing.",success,
8936,strict_hostname_check,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': ""for (ch = host; *ch; ch++) {\n    if (apr_isalpha(*ch) || *ch == '-' || *ch == '_') {\n        is_dotted_decimal = 0;\n    }\n    else if (ch[0] == '.') {\n        dots++;\n        if (ch[1] == '0' && apr_isdigit(ch[2]))\n            leading_zeroes = 1;\n    }\n    else if (!apr_isdigit(*ch)) {\n       goto bad;\n    }\n}"", 'explanation': ""This loop examines each character of the host to ensure it consists only of allowed characters (letters, digits, '-', '_', and '.' with proper context). It attempts to enforce that the generated hostname matches a specific grammar, in line with the RFC’s requirement that protocol elements comply with ABNF.""}}, {'A1': {'code': ""if (leading_zeroes || dots != 3) {\n    goto bad;\n}\n...\nwhile (ch > host && *ch != '.')\n    ch--;\nif (ch[0] == '.' && ch[1] != '\\0' && !apr_isalpha(ch[1]))\n    goto bad;"", 'explanation': 'These checks validate the format further by ensuring that dotted-decimal addresses have exactly three dots and no improper leading zeroes, and that the top-level domain of non-numeric hostnames starts with a letter. This represents an action to reject hostnames not conforming to the expected grammar.'}}]","The function 'strict_hostname_check' implements logic aimed at validating whether a hostname complies with a constrained grammar. By iterating over each character and applying rules like counting dots, checking for leading zeroes, and verifying that the top-level domain starts with a letter, the function partly implements the RFC requirement that a sender must not generate protocol elements that do not match the ABNF grammar. However, the overall implementation only covers specific aspects of hostname validation and does not encompass all possible syntactic checks defined by the RFC, so the match is only partial.",success,
8937,fix_hostname,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (!*src) {\n    return is_v6literal;\n}\n\nfor (c = src; apr_isdigit(*c); ++c);\nif (!*c) {\n    if (strict) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02416)\n                     ""[strict] purely numeric host names not allowed: %s"",\n                     src);\n        goto bad_nolog;\n    }\n    r->hostname = src;\n    return is_v6literal;\n}', 'explanation': 'This segment defensively checks the host header: It allows blank headers, validates that a host isn’t solely numeric (unless non-strict), and accordingly rejects malformed inputs.'}}, {'A1': {'code': 'rv = apr_parse_addr_port(&host, &scope_id, &port, src, r->pool);\nif (rv != APR_SUCCESS || scope_id)\n    goto bad;\n\n...\n\nbad:\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00550)\n                  ""Client sent malformed Host header: %s"",\n                  src);\nbad_nolog:\n    r->status = HTTP_BAD_REQUEST;\n    return is_v6literal;', 'explanation': 'This section logs error details and sets the HTTP_BAD_REQUEST status when a malformed Host header is encountered, demonstrating defensive handling of input.'}}]","The function implements a defensive parsing approach for the Host header as suggested by the RFC—it checks for blank inputs, purely numeric values, malformed patterns, and distinguishes IPv6 literals, logging errors and setting an error status when necessary. However, while it partially adheres to the RFC's intent of defensive parsing, it does not explicitly address other aspects such as buffer size considerations. Therefore, the code function only partially matches the full expectations of the RFC.",success,
8937,fix_hostname,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (!*src) {\n    return is_v6literal;\n}', 'explanation': 'This segment explicitly checks for an empty Host header which is permitted (per RFC 2616) and is part of interpreting the received protocol element.'}}, {'A1': {'code': 'if (strict) {\n    /* RFC 3986 7.4 */\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02416) ""[strict] purely numeric host names not allowed: %s"", src);\n    goto bad_nolog;\n}', 'explanation': 'This enforces strict validation for a numeric hostname when in strict mode, thereby acting on the protocol element as defined by the semantics (rejecting an element not conforming to expected semantics).'}}]","The function implements several key aspects of the RFC requirement to interpret the received Host header, such as allowing an empty header, validating IPv6 literals, and checking numeric-only hosts in strict mode. It also performs error logging and sets an error response when the header is malformed. However, some validation details are delegated to other functions (like fix_hostname_v6_literal, fix_hostname_non_v6, and strict_hostname_check), and not all possible aspects of interpreting the protocol element or error recovery are handled explicitly within this function. Therefore, while it partially addresses the RFC constraints, it does not fully encompass every semantic nuance implied by the specification.",success,
8937,fix_hostname,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'if (!*src) {\n    return is_v6literal;\n}', 'explanation': 'This segment allows a blank Host header as permitted by RFC 2616, thereby addressing a condition that a recipient may accept a blank header.'}}, {'A1': {'code': 'for (c = src; apr_isdigit(*c); ++c);\nif (!*c) {\n    /* pure integer */\n    if (strict) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02416)\n                     ""[strict] purely numeric host names not allowed: %s"",\n                     src);\n        goto bad_nolog;\n    }\n    r->hostname = src;\n    return is_v6literal;\n}', 'explanation': 'This part detects when the host field is purely numeric (which would normally be misinterpreted as a port) and handles it differently based on the strict flag. It either rejects it (in strict mode) or accepts it (in non‐strict mode), hence addressing an action to correctly interpret a received protocol element.'}}, {'A2': {'code': ""if (host_header) {\n    rv = apr_parse_addr_port(&host, &scope_id, &port, src, r->pool);\n    if (rv != APR_SUCCESS || scope_id)\n        goto bad;\n    if (port) {\n        r->parsed_uri.port = port;\n        r->parsed_uri.port_str = apr_itoa(r->pool, (int)port);\n    }\n    if (host_header[0] == '[')\n        is_v6literal = 1;\n} else {\n    host = apr_pstrdup(r->pool, r->hostname);\n    if (ap_strchr(host, ':') != NULL)\n        is_v6literal = 1;\n}"", 'explanation': 'This code parses the Host header using apr_parse_addr_port and distinguishes IPv6 literal addresses (which are enclosed in square brackets). It thereby performs the appropriate interpretation as required by the HTTP spec.'}}, {'A3': {'code': 'if (is_v6literal) {\n    rv = fix_hostname_v6_literal(r, host);\n} else {\n    rv = fix_hostname_non_v6(r, host);\n    if (strict && rv == APR_SUCCESS)\n        rv = strict_hostname_check(r, host);\n}\nif (rv != APR_SUCCESS)\n    goto bad;\n\nr->hostname = host;', 'explanation': 'This segment delegates validation to specialized functions for IPv6 literals and non-IPv6 hosts, and if the connection is in strict mode, it performs an additional hostname check. This shows an effort to enforce the expected semantics of the protocol element.'}}]","The function partially implements portions of the RFC’s handling of the Host header: It accepts a blank host header, differentiates between purely numeric input and more elaborate forms, parses addresses including IPv6 literals, and delegates further checking to helper functions under strict conditions. However, while it addresses some conditions and actions from the spec constraints (such as interpreting a blank header and handling numeric and IPv6 cases), it does not implement a full recovery strategy from malformed constructs in all cases (for instance, it aborts with a BAD_REQUEST rather than attempting to recover in strict mode). This limits its coverage to a partial match relative to the RFC specifications.",success,
8937,fix_hostname,A recipient that processes such a URI reference MUST reject it as invalid.,226,Does Not Match,[],"The provided function processes the hostname from a host header or request record, but it does not implement the RFC requirement that a URI with an empty host identifier must be rejected as invalid. Although there is a conditional check (if (!*src)) that detects an empty hostname, this branch merely returns without setting an error (i.e., it does not set r->status to HTTP_BAD_REQUEST) and thus does not enforce rejection of such URIs. As a result, the function does not visibly address the specified spec constraint.",success,
8937,fix_hostname,A recipient that processes such a URI reference MUST reject it as invalid.,224,Does Not Match,[],"The RFC specification mandates that a recipient processing an HTTP URI with an empty host identifier must reject it as invalid. However, in the provided function, the code segment:

    if (!*src) {
        return is_v6literal;
    }

merely returns without setting an error status or rejecting the URI, effectively allowing an empty host to pass. This logic is based on an older RFC (RFC 2616) that allows a blank Host header, which directly contradicts the current RFC spec. No part of the function properly implements the required rejection of an empty host identifier, and thus the function does not fulfill the specified condition.",success,
8937,fix_hostname,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (!*src) {\n    return is_v6literal;\n}\n\n/* apr_parse_addr_port will interpret a bare integer as a port\n * which is incorrect in this context.  So treat it separately.\n */\nfor (c = src; apr_isdigit(*c); ++c);\nif (!*c) {\n    /* pure integer */\n    if (strict) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02416)\n                     ""[strict] purely numeric host names not allowed: %s"",\n                     src);\n        goto bad_nolog;\n    }\n    r->hostname = src;\n    return is_v6literal;\n}', 'explanation': 'This segment checks the host header string to ensure that if it consists solely of digits (i.e. a bare number), it is rejected when in strict mode. This validation prevents accepting a host value that might qualify as a protocol element disallowed for the sender role under the RFC’s grammar requirements. It is an effort to enforce that only hostname forms permitted by the protocol grammar are accepted.'}}, {'A1': {'code': 'if (strict && rv == APR_SUCCESS)\n    rv = strict_hostname_check(r, host);', 'explanation': 'Here the function calls an additional strict check on the hostname format when in strict mode. This further enforces that the hostname complies with the expected ABNF rules and prevents protocol elements that should only be generated by other roles.'}}]","The fix_hostname function contains logic to validate and adjust the Host header value. In strict mode it explicitly rejects a host value that is purely numeric and applies a strict hostname check, thereby attempting to enforce that the protocol elements (in this case, the Host header) conform to the allowed syntax. However, the RFC’s requirement also covers not generating protocol elements or syntax alternatives reserved for other roles, and this function does not address the full scope of such role-specific generation restrictions—it mainly validates the grammar. Consequently, while parts of the RFC constraints (labeled as C1 and A1) are handled within this function, other aspects are not directly implemented here, leading to a partial match.",success,
8941,check_serverpath,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function 'check_serverpath' does not include any logic that implements or addresses the spec constraint stating that 'an origin server MUST NOT use such context information to alter the request semantics.' This function deals with selecting the appropriate server based on matching the URI and server path from vhost lookup data. It does not interact with or process Content-Location or any related request context, and thus does not implement any labeled condition or action from the spec constraints.",success,
8942,construct_host_header,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Does Not Match,[],"The RFC requirement mandates that a sender MUST NOT generate an ""http"" URI with an empty host identifier. However, in the provided function, the host header is constructed by directly appending r->hostname without any check to ensure that it is non-empty. Since the function does not contain any logic to validate the host identifier's presence (i.e., it does not check if r->hostname is empty), it does not implement the necessary constraint within its own code.",success,
8942,construct_host_header,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'construct_host_header' assembles a Host header string by concatenating elements (such as the hostname, optional IPv6 brackets, and optional port) from the request structure. However, it does not implement any logic to enforce the RFC requirement that a sender must not generate protocol elements or syntax alternatives that are reserved for other roles. There is no visible handling of role restrictions (for example, no checks to avoid generating elements that are not allowed based solely on the sender's role), and the function focuses solely on constructing the header string, not on validating or restricting protocol elements per role-based rules. Therefore, it does not address any of the spec constraints (e.g., C1, A1) within its own code.",success,
8944,ap_update_vhost_from_headers_ex,"When an origin server receives a request with an absolute-form of request-target, the origin server MUST ignore the received Host header field (if any) and instead use the host information of the request-target.",182,Fully Matches,"[{'C1': {'code': ""if (r->hostname) {\n    /*\n     * If there was a host part in the Request-URI, ignore the 'Host'\n     * header.\n     */\n    have_hostname_from_url = 1;\n    is_v6literal = fix_hostname(r, NULL, conf->http_conformance);\n}"", 'explanation': 'This block checks if the request-target (absolute-form) contains a host. If so, it flags that the hostname from the URL should be used rather than the Host header.'}}, {'A1': {'code': 'if (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE) {\n    /*\n     * If we have both hostname from an absoluteURI and a Host header,\n     * we must ignore the Host header (RFC 2616 5.2).\n     * To enforce this, we reset the Host header to the value from the\n     * request line.\n     */\n    if (have_hostname_from_url && host_header != NULL) {\n        const char *repl = construct_host_header(r, is_v6literal);\n        apr_table_setn(r->headers_in, ""Host"", repl);\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02417)\n                      ""Replacing host header \'%s\' with host \'%s\' given ""\n                      ""in the request uri"", host_header, repl);\n    }\n}', 'explanation': 'This section implements the action mandated by the spec: when the request-target has host information, it ignores the original Host header by replacing it with the host from the request-target.'}}]","The function inspects whether the request-target contains a hostname (indicating an absolute-form). When this is true and a Host header is also present, the function explicitly replaces the original Host header with a new one generated from the request-target, thereby fulfilling the specification requirement that the origin server ignore the received Host header in such cases.",success,
8964,ap_bucket_response_clone,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The specified RFC requirement is that a sender must not generate protocol elements or syntax alternatives that can only be generated by participants in other roles. The function ap_bucket_response_clone simply clones a response bucket without any logic that verifies or enforces role-based restrictions, nor does it perform any filtering of protocol elements based on sender role. It merely copies the existing response data, as seen in the cloning of status, reason, headers, and notes. There is no segment that checks if a protocol element is only allowed for a particular role or that prevents generating such elements. Therefore, none of the spec constraints (e.g., C1, A1) are fully implemented in this function independently.",success,
8966,ap_bucket_headers_make,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function 'ap_bucket_headers_make' is focused solely on allocating and setting up a headers bucket by copying or creating a header table and assigning bucket types. There is no logic in the function that checks the sender's role or ensures that protocol elements that are only allowed by other roles are not generated within a given message. Since no part of the function verifies or enforces the role-specific protocol element constraints as described in the specification, it does not address any of the spec constraints (such as C1 or A1) within its own implementation.",success,
8970,apreq_cookie_attr,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function is focused on processing cookie attribute values based on their names (e.g., 'value', 'expires', 'domain', etc.) and does not contain any logic that verifies or enforces the role-based restrictions described in the spec. In other words, the function does not check whether the protocol elements being generated are exclusively allowed for a different role. Although there are conditional checks (for example, for the 'n' attribute or handling 'value') that cause the function to return error codes (APR_ENOTIMPL), these are not implemented to enforce the specific RFC requirement that a sender must not generate protocol elements or syntax alternatives reserved for other roles. No part of the code function directly addresses the labeled conditions or actions (such as C1, A1, etc.) that pertain to role-based restrictions, and so the function does not match the specification constraints.",success,
8972,get_pair,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': ""while (apr_isspace(*hdr) || *hdr == '=')\n    ++hdr;\n...\ncase 0:\ncase ';':\n    if (!nlen_set)\n        *nlen = hdr - key;\n    *v = hdr;\n    *vlen = 0;\n    *data = hdr;\n    return *nlen ? APREQ_ERROR_NOTOKEN : APREQ_ERROR_BADCHAR;"", 'explanation': ""This portion of the code shows a defensive approach in parsing the input by intentionally skipping over unexpected whitespace and '=' characters and returning error codes when tokens are missing or unexpected termination characters are encountered. This demonstrates an attempt to handle inputs that do not strictly conform to the expected ABNF grammar.""}}, {'A1': {'code': 'if (*val == \'""\') {\n    unsigned saw_backslash = 0;\n    for (*v = (unquote) ? ++val : val++; *val; ++val) {\n        switch (*val) {\n        case \'""\':\n            *data = val + 1;\n            \n            if (!unquote) {\n                *vlen = (val - *v) + 1;\n            }\n            else if (!saw_backslash) {\n                *vlen = val - *v;\n            }\n            else {\n                char *dest = apr_palloc(p, val - *v), *d = dest;\n                const char *s = *v;\n                while (s < val) {\n                    if (*s == \'\\\\\')\n                        ++s;\n                    *d++ = *s++;\n                }\n\n                *vlen = d - dest;\n                *v = dest;\n            }\n\n            return APR_SUCCESS;\n        case \'\\\\\':\n            saw_backslash = 1;\n            if (val[1] != 0)\n                ++val;\n        default:\n            break;\n        }\n    }\n    /* bad sequence: no terminating quote found */\n    *data = val;\n    return APREQ_ERROR_BADSEQ;\n}', 'explanation': 'The code handles quoted values defensively by checking for proper termination of quotes and processing escape sequences. It unquotes the value if required, thereby mitigating malformed or nonconforming input while parsing HTTP header components.'}}]","The function implements a defensive parsing mechanism by skipping extraneous characters, handling whitespace, validating token boundaries, and processing quoted strings including escape sequences. These measures address part of the spec's requirement to parse protocol elements defensively even if they don't perfectly conform to the ABNF grammar. However, the function does not include explicit checks for ensuring the protocol element fits within a reasonable buffer size, and thus it only partially meets the full range of the provided RFC constraints.",success,
8972,get_pair,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': ""while (apr_isspace(*hdr) || *hdr == '=')\n    ++hdr;"", 'explanation': ""This loop removes any leading whitespace (and extra '=' characters) from the header before further evaluation, thus ensuring that the field value is processed without leading whitespace.""}}, {'A1': {'code': 'while (apr_isspace(*val))\n    ++val;', 'explanation': ""After the '=' is found, this loop skips whitespace before processing the field's value, thereby fulfilling the requirement to exclude whitespace prior to evaluating the field value.""}}]","The function explicitly strips leading whitespace from both the field name and field value segments as required by the RFC, ensuring that any such whitespace is excluded before evaluation. All relevant logic is contained within the function itself, thereby fully matching the specification requirements.",success,
8972,get_pair,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,"[{'C1': {'code': ""while (apr_isspace(*hdr) || *hdr == '=')\n    ++hdr;\n\nwhile (apr_isspace(*val))\n    ++val;"", 'explanation': ""The function explicitly skips over whitespace characters (and even '=' characters) at the beginning of the header and before the value. This indicates an attempt to remove extraneous or 'bad' whitespace as required by the spec. However, the removal is implemented only in these specific places, and the broader context of processing and fully normalizing BWS (bad whitespace) throughout the protocol element is only partially addressed within this function.""}}]","The spec requires that any bad whitespace be detected and removed before interpreting protocol tokens. In this get_pair function, logic exists to skip leading whitespace (and '=' characters) and to bypass whitespace after the '=' sign. This demonstrates an effort to clean the input. However, the overall design appears focused on tokenizing key-value pairs and handling quoted values, without comprehensive handling of all whitespace normalizations (such as uniformly replacing any OWS/RWS sequences with a single SP) as detailed in the spec context. Consequently, the function only partially meets the requirement.",success,
8972,get_pair,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Partially Matches,"[{'C1': {'code': ""while (apr_isspace(*hdr) || *hdr == '=')\n    ++hdr;\n\n...\n\nwhile (apr_isspace(*val))\n    ++val;"", 'explanation': ""This code removes leading whitespace (and '=' characters) from the input before processing the key/value pair, thereby addressing the requirement of removing any BWS (bad whitespace) as described in the spec. This addresses one key aspect of the spec (C1) by ensuring that optional whitespace is removed before further interpretation. However, other aspects of the BWS handling specified in the RFC are not clearly addressed within this function alone.""}}]","The provided function includes explicit logic to skip and remove whitespace characters (and '=' tokens) at both the beginning of processing the header and before processing the value. This indicates an attempt to address the spec requirement regarding the removal of optional BWS. However, since the RFC's complete set of requirements or additional conditions/actions (e.g., further handling of BWS in other contexts) are not fully implemented within this function, it only partially matches the overall constraints specified by the RFC.",success,
8972,get_pair,Recipients that process the value of a quoted-string MUST handle a quoted-pair as if it were replaced by the octet following the backslash.,242,Fully Matches,"[{'C1': {'code': 'if (*val == \'""\') {\n    unsigned saw_backslash = 0;\n    for (*v = (unquote) ? ++val : val++; *val; ++val) {\n        switch (*val) {\n        case \'""\':\n            *data = val + 1;\n            if (!unquote) {\n                *vlen = (val - *v) + 1;\n            }\n            else if (!saw_backslash) {\n                *vlen = val - *v;\n            }\n            else {\n                char *dest = apr_palloc(p, val - *v), *d = dest;\n                const char *s = *v;\n                while (s < val) {\n                    if (*s == \'\\\\\')\n                        ++s;\n                    *d++ = *s++;\n                }\n                *vlen = d - dest;\n                *v = dest;\n            }\n            return APR_SUCCESS;\n        case \'\\\\\':\n            saw_backslash = 1;\n            if (val[1] != 0)\n                ++val;\n        default:\n            break;\n        }\n    }\n    *data = val;\n    return APREQ_ERROR_BADSEQ;\n}', 'explanation': 'The function explicitly checks if the value is quoted and, within the quoted section, it detects a backslash (the quoted-pair indicator). When a backslash is encountered, it sets a flag and skips the backslash to treat the next octet as its replacement. Later, if unquoting is enabled and a backslash was seen, it rebuilds the string without the backslashes. This logic directly implements the RFC requirement to treat a quoted-pair as if it were replaced by the octet following the backslash.'}}]","The function 'get_pair' contains a clear implementation for parsing quoted strings. In the section handling quoted values (when *val == '""'), it correctly processes backslashes by advancing past them and, if required, rebuilding the unquoted string. This behavior precisely mirrors the RFC specification stating that quoted-pairs must be replaced by the octet following the backslash. Thus, the code fully meets the condition labeled as C1.",success,
8973,apreq_parse_cookie_header,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': ""while (apr_isspace(*hdr))\n    ++hdr;\n\n...\n\nwhile (*hdr == ';' || apr_isspace(*hdr))\n    ++hdr;"", 'explanation': ""The code explicitly removes leading whitespace from the header by using loops that advance the pointer past any whitespace characters before processing the header field's value. This directly implements the requirement that a field parsing implementation must exclude such whitespace prior to evaluating the field value.""}}]","The function 'apreq_parse_cookie_header' removes any leading whitespace before processing the field values, both at the start and within the loop that parses cookie parameters. This behavior visibly addresses the specified HTTP RFC requirement, thereby fully matching the constraint labeled C1.",success,
8973,apreq_parse_cookie_header,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': ""while (apr_isspace(*hdr))\n        ++hdr;\n\n    ...\n\n        while (*hdr == ';' || apr_isspace(*hdr))\n            ++hdr;"", 'explanation': 'The RFC specifies that any bad whitespace (BWS) should be removed before interpreting the protocol element. This code removes leading whitespace at the beginning and then, within the parsing loops, it skips both semicolons and whitespace. This behavior clearly demonstrates that the function itself is handling the removal of BWS as required by the spec.'}}]","The function begins by stripping leading whitespace and continues to skip whitespace within its parsing loops. This directly corresponds to the RFC requirement that BWS (bad whitespace) be removed before further processing. Since this logic is implemented wholly within the function (and not relying on dependencies), it qualifies as fully addressing the requirement outlined in the RFC spec.",success,
8973,apreq_parse_cookie_header,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Fully Matches,"[{'C1': {'code': ""parse_cookie_error:\n\n    switch (*hdr) {\n    \n    case 0:\n        return rv;\n    \n    case ',' :\n    case ';':\n        if (c != NULL)\n            ADD_COOKIE(j, c);\n        ++hdr;\n        goto parse_cookie_header;\n    \n    default:\n        ++hdr;\n        goto parse_cookie_error;\n    }"", 'explanation': ""This code segment is an error-recovery loop that demonstrates the function's attempt to recover a usable protocol element from an invalid construct, which directly reflects the RFC specification statement that a recipient MAY attempt recovery when encountering errors. The function detects anomalies in the input (such as unexpected characters) and then uses goto statements to bypass or skip over the invalid parts, thereby implementing recovery logic as allowed by the specification.""}}]","The apreq_parse_cookie_header function includes logic to recover from errors in the cookie header by skipping over invalid sections and continuing to parse the remaining valid parts. This directly addresses the RFC requirement that a recipient MAY attempt to recover a usable protocol element from an invalid construct (labeled C1 here). All relevant error-handling logic is contained within the function, without relying on external dependencies, thus fully matching the specified requirement.",success,
8973,apreq_parse_cookie_header,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': ""while (apr_isspace(*hdr))\n    ++hdr;\n\n...\n\nwhile (*hdr == ';' || apr_isspace(*hdr))\n    ++hdr;"", 'explanation': 'The function explicitly skips over any whitespace characters (and semicolons when needed) before processing protocol elements. This aligns with the RFC requirement that a recipient must remove bad whitespace before interpreting the protocol element.'}}]","The provided code function directly implements the behavior mandated by the RFC: it parses the header string and removes unwanted whitespace before interpreting the cookie tokens. The loops using 'apr_isspace' (and checking for ';') demonstrate that the function cleans up the input by removing bad whitespace early in the processing. Hence, the code function fully meets the constraint as outlined in the spec.",success,
8973,apreq_parse_cookie_header,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'while (apr_isspace(*hdr))\n    ++hdr;\n\nif (*hdr == \'$\' && strncasecmp(hdr, ""$Version"", 8) == 0) {\n    /* XXX cheat: assume ""$Version"" => RFC Cookie header */\n    version = RFC;\n    ...\n}', 'explanation': 'The function begins by skipping whitespace and checks for a $Version token, indicating an effort to handle variations in the header format defensively. This shows an intent to process the header even if it only marginally conforms to expected formats.'}}, {'A1': {'code': ""case 0:\n    /* this is the normal exit point */\n    if (c != NULL) {\n        ADD_COOKIE(j, c);\n    }\n    return rv;\n\n... \n\nparse_cookie_error:\n\nswitch (*hdr) {\n\ncase 0:\n    return rv;\n\ncase ',' :\ncase ';':\n    if (c != NULL)\n        ADD_COOKIE(j, c);\n    ++hdr;\n    goto parse_cookie_header;\n\ndefault:\n    ++hdr;\n    goto parse_cookie_error;\n}"", 'explanation': 'The multiple error and exit checks, along with the handling of unexpected characters (using goto error labels), demonstrate that the function addresses error conditions in a defensive way, which is in line with the spec’s advice to defensively parse protocol elements.'}}]","The cookie header parser implements several defensive measures by checking for expected tokens, skipping whitespace, and routing errors through dedicated error paths. These aspects reflect an attempt to adhere to the HTTP RFC recommendation to parse conservatively. However, the function does not enforce any explicit checks on the length of the header (i.e. no buffer limit is validated) nor does it fully validate the header against an ABNF grammar, which are aspects also mentioned in the RFC specification. As a result, while some conditions and actions are implemented directly within the function, it only partially meets the overall defensive parsing criteria stated in the spec.",success,
8974,apreq_cookie_serialize,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function apreq_cookie_serialize is focused solely on transforming a cookie structure into a formatted string for either the old Netscape or RFC cookie format. There is no logic present in this function that verifies or restricts protocol elements based on the sender's role, nor does it enforce that only protocol elements allowed for a given role are generated. In other words, it does not check whether any generated cookie attribute (or syntax alternative) is disallowed for the sender’s role, which is the core requirement of the provided RFC specification. Therefore, the function does not visibly address the labeled constraint regarding role-based generation of protocol elements.",success,
8975,apreq_cookie_as_string,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function apreq_cookie_as_string merely converts a cookie data structure into its string representation by calling apreq_cookie_serialize and allocating memory. There is no logic addressing any of the spec constraints related to preventing the generation of protocol elements by unauthorized roles or ensuring that the generated protocol elements conform with the ABNF grammar. Therefore, the function does not visibly implement any condition (like C1) or action (like A1) from the specified HTTP RFC.",success,
8997,copy_request,"A sender MUST NOT generate the userinfo subcomponent (and its ""@"" delimiter) when an ""http"" or ""https"" URI reference is generated within a message as a target URI or field value.",229,Fully Matches,"[{'C1': {'code': 'if (r->parsed_uri.password == NULL) {\n    p = r->the_request;\n}\nelse {\n    /* Don\'t reveal the password in the server-status view */\n    p = apr_pstrcat(r->pool, r->method, "" "",\n                    apr_uri_unparse(r->pool, &r->parsed_uri, APR_URI_UNP_OMITPASSWORD),\n                    r->assbackwards ? NULL : "" "", r->protocol, NULL);\n}', 'explanation': 'This segment checks whether a password is present. If it is, the function uses apr_uri_unparse with the APR_URI_UNP_OMITPASSWORD flag, which omits the password (and thus the userinfo subcomponent) from the generated URI. This directly implements the RFC requirement that the userinfo subcomponent (including any password) must not be generated.'}}]","The function 'copy_request' ensures that whenever a password is found in the parsed URI, it avoids disclosing it by reconstructing the request string with the APR_URI_UNP_OMITPASSWORD flag. This behavior prevents generating the userinfo subcomponent in the output, thereby fulfilling the RFC specification requirement. The code checks and handles the omission directly within the function, satisfying all conditions provided by the spec constraints.",success,
8997,copy_request,The final recipient of the request SHOULD exclude any request fields that are likely to contain sensitive data when that recipient generates the response content.,272,Partially Matches,"[{'C1': {'code': 'if (r->parsed_uri.password == NULL) {\n        p = r->the_request;\n    }\n    else {\n        /* Don\'t reveal the password in the server-status view */\n        p = apr_pstrcat(r->pool, r->method, "" "",\n                        apr_uri_unparse(r->pool, &r->parsed_uri,\n                        APR_URI_UNP_OMITPASSWORD),\n                        r->assbackwards ? NULL : "" "", r->protocol, NULL);\n    }', 'explanation': 'The function checks if a password exists in the parsed URI and, if so, generates the request string using apr_uri_unparse with the flag APR_URI_UNP_OMITPASSWORD. This explicitly omits the password component from the output, corresponding to the spec’s requirement to exclude sensitive data from the response content.'}}]","The function implements logic to exclude at least one kind of sensitive data—the password—from the generated response, directly addressing the security requirement stated in the RFC specification. However, since the specification advises excluding any sensitive request fields and this function only handles the password field, its implementation only partially matches the overall requirements.",success,
9032,ap_field_noparam,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': 'while ((semi > intype) && apr_isspace(semi[-1])) {\n    semi--;\n}', 'explanation': 'This loop explicitly checks for whitespace preceding the semicolon and removes it by decrementing the pointer. This behavior implements the RFC requirement that a recipient must parse for and remove bad (extraneous) whitespace before interpreting the protocol element.'}}]","The function first locates the semicolon in the input string, which marks the beginning of parameters, and then uses a loop to move backwards, effectively removing any trailing whitespace (bad whitespace) before the semicolon. This behavior directly addresses the specification requirement that any extraneous whitespace (BWS) must be removed before the protocol element is interpreted. The implementation in the function body, independent of any external dependencies, fully meets the relevant constraint from the RFC.",success,
9032,ap_field_noparam,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': 'while ((semi > intype) && apr_isspace(semi[-1])) {\n    semi--;\n}', 'explanation': 'This loop checks for and removes trailing whitespace (BWS) preceding the semicolon. This directly implements the RFC requirement that any optional (bad) whitespace be removed before interpreting the protocol element.'}}, {'A1': {'code': 'if (semi == NULL) {\n    return apr_pstrdup(p, intype);\n} else {\n    return apr_pstrmemdup(p, intype, semi - intype);\n}', 'explanation': 'By checking for the presence of a semicolon and returning only the part of the string before it (after trimming trailing whitespace), the function effectively strips off parameters along with any bad whitespace, which is in line with the RFC specification.'}}]","The function ap_field_noparam inspects the input string for a semicolon delimiter, and if found, it walks backwards from the delimiter to eliminate any trailing whitespace (BWS) before returning a duplicate of the trimmed string. This directly implements the RFC requirement to remove BWS before processing the message. Hence, its logic is clearly aligned with the specification constraints regarding the removal of unnecessary whitespace.",success,
9032,ap_field_noparam,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Partially Matches,"[{'C1': {'code': 'while ((semi > intype) && apr_isspace(semi[-1])) {\n    semi--;\n}', 'explanation': 'This loop removes trailing whitespace immediately preceding the semicolon, addressing part of the requirement to exclude whitespace from the field value.'}}]","The provided function attempts to exclude trailing whitespace from the field value by trimming characters before the first semicolon. However, it does not handle leading whitespace or whitespace in cases where a semicolon is not present. Therefore, while it partially meets the spec constraint of removing extraneous whitespace before evaluation, it does not fully implement the requirement as stated in the HTTP spec.",success,
9047,ap_normalize_path,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Fully Matches,"[{'C1': {'code': ""if (decode_unreserved && path[l] == '%') {\n    if (apr_isxdigit(path[l + 1]) && apr_isxdigit(path[l + 2])) {\n        const char c = x2c(&path[l + 1]);\n        if (TEST_CHAR(c, T_URI_UNRESERVED)) {\n            l += 2;\n            path[l] = c;\n        }\n    } else {\n        ret = 0;\n    }\n}"", 'explanation': 'This segment implements the normalization of percent-encoded octets, decoding only those which represent unreserved characters as specified by RFC-3986.'}}, {'C2': {'code': 'if (w == 0 || AP_IS_SLASH(path[w - 1])) {\n    if (merge_slashes && AP_IS_SLASH(path[l])) {\n        do {\n            l++;\n        } while (AP_IS_SLASH(path[l]));\n        continue;\n    }', 'explanation': 'This part of the code collapses multiple consecutive slashes into a single slash, which is a key normalization step.'}}, {'A1': {'code': ""if (path[l] == '.') {\n    /* Remove /./ segments */\n    if (IS_SLASH_OR_NUL(path[l + 1])) {\n        l++;\n        if (path[l]) {\n            l++;\n        }\n        continue;\n    }"", 'explanation': 'This code removes /./ segments from the path, ensuring that redundant current-directory references are eliminated.'}}, {'A2': {'code': ""n = l + 1;\nif ((path[n] == '.' || (decode_unreserved\n                        && path[n] == '%'\n                        && path[++n] == '2'\n                        && (path[++n] == 'e'\n                            || path[n] == 'E')))\n        && IS_SLASH_OR_NUL(path[n + 1])) {\n    if (w > 1) {\n        do {\n            w--;\n        } while (w && !AP_IS_SLASH(path[w - 1]));\n    } else {\n        if (flags & AP_NORMALIZE_NOT_ABOVE_ROOT) {\n            ret = 0;\n        }\n    }\n    l = n + 1;\n    if (path[l]) {\n        l++;\n    }\n    continue;\n}"", 'explanation': 'This block handles the removal of parent-directory references (i.e. /xx/../ segments) by backing up the write pointer to effectively remove the previous segment.'}}]","The function ap_normalize_path implements a series of normalization steps that align with the HTTP RFC’s guidance on URI normalization. It decodes percent-encoded unreserved characters (C1), collapses multiple consecutive slashes (C2), removes current-directory references (/./ segments; A1), and eliminates parent-directory references (/../ segments; A2). Together, these operations fulfill the normalization requirement, ensuring that equivalent HTTP URIs are normalized consistently.",success,
9062,ap_getword_conf,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': 'while (apr_isspace(*str))\n    ++str;\n...\nwhile (apr_isspace(*strend))\n    ++strend;', 'explanation': 'C1 (removal of bad whitespace before processing the token) is fully implemented by skipping leading whitespace at the start and trailing whitespace after token extraction, which aligns with the RFC’s directive to remove BWS.'}}, {'A1': {'code': 'if (!*str) {\n    *line = str;\n    return """";\n}\n\nif ((quote = *str) == \'""\' || quote == \'\\\'\') {\n    strend = str + 1;\n    while (*strend && *strend != quote) {\n        if (*strend == \'\\\\\' && strend[1] &&\n            (strend[1] == quote || strend[1] == \'\\\\\')) {\n            strend += 2;\n        }\n        else {\n            ++strend;\n        }\n    }\n    res = substring_conf(p, str + 1, strend - str - 1, quote);\n\n    if (*strend == quote)\n        ++strend;\n}\nelse {\n    strend = str;\n    while (*strend && !apr_isspace(*strend))\n        ++strend;\n    res = substring_conf(p, str, strend - str, 0);\n}\n\nwhile (apr_isspace(*strend))\n    ++strend;\n*line = strend;\nreturn res;', 'explanation': 'A1 (ensuring that any BWS is removed before further processing) is addressed within the token parsing logic. By correctly handling both quoted and unquoted tokens and subsequently skipping whitespace, the function ensures that extraneous whitespace (BWS) is stripped as required by the RFC.'}}]","The function ap_getword_conf explicitly deals with the removal of bad whitespace (BWS) by advancing the pointer through any leading spaces before parsing the token and then skipping any trailing whitespace afterward. This behavior directly corresponds to the RFC specification stating that a recipient MUST remove such BWS before interpretation. Thus, the function visibly implements the intended removal of BWS on its own, fulfilling the labeled constraints.",success,
9062,ap_getword_conf,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': 'while (apr_isspace(*str)) ++str;\n...\nwhile (apr_isspace(*strend)) ++strend;', 'explanation': ""The function first skips any leading spaces by using 'while (apr_isspace(*str))', and later after determining the word boundary, it again skips any trailing spaces before updating *line. This directly implements the RFC requirement that a recipient must parse for bad whitespace and remove it before interpreting the protocol element.""}}]","The function 'ap_getword_conf' processes an input string by removing unwanted whitespace both at the beginning and end of the intended token. This behavior is in line with the RFC specification that mandates bad whitespace be removed. The relevant code segments explicitly check for whitespace using 'apr_isspace' and remove them, thereby fully addressing the specified condition (C1) within the function itself.",success,
9062,ap_getword_conf,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': 'while (apr_isspace(*str))\n    ++str;', 'explanation': 'This loop skips leading whitespace in the input, ensuring that the field value is evaluated without any preceding whitespace as required by the RFC.'}}, {'A1': {'code': 'while (apr_isspace(*strend))\n    ++strend;', 'explanation': 'This loop advances past any trailing whitespace after the token, ensuring that only the intended field value is retained, which aligns with the RFC mandate to exclude such whitespace before evaluation.'}}]","The function explicitly trims the input by first skipping any leading whitespace and later skipping any trailing whitespace before returning the parsed field value. This approach directly implements the requirement stated in the RFC that any allowed extraneous whitespace should be excluded prior to field evaluation. All whitespace handling is implemented within the function body, making it fully compliant with the spec.",success,
9079,find_list_item,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': ""while (*ptr == ',' || apr_isspace(*ptr)) {\n    ++ptr;\n}"", 'explanation': 'This loop explicitly skips commas and whitespace characters at the beginning of each list item, thereby removing bad whitespace (BWS) as required by the RFC specification.'}}, {'A1': {'code': ""/* We skip extra whitespace and any whitespace around a '=', '/', or ';' ... */\nfor (pos = (const unsigned char *)tok; *ptr && (in_qpair || in_qstr || in_com || *ptr != ','); ++ptr) {\n    …\n    case ' ' :\n    case '\\t': if (addspace || !good)\n                   break;\n               if (in_com || in_qstr)\n                   good = (*pos++ == *ptr);\n               else\n                   addspace = 1;\n               break;\n    …\n}"", 'explanation': ""Within the inner parsing loop, the code distinguishes between whitespace within quoted contexts and outside. It conditionally skips or normalizes whitespace around punctuation (such as '=', '/', ';'), effectively removing superfluous whitespace as mandated by the RFC.""}}]","The function 'find_list_item' is designed to parse an HTTP header list item (specifically eTags) and includes explicit mechanisms to skip and normalize bad whitespace (BWS) before interpreting the protocol element. The initial loop removes leading BWS and the subsequent switch-case logic manages whitespace around significant tokens. Thus, the function itself fully addresses the RFC requirement that any content defined as BWS may be removed before further processing.",success,
9079,find_list_item,Recipients that process the value of a quoted-string MUST handle a quoted-pair as if it were replaced by the octet following the backslash.,242,Partially Matches,"[{'C1': {'code': ""case '\\\\': in_qpair = 1;\n                           if (addspace == 1)\n                               good = good && (*pos++ == ' ');\n                           good = good && (*pos++ == *ptr);\n                           addspace = 0;\n                           break;\n\nif (in_qpair) {\n    in_qpair = 0;\n    if (good)\n        good = (*pos++ == *ptr);\n}"", 'explanation': 'The function includes logic to detect a backslash (i.e. the quoted-pair indicator) and then processes the next octet by comparing it with the expected token character. This corresponds to the spec requirement that the quoted-pair should be handled as if replaced by the character following the backslash. However, the implementation only performs a comparative check rather than explicitly replacing the backslash construct.'}}]","The function attempts to implement the RFC requirement for handling quoted-pairs by checking for backslash characters and then processing the subsequent octet accordingly. This is visible in the switch-case block handling '\\' and the subsequent check when in_qpair is active. Nevertheless, the implementation does not fully perform an octet replacement mechanism as described in the spec—it directly compares characters instead of constructing the final processed string. Therefore, while some parts of the condition (C1) are addressed in the function, the overall approach only partially meets the detailed requirement.",success,
9079,find_list_item,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': ""while (*ptr == ',' || apr_isspace(*ptr)) {\n    ++ptr;\n}"", 'explanation': 'This loop explicitly skips leading commas and whitespace before processing each list item, thereby excluding any leading whitespace prior to evaluating the field value as required by the RFC.'}}, {'A1': {'code': ""case ' ' :\ncase '\\t':\n    if (addspace || !good)\n        break;\n    if (in_com || in_qstr)\n        good = (*pos++ == *ptr);\n    else\n        addspace = 1;\n    break;"", 'explanation': 'This segment handles extra whitespace by either comparing it directly when inside comments or quoted strings or marking it to be skipped. This selective handling ensures that only the significant characters are considered during evaluation, effectively excluding irrelevant whitespace.'}}]","The function 'find_list_item' implements logic to ignore unwanted whitespace before processing the token. It uses a loop to bypass leading commas and whitespace and incorporates additional handling (via the 'addspace' mechanism and specific switch cases for space and tab) to manage whitespace around critical characters. This indicates that the function, by itself, attempts to satisfy the RFC requirement to exclude such whitespace prior to evaluating the field value.",success,
9079,find_list_item,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,"[{'C1': {'code': ""while (*ptr == ',' || apr_isspace(*ptr)) {\n    ++ptr;\n}\n\n...\ncase ' ' :\ncase '\\t': if (addspace || !good)\n               break;\n           if (in_com || in_qstr)\n               good = (*pos++ == *ptr);\n           else\n               addspace = 1;\n           break;"", 'explanation': ""The function explicitly skips over commas and whitespace characters (using apr_isspace) at the beginning of each list item. In the inner parsing loop it sets an 'addspace' flag to account for extra whitespace and then compares this to a single space in the token, effectively normalizing bad whitespace. This indicates an attempt to parse and remove undesirable whitespace before further interpretation, which aligns with the specification. However, the logic is applied only in the context of matching a token in a header list rather than a general-purpose whitespace removal, hence only partially matching the broad requirement.""}}]","The provided function includes logic that skips and normalizes whitespace (bad whitespace) when parsing a comma‐separated list (specifically for ETag values). It uses a loop to advance past commas and whitespace characters and then compares segments of the token while managing extra whitespace (using the addspace flag). This shows a clear attempt to parse for and effectively remove extra whitespace before interpreting the protocol element. However, the handling is limited to the specific parsing context of ETag headers and does not constitute a full general implementation of all aspects of the RFC requirement. Therefore, the function partially matches the constraint concerning bad whitespace removal.",success,
9079,find_list_item,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (!line || !tok) {\n        return 0;\n    }', 'explanation': 'This check ensures that the function does not assume a non-null input, which is a basic defensive parsing measure.'}}, {'A1': {'code': 'for (pos = (const unsigned char *)tok;\n     *ptr && (in_qpair || in_qstr || in_com || *ptr != \',\');\n     ++ptr) {\n\n    if (in_qpair) {\n        in_qpair = 0;\n        if (good)\n            good = (*pos++ == *ptr);\n    }\n    else {\n        switch (*ptr) {\n            case \'\\\\\': in_qpair = 1;\n                       if (addspace == 1)\n                           good = good && (*pos++ == \' \');\n                       good = good && (*pos++ == *ptr);\n                       addspace = 0;\n                       break;\n            case \'""\' : if (!in_com)\n                           in_qstr = !in_qstr;\n                       if (addspace == 1)\n                           good = good && (*pos++ == \' \');\n                       good = good && (*pos++ == *ptr);\n                       addspace = 0;\n                       break;\n            case \'(\' : if (!in_qstr)\n                           ++in_com;\n                       if (addspace == 1)\n                           good = good && (*pos++ == \' \');\n                       good = good && (*pos++ == *ptr);\n                       addspace = 0;\n                       break;\n            case \')\' : if (in_com)\n                           --in_com;\n                       good = good && (*pos++ == *ptr);\n                       addspace = 0;\n                       break;\n            case \' \' :\n            case \'\\t\': if (addspace || !good)\n                           break;\n                       if (in_com || in_qstr)\n                           good = (*pos++ == *ptr);\n                       else\n                           addspace = 1;\n                       break;\n            case \'=\' :\n            case \'/\' :\n            case \';\' : if (!(in_com || in_qstr))\n                           addspace = -1;\n                       good = good && (*pos++ == *ptr);\n                       break;\n            default  : if (!good)\n                           break;\n                       if (addspace == 1)\n                           good = (*pos++ == \' \');\n                       if (in_com || in_qstr)\n                           good = good && (*pos++ == *ptr);\n                       else\n                           good = good && (apr_tolower(*pos++) == apr_tolower(*ptr));\n                       addspace = 0;\n                       break;\n        }\n    }\n}', 'explanation': ""This lengthy loop demonstrates a defensive parsing approach by handling quoted-pairs, quoted-strings, and comments. It does not assume strict conformance to a grammar and tolerates variations, which aligns with the RFC's argument to parse with only marginal expectations.""}}]","The function 'find_list_item' shows aspects of defensive parsing as recommended by the RFC specification by performing null checks and handling various syntactical constructs (quotes, escapes, comments) without strict assumptions about conformance. However, it does not implement explicit buffer size or length validations, and its defensive measures are limited to parsing the specific structure of ETags. As such, while some conditions (like checking for null pointers and handling unexpected characters) are met within the function, the complete set of defensive parsing expectations outlined in the RFC (including considerations of buffer size and comprehensive ABNF conformity) is only partially addressed.",success,
9083,ap_parse_token_list_strict,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (!TEST_CHAR(c, T_HTTP_TOKEN_STOP)) {\n    in_leading_space = 0;\n    if (in_trailing_space) {\n        return ""Encountered illegal whitespace in token"";\n    }\n}\nelse if (c == \' \' || c == \'\\t\') {\n    if (in_leading_space) {\n        ++tok_begin;\n    } else {\n        ++in_trailing_space;\n    }\n}', 'explanation': 'This segment defensively parses the input token by checking for valid token characters versus whitespace and generating an error when illegal whitespace is encountered. It shows an attempt to be lenient (allowing leading whitespace) but strict enough to reject tokens with embedded trailing whitespace, aligning with defensive parsing expectations in the RFC.'}}, {'A1': {'code': 'else {\n    if (skip_invalid) {\n        const char *temp;\n        temp = ap_strchr_c(cur, \',\');\n        if (!temp) {\n            temp = ap_strchr_c(cur, \'\\0\');\n        }\n\n        cur = temp - 1;\n        in_leading_space = 1;\n        in_trailing_space = 0;\n    } else {\n        return apr_psprintf(p, ""Encountered illegal separator \'\\x%.2x\'"", (unsigned int)c);\n    }\n}', 'explanation': ""This block implements a defensive measure by optionally skipping over invalid separator characters based on the 'skip_invalid' flag, thus allowing for only marginal expectations of adherence to the protocol's ABNF grammar, as suggested by the RFC.""}}]","The function ap_parse_token_list_strict implements defensive parsing measures by processing the input token character by character, trimming leading whitespace, and rejecting tokens containing illegal inter-token whitespace or separator characters. These measures partially address the RFC's requirement that a recipient should parse protocol elements defensively, expecting only marginal conformance to the ABNF and reasonable length constraints. However, the function does not implement explicit buffer size checks or comprehensive validations regarding token length, which means that while it takes defensive steps, it only partially meets all elements implied by the spec context.",success,
9083,ap_parse_token_list_strict,"In other words, a recipient MUST accept lists that satisfy the following syntax:",238,Partially Matches,"[{'C1': {'code': ""if (!in_leading_space) {\n    /* If we're out of the leading space, we know we've read some\n     * characters of a token */\n    if (*tokens == NULL) {\n        *tokens = apr_array_make(p, 4, sizeof(char *));\n    }\n    APR_ARRAY_PUSH(*tokens, char *) =\n        apr_pstrmemdup((*tokens)->pool, tok_begin,\n                       (cur - tok_begin) - in_trailing_space);\n}"", 'explanation': 'This segment detects when a token has been found (by checking that we are out of the leading whitespace) and then adds it to the token array. By not adding tokens when still in leading space, the function effectively ignores empty list elements, which aligns with the RFC’s requirement that empty elements should be ignored in the count.'}}, {'A1': {'code': 'if (in_trailing_space) {\n    return ""Encountered illegal whitespace in token"";\n}', 'explanation': 'This code enforces that once a token’s non-whitespace characters have started, any trailing whitespace is disallowed, thereby implementing a strict validation check on the token syntax in accordance with the RFC constraints.'}}]","The function implements a strict parser for comma‐separated token lists. It includes logic to ignore empty tokens (by not adding elements when only whitespace is present) and to enforce that any whitespace occurring after the beginning of a token (i.e. trailing whitespace) results in an error. These pieces of logic visibly address parts of the RFC requirements. However, not every possible aspect is handled solely within this function—some aspects like handling a 'reasonable number of empty list elements' in a broader context or other detailed validations might be managed elsewhere—so the implementation in this function only partially meets the full set of RFC constraints.",success,
9083,ap_parse_token_list_strict,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'else {\n    /* Encountered illegal separator char */\n    if (skip_invalid) {\n        const char *temp;\n        temp = ap_strchr_c(cur, \',\');\n        if(!temp) {\n            temp = ap_strchr_c(cur, \'\\0\');\n        }\n\n        /* Act like we haven\'t seen a token so we reset */\n        cur = temp - 1;\n        in_leading_space = 1;\n        in_trailing_space = 0;\n    } else {\n        return apr_psprintf(p, ""Encountered illegal separator \'\\x%.2x\'"", (unsigned int)c);\n    }\n}', 'explanation': 'This segment implements a recovery strategy when an illegal separator is encountered. If skip_invalid is true, it skips over the invalid input up to the next comma or end-of-string, which is in line with the RFC’s permission for a recipient to recover from an invalid construct.'}}, {'A1': {'code': ""if (!in_leading_space) {\n    /* If we're out of the leading space, we know we've read some characters of a token */\n    if (*tokens == NULL) {\n        *tokens = apr_array_make(p, 4, sizeof(char *));\n    }\n    APR_ARRAY_PUSH(*tokens, char *) =\n        apr_pstrmemdup((*tokens)->pool, tok_begin, (cur - tok_begin) - in_trailing_space);\n}"", 'explanation': 'This code constructs the token by trimming trailing whitespace and then saving the valid token into the tokens array. It represents the action of recovering and forming a usable protocol element from the input.'}}]","The function 'ap_parse_token_list_strict' incorporates logic to process HTTP token lists and employs a recovery mechanism if invalid characters are encountered (controlled by the 'skip_invalid' flag). This aligns partially with the RFC constraint that a recipient MAY attempt to recover a usable protocol element from an invalid construct. However, while it demonstrates recovery (C1) and token reconstruction (A1), other aspects of the RFC, such as broader error handling strategies dictated by the spec context, are either handled elsewhere (in dependencies) or out of scope for this function. Therefore, the function partially matches the RFC specification constraints.",success,
9083,ap_parse_token_list_strict,"Specifications for newly defined fields SHOULD limit their values to visible US-ASCII octets (VCHAR), SP, and HTAB",2,Partially Matches,"[{'A1': {'code': ""else if (c == ' ' || c == '\\t') {\n    if (in_leading_space) {\n        /* We're still in leading whitespace */\n        ++tok_begin;\n    }\n    else {\n        /* We must be in trailing whitespace */\n        ++in_trailing_space;\n    }\n}\n...\nif (!in_leading_space) {\n    APR_ARRAY_PUSH(*tokens, char *) =\n        apr_pstrmemdup((*tokens)->pool, tok_begin, (cur - tok_begin) - in_trailing_space);\n}"", 'explanation': 'The function implements logic to trim leading whitespace (by advancing tok_begin when in_leading_space is true) and to avoid including trailing whitespace (by counting in_trailing_space and subtracting it from the token length). This addresses the spec requirement that field values do not include leading or trailing whitespace before evaluation.'}}]","The function attempts to address part of the HTTP RFC regarding field value formatting by explicitly handling the removal of leading and trailing whitespace when parsing tokens. However, it does not clearly implement the restriction that field values must be limited strictly to visible US-ASCII octets (VCHAR), SP, and HTAB, nor does it clearly check for dangerous characters such as CR, LF, or NUL. Therefore, while the whitespace handling is fully addressed, the character set limitation is only implicitly handled (via the external TEST_CHAR macro) and not explicitly verified in this function. This leads to a partial match with the spec constraints.",success,
9087,ap_get_token,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Partially Matches,"[{'C1': {'code': 'while (apr_isspace(*ptr))\n    ++ptr;\n...\nwhile (apr_isspace(*ptr))\n    ++ptr;', 'explanation': 'The RFC requires that any bad whitespace (BWS) be removed before interpreting protocol elements. In this function, the initial loop skips leading whitespace and a similar loop at the end advances the pointer past any trailing whitespace before updating *accept_line. This effectively removes BWS from around the token.'}}]","The function 'ap_get_token' implements logic to remove whitespace (which qualifies as BWS) by skipping over it before and after token extraction, directly addressing the BWS requirement in the spec context. However, since the provided spec constraints included both conditions (e.g., removal of BWS) and actions (e.g., other handling details that may be part of a full RFC implementation) and only the whitespace-removal part is visibly implemented here, the function only partially matches the overall spec constraints.",success,
9087,ap_get_token,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': 'while (apr_isspace(*ptr))\n    ++ptr;\n\n// …\n\nwhile (apr_isspace(*ptr))\n    ++ptr;\n*accept_line = ptr;', 'explanation': ""The code explicitly skips over any whitespace characters both before beginning token extraction and after the token is parsed. This effectively removes the 'bad whitespace' as required by the RFC.""}}, {'A1': {'code': 'tok_start = ptr;\n\nwhile (*ptr && (accept_white || !apr_isspace(*ptr))\n       && *ptr != \';\' && *ptr != \',\') {\n    if (*ptr++ == \'""\')\n        while (*ptr)\n            if (*ptr++ == \'""\')\n                break;\n}\n\ntoken = apr_pstrmemdup(p, tok_start, ptr - tok_start);', 'explanation': 'The function parses the token after removing leading whitespace, ensuring that only the meaningful protocol element is extracted. This satisfies the requirement that any extraneous whitespace be removed prior to interpretation.'}}]","The function 'ap_get_token' implements token extraction by advancing past whitespace characters at the beginning and end of the token, thus removing any extraneous or 'bad' whitespace. This behavior directly addresses the RFC requirement that a recipient must remove such whitespace before processing the protocol element. The logic within the function fully implements the necessary constraints by handling whitespace removal and then extracting the token, making it compliant with the specification.",success,
9087,ap_get_token,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Partially Matches,"[{'C1': {'code': 'while (apr_isspace(*ptr))\n    ++ptr;\n...\nwhile (apr_isspace(*ptr))\n    ++ptr;', 'explanation': ""The function explicitly skips over leading whitespace and advances the pointer past any whitespace after token extraction. This indicates an intention to remove extraneous whitespace, which is related to the RFC requirement. However, because the behavior depends on the 'accept_white' flag (i.e. when accept_white is true, the token extraction loop does not stop at whitespace), the implementation only conditionally excludes whitespace. Hence, it does not fully guarantee removal of trailing whitespace from the field value in all cases.""}}]","The RFC requires that any allowed whitespace in a header field be removed prior to evaluation. The code function shows logic to skip leading whitespace and later advances the input pointer past any subsequent whitespace. This implements part of the requirement. However, the token extraction behavior varies with the 'accept_white' parameter – when 'accept_white' is true, the loop allows whitespace within the token. As such, the function’s logic only partially addresses the full specification requirement by conditionally trimming whitespace rather than always excluding both leading and trailing whitespace from the token itself.",success,
9091,ap_is_chunked,A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance.,187,Partially Matches,"[{'C1': {'code': 'if (!ap_cstr_casecmp(line, ""chunked"")) { \n    return 1;\n}\n\n...\n\ns = find_last_token(p, line, ""chunked"");\nif (!s) return 0;\n\nwhile (--s > line) { \n    if (*s != \' \') break;\n}\n\nif (*s == \',\' || *s == \' \') { \n    return 1;\n}', 'explanation': ""The function checks whether the input string (typically from a Transfer-Encoding header) is 'chunked' either by a case-insensitive direct comparison or by locating it as the last token when embedded in a comma-separated list. This implements a basic detection of the chunked transfer coding, which partially addresses the specification requiring a recipient to parse it.""}}]","While the HTTP spec requires that a recipient must be able to parse the chunked transfer coding (which involves more detailed parsing and framing of message bodies), this function focuses solely on detecting whether the string 'chunked' is present in the header value. It does so by first checking for an exact case-insensitive match and then by scanning for 'chunked' as a token, which partially fulfills the requirement. However, it does not implement the full parsing and framing behavior described in Section 7.1 of the HTTP RFC, and hence only partially matches the spec constraints.",success,
9094,unescape_url,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': ""if (!apr_isxdigit(*(y + 1)) || !apr_isxdigit(*(y + 2))) {\n    badesc = 1;\n    *x = '%';\n}"", 'explanation': ""This segment detects an invalid percent-encoded sequence and, rather than crashing, copies the '%' literal into the output. This demonstrates an attempt to handle (recover from) an invalid construct as allowed by the RFC.""}}, {'A1': {'code': 'if (badesc) {\n    return HTTP_BAD_REQUEST;\n} else if (badpath) {\n    return HTTP_NOT_FOUND;\n} else {\n    return OK;\n}', 'explanation': 'Based on error flags, the function returns appropriate HTTP error statuses. This explicit error signaling aligns with the RFC context that requires processing protocol elements and handling invalid constructs, although it relies on error signaling rather than a full recovery mechanism.'}}]","The unescape_url function includes logic to detect invalid percent-encoded sequences and handle them by copying literal characters or by returning HTTP error codes. This shows that the function is addressing some aspects of the RFC’s directive to attempt recovery from invalid constructs. However, the recovery is limited—as the function ultimately returns error codes when issues are detected rather than fully normalizing the URL—and it does not handle every potential nuance indicated by the RFC specification context. Hence, it only partially implements the required behavior.",success,
9098,ap_unescape_urlencoded,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Partially Matches,[],"The RFC spec requires that HTTP components treat URIs that are equivalent after normalization as identifying the same resource. The provided function does perform a limited normalization step—it replaces '+' with a space and decodes percent-encoded characters via unescape_url(). However, this only implements a basic unescaping operation rather than a full normalization process (such as case normalization, removal of default port numbers, proper handling of dots in path segments, etc.) as might be expected from a complete implementation in compliance with the RFC. Therefore, while part of the normalization is visible, the function does not fully implement the entire normalization requirement specified by the RFC.",success,
9098,ap_unescape_urlencoded,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function_ap_unescape_urlencoded only performs string unescaping by replacing '+' with a space and then calling an unescape function. There is no logic within this function that checks or enforces any constraint related to a sender not generating protocol elements or syntax alternatives restricted to other roles (as outlined in the RFC spec). Hence, none of the labeled conditions (e.g., C1) or actions (e.g., A1) from the spec constraints are implemented in the function.",success,
9099,ap_construct_server,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Does Not Match,[],"The function 'ap_construct_server' is responsible for constructing the server string by appending the port to the hostname if the port is non-default. However, it does not include any logic to verify that the hostname is non-empty. According to the spec, a sender MUST NOT generate an ""http"" URI with an empty host identifier, which implies that there should be a check to ensure the hostname is not empty. Since such a check is absent, the function does not visibly address the specified constraint within its own logic.",success,
9107,ap_escape_html2,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function ap_escape_html2 is dedicated to escaping HTML characters in a string by replacing them with their corresponding HTML entities. This logic is focused on sanitizing output for HTML contexts. There is no evidence in this function that it checks or restricts the generation of protocol elements based on sender roles or adherence to the HTTP RFC requirement that 'a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles.' Therefore, none of the spec constraints (e.g., C1, A1) are addressed within this function.",success,
9121,ap_pbase64decode_strict,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'end_index = strspn(encoded, ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""\n                            ""abcdefghijklmnopqrstuvwxyz""\n                            ""0123456789+/"" );\n\n... \nif (*end) {\n    return APR_EINVAL;\n}', 'explanation': 'The function uses strspn to ensure that the characters in the input string belong to the Base64 alphabet, and later checks that the string ends exactly when valid Base64 content ends. This defensive check partially reflects the RFC’s recommendation to parse protocol elements defensively with only marginal assumptions about conformance.'}}, {'A1': {'code': 'if (last_group_len == 1) {\n    return APR_EINVAL;\n} else if (last_group_len == 2) {\n    if (*end != \'=\' || end[1] != \'=\') {\n        return APR_EINVAL;\n    } else if (!ap_strchr(""AQgw"", end[-1])) {\n        return APR_EINVAL;\n    }\n    end += 2;\n} else if (last_group_len == 3) {\n    if (*end != \'=\') {\n        return APR_EINVAL;\n    } else if (!ap_strchr(""AEIMQUYcgkosw048"", end[-1])) {\n        return APR_EINVAL;\n    }\n    end++;\n}', 'explanation': 'This segment strictly enforces the two allowed padding cases in Base64 encoding. By verifying that only the expected padding characters appear (and in their correct positions), the code is taking a defensive approach to validate the input against a strict interpretation of the Base64 ABNF, which is in line with the RFC’s mindset.'}}]","The function clearly implements several defensive parsing checks such as verifying that the input string contains only valid Base64 characters, enforcing strict padding rules, and confirming proper termination of the input. Such measures match the RFC’s guidance that recipients should parse protocol elements defensively with only minimal assumptions regarding adherence to the ABNF grammar. However, the function does not address all aspects mentioned in the RFC—specifically, it does not enforce a maximum buffer size or handle other potential irregularities beyond the Base64 format. Because only some of the RFC’s defensive parsing expectations are implemented in the function’s own logic, the overall match is considered partial.",success,
9124,ap_escape_quotes,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, ap_escape_quotes, processes an input string to escape quotes by inserting a preceding backslash. It does not perform any checks, validations, or logic concerning the generation of protocol elements or enforcing role-specific restrictions as required by the RFC specification. No part of the function addresses the requirement that a sender must not generate protocol elements or syntax alternatives reserved for other roles.",success,
9126,ap_timeout_parameter_parse,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'tout = apr_strtoi64(timeout_parameter, &endp, 10);\nif (errno) {\n    return errno;\n}', 'explanation': 'This code segment defensively attempts to parse the numeric part of the protocol element, checking for conversion errors (e.g., non‐numeric input), which is in the spirit of the RFC’s recommendation to not assume full ABNF conformance.'}}, {'C2': {'code': 'if (!endp || !*endp) {\n    time_str = default_time_unit;\n} else {\n    time_str = endp;\n}', 'explanation': 'This segment handles cases where no explicit time unit is provided by falling back to a default unit, thus defensively accommodating variations in the received protocol element.'}}, {'A1': {'code': 'if (tout < 0) { \n    return APR_EGENERAL;\n}', 'explanation': 'This block ensures that negative timeout values are rejected, a defensive measure to enforce valid value ranges.'}}, {'A2': {'code': ""switch (*time_str) {\n    case 's':\n    case 'S':\n        CHECK_OVERFLOW(tout, apr_time_sec(APR_INT64_MAX));\n        check = apr_time_from_sec(tout);\n        break;\n    // ... other cases with overflow checks ...\n}"", 'explanation': 'The switch statement coupled with the CHECK_OVERFLOW macros for various time units shows that the function is implemented to defend against numerical overflow and to correctly interpret the time unit, further meeting the RFC’s defensive parsing approach.'}}]","The function ap_timeout_parameter_parse implements a defensive parsing strategy for a timeout parameter in an HTTP-like protocol element. It does so by checking the outcome of numeric conversion, providing a default for missing unit specifiers, rejecting negative values, and performing overflow checks. These measures directly address the intent of the RFC specification—to parse protocol elements defensively without assuming complete adherence to a prescribed grammar—which means the function fully matches the constraints set out in the spec.",success,
9127,ap_parse_strict_length,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': ""apr_isdigit(*str) && apr_strtoff(len, str, &end, 10) == APR_SUCCESS && *end == '\\0'"", 'explanation': 'This code verifies that the input string begins with a digit, that the conversion to an integer (using apr_strtoff) is successful, and that the entire string is consumed during conversion. This defensive check aligns with the RFC’s advice to not assume full conformance to the ABNF grammar, though it is limited to strictly numeric input.'}}]","The function attempts to defensively process a protocol element by ensuring that the provided string is strictly numeric and fully convertible to an integer without any trailing characters. This is in the spirit of defensive parsing described in the RFC specification, which advises not to assume complete conformance and to check cautiously. However, the function does not check for other aspects such as verifying that the parsed value is within a 'reasonable buffer size', nor does it handle non-numeric protocol elements. As a result, while it does implement some defensive checks (e.g. validating ABNF conformance for a numeric element), it only partially meets the full intent of the RFC constraints.",success,
9133,ap_parse_form_data,"Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",308,Does Not Match,[],"The provided function, ap_parse_form_data, is focused on parsing 'application/x-www-form-urlencoded' form data and does not include any logic to check or restrict parameters named 'q' (case-insensitively) as required by the RFC specification. There is no code segment within the function that compares parameter names against 'q' or that manages transfer coding parameters. Therefore, this function does not visibly address the specified condition regarding the exclusion of a 'q' parameter.",success,
9133,ap_parse_form_data,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function, ap_parse_form_data, is responsible for parsing and processing incoming form data (application/x-www-form-urlencoded), not for generating protocol elements. The RFC specification requires that a sender must not generate protocol elements that do not match the ABNF grammar. This function does not generate protocol elements, nor does it implement logic ensuring that any generated output conforms to the ABNF grammar. Instead, its focus is on reading buckets, decoding percent encodings, and splitting parameters. Thus, within the function_body there is no visible implementation that addresses the spec constraint (labeled here as C1 or similar) requiring a sender to only produce valid protocol elements. Dependencies or other parts of the system might handle such validation or generation, but by itself, this function does not meet the required constraint.",success,
9133,ap_parse_form_data,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function is focused on parsing form data from an incoming HTTP request and handling the data accordingly. It verifies the Content-Type header and processes the input buckets, but it does not generate or output any protocol elements or syntax alternatives. Thus, it does not include any logic to enforce that a sender must not generate protocol elements or syntax alternatives reserved for other roles, as specified by the RFC. The function neither validates roles nor prevents the generation of disallowed protocol elements, so it does not meet the specified constraint within its own logic.",success,
9133,ap_parse_form_data,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (offset < HUGE_STRING_LEN) {\n    ...\n} else {\n    state = FORM_ABORT;\n}', 'explanation': 'This segment checks that the accumulated input does not exceed a well‐defined buffer size (HUGE_STRING_LEN). By setting the state to FORM_ABORT when the limit is reached, the function defends against overly large inputs, directly addressing the requirement to parse with only marginal expectations.'}}, {'A1': {'code': 'if (FORM_ABORT == state || size < 0 || num == 0) {\n    return HTTP_REQUEST_ENTITY_TOO_LARGE;\n}', 'explanation': 'This code returns an error when the input exceeds the allowed buffer or when other limits (such as the available data count) are exceeded. This is a direct action enforcing that the recipient should handle unexpected or excessive input defensively as per the RFC.'}}]","The function implements a defensive parsing strategy as recommended by the RFC. It ensures that the input conforms only marginally to expected form data format and imposes a maximum buffer limit. By checking the content type, using a state machine to process the data (including handling '+' and percent-encoded characters), and aborting when the length exceeds HUGE_STRING_LEN, the function fulfills the spirit of both the condition (C1) and the action (A1) specified in the RFC constraints. Thus, the function alone visibly addresses the key defensive measures required by the HTTP RFC.",success,
9133,ap_parse_form_data,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'ct = apr_table_get(r->headers_in, ""Content-Type"");\nif (!ct || ap_cstr_casecmpn(""application/x-www-form-urlencoded"", ct, 33)) {\n    return ap_discard_request_body(r);\n}', 'explanation': 'This segment checks that the received protocol element (i.e. the Content-Type header) matches the expected form type as defined by the spec. It represents an attempt to interpret the protocol element according to the required semantics.'}}, {'A1': {'code': 'if (FORM_ABORT == state || size < 0 || num == 0) {\n    return HTTP_REQUEST_ENTITY_TOO_LARGE;\n}\n...\nelse if (FORM_VALUE == state && pair && offset > 0) {\n    const char *tmp = apr_pmemdup(r->pool, buffer, offset);\n    apr_bucket *b = apr_bucket_pool_create(tmp, offset, r->pool, r->connection->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(pair->value, b);\n}', 'explanation': 'This set of code segments shows an attempt to recover and complete a partially parsed form element before aborting. It reflects the spec’s allowance that a recipient MAY try to recover a usable protocol element even when encountering invalid constructs.'}}]","The function implements logic to interpret an incoming protocol element – in this case, a form submission – by checking the Content-Type and processing the data accordingly. It shows error handling and recovery efforts (e.g. attempting to build up a complete form parameter, then aborting if limits are exceeded) which align with aspects of the RFC specification. However, it does not address all possible aspects stated in the RFC (for example, it does not inspect other headers or determine known incorrect implementations from configuration or experience). Therefore, while parts of the spec constraints (here represented as C1 and A1) are visibly implemented within the function, not all potential conditions or actions are fully addressed within this code alone.",success,
9154,ap_password_validate,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided function, ap_password_validate, implements a caching mechanism for password validation by storing and reusing computed results. However, it does not address the RFC specification regarding caching for HTTP transactions, particularly the aspect that states 'Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.' There is no logic within this function that checks or enforces whether the cache is being used in non-tunnel scenarios. As such, none of the labeled spec constraints (e.g., C1, A1) from the RFC specification are visibly addressed by this function.",success,
9177,mpmt_os2_check_config,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Does Not Match,[],"The RFC specification instructs that a recipient MAY attempt to recover a usable protocol element from an invalid construct, implying error recovery of HTTP protocol elements. The provided function, however, only validates and adjusts server configuration parameters (such as ap_daemons_to_start and ap_min_spare_threads) and logs warnings if they are out of allowed ranges. It does not process, interpret, or recover HTTP protocol elements, nor does it interpret the semantics defined by the RFC for protocol elements. Therefore, in isolation, this function does not implement the RFC’s error recovery requirement for HTTP constructs.",success,
9306,motorz_io_timeout_cb,A client or server that wishes to time out SHOULD issue a graceful close on the connection.,314,Fully Matches,"[{'A1': {'code': 'scon->cs.state = CONN_STATE_LINGER;\n    ap_lingering_close(c);', 'explanation': ""This code sets the connection state to a 'linger' state and calls ap_lingering_close(c) to perform a graceful shutdown of the connection when a timeout occurs. This directly implements the spec's instruction that a client or server wishing to time out SHOULD issue a graceful close on the connection.""}}]","The function motorz_io_timeout_cb acts as a timeout callback that handles a connection timeout by marking the connection state appropriately (CONN_STATE_LINGER) and then calling the ap_lingering_close function. This sequence is a clear and direct implementation of the RFC requirement to perform a graceful close when timing out, thereby fully addressing the spec constraint.",success,
9306,motorz_io_timeout_cb,"A client, server, or proxy MAY close the transport connection at any time.",316,Fully Matches,"[{'A1': {'code': 'scon->cs.state = CONN_STATE_LINGER;\n    ap_lingering_close(c);', 'explanation': ""The function sets the connection's state to CONN_STATE_LINGER and immediately calls ap_lingering_close, which triggers a graceful close on the connection. This directly implements the spec's recommendation that a client or server that times out SHOULD issue a graceful close on the connection.""}}]","The function motorz_io_timeout_cb directly addresses the key spec action by explicitly transitioning the connection into a state for lingering (graceful closure) and then calling the function that handles the graceful close. This single-step logic satisfies the spec requirement that a connection timeout should result in a graceful connection close, allowing system resources to be reclaimed as recommended by the HTTP RFC context.",success,
9316,motorz_io_process,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'if (scon->cs.state == CONN_STATE_KEEPALIVE) {\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(03333)\n                         ""motorz_io_process(): CONN_STATE_KEEPALIVE"");\n    motorz_register_timeout(scon,\n                          motorz_io_timeout_cb,\n                          motorz_get_keep_alive_timeout(scon));\n\n    scon->pfd.reqevents = APR_POLLIN | APR_POLLHUP | APR_POLLERR;\n    scon->cs.sense = CONN_SENSE_DEFAULT;\n\n    rv = apr_pollset_add(mz->pollset, &scon->pfd);\n\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(02850)\n                     ""process_socket: apr_pollset_add failure in read request line"");\n        return rv;\n    }\n}', 'explanation': 'This block implements handling of a persistent connection by setting the keepalive state, registering a timeout, and using the pollset to wait for incoming data. This attempts to sustain persistent connections as recommended by the spec.'}}]","The function implements a state machine that supports persistent connections by entering a keepalive state and scheduling timeouts with pollset integration. This corresponds to sustaining persistent connections under normal conditions. However, while the spec also calls for using underlying transport flow-control mechanisms to manage temporary overloads rather than prematurely terminating connections, such explicit logic is not visibly present in the function. Thus, the code only partially matches the complete intent of the specification.",success,
9316,motorz_io_process,HTTP implementations SHOULD support persistent connections.,311,Partially Matches,[],"The spec requires that HTTP implementations support persistent connections. The function shows logic for handling different connection states including CONN_STATE_KEEPALIVE by re-adding the connection to a pollset and setting a keep-alive timeout, which is an attempt to maintain persistent connections. However, the function does not contain logic to inspect the protocol version or the Connection header field (as mandated by the spec context), and this decision-making likely occurs elsewhere in the system. Therefore, while the function contributes to persistent connection support via its state machine (e.g., transitioning to and handling KEEPALIVE state), it only partially addresses the spec constraints by not fully implementing all aspects required by the RFC within this function alone.",success,
9365,simple_io_process,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'if (scon->cs.state == CONN_STATE_KEEPALIVE) {\n    simple_register_timer(scon->sc,\n                          simple_io_timeout_cb,\n                          scon,\n                          scon->c->base_server != NULL ? scon->c->base_server->timeout : ap_server_conf->timeout,\n                          scon->pool);\n\n    scon->pfd.reqevents = (scon->cs.sense == CONN_SENSE_WANT_WRITE ? APR_POLLOUT : APR_POLLIN);\n    scon->cs.sense = CONN_SENSE_DEFAULT;\n\n    rv = apr_pollcb_add(sc->pollcb, &scon->pfd);\n\n    if (rv) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(00251)\n                     ""process_socket: apr_pollcb_add failure in read request line"");\n        AP_DEBUG_ASSERT(rv == APR_SUCCESS);\n    }\n\n    return APR_SUCCESS;\n}', 'explanation': 'This code branch puts the connection into a KEEPALIVE state when possible, which aligns with the RFC requirement for sustaining persistent connections. The function registers a timer and re-adds the connection to the poll mechanism, helping to keep the connection open for further requests rather than closing it immediately.'}}]","The function implements a state machine that includes a KEEPALIVE state, thereby addressing the portion of the RFC that calls for sustaining persistent connections when possible. However, there is no explicit logic in the function for allowing the underlying transport's flow-control mechanisms to autonomously resolve temporary overload conditions (rather than terminating connections and expecting retries). As such, only part of the specified RFC behavior is visibly implemented within this function.",success,
9425,process_socket,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'if (cs->pub.state == CONN_STATE_KEEPALIVE) {\n    ap_update_child_status(cs->sbh, SERVER_BUSY_KEEPALIVE, NULL);\n    cs->queue_timestamp = apr_time_now();\n    notify_suspend(cs);\n    cs->pub.sense = CONN_SENSE_DEFAULT;\n    update_reqevents_from_sense(cs, CONN_SENSE_WANT_READ);\n    apr_thread_mutex_lock(timeout_mutex);\n    TO_QUEUE_APPEND(cs->sc->ka_q, cs);\n    rv = apr_pollset_add(event_pollset, &cs->pfd);\n    if (rv != APR_SUCCESS && !APR_STATUS_IS_EEXIST(rv)) {\n        AP_DEBUG_ASSERT(0);\n        TO_QUEUE_REMOVE(cs->sc->ka_q, cs);\n        apr_thread_mutex_unlock(timeout_mutex);\n        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, APLOGNO(03093)\n                     ""process_socket: apr_pollset_add failure for keep alive"");\n        close_connection(cs);\n        signal_threads(ST_GRACEFUL);\n    }\n    else {\n        apr_thread_mutex_unlock(timeout_mutex);\n    }\n    return;\n}', 'explanation': 'This code segment checks for the CONN_STATE_KEEPALIVE state and adds the connection to a keep-alive queue, thereby attempting to sustain persistent connections as recommended by the RFC.'}}]","The function implements a state machine to process connections, handling states such as processing, lingering, asynchronous IO, and keepalive. The code segment for CONN_STATE_KEEPALIVE indicates that the function attempts to sustain persistent connections. However, while the RFC also instructs that the server should allow underlying transport flow-control mechanisms to resolve temporary overloads rather than drop connections, there is no explicit logic in this function addressing transport flow-control resolution beyond using pollsets and timeouts. As a result, only part of the spec is visibly implemented in this code function.",success,
9425,process_socket,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (CONN_STATE_IS_LINGERING_CLOSE(cs->pub.state)) {\n    goto lingering_close;\n}\n\n... \nif (rc != OK || (cs->pub.state != CONN_STATE_LINGER\n                     && cs->pub.state != CONN_STATE_ASYNC_WAITIO\n                     && cs->pub.state != CONN_STATE_WRITE_COMPLETION\n                     && cs->pub.state != CONN_STATE_SUSPENDED)) {\n    ap_log_cerror(...);\n    cs->pub.state = CONN_STATE_LINGER;\n}\n\n...\nlingering_close:\n    process_lingering_close(cs);', 'explanation': 'This segment shows that when the connection state indicates a need for closure or an error is encountered, the code transitions to a lingering close state and eventually calls the function to gracefully close the connection. This is an implementation attempt to satisfy the condition that a connection may be closed at any time.'}}, {'A1': {'code': 'close_connection(cs);\n...\nprocess_lingering_close(cs);', 'explanation': 'The function invokes graceful connection shutdown by calling close_connection (on error situations) and process_lingering_close, aligning with the RFC suggestion that a client, server, or proxy may (and sometimes should) issue a graceful close, reclaiming resources.'}}]","The function employs various connection states (e.g. PROCESSING, KEEPALIVE, LINGER) and checks (such as examining if the connection is in a lingering close state or aborted) to decide when to close a connection gracefully. It initiates closure via calls to close_connection and process_lingering_close when appropriate. Although it does not directly monitor for an external 'closure signal' from the other endpoint, the internal state‐based logic shows an attempt to implement the RFC’s allowance for closing the transport connection at any time. Thus, while some aspects are handled within this function, the full spectrum of monitoring for external closure may rely on additional parts of the system, and so this function only partially meets the RFC’s constraints by itself.",success,
9441,process_lingering_close,"A client, server, or proxy MAY close the transport connection at any time.",316,Fully Matches,"[{'C1': {'code': 'if (!APR_STATUS_IS_EAGAIN(rv)) {\n    close_connection(cs);\n    return;\n}', 'explanation': 'This segment checks if the socket read did not return EAGAIN (i.e. no more pending data) and then explicitly closes the connection. This directly implements the idea that a connection (client, server, or proxy) MAY close the transport connection at any time, handling the closure as specified.'}}, {'A1': {'code': 'if (ap_start_lingering_close(cs->c)) {\n    notify_suspend(cs);\n    close_connection(cs);\n    return;\n}\n\n...\n\ndo {\n    nbytes = sizeof(dummybuf);\n    rv = apr_socket_recv(csd, dummybuf, &nbytes);\n} while (rv == APR_SUCCESS);\n\nif (!APR_STATUS_IS_EAGAIN(rv)) {\n    close_connection(cs);\n    return;\n}', 'explanation': 'This code initiates a graceful ‘lingering close’ process. It first attempts a graceful shutdown via ap_start_lingering_close. Then it enters a loop to drain remaining data (if any), and eventually, when no more data can be read, it closes the connection. This behavior aligns with the RFC suggestion for a graceful closure by monitoring and handling a closure signal.'}}]","The function process_lingering_close is self-contained in implementing the gracefull closure of connections. It starts by initiating the lingering close, then monitors for incoming data to ensure that the connection is properly timed out or closed when there is no further activity. These behaviors directly reflect the RFC specification which allows a client, server, or proxy to close the connection at any time and recommends a graceful approach when a timeout occurs.",success,
9441,process_lingering_close,"Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.",315,Fully Matches,"[{'C1': {'code': 'do {\n    nbytes = sizeof(dummybuf);\n    rv = apr_socket_recv(csd, dummybuf, &nbytes);\n} while (rv == APR_SUCCESS);', 'explanation': 'This loop continually attempts to read from the socket, effectively monitoring the connection for any closure signals (or other conditions) as data is received.'}}, {'A1': {'code': 'if (!APR_STATUS_IS_EAGAIN(rv)) {\n    close_connection(cs);\n    return;\n}', 'explanation': 'When a received status is not EAGAIN (indicating a closure signal or error), the code immediately closes the connection, thereby reclaiming system resources as recommended.'}}]",The function 'process_lingering_close' implements the key aspects of the RFC specification by constantly monitoring the connection for a closure signal (as seen in the loop that reads from the socket) and responding immediately by closing the connection (as triggered when the read does not return EAGAIN). This direct intervention to release resources fulfills the essential conditions and actions defined in the spec.,success,
9441,process_lingering_close,A client or server that wishes to time out SHOULD issue a graceful close on the connection.,314,Fully Matches,"[{'C1': {'code': 'do {\n    nbytes = sizeof(dummybuf);\n    rv = apr_socket_recv(csd, dummybuf, &nbytes);\n} while (rv == APR_SUCCESS);\n\nif (!APR_STATUS_IS_EAGAIN(rv)) {\n    close_connection(cs);\n    return;\n}', 'explanation': 'This segment continuously monitors the connection by reading data until it stops receiving valid data (i.e. a closure signal is detected) and then, if the error is not a recoverable EAGAIN, proceeds to close the connection gracefully.'}}, {'A1': {'code': 'if (ap_start_lingering_close(cs->c)) {\n    notify_suspend(cs);\n    close_connection(cs);\n    return;\n}', 'explanation': 'Here the function checks if a lingering (graceful) close should begin. If so, it suspends further processing and calls close_connection(), thereby issuing a graceful close as recommended by the RFC.'}}]","The function process_lingering_close directly attempts to address the RFC requirement that a client or server wishing to time out should issue a graceful close. It does so by monitoring the connection for closure signals using a loop that reads from the socket (addressing condition C1), and by initiating a graceful close when appropriate (action A1). All the necessary logic to handle a graceful close is contained within the function, fulfilling the spec constraints.",success,
9444,listener_thread,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Does Not Match,[],"The provided function is an event listener that manages socket polling, worker assignment, and connection state transitions; however, no part of the function clearly implements the RFC requirement to sustain persistent connections by allowing transport-level flow-control mechanisms to resolve temporary overloads. Instead, in cases such as when no idle worker is immediately available (as seen in the keepalive connection handling), the code chooses to close the connection. This behavior does not align with the spec’s guidance to avoid terminating connections under temporary overload conditions, and no visible logic in the function directly addresses this aspect of the specification.",success,
9444,listener_thread,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (listener_may_exit) {\n    int first_close = close_listeners(&closed);\n\n    if (terminate_mode == ST_UNGRACEFUL\n        || apr_atomic_read32(&connection_count) == 0)\n        break;\n\n    /* ... later in the loop ... */\n}', 'explanation': 'This segment shows that when a shutdown is signaled (listener_may_exit true), the listener proactively closes its listening sockets by calling close_listeners, which is indicative of the server’s willingness to close the transport (i.e. a connection) as allowed by the RFC.'}}, {'A1': {'code': 'if (!have_idle_worker) {\n    shutdown_connection(cs);\n}\n...', 'explanation': 'When no idle worker is available to handle a connection (for example in the keepalive or lingering close case), the function calls shutdown_connection(cs) to close the transport connection. This implements an action toward a graceful closure of a connection.'}}]","The code function implements parts of the RFC by monitoring for shutdown signals and by closing connections when conditions require it. Specifically, it checks for a shutdown signal via listener_may_exit and closes listening sockets, and it calls shutdown_connection when a connection cannot be handled by an idle worker. However, while these code segments address certain aspects of the RFC's guidance for connection closure, not all possible conditions (for example, handling a connection where a new request is in progress) are directly addressed in this function. Therefore, the implementation in this function partially matches the spec constraints.",success,
9584,apache2_args,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC specification requires that a sender must not generate protocol elements that do not conform to the grammar defined by the corresponding ABNF rules. In the provided function, there is no logic that validates or enforces that the query string or any generated protocol element adheres to such grammar. The function simply parses a query string (if present) and returns a table of arguments, without any checks or mechanisms to verify grammar compliance. Therefore, none of the labeled conditions (e.g., C1) or actions (e.g., A1) regarding the conformance to the ABNF rules are implemented within this function.",success,
9584,apache2_args,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'apache2_args' is solely concerned with parsing the query string from the request and managing its internal state based on the presence of arguments. There is no logic in this function that implements or enforces the RFC requirement that a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed for other roles. No code segment is seen that checks or restricts the generation of protocol elements based on the sender's role, so it does not visibly address any labeled condition or action from the spec constraints.",success,
9619,apreq_filter_init_context,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function sets up context for parsing request bodies (e.g., by checking the HTTP method, Content-Length, and Content-Type headers) and configuring a parser. However, it does not implement logic that ensures a sender does not generate protocol elements or syntax alternatives that are reserved for other roles, as specified by the RFC. None of the code segments address or enforce the restriction that a sender must not generate protocol elements reserved to other roles. Thus, in isolation, the function does not visibly address any of the labeled spec constraints.",success,
9619,apreq_filter_init_context,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'cl_header = apr_table_get(r->headers_in, ""Content-Length"");\nif (cl_header != NULL) {\n    apr_off_t cl;\n\n    if (!ap_parse_strict_length(&cl, cl_header)) {\n        ap_log_rerror(..., ""Invalid Content-Length header (%s)"", cl_header);\n        ctx->body_status = APREQ_ERROR_BADHEADER;\n        return;\n    }\n    ...\n}', 'explanation': 'The function defensively retrieves and strictly parses the Content-Length header to ensure it conforms to expected grammar, addressing the RFC requirement to not assume perfect conformance of the protocol element.'}}, {'A1': {'code': 'if ((apr_uint64_t)cl > ctx->read_limit) {\n    ap_log_rerror(..., ""Content-Length header (%s) exceeds configured max_body limit (%"" APR_UINT64_T_FMT "")"",\n                  cl_header, ctx->read_limit);\n    ctx->body_status = APREQ_ERROR_OVERLIMIT;\n    return;\n}', 'explanation': ""This code block enforces a reasonable maximum size (read_limit) for the Content-Length, which is a defensive measure to avoid processing oversized inputs, aligning with the RFC's emphasis on reasonable buffer sizes.""}}]","The function implements several defensive measures by verifying the structure and value of the Content-Length header through strict parsing and limiting its size, which directly addresses part of the HTTP RFC requirement for defensive parsing of protocol elements. However, while these measures are present, the function does not encompass every potential defensive action the RFC might imply (for example, handling all protocol elements or varying limits based on deployment context), so it only partially matches the complete spec requirements.",success,
9619,apreq_filter_init_context,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'cl_header = apr_table_get(r->headers_in, ""Content-Length"");\nif (cl_header != NULL) {\n    apr_off_t cl;\n    if (!ap_parse_strict_length(&cl, cl_header)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, r, APLOGNO(02045)\n                      ""Invalid Content-Length header (%s)"", cl_header);\n        ctx->body_status = APREQ_ERROR_BADHEADER;\n        return;\n    }\n    if ((apr_uint64_t)cl > ctx->read_limit) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EGENERAL, r, APLOGNO(02046)\n                      ""Content-Length header (%s) exceeds configured max_body limit (%"" APR_UINT64_T_FMT "")"",\n                      cl_header, ctx->read_limit);\n        ctx->body_status = APREQ_ERROR_OVERLIMIT;\n        return;\n    }\n}', 'explanation': 'This segment retrieves and validates the Content-Length header, ensuring that the header value is both correctly formed and within the accepted limit. This reflects the RFC mandate to interpret received protocol elements according to defined semantics by rejecting invalid or out-of-limit values.'}}, {'A1': {'code': 'const char *ct_header = apr_table_get(r->headers_in, ""Content-Type"");\nif (ct_header != NULL) {\n    apreq_parser_function_t pf = apreq_parser(ct_header);\n    if (pf != NULL) {\n        ctx->parser = apreq_parser_make(r->pool, ba, ct_header, pf,\n                                        ctx->brigade_limit,\n                                        ctx->temp_dir,\n                                        ctx->hook_queue,\n                                        NULL);\n    }\n    else {\n        ctx->body_status = APREQ_ERROR_NOPARSER;\n        return;\n    }\n}\nelse {\n    ctx->body_status = APREQ_ERROR_NOHEADER;\n    return;\n}', 'explanation': 'This part examines the Content-Type header and selects the appropriate parser based on its value. By doing so, the function assigns semantics to the incoming protocol element in accordance with the RFC, which requires interpretation based on protocol definitions and supported extensions.'}}]","The function partially implements the HTTP RFC requirement by inspecting and interpreting key headers such as Content-Length and Content-Type. It validates these headers strictly and returns error statuses when the headers are malformed or exceed configured limits. However, while these code segments reflect an attempt to apply the RFC’s semantics to received elements, the implementation does not cover the entire scope of the specification (e.g., broader error recovery or handling extensions comprehensively) solely within this function. Therefore, the function only partially matches the specified conditions and actions.",success,
9628,is_scriptaliased,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The function 'is_scriptaliased' only checks whether a note 'alias-forced-type' equals 'cgi-script'. There is no logic within this function that handles or references context information related to the Content-Location header or any request semantics, as specified in the RFC. Therefore, it does not address any of the labeled conditions or actions derived from the RFC specification regarding not altering request semantics with this context information.",success,
9650,log_script,"Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",308,Does Not Match,[],"The provided function is solely a logging routine that records CGI script output, request, and response headers. It does not contain any logic related to checking for or handling parameters named ""q"" in transfer codings, nor does it validate or enforce any rules related to HTTP RFC specifications about transfer codings. As such, none of the spec constraints (e.g., avoiding the use of a parameter named 'q') are addressed by this function.",success,
9656,include_cgi,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function 'include_cgi' does not contain any logic that addresses the RFC specification regarding header fields with identical names or the requirement to preserve their order. The code solely focuses on handling a CGI subrequest, processing a Location header if a redirect is detected, and escaping HTML for inclusion in a bucket brigade. It does not implement any checks or mechanisms to prohibit generating multiple field lines with the same name or to preserve their order, which are the core aspects of the RFC specification described.",success,
9656,include_cgi,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Does Not Match,[],"The RFC requires that the server generate a Location header field in the HTTP response when performing a redirection. In the function_body, instead of adding a Location header to the response, the code merely checks if the subrequest resulted in an HTTP redirect and then, if a Location value is found, it escapes it and outputs an HTML hyperlink into the response body. This approach does not implement the action of generating a Location header field as mandated by the spec, and hence no labeled condition or action (e.g., C1 or A1) is fully met within this function.",success,
9656,include_cgi,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Partially Matches,"[{'A1': {'code': 'if (ap_is_HTTP_REDIRECT(rr_status)) {\n    const char *location = apr_table_get(rr->headers_out, ""Location"");\n\n    if (location) {\n        char *buffer;\n\n        location = ap_escape_html(rr->pool, location);\n        buffer = apr_pstrcat(ctx->pool, ""<a href=\\"""", location, ""\\"">"",\n                             location, ""</a>"", NULL);\n\n        APR_BRIGADE_INSERT_TAIL(bb, apr_bucket_pool_create(buffer,\n                                strlen(buffer), ctx->pool,\n                                f->c->bucket_alloc));\n    }\n}', 'explanation': ""The function detects an HTTP redirect from the sub-request, retrieves the 'Location' header, escapes it, and creates an HTML hyperlink, which corresponds to the spec's suggestion for including a hypertext note with a hyperlink in the response content.""}}]","The RFC requires that the server SHOULD generate a Location header field in the response with a URI reference; however, this function does not add such a header to the response. It only uses the Location header obtained from the sub-request to create an HTML anchor tag in the response body. Thus, while it implements the inclusion of a hyperlink note (A1), it does not implement the generation of a Location header field (C1), leading to a partial match of the specification.",success,
9664,is_scriptaliased,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function 'is_scriptaliased' only checks whether the 'alias-forced-type' note in the request equals 'cgi-script'. It does not interact with or process the Content-Location header or any context information as described in the RFC specification, which states that an origin server MUST NOT use such context information to alter the request semantics. Therefore, no part of the provided code function addresses the spec constraint.",success,
9672,get_req,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'get_req' is focused on reading and validating a request header and its associated parameters. It performs sanity checks such as ensuring non-zero lengths and limits on various fields, but there is no code that verifies or restricts the generation of protocol elements based on the sender's role. In other words, it does not implement any logic that prevents the sender from generating protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. Therefore, this function does not address the specific RFC requirement stated in the spec.",success,
9673,send_req,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. In the provided function_body, while the code assembles and sends request header information and environment variables, there is no logic that checks or validates the sender's role, nor is there any mechanism in place to prevent the generation of protocol elements that are reserved for other roles. This lack of role verification or filtering logic means that none of the spec constraints (e.g., C1, A1, etc.) are clearly implemented within this function.",success,
9673,send_req,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function prepares and sends a request header and environment variables without any explicit mechanism to verify or enforce that the resulting protocol elements conform to the ABNF grammar defined in the RFC. There is no visible logic within the function that validates the syntactic correctness or checks against specific ABNF rules (e.g., rule checks, format validations) as required by the constraint. Hence, the function does not implement the spec constraint that a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.",success,
9689,connect_to_daemon,"A client, server, or proxy MAY close the transport connection at any time.",316,Does Not Match,[],"The provided function is focused on establishing a connection to the CGI daemon and retrying upon failures rather than implementing any logic pertaining to closing an established connection gracefully or in response to a closure signal. Although the function does close sockets when connection attempts fail (using close(sd) and registering cleanup via apr_pool_cleanup_register), it does not include any logic that monitors for a closure signal or initiates a graceful connection shutdown in line with the spec context (e.g., closing the transport connection on timeouts or upon receiving a signal). Thus, none of the spec conditions or actions (like those hypothetically labeled C1, A1, etc.) regarding connection closure are directly implemented in this function.",success,
9695,include_cgi,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Partially Matches,"[{'A1': {'code': 'if (ap_is_HTTP_REDIRECT(rr_status)) {\n    const char *location = apr_table_get(rr->headers_out, ""Location"");\n\n    if (location) {\n        char *buffer;\n\n        location = ap_escape_html(rr->pool, location);\n        buffer = apr_pstrcat(ctx->pool, ""<a href=\\"""", location, ""\\"">"", location, ""</a>"", NULL);\n\n        APR_BRIGADE_INSERT_TAIL(bb, apr_bucket_pool_create(buffer, strlen(buffer), ctx->pool, f->c->bucket_alloc));\n    }\n}', 'explanation': ""This segment checks if the sub-request returned a redirection, retrieves the 'Location' header, escapes it for HTML safety, and generates an HTML hyperlink. This corresponds to the spec's note that the response content usually contains a hypertext link to the different URI. However, no code in this function generates a Location header field in the HTTP response itself.""}}]","The provided function inspects the sub-request's status and, when a redirect is detected, retrieves the Location header from the sub-request's headers and uses it to generate an HTML anchor element. This meets the part of the RFC that states the response content should include a hyperlink, but it does not implement the requirement to generate a Location header field in the HTTP response. Therefore, only part of the spec constraint is handled within this function.",success,
9709,emit_preamble,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function emits HTML preamble content based solely on parameters (such as XHTML flag and title) and configuration data (like stylesheet and head insertion). There is no logic in the function that checks or ensures that the generated protocol elements match the grammar defined by the ABNF rules, which is the core requirement posed by the RFC specification. In other words, the function does not implement any of the spec constraints (labeled as C1, A1, etc.) with respect to the protocol grammar, as its sole responsibility is generating HTML output without validating it against the ABNF.",success,
9709,emit_preamble,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'emit_preamble' simply emits an HTML preamble based on the XHTML flag and configuration settings. It does not include any logic to ensure that the sender only generates protocol elements that it is allowed to generate according to the RFC requirement. There is no role verification or restriction mechanism present in this function, and therefore it does not address the specified constraint.",success,
9724,emit_head,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],The provided function focuses on generating and emitting an HTML header page (including handling subrequests and file output) and on temporarily modifying request header values for Accept and Accept-Encoding. It does not contain any logic that enforces or considers the RFC requirement of preventing multiple header field lines with the same name or preserving the order of header fields as specified. None of the code addresses the condition that a sender must not generate or append duplicate header fields unless allowed by the respective field's definition.,success,
9724,emit_head,"Note that the coding named ""identity"" is reserved for its special role in Accept-Encoding and thus SHOULD NOT be included.",38,Does Not Match,[],"The provided function does not implement any logic that addresses the RFC requirements regarding Content-Encoding (e.g., applying and ordering content encodings such as gzip, nor excluding the 'identity' coding). The function primarily manages Accept and Accept-Encoding headers during header file processing for autoindexing, and does not process Content-Encoding headers as required by the specification.",success,
9726,find_title,A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.,173,Partially Matches,"[{'A1': {'code': ""for (y = x; titlebuf[y]; y++) {\n    if ((titlebuf[y] == CR) || (titlebuf[y] == LF)) {\n        if (y == x) {\n            x++;\n        } else {\n            titlebuf[y] = ' ';\n        }\n    }\n}"", 'explanation': 'This loop scans the extracted title content and replaces any occurrence of a CR (or LF) with a space. This is an attempt to address the action requiring that each bare CR be replaced with SP. However, the code does not distinguish between a bare CR and a CR that is part of a CRLF sequence, and it also replaces LF characters, so it only partially matches the RFC constraint.'}}]","The function 'find_title' reads a segment of the file and, after locating the <title> element, it iterates over its characters to replace any line break characters (CR or LF) with a space. This partially implements the RFC requirement which states that a bare CR should be considered invalid or replaced with a space before further processing. Since the implementation does not verify whether a CR is 'bare' or part of a proper CRLF sequence and also applies the replacement to LF characters, the function only partially meets the specified constraint.",success,
9726,find_title,"Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message.",3,Partially Matches,"[{'C1': {'code': ""for (y = x; titlebuf[y]; y++) {\n    if ((titlebuf[y] == CR) || (titlebuf[y] == LF)) {\n        if (y == x) {\n            x++;\n        } else {\n            titlebuf[y] = ' ';\n        }\n    }\n}"", 'explanation': 'This loop scans the titlebuf after detecting the <title> tag. When a CR or LF is encountered, it is replaced by a space (SP), which is an attempt to meet the requirement that field values containing these characters be replaced with SP. However, there is no explicit handling for NUL characters.'}}]","The RFC specification mandates that field values containing CR, LF, or NUL characters be either rejected or have those characters replaced with SP. The function 'find_title' partially implements this by scanning for CR and LF characters and replacing them with spaces, thereby addressing part of the requirement (condition C1). However, it does not explicitly address NUL characters since they are implicitly handled as string terminators in C. Therefore, the implementation is only a partial match to the RFC specification's mandate.",success,
9733,index_directory,"If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type.",35,Fully Matches,"[{'A1': {'code': 'if (*charset) {\n    ap_set_content_type_ex(r, apr_pstrcat(r->pool, ctype, "";charset="", charset, NULL), 1);\n} else {\n    ap_set_content_type_ex(r, ctype, 1);\n}', 'explanation': 'The RFC requires that a sender that generates a message should include a Content-Type header. This code always sets a Content-Type header—using a configured type if available or defaulting to ""text/html""—thus fulfilling the requirement. The RFC also states that if a header is absent, recipients may assume a default (application/octet-stream) or inspect the data, but since this is sender behavior, always setting the header adheres to the recommendation.'}}]","The function explicitly sets the Content-Type header by calling ap_set_content_type_ex with an appropriate media type and charset. This directly addresses the RFC's recommendation that a message should include a Content-Type header, thereby ensuring that the sender provides the header rather than expecting the recipient to perform a fallback. All logic relevant to the RFC's requirements is contained within the function.",success,
9733,index_directory,"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.",52,Fully Matches,"[{'A1': {'code': 'if (autoindex_opts & TRACK_MODIFIED) {\n    ap_update_mtime(r, r->finfo.mtime);\n    ap_set_last_modified(r);\n    ap_set_etag(r);\n}', 'explanation': 'This block of code checks if the TRACK_MODIFIED option is set, and if so, it updates the modification time and explicitly calls ap_set_last_modified(r) to send the Last-Modified header, thus fulfilling the RFC requirement that an origin server SHOULD send a Last-Modified header for a representation with a determinable last modification date.'}}]","The provided function clearly includes logic to send the Last-Modified header when applicable. The check 'if (autoindex_opts & TRACK_MODIFIED)' and subsequent call to ap_set_last_modified(r) directly address the RFC's stipulation regarding the inclusion of a Last-Modified header, thereby fully matching the specified constraint.",success,
9733,index_directory,"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.",57,Partially Matches,"[{'A1': {'code': 'if (autoindex_opts & TRACK_MODIFIED) {\n    ap_update_mtime(r, r->finfo.mtime);\n    ap_set_last_modified(r);\n    ap_set_etag(r);\n}', 'explanation': ""This block of code conditionally sets the ETag header (as well as updating the modification time and last modified) when the TRACK_MODIFIED option is enabled. It addresses the RFC's recommendation to send an ETag for a selected representation, but only when changes are being tracked.""}}]","The RFC specifies that an origin server SHOULD send an ETag for a selected representation to facilitate caching and change detection. In this function, the ETag is set via the call to ap_set_etag(r) inside a conditional block that checks if the autoindex_opts has the TRACK_MODIFIED flag enabled. This means that the function only sets the ETag under certain conditions rather than unconditionally for every representation. Therefore, while it does attempt to implement the RFC behavior, it only partially meets the requirement because it relies on a configuration flag to trigger ETag generation.",success,
9733,index_directory,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'if (*charset) {\n        ap_set_content_type_ex(r, apr_pstrcat(r->pool, ctype, "";charset="", charset, NULL), 1);\n    } else {\n        ap_set_content_type_ex(r, ctype, 1);\n    }', 'explanation': ""This code unconditionally sets the Content-Type header by invoking ap_set_content_type_ex. It uses a default value ('text/html') or a configured one (autoindex_conf->ctype) and appends a charset if available, fulfilling the RFC requirement to generate a Content-Type header when content is present.""}}]","The function_body includes logic that directly generates a Content-Type header field for the message. By checking the charset and ctype values—defaulting to 'text/html' when none is provided—it ensures that content responses have the appropriate Content-Type header, which complies with the specified RFC requirement.",success,
9733,index_directory,"In 200 responses to GET or HEAD, an origin server SHOULD send any available validator fields (Section 8.8) for the selected representation, with both a strong entity tag and a Last-Modified date being preferred.",141,Partially Matches,"[{'A1': {'code': 'if (autoindex_opts & TRACK_MODIFIED) {\n    ap_update_mtime(r, r->finfo.mtime);\n    ap_set_last_modified(r);\n    ap_set_etag(r);\n}', 'explanation': 'This block sets the validator fields (Last-Modified and ETag) when the TRACK_MODIFIED option is enabled. It addresses the RFC’s recommendation to send available validator fields with a strong entity tag and Last-Modified date; however, it does so conditionally and only within the TRACK_MODIFIED branch, rather than unconditionally for all 200 responses to GET or HEAD.'}}]","The function includes code that attempts to implement part of the HTTP RFC requirement by setting validator fields (Last-Modified and ETag) when the TRACK_MODIFIED option is active. This corresponds to the action of sending validator fields in 200 responses. However, the implementation is conditional and does not explicitly verify the request method (GET or HEAD) nor ensure that both fields are always set, which is why it is judged as partially matching the spec constraints.",success,
9733,index_directory,The type/subtype MAY be followed by semicolon-delimited parameters (Section 5.6.6) in the form of name/value pairs.,259,Partially Matches,"[{'A1': {'code': 'if (*charset) {\n    ap_set_content_type_ex(r, apr_pstrcat(r->pool, ctype, "";charset="", charset, NULL), 1);\n}\nelse {\n    ap_set_content_type_ex(r, ctype, 1);\n}', 'explanation': 'This code constructs the Content-Type header by appending the "";charset="" parameter if a charset is provided. This addresses the spec requirement that the media type may be followed by semicolon-delimited parameters (e.g., charset).'}}]","The RFC specifies that the type/subtype MAY be followed by semicolon-delimited parameters in the form of name/value pairs. In this function, the only visible implementation related to that is the construction of the Content-Type header by appending a "";charset="" parameter when a charset is provided. Although the function does implement this specific parameter formatting, it does not appear to handle any other name/value pairs, so the implementation only partially covers the overall RFC specification within this function.",success,
9734,handle_autoindex,"An origin server that wishes to ""hide"" the current existence of a forbidden target resource MAY instead respond with a status code of 404 (Not Found).",163,Fully Matches,"[{'A1': {'code': 'return d->not_found ? HTTP_NOT_FOUND : HTTP_FORBIDDEN;', 'explanation': 'This code directly implements the RFC instruction that an origin server wishing to hide the existence of a forbidden resource may respond with a 404 (Not Found) status. When the configuration (d->not_found) is set, instead of returning HTTP_FORBIDDEN, it returns HTTP_NOT_FOUND, thereby hiding the resource.'}}]","The function 'handle_autoindex' checks the provided options for serving a directory index. In situations where directory indexing is not permitted, it returns either HTTP_FORBIDDEN or, if the configuration flag 'not_found' is enabled, HTTP_NOT_FOUND. This behavior visibly addresses the RFC specification allowing the server to hide the existence of a forbidden resource by returning a 404 status code. Thus, the function fully meets the relevant spec constraint as implemented in its own logic.",success,
9760,display_info,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function 'display_info' is focused on displaying server-related information in HTML and does not include any logic that addresses the RFC specification regarding the handling of the Content-Location header in request messages. Specifically, the RFC constraint stating that an origin server must not use context information (such as Content-Location) to alter the request semantics is not reflected anywhere in the code. There is no evidence in the function_body of any processing logic related to request context or handling of such HTTP headers. As a result, none of the labeled conditions (e.g., C1) or actions (e.g., A1) are implemented within this function.",success,
9760,display_info,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'ap_set_content_type_ex(r, ""text/html; charset=ISO-8859-1"", 1);', 'explanation': 'This call explicitly sets the Content-Type header field for the generated HTML content. Since the RFC requires that a sender of a message containing content SHOULD generate a Content-Type header field (when the intended media type is known), this implementation satisfies that requirement within the function.'}}]","The function 'display_info' generates an HTML response and directly sets the Content-Type header via the call to 'ap_set_content_type_ex'. This directly implements the RFC specification that a Content-Type header field should be generated when content is produced. Although the charset specified (ISO-8859-1) differs from the one mentioned in the spec context (ISO-8859-4), the fundamental requirement—to include a Content-Type header—is fully addressed within this function.",success,
9760,display_info,"If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type.",35,Does Not Match,[],"The RFC specifies that if the Content-Type header is not present then the recipient may assume a media type of 'application/octet-stream' or try to deduce the type from the content. In contrast, this function unconditionally sets the Content-Type header to 'text/html; charset=ISO-8859-1' (line with ap_set_content_type_ex) without checking whether the header is already present or applying any fallback logic. Thus, this function does not visibly address the condition described in the RFC.",success,
9771,status_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'ap_set_content_type_ex(r, ""text/html; charset=ISO-8859-1"", 1);', 'explanation': 'The function explicitly sets the Content-Type header on the response by calling ap_set_content_type_ex. This satisfies the RFC requirement that a sender generating a message containing content should include a Content-Type header field. In addition, when the ?auto option is provided, it even adjusts the type to ""text/plain; charset=ISO-8859-1"".'}}]","The status_handler function generates an HTTP response with content and directly sets its Content-Type header field by calling ap_set_content_type_ex. This action directly addresses the RFC specification that a sender that generates a message with content SHOULD include a Content-Type header field, provided the media type is known. Hence, the function fully meets the required labeled action (A1) within its own logic.",success,
9883,select_application_protocol,"A server MAY choose to ignore the order of preference indicated by the client and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.",258,Partially Matches,"[{'C1': {'code': 'if (cc->alpn && cc->alpn->nelts > 0) {\n    proposed = ap_select_protocol(c, NULL, s, cc->alpn);\n    if (!proposed) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE2, rv, c, ""ALPN: no protocol selected in server"");\n        goto cleanup;\n    }', 'explanation': 'This code block checks if the client provided ALPN protocol proposals and then selects a protocol. It partially addresses the RFC requirement of considering client offered protocols, even though the details of ignoring their order are delegated to ap_select_protocol.'}}, {'A1': {'code': 'if (strcmp(proposed, cc->application_protocol)) {\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE2, rv, c,\n        ""ALPN: switching protocol from `%s` to `%s`"", cc->application_protocol, proposed);\n    rv = ap_switch_protocol(c, NULL, cc->server, proposed);\n    if (APR_SUCCESS != rv) goto cleanup;\n}', 'explanation': 'This segment implements the action of switching protocols when the selected protocol differs from the current one by invoking ap_switch_protocol, which is in line with the RFC’s protocol switching mechanism.'}}]","The function attempts to implement the RFC by handling ALPN negotiation and protocol switching. It checks for client proposals and, if a different protocol is selected, initiates a switch. However, finer points of the RFC—such as explicitly ignoring the client’s order of preference or constructing the Upgrade header with the required ordering—are either abstracted into helper functions (like ap_select_protocol) or left to other parts of the system. Thus, while the function addresses some core aspects (as seen in C1 and A1), it does not fully implement all the specified requirements within its own logic.",success,
9898,filter_abort,"Servers MAY close the connection after sending the closure alert, thus generating an incomplete close on the client side.",326,Fully Matches,"[{'A1': {'code': 'rustls_connection_send_close_notify(fctx->cc->rustls_connection);', 'explanation': 'This call sends a close_notify alert, fulfilling the RFC requirement for the server to attempt an exchange of closure alerts with the client before closing the connection.'}}, {'C1': {'code': 'if (fctx->cc->state != TLS_CONN_ST_DONE) { ... fctx->c->aborted = 1; fctx->cc->state = TLS_CONN_ST_DONE; }', 'explanation': 'By marking the connection as done (aborted) after sending the closure alert, the function implements the RFC guidance that servers may close the connection after sending the closure alert, even if it results in an incomplete close on the client side.'}}]","The function 'filter_abort' inspects the connection state and, if appropriate (i.e., when the state exceeds TLS_CONN_ST_CLIENT_HELLO), it calls the function to send the closure alert (rustls_connection_send_close_notify) followed by flushing the output and marking the connection as aborted. These steps together implement the RFC's requirements: initiating an exchange of closure alerts and then closing the connection, which matches the spec conditions.",success,
9898,filter_abort,Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection.,325,Fully Matches,"[{'C1': {'code': 'if (fctx->cc->state != TLS_CONN_ST_DONE) {', 'explanation': 'This check ensures that the connection is still active and not already closed. It satisfies the precondition for initiating a TLS closure alert exchange.'}}, {'A1': {'code': 'rustls_connection_send_close_notify(fctx->cc->rustls_connection);', 'explanation': 'This call explicitly sends the TLS close notify alert to the client, fulfilling the requirement that servers must attempt to initiate an exchange of closure alerts before closing the connection.'}}]","The function checks that the connection has not already been closed (C1) and, if the connection state is appropriate, it sends a close notification (A1) to initiate the exchange of closure alerts per the RFC specification. This logic is contained entirely within the function and directly implements the RFC requirement.",success,
9911,fout_add_bucket_to_tls,Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection.,325,Fully Matches,"[{'A1': {'code': 'if (AP_BUCKET_IS_EOC(b)) {\n    rustls_connection_send_close_notify(fctx->cc->rustls_connection);\n    fctx->cc->state = TLS_CONN_ST_NOTIFIED;\n    rv = fout_pass_rustls_to_tls(fctx);\n    if (APR_SUCCESS != rv) goto cleanup;\n}', 'explanation': 'This block checks if the bucket is an end-of-connection indicator and then calls rustls_connection_send_close_notify to initiate the exchange of closure alerts, thereby fulfilling the specification requirement that the server must attempt to initiate an exchange of closure alerts with the client before closing the connection.'}}]","The function explicitly checks for the end-of-connection condition and then sends a close notify message (using rustls_connection_send_close_notify), which is the core action required by the spec. No additional logic is needed in this function to address other aspects of the closure exchange, so it fully matches the provided specification constraint.",success,
9931,cache_init,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided RFC specification deals with HTTP caching behavior (a cache may be used by a client or server but not while acting as a tunnel), which is distinct from the TLS session cache mechanism being initialized in this function. The function 'cache_init' largely focuses on setting up and configuring a TLS session cache and does not include any logic that verifies or ensures that caches are not used in tunnel scenarios, nor does it relate to the HTTP request/response caching behavior described in the spec. Therefore, no part of the code function can be said to implement any of the labeled constraints derived from the RFC.",success,
9933,tls_cache_post_config,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The RFC spec states that any client or server MAY use a cache, but it cannot be used while acting as a tunnel. The provided function, tls_cache_post_config, only handles the initialization of a TLS session cache (logging initialization status and calling the provider's init method) without any logic to check whether the process is acting as a tunnel or to prevent cache use in that scenario. Thus, no part of this function specifically implements the constraints as stated in the RFC.",success,
9938,tls_cache_get,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided function implements a cache retrieval for TLS sessions by looking up and optionally removing a cached session, but it does not address the key aspect of the HTTP RFC which specifies that a cache cannot be used while acting as a tunnel. There is no logic in the function that detects or forbids cache usage when operating as a tunnel. Thus, while the function uses caching, it does not implement or enforce the RFC constraint regarding tunnel behavior, meaning none of the labeled constraints (e.g., C1, A1) from the RFC spec are fully met in this function.",success,
9939,tls_cache_put,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'if (!sc->global->session_cache) goto not_stored;\n...\nrv = sc->global->session_cache_provider->store(sc->global->session_cache, cc->server,\n                                                   kdata, klen, expires_at,\n                                                   (unsigned char*)val->data, vlen, c->pool);', 'explanation': ""The code checks for the existence of a global session cache and then attempts to store TLS session data in it. This indicates that caching is being employed as allowed by the RFC ('MAY employ a cache'). However, there is no logic to ensure that a cache is not used when acting as a tunnel, which is part of the specification.""}}]","The function implements a caching mechanism by checking for a global cache and storing TLS session data, thus addressing the part of the spec that permits caching. However, it does not implement any logic to prevent the cache from being used while acting as a tunnel. As a result, the function only partially matches the spec constraints.",success,
9968,tls_util_brigade_split_line,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, tls_util_brigade_split_line, is solely concerned with processing and cleaning up a brigade, specifically by splitting a brigade into a line and removing a zero‐length bucket. There is no visible logic in the function that checks or restricts the generation of protocol elements according to role-based rules as required by the RFC spec. The function does not implement any checks against generating protocol elements or syntax alternatives reserved for other roles, and therefore does not address any of the labeled conditions or actions (e.g., C1, A1) mentioned in the spec.",success,
10124,bucketeer_out_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'apr_table_unset(f->r->headers_out, ""Content-Length"");', 'explanation': 'The function removes the Content-Length header from the outgoing message, which is an attempt to prevent forwarding an incorrect Content-Length value. This reflects an action intended to comply with the RFC’s requirement not to forward messages with a known incorrect Content-Length header.'}}]","The RFC specifies that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect. In this code, for text responses, the header is unconditionally unset (removed) when the filter is first applied. This is an attempt to comply with the requirement by ensuring that potentially incorrect Content-Length values are not forwarded. However, the code does not actually validate or check if the Content-Length is incorrect, nor does it handle the exception for duplicate decimal values. Therefore, only part of the RFC requirement is addressed directly in this function.",success,
10124,bucketeer_out_filter,"Likewise, a sender MUST NOT forward a message with a Content-Length header field value that does not match the ABNF above, with one exception: a recipient of a Content-Length header field value consisting of the same decimal value repeated as a comma-separated list (e.g, ""Content-Length: 42, 42"") MAY either reject the message as invalid or replace that invalid field value with a single instance of the decimal value, since this likely indicates that a duplicate was generated or combined by an upstream message processor.",49,Does Not Match,[],"The provided function does not implement any logic that verifies the Content-Length header field value against the ABNF specification or checks for repeated decimal values as described in the RFC requirement. While it does remove the Content-Length header (using apr_table_unset) when filtering based on text content, this is only part of typical output filter processing and is not an implementation of the RFC constraint (e.g., validating or replacing duplicate values). Thus, the function does not visibly address any of the labeled conditions or actions from the spec constraints.",success,
10128,pumpit_cleanup,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'hdr_len = apr_snprintf(header, sizeof(header), HEADER_FMT, (apr_uint64_t) 0, (apr_uint64_t) apr_time_now(), ctx->direction, ctx->uuid, ctx->count);\nap_xlate_proto_to_ascii(header, hdr_len);', 'explanation': 'The function builds a header using a fixed format (HEADER_FMT) and then converts it to plain ASCII via ap_xlate_proto_to_ascii. This indicates an intent to generate a protocol element within a defined structure (possibly conforming to ABNF), thus partially addressing the RFC requirement. However, no explicit check or validation is performed to verify that the generated header fully complies with the ABNF grammar.'}}]","The RFC requires senders to generate protocol elements that exactly match the grammar. In the code, while a header is constructed using a fixed format and then translated to ASCII (which suggests an effort to produce a correctly formatted header), there is no explicit mechanism to validate the header against the corresponding ABNF rules. Therefore, within the boundaries of this function, the RFC’s constraints are only partially addressed.",success,
10128,pumpit_cleanup,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that within a given message, a sender must not generate protocol elements or syntax alternatives that are only allowed for participants in other roles. In the function pumpit_cleanup, the logic is solely focused on formatting and writing a header message and does not include any logic to validate or restrict protocol elements based on sender roles. There is no code that checks whether the sender is generating elements that are disallowed according to its role. Consequently, none of the spec constraints (e.g., C1 regarding role-based generation of protocol elements) or corresponding actions (e.g., A1) are implemented in this function.",success,
10129,pumpit,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function mainly handles reading data from a bucket, formatting a header using a fixed format (HEADER_FMT), and writing the data out with a chunk header and CRLF. There is no explicit logic within the function that checks or enforces the sender's role or prohibits generating protocol elements that are exclusive to other roles, as specified by the RFC requirement. Although the function translates the header to ASCII and formats output according to a predefined format, it does not verify that the generated protocol elements conform to the ABNF grammar or are restricted to the correct sender role. All role-specific validation or prohibition of unauthorized protocol elements appears to be missing in this function. Thus, the function does not visibly address the constraint provided in the RFC specification.",success,
10129,pumpit,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,36,Fully Matches,"[{'A1': {'code': 'vec[2].iov_base = CRLF;\nvec[2].iov_len = 2;', 'explanation': 'The RFC requires that only CRLF be used to represent line breaks between body parts. In the code, after writing the header and the body chunk it appends a CRLF (as defined by the CRLF macro) with a fixed length of 2 bytes. This directly implements the specified behavior.'}}]","The sole requirement from the RFC specification is that the message body must use only CRLF to represent line breaks between its parts. The provided function explicitly inserts a CRLF sequence (using a fixed 2-byte array) after each data chunk it writes. This logic is embedded directly within the function and does not rely on external dependencies, thereby fully addressing the spec constraint.",success,
10130,firehose_input_filter,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function, firehose_input_filter, does not contain any explicit logic to ensure that the protocol elements generated conform to the grammar defined by the corresponding ABNF rules (as required by the RFC specification). Its primary role is to retrieve and process input data buckets using functions like ap_get_brigade and pumpit without performing any grammar validation. Although the function processes data and handles error conditions, there is no code segment within it that checks or enforces that the protocol elements match the ABNF grammar. Thus, in isolation from its dependencies, it does not address the specified constraint.",success,
10130,firehose_input_filter,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function 'firehose_input_filter' does not contain any logic that specifically checks for or prevents the generation of protocol elements or syntax alternatives that are only allowed for other roles. It mainly focuses on retrieving and processing input data (via ap_get_brigade and pumpit) without enforcing any role-based constraints as described in the spec constraints (e.g., ensuring that a sender does not generate protocol elements reserved for other roles). Therefore, no part of the code can be directly mapped to the spec's labeled conditions or actions.",success,
10166,qs_to_table,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function qs_to_table only handles parsing and unescaping of query string parameters. It does not include any logic that attempts to enforce or check the constraint that a sender must not generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. There is no logic within this function that relates to protocol element generation, message role validation, or compliance with ABNF rules as required by the spec constraint (C1, A1, etc.). Therefore, the function does not visibly address the given RFC's role-based protocol element constraints.",success,
10179,hm_watchdog_callback,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'A1': {'code': 'case AP_WATCHDOG_STATE_STOPPING:\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ctx->s, APLOGNO(02092)\n                 ""stopping %s listener."",\n                 HM_WATHCHDOG_NAME);\n\n    ctx->keep_running = 0;\n    if (ctx->sock) {\n        apr_socket_close(ctx->sock);\n        ctx->sock = NULL;\n    }', 'explanation': 'In the STOPPING state, the function explicitly stops further processing (ctx->keep_running = 0) and, if there is an open socket, it closes it using apr_socket_close. This behavior aligns with the RFC’s allowance for a client, server, or proxy to close the transport connection at any time, essentially performing a graceful shutdown of the connection.'}}]","The RFC allows a transport connection to be closed at any time and suggests that a graceful close should be issued when timing out. Within the function_body, only the STOPPING state implements connection closure via closing the socket, effectively attempting a graceful shutdown. However, no other parts of the function address scenarios like monitoring for an incoming close signal during an on-going request or managing idle connections with flow-control mechanisms. Therefore, while the connection closure logic in the STOPPING state (A1) is implemented, the code does not cover all aspects suggested by the RFC context, leading to a ‘Partially Matches’ judgment.",success,
10181,hm_handler,"An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",60,Fully Matches,"[{'A1': {'code': 'if (r->method_number != M_POST) {\n    return HTTP_METHOD_NOT_ALLOWED;\n}', 'explanation': 'This code explicitly checks if the HTTP method is not POST, and if so, it returns HTTP_METHOD_NOT_ALLOWED (405). This directly addresses the RFC requirement that a recognized and implemented method which is not allowed for the target resource should yield a 405 status code.'}}]","The function implements the RFC requirement by supporting only POST requests for the 'heartbeat' handler. For any other method (which is recognized but not allowed for this resource), it immediately returns 405. This behavior clearly meets the specified condition where the server should respond with a 405 (Method Not Allowed) status code when a recognized and implemented method is not appropriate for the target resource.",success,
10181,hm_handler,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Does Not Match,[],"The provided function does not include any logic that checks for a Transfer-Encoding header before setting the Content-Length header. According to the RFC specification, a sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field. In this function, ap_set_content_length(r, 2) is unconditionally invoked without verifying whether the message contains a Transfer-Encoding header. As such, this code does not visibly address the RFC requirement within the function_body.",success,
10181,hm_handler,"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT",71,Partially Matches,"[{'C1': {'code': 'if (r->method_number != M_POST) {\n    return HTTP_METHOD_NOT_ALLOWED;\n}', 'explanation': 'This code rejects any non-POST request, directly enforcing that state-changing requests must be made using POST as required by the RFC.'}}]","The function ensures that only POST requests are accepted by explicitly checking the request method, which aligns with the RFC's requirement to use POST rather than PUT for state-changing requests. However, it does not include any logic for selecting a proper URI on behalf of the client or handling redirection (3xx responses) if a PUT request is attempted. Since only part of the specification (i.e., enforcing POST) is handled within this function, the overall match is partial.",success,
10181,hm_handler,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'hmserver.port = 80;\nif (apr_table_get(tbl, ""port"") != NULL)\n    hmserver.port = atoi(apr_table_get(tbl, ""port""));', 'explanation': 'This segment sets the default port to 80 when no port is provided, thereby implementing the RFC requirement that in the absence of a specified port the recipient may assume the default port for the received-protocol.'}}]","The function explicitly sets a default port (80) and then checks for an incoming 'port' parameter to override this default. This behavior directly addresses the specified RFC condition regarding handling cases when a port is not provided, making the implementation fully match the specified constraint.",success,
10181,hm_handler,"If the purpose of such a resource is to perform an unsafe action, then the resource owner MUST disable or disallow that action when it is accessed using a safe request method.",267,Fully Matches,"[{'A1': {'code': 'if (r->method_number != M_POST) {\n    return HTTP_METHOD_NOT_ALLOWED;\n}', 'explanation': 'This code segment ensures that only POST requests (which are considered unsafe methods for this purpose) are allowed. Any safe request method (such as GET) is explicitly disallowed by returning HTTP_METHOD_NOT_ALLOWED, which directly implements the RFC requirement to disable or disallow an unsafe action when accessed via a safe request method.'}}]","The function explicitly checks the request method and only permits POST requests, thereby preventing safe methods from triggering an unsafe action. This fulfills the requirement as stated in the RFC, and the implementation is contained entirely within the function_body without reliance on external dependencies.",success,
10181,hm_handler,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Partially Matches,"[{'A1': {'code': 'ap_set_content_length(r, 2);', 'explanation': 'This line explicitly sets a Content-Length header for the response, which addresses the RFC recommendation that servers should generate encoding or length-delimited messages whenever possible. This is the only part of the RFC spec that is visibly implemented in this function.'}}]","The provided function implements a heartbeat endpoint that reads a request and sends back a short response. In doing so, it explicitly sets the response Content-Length (using ap_set_content_length) and writes a known message body ('OK'), thereby ensuring that the response is length-delimited. This addresses the RFC recommendation to use encoding or length-delimited messages. However, other parts of the RFC regarding handling of invalid Content-Length headers, Transfer-Encoding, or incomplete messages are not implemented here. Thus, only one of the spec's actions (labeled A1) is met, resulting in a 'Partially Matches' judgment.",success,
10181,hm_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'ap_set_content_type_ex(r, ""text/plain"", 1);', 'explanation': 'This line explicitly sets the Content-Type header field for the outgoing message, satisfying the RFC requirement that a sender generating a message containing content SHOULD include a Content-Type header field when the media type is known.'}}]","The function_body implements the specification by ensuring that the generated response contains a Content-Type header. In this case, the function uses 'ap_set_content_type_ex' to set the header to 'text/plain', confirming that it addresses the RFC mandate for including Content-Type in message responses with content.",success,
10181,hm_handler,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'A1': {'code': 'ap_set_content_length(r, 2);', 'explanation': ""The function explicitly sets the Content-Length header to 2, thereby attempting to send a Content-Length header when the response body ('OK') size is known. This partially reflects the RFC requirement to send a Content-Length header when the content size is known.""}}]","The provided function does set a Content-Length header when the content size is known, fulfilling part of the RFC specification. However, it does not include logic to avoid sending the header in cases where it should not (for example, responses with a 1xx or 204 status code or 2xx responses to CONNECT requests as mentioned in the RFC context). Therefore, while the function implements the action of sending a Content-Length header when appropriate for its specific use case, it does not address all conditions outlined in the RFC, resulting in a 'Partially Matches' outcome.",success,
10181,hm_handler,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The spec requires that a sender MUST NOT forward a message with a Content-Length header value known to be incorrect. In this function_body, there is no visible logic to validate the Content-Length header against the actual message framing, nor is there any check to ensure that an incorrect or duplicate Content-Length is handled according to the specification. The function simply reads and processes the message and then sends a fixed response with a hard-coded content length, without any verification of the incoming Content-Length header. Therefore, no labeled condition or action from the spec (e.g., C1 or A1) is implemented within this function.",success,
10322,dav_error_response,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, dav_error_response, simply formats and sends an error response by setting the status, status_line, content type, and then using predefined response body segments. It does not exhibit any logic specific to ensuring that protocol elements or syntax alternatives are only generated by participants with the correct role, as required by the RFC specification. There is no visible check or conditional logic that prevents the generation of protocol elements meant for other roles (e.g., verifying the role or matching the grammar defined by ABNF rules). Thus, the function does not address the spec constraint within its own code.",success,
10322,dav_error_response,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'ap_set_content_type_ex(r, ""text/html; charset=ISO-8859-1"", 1);', 'explanation': 'This line explicitly sets the Content-Type header for the response. According to the RFC, a sender that generates content SHOULD include a Content-Type header unless the media type is unknown. Here the function always sets a known media type, thereby satisfying the requirement.'}}]","The function dav_error_response contains a call to ap_set_content_type_ex which sets the Content-Type header to a fixed, known media type (text/html with a charset specified). This is in accordance with the spec requirement that a message containing content should include a Content-Type header field, thus the function fully addresses the relevant constraint (C1) by itself.",success,
10323,dav_error_response_tag,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function dav_error_response_tag constructs and outputs an error response in XML format. However, it does not include any explicit logic that checks or restricts protocol elements based on sender roles. The RFC specification requires that a sender must not generate protocol elements (or syntax alternatives) that are only allowed for participants in other roles, but the function merely formats and outputs error XML without validating or ensuring that these elements are appropriate for the sender's role. Therefore, no part of the function’s code visibly implements the necessary constraints (e.g., checking sender roles or conditionally generating tags) required by the RFC.",success,
10323,dav_error_response_tag,"If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type.",35,Does Not Match,[],"The RFC specification requires that if a Content-Type header is not present, the recipient may assume a default media type (application/octet-stream) or examine the data to determine its type. In contrast, the function unconditionally sets a content type via the call to ap_set_content_type_ex(r, DAV_XML_CONTENT_TYPE, 1); and does not check for the absence of a Content-Type header, inspect data, or conditionally default the type. Thus, no visible logic in the function specifically addresses the RFC’s stipulation regarding missing Content-Type header handling.",success,
10323,dav_error_response_tag,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'ap_set_content_type_ex(r, DAV_XML_CONTENT_TYPE, 1);', 'explanation': 'This call sets the Content-Type header field for the response message. The RFC states that a sender generating a message containing content SHOULD include a Content-Type header field, and this code explicitly does that, thereby addressing the specification.'}}]","The function 'dav_error_response_tag' generates an error response by sending XML content and appropriately sets the Content-Type header via the call to 'ap_set_content_type_ex'. This meets the specification requiring that a message containing content SHOULD have a Content-Type header field, thus fully matching the constraint based solely on the logic implemented within this function.",success,
10324,dav_xml_escape_uri,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function dav_xml_escape_uri is focused on escaping a URI for safe XML embedding by using ap_escape_uri and apr_xml_quote_string. It checks for the existence of the '&' character and performs additional escaping if necessary. However, none of this logic enforces or validates the HTTP RFC requirement that a sender must not generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. There is no logic in the function that inspects the role of the sender nor does it ensure compliance with the ABNF grammar for protocol elements, which are the conditions (e.g., C1) and actions (e.g., A1) defined in the spec constraints. Therefore, this function does not visibly address any of the labeled conditions or actions from the provided specification.",success,
10325,dav_send_one_response,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that the sender must not generate protocol elements or syntax alternatives that are reserved for another role. In the provided function, the code simply outputs various XML elements (<D:response>, <D:href>, <D:status>, and optionally <D:responsedescription>) based solely on the response structure without any logic to verify or enforce sender role restrictions. There is no conditional check or mechanism in the function_body that prevents generation of disallowed protocol elements for the sender’s role. Thus, within this function, the labeled constraint (e.g., C1) from the spec is not addressed.",success,
10326,dav_begin_multistatus,"A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the ""message/http"" media type.",301,Does Not Match,[],"The provided function 'dav_begin_multistatus' solely sets HTTP status, content type, and outputs an XML multistatus response. There is no logic present within the function that examines or modifies any header field values to prevent or replace line folding (obs-fold) as dictated by the RFC specification. No checks or actions are taken to ensure that a generated message does not include obs-fold unless within a 'message/http' media type. As a result, none of the specified constraints related to preventing line folding (e.g., C1, A1) are addressed within this function.",success,
10326,dav_begin_multistatus,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function generates an XML multistatus response by writing a header and appending namespace attributes if present. However, it does not implement any validation logic to ensure that the generated protocol elements conform to the ABNF rules defined in the HTTP RFC specification. Specifically, it does not check that the constructed XML or namespaces adhere to a particular grammar. Therefore, although it superficially generates protocol content, it does not enforce the requirement that a sender must not generate protocol elements that deviate from the prescribed grammar (the condition implied by C1). As such, the function does not visibly address this key constraint within its own logic.",success,
10326,dav_begin_multistatus,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are reserved for other roles. In the function_body, there is no visible logic or checks that address role-based restrictions or ensure that elements generated conform strictly to the sender's role. The function simply sets the response status, content type, and prints a multistatus XML header (and optional namespace attributes) without verifying that any generated protocol elements conform to the allowed set for this sender role. Therefore, none of the labeled conditions or actions (e.g., C1 or A1) from the spec constraints are implemented within this code function.",success,
10326,dav_begin_multistatus,"A sender SHOULD NOT generate a quoted-pair in a comment except where necessary to quote parentheses [""("" and "")""] and backslash octets occurring within that comment.",243,Does Not Match,[],"The provided function, dav_begin_multistatus, simply sets the HTTP status, content type, and writes an XML multistatus response with optional namespaces. There is no logic that addresses the generation or handling of quoted-pairs within comments as required by the RFC specification (i.e., ensuring that quoted-pairs are only generated when necessary to quote parentheses or backslash octets). As such, none of the labeled spec constraints (e.g., C1 or A1) concerning quoted-pair generation in comments are implemented within this function.",success,
10326,dav_begin_multistatus,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'r->status = status;\nap_set_content_type_ex(r, DAV_XML_CONTENT_TYPE, 1);', 'explanation': 'The function explicitly sets the Content-Type header by calling ap_set_content_type_ex with a known MIME type (DAV_XML_CONTENT_TYPE), thereby fulfilling the RFC requirement that a message containing content should include a Content-Type header, unless the media type is unknown.'}}]","The RFC requires that any message generated with content must include a Content-Type header unless the media type is unknown. In the provided function, the call to ap_set_content_type_ex(r, DAV_XML_CONTENT_TYPE, 1) unconditionally assigns a known media type to the response. This action directly implements the requirement by ensuring that a Content-Type header is present in the message. Since the function by itself produces the header (without relying on behavior in its dependencies), it fully addresses the specified RFC constraint.",success,
10326,dav_begin_multistatus,"If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type.",35,Fully Matches,"[{'C1': {'code': 'ap_set_content_type_ex(r, DAV_XML_CONTENT_TYPE, 1);', 'explanation': 'The RFC indicates that a sender SHOULD include a Content-Type header field when it knows the media type. This code call explicitly sets the Content-Type (using a defined DAV_XML_CONTENT_TYPE) which fulfills that requirement.'}}]","The function sets the Content-Type header explicitly, complying with the RFC's recommendation for senders to generate a Content-Type header when the media type is known. Because the function always generates the header rather than relying on default behavior when absent, it fully addresses the relevant specification constraint without needing additional logic for header absence.",success,
10327,dav_finish_multistatus,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'ap_fputs(r->output_filters, bb, ""</D:multistatus>"" DEBUG_CR);', 'explanation': 'This line outputs a hard-coded closing tag that is intended to conform to the protocol grammar. By consistently generating the defined valid element, the function ensures that no incorrect protocol elements are emitted.'}}]","The only requirement from the spec is that the sender must not generate protocol elements that do not adhere to the grammar defined in the ABNF rules. The function accomplishes this by outputting a literal (and correct) closing tag for the multistatus XML element and properly terminating the response body. There is no dynamic or conditional generation of protocol elements; instead, it simply emits a constant string known to be valid. As such, within its limited scope, the function fully addresses the constraint specified by the HTTP RFC.",success,
10327,dav_finish_multistatus,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function simply writes the closing tag for a multistatus XML element, appends an end-of-stream bucket, and forwards the brigade without checking or enforcing any role-specific restrictions as required by the RFC specification. There is no logic within the function that verifies whether the sender is allowed to generate the protocol element (i.e., checking that the sender does not output elements reserved for other roles). As a result, the function does not implement any of the specified conditions (e.g., C1) or actions (e.g., A1) related to the sender's role constraints.",success,
10328,dav_send_multistatus,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, dav_send_multistatus, primarily creates and sends a multistatus response by invoking helper functions (dav_begin_multistatus, dav_send_one_response, and dav_finish_multistatus) without directly enforcing or validating that only permitted protocol elements are generated. The RFC specification requires that a sender must not generate protocol elements that are reserved for other roles. However, no logic in the function_body checks the sender's role against the elements being generated or ensures that disallowed syntax is filtered out. As such, the function does not visibly address the spec constraint within its own logic.",success,
10331,dav_created,A sender MUST NOT send a connection option corresponding to a field that is intended for all recipients of the content.,252,Does Not Match,[],"The provided function deals with constructing a response for a created resource by setting a Location header and composing a response body. However, there is no logic within the function that addresses the RFC requirement to not send a connection option corresponding to a field that is intended for all recipients of the content (e.g., handling or avoiding fields like Cache-Control as connection options). Therefore, none of the spec constraints (such as C1 or any related actions) are visibly implemented in this function.",success,
10331,dav_created,"An origin server MUST NOT send a validator field (Section 8.8), such as an ETag or Last-Modified field, in a successful response to PUT unless the request's representation data was saved without any transformation applied to the content (i.e., the resource's new representation data is identical to the content received in the PUT request) and the validator field value reflects the new representation.",70,Partially Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Location"", ap_construct_url(r->pool, locn, r));', 'explanation': 'This code sets the Location header in the response as required by HTTP/1.1 when a new resource is created. It visibly implements part of the spec that mandates including a Location header in the response.'}}]","The provided function dav_created sets the Location header for a created resource, which aligns with one aspect (action A1) of the HTTP/1.1 requirements for a successful creation response. However, the RFC specification emphasizes not sending a validator field (e.g., an ETag or Last-Modified header) unless the stored representation is an exact, untransformed copy of the PUT request. The function does not include any logic to add a validator field—in fact, it simply omits it—and there is even a comment suggesting that inserting an ETag header is a possibility, but no implementation is provided. As a result, while the function does address sending the Location header, it does not explicitly implement the conditional validator field logic mandated by the RFC. Thus, the function only partially matches the spec constraints.",success,
10331,dav_created,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'if (locn == NULL) {\n    locn = ap_escape_uri(r->pool, r->uri);\n}\n...\napr_table_setn(r->headers_out, ""Location"", ap_construct_url(r->pool, locn, r));', 'explanation': 'The RFC requires that a sender must not produce protocol elements that violate the ABNF grammar. In this function, the generated Location header is built using ap_escape_uri (if locn is null) and ap_construct_url to produce an absolute URI. These calls ensure that the URI conforms to the proper escaping rules, thereby ensuring that the generated protocol elements match the ABNF rules.'}}]","The function directly handles the generation of protocol elements (in this case, the Location header and parts of the response body) and does so by applying escaping and URL-construction routines. These routines are intended to produce correctly formatted output according to HTTP/1.1 grammar. Thus, the function visibly addresses the spec constraint that protocol elements must match the ABNF grammar, and it does so fully within its own logic.",success,
10331,dav_created,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Fully Matches,"[{'C1': {'code': 'if (replaced) {\n    /* Apache will supply a default message */\n    return HTTP_NO_CONTENT;\n}', 'explanation': 'This code block makes sure that if the target resource already existed (i.e. the sender’s role does not include creating a new resource), then no creation-specific protocol elements (like a Location header) are generated. This complies with the requirement that a sender must not generate protocol elements reserved for other roles.'}}, {'A1': {'code': 'apr_table_setn(r->headers_out, ""Location"", ap_construct_url(r->pool, locn, r));', 'explanation': 'When a resource is created, this statement builds an absolute URI for the new resource and sets it in the Location header, fulfilling the HTTP/1.1 requirement (as per S10.2.2) while ensuring that only the correct message for the sender role is generated.'}}]","The function implements the RFC requirement by conditionally generating a Location header only when a new resource is actually created. When the resource already exists (indicated by the 'replaced' flag), it avoids adding creation-specific protocol elements. Thus, the code function alone visibly addresses the spec constraints regarding role-based generation of protocol elements.",success,
10331,dav_created,A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content).,193,Does Not Match,[],"The RFC specification requires that a server must not send a Transfer-Encoding header in responses with status codes 1xx or 204. While the function does return HTTP_NO_CONTENT (204) if the resource was replaced, it does not contain any explicit logic to check for or prevent the inclusion of a Transfer-Encoding header field. There is no code in the function that addresses this constraint, as it neither sets nor removes the Transfer-Encoding header. Therefore, the function does not visibly implement the specified RFC constraint within its own logic.",success,
10331,dav_created,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Does Not Match,[],"The provided function does not include any explicit logic that addresses the RFC requirement to not send a Content-Length header in 1xx or 204 responses. Although it returns HTTP_NO_CONTENT (which corresponds to 204) when the resource already exists, there is no code in the function that explicitly ensures that a Content-Length header is omitted from that response. The function only manipulates a Location header for created resources and relies on external default behavior for the 204 response, so it does not visibly implement the specified constraint within the function_body itself.",success,
10331,dav_created,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,155,Fully Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Location"", ap_construct_url(r->pool, locn, r));', 'explanation': ""This line converts the provided 'locn' to an absolute URI and sets it in the 'Location' header of the response, thereby fulfilling the RFC requirement to include a preferred URI reference for the new permanent URI.""}}]","The function 'dav_created' checks if a new resource is being created (i.e., not replaced). For a new creation, it creates an absolute URI from the provided location (or from the request URI if not provided) and assigns it to the 'Location' header via the call to ap_construct_url followed by apr_table_setn. This directly addresses the RFC specification that requires the server to generate a Location header with the new permanent URI. All logic fulfilling the spec constraint is contained within the function itself.",success,
10331,dav_created,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'C1': {'code': 'apr_table_setn(r->headers_out, ""Location"", ap_construct_url(r->pool, locn, r));', 'explanation': ""This line converts the provided or default 'locn' to an absolute URI and sets it in the Location header of the response as required by the RFC specification.""}}]","The function 'dav_created' directly implements the RFC requirement by ensuring that a Location header is generated in the response. When creating a new resource (HTTP_CREATED), it constructs an absolute URI from the provided location or the current URI and sets it in the response header. This matches the specified condition, satisfying the requirement within the function_body itself.",success,
10331,dav_created,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Location"", ap_construct_url(r->pool, locn, r));', 'explanation': ""This code constructs an absolute URI from the provided 'locn' (or a default if null) and sets it in the Location header of the response. This directly fulfills the spec constraint that requires the server to generate a Location header field containing a URI reference for the different URI.""}}]","The function 'dav_created' explicitly handles the creation of a Location header when a new resource is being created (i.e., when 'replaced' is false). By converting the URI to its absolute form using 'ap_construct_url' and then setting the header with 'apr_table_setn', the code addresses the spec requirement. No other parts of the function rely on external dependencies to implement this behavior, so within its own scope it fully meets the specified condition.",success,
10331,dav_created,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,160,Fully Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Location"", ap_construct_url(r->pool, locn, r));', 'explanation': ""This line converts the provided URI to an absolute URL and sets it as the 'Location' header in the response. This directly implements the specification requirement to generate a 'Location' header field containing the preferred URI reference for the new permanent URI.""}}]","The function 'dav_created' visibly implements the RFC requirement by ensuring that a 'Location' header is present in the response when a new resource is created. The specific code segment that constructs the absolute URI and sets the header directly addresses the spec constraint. Thus, the function fully meets the specified condition within its own logic.",success,
10331,dav_created,"It MUST conform to the field-name syntax defined in Section 5.1, and it SHOULD be restricted to just letters, digits, and hyphen ('-') characters, with the first character being a letter.",293,Does Not Match,[],"The provided function, dav_created, handles the creation of a resource and sets the 'Location' header for the HTTP response as per HTTP/1.1 guidelines (e.g., Section 10.2.2). It does not contain any logic related to verifying or enforcing the field-name syntax as required by the RFC specification for registration requests (e.g., checking that a field name is restricted to letters, digits, and hyphen characters with the first letter being a letter). Therefore, the function does not attempt to implement the specified HTTP RFC registration field-name constraints, and no labeled spec constraint (e.g., C1 or A1) related to that are addressed within this function.",success,
10332,dav_get_depth,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (depth == NULL) {\n    return def_depth;\n}', 'explanation': ""Checks for the absence of the 'Depth' header and returns a default value, demonstrating a defensive approach to parsing.""}}, {'A1': {'code': 'ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00580)\n              ""An invalid Depth header was specified."");\nreturn -1;', 'explanation': 'Logs an error and returns -1 when the header value does not match expected legal values, thereby handling an invalid input defensively.'}}]","The function defensively parses the 'Depth' header by checking if it is present and comparing it against a few accepted string values ('infinity', '0', '1'). This meets some aspects of defensive parsing as described in the spec by handling missing and invalid values. However, it does not perform comprehensive validation such as checking for conformance to the full ABNF grammar or verifying buffer length limitations. Therefore, while it shows a defensive approach in part, it only partially implements the full expectations of the RFC specification.",success,
10332,dav_get_depth,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function solely inspects and validates the 'Depth' header received in a message—ensuring its value is one of the allowed ones ('infinity', '0', or '1')—and logs an error if it finds an unexpected value. This check is about verifying that incoming protocol elements conform to the expected grammar. However, the RFC specification requires that a sender must not generate protocol elements (or syntax alternatives) that are reserved for other roles. Since this function does not generate protocol elements but only validates received input, it does not implement the specific sender-side requirement outlined in the spec. Hence, the function does not attempt to implement the required behavior from the RFC.",success,
10332,dav_get_depth,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'if (depth == NULL) {\n    return def_depth;\n}\n\nif (ap_cstr_casecmp(depth, ""infinity"") == 0) {\n    return DAV_INFINITY;\n}\nelse if (strcmp(depth, ""0"") == 0) {\n    return 0;\n}\nelse if (strcmp(depth, ""1"") == 0) {\n    return 1;\n}', 'explanation': 'This segment verifies that the \'Depth\' header value strictly conforms to a limited set of permitted values (""infinity"", ""0"", ""1""). By checking the header against these allowed grammar options, it prevents processing (and later generation) of protocol elements that do not match the defined ABNF rules.'}}, {'A1': {'code': '/* The caller will return an HTTP_BAD_REQUEST. This will augment the\n * default message that Apache provides. */\nap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00580)\n              ""An invalid Depth header was specified."");\nreturn -1;', 'explanation': 'When the header value does not match any of the allowed values, this segment logs an error and returns a distinct error code (-1), which causes the caller to generate an HTTP_BAD_REQUEST. This ensures that invalid, nonconforming header values do not result in protocol elements being generated.'}}]","The function 'dav_get_depth' inspects the incoming 'Depth' header and only recognizes specific, approved values as defined by the ABNF grammar. It returns valid depth values for matching inputs and signals an error when the header does not conform. In doing so, it prevents the propagation or generation of protocol elements that do not adhere to the RFC requirements, thereby fully addressing the spec constraint provided.",success,
10332,dav_get_depth,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Fully Matches,"[{'C1': {'code': 'const char *depth = apr_table_get(r->headers_in, ""Depth"");\n\nif (depth == NULL) {\n    return def_depth;\n}\n\nif (ap_cstr_casecmp(depth, ""infinity"") == 0) {\n    return DAV_INFINITY;\n}\nelse if (strcmp(depth, ""0"") == 0) {\n    return 0;\n}\nelse if (strcmp(depth, ""1"") == 0) {\n    return 1;\n}', 'explanation': ""This segment retrieves the 'Depth' header and interprets it according to defined semantics. It covers the cases where the header is missing (returning a default value) and valid inputs ('infinity', '0', '1'). This fulfills the requirement that the recipient MUST interpret the protocol element as specified.""}}, {'A1': {'code': 'ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00580)\n              ""An invalid Depth header was specified."");\nreturn -1;', 'explanation': 'This part addresses the action for handling invalid constructs. It logs an error and returns -1 to indicate an invalid Depth header, thereby deferring the final HTTP_BAD_REQUEST response to the caller.'}}]","The function clearly implements the RFC's requirement for interpreting a received protocol element by reading and processing the 'Depth' header. Valid values are properly mapped to their associated constants, and invalid inputs are handled with error logging and an error return code. All logic is contained within this function, and thus it fully meets the specified constraints.",success,
10333,dav_get_overwrite,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function only processes and validates the 'Overwrite' header by ensuring its value is either missing (defaulting to 'T') or exactly 'T'/'F' (in a case‐insensitive single character format). It does not include any logic to check or enforce that protocol elements (or syntax alternatives) are only generated by participants in the appropriate roles, as required by the specification. In other words, while it validates the header’s syntax, it does not address the requirement that a sender must not generate elements reserved for other roles. Therefore, the function does not visibly address the labeled conditions/actions from the spec constraints.",success,
10333,dav_get_overwrite,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': ""if ((*overwrite == 'F' || *overwrite == 'f') && overwrite[1] == '\\0') {\n    return 0;\n}\n\nif ((*overwrite == 'T' || *overwrite == 't') && overwrite[1] == '\\0') {\n    return 1;\n}"", 'explanation': ""This segment ensures that the Overwrite header matches a very strict grammar (i.e. exactly one character, either a 'T' or 'F' in any case), aligning with the ABNF rule for that header value.""}}, {'A1': {'code': 'ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00581) ""An invalid Overwrite header was specified."");\nreturn -1;', 'explanation': 'This code rejects any header value that does not strictly conform to the expected grammar, ensuring that invalid protocol elements are not further processed.'}}]","The function validates the 'Overwrite' header by checking that it comprises only a single character—either 'T'/'t' or 'F'/'f'. This validation directly addresses a part of the RFC requirement that protocol elements conform to their defined grammar. However, the RFC mandates that a sender must not generate any protocol elements that do not match the ABNF grammar, which is a broader requirement. The function only performs a check on one header field, meaning it addresses some (but not all) aspects of the overall requirement. Consequently, the function partially matches the intended specification.",success,
10337,dav_parse_range,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'if (ap_cstr_casecmpn(range, ""bytes "", 6) != 0\n    || (dash = ap_strchr(range + 6, \'-\')) == NULL\n    || (slash = ap_strchr(range + 6, \'/\')) == NULL) {\n    /* malformed header */\n    return -1;\n}\n\n*dash++ = *slash++ = \'\\0\';\n\nif (!ap_parse_strict_length(range_start, range + 6)) {\n    return -1;\n}\nif (!ap_parse_strict_length(range_end, dash) || *range_end < *range_start) {\n    return -1;\n}\n\nif (*slash != \'*\') {\n    apr_off_t dummy;\n\n    if (!ap_parse_strict_length(&dummy, slash) || dummy <= *range_end) {\n        return -1;\n    }\n}', 'explanation': ""The function explicitly validates the syntax of the 'Content-Range' header by enforcing that it begins with the literal 'bytes ', confirming the presence of both '-' and '/' characters, and then strictly parsing the numerical components. This set of validations ensures that only header values matching the ABNF grammar are accepted, which is in line with the specification that dictates a sender must not generate protocol elements that deviate from the defined grammar.""}}]","The provided function 'dav_parse_range' implements a series of checks to ensure that the 'Content-Range' header strictly adheres to the expected grammar. It verifies the literal prefix, required delimiters, and applies strict numeric parsing to enforce format rules. As a result, it prevents the processing of malformed protocol elements – effectively addressing the RFC requirement that a sender must not generate protocol elements that do not match the corresponding ABNF grammar. All relevant aspects of the constraint are handled within this function, thus the outcome is 'Fully Matches'.",success,
10337,dav_parse_range,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (ap_cstr_casecmpn(range, ""bytes "", 6) != 0\n    || (dash = ap_strchr(range + 6, \'-\')) == NULL\n    || (slash = ap_strchr(range + 6, \'/\')) == NULL) {\n    /* malformed header */\n    return -1;\n}', 'explanation': ""This segment defensively checks that the received header begins with the expected 'bytes ' prefix and contains both '-' and '/' delimiters, which is in line with the requirement to guard against nonconforming input per the RFC.""}}, {'A1': {'code': ""if (!ap_parse_strict_length(range_start, range + 6)) {\n    return -1;\n}\nif (!ap_parse_strict_length(range_end, dash) || *range_end < *range_start) {\n    return -1;\n}\n\nif (*slash != '*') {\n    apr_off_t dummy;\n\n    if (!ap_parse_strict_length(&dummy, slash) || dummy <= *range_end) {\n        return -1;\n    }\n}"", 'explanation': 'This block uses strict parsing functions to validate that the numeric parts of the header conform to expected formats and logical relationships, thereby enforcing defensiveness in parsing numeric values.'}}]","The function implements defensive parsing by performing several validations: it checks that the header is present, begins with 'bytes ', and includes the necessary delimiters, and it employs strict numeric parsing to verify range values. This addresses part of the RFC's requirement to defensively parse protocol elements. However, it does not incorporate any explicit checks for limiting the input size (buffer size) or fully validating against the complete ABNF grammar. Therefore, while the code does incorporate important defensive measures (meeting conditions C1 and A1), its implementation is only a partial match to all aspects of the RFC specification.",success,
10337,dav_parse_range,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'range = apr_pstrdup(r->pool, range_c);\nif (ap_cstr_casecmpn(range, ""bytes "", 6) != 0\n    || (dash = ap_strchr(range + 6, \'-\')) == NULL\n    || (slash = ap_strchr(range + 6, \'/\')) == NULL) {\n    /* malformed header */\n    return -1;\n}', 'explanation': ""This segment checks that the received header element adheres to the expected format (i.e. begins with 'bytes ', contains a '-' and a '/'). This is an attempt to interpret the protocol element according to the semantic rules implied by the HTTP specification. However, while it enforces a strict format, it does not implement any error recovery or extension handling, which limits its coverage of the overall specification.""}}]","The function 'dav_parse_range' attempts to interpret the 'content-range' header field by checking its syntax and strictly parsing its numerical values. This meets a primary requirement of the RFC—that a recipient must interpret a protocol element per defined semantics—by validating the expected 'bytes start-end/total' format. Nevertheless, it does not address additional behaviors such as recovering from invalid constructs or handling known sender errors via configuration or experience (as hinted by the spec context). Thus, while the function does capture some of the constrained behavior (labeled here as C1), it only partially matches the full intent of the RFC.",success,
10338,dav_method_get,"Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method.",282,Partially Matches,[],"The function does include logic that appears to evaluate request preconditions – for example, through the call to dav_run_method_precondition() and later the ap_meets_conditions() check – which aligns partly with the RFC requirement to evaluate preconditions just before processing the request content. However, the RFC also requires that a server ignore these preconditions if its response to the unconditional request would have been a status code other than a successful 2xx or 412. This nuanced check is not implemented within this function. In addition, while the function is specific to the GET method (which does involve selection of a representation), it does not comprehensively address all aspects of the RFC’s precondition handling solely by its own internal logic. Therefore, although some precondition evaluation is visible, the implementation is incomplete and only partially satisfies the specified constraints.",success,
10340,dav_method_put,"If the target resource does not have a current representation and the PUT successfully creates one, then the origin server MUST inform the user agent by sending a 201 (Created) response.",65,Fully Matches,"[{'A1': {'code': 'rc = dav_created(r, NULL, ""Resource"", resource_state == DAV_RESOURCE_EXISTS);', 'explanation': 'This code calls dav_created with a flag that checks if the resource already existed. When resource_state indicates that the resource did not exist (i.e. it was created by the PUT), dav_created is expected to return a 201 (Created) response as required by the RFC.'}}]","The RFC requires that if a PUT request creates a new resource (i.e. the target resource does not currently have a representation), the server must respond with a 201 (Created) status. In this function, the resource state is determined and, following a successful write, the function calls dav_created with the boolean expression (resource_state == DAV_RESOURCE_EXISTS). This implies that if the resource did not exist, the dav_created function will return HTTP_CREATED (201). Thus, the function visibly implements the required logic within its body.",success,
10340,dav_method_put,"A server MUST read the entire request message body or close the connection after sending its response; otherwise, the remaining data on a persistent connection would be misinterpreted as the next request.",312,Fully Matches,"[{'C1': {'code': 'do {\n    apr_status_t rc;\n\n    rc = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,\n                        APR_BLOCK_READ, DAV_READ_BLOCKSIZE);\n\n    if (rc != APR_SUCCESS) {\n        // Error handling...\n        break;\n    }\n\n    for (b = APR_BRIGADE_FIRST(bb);\n         b != APR_BRIGADE_SENTINEL(bb);\n         b = APR_BUCKET_NEXT(b)) {\n        if (APR_BUCKET_IS_EOS(b)) {\n            seen_eos = 1;\n            break;\n        }\n        // Further reading and writing to stream continues...\n    }\n\n    apr_brigade_cleanup(bb);\n} while (!seen_eos);', 'explanation': 'This loop continuously reads data from the request body until an End-of-Stream (EOS) bucket is encountered, ensuring that the entire request body is consumed as required by the RFC.'}}]",The function 'dav_method_put' includes a loop that reads the entire request body using 'ap_get_brigade' and iterates over the bucket brigade until it detects the end of the stream. This fully implements the specified RFC requirement that the server must read the complete request message body to prevent misinterpretation of subsequent requests on a persistent connection.,success,
10340,dav_method_put,"If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.",202,Partially Matches,"[{'C1': {'code': 'if (has_range < 0) {\n    body = apr_psprintf(r->pool,\n                        ""Malformed Content-Range header for PUT %s."",\n                        ap_escape_html(r->pool, r->uri));\n    return dav_error_response(r, HTTP_BAD_REQUEST, body);\n}', 'explanation': 'This segment checks for a malformed Content-Range header—a case considered unrecoverable in a request message according to the spec—and responds with a 400 (Bad Request) error. This addresses the part of the spec that requires the server to respond with a 400 error code on unrecoverable errors in the request message. However, the code does not explicitly show logic to close the connection after sending the response, so the full action specified (responding with 400 and then closing the connection) is only partially implemented in the function itself.'}}]","The function includes logic that, upon encountering an unrecoverable error (in this case a malformed Content-Range header), returns a 400 error response (via dav_error_response). This aligns with the part of the spec that requires sending a 400 status code for errors in a request message. However, there is no explicit handling within the function to close the connection after sending the error response, which is a requirement of the spec. Thus, while the function visibly attempts to implement the error response portion of the constraint, it does not fully cover the complete set of actions (specifically, the connection closure), resulting in a 'Partially Matches' judgment.",success,
10340,dav_method_put,The recipient of an invalid Content-Range MUST NOT attempt to recombine the received content with a stored representation.,136,Fully Matches,"[{'C1': {'code': 'has_range = dav_parse_range(r, &range_start, &range_end);\nif (has_range < 0) {\n    /* RFC 2616 14.16: If we receive an invalid Content-Range we must\n     * not use the content.\n     */\n    body = apr_psprintf(r->pool,\n                        ""Malformed Content-Range header for PUT %s."",\n                        ap_escape_html(r->pool, r->uri));\n    return dav_error_response(r, HTTP_BAD_REQUEST, body);\n}', 'explanation': 'This code checks for an invalid Content-Range by calling dav_parse_range. When the return value indicates an invalid range (has_range < 0), it immediately returns an error response without attempting to recombine the received content with the stored representation, thereby meeting the spec requirement.'}}]","The function explicitly checks for an invalid Content-Range header and, upon detecting an error condition (has_range < 0), it returns an error via dav_error_response without processing or recombining the content. This behavior fully implements the spec constraint that the recipient must not attempt to recombine content when an invalid Content-Range is provided.",success,
10341,dav_stream_response,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'dav_stream_response' only constructs a response structure from input parameters and passes it to another function ('dav_send_one_response'). There is no logic within this function that verifies or prevents the generation of protocol elements or syntax alternatives that are reserved for other roles, as required by the RFC specification. No checks against sender roles or conformance to ABNF grammar are implemented here. Therefore, in isolation, this function does not address any of the specified constraints (e.g., C1) or any actions (e.g., A1).",success,
10341,dav_stream_response,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function builds a response structure and forwards it via a helper function but does not contain any logic to verify or enforce that the generated protocol elements match the specific ABNF grammar as required by the spec (C1). There is no validation or checking mechanism implemented within this function to ensure that only conformant protocol elements are produced, meaning it does not visibly address the specified RFC requirement.",success,
10343,dav_method_delete,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'depth = dav_get_depth(r, DAV_INFINITY);\n\nif (resource->collection && depth != DAV_INFINITY) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00582)\n                  ""Depth must be \\""infinity\\"" for DELETE of a collection."");\n    return HTTP_BAD_REQUEST;\n}\n\nif (!resource->collection && depth == 1) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00583)\n                  ""Depth of \\""1\\"" is not allowed for DELETE."");\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'The function explicitly retrieves and interprets the Depth header value (with dav_get_depth) and applies logic according to whether the targeted resource is a collection or not. This handling reflects an effort to conform to the semantics implied by the HTTP/DAV specification.'}}, {'C2': {'code': 'if (!resource->exists) {\n    /* Apache will supply a default error for this. */\n    return HTTP_NOT_FOUND;\n}', 'explanation': 'By testing if the resource exists and returning HTTP_NOT_FOUND when it does not, the function interprets the resource state according to protocol semantics.'}}, {'A1': {'code': 'if (dav_run_method_precondition(r, resource, NULL, NULL, &err) != DECLINED\n        && err) {\n    return dav_handle_err(r, err, NULL);\n}', 'explanation': 'This segment shows that the function actively checks for method preconditions (such as header conditions) and handles errors as dictated by the protocol, which is an action required by the RFC.'}}]","The function implements several visible checks—such as verifying the resource existence, interpreting the Depth header appropriately, and evaluating method preconditions—which are core aspects of interpreting a received protocol element per the HTTP specification. However, not all aspects of the RFC (for example, broader mechanisms for recovering from invalid constructs or extended error handling strategies) are fully handled within this function alone, hence the conclusion that it only partially matches the overall RFC constraints.",success,
10343,dav_method_delete,"Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method.",282,Fully Matches,"[{'C1': {'code': '/* check for any method preconditions */\n    if (dav_run_method_precondition(r, resource, NULL, NULL, &err) != DECLINED\n            && err) {\n        return dav_handle_err(r, err, NULL);\n    }', 'explanation': 'This code segment explicitly evaluates the received request preconditions before processing the DELETE action, which fulfills the RFC requirement. The function first performs normal checks (e.g., discards the body and resolves the resource) and then calls dav_run_method_precondition, thus meeting the condition specified in the RFC.'}}]","The function implements the key requirement of the RFC by ensuring that any request preconditions are evaluated just before the deletion (action) takes place. This evaluation is done after the normal request checks (such as discarding the request body and resolving the resource) and before any modification actions, which directly maps to the specified requirement. Dependencies and additional context are beyond the scope of this function, and therefore only the internal logic (specifically the precondition check) is considered.",success,
10344,dav_gen_supported_methods,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that a sender must not generate protocol elements or syntax alternatives that are only allowed to be generated by other roles. In the provided function, while it generates XML elements for supported methods and performs some validation (e.g., ensuring a 'name' attribute is present), it does not include any logic to restrict the generation of these elements based on the sender’s role. There is no check that verifies whether the sender is allowed to produce these protocol elements, nor is there any reference to role-specific conditions as mandated by the specification. As such, the function does not visibly address the condition described in the RFC.",success,
10344,dav_gen_supported_methods,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'for (child = elem->first_child; child != NULL; child = child->next) {\n    if (child->ns == APR_XML_NS_DAV_ID && strcmp(child->name, ""supported-method"") == 0) {\n        const char *name = NULL;\n\n        /* go through attributes to find method name */\n        for (attr = child->attr; attr != NULL; attr = attr->next) {\n            if (attr->ns == APR_XML_NS_DAV_ID && strcmp(attr->name, ""name"") == 0)\n                name = attr->value;\n        }\n\n        if (name == NULL) {\n            return dav_new_error(r->pool, HTTP_BAD_REQUEST, 0, 0,\n                                 ""A DAV:supported-method element does not have a \\""name\\"" attribute"");\n        }\n\n        /* see if method is supported */\n        if (apr_table_get(methods, name) != NULL) {\n            s = apr_pstrcat(r->pool,\n                            ""<D:supported-method D:name=\\"""",\n                            name, ""\\""/>"" DEBUG_CR, NULL);\n            apr_text_append(r->pool, body, s);\n        }\n    }\n}', 'explanation': ""This segment verifies that if a DAV:supported-method element is provided, it includes the required 'name' attribute. By returning an error when it is missing, the function ensures that the generated protocol element meets the expected grammar structure, partially addressing the spec requirement.""}}]","The RFC requires that a sender must not generate protocol elements that do not match the grammar defined by the ABNF rules. In this function, the fixed XML element templates and the check for the mandatory 'name' attribute in provided supported-method elements demonstrate an attempt to conform to that requirement. However, the function does not perform a comprehensive validation of all aspects of the ABNF grammar (for example, it does not validate the content of method names or sanitize inputs from the methods table in the case when no child elements are provided). Therefore, the function only partially matches the RFC constraint by implementing only a subset of the full grammar-validation logic.",success,
10344,dav_gen_supported_methods,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,36,Partially Matches,"[{'C1': {'code': 'apr_text_append(r->pool, body, ""<D:supported-method-set>"" DEBUG_CR);\n...\ns = apr_pstrcat(r->pool, ""<D:supported-method D:name=\\"""", elts[i].key, ""\\""/>"" DEBUG_CR, NULL);\n...\napr_text_append(r->pool, body, ""</D:supported-method-set>"" DEBUG_CR);', 'explanation': 'The RFC requires that a sender generate only CRLF to represent line breaks between body parts. In this function, every XML element line is concatenated with the DEBUG_CR macro (presumably defined as the CRLF sequence). This indicates an attempt to conform to the requirement. However, the function does not validate or enforce that the DEBUG_CR macro indeed expands solely to CRLF, nor does it handle other potential line break insertions – so the approach is only a partial implementation of the spec constraint.'}}]","The function generates the XML output for a WebDAV supported methods response and appends a macro (DEBUG_CR) for each line break. This suggests an intention to comply with the RFC requirement to use CRLF as the only line break representation. Nonetheless, since the function depends entirely on the DEBUG_CR macro without additional checks or guarantees that only CRLF is produced, it only partially meets the RFC constraint in its own code.",success,
10345,dav_gen_supported_live_props,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (name == NULL) {\n    err = dav_new_error(r->pool, HTTP_BAD_REQUEST, 0, 0,\n                        ""A DAV:supported-live-property element does not have a \\""name\\"" attribute"");\n    break;\n}\n\n/* default namespace to DAV: */\nif (nmspace == NULL)\n    nmspace = ""DAV:"";', 'explanation': ""The function checks that a DAV:supported-live-property element includes the required 'name' attribute (and defaults the namespace when missing), which is a basic enforcement of the expected grammar. This demonstrates an attempt to prevent generating protocol elements that do not conform to the expected ABNF rules. However, the function only covers part of the overall requirement.""}}]","The RFC requires that a sender must not generate protocol elements that do not match the ABNF grammar. In this function, there is a check for the presence of the 'name' attribute and a defaulting mechanism for the 'namespace' attribute when it is missing. These checks partially ensure that the generated XML elements adhere to a specific structure as expected by the grammar. Nonetheless, the function does not implement a comprehensive rating of all possible grammar conformance issues (e.g., it does not validate all aspects of the ABNF grammar), so it only partially meets the constraint.",success,
10345,dav_gen_supported_live_props,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function_body generates a WebDAV XML response (the DAV:supported-live-property-set element) and conditionally processes child elements of the input XML. However, it does not implement any logic that verifies whether the protocol elements being generated belong to the role of the sender or whether elements exclusive to other roles are being mistakenly generated. In other words, there is no check or enforcement to comply with the RFC requirement that a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. As a consequence, there is no visible implementation within function_body that addresses the specified RFC constraint, and thus it does not match the requirements.",success,
10346,dav_gen_supported_reports,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,[],"The RFC constraint (labeled here as C1) requires that a sender not generate protocol elements that deviate from the grammar defined by the ABNF rules. In the function, the XML elements (like <D:supported-report-set> and <D:supported-report .../>) are constructed using fixed string concatenation and, while there is a check for the existence of a mandatory “name” attribute on a DAV:supported-report element, there is no explicit validation to ensure that the concatenated output conforms to the ABNF grammar. The function assumes that the gathered report elements are correctly quoted and trusted, and thus it does not fully enforce or validate the ABNF grammar within its own logic. Therefore, the function only partially addresses the RFC requirement by hardcoding XML fragments without performing comprehensive grammar validation.",success,
10346,dav_gen_supported_reports,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that within a given message a sender must not generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. In this function, dav_gen_supported_reports, the code is solely responsible for generating a DAV:supported-report-set based on available reports. However, the function does not include any logic to enforce role-based restrictions (e.g., evaluating the sender's role or filtering out protocol elements/syntax alternatives that the sender is not allowed to generate). It simply iterates through available report elements and appends them to the response body. As a result, the function does not address the constraint that a sender must avoid generating elements that belong to another role, and thus it does not visibly implement the spec’s requirements.",success,
10347,dav_method_search,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC specification requires that a sender must not generate protocol elements that do not match the ABNF rules. In the function body of dav_method_search, there is no visible logic that ensures the generated protocol elements (such as HTTP headers or multi-status responses) conform to the specified ABNF grammar. Instead, the function delegates header setting and response generation to external hook functions (e.g., resource->hooks->set_headers and search_hooks->search_resource) without performing any explicit conformant checks. Thus, no part of the function itself implements the constraint regarding strict protocol element formatting, and this conformance is not addressed within the provided code.",success,
10347,dav_method_search,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function dav_method_search does not contain any explicit logic to enforce or verify the RFC requirement that a sender must not generate protocol elements or syntax alternatives that are reserved for participants in other roles. The function primarily performs resource retrieval, error handling, and delegates header setting and search processing to external hooks. There is no code within the function verifying proper role-based generation of protocol elements or checking against the ABNF grammar for elements that should only be generated by specific roles. As a result, none of the spec constraints (e.g., C1 or any similar condition) are visibly addressed in this function.",success,
10348,dav_method_options,"A server generating a successful response to OPTIONS SHOULD send any header that might indicate optional features implemented by the server and applicable to the target resource (e.g., Allow), including potential extensions not defined by this specification.",77,Fully Matches,"[{'C1': {'code': 'apr_table_setn(r->headers_out, ""DAV"", dav_level);', 'explanation': ""This line constructs and sends the 'DAV' header, which signals optional WebDAV features (and any extensions) available on the resource, aligning with the RFC specification.""}}, {'A1': {'code': '/* Generate the Allow header */\n...\napr_table_setn(r->headers_out, ""Allow"", allow);', 'explanation': ""The function compiles the allowed HTTP methods into the 'Allow' header, ensuring that the client receives a list of methods that are supported by the server for the target resource, compliant with the RFC spec.""}}]","The function clearly implements the key aspects of the OPTIONS method as described in the specification. It constructs the 'DAV' header to indicate supported optional features and extensions, and it builds the 'Allow' header from the methods available on the resource. These implementations directly address the requirements of the RFC that mandates a server to send any header that might indicate optional features when generating a successful OPTIONS response.",success,
10348,dav_method_options,A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.,30,Fully Matches,"[{'C1': {'code': 'if (doc == NULL) {\n    ap_set_content_length(r, 0);\n    return DONE;\n}\n\nr->status = HTTP_OK;\nap_set_content_type_ex(r, DAV_XML_CONTENT_TYPE, 1);\n\nap_rputs(DAV_XML_HEADER DEBUG_CR ""<D:options-response xmlns:D=\\""DAV:\\"">"" DEBUG_CR, r);\n\nfor (t = body.first; t != NULL; t = t->next)\n    ap_rputs(t->text, r);\n\nap_rputs(""</D:options-response>"" DEBUG_CR, r);', 'explanation': 'The function processes an OPTIONS request by building and sending an appropriate response without attempting to switch protocols. This adheres to the RFC requirement that an OPTIONS request must be honored (i.e. served with a proper response) under any protocol.'}}]","The provided code function implements the handling of an OPTIONS request by first determining the allowed methods, setting appropriate headers (such as the DAV and Allow headers), parsing any XML in the request body, and then sending an HTTP_OK response with an XML response body. There is no logic for switching protocols, which complies with the RFC mandate that no protocol switch should be attempted unless the new protocol can honor the request's semantics. Therefore, the function visibly addresses the key aspect of the spec that OPTIONS requests can (and should) be honored by any protocol.",success,
10348,dav_method_options,All general-purpose servers MUST support the methods GET and HEAD,58,Partially Matches,"[{'C1': {'code': 'case DAV_RESOURCE_EXISTS:\n    /* resource exists */\n    apr_table_addn(methods, ""GET"", """");\n    apr_table_addn(methods, ""HEAD"", """");', 'explanation': 'In the DAV_RESOURCE_EXISTS branch the function explicitly adds GET and HEAD to the allowed methods list, thus addressing the requirement that general-purpose servers must support these methods. However, the implementation does not add GET and HEAD for non-existent (or null) resources.'}}]","The provided 'dav_method_options' function attempts to implement the OPTIONS response by listing allowed HTTP methods. It meets the RFC requirement by adding GET and HEAD when the resource exists, which addresses the spec constraint that all general-purpose servers MUST support GET and HEAD. However, because the function adds these methods only in the DAV_RESOURCE_EXISTS case (and not for DAV_RESOURCE_NULL or DAV_RESOURCE_LOCK_NULL), the implementation only partially matches the RFC requirement when considered in isolation.",success,
10348,dav_method_options,"A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the ""message/http"" media type.",301,Does Not Match,[],"The provided code function does not include any logic that addresses the RFC requirement regarding line folding (obs-fold). The RFC specifies that the sender must not generate a message with field line values containing obs-fold unless the message is for packaging within the ""message/http"" media type. In this function, while header values (such as the ""DAV"" and ""Allow"" headers) are being composed, there is no evidence of any checking, rejecting, or modifying of field values that might contain line folding, nor any conditional handling for the ""message/http"" media type. Thus, within the function_body itself, there is no visible implementation corresponding to the spec's constraint.",success,
10349,dav_cache_badprops,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function dav_cache_badprops constructs an XML fragment containing a property status with a 404 error message, but it does not incorporate any logic to verify or enforce role-based restrictions on generating protocol elements. In other words, it does not check or ensure that only elements allowed for the sender's role are generated. No part of the function addresses the spec condition that a sender MUST NOT generate protocol elements or syntax alternatives allowed only to other roles, and therefore the code does not visibly address the labeled constraint.",success,
10351,dav_method_propfind,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (doc && !dav_validate_root(doc, ""propfind"")) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00585)\n                  ""The \\""propfind\\"" element was not found."");\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'This check validates that the XML document’s root is the expected ""propfind"" element. In doing so, it helps ensure that only protocol elements appropriate for a PROPFIND request (i.e. those generated by a client in this case) are accepted; elements inappropriate for the sender’s role are rejected.'}}, {'A1': {'code': 'if (doc == NULL || dav_find_child(doc->root, ""allprop"") != NULL) {\n    ctx.propfind_type = DAV_PROPFIND_IS_ALLPROP;\n}\nelse if (dav_find_child(doc->root, ""propname"") != NULL) {\n    ctx.propfind_type = DAV_PROPFIND_IS_PROPNAME;\n}\nelse if (dav_find_child(doc->root, ""prop"") != NULL) {\n    ctx.propfind_type = DAV_PROPFIND_IS_PROP;\n}\nelse {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00586)\n                  ""The \\""propfind\\"" element does not contain one of the required child elements (the specific command)."");\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'This branch distinguishes among the allowed child elements (<allprop>, <propname>, <prop>) so that no protocol element outside these alternatives is accepted. This enforces that the incoming message contains only allowed syntax for a PROPFIND request, though it does not strictly validate that exactly one is present.'}}]","The function implements key checks for the PROPFIND request by validating that the XML document has a ""propfind"" root and that it contains one (or a default is applied) of the allowed children: ""allprop"", ""propname"", or ""prop"". This indicates an attempt to ensure that the client (the sender of the request) does not include disallowed protocol elements or syntax alternatives. However, while these checks align with the requirement that a sender must not generate elements reserved for other roles, the function does not enforce all aspects (e.g., validating that only one of these children is present) solely within its own logic. Therefore, it only partially meets the specification constraints as provided.",success,
10351,dav_method_propfind,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (doc && !dav_validate_root(doc, ""propfind"")) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00585)\n                  ""The \\""propfind\\"" element was not found."");\n    return HTTP_BAD_REQUEST;\n}', 'explanation': ""This segment verifies that, when a request body is provided, its root element is 'propfind', which is part of ensuring that incoming protocol elements conform to the expected XML grammar defined for the method.""}}, {'A1': {'code': 'dav_begin_multistatus(ctx.bb, r, HTTP_MULTI_STATUS, doc ? doc->namespaces : NULL);', 'explanation': ""This call begins the generation of the <multistatus> XML response, explicitly including the document's namespaces, which is important for matching the required grammar for protocol responses.""}}]","The function partially addresses the requirement by checking the validity of the incoming XML (ensuring that the 'propfind' element is present) and by generating the <multistatus> response with the proper namespaces attached. These actions contribute to ensuring that both the input and output conform to the expected XML grammar. However, the function does not fully implement all aspects of the ABNF grammar validation (for example, validating that only one of the allowed child elements is present is noted but not enforced in code), so it only partially matches the full specification as stated in the RFC.",success,
10352,dav_failed_proppatch,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function constructs XML responses by appending strings and XML fragments without any validation or enforcement that these generated elements conform to the ABNF-defined grammar. In other words, while it produces protocol elements, it does not check or ensure that these elements strictly follow the grammar as required by the specification. Thus, none of the spec constraints (such as ensuring the protocol elements match the ABNF rules) are addressed within this function.",success,
10352,dav_failed_proppatch,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function, dav_failed_proppatch, is focused solely on constructing an XML response for a failed PROPPATCH operation by appending XML fragments and setting error statuses. It does not contain any logic that attempts to verify or enforce the RFC requirement that a sender must not generate protocol elements or syntax alternatives reserved for other roles. There are no checks, conditions, or logic within the function that restrict the generation of protocol elements based on the sender's role or conformity with the grammar defined by the ABNF rules. Since no part of this function addresses the labeled condition (C1) or any similar action (e.g., A1) described in the RFC specification constraints, the function’s implementation does not visibly implement the required constraint.",success,
10356,dav_method_proppatch,"Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method.",282,Partially Matches,"[{'C1': {'code': 'if (dav_run_method_precondition(r, resource, NULL, doc, &err) != DECLINED && err) {\n        return dav_handle_err(r, err, NULL);\n    }', 'explanation': 'This code segment calls dav_run_method_precondition immediately after parsing the request and before processing the content, which shows an attempt to evaluate preconditions in line with the RFC requirement that preconditions be checked after normal request validations.'}}]","The function visibly implements one core aspect of the spec by evaluating request preconditions via dav_run_method_precondition (labeled as C1), ensuring that preconditions are checked before processing the request content. However, the RFC also requires that preconditions be ignored if the response for an unconditional request would not be successful (2xx or 412), and this additional logic is not evident in the function itself. As such, while part of the specification is addressed by this function, not all labeled conditions and actions are fully handled which leads to the overall determination of 'Partially Matches.'",success,
10357,process_mkcol_body,A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 (Not Implemented).,195,Partially Matches,"[{'C1': {'code': 'if (tenc) {\n    if (ap_cstr_casecmp(tenc, ""chunked"")) {\n        /* Use this instead of Apache\'s default error string */\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00589)\n                      ""Unknown Transfer-Encoding %s"", tenc);\n        return HTTP_NOT_IMPLEMENTED;\n    }\n    r->read_chunked = 1;\n}', 'explanation': ""This code checks if the Transfer-Encoding header (tenc) is present and if its value is not 'chunked', then logs an error and returns HTTP_NOT_IMPLEMENTED (501). This directly addresses the spec requirement that a server receiving an unknown transfer coding should respond with a 501 status.""}}]","The function 'process_mkcol_body' examines the 'Transfer-Encoding' header and implements logic to return 501 (Not Implemented) if the transfer coding is not recognized as 'chunked'. This meets the specific RFC condition regarding unrecognized transfer codings. However, the function does not implement logic for other aspects of the spec (such as handling Transfer-Encoding header in responses for certain status codes), which might be handled elsewhere in the system. Therefore, only a part of the full spec constraint is addressed in this function, leading to a 'Partially Matches' outcome.",success,
10357,process_mkcol_body,"If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value).",201,Partially Matches,"[{'C2': {'code': 'else if (lenp) {\n    if (!ap_parse_strict_length(&r->remaining, lenp)) {\n        r->remaining = 0;\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00590)\n                      ""Invalid Content-Length %s"", lenp);\n        return HTTP_BAD_REQUEST;\n    }\n}', 'explanation': 'This segment checks for the presence of a Content-Length header when no Transfer-Encoding header is provided and uses a strict parser. If the parser fails (indicating an invalid Content-Length), it logs an error and returns HTTP_BAD_REQUEST, aligning with the RFC condition that an invalid Content-Length (without a Transfer-Encoding) must result in an error.'}}, {'A1': {'code': 'return HTTP_BAD_REQUEST;', 'explanation': 'Following the detection of an invalid Content-Length, the function returns HTTP_BAD_REQUEST, directly implementing the prescribed error action for such a case in request messages.'}}]","The function shows an effort to implement part of the RFC by focusing on the condition where a message arrives without a Transfer-Encoding header and with an invalid Content-Length header. It uses a strict parser to validate the header and, if invalid, logs the error and returns HTTP_BAD_REQUEST. However, it does not handle the exception noted in the RFC (i.e. parsing a comma‐separated list of values where all valid values are identical), so the implementation is only partial with respect to the complete RFC specification.",success,
10358,dav_method_mkcol,"An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",60,Fully Matches,"[{'C1': {'code': 'if (resource->exists) {\n    /* oops. something was already there! */\n    return HTTP_METHOD_NOT_ALLOWED;\n}', 'explanation': 'This code segment checks whether the target resource already exists. If it does, the function returns the HTTP_METHOD_NOT_ALLOWED status (405), corresponding exactly to the RFC requirement that a recognized and implemented method, when not allowed for the target resource, should result in a 405 response.'}}]","The function 'dav_method_mkcol' implements the RFC behavior by explicitly checking if the resource already exists and then returning HTTP_METHOD_NOT_ALLOWED (405). This directly addresses the condition described in the specification that a recognized and implemented method, if not allowed for the target resource, must result in a 405 status code. All of this logic is self-contained within the function, making it a full match to the intended behavior.",success,
10358,dav_method_mkcol,"Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method.",282,Partially Matches,"[{'C1': {'code': 'if (dav_run_method_precondition(r, resource, NULL, NULL, &err) != DECLINED && err) {\n        return dav_handle_err(r, err, NULL);\n    }', 'explanation': 'The code invokes dav_run_method_precondition to check for preconditions before performing the collection creation action. This demonstrates an attempt to satisfy the requirement to evaluate request preconditions as specified by the RFC.'}}]","The RFC mandates that preconditions be evaluated after normal request checks and just before processing the request content or taking action. In this function, after initial body processing (via process_mkcol_body) and successful resource resolution, the code performs a precondition check using dav_run_method_precondition, which addresses the requirement. However, the precondition evaluation occurs after some request body handling rather than strictly prior to processing request content or actions, as the spec advises. This ordering deviation means that while the function clearly attempts to implement the precondition evaluation (C1), it does not fully conform to the ideal timing outlined by the RFC, resulting in a partial match.",success,
10359,dav_method_copymove,"An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",60,Fully Matches,"[{'C1': {'code': 'if (resource->type != DAV_RESOURCE_TYPE_REGULAR) {\n    body = apr_psprintf(r->pool,\n                        ""Cannot COPY/MOVE resource %s."",\n                        ap_escape_html(r->pool, r->uri));\n    return dav_error_response(r, HTTP_METHOD_NOT_ALLOWED, body);\n}', 'explanation': 'This code segment checks whether the resource type is not regular (i.e. not allowed for COPY/MOVE) and responds with HTTP_METHOD_NOT_ALLOWED (405), which directly implements the RFC requirement for a recognized method that is implemented but not allowed for the target resource.'}}]","The function dav_method_copymove contains specific logic to determine if a resource is eligible for COPY/MOVE. When the resource type is not DAV_RESOURCE_TYPE_REGULAR, the function immediately returns a 405 error, fulfilling the RFC specification that an origin server should respond with a 405 status code if the method is recognized and implemented but not allowed for the target resource. This implementation resides entirely in the function_body, satisfying the labeled constraint.",success,
10359,dav_method_copymove,A server generating a 401 (Unauthorized) response MUST send a WWW-Authenticate header field containing at least one challenge.,92,Partially Matches,"[{'C1': {'code': 'if (lookup.rnew->status != HTTP_OK) {\n    const char *auth = apr_table_get(lookup.rnew->err_headers_out, ""WWW-Authenticate"");\n    if (lookup.rnew->status == HTTP_UNAUTHORIZED && auth != NULL) {\n        apr_table_setn(r->err_headers_out, ""WWW-Authenticate"", apr_pstrdup(r->pool, auth));\n    }\n    return dav_error_response(r, lookup.rnew->status, ""Destination URI had an error."");\n}', 'explanation': 'This segment checks if the subrequest (lookup.rnew) returns a 401 Unauthorized status and, if so, propagates the WWW-Authenticate header to the response. This behavior attempts to address the RFC requirement for including at least one challenge in a 401 response. However, the implementation propagates a header only if supplied by the subrequest rather than ensuring that a challenge is constructed and provided in all cases.'}}]","The function contains a code segment that directly handles the case when a subrequest returns a 401 status by propagating an existing WWW-Authenticate header. This indicates an attempt to comply with the RFC requirement that a 401 response include at least one challenge. However, as the implementation depends on the subrequest providing the header, it only partially meets the RFC constraint when considered in isolation from other parts of the system.",success,
10359,dav_method_copymove,A server MAY generate a WWW-Authenticate header field in other response messages to indicate that supplying credentials (or different credentials) might affect the response.,93,Fully Matches,"[{'A1': {'code': 'if (lookup.rnew->status != HTTP_OK) {\n    const char *auth = apr_table_get(lookup.rnew->err_headers_out, ""WWW-Authenticate"");\n    if (lookup.rnew->status == HTTP_UNAUTHORIZED && auth != NULL) {\n        apr_table_setn(r->err_headers_out, ""WWW-Authenticate"", apr_pstrdup(r->pool, auth));\n    }\n    return dav_error_response(r, lookup.rnew->status,\n                              ""Destination URI had an error."");\n}', 'explanation': 'This code segment checks if the subrequest (lookup.rnew) resulted in an error. In particular, if the status is HTTP_UNAUTHORIZED and a WWW-Authenticate header exists, it propagates that header into the main response. This behavior satisfies the RFC requirement that a server MAY generate a WWW-Authenticate header in response messages (even outside of plain 401 responses) to indicate that supplying credentials might affect the response.'}}]","The function primarily implements COPY/MOVE operations but explicitly inspects the error subresponse for a WWW-Authenticate header when a 401 error occurs. By propagating the header from the subresponse to the client, it visibly implements the RFC provision regarding the generation of a WWW-Authenticate header in other response messages. Therefore, the function fully matches the relevant spec constraint, independent of other module dependencies.",success,
10359,dav_method_copymove,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The function dav_method_copymove focuses on handling WebDAV COPY/MOVE operations through resource resolution, precondition checking, error handling, and invoking hooks from the resource objects. While it does retrieve header values (e.g., using apr_table_get to get the 'Destination' header), there is no logic within this function that checks for or prevents the presence of multiple header field lines with the same name, nor does it address the requirement to preserve the ordering of such headers when forwarding a message. Thus, the code does not visibly implement any of the RFC constraints regarding duplicate header fields (the conditions that a sender MUST NOT generate multiple field lines with the same name unless permitted) or handle the ordering specified in the RFC.",success,
10359,dav_method_copymove,The server generating a 401 response MUST send a WWW-Authenticate header field (Section 11.6.1) containing at least one challenge applicable to the target resource.,162,Partially Matches,[],"The RFC mandates that when sending a 401 (Unauthorized) response, the server must include a WWW-Authenticate header containing at least one challenge. In the provided function, there is a code segment that checks if the destination subrequest resulted in an HTTP_UNAUTHORIZED status and, if so, it propagates a WWW-Authenticate header from the subrequest (see the block:

    if (lookup.rnew->status != HTTP_OK) {
        const char *auth = apr_table_get(lookup.rnew->err_headers_out, ""WWW-Authenticate"");
        if (lookup.rnew->status == HTTP_UNAUTHORIZED && auth != NULL) {
            apr_table_setn(r->err_headers_out, ""WWW-Authenticate"", apr_pstrdup(r->pool, auth));
        }
        return dav_error_response(r, lookup.rnew->status, ""Destination URI had an error."");
    }

). This indicates an attempt to comply with the RFC by ensuring that when a subrequest generates a 401, the header is forwarded to the client. However, this implementation is partial since it does not itself generate or verify the correctness of a WWW-Authenticate challenge in all cases where a 401 response might be generated—it merely relies on an upstream (subrequest) mechanism. Therefore, while some logic addressing the spec is visible, it does not fully implement the RFC requirement solely within this function.",success,
10359,dav_method_copymove,"Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method.",282,Partially Matches,"[{'C1': {'code': '/* check for any method preconditions */\nif (dav_run_method_precondition(r, resource, NULL, NULL, &err) != DECLINED\n        && err) {\n    return dav_handle_err(r, err, NULL);\n}\n\n...\n\n/* check for any method preconditions */\nif (dav_run_method_precondition(r, resource, resnew, NULL, &err) != DECLINED\n        && err) {\n    return dav_handle_err(r, err, NULL);\n}', 'explanation': 'The function makes explicit calls to evaluate preconditions (via dav_run_method_precondition) at two points – once after resolving the source resource and once after resolving the destination resource – ensuring that preconditions are checked before further processing (such as processing the request body). This partially meets the RFC requirement to evaluate received request preconditions after normal request checks and just before processing the request content.'}}]","The code function clearly addresses the evaluation of preconditions by calling helper functions (dav_run_method_precondition and dav_validate_request) before discarding the request body and performing the main actions of COPY or MOVE. However, it does not fully implement all aspects of the RFC as stated in the specification context (for example, the logic for ignoring preconditions if the unchecked request would result in a non-2xx or non-412 status is not handled explicitly within this function). As such, while the function does attempt to implement part of the RFC’s precondition evaluation requirements, it does not completely cover all the specified conditions and actions, leading to a 'Partially Matches' judgment.",success,
10360,dav_method_lock,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specifies that within a given message, a sender must not generate protocol elements or syntax alternatives that are reserved for participants in another role. In reviewing the code in dav_method_lock, there is no visible logic that validates or enforces that restriction. The function processes LOCK requests by parsing XML input, validating preconditions, and generating responses (including Lock-Token and lockdiscovery elements), but it does not check that the protocol elements generated are limited to the sender’s role. In essence, while the function implements the LOCK method handling, it does not explicitly implement any checks or constraints corresponding to the RFC requirement (e.g., a condition labeled C1 or action labeled A1) regarding role-specific element generation within the message. Therefore, based solely on the function_body, it does not visibly address the specified RFC constraint.",success,
10360,dav_method_lock,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC requires that a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. Within this function, while there is code that generates XML responses (such as outputting the XML header, <D:prop> element, and <D:lockdiscovery> block) and sets header values (like Lock-Token), there is no explicit logic that validates or ensures that these generated protocol elements adhere to the ABNF grammar. The function relies on hardcoded strings and delegated helper functions (e.g., dav_lock_get_activelock) without performing any in-function grammar checks. Since ensuring conformity to the ABNF is not implemented directly in this function (and any such logic in dependencies does not count), it does not satisfy the specified RFC requirement.",success,
10360,dav_method_lock,"Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method.",282,Partially Matches,"[{'C1': {'code': '/* check for any method preconditions */\nif (dav_run_method_precondition(r, resource, NULL, doc, &err) != DECLINED\n        && err) {\n    return dav_handle_err(r, err, NULL);\n}', 'explanation': 'This snippet shows an attempt to evaluate the request preconditions after initial processing, which corresponds to the RFC requirement to check preconditions before processing the request content. However, the full spectrum of the RFC’s precondition logic—such as ignoring them when the unconditional request would not yield a 2xx (or 412) response—is not fully implemented in this function.'}}]","The function partially implements the RFC’s requirement by calling dav_run_method_precondition to evaluate request preconditions after normal request checks and prior to processing the request content. This addresses a key part of the spec (labeled here as condition C1). However, additional aspects specified in the RFC (such as ignoring the preconditions based on the status of an unconditional check) are not handled in this code snippet. Therefore, the function only partially matches the specified constraints.",success,
10362,dav_method_vsn_control,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (resource->exists) {\n    /* cannot add resource to existing version history */\n    if (target != NULL) {\n        err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,\n                            ""<DAV:cannot-add-to-existing-history/>"");\n        return dav_handle_err(r, err, NULL);\n    }\n    ...\n}', 'explanation': ""This block ensures that when the resource already exists (i.e. the sender is not in the role to add new version history), any protocol element (the 'target' URI) that should only be generated by the appropriate role is rejected, thereby enforcing that the sender does not generate elements reserved for other roles.""}}, {'A1': {'code': 'if (!resource->exists && target == NULL) {\n    err = dav_new_error(r->pool, HTTP_CONFLICT, 0, 0,\n                        ""<DAV:initial-version-required/>"");\n    return dav_handle_err(r, err, NULL);\n}', 'explanation': ""This segment mandates that when versioning a non-existent (new) resource, the sender must supply a version URI. This forces the protocol elements to reflect the sender's role correctly by providing appropriate versioning details.""}}]","The function implements checks on the XML input to ensure that the version-control related protocol elements adhere to the constraints. In particular, it rejects version information when it is not permitted (i.e. when the resource already exists) and requires necessary elements when versioning a new resource. These checks partially implement the RFC requirement that a sender must not generate protocol elements or syntax alternatives that are only allowed for participants in other roles. However, the function does not cover every aspect of the spec (for example, it relies on other modules for certain validations), so it only partially matches the complete intent of the constraint.",success,
10362,dav_method_vsn_control,A sender MUST NOT send a connection option corresponding to a field that is intended for all recipients of the content.,252,Partially Matches,"[{'A1': {'code': '/* set the Cache-Control header, per the spec */\napr_table_setn(r->headers_out, ""Cache-Control"", ""no-cache"");', 'explanation': 'In two locations the function sets the Cache-Control header to ""no-cache"". The code comment explicitly mentions that this is done per the spec. This action ensures that Cache-Control is sent as a general response header and not as a connection option, which is in line with the RFC requirement.'}}]","The RFC specifies that a sender MUST NOT send a connection option corresponding to a field that is intended for all recipients, such as Cache-Control. In this function, the code sets the Cache-Control header properly as a general header (by calling apr_table_setn on r->headers_out) rather than placing it within a Connection header. However, aside from setting the header, the function provides no additional checks or logic to enforce that the header is not misused as a connection option. As the visible logic in the function deals with setting Cache-Control in a compliant manner but does not fully implement broader safeguards regarding connection options, the function only partially matches the spec constraint.",success,
10362,dav_method_vsn_control,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (doc != NULL) {\n    if (!dav_validate_root(doc, ""version-control"")) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00597) ""The request body does not contain ""version-control"" element."");\n        return HTTP_BAD_REQUEST;\n    }\n    \n    /* get the version URI */\n    if ((child = dav_find_child(doc->root, ""version"")) == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00598) ""The ""version-control"" element does not contain ""version"" element."");\n        return HTTP_BAD_REQUEST;\n    }\n    \n    if ((child = dav_find_child(child, ""href"")) == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00599) ""The ""version"" element does not contain an ""href"" element."");\n        return HTTP_BAD_REQUEST;\n    }\n    \n    /* get version URI */\n    apr_xml_to_text(r->pool, child, APR_XML_X2T_INNER, NULL, NULL, &target, &tsize);\n    if (tsize == 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00600) ""An ""href"" element does not contain a URI."");\n        return HTTP_BAD_REQUEST;\n    }\n}', 'explanation': 'This segment enforces a check on the XML request body, ensuring that the protocol element <version-control> and its required children (<version> and <href>) are present. This is an attempt to validate that the incoming protocol elements match the expected grammar as dictated by the RFC.'}}]","The provided function validates the structure of the incoming XML request by checking for mandatory elements in the protocol message (i.e., <version-control>, <version>, and <href>). This demonstrates some effort to ensure that the protocol elements match a defined grammar. However, the check is limited to the presence of expected XML elements and does not fully encompass comprehensive ABNF rule validation or generation considerations. Therefore, while the function does address part of the RFC requirement (labeled as C1), it does not fully implement all aspects of the RFC specification on protocol element generation.",success,
10362,dav_method_vsn_control,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The RFC specification requires that any context information (such as that from a Content-Location header) must not be used by the origin server to alter the request semantics. Within this function, there is no handling or inspection of any Content-Location header or similar request context information. The function focuses solely on version-control operations and does not include logic that processes or intentionally ignores Content-Location data in a way that confirms adherence to the spec requirement. Because nothing in the function directly addresses the constraint to not modify request semantics based on context information, it does not visibly implement this aspect of the RFC.",success,
10363,dav_method_checkout,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (doc != NULL) {\n    if (!dav_validate_root(doc, ""checkout"")) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00601)\n                      ""The request body, if present, must be a ""\n                      ""DAV:checkout element."");\n        return HTTP_BAD_REQUEST;\n    }\n    ...\n}', 'explanation': ""This segment checks that if a request payload is present, its root element is 'checkout', thereby enforcing that the protocol element conforms to the expected XML grammar as required by the spec. This demonstrates an attempt to ensure that only valid protocol elements (matching the ABNF grammar) are processed.""}}]","The function implements some checks to ensure that the incoming XML (protocol element) adheres to the expected grammar (specifically, that the root element is 'checkout'). It also performs additional validations (e.g., for mutually exclusive header usage and required sub-elements in 'activity-set'), which further indicate an effort to enforce proper protocol syntax. However, while it does verify the grammar of the input, it does not explicitly address all aspects of the RFC requirement concerning generation of only valid protocol elements (for example, other protocol elements generated as part of the response are not similarly validated within this function). Therefore, the implementation is considered to partially match the spec's constraints.",success,
10363,dav_method_checkout,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (doc != NULL) {\n    if (!dav_validate_root(doc, ""checkout"")) {\n        /* This supplies additional information for the default msg. */\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00601)\n                      ""The request body, if present, must be a ""\n                      ""DAV:checkout element."");\n        return HTTP_BAD_REQUEST;\n    }\n    ...\n}', 'explanation': ""The code ensures that when a request body is present, its root element must be 'checkout', thereby validating that the generated protocol element adheres to expected syntax, as would be required by the RFC specification.""}}, {'A1': {'code': 'if (dav_find_child(doc->root, ""apply-to-version"") != NULL) {\n    if (apr_table_get(r->headers_in, ""label"") != NULL) {\n        /* ### we want generic 403/409 XML reporting here */\n        /* ### DAV:must-not-have-label-and-apply-to-version */\n        return dav_error_response(r, HTTP_CONFLICT,\n                                  ""DAV:apply-to-version cannot be used in conjunction with a Label header."");\n    }\n    apply_to_vsn = 1;\n}', 'explanation': ""This segment prevents the use of the 'apply-to-version' element together with a Label header, thereby stopping protocol elements from being generated in roles not permitted by the sender. This aligns with the RFC's requirement that a sender must not generate protocol elements or syntax alternatives allowed only for other roles.""}}]","The dav_method_checkout function performs input validation on the XML body of the checkout request by ensuring that the root element is 'checkout' and by disallowing forbidden protocol element combinations (such as 'apply-to-version' with a Label header). These checks address some of the role-related restrictions imposed by the RFC; however, not every possible constraint or action of the RFC is enforced entirely within this function. Therefore, the implementation is assessed as partially matching the RFC requirements.",success,
10363,dav_method_checkout,"Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method.",282,Fully Matches,"[{'C1': {'code': '/* check for any method preconditions */\nif (dav_run_method_precondition(r, resource, NULL, doc, &err) != DECLINED\n        && err) {\n    return dav_handle_err(r, err, NULL);\n}', 'explanation': 'This segment evaluates the request preconditions immediately after performing the normal request checks (e.g. resolving the resource) and before executing the checkout action. It thereby meets the RFC requirement that preconditions be evaluated just before processing the request content or taking the associated action.'}}, {'A1': {'code': 'if ((err = (*vsn_hooks->checkout)(resource, 0 /*auto_checkout*/,\n                                  is_unreserved, is_fork_ok,\n                                  create_activity, activities,\n                                  &working_resource)) != NULL) {\n    err = dav_push_error(r->pool, HTTP_CONFLICT, 0,\n                         apr_psprintf(r->pool,\n                                      ""Could not CHECKOUT resource %s."",\n                                      ap_escape_html(r->pool, r->uri)),\n                         err);\n    return dav_handle_err(r, err, NULL);\n}', 'explanation': 'This code performs the checkout action only after preconditions have been evaluated, aligning with the RFC requirement to postpone processing until preconditions are checked. This confirms that the method action is gated by the precondition check.'}}]","The function first performs its normal checks (e.g. validating XML input, resolving the resource) and then explicitly evaluates the request preconditions by calling the dav_run_method_precondition routine. Only after a successful precondition check does it proceed to perform the checkout action. This sequencing – checking preconditions just before executing the main action – is in direct conformity with the RFC specification. Therefore, the function visibly and self‐containedly implements the necessary aspects of the RFC requirement.",success,
10363,dav_method_checkout,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'return dav_created(r, working_resource->uri, ""Checked-out resource"", 0);', 'explanation': 'This call returns a response that uses the working_resource->uri when a new working resource is created. The dav_created function is expected to set the Location header field according to the HTTP spec, thus fulfilling the requirement.'}}]","The provided function implements the key part of the specification by ensuring that when a new working resource is created (i.e., when working_resource is not NULL), it returns a response using dav_created with the working_resource URI. This call is expected to produce a Location header field as required by the RFC. Since this logic is present within the function, the function fully meets the constraint.",success,
10364,dav_method_uncheckout,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Partially Matches,"[{'A1': {'code': 'ap_set_content_length(r, 0);', 'explanation': 'This line explicitly sets the Content-Length header to zero when no response body is present, which is in keeping with the RFC recommendation that a server SHOULD generate an encoding or length-delimited message whenever possible.'}}]","The function partially implements the RFC requirement by ensuring that the response is length-delimited when no body is sent via the call to ap_set_content_length(r, 0). However, the function does not address other parts of the RFC specification related to handling invalid Content-Length headers or other framing conditions mentioned in the context. As a result, only a part of the spec is addressed directly within this function.",success,
10364,dav_method_uncheckout,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'A1': {'code': 'ap_set_content_length(r, 0);', 'explanation': ""This line explicitly sets the Content-Length header to 0, which aligns with the specification that when no response body is sent (and the content length is known), the header should be provided. However, the function does not handle all cases (such as checking for Transfer-Encoding or dealing with specific status codes like 1xx, 204, or CONNECT requests) mentioned in the RFC's context.""}}]","The function does address a portion of the RFC requirement by setting the Content-Length header when the response is known to have no body. The call to ap_set_content_length(r, 0) implements the action to send a Content-Length header for a zero-length message body, which is appropriate per the spec when the content size is known. However, the function does not consider the additional restrictions (e.g., omitting Content-Length in responses with status codes 1xx, 204, or in 2xx responses to CONNECT requests, nor does it inspect Transfer-Encoding), so only part of the described RFC behavior is implemented within this function.",success,
10364,dav_method_uncheckout,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The provided function does not address the HTTP RFC requirement regarding the handling of an incorrect Content-Length header. Although the function sets the Content-Length header to 0 in the response (using ap_set_content_length(r, 0);), it does not perform any validation on the incoming Content-Length header value nor does it reject or correct a message with an incorrect Content-Length value. The RFC states that a sender MUST NOT forward a message with a known incorrect Content-Length header, but no such check or logic exists within this function. Thus, the function does not implement any of the spec constraints.",success,
10365,dav_method_checkin,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (doc != NULL) {\n    if (!dav_validate_root(doc, ""checkin"")) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00603)\n                      ""The request body, if present, must be a ""\n                      ""DAV:checkin element."");\n        return HTTP_BAD_REQUEST;\n    }\n\n    keep_checked_out = dav_find_child(doc->root, ""keep-checked-out"") != NULL;\n}', 'explanation': ""This segment validates that if a request body is present, its root element is 'checkin', thereby checking that a protocol element adheres to its defined grammar. This is a visible attempt to enforce a constraint related to ensuring that generated (or processed) protocol elements match the expected ABNF grammar.""}}]","The function attempts to satisfy part of the RFC requirement by validating the XML input (if present) to ensure it conforms to the expected grammar (DAV:checkin element). However, it does not comprehensively address all aspects of the spec—specifically, it does not fully ensure that all protocol elements it may generate throughout the checkin process conform to the ABNF grammar. As such, while some labeled constraint (here, C1) is met within the function, other aspects of the specification remain unaddressed in this code segment, leading to a 'Partially Matches' judgment.",success,
10365,dav_method_checkin,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (doc != NULL) {\n    if (!dav_validate_root(doc, ""checkin"")) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00603)\n                      ""The request body, if present, must be a DAV:checkin element."");\n        return HTTP_BAD_REQUEST;\n    }\n    keep_checked_out = dav_find_child(doc->root, ""keep-checked-out"") != NULL;\n}', 'explanation': ""This segment checks whether the incoming XML document has a root element of 'checkin'. It aims at enforcing that if a message body is present, it adheres to the expected DAV:checkin syntax. This is in line with preventing the inclusion of protocol elements that do not match the defined grammar.""}}]","The function validates that the request body, when provided, has a root element 'checkin', which is a visible attempt to enforce the proper messaging syntax. However, the RFC requirement also states that a sender MUST NOT generate protocol elements reserved for other roles. This function does not enforce role-based restrictions (i.e. it does not check whether the sender is authorized to generate certain protocol elements), and it defers many other validations (such as preconditions and resource states) to external calls. Therefore, while it implements a part of the spec (syntax validation as indicated in constraint C1), it does not fully implement the role-specific limitations prescribed by the RFC.",success,
10366,dav_method_update,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if ((child = dav_find_child(doc->root, ""label-name"")) != NULL)\n    is_label = 1;\nelse if ((child = dav_find_child(doc->root, ""version"")) != NULL) {\n    if ((child = dav_find_child(child, ""href"")) == NULL) {\n        ap_log_rerror(...);\n        return HTTP_BAD_REQUEST;\n    }\n}\nelse {\n    ap_log_rerror(...);\n    return HTTP_BAD_REQUEST;\n}', 'explanation': ""This block enforces that the update message contains one—and only one—of the permissible elements (either a 'label-name' or a 'version' containing an 'href'). This helps ensure that the sender has not included protocol elements that it should not generate, partially meeting the RFC’s requirement concerning generation of protocol elements based on roles.""}}, {'A1': {'code': 'if (!is_label && depth != 0) {\n    ap_log_rerror(...);\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'Here the code verifies that when a version (rather than a label) is used, the depth must be zero. This additional check aids in maintaining protocol integrity by rejecting inappropriate settings, which aligns with ensuring that protocol elements and behaviors are correctly generated based on role.'}}]","The dav_method_update function inspects the incoming XML request for an 'update' element and then verifies that it contains exactly one of the allowed child elements ('label-name' or 'version' with an 'href'). Additionally, it checks that the depth header complies with constraints applicable to the type of update. These checks partially implement the RFC requirement that a sender must not generate protocol elements or syntax alternatives only allowed for other roles. However, the function does not include explicit role-based verification beyond these structural validations, and some aspects of the RFC constraint are likely handled elsewhere in the system. Thus, the implementation in this function is only a partial match to the given RFC specification.",success,
10366,dav_method_update,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if ((result = ap_xml_parse_input(r, &doc)) != OK) {\n    return result;\n}\n\nif (doc == NULL || !dav_validate_root(doc, ""update"")) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00604)\n                  ""The request body does not contain ""\n                  ""an \\""update\\"" element."");\n    return HTTP_BAD_REQUEST;\n}', 'explanation': ""This segment shows the defensive parsing of the XML request body. It uses an XML parser and validates that the root element is 'update', ensuring that the protocol element conforms at least marginally to expectations before proceeding.""}}, {'A1': {'code': 'if ((child = dav_find_child(doc->root, ""label-name"")) != NULL)\n    is_label = 1;\nelse if ((child = dav_find_child(doc->root, ""version"")) != NULL) {\n    if ((child = dav_find_child(child, ""href"")) == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00605)\n                      ""The version element does not contain ""\n                      ""an \\""href\\"" element."");\n        return HTTP_BAD_REQUEST;\n    }\n}\nelse {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00606)\n                  ""The \\""update\\"" element does not contain ""\n                  ""a \\""label-name\\"" or \\""version\\"" element."");\n    return HTTP_BAD_REQUEST;\n}\n\napr_xml_to_text(r->pool, child, APR_XML_X2T_INNER, NULL, NULL,\n                &target, &tsize);\nif (tsize == 0) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00608)\n                  ""A \\""label-name\\"" or \\""href\\"" element does not contain ""\n                  ""any content."");\n    return HTTP_BAD_REQUEST;\n}', 'explanation': ""This code verifies that either a 'label-name' or a 'version' element is present in the XML, confirms that the 'version' element contains an 'href' sub-element when needed, and checks that the content is non-empty. It defensively validates the received protocol element and returns appropriate errors when the input does not match expectations.""}}]","The function implements defensive parsing as recommended by the RFC: it parses the XML input, checks that the root element is as expected, validates the presence and non‐emptiness of required child elements, and responds with clear error codes (e.g., HTTP_BAD_REQUEST) when the input does not conform. This logic, contained solely within the function_body, fully meets the specification’s directive to parse protocol elements defensively.",success,
10366,dav_method_update,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (doc == NULL || !dav_validate_root(doc, ""update"")) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00604)\n                  ""The request body does not contain ""\n                  ""an \\""update\\"" element."");\n    return HTTP_BAD_REQUEST;\n}\n\n/* check for label-name or version element, but not both */\nif ((child = dav_find_child(doc->root, ""label-name"")) != NULL)\n    is_label = 1;\nelse if ((child = dav_find_child(doc->root, ""version"")) != NULL) {\n    /* get the href element */\n    if ((child = dav_find_child(child, ""href"")) == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00605)\n                      ""The version element does not contain ""\n                      ""an \\""href\\"" element."");\n        return HTTP_BAD_REQUEST;\n    }\n} else {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00606)\n                  ""The \\""update\\"" element does not contain ""\n                  ""a \\""label-name\\"" or \\""version\\"" element."");\n    return HTTP_BAD_REQUEST;\n}', 'explanation': ""This segment shows that the function parses the incoming XML, checks for an 'update' element and validates its children (either 'label-name' or 'version' with its 'href'). This inline check implements the requirement that a received protocol element is interpreted according to the semantics defined by the spec.""}}]","The function demonstrates logic that examines the XML request body and enforces the presence and the structure of an 'update' element, which aligns with the RFC requirement that a recipient must interpret a received protocol element according to its defined semantics. However, other aspects mentioned in the RFC—such as extended error recovery strategies or handling cases where the sender implements things incorrectly—are either delegated to other components or not fully implemented within this function. Therefore, while part of the spec (condition C1) is addressed directly in the function, the full spectrum of requirements is not entirely handled here, leading to a 'Partially Matches' outcome.",success,
10366,dav_method_update,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (doc == NULL || !dav_validate_root(doc, ""update"")) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00604)\n                  ""The request body does not contain an \\""update\\"" element."");\n    return HTTP_BAD_REQUEST;\n}\n\n...\n\nif (tsize == 0) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00608)\n                  ""A \\""label-name\\"" or \\""href\\"" element does not contain any content."");\n    return HTTP_BAD_REQUEST;\n}', 'explanation': ""This code segment validates that the XML request body conforms to a minimal grammar: it must have an 'update' root element and either a 'label-name' or a 'version' (with an 'href') element containing non‐empty text. This enforces part of the RFC requirement that generated protocol elements adhere to the defined ABNF grammar. However, it only covers input validation and not all aspects (such as role‐specific syntactic generation) of the spec.""}}]","The function shows visible logic that enforces parts of the HTTP RFC requirement by checking that the incoming XML message conforms to the expected grammar (e.g., having an 'update' element with the proper subelements and non-empty content). This validation helps ensure that the protocol elements generated or processed by this sender adhere to the defined ABNF rules. However, since the function does not deal with every aspect of generating protocol elements (for example, role‐specific syntax alternatives) and delegates some checks to external calls, it only partially implements the overall constraints described in the RFC specification.",success,
10367,dav_label_walker,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided code function (dav_label_walker) does not address the specific RFC requirement regarding the handling of context information (i.e., the Content-Location header) so that it is not used to alter the request semantics. The function is solely focused on label operations and version resource verification without any logic that considers or preserves the original semantics of request context information as described in the spec. Therefore, none of the labeled conditions or actions (C1, A1, etc.) are visibly implemented within this function.",success,
10367,dav_label_walker,The server SHOULD generate content that includes enough information for a user to recognize the source of the conflict.,291,Fully Matches,"[{'A1': {'code': 'if (err != NULL) {\n    dav_add_response(wres, err->status, NULL);\n    wres->response->desc = err->desc;\n}', 'explanation': 'This code block creates an HTTP_CONFLICT response (409) and sets the response description to the error\'s description (e.g., ""<DAV:must-be-version-or-version-selector/>""). This fulfills the RFC requirement that the server generate content that includes sufficient information for the user to recognize the source of the conflict.'}}]","The function checks several conditions on the resource. When a conflict is detected (for instance, due to an inappropriate resource type or being checked out), it constructs an error with the 409 (Conflict) status and assigns an XML description to it. This description is then added to the response, thereby providing information to help the user identify the conflict. Although the code contains comments about future improvements, the logic present in the function itself directly addresses the RFC’s mandate for conflict content generation.",success,
10368,dav_method_label,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Does Not Match,[],"The RFC states that a sender MUST NOT send a Content-Length header if a Transfer-Encoding header is present. In this function, the Content-Length header is set unconditionally (using ap_set_content_length(r, 0)) without any check to determine whether a Transfer-Encoding header field exists in the message. There is no logic within the function that prevents setting Content-Length when Transfer-Encoding is present. Therefore, the function does not address the specified RFC constraint.",success,
10368,dav_method_label,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (doc == NULL || !dav_validate_root(doc, ""label"")) {\n    ap_log_rerror(...);\n    return HTTP_BAD_REQUEST;\n}\n\n/* check for add, set, or remove element */\nif ((child = dav_find_child(doc->root, ""add"")) != NULL) {\n    ctx.label_op = DAV_LABEL_ADD;\n}\nelse if ((child = dav_find_child(doc->root, ""set"")) != NULL) {\n    ctx.label_op = DAV_LABEL_SET;\n}\nelse if ((child = dav_find_child(doc->root, ""remove"")) != NULL) {\n    ctx.label_op = DAV_LABEL_REMOVE;\n}\nelse {\n    ap_log_rerror(...);\n    return HTTP_BAD_REQUEST;\n}\n\n/* get the label string */\nif ((child = dav_find_child(child, ""label-name"")) == NULL) {\n    ap_log_rerror(...);\n    return HTTP_BAD_REQUEST;\n}\n\napr_xml_to_text(r->pool, child, APR_XML_X2T_INNER, NULL, NULL, &ctx.label, &tsize);\nif (tsize == 0) {\n    ap_log_rerror(...);\n    return HTTP_BAD_REQUEST;\n}', 'explanation': ""The function checks that the received XML follows the expected structure (e.g. contains a 'label' root, one of 'add', 'set', or 'remove' elements, and a non-empty 'label-name') to ensure that only protocol elements conforming to the expected grammar are processed. This corresponds to the RFC requirement that a sender must not generate or handle protocol elements that do not match the defined grammar.""}}, {'A1': {'code': 'apr_table_setn(r->headers_out, ""Cache-Control"", ""no-cache"");', 'explanation': 'The function sets the Cache-Control header as required by the spec to ensure proper HTTP behavior, matching an action defined in the RFC.'}}]","The function demonstrates visible logic addressing the RFC constraint by validating the incoming XML request against an expected structure (thereby ensuring that protocol elements adhere to the defined grammar) and by setting a proper HTTP header. However, while it validates incoming protocol elements and sets required headers, it does not cover all aspects of the sender’s responsibilities as laid out in the RFC. Therefore, the function partially matches the specified RFC requirements based solely on its isolated logic.",success,
10368,dav_method_label,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, dav_method_label, focuses on parsing and processing a WebDAV LABEL request by validating its XML body, ensuring required elements (""label"", ""add""/""set""/""remove"", ""label-name"") are present, and handling errors accordingly. However, it does not include any logic that checks whether the generated protocol elements are restricted to the sender's role as mandated by the RFC (i.e., ensuring that protocol elements are not generated for roles to which the sender does not belong). No part of the function inspects or enforces role-based constraints as described in the RFC specification. Thus, the function does not visibly address the specific requirement stated in the RFC.",success,
10368,dav_method_label,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'A1': {'code': '    /* set the Cache-Control header, per the spec */\n    apr_table_setn(r->headers_out, ""Cache-Control"", ""no-cache"");', 'explanation': ""This code segment explicitly sets the 'Cache-Control' header to 'no-cache' as required by the RFC action, ensuring that the response reflects the appropriate caching directive.""}}]","The RFC calls for defensive parsing of protocol elements, accepting that the received element may only marginally conform to its ABNF grammar and be within a reasonable size. This function implements defensive parsing by using ap_xml_parse_input to process the XML body, checking that the document has a 'label' root element and then ensuring that one of the expected sub-elements ('add', 'set', or 'remove') is present along with a non-empty 'label-name'. These checks address part of the defensive parsing requirement. However, the function does not explicitly check or enforce any maximum length or buffer size constraints apart from ensuring a non-zero label text size. As a result, while it partially meets the defensive parsing expectation, it does not fully implement all aspects (such as explicit handling of buffer size limits) stated in the RFC specification. Therefore, only the action of setting the Cache-Control header (A1) is fully implemented in the function, and overall the function only partially matches the complete intent of the specification.",success,
10368,dav_method_label,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Fully Matches,"[{'A1': {'code': '/* no body */\nap_set_content_length(r, 0);', 'explanation': 'The code explicitly sets the Content-Length header to 0, which complies with the RFC requirement to include a Content-Length header when the size of the content is known (here, known to be zero).'}}]","The provided function, after completing its processing of the LABEL operation, explicitly sets the Content-Length header by calling ap_set_content_length(r, 0). This demonstrates an attempt to conform to the RFC specification that, in the absence of Transfer-Encoding, a Content-Length header should be sent when the content size is known. Although the RFC also defines exceptional cases (such as for 1xx or 204 status responses), this function is processing a LABEL method and not one of those exceptional cases. Therefore, within the context of this function, the implementation fully matches the relevant part of the spec.",success,
10371,dav_method_report,An origin server that receives a request method that is unrecognized or not implemented SHOULD respond with the 501 (Not Implemented) status code.,59,Fully Matches,"[{'C1': {'code': 'case DECLINED:\n        /* No one handled the report */\n        return HTTP_NOT_IMPLEMENTED;', 'explanation': 'This code segment checks if no report handler has processed the request (result equals DECLINED) and then returns HTTP_NOT_IMPLEMENTED (501), which aligns with the RFC requirement for sending a 501 status code when a method is not implemented.'}}]","The function 'dav_method_report' directly addresses the RFC specification by returning a 501 (Not Implemented) status when the report method is not handled (i.e., unrecognized or not implemented). The implementation in the switch statement effectively captures the required behavior solely within the function, thereby fully matching the specified condition.",success,
10371,dav_method_report,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if ((result = ap_xml_parse_input(r, &doc)) != OK) {\n    return result;\n}\nif (doc == NULL) {\n    /* This supplies additional information for the default msg. */\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00614)\n                  ""The request body must specify a report."");\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'This code segment calls a strict XML parser and checks that a valid XML document is present, effectively ensuring that any protocol elements (the report) are parsed according to a predefined grammar. This indirectly addresses the requirement that the sender generate protocol elements that match the ABNF-defined grammar. However, the function does not explicitly perform any additional grammar validation for generated responses.'}}]","The provided function partially addresses the RFC constraint by ensuring that incoming XML content complies with the expected format (thereby indirectly ensuring that protocol elements follow the correct grammar). The use of ap_xml_parse_input and the subsequent check for a valid document (C1) ensures that the report is only processed if it conforms to the required grammar. However, other aspects of generating protocol elements, including ensuring that only allowed elements are produced, are delegated to external hooks (e.g., dav_run_deliver_report) and are not explicitly verified within this function. Therefore, the function only partially matches the full scope of the specification.",success,
10371,dav_method_report,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function dav_method_report primarily deals with parsing the XML input, retrieving and validating the resource, and then delivering a report. Although it calls a hook (report_label_header_allowed) to check if a Target-Selector header is allowed, this check is delegated and does not directly ensure that protocol elements or syntax alternatives intended for other roles are not generated. There is no direct logic in the function that verifies or enforces the specific RFC constraint requiring a sender to avoid generating protocol elements reserved for other roles. Therefore, there is no visible implementation of the labeled condition in the provided code.",success,
10371,dav_method_report,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'ap_set_content_type_ex(r, DAV_XML_CONTENT_TYPE, 1);', 'explanation': 'This call explicitly sets the Content-Type header for the response, satisfying the RFC requirement that a sender generating a message with content should include a Content-Type header field.'}}]","The function dav_method_report, when generating the response for a REPORT method, includes a call to set the Content-Type header (via ap_set_content_type_ex). This directly implements the action from the RFC specification that a sender generating a message with content should include a Content-Type header, provided that the media type is known. Although the RFC also mentions the exception when the media type is unknown, the function uses a defined constant (DAV_XML_CONTENT_TYPE) to always set the header, indicating that the media type is known. All logic related to generating the Content-Type header is contained within this function, and thus in isolation this function fulfills the specified constraint.",success,
10372,dav_method_make_workspace,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (doc == NULL\n        || !dav_validate_root(doc, ""mkworkspace"")) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00615)\n                      ""The request body does not contain ""\n                      ""a \\""mkworkspace\\"" element."");\n        return HTTP_BAD_REQUEST;\n    }', 'explanation': ""This segment validates the XML request body by ensuring that the root element is 'mkworkspace', which is an attempt to enforce that only protocol elements matching the defined grammar are processed. It thus partially satisfies the constraint that a sender must not generate protocol elements that do not match the designated ABNF rules.""}}]","The function shows visible logic aimed at complying with the requirement by validating the XML grammar of the incoming request (ensuring the presence of a 'mkworkspace' element) and rejecting requests that do not conform. However, the function does not encompass all aspects of the RFC—in particular, it relies on other functions (such as dav_created) for generating the response payload, and it does not independently verify that all generated protocol elements strictly adhere to the ABNF grammar. As such, it only partially matches the specification.",success,
10372,dav_method_make_workspace,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function primarily handles workspace creation by parsing the input XML for a 'mkworkspace' element, checking preconditions, and then calling a provider hook to create the workspace. There is no visible logic in this function that addresses the RFC requirement which states that a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. In other words, the function does not include any specific checks or restrictions regarding the generation of protocol elements reserved for other roles, and thus does not visibly implement the RFC constraint.",success,
10372,dav_method_make_workspace,"An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",271,Does Not Match,[],"The provided function, dav_method_make_workspace, implements making a workspace, including parsing an XML body for a mkworkspace element, checking preconditions, and setting a Cache-Control header. However, it does not contain any logic addressing the RFC specification that states 'An origin server SHOULD NOT rely on private agreements to receive content.' There is no code in the function that checks or prevents relying on private agreements, nor is there any mechanism that validates the absence of such agreements in the request processing. As a result, the function does not visibly address or implement the specified requirement.",success,
10375,dav_method_merge,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (doc == NULL || !dav_validate_root(doc, ""merge"")) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00616)\n                  ""The request body must be present and must be a DAV:merge element."");\n    return HTTP_BAD_REQUEST;\n}\n\nif ((source_elem = dav_find_child(doc->root, ""source"")) == NULL) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00617)\n                  ""The DAV:merge element must contain a DAV:source element."");\n    return HTTP_BAD_REQUEST;\n}\n\nif ((href_elem = dav_find_child(source_elem, ""href"")) == NULL) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00618)\n                  ""The DAV:source element must contain a DAV:href element."");\n    return HTTP_BAD_REQUEST;\n}', 'explanation': ""These code segments validate the structure of the request by ensuring that the root element is 'merge' and that the required child elements ('source' and 'href') are present. This addresses the need to enforce the request's conformance to the expected XML grammar, which is related to the RFC requirement that protocol elements match the defined ABNF rules.""}}]","The function implements several checks on the XML structure of the incoming MERGE request which partially fulfills the RFC requirement that a sender must only generate protocol elements compliant with the defined grammar. However, while it verifies that the incoming message adheres to expected structure, it does not fully address all aspects of generating protocol elements (for example, ensuring that no extraneous or incorrect elements are produced in any outgoing message). As a result, the implementation in the function partially matches the RFC constraints by validating required elements, but it does not cover the complete set of constraints or actions implied by the specification.",success,
10375,dav_method_merge,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC requirement specifies that within a given message the sender must not generate protocol elements or syntax alternatives reserved for other roles. In the function_body, although there is logic to validate the structure of the received XML (ensuring a DAV:merge element with required sub‐elements such as DAV:source and DAV:href) and to enforce some preconditions, there is no explicit check or enforcement that prevents the generation of protocol elements that are only allowed for other roles. The comments even hint at gaps (e.g., regarding elements from DAV:checkout) which further indicates that the role‑based constraints are not handled within this function. Consequently, the function does not address the labeled RFC constraint within its own implementation.",success,
10375,dav_method_merge,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'ap_set_content_type_ex(r, ""text/xml"", 1);', 'explanation': 'The RFC specifies that if a message contains content the sender SHOULD generate a Content-Type header. In this function, this is implemented by explicitly setting the Content-Type header using ap_set_content_type_ex, thereby meeting the requirement.'}}]","The function_body ensures that a Content-Type header is included in the response message by invoking ap_set_content_type_ex with a defined media type ('text/xml'). This visible implementation meets the RFC’s requirement for including a Content-Type header when content is generated, and no further checks (such as verifying if the media type is unknown) are needed because the function assumes a known media type. Hence, the function fully matches the specified RFC constraint.",success,
10376,dav_method_bind,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function, dav_method_bind, does not contain any logic that explicitly validates or enforces that the protocol elements conform to the ABNF grammar as required by the RFC specification. Although the function checks for the presence of mandatory headers (such as the Destination header) and returns appropriate HTTP error codes when conditions are not met, it does not perform any parsing or validation against the formal ABNF defined grammar. Thus, no specific labeled conditions (e.g., C1) or actions (e.g., A1) that directly implement the constraint of only generating valid protocol elements are fully implemented within this function.",success,
10376,dav_method_bind,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function implements the BIND method processing for a WebDAV (HTTP) server by performing various checks such as validating headers, resource existence, preconditions, proper destination handling, etc. However, none of its internal logic addresses the specific RFC requirement: 'Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles.' There is no explicit check that prevents protocol elements meant for a different sender role from being generated. All error handling and resource validation are implemented, but they do not cover the constraint regarding role-specific generation of protocol elements. Therefore, the function does not visibly implement the labeled spec requirement.",success,
10376,dav_method_bind,"Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method.",282,Partially Matches,"[{'C1': {'code': '    /* check for any method preconditions */\n    if (dav_run_method_precondition(r, resource, NULL, NULL, &err) != DECLINED\n            && err) {\n        return dav_handle_err(r, err, NULL);\n    }\n\n    ...\n\n    /* check for any method preconditions */\n    if (dav_run_method_precondition(r, resource, binding, NULL, &err) != DECLINED\n            && err) {\n        return dav_handle_err(r, err, NULL);\n    }', 'explanation': ""The function explicitly calls 'dav_run_method_precondition' before proceeding with further actions, which demonstrates that it is evaluating request preconditions as mandated by the RFC. This addresses the requirement to check preconditions after normal request processing but before processing the request content or performing the action.""}}]","The function includes logic to evaluate request preconditions by invoking 'dav_run_method_precondition' at key points—after the initial resource retrieval and again after resolving the destination binding resource. This indicates an attempt to implement the spec requirement that preconditions be evaluated after normal request checks and before executing the main method action. However, the function does not handle all aspects of the RFC context, such as conditional ignoring of preconditions based on earlier error responses or for methods not involving representation selection/modification. Thus, while the code addresses part of the specification (condition C1), it only partially matches the complete set of spec constraints.",success,
10377,dav_handler,A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.,30,Does Not Match,[],"The provided function (dav_handler) focuses on dispatching HTTP methods and setting allowed methods for various DAV and HTTP operations. It does not contain any logic to handle protocol switching (e.g., checking if the received request semantics allow switching protocols, sending a 101 Switching Protocols response, or any handling for Upgrade header fields) as required by the RFC specification. Even though the OPTIONS request is dispatched via dav_method_options (which would be acceptable under any protocol), the function itself does not implement the necessary checks or actions for switching protocols. Therefore, it does not meet any of the specific conditions (e.g., C1) or actions (e.g., A1) outlined in the RFC specification.",success,
10398,dav_lock_get_activelock,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,[],"The provided function constructs XML for an activelock element using hard-coded XML tags and formatted strings. In doing so, it appears intended to generate protocol elements that adhere to a known XML grammar. However, it does not explicitly verify or enforce conformity with an ABNF grammar as demanded by the spec. For example, while the function uses fixed XML elements (e.g., ""<D:activelock>"", ""<D:locktype>"", etc.) to generate its output, there is no explicit check or validation against the ABNF definitions, and the debug branch even produces a deliberately malformed output to indicate an error. Consequently, although the function makes an attempt by constructing XML in a structured manner, it does not implement a complete solution that guarantees all generated protocol elements match the ABNF grammar. Therefore, this function only partially addresses the specified requirement.",success,
10398,dav_lock_get_activelock,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function solely focuses on generating XML fragments for active locks without verifying any role-based limitations as required by the spec. The RFC specification mandates that a sender must not generate protocol elements or syntax alternatives that are reserved for other roles. In this function, there is no logic to check or restrict protocol element generation based on the sender's role, nor is there any validation against the ABNF grammar for role-specific elements. Thus, the function does not visibly address the spec constraint within its own implementation.",success,
10399,dav_lock_parse_lockinfo,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (!dav_validate_root(doc, ""lockinfo"")) {\n    return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,\n                         ""The request body contains an unexpected ""\n                         ""XML root element."");\n}\n\nfor (child = doc->root->first_child; child; child = child->next) {\n    if (strcmp(child->name, ""locktype"") == 0\n        && child->first_child\n        && lock->type == DAV_LOCKTYPE_UNKNOWN) {\n        if (strcmp(child->first_child->name, ""write"") == 0) {\n            lock->type = DAV_LOCKTYPE_WRITE;\n            continue;\n        }\n    }\n    if (strcmp(child->name, ""lockscope"") == 0\n        && child->first_child\n        && lock->scope == DAV_LOCKSCOPE_UNKNOWN) {\n        if (strcmp(child->first_child->name, ""exclusive"") == 0)\n            lock->scope = DAV_LOCKSCOPE_EXCLUSIVE;\n        else if (strcmp(child->first_child->name, ""shared"") == 0)\n            lock->scope = DAV_LOCKSCOPE_SHARED;\n        if (lock->scope != DAV_LOCKSCOPE_UNKNOWN)\n            continue;\n    }\n\n    if (strcmp(child->name, ""owner"") == 0 && lock->owner == NULL) {\n        const char *text;\n        apr_xml_quote_elem(p, child);\n        apr_xml_to_text(p, child, APR_XML_X2T_FULL_NS_LANG, doc->namespaces,\n                        NULL, &text, NULL);\n        lock->owner = text;\n        continue;\n    }\n\n    return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0, 0,\n                         apr_psprintf(p,\n                                     ""The server cannot satisfy the ""\n                                     ""LOCK request due to an unknown XML ""\n                                     ""element (\\""%s\\"") within the ""\n                                     ""DAV:lockinfo element."",\n                                     child->name));\n}', 'explanation': ""This segment checks that the XML conforms to an expected structure by enforcing that the root element is 'lockinfo' and only allowing known child elements ('locktype', 'lockscope', 'owner'). If any unknown element is encountered, an error is returned. This behavior partially enforces the RFC requirement that a sender must not generate unauthorized protocol elements.""}}]","The implementation in this function validates the XML structure for a lock request, ensuring that only the permitted elements are processed and returning errors for unexpected elements. However, while it checks for the valid presence of expected elements, it does not explicitly enforce role-based restrictions or handle all possible conditions of the RFC. Therefore, the function only partially matches the RFC specification.",success,
10399,dav_lock_parse_lockinfo,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (!dav_validate_root(doc, ""lockinfo"")) {\n    return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,\n                         ""The request body contains an unexpected ""\n                         ""XML root element."");\n}', 'explanation': ""This code explicitly checks that the XML document has a root element of 'lockinfo', which is part of ensuring that protocol elements conform to the expected grammar.""}}, {'A1': {'code': 'for (child = doc->root->first_child; child; child = child->next) {\n    ...\n    return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0, 0,\n                         apr_psprintf(p,\n                                      ""The server cannot satisfy the ""\n                                      ""LOCK request due to an unknown XML ""\n                                      ""element (\\""%s\\"") within the ""\n                                      ""DAV:lockinfo element."",\n                                      child->name));\n}', 'explanation': ""This loop iterates through each child element within the 'lockinfo' and returns an error if an unknown element is encountered. This helps ensure that only XML conforming to the defined grammar is accepted.""}}]","The function performs validation of the incoming XML by verifying the root element and each child element against expected names (locktype, lockscope, owner). This shows an attempt to enforce the constraint that only protocol elements matching the defined grammar are processed. However, while it partially validates incoming data, the function does not cover all aspects of the RFC concerning the generation of protocol elements (e.g., it does no processing related to elements that should only be generated by other roles). Thus, within its own scope, the function partially meets the specified RFC requirements.",success,
10399,dav_lock_parse_lockinfo,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (!dav_validate_root(doc, ""lockinfo"")) {\n    return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,\n                         ""The request body contains an unexpected ""\n                         ""XML root element."");\n}', 'explanation': 'This segment ensures that the XML document has the expected root element ""lockinfo"", thus beginning to interpret the protocol element as specified by the RFC.'}}, {'A1': {'code': 'for (child = doc->root->first_child; child; child = child->next) {\n    ...\n    if (strcmp(child->name, ""locktype"") == 0 && child->first_child && lock->type == DAV_LOCKTYPE_UNKNOWN) {\n        if (strcmp(child->first_child->name, ""write"") == 0) {\n            lock->type = DAV_LOCKTYPE_WRITE;\n            continue;\n        }\n    }\n    if (strcmp(child->name, ""lockscope"") == 0 && child->first_child && lock->scope == DAV_LOCKSCOPE_UNKNOWN) {\n        if (strcmp(child->first_child->name, ""exclusive"") == 0)\n            lock->scope = DAV_LOCKSCOPE_EXCLUSIVE;\n        else if (strcmp(child->first_child->name, ""shared"") == 0)\n            lock->scope = DAV_LOCKSCOPE_SHARED;\n        if (lock->scope != DAV_LOCKSCOPE_UNKNOWN)\n            continue;\n    }\n    if (strcmp(child->name, ""owner"") == 0 && lock->owner == NULL) {\n        ...\n        lock->owner = text;\n        continue;\n    }\n    return dav_new_error(p, HTTP_PRECONDITION_FAILED, 0, 0,\n                         apr_psprintf(p,\n                                     ""The server cannot satisfy the LOCK request due to an unknown XML ""\n                                     ""element (\\""%s\\"") within the DAV:lockinfo element."",\n                                     child->name));\n}', 'explanation': 'This loop parses each child element of the DAV:lockinfo element. It maps known sub-elements (locktype, lockscope, owner) to internal representations. When an unknown element is encountered, an explicit error is returned. This reflects a strict interpretation of the protocol data, although it does not attempt to recover from invalid constructs as allowed by the RFC context.'}}]","The function implements parsing of the DAV:lockinfo XML by checking the root element and processing known sub-elements (locktype, lockscope, owner). It follows the RFC requirement to interpret protocol elements according to their defined semantics. However, the function opts to reject any unexpected XML element with an error response rather than attempting error recovery as the broader HTTP specification might allow. As such, while it visibly addresses some conditions (like ensuring expected element names) and actions (mapping elements to internal states and erroring on unrecognized tags), it does not fully implement all aspects of the specification's error-handling flexibility, resulting in a 'Partially Matches' outcome.",success,
10399,dav_lock_parse_lockinfo,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (!dav_validate_root(doc, ""lockinfo"")) {\n    return dav_new_error(p, HTTP_BAD_REQUEST, 0, 0,\n                         ""The request body contains an unexpected ""\n                         ""XML root element."");\n}', 'explanation': ""This segment checks that the XML root element is exactly 'lockinfo', thus defensively ensuring that the XML meets a minimal expected format.""}}, {'A1': {'code': 'if (strcmp(child->name, ""locktype"") == 0\n    && child->first_child\n    && lock->type == DAV_LOCKTYPE_UNKNOWN) {\n    if (strcmp(child->first_child->name, ""write"") == 0) {\n        lock->type = DAV_LOCKTYPE_WRITE;\n        continue;\n    }\n}\n\nif (strcmp(child->name, ""lockscope"") == 0\n    && child->first_child\n    && lock->scope == DAV_LOCKSCOPE_UNKNOWN) {\n    if (strcmp(child->first_child->name, ""exclusive"") == 0)\n        lock->scope = DAV_LOCKSCOPE_EXCLUSIVE;\n    else if (strcmp(child->first_child->name, ""shared"") == 0)\n        lock->scope = DAV_LOCKSCOPE_SHARED;\n    if (lock->scope != DAV_LOCKSCOPE_UNKNOWN)\n        continue;\n}\n\nif (strcmp(child->name, ""owner"") == 0 && lock->owner == NULL) {\n    const char *text;\n\n    apr_xml_quote_elem(p, child);\n\n    apr_xml_to_text(p, child, APR_XML_X2T_FULL_NS_LANG, doc->namespaces,\n                    NULL, &text, NULL);\n    lock->owner = text;\n\n    continue;\n}\n\nreturn dav_new_error(p, HTTP_PRECONDITION_FAILED, 0, 0,\n                     apr_psprintf(p,\n                                 ""The server cannot satisfy the ""\n                                 ""LOCK request due to an unknown XML ""\n                                 ""element (\\""%s\\"") within the ""\n                                 ""DAV:lockinfo element."",\n                                 child->name));', 'explanation': ""This code block further performs defensive parsing by processing known child elements and, importantly, returning an error if an unexpected XML element is encountered. It ensures that only recognized elements ('locktype', 'lockscope', 'owner') are accepted.""}}]","The function applies defensive parsing approaches by checking for the expected XML structure and validating specific child elements, which addresses the notion of parsing with minimal conformance expectations as mentioned in the RFC specification. However, while it is defensive regarding the structure and recognition of XML elements, the code does not implement controls such as buffer size validations. As a result, it only partially meets the full defensive parsing requirement described in the RFC.",success,
10400,dav_lock_walker,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function, dav_lock_walker, does not visibly address any aspect of the RFC requirement stating that an origin server MUST NOT use context information (such as Content-Location) to alter the request semantics. The code logic focuses on locking resources and handling errors related to lock operations. There is no implemented logic that processes the Content-Location or any similar request context information in a manner that would affect the request semantics. Therefore, none of the labeled conditions or actions specified in the RFC constraints are implemented within this function.",success,
10405,dav_unlock,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided code function dav_unlock is concerned with unlocking DAV resources by interacting with lock databases and walking the resource hierarchy to remove locks. It does not contain any logic regarding handling or interpreting the Content-Location header or similar contextual information, nor does it address mechanisms to ensure that such context information is not used to alter request semantics. Thus, none of the labeled spec constraints (such as C1 or A1) that pertain to not using context information to alter request semantics are implemented within this function.",success,
10408,dav_get_resource_state,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function (dav_get_resource_state) focuses on determining the state of a resource (checking if it exists or if it is a locknull resource) and does not involve any handling of the Content-Location header or similar request context. The RFC specifies that an origin server MUST NOT use such context information (e.g., Content-Location) to alter request semantics, but there is no code in this function that inspects or acts upon Content-Location or any related header. The function does not include any logic that attempts to implement the RFC constraint, and thus, the code does not visibly address the labeled condition/action regarding the usage of transient context information in requests.",success,
10421,dav_do_prop_subreq,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Partially Matches,"[{'C1': {'code': 'const char *e_uri = ap_escape_uri(propdb->p, propdb->resource->uri);', 'explanation': 'This call escapes (normalizes) the URI from the resource structure, which aligns with the spec requirement that HTTP URIs be normalized so that equivalent URIs identify the same resource.'}}]","The function performs a normalization step by calling ap_escape_uri on the resource's URI before making a sub-request, which is an attempt to implement the normalization behavior described in the RFC spec. However, while it addresses normalization (condition C1), it does not include logic to enforce or verify that two URIs equivalent after normalization indeed identify the same resource. Thus, only a part of the spec requirements is implemented within this function.",success,
10422,dav_insert_coreprop,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 's = apr_pstrcat(propdb->p, ""<D:"", name, "">"", value, ""</D:"", name, "">"" DEBUG_CR, NULL);\napr_text_append(propdb->p, phdr, s);', 'explanation': 'This code block constructs XML protocol elements using a fixed template (with the ""D:"" prefix) when inserting property values. While it appears to be designed to produce well‐formed XML elements as required by the ABNF grammar, it relies on simple string concatenation and does not explicitly validate that the resulting element exactly conforms to the ABNF rules. Therefore, it only partially meets the requirement of ensuring generated protocol elements match the grammar.'}}]","The RFC requires that a sender must not generate protocol elements that do not match the ABNF grammar. The function attempts to enforce this by constructing XML fragments using fixed string patterns (e.g., using '<D:' and proper closing tags). However, it assumes that input values such as 'name' are valid and does not execute any explicit check against the ABNF grammar. In isolation, the function shows some effort to produce correctly formatted protocol elements, but without additional validation the implementation only partially satisfies the RFC constraint.",success,
10422,dav_insert_coreprop,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, dav_insert_coreprop, handles the insertion of various DAV properties into a message by evaluating the property identifier and selecting the appropriate form of markup. However, it does not contain any logic that verifies or enforces the sender’s role in relation to the generation of protocol elements. In other words, there is no check within the function to ensure that protocol elements or syntax alternatives are only generated by participants with the correct role, as required by the RFC specification. Thus, the function does not address the spec’s constraint regarding role-based generation of protocol elements (e.g., C1, A1), and no constraints are fully implemented in the code.",success,
10430,dav_get_allprops,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC requires that the sender must not generate protocol elements that do not match the grammar defined by the ABNF rules. In the provided function, although XML/HTTP elements are constructed by appending specific strings and calling helper functions (like dav_insert_coreprop and dav_xmlns_generate), there is no explicit logic within the function that validates or enforces compliance with the ABNF-defined grammar. The function simply builds XML output without verifying that the generated protocol elements conform to the ABNF. Therefore, within this function, no labeled condition or action (e.g., C1 or A1) addressing this requirement is implemented.",success,
10430,dav_get_allprops,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC requirement mandates that within a given message the sender must not generate protocol elements that are only allowed for other roles. In the provided function, while there is logic for iterating over property names, appending XML tags, and even an ACL check in one section, there is no explicit mechanism or explicit check that verifies a property or protocol element is only generated if the sender is authorized to do so based on its role. The ACL check present appears to filter out properties in some conditions, but it does not clearly enforce the sender’s role restrictions as described by the RFC. Consequently, the function does not visibly implement the necessary constraints on generating role-specific protocol elements.",success,
10431,dav_get_props,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function dav_get_props constructs and concatenates XML fragments for property responses (good, bad, and, in some builds, not authorized) but does not include any explicit logic to ensure that protocol elements or syntax alternatives generated are limited to those allowed for the sender’s role. Although there is a block that checks ACL restrictions (under APR_XML_X2T_PARSED) and diverts properties that fail the acl_check_prop into a 'not authorized' branch (resulting in a 403 Forbidden status), this check is for access control rather than for enforcing the RFC requirement that prohibits generating protocol elements exclusively allowed for other roles. The function does not inspect or conditionally filter elements based on sender role membership, and thus does not fulfill the specific constraint defined in the specification context.",success,
10431,dav_get_props,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,[],"The RFC requirement is that a sender MUST NOT generate protocol elements that do not match the grammar defined by the ABNF rules. In the provided function, XML response fragments (such as the <D:propstat>, <D:prop>, and <D:status> tags) are constructed using hard-coded strings and helper functions. This shows that the function is attempting to generate well‐formed protocol elements. However, there is no explicit validation or check against an ABNF grammar within the function, and it relies entirely on fixed strings and external helper routines to produce the output. Therefore, while the function partially addresses the need to generate protocol elements in a fixed format, it does not itself enforce or validate full conformance to the ABNF rules. As a result, the implementation is only partially matching the spec constraint by itself.",success,
10435,dav_prop_exec,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function, dav_prop_exec, primarily handles property operations (setting, deleting, and live properties execution) and rollback management, with no logic that inspects or interprets the request's contextual information such as Content-Location. According to the RFC, an origin server must not use the context information (like Content-Location) to alter request semantics. However, the function contains no specific checks or logic to ensure that such context is not used to modify behavior. Therefore, the function does not visibly address the specified RFC constraint.",success,
10438,dav_core_insert_prop,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that a sender must not generate protocol elements that are reserved for other roles, but the provided function does not include any logic to check or enforce sender roles. It simply builds XML elements based on the resource type without validating if generating such elements is permitted for the sender's role. Since no part of the code inspects or restricts role-based generation of protocol elements, none of the labeled constraints (such as C1 or A1) are addressed within this function.",success,
10438,dav_core_insert_prop,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'if (what == DAV_PROP_INSERT_SUPPORTED) {\n    s = apr_pstrcat(p,\n                     ""<D:supported-live-property D:name=\\"""", info->name,\n                     ""\\"" D:namespace=\\"""", dav_core_namespace_uris[info->ns],\n                     ""\\""/>"" DEBUG_CR, NULL);\n} else if (what == DAV_PROP_INSERT_VALUE && *value != \'\\0\') {\n    s = apr_psprintf(p, ""<lp%ld:%s>%s</lp%ld:%s>"" DEBUG_CR,\n                     global_ns, info->name, value, global_ns, info->name);\n} else {\n    s = apr_psprintf(p, ""<lp%ld:%s/>"" DEBUG_CR, global_ns, info->name);\n}', 'explanation': 'This code constructs protocol element XML fragments using fixed string templates and controlled variables. By always outputting elements in the standardized formats (e.g., <D:supported-live-property .../>, <lp...:...>...</lp...:...>), it ensures that the generated protocol elements conform to the grammar defined by the ABNF rules.'}}]","The function dav_core_insert_prop builds XML-based protocol elements using controlled template strings (via apr_pstrcat and apr_psprintf) and predetermined attribute names and namespace URIs. This approach ensures that regardless of the property being processed, the resulting protocol elements adhere to the expected XML structure as specified in the RFC. Therefore, the function visibly addresses the requirement (labeled here as C1) that a sender must not generate protocol elements that deviate from the ABNF grammar.",success,
10448,dav_add_all_liveprop_xmlns,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function merely iterates over a global hash of live property URIs to generate XML namespace attributes and appends them to a header. It does not perform any checking or enforcement related to the HTTP RFC specification—that is, it does not verify that protocol elements are generated only by the proper roles or adhere to the required ABNF grammar. There is no code that addresses any labeled conditions (e.g., C1) or actions (e.g., A1) specified by the RFC. The function simply formats and appends namespace strings without implementing any of the role-based restrictions or syntax validations mandated by the RFC.",success,
10452,delete_if_fixup,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC spec requires that a sender must not generate protocol elements or syntax alternatives reserved for other roles. This function only manipulates the 'If' header by verifying its enclosing parentheses and prepending the URI, but it does not perform any checks related to the sender’s role or restrict generation of protocol elements based on that role. Thus, no labeled condition (e.g., C1) or action (e.g., A1) from the spec constraints is implemented in this function.",success,
10452,delete_if_fixup,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': ""if (if_hdr[0] != '(' || if_hdr[len - 1] != ')')\n    goto out;"", 'explanation': ""This code checks that the 'If' header value is enclosed in parentheses, which is an attempt to validate that it adheres to a specific grammar.""}}, {'C2': {'code': ""for (cp = if_hdr; *cp; cp++) {\n    if (*cp == ')' && *(cp + 1))\n        goto out;\n}"", 'explanation': 'This loop ensures that after the closing parenthesis there are no extraneous characters, further enforcing strict adherence to the expected grammar.'}}, {'A1': {'code': 'if_hdr = apr_psprintf(r->pool, ""<%s> %s"", r->uri, if_hdr);\napr_table_set(r->headers_in, ""If"", if_hdr);', 'explanation': 'After validating the header, the function prepends the request URI in angle brackets to the header, thereby constructing a new protocol element that conforms to the expected ABNF grammar.'}}]","The function 'delete_if_fixup' directly implements logic to enforce grammar compliance for the 'If' header by checking its format against expected parenthesis enclosure and by constructing a new header value (with the URI in angle brackets) when the format is correct. This approach partially addresses the RFC requirement that a sender must not generate protocol elements that do not match the defined ABNF grammar. However, it only deals with the specific case of the 'If' header and does not cover all protocol elements or role-specific constraints, hence it is considered a partial match.",success,
10455,mswdv_urlencode,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'mswdv_urlencode' solely performs URL encoding by converting non-alphanumeric characters into their percent-encoded representations. It does not contain any logic to verify or enforce the RFC specification regarding role-based generation of protocol elements, such as ensuring that a sender does not generate elements reserved for other roles. There is no evidence within the function of any checks or constraints corresponding to the condition (C1) or similar actions (A1) described in the spec constraints. As a result, the function does not visibly address the specified RFC constraint.",success,
10456,mswdv_err_checked_out,"It MUST conform to the field-name syntax defined in Section 5.1, and it SHOULD be restricted to just letters, digits, and hyphen ('-') characters, with the first character being a letter.",293,Does Not Match,[],"The provided function constructs an error message and sets an HTTP header ('X-MSDAVEXT_ERROR') but does not implement any logic to enforce or validate the field-name syntax as specified (i.e., ensuring that the field name is restricted to letters, digits, and hyphen characters with its first character being a letter). There is no code in the function that checks or processes any registration request's field name against the RFC's requirements. Therefore, the function does not address any of the spec constraints.",success,
10458,mswdv_combined_lock,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': ""if (lock_token_hdr) {\n    apr_size_t len = strlen(lock_token_hdr);\n    if (lock_token_hdr[0] == '<' || lock_token_hdr[len - 1] == '>')\n        lock_token_hdr = apr_pstrndup(r->pool, lock_token_hdr + 1, len - 2);\n}"", 'explanation': 'This segment attempts to recover a usable Lock-Token header value by stripping off extraneous angle brackets, which aligns with the RFC’s allowance to recover elements from an invalid construct.'}}, {'A1': {'code': 'if (!lock_token_hdr && lock_timeout_hdr && timeout_zero) {\n     failmsg = ""Unlock operation requires a lock token."";\n     goto done;\n}', 'explanation': 'This block enforces error handling when a required protocol element is missing. It returns an error when the Lock-Token is absent but a timeout header is present, addressing the protocol’s error handling guidance.'}}]","The function includes logic that visibly addresses portions of the HTTP RFC behavior: it recovers from a potentially malformed Lock-Token header by stripping extraneous brackets (labeled here as C1) and handles error conditions by returning corresponding error messages (labeled here as A1). However, while these portions attempt to meet the specification’s recommendations for recovering from invalid constructs and enforcing required semantics, the function does not cover every possible condition or error handling mechanism prescribed by the RFC. Therefore, the function only partially matches the overall spec constraints.",success,
10458,mswdv_combined_lock,A recipient MAY employ such workarounds while remaining conformant to this protocol if the workarounds are limited to the implementations at fault.,216,Partially Matches,"[{'C1': {'code': ""if (lock_token_hdr) {\n    apr_size_t len = strlen(lock_token_hdr);\n\n    if (lock_token_hdr[0] == '<' || lock_token_hdr[len - 1] == '>')\n        lock_token_hdr = apr_pstrndup(r->pool, lock_token_hdr + 1, len - 2);\n}"", 'explanation': 'This segment handles the scenario where a Lock-Token header might be sent with or without angle brackets, which is a workaround mentioned in the spec context. It shows that the function is aware that clients might use a non‐standard format and adjusts accordingly.'}}, {'A1': {'code': 'if (timeout_zero) {\n    action = ACTION_UNLOCK;\n    goto done;\n}', 'explanation': 'This code branch implements an action for an immediate timeout (i.e. ""Second-0""), which is one of the actions (unlock operation) defined in the underlying MS-WDV spec behavior and is indicative of applying a workaround based on header values.'}}]","The function implements several conditional checks and action branches based on the presence and values of the Lock-Token and X-MSDAVEXTLockTimeout headers. In doing so it demonstrates awareness of non‐standard client behavior (for example, clients omitting angle brackets) and provides alternative actions (such as lock, refresh, or unlock) accordingly. However, while it visibly addresses certain conditions (like the treatment of token formats and immediate timeouts), it does not cover every aspect of the overarching protocol requirement (for example, it does not explicitly ensure that these workarounds are limited to the faulty implementations), and thus only partially matches the full set of spec constraints.",success,
10459,mswdv_combined_propfind,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,"[{'A1': {'code': 'ap_set_content_type_ex(r, ""multipart/MSDAVEXTPrefixEncoded"", 1);', 'explanation': 'This line explicitly sets the Content-Type header for the outgoing response, which is in line with the RFC’s requirement that a message containing content should include a Content-Type header. It demonstrates that the code is taking action to generate the header when content is present.'}}]","The RFC specifies that a sender generating a message with content SHOULD generate a Content-Type header unless the media type is unknown. In the function_body, the header is explicitly set via the call to ap_set_content_type_ex, which satisfies the requirement when the media type is known. However, the implementation does not contain logic to handle the exception for when the intended media type is unknown. Because the function unconditionally sets the Content-Type header without checking whether the media type is known or not, it only partially meets the complete spirit of the specification. Hence, the function partially matches the spec constraints.",success,
10460,mswdv_combined_proppatch,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function mswdv_combined_proppatch is focused on reading and processing specific parts of the request body (namely, the PROPPATCH part and a subsequent PUT part) by reading fixed-length segments and converting them, but it does not include any logic that directly verifies or enforces the HTTP RFC requirement that a sender MUST NOT generate protocol elements or syntax alternatives that are reserved for other roles. There is no check related to sender roles or validation of protocol element generation as per the spec constraint. Thus, within this function's code there is no visible implementation addressing the labeled constraint.",success,
10460,mswdv_combined_proppatch,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (len != 16)\n        return dav_new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR, 0, status,\n                             ""Unexpected PROPPATCH part length"");\n\nstatus = apr_strtoff(&proppatch_len, proppatch_len_str, NULL, 16);\nif (status != APR_SUCCESS)\n    return dav_new_error(r->pool, HTTP_BAD_REQUEST, 0, status,\n                         ""Bad PROPPATCH part length"");', 'explanation': 'The function defensively reads exactly 16 bytes from the input, validates that the expected length is received, and then parses it using apr_strtoff. This error-checking demonstrates an attempt to parse the protocol element defensively, as suggested by the RFC spec. However, it only addresses one specific expected length rather than handling broader variability in protocol element lengths.'}}]","The RFC requires that a recipient parse a received protocol element defensively without assuming it perfectly conforms to a defined grammar or size. The function shows defensive parsing by reading a fixed amount of bytes, checking for errors, and validating that the read length is exactly as expected before processing further. While these checks protect against malformed input, the function is designed to work with a fixed 16-byte header rather than accommodating arbitrary or evolving protocol element lengths. This indicates that the function only partially matches the spec, implementing some defensive measures (labeled as C1) while not fully embracing the broader defensive parsing philosophy outlined in the context.",success,
10460,mswdv_combined_proppatch,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function does not implement any visible logic to ensure that protocol elements conform to the ABNF grammar as required by the specification (i.e., the requirement that a sender MUST NOT generate protocol elements that do not match the grammar). The function primarily reads input data, performs length checks, and sets some header values; it does not generate any protocol elements nor does it validate generated elements against the ABNF rules. Therefore, the function does not address the constraint within its own code.",success,
10460,mswdv_combined_proppatch,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_in, ""Content-Type"", ""application/octet-stream"");', 'explanation': ""This line explicitly sets the Content-Type header in the message. The RFC specifies that a sender generating a message with content SHOULD include a Content-Type header when the media type is known. By unconditionally setting it (choosing 'application/octet-stream' when the specific type isn’t determined), the function meets this requirement.""}}]","The function implements the RFC requirement by ensuring that a Content-Type header field is generated. Although the media type is set to a generic value ('application/octet-stream'), this behavior complies with the RFC directive that if the intended media type is unknown, the sender may provide an explicit header. Thus, the core spec constraint is fully addressed within this function.",success,
10460,mswdv_combined_proppatch,"If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type.",35,Partially Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_in, ""Content-Type"", ""application/octet-stream"");', 'explanation': ""This line directly sets the Content-Type header to 'application/octet-stream', which is one of the options provided by the RFC when no Content-Type header is present.""}}]","The RFC allows the recipient to assume a media type of 'application/octet-stream' if no Content-Type header is provided. In this function, after processing the PROPPATCH and PUT parts, the code sets the Content-Type header to 'application/octet-stream'. This satisfies the action of assuming the default media type (labeled as A1). However, the function does not check whether the header is actually missing before setting it, and it does not examine the data to determine its type. Therefore, only part of the RFC constraint is addressed by this function.",success,
10461,dav_mswdv_preprocessing,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function does not contain any logic addressing the RFC's requirement to prevent multiple field lines with the same name or to preserve the order of such fields. The code simply sets headers and handles method-specific processing without any checks for duplicate header field names or ordering, and therefore does not implement any of the labeled constraints (e.g., C1, A1) from the spec.",success,
10461,dav_mswdv_preprocessing,"A server generating a successful response to OPTIONS SHOULD send any header that might indicate optional features implemented by the server and applicable to the target resource (e.g., Allow), including potential extensions not defined by this specification.",77,Fully Matches,"[{'C1': {'code': 'if (r->method_number == M_OPTIONS) {\n    apr_table_setn(r->headers_out, ""X-MSDAVEXT"", ""1"");\n    apr_table_setn(r->err_headers_out, ""X-MSDAVEXT"", ""1"");\n}', 'explanation': 'For OPTIONS requests the code sets a header (X-MSDAVEXT) that indicates optional features, which complies with the spec requirement that any header indicating optional features (including extensions not defined by the spec) should be sent.'}}]","The function explicitly handles the case when the HTTP method is OPTIONS by adding the custom header 'X-MSDAVEXT' to both normal and error response headers. This directly implements the RFC's requirement to send a header that indicates optional features in a successful OPTIONS response. Thus, within the scope of this function, the relevant spec constraint is fully addressed.",success,
10461,dav_mswdv_preprocessing,A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.,30,Partially Matches,"[{'C1': {'code': 'if (r->method_number == M_OPTIONS) {\n    apr_table_setn(r->headers_out, ""X-MSDAVEXT"", ""1"");\n    apr_table_setn(r->err_headers_out, ""X-MSDAVEXT"", ""1"");\n}', 'explanation': 'This segment handles OPTIONS requests by setting the X-MSDAVEXT header, which indicates that such requests are treated differently. It aligns with the part of the spec stating that an OPTIONS request can be honored by any protocol. However, the function does not address the requirement of verifying that the semantics of a received message can be honored by the new protocol before switching.'}}]","The provided code function visibly deals with the special handling for OPTIONS requests by setting a specific header, which partially implements the intent of the RFC stating that an OPTIONS request can be honored by any protocol. However, it lacks implementation for the protocol switching logic itself—including checking that received message semantics are honored by the new protocol and sending a 101 (Switching Protocols) response followed by the corresponding new protocol response—so it does not fully match the complete specification.",success,
10475,dav_lookup_uri,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'if (comp.port == 0)\n    comp.port = apr_uri_port_of_scheme(comp.scheme);', 'explanation': ""The code checks if the URI's port is zero (i.e., not provided) and assigns the default port using apr_uri_port_of_scheme(), which directly implements the RFC requirement that a missing port may be interpreted as the default port for the received-protocol.""}}]","The function dav_lookup_uri contains explicit logic to handle cases where the URI does not specify a port by assigning the default port based on the scheme. This directly corresponds to the RFC specification that states a recipient may treat an absent port as the default port. Since this matching behavior is fully implemented within the function itself, the outcome is 'Fully Matches'.",success,
10475,dav_lookup_uri,"Unless the connection is from a trusted gateway, an origin server MUST reject a request if any scheme-specific requirements for the target URI are not met.",250,Partially Matches,"[{'C1': {'code': 'if (comp.scheme == NULL && must_be_absolute) {\n    result.err.status = HTTP_BAD_REQUEST;\n    result.err.desc = ""Destination URI must be an absolute URI."";\n    return result;\n}', 'explanation': 'This code block verifies that, when an absolute URI is required, the URI indeed contains a scheme. This partially addresses the scheme-specific requirements by ensuring the URI is absolute.'}}, {'C2': {'code': 'if (comp.query != NULL || comp.fragment != NULL) {\n    result.err.status = HTTP_BAD_REQUEST;\n    result.err.desc = ""Destination URI contains invalid components (a query or a fragment)."";\n    return result;\n}', 'explanation': 'This block rejects URIs that include query or fragment components, enforcing part of the scheme-specific constraints.'}}, {'A1': {'code': 'if (comp.scheme != NULL || comp.port != 0 || must_be_absolute) {\n    scheme = r->parsed_uri.scheme;\n    if (scheme == NULL)\n        scheme = ap_http_scheme(r);\n    if (comp.port == 0)\n        comp.port = apr_uri_port_of_scheme(comp.scheme);\n    port = r->connection->local_addr->port;\n    if (ap_cstr_casecmp(comp.scheme, scheme) != 0\n#ifdef APACHE_PORT_HANDLING_IS_BUSTED\n        || comp.port != port\n#endif\n    ) {\n        result.err.status = HTTP_BAD_GATEWAY;\n        result.err.desc = apr_psprintf(r->pool,\n                                       ""Destination URI refers to different scheme or port (%s://hostname:%d)"" APR_EOL_STR\n                                       ""(want: %s://hostname:%d)"",\n                                       comp.scheme ? comp.scheme : scheme,\n                                       comp.port ? comp.port : port,\n                                       scheme, port);\n        return result;\n    }\n}', 'explanation': 'This segment compares the scheme (and implicitly port) of the incoming request with that of the target URI. It rejects the request if there is a mismatch, thus enforcing scheme-specific requirements.'}}]","The function demonstrates several checks that enforce parts of the RFC's scheme-specific requirements, such as ensuring the URI is absolute when needed, rejecting URIs with query parameters or fragments, and confirming that the scheme (and port) match the current request. However, it does not incorporate logic for determining whether the connection is from a trusted gateway or verifying certificate validity for https resources. Because it addresses some conditions but not the trusted gateway requirement mentioned in the RFC specification, the implementation is considered a partial match.",success,
10475,dav_lookup_uri,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (comp.query != NULL || comp.fragment != NULL) {\n    result.err.status = HTTP_BAD_REQUEST;\n    result.err.desc =\n        ""Destination URI contains invalid components ""\n        ""(a query or a fragment)."";\n    return result;\n}', 'explanation': 'This code block ensures that the URI does not contain query or fragment components. In the RFC, senders are not supposed to generate protocol elements or syntax alternatives (such as query strings or fragments) that belong to roles they do not have. While this check prevents these extra elements from being included, it addresses only one aspect of the spec requirement.'}}, {'C1': {'code': 'if (comp.scheme == NULL && must_be_absolute) {\n    result.err.status = HTTP_BAD_REQUEST;\n    result.err.desc = ""Destination URI must be an absolute URI."";\n    return result;\n}', 'explanation': 'This segment verifies that when an absolute URI is required, the incoming URI must contain a scheme. This contributes to ensuring that the sender does not generate or use a URI form that is not permitted under the proper roles, partially addressing the RFC constraint.'}}]","The function dav_lookup_uri performs several validation steps on the input URI, such as checking for the presence of forbidden components (query and fragment) and verifying that a required absolute URI has a scheme. These checks can be seen as an attempt to enforce the RFC’s requirement that a sender must not generate protocol elements or syntax alternatives that are restricted to other roles. However, the function does not explicitly tie these validations to the sender's role or comprehensively address all aspects of the RFC specification. Therefore, while it implements some of the necessary conditions, it only partially matches the specification.",success,
10475,dav_lookup_uri,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (apr_uri_parse(r->pool, uri, &comp) != APR_SUCCESS) {\n    result.err.status = HTTP_BAD_REQUEST;\n    result.err.desc = ""Invalid syntax in Destination URI."";\n    return result;\n}', 'explanation': 'This segment checks that the incoming URI can be successfully parsed, enforcing that the URI conforms to the expected ABNF grammar. It returns an error if the URI does not adhere to the syntax, which is a direct attempt to implement the constraint that protocol elements must match the defined grammar.'}}, {'C2': {'code': 'if (comp.query != NULL || comp.fragment != NULL) {\n    result.err.status = HTTP_BAD_REQUEST;\n    result.err.desc = ""Destination URI contains invalid components (a query or a fragment)."";\n    return result;\n}', 'explanation': 'This code explicitly rejects URIs that include a query or fragment, which are not allowed according to the spec. In doing so, it helps ensure that the generated protocol elements conform strictly to the defined grammar.'}}]","The function attempts to validate the destination URI to ensure that it adheres to the ABNF-defined grammar by parsing it and eliminating disallowed components such as query strings and fragments. However, while it covers key aspects of URI validation—thereby partially meeting the requirements of the spec—it does not address all potential protocol elements or the complete set of semantic restrictions implied by the RFC. Thus, the implementation in this function is considered to partially match the spec's constraints.",success,
10491,dav_get_timeout_string,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': 'while ((val = ap_getword_white(r->pool, &timeout)) && strlen(val)) { ... }', 'explanation': 'The function uses ap_getword_white to extract each token from the duplicated string. This helper function is expected to ignore leading whitespace when obtaining the word, thereby excluding whitespace before the token is evaluated. This directly addresses the RFC requirement to remove any whitespace from field values prior to evaluation.'}}]","The provided code function processes the input field (timeout_const) by duplicating it and then iteratively extracting tokens using ap_getword_white, which inherently strips out leading whitespace. This behavior meets the HTTP RFC specification that mandates the exclusion of such whitespace before evaluating the field value. The implementation within the function_body directly adheres to the specified constraint, so we conclude that the function fully matches the requirement.",success,
10491,dav_get_timeout_string,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function processes and interprets a timeout string (checking for the tokens 'Infinite' and 'Second-') and returns a time value accordingly. However, there is no part of the function that enforces or checks the RFC requirement stating that a sender MUST NOT generate protocol elements or syntax alternatives reserved for other roles. No code logic is found addressing the role-based generation of protocol elements as specified, so the function does not attempt to implement the constraints (e.g., C1, A1, etc.) of the HTTP RFC.",success,
10491,dav_get_timeout_string,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function dav_get_timeout_string only parses a timeout string by recognizing specific tokens ('Infinite' and 'Second-') and returns a time_t value based on these. It does not generate any HTTP protocol elements nor does it enforce or check against the full ABNF grammar required by the HTTP RFC for generated protocol elements. Thus, it does not implement the RFC’s requirement that a sender must not generate protocol elements that do not match the defined grammar, as its logic is limited to basic token recognition and conversion.",success,
10493,dav_add_if_state,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Fully Matches,"[{'C1': {'code': 'if ((err = (*locks_hooks->parse_locktoken)(p, state_token, &new_sl->locktoken)) != NULL) {\n    /* If the state token cannot be parsed, treat it as an unknown state; this will evaluate to ""false"" later during If header validation. */\n    if (err->error_id == DAV_ERR_LOCK_UNK_STATE_TOKEN) {\n        new_sl->type = dav_if_unknown;\n    }\n    else {\n        return err;\n    }\n}', 'explanation': ""This code block implements error recovery from an invalid construct (a state token that cannot be parsed) by checking if the error id equals DAV_ERR_LOCK_UNK_STATE_TOKEN and then setting the state type to 'unknown'. This behavior aligns with the RFC specification guidance that a recipient MAY attempt to recover a usable protocol element from an invalid construct.""}}]","The function visibly addresses the RFC requirement by attempting to recover a usable protocol element when the state token is invalid. It checks the result of parsing the state token and, upon detecting a specific error condition, recovers by marking the token as 'unknown' rather than failing outright. This direct handling within the function meets the labeled condition.",success,
10493,dav_add_if_state,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if ((err = (*locks_hooks->parse_locktoken)(p, state_token, &new_sl->locktoken)) != NULL) {\n    if (err->error_id == DAV_ERR_LOCK_UNK_STATE_TOKEN) {\n        new_sl->type = dav_if_unknown;\n    }\n    else {\n        return err;\n    }\n}', 'explanation': ""This code segment interprets the received state token for an opaque lock. In line with the RFC, it attempts to parse the token and if parsing fails with a specific error (indicating an unknown state), it resets the type to 'unknown', thereby allowing later evaluation as false. This reflects the RFC requirement that a recipient MUST interpret the token using defined semantics and recover from invalid constructs.""}}, {'A1': {'code': 'new_sl->condition = condition;\nnew_sl->type      = t;\n...\nnew_sl->etag = state_token;', 'explanation': 'These assignments and the handling of the non-opaquelock token show that the function interprets and assigns protocol element values (whether as lock tokens or etags) based on its semantics. This demonstrates an effort to apply the meaning defined by the protocol, as the RFC requires.'}}]","The function dav_add_if_state processes a protocol element (the state token) by determining whether it is an opaque lock token or an etag and then storing the information accordingly. In the case of an opaquelock, it calls a parsing method and handles errors by setting the type to unknown, which is a form of error recovery as permitted by the RFC. Nonetheless, the function only addresses the interpretation of the state token element; it does not cover all possible conditions or actions that might be required by a complete RFC implementation. Therefore, the function only partially matches the RFC constraints.",success,
10493,dav_add_if_state,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if ((err = (*locks_hooks->parse_locktoken)(p, state_token, &new_sl->locktoken)) != NULL) {\n    /* If the state token cannot be parsed, treat it as an\n     * unknown state; this will evaluate to ""false"" later\n     * during If header validation. */\n    if (err->error_id == DAV_ERR_LOCK_UNK_STATE_TOKEN) {\n        new_sl->type = dav_if_unknown;\n    }\n    else {\n        return err;\n    }\n}', 'explanation': ""This code segment calls a dedicated token parser and checks for errors. If the parser returns an error indicating an unknown state token, it defensively sets the token type to 'unknown' rather than failing immediately. This implements a form of defensive parsing as recommended by the RFC, though it does not include checks (e.g., verifying buffer sizes) for all aspects mentioned in the specification.""}}]","The function attempts to defensively parse a received protocol element by invoking a dedicated parsing function and gracefully handling error conditions. This aligns partially with the RFC’s recommendation to parse protocol elements defensively. However, the implementation does not explicitly handle concerns such as ensuring the element fits within a reasonable buffer size, thus only partially meeting the full intent of the specification.",success,
10493,dav_add_if_state,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (t == dav_if_opaquelock) {\n    dav_error *err;\n\n    if ((err = (*locks_hooks->parse_locktoken)(p, state_token, &new_sl->locktoken)) != NULL) {\n        /* If the state token cannot be parsed, treat it as an\n         * unknown state; this will evaluate to ""false"" later\n         * during If header validation. */\n        if (err->error_id == DAV_ERR_LOCK_UNK_STATE_TOKEN) {\n            new_sl->type = dav_if_unknown;\n        } else {\n            return err;\n        }\n    }\n}', 'explanation': 'This segment of code validates lock tokens by parsing them to ensure that they match the expected grammar. If the token does not parse correctly, it marks the state as unknown (or returns an error), which prevents the generation of protocol elements that do not conform to the required syntax. However, this validation is only performed for opaquelock tokens, while other tokens (such as etags) are accepted without explicit grammar validation.'}}]","The function partially implements the RFC requirement that 'a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.' It achieves this by verifying opaquelock tokens via a parsing function. If the token fails to parse correctly, the function adjusts the token's type to prevent invalid protocol element generation. However, the function does not perform a similar grammatical check for non-lock tokens (etag values), meaning that it only partially satisfies the specification within its own logic.",success,
10493,dav_add_if_state,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function primarily creates and attaches an 'if state' object based on the provided state token and type, handling parsing errors accordingly. It does not include any logic to check or control protocol element generation based on sender roles, nor does it validate that the syntax elements being generated comply with a role-specific ABNF grammar. Therefore, none of the spec constraints (e.g., ensuring that a sender does not generate elements reserved for other roles) are visibly addressed within this function's code.",success,
10495,dav_process_if_header,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if ((str = apr_pstrdup(r->pool, apr_table_get(r->headers_in, ""If""))) == NULL)\n    return NULL;\n\nwhile (*str) {\n    switch(*str) {\n    case \'<\':\n        /* Tagged-list production - following states apply to this uri */\n        if (list_type == no_tagged\n            || ((uri = dav_fetch_next_token(&str, \'>\')) == NULL)) {\n            return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                                 DAV_ERR_IF_TAGGED, 0,\n                                 ""Invalid If-header: unclosed \\""<\\"" or unexpected tagged-list production."");\n        }\n        ...\n    case \'(\':\n        /* List production */\n        if (list_type == unknown)\n            list_type = no_tagged;\n\n        if ((list = dav_fetch_next_token(&str, \')\')) == NULL) {\n            return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                                 DAV_ERR_IF_UNCLOSED_PAREN, 0,\n                                 ""Invalid If-header: unclosed \\""(\\""."");\n        }\n        ...\n    }\n    str++;\n}\n*p_ih = ih;\nreturn NULL;', 'explanation': 'This segment shows that the function attempts to interpret the received If-header by parsing its various productions (tagged and no-tagged lists) according to the RFC’s semantics (i.e. processing URIs and state tokens). It validates structure and returns specific errors if parsing fails.'}}]","The RFC requires that a recipient must interpret a received protocol element based on the defined semantics. This function processes the HTTP If header by parsing tokenized elements, verifying proper closure of tokens and URIs, and performing normalization. While it clearly addresses the syntactic interpretation aspect (condition C1), it does not incorporate additional behavior indicated by the spec context—such as selecting alternative recovery paths when a sender is known to implement the protocol incorrectly. As such, the function only partially meets the overall intended RFC specification.",success,
10495,dav_process_if_header,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if ((str = apr_pstrdup(r->pool, apr_table_get(r->headers_in, ""If""))) == NULL)\n    return NULL;\n\nwhile (*str) {\n    switch(*str) {\n    case \'<\':\n        // Parsing a tagged-list production with checks for unclosed tokens\n        if (list_type == no_tagged\n            || ((uri = dav_fetch_next_token(&str, \'>\')) == NULL)) {\n            return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                                 DAV_ERR_IF_TAGGED, 0,\n                                 ""Invalid If-header: unclosed \\""<\\"" or ""\n                                 ""unexpected tagged-list production."");\n        }\n        ...\n    default:\n        return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                             DAV_ERR_IF_UNK_CHAR, 0,\n                             apr_psprintf(r->pool,\n                                         ""Invalid \\""If:\\"" header: ""\n                                         ""Unexpected character encountered (0x%02x, \'%c\')."",\n                                         *str, *str));\n    }\n\n    str++;\n}', 'explanation': 'This code demonstrates a defensive parsing approach by not assuming the input perfectly conforms to the ABNF grammar. It verifies the existence of the header, iterates over each character, and switches on expected tokens, returning errors immediately when encountering unclosed or unexpected characters.'}}, {'A1': {'code': 'if ((list = dav_fetch_next_token(&str, \')\')) == NULL) {\n    return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                         DAV_ERR_IF_UNCLOSED_PAREN, 0,\n                         ""Invalid If-header: unclosed \\""(\\""."");\n}\n\n...\n\nif ((state_token = dav_fetch_next_token(&list, \'>\')) == NULL) {\n    return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                         DAV_ERR_IF_PARSE, 0, NULL);\n}\n\n...\n\nif (!ap_normalize_path(parsed_uri.path,\n                       AP_NORMALIZE_NOT_ABOVE_ROOT |\n                       AP_NORMALIZE_DECODE_UNRESERVED)) {\n    return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                         DAV_ERR_IF_TAGGED, rv,\n                         ""Invalid URI path tagged If-header."");\n}', 'explanation': 'Throughout the function, multiple error conditions are checked and errors are returned using dav_new_error with an appropriate HTTP status and detailed message. This verifies that the function is designed to handle malformed or unexpected protocol elements robustly.'}}]","The function dav_process_if_header implements a defensive parsing strategy as required by the HTTP RFC. It does not assume perfect conformity to the expected ABNF grammar and performs rigorous checks for unclosed tokens, unexpected characters, and invalid URIs. By immediately returning descriptive error messages when these conditions occur, the function embodies both the defensive parsing and error handling mandates specified in the RFC.",success,
10495,dav_process_if_header,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'while (*str) {\n    switch(*str) {\n    case \'<\':\n        /* Tagged-list production ... */\n        if (list_type == no_tagged || ((uri = dav_fetch_next_token(&str, \'>\')) == NULL)) {\n            return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                                 DAV_ERR_IF_TAGGED, 0,\n                                 ""Invalid If-header: unclosed \\""<\\"" or unexpected tagged-list production."");\n        }\n        ...\n        break;\n    case \'(\':\n        /* List production */\n        if ((list = dav_fetch_next_token(&str, \')\')) == NULL) {\n            return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                                 DAV_ERR_IF_UNCLOSED_PAREN, 0,\n                                 ""Invalid If-header: unclosed \\""(\\""."");\n        }\n        ...\n        while (*list) {\n            switch (*list) {\n            case \'<\':\n                if ((state_token = dav_fetch_next_token(&list, \'>\')) == NULL) {\n                    return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                                         DAV_ERR_IF_PARSE, 0, NULL);\n                }\n                ...\n                break;\n            case \'[\':\n                if ((state_token = dav_fetch_next_token(&list, \']\')) == NULL) {\n                    return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                                         DAV_ERR_IF_PARSE, 0, NULL);\n                }\n                ...\n                break;\n            case \'N\':\n                if (list[1] == \'o\' && list[2] == \'t\') {\n                    if (condition != DAV_IF_COND_NORMAL) {\n                        return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                                             DAV_ERR_IF_MULTIPLE_NOT, 0,\n                                             ""Invalid \\""If:\\"" header: Multiple \\""not\\"" entries for the same state."");\n                    }\n                    condition = DAV_IF_COND_NOT;\n                    list += 2;\n                } else {\n                    return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                                         DAV_ERR_IF_UNK_CHAR, 0,\n                                         ""Invalid \\""If:\\"" header: Unexpected character in List"");\n                }\n                break;\n            default:\n                return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                                     DAV_ERR_IF_UNK_CHAR, 0,\n                                     apr_psprintf(r->pool,\n                                                 ""Invalid \\""If:\\"" header: Unexpected character encountered (0x%02x, \'%c\')."",\n                                                 *list, *list));\n            }\n            list++;\n        }\n        break;\n    default:\n        return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                             DAV_ERR_IF_UNK_CHAR, 0,\n                             apr_psprintf(r->pool,\n                                         ""Invalid \\""If:\\"" header: Unexpected character encountered (0x%02x, \'%c\')."",\n                                         *str, *str));\n    }\n    str++;\n}', 'explanation': ""The function processes the 'If' header while strictly checking for correct grammar by inspecting tokens (such as '<', '(', ')', '>', '[' and ']') and returning appropriate errors when unexpected or malformed input is found. This code directly enforces the requirement that protocol elements must match the defined grammar by rejecting malformed productions. However, it is only responsible for parsing and validating incoming header data and does not cover all aspects of protocol element generation as mandated by the RFC.""}}]","The function 'dav_process_if_header' includes parser logic that validates the structure and syntax of the 'If' header against expected tokens defined by an ABNF-like grammar. It rejects malformed header content by producing errors, thereby partially addressing the RFC requirement that a sender must not generate protocol elements that do not match the grammar. However, since the function operates solely as a parser (and thus does not generate protocol elements itself), it only partially satisfies the overall requirement as stated in the RFC.",success,
10495,dav_process_if_header,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Partially Matches,"[{'C1': {'code': 'if (!ap_normalize_path(parsed_uri.path,\n                       AP_NORMALIZE_NOT_ABOVE_ROOT |\n                       AP_NORMALIZE_DECODE_UNRESERVED)) {\n    return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                         DAV_ERR_IF_TAGGED, rv,\n                         ""Invalid URI path tagged If-header."");\n}', 'explanation': 'The code calls ap_normalize_path to normalize the URI path from the If header in order to prepare for a proper comparison. This normalization is in line with the requirement that HTTP URIs equivalent after normalization be identified as the same resource.'}}, {'A1': {'code': 'if (ap_unescape_url(parsed_uri.path) != OK) {\n    return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                         DAV_ERR_IF_TAGGED, rv,\n                         ""Invalid percent encoded URI in tagged If-header."");\n}\n\nuri_len = strlen(parsed_uri.path);\nif (uri_len > 1 && parsed_uri.path[uri_len - 1] == \'/\') {\n    parsed_uri.path[--uri_len] = \'\\0\';\n}', 'explanation': 'The function unescapes the normalized URI and removes a trailing slash. These actions further prepare the URI for comparison, aligning with the idea that equivalent HTTP URIs (after normalization) should identify the same resource.'}}]","The function implements key parts of URI normalization by invoking ap_normalize_path and ap_unescape_url and by adjusting the URI (such as removing a trailing slash). This logic directly addresses aspects of the specification that suggest that equivalent normalized HTTP URIs should be treated as the same. However, while these normalization steps are performed, the function does not complete the entire comparison logic (for example, comparing the normalized URI against r->uri or handling all potential variations) solely within its scope. Hence, the implementation only partially meets the overall spec constraints.",success,
10495,dav_process_if_header,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function dav_process_if_header is focused on parsing and validating the syntax of the 'If' header by checking for correct token boundaries, proper URI formats, and valid state tokens. It does not, however, implement any logic that checks or enforces the sender’s role with respect to generating protocol elements (i.e., ensuring that a sender does not generate elements intended only for other roles). Therefore, none of the spec constraints—such as the requirement that a sender MUST NOT generate protocol elements or syntax alternatives reserved for other roles—are addressed within this function.",success,
10495,dav_process_if_header,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",175,Fully Matches,"[{'C1': {'code': 'case \'<\':\n    /* Tagged-list production - following states apply to this uri */\n    if (list_type == no_tagged\n        || ((uri = dav_fetch_next_token(&str, \'>\')) == NULL)) {\n        return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                             DAV_ERR_IF_TAGGED, 0,\n                             ""Invalid If-header: unclosed \\""<\\"" or unexpected tagged-list production."");\n    }\n    ...\n    if ((rv = apr_uri_parse(r->pool, uri, &parsed_uri)) != APR_SUCCESS\n        || !parsed_uri.path) {\n        return dav_new_error(r->pool, HTTP_BAD_REQUEST,\n                             DAV_ERR_IF_TAGGED, rv,\n                             ""Invalid URI in tagged If-header."");\n    }', 'explanation': ""This segment verifies that the tagged part of the If header is well‐formed. When the expected grammar (e.g. closed '<' and proper URI) is not met, it returns an error with HTTP_BAD_REQUEST, fulfilling the spec requirement to reject malformed messages.""}}, {'A1': {'code': 'return dav_new_error(r->pool, HTTP_BAD_REQUEST, <...>, 0, <error message>);', 'explanation': ""Throughout the function, in various branches (e.g., unclosed parentheses, invalid tokens, multiple 'not' entries), the code consistently returns an error with HTTP_BAD_REQUEST. This aligns with the spec mandate to respond with a 400 (Bad Request) error upon receiving octets that do not meet the HTTP-message grammar.""}}]","The function 'dav_process_if_header' is dedicated to parsing the 'If:' header and includes checks for proper tokenization and valid URI formatting. In each case where the header does not conform to the expected grammar (for example, unclosed '<' or '(' tokens, invalid characters, or malformed URIs), the code returns an error object with the HTTP_BAD_REQUEST status. Additionally, the handling of whitespace characters (ignoring spaces and tabs) addresses the robustness exception mentioned in the specification. Since the function alone implements all the necessary error responses and ignores invalid input as prescribed by the specification, it fully meets the constraints laid out in the RFC.",success,
10499,dav_meets_conditions,An origin server that evaluates an If-Match condition MUST NOT perform the requested method if the condition evaluates to false,99,Partially Matches,"[{'C1': {'code': 'if ((if_match = apr_table_get(r->headers_in, ""If-Match"")) != NULL) {\n    if (if_match[0] == \'*\' && resource_state != DAV_RESOURCE_EXISTS)\n        return HTTP_PRECONDITION_FAILED;\n}', 'explanation': ""This segment directly checks if the If-Match header is '*' and if the resource does not exist, then it returns HTTP_PRECONDITION_FAILED, thereby preventing the requested method when the condition is false.""}}, {'A1': {'code': ""if (if_match[0] == '*' && resource_state != DAV_RESOURCE_EXISTS)\n    return HTTP_PRECONDITION_FAILED;"", 'explanation': ""By returning HTTP_PRECONDITION_FAILED when the condition is false, this code enforces the action specified by the RFC (i.e., not performing the request) in the case of an If-Match '*' condition.""}}]","The function partially implements the RFC requirement by directly handling the case where the If-Match header is '*'—ensuring that if the resource does not exist, it returns HTTP_PRECONDITION_FAILED, thus not performing the requested method. However, evaluation of a list of entity tags is delegated to the ap_meets_conditions function, so the function itself does not fully implement all aspects of the RFC condition handling.",success,
10499,dav_meets_conditions,"Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code",100,Partially Matches,"[{'C1': {'code': 'if ((if_match = apr_table_get(r->headers_in, ""If-Match"")) != NULL) {\n    if (if_match[0] == \'*\' && resource_state != DAV_RESOURCE_EXISTS)\n        return HTTP_PRECONDITION_FAILED;\n}', 'explanation': ""This segment verifies that when an If-Match header with '*' is seen, if the resource does not exist the function returns a 412 (Precondition Failed), thereby addressing the condition that if the match isn’t met the operation should not proceed.""}}, {'A1': {'code': 'return HTTP_PRECONDITION_FAILED;', 'explanation': 'This return statement is used to signal failure of the precondition as per the RFC where the origin server MAY indicate a conditional request failure.'}}]","The function directly addresses part of the RFC specification by checking an If-Match header with a value of '*' and returning a 412 status code when the resource does not exist. It also handles the If-None-Match '*' case by returning OK under certain conditions. However, further handling such as evaluating a list of entity tags or other complex conditional logic is not directly managed within this function (being delegated to ap_meets_conditions), rendering the implementation a partial match to the RFC specification in scope.",success,
10499,dav_meets_conditions,"When an origin server receives a request that selects a representation and that request includes an If-None-Match header field, the origin server MUST evaluate the If-None-Match condition per Section 13.2 prior to performing the method.",103,Partially Matches,"[{'C1': {'code': 'if ((if_none_match = apr_table_get(r->headers_in, ""If-None-Match"")) != NULL) {\n    if (if_none_match[0] == \'*\'\n        && resource_state != DAV_RESOURCE_EXISTS) {\n        return OK;\n    }\n}', 'explanation': ""This segment implements the evaluation of the If-None-Match header when its value is '*'. It returns OK if the resource does not exist, aligning with the spec requirement regarding the '*' value. However, handling for matching when a list of entity tags is provided is not done here (it is deferred to the ap_meets_conditions function), hence only part of the spec is addressed directly.""}}]","The function evaluates preconditions by first checking the If-Match header for '*' and then by calling ap_meets_conditions(r) for further evaluation. It contains explicit code to handle the special case for an If-None-Match header with a '*' value (C1), returning OK when the resource does not exist. However, the RFC also requires evaluation of lists of entity tags and other conditions (as noted in the spec and context), and this part of the logic is not visible in the function itself but is likely dealt with in the dependency function. Therefore, the function only partially meets the set of conditions and actions detailed in the spec constraints.",success,
10499,dav_meets_conditions,"When an origin server receives a request that selects a representation and that request includes an If-Match header field, the origin server MUST evaluate the If-Match condition per Section 13.2 prior to performing the method.",98,Partially Matches,"[{'C1': {'code': 'if ((if_match = apr_table_get(r->headers_in, ""If-Match"")) != NULL) {\n    if (if_match[0] == \'*\' && resource_state != DAV_RESOURCE_EXISTS)\n        return HTTP_PRECONDITION_FAILED;\n}', 'explanation': ""This segment implements the special case for the If-Match header when its value is '*'. According to the RFC, if the header is '*' then the condition is true only if the resource exists; otherwise the request must fail. This code checks if the resource does not exist and returns HTTP_PRECONDITION_FAILED, thereby directly addressing that part of the spec.""}}]","The function partially meets the RFC requirements by directly handling the special case where the If-Match header has the value '*'. However, the RFC also requires evaluating a list of entity tags to determine if any of them match the current entity tag. In this function, the evaluation of non-'*' header values is delegated to an external function call (ap_meets_conditions), which means that the full evaluation logic is not implemented within this function itself. Consequently, while the '*' condition (C1) is fully addressed, the other aspects are not handled directly, leading to a 'Partially Matches' judgment.",success,
10500,dav_validate_request,"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.",57,Fully Matches,"[{'C1': {'code': '/* Set the ETag header required by dav_meets_conditions() */\netag = apr_table_get(r->headers_out, ""ETag"");\nif (!etag) {\n    etag = (*resource->hooks->getetag)(resource);\n    if (etag && *etag) {\n        apr_table_set(r->headers_out, ""ETag"", etag);\n        set_etag = 1;\n    }\n}', 'explanation': ""This code segment checks if the outgoing headers already contain an ETag, and if not, it retrieves one using the resource's getetag hook and sets it. This directly implements the RFC requirement that the origin server should send an ETag for any selected representation to enable change detection and conditional requests.""}}]","The function visibly implements the RFC requirement by ensuring that an ETag header is provided when missing, thereby supporting the use of conditional requests and cache validation. The logic within the function addresses the constraint of providing a reliably determined ETag, fulfilling the specification's intent within this function alone.",success,
10500,dav_validate_request,"Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method.",282,Partially Matches,"[{'C1': {'code': 'etag = apr_table_get(r->headers_out, ""ETag"");\nif (!etag) {\n    etag = (*resource->hooks->getetag)(resource);\n    if (etag && *etag) {\n        apr_table_set(r->headers_out, ""ETag"", etag);\n        set_etag = 1;\n    }\n}\n\n/* Do the standard checks for conditional requests using\n * If-..-Since, If-Match etc */\nresource_state = dav_get_resource_state(r, resource);\nresult = dav_meets_conditions(r, resource_state);\nif (set_etag) {\n    apr_table_unset(r->headers_out, ""ETag"");\n}\nif (result != OK) {\n    return dav_new_error(r->pool, result, 0, 0, NULL);\n}', 'explanation': 'This segment sets up the ETag and then calls dav_meets_conditions to evaluate the HTTP preconditions, returning an error if the conditions are not met. It shows an attempt to evaluate preconditions after initial request checks.'}}, {'A1': {'code': '/* always parse (and later process) the If: header */\nif ((err = dav_process_if_header(r, &if_header)) != NULL) {\n    return err;\n}\n\n... (locktoken handling and further resource validation) ...', 'explanation': ""By parsing the 'If:' header and incorporating locktoken data when provided, the function attempts to implement conditional processing actions before proceeding with request content processing.""}}]","The function shows visible logic to evaluate HTTP request preconditions by preparing response headers, checking conditions via dav_meets_conditions, and parsing conditional headers. This satisfies a core aspect of the RFC requirement. However, it does not implement all aspects mentioned in the specification—particularly the part that requires preconditions to be ignored if the unconditioned request would not otherwise result in a 2xx or 412 status. The code only partially addresses the spec constraints by incorporating conditional checks, making the overall implementation a partial match.",success,
10502,dav_add_vary_header,"In any production that uses the list construct, a sender MUST NOT generate empty list elements.",236,Does Not Match,[],"The RFC specification requires that in any production using the list construct, empty list elements must not be generated. In the function provided, although logic is present to append a header value (DAV_LABEL_HDR) to the 'Vary' header, there is no explicit handling or validation to ensure that empty list elements are not produced. The code simply concatenates header values with a comma without checking if this process might result in an empty element. Therefore, no part of the function_body fully implements the check or behavior described in the spec constraint.",success,
10502,dav_add_vary_header,"A recipient MAY combine multiple field lines within a field section that have the same field name into one field line, without changing the semantics of the message, by appending each subsequent field line value to the initial field line value in order, separated by a comma ("","") and optional whitespace (OWS, defined in Section 5.6.3).",231,Partially Matches,"[{'C1': {'code': 'if (vary == NULL)\n    vary = DAV_LABEL_HDR;\nelse\n    vary = apr_pstrcat(out_req->pool, vary, "","" DAV_LABEL_HDR, NULL);', 'explanation': ""This code segment attempts to combine multiple header values by appending DAV_LABEL_HDR to an existing 'Vary' header using a comma separator. It addresses the basic requirement of merging field lines. However, the RFC and context specify that the values should be separated by a comma followed by a space (comma SP) for consistency, and the code does not insert the space.""}}]","The function dav_add_vary_header partially implements the RFC specification by appending new header values to the existing 'Vary' header using a comma separator, thereby preserving the order of received values. However, it does not fully meet the spec's requirement to insert a space after the comma, as indicated in the specification context, and thus is only a partial match.",success,
10502,dav_add_vary_header,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'A1': {'code': 'if (vary == NULL)\n    vary = DAV_LABEL_HDR;\nelse\n    vary = apr_pstrcat(out_req->pool, vary, "","" DAV_LABEL_HDR, NULL);\napr_table_setn(out_req->headers_out, ""Vary"", vary);', 'explanation': 'This code segment ensures that if a Vary header already exists, the new value (DAV_LABEL_HDR) is appended as a comma‐separated list. This addresses the RFC requirement that multiple values should be combined rather than creating separate header fields.'}}]","The RFC specifies that senders must not produce multiple header fields with the same name, except in cases where the field’s definition allows combining them into a comma-separated list. The function does attempt to conform to that part of the specification by checking if a Vary header already exists and then concatenating the additional value accordingly. However, the function only implements this logic for a specific header (DAV_LABEL_HDR when a target exists) and does not address other ordering concerns or the full range of conditions the RFC mandates. As a result, while it partially implements the required behavior (specifically, action A1), it does not fully cover all spec constraints. Therefore, the overall judgement is that the function partially matches the specification.",success,
10610,dav_generic_parse_locktoken,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'if (ap_strstr_c(char_token, ""opaquelocktoken:"") != char_token) {\n    return dav_new_error(p,\n                         HTTP_BAD_REQUEST, DAV_ERR_LOCK_UNK_STATE_TOKEN, 0,\n                         ""The lock token uses an unknown State-token ""\n                         ""format and could not be parsed."");\n}\nchar_token += 16;\n\nif (apr_uuid_parse(&locktoken->uuid, char_token)) {\n    return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN, 0,\n                         ""The opaquelocktoken has an incorrect format ""\n                         ""and could not be parsed."");\n}', 'explanation': ""This segment ensures that only lock tokens that strictly conform to the expected ABNF grammar (i.e., starting with 'opaquelocktoken:' and containing a parseable UUID) are processed. It prevents generating or accepting protocol elements that do not match the defined grammar.""}}]","The function checks the format of the lock token by verifying the required prefix and parsing the subsequent UUID. By returning errors for tokens that do not meet these criteria, it enforces that only protocol elements that conform to the ABNF grammar are generated or accepted, thereby fully addressing the specified HTTP RFC requirement.",success,
10610,dav_generic_parse_locktoken,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (ap_strstr_c(char_token, ""opaquelocktoken:"") != char_token) {\n    return dav_new_error(p,\n                         HTTP_BAD_REQUEST, DAV_ERR_LOCK_UNK_STATE_TOKEN, 0,\n                         ""The lock token uses an unknown State-token ""\n                         ""format and could not be parsed."");\n}\n\nchar_token += 16;\n\nlocktoken = apr_pcalloc(p, sizeof(*locktoken));\nif (apr_uuid_parse(&locktoken->uuid, char_token)) {\n    return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN, 0,\n                         ""The opaquelocktoken has an incorrect format ""\n                         ""and could not be parsed."");\n}', 'explanation': ""This code segment enforces that the received lock token follows the expected opaque lock token format by checking for the 'opaquelocktoken:' prefix and parsing the subsequent UUID. This directly aligns with the spec's mandate that a recipient must interpret a received protocol element according to the defined semantics.""}}]","The function implements a portion of the RFC by validating that the received lock token conforms to a known format. It checks for the required 'opaquelocktoken:' prefix and attempts to parse the expected UUID, returning errors if these checks fail. However, while this addresses the formal structure (one aspect of condition C1), the function does not cover broader error recovery strategies or other semantic interpretations (e.g., handling extensions or configurations based on sender behavior) outlined in the RFC specification. Therefore, the function only partially implements the necessary conditions from the RFC.",success,
10610,dav_generic_parse_locktoken,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, dav_generic_parse_locktoken, is solely focused on parsing and validating the syntax of a lock token—specifically ensuring it starts with ""opaquelocktoken:"" and that the remainder conforms to a UUID format. It does not implement any logic to ensure that a protocol element is not generated by a role which is not allowed to do so, as specified in the RFC requirement. Thus, while it enforces a grammatical structure, it does not address the condition about a sender not generating protocol elements or syntax alternatives reserved for other roles.",success,
10610,dav_generic_parse_locktoken,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (ap_strstr_c(char_token, ""opaquelocktoken:"") != char_token) {\n    return dav_new_error(p,\n                         HTTP_BAD_REQUEST, DAV_ERR_LOCK_UNK_STATE_TOKEN, 0,\n                         ""The lock token uses an unknown State-token ""\n                         ""format and could not be parsed."");\n}', 'explanation': 'This code checks that the input begins with the expected ""opaquelocktoken:"" prefix. This is a form of defensive parsing against an incorrectly formatted protocol element, aligning partially with the idea of only marginally expecting full conformance to ABNF grammar.'}}, {'A1': {'code': 'if (apr_uuid_parse(&locktoken->uuid, char_token)) {\n    return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN, 0,\n                         ""The opaquelocktoken has an incorrect format ""\n                         ""and could not be parsed."");\n}', 'explanation': 'This segment attempts to parse the remaining token as a UUID. It validates that the contents of the protocol element conform to an expected UUID format, which is an attempt to enforce a specific subset of the ABNF grammar associated with lock tokens.'}}]","The function implements defensive parsing by checking for the required prefix and by trying to parse the token as a UUID, returning errors when these validations fail. However, while it validates format, it does not perform additional defensive checks such as ensuring the token fits within a 'reasonable buffer size'—a key aspect mentioned in the RFC specification. As a result, the function only partially meets the specified conditions and actions.",success,
10611,dav_generic_format_locktoken,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function simply formats a lock token string by concatenating a fixed prefix ('opaquelocktoken:') with a formatted UUID. It does not perform any role checks, validations, or restrictions to ensure that protocol elements are only generated by the authorized sender, as required by the spec. No part of the function implements logic that addresses the condition prohibiting generation of protocol elements reserved for other roles.",success,
10621,dav_generic_get_supportedlock,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,36,Does Not Match,[],"The RFC specification requires that the message body be generated using only CRLF for line breaks between body parts. However, the provided function simply constructs and returns an XML fragment representing supported locks, using the DEBUG_CR macro to insert line breaks. There is no logic in the function that explicitly ensures or enforces that only CRLF (and not any other line break representation) is used. Additionally, the function's purpose (defining supported locks for WebDAV) is unrelated to the multipart message body handling specified in the RFC. Therefore, the code function does not visibly address the specified RFC constraint.",success,
10631,dav_generic_get_lockdb_path,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function simply retrieves a configuration value (lockdb_path) from the module's per-directory configuration and returns it. There is no logic in the function that evaluates or manipulates the Content-Location context or alters request semantics as described in the RFC specification and its constraints. Therefore, no labeled condition (e.g., C1) or action (e.g., A1) from the spec is implemented in this function.",success,
10711,dav_fs_open_stream,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function, dav_fs_open_stream, is solely concerned with opening file streams for reading or writing and does not contain any logic that processes or respects the HTTP Content-Location header context as described in the RFC specification. There is no code that addresses the constraint that an origin server MUST NOT use the context information to alter request semantics, nor is there any handling or checking of Content-Location values. Therefore, this function does not visibly implement any of the specified constraints (C1, A1, etc.) regarding the treatment of the Content-Location header.",success,
10721,dav_fs_remove_resource,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The RFC specifies that an origin server MUST NOT use context information (such as Content-Location provided by a user agent) to alter the request semantics. The provided function dav_fs_remove_resource is solely concerned with removing a resource (or collection of resources) from the filesystem. It contains logic for recursively deleting collections or removing individual files and updating the resource state accordingly. There is no visible logic within this function that inspects any request context or Content-Location header, nor is there any code that makes decisions based on that information. As a result, this function does not address the specified constraint from the RFC.",success,
10725,dav_fs_getetag,"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.",57,Partially Matches,[],"The function dav_fs_getetag performs a basic check to see if the resource exists and then populates an etag record (er) with metadata such as request_time, file info, and pathname. This establishes a foundation for generating an ETag, which is in line with the RFC’s specification that an origin server SHOULD send an ETag when change detection is possible. However, the actual creation and logic for robust change detection are delegated to the helper function ap_make_etag_ex, and no in‐function logic directly implements the nuanced requirements discussed in the RFC (e.g., determining a collision-resistant hash, applying internal revision numbers, or handling weak versus strong validators beyond setting force_weak to 0). As dependencies do not count toward this function’s implementation, the code only partially addresses the spec constraints.",success,
10726,dav_fs_insert_prop,"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.",57,Fully Matches,"[{'C1': {'code': 'case DAV_PROPID_getetag:\n        value = dav_fs_getetag(resource);', 'explanation': 'This segment shows that when the property ID corresponds to the ETag, the function retrieves an ETag value via dav_fs_getetag(resource) and proceeds to insert it into the response. This behavior directly implements the RFC requirement that an origin server SHOULD send an ETag for any selected representation.'}}]","The function includes explicit handling for the ETag property within its switch statement. For the case corresponding to DAV_PROPID_getetag, the function obtains an ETag value, thereby meeting the RFC specification's requirement for sending an entity tag when appropriate. All logic visible within this function for ETag generation and insertion addresses the labeled spec constraint, and no other dependencies outside of the function are used for this critical behavior.",success,
10728,dav_fs_patch_validate,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (cdata->next != NULL || strlen(cdata->text) != 1)\n    goto too_long;', 'explanation': 'This segment defensively checks that the text for the property is exactly one character long and that no additional text segments are present. This shows an attempt to validate the element against a narrowly defined expectation.'}}, {'A1': {'code': 'if (cdata == NULL) {\n    if (f_cdata == NULL) {\n        return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0, 0,\n                             ""The \'executable\' property expects a single character, valued \'T\' or \'F\'. There was no value submitted."");\n    }\n    cdata = f_cdata;\n}', 'explanation': ""This block handles the situation when the expected protocol element content is missing, returning an error message indicating the issue. It demonstrates a defensive parsing behavior by rejecting input that doesn't conform to the single-character expectation.""}}]","The RFC specifies that a recipient should parse received protocol elements defensively with only marginal assumptions about conformance. The function attempts to do this by enforcing that the value for the 'executable' property is exactly one character ('T' or 'F') and by returning errors when multiple text segments or an absent value is detected. However, the code explicitly notes via a comment that not all possible text items are checked. Consequently, while the function includes defensive checks (addressing aspects related to conditions C1 and actions A1), its approach is not fully comprehensive in handling all possible malformed inputs. This results in a judgment of 'Partially Matches.'",success,
10728,dav_fs_patch_validate,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (priv->propid != DAV_PROPID_FS_executable) {\n    *defer_to_dead = 1;\n    return NULL;\n}\n\nif (operation == DAV_PROP_OP_DELETE) {\n    return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0, 0,\n                         ""The \'executable\' property cannot be removed."");\n}\n\nvalue = cdata->text[0];\nif (value != \'T\' && value != \'F\') {\n    return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0, 0,\n                         ""The \'executable\' property expects a single character, valued \'T\' or \'F\'. The value submitted is invalid."");\n}', 'explanation': ""This segment verifies that only the 'executable' property is processed, ensures that deletion is forbidden, and validates that the property value is exactly one character ('T' or 'F'). It partially implements the RFC requirement to interpret protocol elements according to defined semantics.""}}, {'A1': {'code': 'if (cdata == NULL) {\n    if (f_cdata == NULL) {\n        return dav_new_error(resource->info->pool, HTTP_CONFLICT, 0, 0,\n                             ""The \'executable\' property expects a single character, valued \'T\' or \'F\'. There was no value submitted."");\n    }\n    cdata = f_cdata;\n}', 'explanation': 'This code attempts to recover a usable protocol element by checking an alternate text source (f_cdata) when the primary is missing, reflecting the RFC’s allowance for recovering from an invalid construct.'}}]","The function validates the 'executable' property by ensuring that only the appropriate property is handled, that deletion operations are rejected, and that the property value conforms to the strict specification ('T' or 'F' as a single character). It also makes an effort to recover a valid text element if the primary is absent. However, not all edge cases or error recovery mechanisms suggested by the RFC are fully covered within this function. Therefore, the implementation only partially matches the specified RFC constraints.",success,
10728,dav_fs_patch_validate,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function just validates that the 'executable' property, when patched, has a single character value of either 'T' or 'F'. It does not include any logic that checks whether or not the sender is generating protocol elements or syntax alternatives that are reserved for other roles as mandated by the RFC specification. There is no code that implements the role restriction (e.g., preventing a sender from generating elements only allowed for other participants), so this function does not visibly address the specified constraint.",success,
10734,dav_fs_insert_all_liveprops,"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.",57,Partially Matches,"[{'A1': {'code': '(void) dav_fs_insert_prop(resource, DAV_PROPID_getetag,\n                              what, phdr);', 'explanation': ""This line directly inserts the ETag property into the response's live properties when the resource exists and its hooks match the repository type. This demonstrates an attempt to implement the RFC requirement that an origin server should send an ETag for representations. However, the function does not include any logic for determining if changes can be reasonably and consistently detected, nor does it incorporate any further conditional checking or computation related to the ETag’s generation.""}}]","The RFC specifies that an origin server should send an ETag so that changes in a representation can be detected and cache behavior evaluated. In the provided function, the code attempts to fulfill that requirement by unconditionally inserting the ETag property (via dav_fs_insert_prop) for a resource that exists and is recognized as being 'our' resource. While this demonstrates an effort to conform to the specification, it does not incorporate additional logic for reliably determining when and how the ETag should be sent (such as evaluating change detection conditions), and thus only partially meets the complete intent of the RFC requirement.",success,
10734,dav_fs_insert_all_liveprops,"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.",52,Partially Matches,"[{'A1': {'code': '(void) dav_fs_insert_prop(resource, DAV_PROPID_getlastmodified,\n                              what, phdr);', 'explanation': ""This code segment attempts to insert the Last-Modified property for the resource, which corresponds to the action of sending Last-Modified as required by the RFC. It is invoked only when the resource exists, thus ensuring that a live property is added for a valid representation. However, the function does not incorporate logic to determine if the last modification date is 'reasonably and consistently determined' as the spec describes, relying instead on underlying resource data. Therefore, it only partially fulfills the RFC's requirement within this function alone.""}}]","The function dav_fs_insert_all_liveprops includes logic to insert the getlastmodified live property when the resource exists, thereby addressing the RFC's recommendation to send a Last-Modified header when appropriate. Nonetheless, it does not determine or validate that the last modification date is computed according to the spec and leaves that detail to lower-level code or dependencies. Consequently, the function partially matches the specification by handling the insertion of the property without fully implementing all conditions described in the RFC.",success,
10739,dav_fs_parse_locktoken,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (ap_strstr_c(char_token, ""opaquelocktoken:"") != char_token) {\n    return dav_new_error(p,\n                         HTTP_BAD_REQUEST, DAV_ERR_LOCK_UNK_STATE_TOKEN, 0,\n                         ""The lock token uses an unknown State-token ""\n                         ""format and could not be parsed."");\n}', 'explanation': ""The code checks whether the input token begins with the prefix 'opaquelocktoken:', which is a part of interpreting the received protocol element as per the defined semantics. This ensures that only tokens with the known format are processed further.""}}, {'A1': {'code': 'if (apr_uuid_parse(&locktoken->uuid, char_token)) {\n    return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN, 0,\n                         ""The opaquelocktoken has an incorrect format ""\n                         ""and could not be parsed."");\n}', 'explanation': 'By attempting to parse the remainder of the token as a UUID, the function enforces the expected format and semantics defined in the specification, thereby addressing proper interpretation of the protocol element.'}}]","The function implements basic checks to ensure that the lock token adheres to a specific opaque format by verifying its prefix and attempting UUID parsing. This addresses some of the RFC requirement to interpret the protocol element according to its defined semantics. However, the RFC also mentions that a recipient may attempt to recover a usable protocol element from an invalid construct or consider configuration‐based exceptions. The absence of such recovery or configuration-based handling within the function indicates that while it enforces format correctness, it does not comprehensively implement all possible aspects implied by the specification. Hence, the code function partially matches the constraints.",success,
10739,dav_fs_parse_locktoken,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'if (ap_strstr_c(char_token, ""opaquelocktoken:"") != char_token) {\n    return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_UNK_STATE_TOKEN, 0,\n                         ""The lock token uses an unknown State-token format and could not be parsed."");\n}\nchar_token += 16;\n\nif (apr_uuid_parse(&locktoken->uuid, char_token)) {\n    return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN, 0,\n                         ""The opaquelocktoken has an incorrect format and could not be parsed."");\n}', 'explanation': ""The function validates the lock token by first ensuring it begins with the required prefix 'opaquelocktoken:' and then checking that the following portion conforms to a valid UUID format using apr_uuid_parse. This enforces that the token matches the expected ABNF grammar, addressing the spec constraint.""}}]","The function implements explicit checks to ensure the lock token adheres to the expected format defined by the HTTP specification. It does this by verifying the token's prefix and using a UUID parser to validate the remainder of the token. This validation logic is sufficient by itself to meet the constraint that protocol elements must match the ABNF grammar, and no additional actions are required within this function. Hence, the function fully matches the specified constraint.",success,
10739,dav_fs_parse_locktoken,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function dav_fs_parse_locktoken only validates that the lock token string conforms to a fixed syntax (i.e., it must start with 'opaquelocktoken:' and follow with a valid UUID). It does not implement any logic related to the sender's role or the requirement that a sender must not generate protocol elements or syntax alternatives reserved for other roles. In other words, while it enforces a specific token format, it does not address the RFC requirement regarding role-based generation of protocol elements, and therefore no labeled constraint from the spec (e.g., C1, A1) is fully implemented within this function.",success,
10739,dav_fs_parse_locktoken,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (ap_strstr_c(char_token, ""opaquelocktoken:"") != char_token) {\n    return dav_new_error(p,\n                         HTTP_BAD_REQUEST, DAV_ERR_LOCK_UNK_STATE_TOKEN, 0,\n                         ""The lock token uses an unknown State-token ""\n                         ""format and could not be parsed."");\n}', 'explanation': 'This segment defensively checks that the received protocol element starts with the expected prefix, addressing the need to not assume the element conforms fully to its ABNF grammar.'}}, {'A1': {'code': 'if (apr_uuid_parse(&locktoken->uuid, char_token)) {\n    return dav_new_error(p, HTTP_BAD_REQUEST, DAV_ERR_LOCK_PARSE_TOKEN, 0,\n                         ""The opaquelocktoken has an incorrect format ""\n                         ""and could not be parsed."");\n}', 'explanation': 'This segment further validates the token by attempting to parse a UUID from the remainder of the string, thereby ensuring the element meets a specific expected format.'}}]","The function implements some defensive parsing measures by validating the token prefix and checking the format of the UUID portion. This shows an attempt to parse a received protocol element defensively, as suggested in the spec context. However, it does not cover all aspects mentioned in the RFC—such as checking for a reasonable buffer size or accommodating a wide range of possible valid variations in protocol elements. Therefore, the function only partially matches the full requirements of the spec constraints.",success,
10740,dav_fs_format_locktoken,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function simply formats a lock token by converting a UUID into a formatted string prefixed with 'opaquelocktoken:'. It does not contain any logic to verify or enforce that protocol elements or syntax alternatives match the sender's role as required by the RFC specification. There is no checking of roles or prevention of generating elements reserved for other participants within this function. As a result, the function does not implement or address the specified condition regarding role-based generation of protocol elements.",success,
10749,dav_fs_load_lock_record,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The function dav_fs_load_lock_record is primarily focused on reading, parsing, and processing lock record data from a database. Its logic is centered around processing binary data, handling lock expiration, and managing linked list structures for lock discovery and indirect locks. There is no visible implementation within this function that validates or ensures that any generated protocol elements conform to an ABNF grammar, as required by the spec’s mandate that a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. Since the function does not address any checking or generation of protocol elements in compliance with the ABNF grammar, it does not implement the relevant condition (C1) or any action (A1) related to the RFC specification.",success,
10751,dav_fs_get_supportedlock,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,36,Does Not Match,[],"The RFC requires that the sender must generate only CRLF to represent line breaks between body parts. The provided function simply returns a static XML string that embeds the macro DEBUG_CR, but it does not contain logic that verifies or enforces that only CRLF (i.e. ""\r\n"") is used as line breaks. Furthermore, the function is focused on returning supported lock XML fragments, not on handling multipart message framing or ensuring proper line break generation as mandated by the spec. Therefore, no part of the function directly meets any labeled spec conditions or actions.",success,
10773,dav_fs_quota_precondition,"If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value).",201,Partially Matches,"[{'C1': {'code': 'if ((lenhdr = apr_table_get(r->headers_in, ""Content-Length""))) {\n            if (!ap_parse_strict_length(&size, lenhdr)) {\n                status = HTTP_BAD_REQUEST;\n                *err = dav_new_error(r->pool, status, 0, 0,\n                                     ""client sent invalid Content-Length"");\n                goto out;\n            }\n        }', 'explanation': ""The function checks if the 'Content-Length' header is present (in a PUT request) and validates it using 'ap_parse_strict_length'. If the value cannot be parsed strictly, it returns an HTTP_BAD_REQUEST error, which partially implements the RFC requirement for handling invalid Content-Length header fields when Transfer-Encoding is not present. However, it does not account for the comma-separated list scenario allowed by the spec.""}}]","The function implements a check for the invalid Content-Length header by attempting to strictly parse it and returning a 400 error if the value is invalid. This aligns partially with the RFC specification for messages received without Transfer-Encoding and an invalid Content-Length. However, it does not implement the exception where a comma-separated list of identical values would be acceptable, nor does it consider the presence of a Transfer-Encoding header. Thus, only part of the spec condition is addressed in this function.",success,
10773,dav_fs_quota_precondition,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if ((lenhdr = apr_table_get(r->headers_in, ""Content-Length""))) {\n    if (!ap_parse_strict_length(&size, lenhdr)) {\n        status = HTTP_BAD_REQUEST;\n        *err = dav_new_error(r->pool, status, 0, 0,\n                             ""client sent invalid Content-Length"");\n        goto out;\n    }\n}', 'explanation': 'This segment checks the Content-Length header against strict parsing rules. It verifies that the header conforms to the expected grammatical format, which directly relates to the requirement that protocol elements (here, specifically the Content-Length header) must conform to their ABNF grammar.'}}]","The function implements a strict parsing check for the Content-Length header, ensuring that this protocol element adheres to its defined grammar. However, the RFC requirement mandates against generating any protocol elements that do not match the ABNF rules, which covers a broader scope than just validating the Content-Length header. Since the function only demonstrates compliance for one aspect (the validation of the Content-Length header) and does not address the totality of the sender’s obligations regarding protocol element generation, the implementation only partially matches the RFC specification.",success,
10773,dav_fs_quota_precondition,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, dav_fs_quota_precondition, is focused on verifying filesystem quota limits and ensuring that there is sufficient disk space before performing file operations. It does not contain any logic that addresses the RFC constraint stating that a sender must not generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. There is no validation or enforcement regarding roles or the generation of protocol elements. Therefore, the function does not visibly implement any of the specified conditions or actions related to the RFC.",success,
11056,dav_fs_get_quota,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function 'dav_fs_get_quota' focuses entirely on retrieving quota configuration for a directory path, using either the current request configuration or via a subrequest to obtain per-directory settings. It does not reference nor implement any logic related to handling the Content-Location header or ensuring that any context information is not used to alter the request semantics, as required by the RFC specification. None of the spec constraints (e.g., those labeled C1, A1, etc.) are addressed by this function's internal logic.",success,
11076,header_request_time,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function only formats and returns a string containing the request time (using r->request_time), and it does not reference or handle any context information, such as the Content-Location header. The RFC specification requires that an origin server MUST NOT use the context information from Content-Location to alter request semantics. No part of the function_body implements any logic to enforce or even acknowledge this constraint (e.g., checking, preserving, or ignoring Content-Location). Therefore, the code does not address any of the spec constraints.",success,
11077,unwrap_header,"A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the ""message/http"" media type.",301,Partially Matches,"[{'C1': {'code': 'if (ap_strchr_c(hdr, APR_ASCII_LF) || ap_strchr_c(hdr, APR_ASCII_CR)) {', 'explanation': 'This segment checks for the presence of LF or CR characters in the header, which are indicative of an obs-fold.'}}, {'A1': {'code': 'do {\n    if (*ptr == APR_ASCII_LF || *ptr == APR_ASCII_CR)\n        *ptr = APR_ASCII_BLANK;\n} while (*ptr++);', 'explanation': 'This loop replaces each occurrence of LF or CR with a blank space, effectively unwrapping any folded lines as required by the spec for received messages.'}}]","The function inspects the header for line fold characters (LF/CR) and replaces them with spaces, which aligns with the action mandated for handling obs-fold in received messages (replacing them prior to interpretation). However, it does not account for the exception in the spec that messages intended for packaging within the 'message/http' media type must not have their obs-fold replaced. Because this container-dependent logic is absent, the function only partially matches the full requirements of the RFC.",success,
11077,unwrap_header,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': 'if (ap_strchr_c(hdr, APR_ASCII_LF) || ap_strchr_c(hdr, APR_ASCII_CR)) {\n    char *ptr;\n\n    hdr = ptr = apr_pstrdup(p, hdr);\n\n    do {\n        if (*ptr == APR_ASCII_LF || *ptr == APR_ASCII_CR)\n            *ptr = APR_ASCII_BLANK;\n    } while (*ptr++);\n}', 'explanation': 'This segment detects any occurrence of CR or LF characters (which are considered part of bad whitespace in the context of the RFC) and replaces them with a blank. This behavior implements the requirement that any BWS (bad whitespace) be removed or normalized before further interpretation.'}}]","The function 'unwrap_header' identifies bad whitespace (specifically carriage returns and line feeds) in the header string and replaces them with a single blank character. This is in line with the RFC specification, which permits removal of such BWS before further processing. All relevant logic needed to address the removal/normalization of BWS is contained within this function, so it fully meets the specified constraint.",success,
11077,unwrap_header,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': 'if (ap_strchr_c(hdr, APR_ASCII_LF) || ap_strchr_c(hdr, APR_ASCII_CR)) { ... do { if (*ptr == APR_ASCII_LF || *ptr == APR_ASCII_CR) *ptr = APR_ASCII_BLANK; } while (*ptr++); }', 'explanation': 'The function explicitly checks for newline (LF) and carriage return (CR) characters in the header. Upon finding them, it duplicates the string and iterates over each character, replacing any LF or CR with a blank (space). This is in line with the RFC requirement that a recipient must parse for such bad whitespace and remove it (or in this context, replace it with a single space), thereby fulfilling the constraint.'}}]","The code function 'unwrap_header' inspects the header string for occurrences of CR and LF, and replaces them with a blank. This directly addresses the RFC instruction that recipients remove (or neutralize) bad whitespace before interpreting protocol elements. The logic within the function is self-contained and does not rely on external dependencies, and hence, it fully implements the specified RFC requirement.",success,
11077,unwrap_header,A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.,173,Fully Matches,"[{'C1': {'code': 'if (*ptr == APR_ASCII_LF || *ptr == APR_ASCII_CR)\n    *ptr = APR_ASCII_BLANK;', 'explanation': 'This code scans the header for any CR or LF characters and replaces them with a blank (SP). The RFC requires that bare CR characters be either considered invalid or replaced with SP, and this function replaces them (as well as LF) with SP before further processing, thereby addressing the specification.'}}]","The function unwrap_header duplicates the header string and then iterates over it, substituting any occurrence of CR or LF with a space. This behavior directly implements the specified RFC requirement that any bare CR (and, in this case, also LF) be replaced with SP prior to processing. The implementation is self-contained in this function, fulfilling its portion of the spec.",success,
11077,unwrap_header,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Partially Matches,"[{'A1': {'code': 'if (*ptr == APR_ASCII_LF || *ptr == APR_ASCII_CR) *ptr = APR_ASCII_BLANK;', 'explanation': 'This line replaces any CR or LF character with a blank. It shows an attempt to sanitize header values by eliminating raw control characters (i.e. replacing bare CR with SP), which is related to the RFC requirement. However, the RFC calls for replacing only bare CR (those not part of a proper CRLF sequence) whereas this implementation replaces all CR and LF characters indiscriminately.'}}]","The function checks if the header contains any CR or LF characters, duplicates the string for mutability, and then replaces every occurrence of these characters with a blank space. This indicates an attempt to address the RFC’s requirement regarding bare CR characters. However, because the code does not differentiate between bare CR and properly paired CRLF sequences—it replaces both—it only partially implements the specification. No separate logic is provided to inspect and preserve valid CRLF sequences, so while some sanitization is performed, it does not fully adhere to the nuanced handling mandated by the RFC.",success,
11077,unwrap_header,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Partially Matches,"[{'C1': {'code': 'if (ap_strchr_c(hdr, APR_ASCII_LF) || ap_strchr_c(hdr, APR_ASCII_CR)) { ... }', 'explanation': 'This segment checks for the presence of LF or CR in the header, which corresponds to recognizing that a line terminator may be just an LF (as permitted by the RFC).'}}, {'A1': {'code': 'if (*ptr == APR_ASCII_LF || *ptr == APR_ASCII_CR)\n    *ptr = APR_ASCII_BLANK;', 'explanation': 'This code replaces any encountered CR or LF with a blank (SP), fulfilling the action that a recipient SHOULD replace a bare CR with SP. However, it does so without discerning a proper CRLF pair from a bare CR.'}}]","The function attempts to handle header line terminations by searching for LF and CR characters and replacing them with a blank, which is an effort to comply with the RFC requirement that a recipient may treat a single LF as a valid line terminator and must replace any bare CR with SP. However, it oversimplifies the handling of CRLF sequences by unconditionally replacing them rather than correctly interpreting CRLF as a unit. Thus, it only partially matches the RFC constraints.",success,
11077,unwrap_header,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Does Not Match,[],"The RFC requires that any whitespace (arising from header folding) be excluded (i.e., removed) prior to field value evaluation. Although the function does process the header by detecting CR and LF characters, it only replaces them with a blank (space) rather than removing them. This approach does not fully implement the exclusion of such whitespace as mandated by the specification. Consequently, the function does not visibly address the constraint within its own logic.",success,
11077,unwrap_header,"Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message.",3,Partially Matches,"[{'A1': {'code': 'if (*ptr == APR_ASCII_LF || *ptr == APR_ASCII_CR)\n                *ptr = APR_ASCII_BLANK;', 'explanation': 'This code segment scans the header for CR or LF and replaces each occurrence with a space, meeting the RFC requirement to replace dangerous characters with SP.'}}]","The function unwrap_header checks the header for CR and LF characters and replaces them with a space. This addresses the RFC specification that mandates replacing CR and LF characters with SP to avoid dangerous parsing issues. However, the RFC also explicitly mentions NUL characters, and this function does not check for or handle NUL characters. Since it only addresses part of the spec (CR and LF, but not NUL), the match is considered only partial.",success,
11086,parse_format_tag,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'parse_format_tag' is primarily concerned with parsing a format tag string (handling literal strings, conditional formats, and looking up tag handlers) and does not contain any logic to enforce role-based restrictions on generating protocol elements. In other words, it does not address the RFC requirement that dictates a sender must not generate protocol elements that are only allowed to be generated by participants in other roles. There is no logic within the function that verifies the sender's role or restricts syntax alternatives based on that role.",success,
11088,header_inout_cmd,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,[],"The specification requires that a sender must not generate protocol elements that fall outside the defined ABNF grammar. In isolation, this function performs some parameter checking—it verifies that the header action is one of a preset list (set, add, etc.) and does some minimal processing such as trimming the header at a colon and compiling regular expressions where appropriate. These checks help prevent obviously malformed inputs. However, the function does not perform a thorough validation of the header elements against the full ABNF grammar specified by the HTTP RFC. In other words, while it does provide error handling and validation related to allowed operations, it does not fully enforce or validate the complete syntactic constraints (grammar) required by the RFC. Thus, only part of the requirement is addressed by this function’s logic.",success,
11144,set_cookie_exp,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, set_cookie_exp, focuses solely on parsing and setting expiration times for cookies based on numerical and textual input (such as 'years', 'months', etc.). It does not contain any logic that checks or enforces the HTTP RFC requirement about ensuring a sender does not generate protocol elements or syntax alternatives reserved for other roles. There is no conditional or action-based handling in the function that addresses the constraint (e.g., C1 or A1) related to sender roles or generating protocol-specific elements. As such, the function does not visibly address any of the specified RFC constraints within its own logic.",success,
11144,set_cookie_exp,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (apr_isdigit(arg[0]) && apr_isdigit(arg[strlen(arg) - 1])) {\n    cls->expires = atol(arg);\n    return NULL;\n}', 'explanation': 'This segment checks whether the whole input consists of digits and immediately converts it, showing an expectation that the value might come in a simple numeric form. This is a defensive check in line with the RFC’s suggestion of marginal expectations regarding conformity.'}}, {'A1': {'code': 'while (word[0]) {\n    /* <num> */\n    if (apr_isdigit(word[0]))\n        num = atoi(word);\n    else\n        return ""bad expires code, numeric value expected."";\n\n    /* <type> */\n    word = ap_getword_conf(parms->temp_pool, &arg);\n    if (!word[0])\n        return ""bad expires code, missing <type>"";\n\n    if (!strncasecmp(word, ""years"", 1))\n        factor = 60 * 60 * 24 * 365;\n    else if (!strncasecmp(word, ""months"", 2))\n        factor = 60 * 60 * 24 * 30;\n    else if (!strncasecmp(word, ""weeks"", 1))\n        factor = 60 * 60 * 24 * 7;\n    else if (!strncasecmp(word, ""days"", 1))\n        factor = 60 * 60 * 24;\n    else if (!strncasecmp(word, ""hours"", 1))\n        factor = 60 * 60;\n    else if (!strncasecmp(word, ""minutes"", 2))\n        factor = 60;\n    else if (!strncasecmp(word, ""seconds"", 1))\n        factor = 1;\n    else\n        return ""bad expires code, unrecognized type"";\n\n    modifier = modifier + factor * num;\n    word = ap_getword_conf(parms->temp_pool, &arg);\n}', 'explanation': 'This loop-based parsing of a complex tokenized input demonstrates defensive parsing: it validates that numeric parts are actually numeric, checks for the presence of the expected type token, and returns an error when the input does not follow the expected grammar. This directly addresses the RFC’s expectation to parse protocol elements defensively.'}}]","The function implements a defensive parsing strategy by carefully tokenizing the input and returning explicit error messages when deviations from the expected format are detected. This approach matches the RFC's recommendation to expect only marginal conformity to the expected grammar (and by extension, input of unpredictable length), even though explicit buffer size validations are not performed within this function. Therefore, the function partially matches the RFC specification by incorporating defensive parsing logic within its own scope.",success,
11152,start_ifversion,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'endp = arg2 + strlen(arg2);\n    if (   endp == arg2\n        || (!(arg3 && *arg3 == \'>\' && !arg3[1]) && *--endp != \'>\')) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           ""> directive missing closing \'>\'"", NULL);\n    }', 'explanation': ""This segment shows that the function is implementing defensive parsing by checking for the necessary closing delimiter (a '>') in the protocol element. It ensures the input minimally conforms to the expected format, aligning partly with the RFC’s recommendation to parse defensively.""}}]","The provided function implements defensive parsing by validating that required characters (like the closing '>') are present and by rejecting inputs that do not conform to this minimal expected format. However, it does not perform comprehensive checks such as verifying that the input fits within a reasonable buffer size or strictly enforcing the ABNF grammar. As such, the function only partially matches the RFC specification's constraints since only some aspects of defensive parsing are handled within this function.",success,
11169,remoteip_process_v1_header,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'end = memchr(hdr->v1.line, \'\\r\', len - 1);\nif (!end || end[1] != \'\\n\') {\n    return HDR_NEED_MORE; /* partial or invalid header */\n}\n*end = \'\\0\';\n*hdr_len = end + 2 - hdr->v1.line; /* skip header + CRLF */\n\napr_strtok(buf, "" "", &saveptr);\n\n/* parse family */\nGET_NEXT_WORD(""family"")\nif (strcmp(word, ""UNKNOWN"") == 0) {\n    conn_conf->client_addr = c->client_addr;\n    conn_conf->client_ip = c->client_ip;\n    return HDR_DONE;\n}\n... (further token extraction and field validation)', 'explanation': ""This section of the code verifies the overall structure of the header per the expected protocol format. It checks for proper CRLF termination and parses critical tokens such as the family, client-address, and port. By validating the structure and content, the function embodies the requirement that the recipient 'MUST interpret a received protocol element according to the semantics defined' in the specification.""}}, {'A1': {'code': 'if (strcmp(word, ""UNKNOWN"") == 0) {\n    conn_conf->client_addr = c->client_addr;\n    conn_conf->client_ip = c->client_ip;\n    return HDR_DONE;\n}', 'explanation': ""This branch handles the 'UNKNOWN' case by falling back to the connection's default address information. It shows an attempt to deal with a situation where the header does not provide a recognizable protocol element, aligning with the spec’s notion that a recipient may adopt alternative behaviors when the sender appears to implement the semantics incorrectly.""}}]","The function 'remoteip_process_v1_header' demonstrates a partial implementation of the RFC’s requirement for interpreting a received protocol element. It validates the structure (e.g., enforcing CRLF termination), tokenizes the content, and processes individual fields such as family, addresses, and ports. Additionally, the code provides a fallback for the 'UNKNOWN' family case. However, while it makes significant efforts toward interpreting the protocol semantics, it does not fully implement more nuanced recovery or extension handling mechanisms that might be expected from the complete specification. Thus, only some of the labeled conditions/actions are visibly addressed by this function.",success,
11169,remoteip_process_v1_header,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': ""end = memchr(hdr->v1.line, '\\r', len - 1);\nif (!end || end[1] != '\\n') {\n    return HDR_NEED_MORE; /* partial or invalid header */\n}"", 'explanation': 'The function checks for the proper CRLF sequence at the end of the header, which is a defensive parsing measure ensuring that the protocol element appears complete before further processing.'}}, {'A1': {'code': '#define GET_NEXT_WORD(field) \\\n    word = apr_strtok(NULL, "" "", &saveptr); \\\n    if (!word) { \\\n        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, c, APLOGNO(03497) \\\n                      ""RemoteIPProxyProtocol: no "" field "" found in header \'%s\'"", \\\n                      hdr->v1.line); \\\n        return HDR_ERROR; \\\n    }', 'explanation': 'This macro is used repeatedly to safely extract required tokens from the header. It defensively verifies the existence of each expected field and aborts processing if any are missing, in line with the requirement to parse elements defensively with minimal assumptions about formal conformance.'}}]","The function implements several defensive parsing checks such as ensuring the header ends with a CRLF sequence and validating the presence of required tokens using a dedicated macro. These measures show that the function addresses the defensive parsing requirement by not assuming full conformance to the expected ABNF grammar. However, it only partially covers all aspects mentioned in the specification (for instance, it does not enforce comprehensive buffer size validations or a complete grammar check), so overall it partially matches the RFC guidance.",success,
11169,remoteip_process_v1_header,"Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message.",3,Does Not Match,[],"The provided function does perform basic header termination checking (by looking for a CR followed by LF) but does not implement the RFC requirement to either reject or replace CR, LF, or NUL characters within field values. There is no logic ensuring that any CR, LF, or NUL characters that might appear within individual fields (beyond the header termination) are handled according to the specification. Therefore, the function does not visibly address the labeled condition from the spec.",success,
11169,remoteip_process_v1_header,A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.,173,Fully Matches,"[{'C1': {'code': ""end = memchr(hdr->v1.line, '\\r', len - 1);\n    if (!end || end[1] != '\\n') {\n        return HDR_NEED_MORE; /* partial or invalid header */\n    }"", 'explanation': 'The RFC requires that any bare CR (a CR not immediately followed by LF) be treated as invalid (or replaced with SP). This code checks for the presence of a CR and ensures that it is immediately followed by an LF; if not, it returns an error status (HDR_NEED_MORE), thereby treating the header as invalid in accordance with the specification.'}}]","The function directly inspects the header for a CR character and verifies that it is immediately followed by an LF. In the event that this condition is not met, the function returns HDR_NEED_MORE, which indicates an invalid or incomplete header. This behavior satisfies the requirement from the RFC that a bare CR (not followed by LF) must be considered invalid. Since this is the only relevant constraint from the spec for this function, and it is fully implemented within the function itself, the outcome is 'Fully Matches'.",success,
11174,remoteip_input_filter,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'ret = apr_brigade_length(ctx->bb, 1, &got);\n            if (ret || got > want) {\n                ap_log_cerror(APLOG_MARK, APLOG_ERR, ret, f->c, APLOGNO(10185)\n                              ""RemoteIPProxyProtocol header too long, got %"" APR_OFF_T_FMT "" expected %"" APR_OFF_T_FMT,\n                              got, want);\n                f->c->aborted = 1;\n                return APR_ECONNABORTED;\n            }', 'explanation': 'This snippet checks that the header data read does not exceed the expected amount (i.e. fits within a reasonable buffer size) and aborts the connection if it does, implementing a defensive parsing check per the RFC elements.'}}, {'A1': {'code': 'if (ctx->version == 0) {\n                if (ctx->rcvd >= MIN_HDR_LEN) {\n                    ctx->version = remoteip_determine_version(f->c, ctx->header);\n                    if (ctx->version < 0) {\n                        psts = HDR_ERROR;\n                    }\n                    else if (ctx->version == 1) {\n                        ctx->mode = AP_MODE_GETLINE;\n                        ctx->need = sizeof(proxy_v1);\n                    }\n                    else if (ctx->version == 2) {\n                        ctx->need = MIN_V2_HDR_LEN;\n                    }\n                }\n            }', 'explanation': 'This segment initiates a defensive parsing approach by not assuming a specific format until enough data has been read to determine the version, then adjusting expectations accordingly. It reflects an effort to handle protocol elements with only marginal expectations of conformity.'}}]","The function implements aspects of defensive parsing as outlined in the RFC specification. It monitors the length of the received header to ensure that the incoming data does not exceed acceptable limits and aborts the connection if it does (thus addressing the 'reasonable buffer size' part). It also defers detailed grammar processing to version-specific routines once enough data is gathered. However, while the code validates header length and changes its mode based on initial content, much of the actual conformance to the protocol grammar is managed by external functions (e.g., remoteip_process_v1_header, remoteip_process_v2_header), meaning that only part of the defensive parsing is handled directly within this function. As a result, it partially meets the specified defensive requirements of the RFC.",success,
11201,magic_rsl_to_request,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function primarily parses a 'magic' result to determine and set the MIME content type and optionally the content encoding in the request record. It does not contain any logic that explicitly checks or restricts the generation of protocol elements based on sender roles as required by the RFC specification. In other words, it does not inspect or enforce role-based restrictions (e.g., ensuring that elements only generated by permitted roles are not produced) within the message. Therefore, no part of the function visibly implements the condition (C1) or any actionable check (A1) as dictated by the RFC.",success,
11201,magic_rsl_to_request,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'if (!req_dat || !req_dat->head) {\n    /* empty - no match, we defer to other Apache modules */\n    return DECLINED;\n}', 'explanation': 'This segment checks whether media type information is available. If not, it does not set a Content-Type header, which aligns with the spec stating that the header should only be generated if the media type is known.'}}, {'A1': {'code': 'tmp = rsl_strdup(r, type_frag, type_pos, type_len);\n/* Convert to lower-case to normalize the media type */\nap_content_type_tolower(tmp);\nap_set_content_type_ex(r, tmp, 1);', 'explanation': 'This code constructs and sets the Content-Type header field when valid MIME type information is available. It meets the spec requirement that a sender SHOULD generate a Content-Type header for messages containing content.'}}]","The function processes the MIME type fragments from the request data and, if valid information is found, constructs the Content-Type header by lowercasing and setting it via ap_set_content_type_ex. It also appropriately defers (returns DECLINED) when no valid media type is available, thereby fully implementing the specified behavior from the RFC regarding generation of the Content-Type header based on known media types.",success,
11202,magic_process,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,44,Does Not Match,[],"The provided function 'magic_process' does not include any logic for handling Content-Length header field rules as specified in the RFC. There is no code present in the function that checks for a HEAD request or a 304 response, nor is there logic ensuring that Content-Length equals the correct number of octets. The function solely focuses on file-based processing (using fsmagic, reading file bytes, and calling tryit) and does not address any of the specified conditions or actions related to Content-Length header handling.",success,
11208,getstr,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (p >= pmax) {\n    ap_log_error(APLOG_MARK, APLOG_ERR, 0, serv, APLOGNO(01526) MODNAME "": string too long: %s"", origs);\n    break;\n}', 'explanation': 'This segment checks the length of the output buffer (p versus pmax) and logs an error if the limit is reached, demonstrating a defensive parsing strategy with respect to buffer limits, as suggested by the spec.'}}]","The function implements a defensive parsing mechanism by ensuring that the output buffer does not overflow and by handling escape sequences. This defensive approach aligns partially with the RFC requirement to handle protocol elements even if they only marginally conform to expected grammar or size limitations. However, the function does not perform comprehensive validation against the full ABNF grammar, so it does not fully implement all aspects of the RFC in isolation.",success,
11208,getstr,Recipients that process the value of a quoted-string MUST handle a quoted-pair as if it were replaced by the octet following the backslash.,242,Fully Matches,"[{'C1': {'code': ""if (c == '\\\\') {\n    switch (c = *s++) {\n    \n    case '\\0':\n        goto out;\n\n    default:\n        *p++ = (char) c;\n        break;\n\n    case 'n':\n        *p++ = '\\n';\n        break;\n\n    case 'r':\n        *p++ = '\\r';\n        break;\n\n    case 'b':\n        *p++ = '\\b';\n        break;\n\n    case 't':\n        *p++ = '\\t';\n        break;\n\n    case 'f':\n        *p++ = '\\f';\n        break;\n\n    case 'v':\n        *p++ = '\\v';\n        break;\n\n    /* handling octal and hexadecimal quoted-pairs */\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n        val = c - '0';\n        c = *s++;  /* try for 2 */\n        if (c >= '0' && c <= '7') {\n            val = (val << 3) | (c - '0');\n            c = *s++;  /* try for 3 */\n            if (c >= '0' && c <= '7')\n                val = (val << 3) | (c - '0');\n            else\n                --s;\n        } else\n            --s;\n        *p++ = (char) val;\n        break;\n\n    case 'x':\n        val = 'x';\n        c = hextoint(*s++);\n        if (c >= 0) {\n            val = c;\n            c = hextoint(*s++);\n            if (c >= 0) {\n                val = (val << 4) + c;\n                c = hextoint(*s++);\n                if (c >= 0)\n                    val = (val << 4) + c;\n                else\n                    --s;\n            } else\n                --s;\n        } else\n            --s;\n        *p++ = (char) val;\n        break;\n    }\n}"", 'explanation': 'When the function encounters a backslash in the input, it immediately reads the next character and interprets it according to various cases. In the default case, as well as in the specific handling of escape sequences (\\n, \\r, etc.), the function replaces the backslash sequence with the octet that follows (or its transformed value). This directly implements the RFC specification that quoted-pairs should be handled as though replaced by the octet following the backslash.'}}]","The function 'getstr' explicitly checks for the backslash character and processes the following character by either directly copying it or converting it according to common escape sequences and even octal or hexadecimal representations. This behavior is in line with the RFC requirement that when processing a quoted-string, a quoted-pair should be handled by replacing the backslash and its following octet with just that octet. All relevant processing is contained within the function, fulfilling the spec constraint.",success,
11225,magic_find_ct,"If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type.",35,Fully Matches,"[{'C1': {'code': 'if (r->content_type) {\n    return DECLINED;\n}', 'explanation': 'This check ensures that if a Content-Type header is already present, the function does not attempt to re-determine it. This is in line with the spec condition requiring action only when the header is missing.'}}, {'A1': {'code': '/* process it based on the file contents */\nif ((result = magic_process(r)) != OK) {\n    return result;\n}\n...\nreturn magic_rsl_to_request(r);', 'explanation': 'Once confirmed that the Content-Type header is missing, the function analyzes the file contents (via magic_process and magic_rsl_to_request) to determine the media type, which complies with the RFC option to examine the data when no header is provided.'}}]","The RFC specifies that if a Content-Type header is not present, the recipient MAY either assume a default media type or examine the data. This function first checks whether a Content-Type has already been set (fulfilling condition C1) and, if not, proceeds to analyze the file's contents using its magic processing functions (fulfilling action A1). Since examining the file contents is one acceptable method as per the RFC, the function fully implements the specified behavior within its own logic.",success,
11240,scan_meta_file,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (!(l = strchr(w, \':\'))) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01560)\n        ""malformed header in meta file: %s"", r->filename);\n    return HTTP_INTERNAL_SERVER_ERROR;\n}', 'explanation': 'This segment checks that each header line contains a colon, which is a minimal enforcement of header grammar. It prevents sending protocol elements that do not include the required separator, addressing the ABNF-based grammatical structure to some extent.'}}, {'A1': {'code': 'while (apr_isspace(*l))\n    ++l;\n\nif (!ap_cstr_casecmp(w, ""Content-type"")) {\n    char *endp = l + strlen(l) - 1;\n    while (endp > l && apr_isspace(*endp))\n        *endp-- = \'\\0\';\n\n    tmp = apr_pstrdup(r->pool, l);\n    ap_content_type_tolower(tmp);\n    ap_set_content_type(r, tmp);\n}', 'explanation': ""This code processes the header field 'Content-type' by trimming whitespace and converting the value to lowercase, ensuring that the header conforms to a normalized format before it is used in output. While not a complete ABNF check, it is an attempt to enforce a proper, predictable header format.""}}]","The function 'scan_meta_file' reads header lines from a meta file and performs minimal syntax checks: it ensures each non-empty line contains a colon to separate the header name from its value and processes specific headers (Content-type and Status) with basic normalization. These actions partially address the RFC requirement that a sender MUST NOT generate protocol elements that do not match the ABNF grammar. However, the implementation only covers a minimal check (e.g., colon existence and trimming whitespace) rather than rigorously validating against the full ABNF rules. Thus, while the function does implement some measures to enforce grammatical correctness, it only partially meets the specification.",success,
11240,scan_meta_file,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification mandates that a sender must not generate protocol elements or syntax alternatives that are reserved for participants in other roles. In examining the function_body, the code is solely responsible for scanning a meta file, parsing header lines, and setting the Content-Type and Status in the response. There is no explicit logic to check whether protocol elements being generated are allowed for the sender's role or to filter out elements that should only be generated by different participants. Therefore, none of the labeled constraints (such as C1 or any corresponding action like A1) addressing the role-based generation of protocol elements can be identified within this function, resulting in the determination that the code does not implement the specified RFC requirement by itself.",success,
11240,scan_meta_file,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': ""while (apr_file_gets(w, MAX_STRING_LEN - 1, f) == APR_SUCCESS) {\n    /* Delete terminal (CR?)LF */\n    p = strlen(w);\n    if (p > 0 && w[p - 1] == '\\n') {\n        if (p > 1 && w[p - 2] == '\\015')\n            w[p - 2] = '\\0';\n        else\n            w[p - 1] = '\\0';\n    }\n    \n    if (w[0] == '\\0') {\n        return OK;\n    }\n    ...\n}"", 'explanation': 'This loop reads each line from the file using a bounded buffer (MAX_STRING_LEN) and trims CR/LF characters. It demonstrates a defensive parsing approach by limiting expected input size and handling trivial non-conformities.'}}, {'A1': {'code': 'if (!(l = strchr(w, \':\'))) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01560)\n        ""malformed header in meta file: %s"", r->filename);\n    return HTTP_INTERNAL_SERVER_ERROR;\n}', 'explanation': 'This segment checks for a colon in the header line and, if missing, logs the error and aborts processing. It shows an action to handle non-conforming protocol elements defensively.'}}]","The RFC specifies that a recipient should parse protocol elements defensively, with only marginal assumptions regarding proper conformance to an ABNF grammar and reasonable lengths. In the function, defensive techniques are applied such as using a fixed maximum buffer to read lines, trimming extraneous CR/LF characters, and validating that a header is properly formatted by checking for a colon. While these steps address some aspects of defensive parsing as per the RFC, the implementation does not cover more thorough ABNF validation or dynamic length handling that may be required in some contexts. Thus, the function partially meets the specification.",success,
11240,scan_meta_file,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'while (apr_file_gets(w, MAX_STRING_LEN - 1, f) == APR_SUCCESS) {\n    /* Delete terminal (CR?)LF */\n    p = strlen(w);\n    if (p > 0 && w[p - 1] == \'\\n\') {\n        if (p > 1 && w[p - 2] == \'\\015\')\n            w[p - 2] = \'\\0\';\n        else\n            w[p - 1] = \'\\0\';\n    }\n\n    if (w[0] == \'\\0\') {\n        return OK;\n    }\n\n    if (!(l = strchr(w, \':\'))) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01560)\n            ""malformed header in meta file: %s"", r->filename);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    *l++ = \'\\0\';\n    while (apr_isspace(*l))\n        ++l;\n\n    if (!ap_cstr_casecmp(w, ""Content-type"")) {\n        char *tmp;\n        char *endp = l + strlen(l) - 1;\n        while (endp > l && apr_isspace(*endp))\n            *endp-- = \'\\0\';\n\n        tmp = apr_pstrdup(r->pool, l);\n        ap_content_type_tolower(tmp);\n        ap_set_content_type(r, tmp);\n    }\n    else if (!ap_cstr_casecmp(w, ""Status"")) {\n        sscanf(l, ""%d"", &r->status);\n        r->status_line = apr_pstrdup(r->pool, l);\n    }\n    else {\n        apr_table_set(tmp_headers, w, l);\n    }\n}\napr_table_overlap(r->headers_out, tmp_headers, APR_OVERLAP_TABLES_SET);\nreturn OK;', 'explanation': ""This loop reads each line from the meta file, trims it, splits it based on a colon, and interprets known header fields ('Content-type' and 'Status'). In doing so, it is directly interpreting a received protocol element per RFC requirements.""}}]","The provided function attempts to interpret meta file header lines as protocol elements, fulfilling part of the RFC requirement that a recipient must interpret received protocol elements according to their defined semantics. It handles expected header fields by trimming whitespace, parsing content-type (including lowercasing) and status codes, and populates a header table. However, the function does not implement the additional part of the RFC which allows a recipient to determine (based on experience or configuration) that the sender incorrectly implements the protocol or to attempt recovery from an invalid construct. Specifically, upon encountering a malformed header (one that lacks a colon), it logs an error and immediately returns an internal server error rather than attempting any recovery. Therefore, while it visibly addresses condition C1 from the spec (interpreting protocol elements), it does not address the extended error-handling or sender-implementation determination aspects. In isolation, this function only partially matches the RFC specification.",success,
11240,scan_meta_file,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': ""p = strlen(w);\nif (p > 0 && w[p - 1] == '\\n') {\n    if (p > 1 && w[p - 2] == '\\015')\n        w[p - 2] = '\\0';\n    else\n        w[p - 1] = '\\0';\n}"", 'explanation': 'This code removes a trailing newline (and carriage return, if present) from the header line. It is an example of attempting to sanitize/normalize the input, which can be seen as a basic recovery mechanism for invalid constructs (e.g. extra whitespace), consistent with the RFC’s allowance to recover a usable element.'}}, {'A1': {'code': ""char *endp = l + strlen(l) - 1;\nwhile (endp > l && apr_isspace(*endp))\n    *endp-- = '\\0';"", 'explanation': 'For the Content-type header, this snippet trims trailing whitespace from the header value to ensure that only the significant part is used; this is in the spirit of recovering a usable protocol element from a potentially malformed one.'}}]","The function reads header lines from a meta file and includes logic to sanitize the input by removing terminal newline characters and extraneous trailing whitespace. Such processing aligns with the RFC’s note that a recipient MAY attempt to recover a usable protocol element from an invalid construct. However, while these aspects (e.g. whitespace trimming) are implemented, the function does not always recover from invalid input: if a header line does not contain a colon, it logs an error and returns an internal server error rather than attempting any further recovery. Thus, the function addresses some aspects of the specification but not comprehensively, so it is judged to only partially match the specified requirements.",success,
11240,scan_meta_file,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Partially Matches,"[{'C1': {'code': 'while (apr_isspace(*l))\n    ++l;', 'explanation': 'This loop removes leading whitespace from the field value after the colon, addressing the requirement to exclude such whitespace.'}}, {'A1': {'code': 'if (!ap_cstr_casecmp(w, ""Content-type"")) {\n    char *tmp;\n    /* Nuke trailing whitespace */\n    char *endp = l + strlen(l) - 1;\n    while (endp > l && apr_isspace(*endp))\n        *endp-- = \'\\0\';\n\n    tmp = apr_pstrdup(r->pool, l);\n    ap_content_type_tolower(tmp);\n    ap_set_content_type(r, tmp);\n}', 'explanation': ""This block specifically trims trailing whitespace for the 'Content-type' header, which is in line with the RFC's requirement to exclude trailing whitespace prior to evaluation.""}}]","The function processes header lines from a meta file and attempts to remove unwanted whitespace. It clears leading whitespace for all header fields and explicitly trims trailing whitespace for 'Content-type'. However, it does not consistently apply trailing whitespace removal to all headers (e.g., for the 'Status' header or others), meaning the implementation only partially meets the specified RFC requirement that field values must be stripped of both leading and trailing whitespace before evaluation.",success,
11240,scan_meta_file,A sender MUST NOT generate BWS in messages.,239,Does Not Match,[],"The provided function reads and normalizes header values from a meta file (for instance, by stripping leading whitespace after the colon and trimming trailing whitespace for the Content-type header), which is consistent with recipient-side normalization. However, the HTTP RFC specification states that a sender MUST NOT generate bad whitespace (BWS) in messages. This function does not implement any logic to prevent the generation of extra whitespace on the sender side—it only processes (and partially cleans) input headers. Therefore, there is no visible implementation in the function addressing the sender’s prohibition against generating BWS.",success,
11240,scan_meta_file,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': '        /* Delete terminal (CR?)LF */\n        p = strlen(w);\n        if (p > 0 && w[p - 1] == \'\\n\') {\n            if (p > 1 && w[p - 2] == \'\\015\')\n                w[p - 2] = \'\\0\';\n            else\n                w[p - 1] = \'\\0\';\n        }\n\n        ...\n\n        *l++ = \'\\0\';\n        while (apr_isspace(*l))\n            ++l;\n\n        if (!ap_cstr_casecmp(w, ""Content-type"")) {\n            char *endp = l + strlen(l) - 1;\n            while (endp > l && apr_isspace(*endp))\n                *endp-- = \'\\0\';\n            ...\n        }', 'explanation': ""The function removes trailing newline characters (including CR-LF) and then explicitly removes leading whitespace from the header value immediately after the colon. For the 'Content-type' header, it additionally removes trailing whitespace. This directly implements the RFC requirement to parse for and remove bad whitespace before interpreting protocol elements.""}}]","The code function explicitly trims both leading and trailing bad whitespace from header lines, ensuring that any extraneous whitespace is removed before the protocol elements are processed. This directly aligns with the specified RFC requirement, and thus the function fully meets the condition (C1) defined in the RFC specification.",success,
11240,scan_meta_file,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,"[{'C1': {'code': 'if (!ap_cstr_casecmp(w, ""Content-type"")) {\n    char *tmp;\n    /* Nuke trailing whitespace */\n    char *endp = l + strlen(l) - 1;\n    while (endp > l && apr_isspace(*endp))\n        *endp-- = \'\\0\';\n\n    tmp = apr_pstrdup(r->pool, l);\n    ap_content_type_tolower(tmp);\n    ap_set_content_type(r, tmp);\n}', 'explanation': ""This segment checks whether the header line is 'Content-type' and, if so, it processes the value (trimming and converting to lower case) before setting it via ap_set_content_type. This addresses the requirement for generating a Content-Type header when content is present. However, it does not implement any logic for determining if the intended media type is unknown, which is required by the RFC to decide whether to set the header. Thus, it only partially implements the specified behavior.""}}]","The function scans a meta file and extracts header information. When it identifies a 'Content-type' header, it processes and sets the Content-Type header in the response. This directly meets part of the RFC requirement that a sender should generate a Content-Type header when content is present. However, because the code does not include logic to handle cases where the intended media type is unknown (and potentially to omit or set a default value accordingly), the implementation only partially matches the full specification described in the RFC.",success,
11240,scan_meta_file,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Fully Matches,"[{'C1': {'code': ""p = strlen(w);\nif (p > 0 && w[p - 1] == '\\n') {\n    if (p > 1 && w[p - 2] == '\\015')\n        w[p - 2] = '\\0';\n    else\n        w[p - 1] = '\\0';\n}"", 'explanation': ""This code segment explicitly checks for a newline ('\\n') at the end of a string and, if found, further checks if it is preceded by a carriage return ('\\015'). In the case of a CRLF sequence, it removes both characters; if only LF is present, it removes just the LF. This directly implements the RFC specification outlining that a single LF should be recognized as a line terminator with any preceding CR being ignored.""}}]","The function contains explicit logic that handles the removal of line terminators in compliance with the RFC specification. It identifies both CRLF and bare LF sequences as valid line terminators and adjusts the string accordingly. As this implementation fully addresses the requirement described in the RFC, the analysis determines that the function fully matches the specified constraint.",success,
11240,scan_meta_file,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Does Not Match,[],"The RFC specification requires that a sender must not generate a bare CR (i.e. a CR not immediately followed by LF) within any protocol elements other than the content. In this function, the only related logic is the code that trims a trailing newline sequence by checking if the last character is '\n' and, if preceded by '\015', removing both characters. This logic only deals with CRLF at the end of each line and does not scan for or otherwise handle bare CR characters that may appear within the line. Therefore, this function does not implement the specific RFC constraint regarding bare CR generation.",success,
11363,h2_bucket_headers_clone,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function h2_bucket_headers_clone only clones header data by calling h2_headers_clone and then creating a new bucket with h2_bucket_headers_create. It does not include any logic that restricts or checks protocol element generation based on sender roles, nor does it validate against the ABNF grammar or enforce any role-specific constraints as required by the provided RFC specification. As a result, no part of this function addresses any of the specified conditions (C1, C2, etc.) or actions (A1, A2, etc.) from the RFC.",success,
11368,h2_headers_rcreate,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (headers->status == HTTP_FORBIDDEN) {\n    request_rec *r_prev;\n    for (r_prev = r; r_prev != NULL; r_prev = r_prev->prev) {\n        const char *cause = apr_table_get(r_prev->notes, ""ssl-renegotiate-forbidden"");\n        if (cause) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, headers->status, r,\n                          APLOGNO(10399)\n                          ""h2_headers(%ld): renegotiate forbidden, cause: %s"",\n                          (long)r->connection->id, cause);\n            headers->status = H2_ERR_HTTP_1_1_REQUIRED;\n            break;\n        }\n    }\n}', 'explanation': 'This segment checks for a condition (TLS renegotiation not allowed) that implies a protocol element (renegotiation) forbidden in HTTP/2. In response, it changes the header status to H2_ERR_HTTP_1_1_REQUIRED, which is an attempt to signal that an element reserved to another role (HTTP/1.1) should be used instead.'}}, {'A1': {'code': 'if (is_unsafe(r->server)) {\n    apr_table_setn(headers->notes, H2_HDR_CONFORMANCE, H2_HDR_CONFORMANCE_UNSAFE);\n}', 'explanation': 'This code sets a note indicating unsafe header conformance, indirectly flagging that protocol elements might not be generated correctly according to the sender’s role.'}}]","The function includes logic that reacts to forbidden TLS renegotiations and marks headers with a conformance note. These actions partially address the RFC constraint by trying to avoid generating protocol elements that are not appropriate for the sender’s role (e.g., switching error handling to HTTP/1.1 when necessary and flagging unsafe configurations). However, the function does not comprehensively verify or enforce that all protocol elements are generated only within the allowed role. Thus, while some aspects are covered, they only partially meet the specified requirement.",success,
11368,h2_headers_rcreate,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function 'h2_headers_rcreate' focuses on creating and modifying HTTP/2 header objects, handling special cases such as TLS renegotiation issues and unsafe server conditions. However, there is no logic within this function that inspects or verifies if generated protocol elements adhere to the ABNF grammar rules, which is the core requirement stated in the RFC. Hence, this function does not visibly implement the necessary check to ensure that protocol elements match the defined grammar.",success,
11371,h2_headers_die,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC specification mandates that a sender must not generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. This function only allocates header structures and sets some headers (such as 'Date' and 'Server') by delegating string generation to external helper functions (ap_recent_rfc822_date and ap_get_server_banner). There is no intrinsic logic within this function that enforces or validates that the generated protocol elements adhere to the ABNF grammar. Therefore, while it constructs header fields, it does not visibly address the specific requirement regarding conformance to the ABNF grammar as mandated by the RFC.",success,
11371,h2_headers_die,An origin server MAY generate a Server header field in its responses.,89,Fully Matches,"[{'C1': {'code': 'apr_table_setn(headers->headers, ""Server"", ap_get_server_banner());', 'explanation': ""This line explicitly sets the 'Server' header by calling ap_get_server_banner(), thereby directly implementing the RFC requirement that an origin server MAY generate a Server header field in its responses.""}}]","The function_body creates the headers structure for an HTTP response and populates it with both a 'Date' header and a 'Server' header. By invoking ap_get_server_banner() and assigning its result to the 'Server' header, the code visibly attempts to implement the RFC spec regarding the optional generation of the Server header field. Consequently, within the confines of this function, all aspects of the spec constraint concerning the Server header are handled.",success,
11371,h2_headers_die,"When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.",245,Does Not Match,[],"The RFC specification requires that timestamps be generated in the IMF-fixdate format. In the code, the Date header is set using the function ap_recent_rfc822_date, which produces a date in the RFC822 format rather than the required IMF-fixdate. Since the function does not contain any logic to produce an IMF-fixdate timestamp, it does not meet the specified HTTP RFC constraint.",success,
11371,h2_headers_die,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function populates standard HTTP headers like Status, Date, and Server without any logic that checks or enforces the sender’s role constraints as required by the RFC specification. There is no implementation of conditional logic to prevent generation of protocol elements or syntax alternatives that are meant only for other roles. The function simply creates and initializes headers, and does not validate whether these elements are allowed based on the sender's role. Therefore, the function does not visibly address any of the labeled spec constraints (such as C1 or A1) by itself.",success,
11371,h2_headers_die,"An origin server with a clock (as defined in Section 5.6.7) MUST generate a Date header field in all 2xx (Successful), 3xx (Redirection), and 4xx (Client Error) responses, and MAY generate a Date header field in 1xx (Informational) and 5xx (Server Error) responses.",16,Fully Matches,"[{'C1': {'code': 'headers->status = (type >= 200 && type < 600)? type : 500;\n...\napr_table_setn(headers->headers, ""Date"", date);', 'explanation': 'The function ensures that for response codes within the valid range (i.e., 2xx, 3xx, 4xx, and even 5xx based on the fallback) a Date header is generated, thereby satisfying the RFC requirement that an origin server with a clock MUST generate a Date header field in these responses.'}}, {'A1': {'code': 'date = apr_palloc(pool, APR_RFC822_DATE_LEN);\nap_recent_rfc822_date(date, req? req->request_time : apr_time_now());', 'explanation': ""This code segment shows that the function sets the Date header using the best available approximation of the current date and time (using the request time if provided or the current time), in compliance with the specification's recommendation regarding the timing of message generation.""}}]","The function_body directly implements the generation of a Date header by unconditionally creating a properly formatted RFC822 date value and setting it in the response header table. It aligns with the RFC specification that mandates an origin server with a clock to include a Date header in 2xx, 3xx, and 4xx responses (and optionally in 1xx and 5xx responses). The function does not rely on external dependencies to fulfill this requirement, and the core logic (checking response code validity and generating the date) is present within the function. Therefore, the code fully matches the outlined constraints.",success,
11371,h2_headers_die,A sender that generates a Date header field SHOULD generate its field value as the best available approximation of the date and time of message generation.,15,Fully Matches,"[{'C1': {'code': 'date = apr_palloc(pool, APR_RFC822_DATE_LEN);\n    ap_recent_rfc822_date(date, req? req->request_time : apr_time_now());\n    apr_table_setn(headers->headers, ""Date"", date);', 'explanation': ""The function allocates memory for a date string, then uses either the request's timestamp (req->request_time) or the current time (apr_time_now()) to generate an RFC822-formatted date, which is then set as the Date header. This directly implements the specification to provide the best approximation of the date and time of message generation.""}}]","The function directly addresses the RFC requirement by generating and setting a Date header field based on the best available timestamp from the request or current time. All logic necessary for fulfilling the specified condition is contained entirely within the function_body, with no dependence on external callers.",success,
11378,h2_request_create,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function simply creates and initializes a request object by assigning values to its fields. There is no logic present in this function that checks or enforces any protocol role constraints (e.g., ensuring that only allowed protocol elements are generated by a sender) as specified in the RFC. Therefore, the code does not address the requirement that a sender must not generate protocol elements or syntax alternatives reserved for other roles.",success,
11380,h2_request_rcreate,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function h2_request_rcreate does not include any logic that enforces the requirement from the RFC specification. The RFC states that a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. However, the function simply extracts and duplicates various request components (scheme, authority, path, headers) and reassembles them into an internal structure without checking or limiting protocol elements based on the sender’s role. No conditional checks, role validations, or restrictions are implemented in this function to ensure that only the allowed protocol elements are generated for the sender’s role. Therefore, the code does not visibly address any of the labeled conditions (C1, etc.) or actions (A1, etc.) required by the RFC.",success,
11380,h2_request_rcreate,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'if (!ap_strchr_c(authority, \':\')) {\n    if (r->parsed_uri.port_str) {\n        /* Yes, it was there, add it again. */\n        authority = apr_pstrcat(pool, authority, "":"", r->parsed_uri.port_str, NULL);\n    }\n    else if (!r->parsed_uri.hostname && r->server && r->server->port) {\n        /* If URL was relative, restore port from server->port if not default for scheme. */\n        apr_port_t defport = apr_uri_port_of_scheme(scheme);\n        if (defport != r->server->port) {\n            authority = apr_psprintf(pool, ""%s:%d"", authority, (int)r->server->port);\n        }\n    }\n}', 'explanation': ""The code checks whether the authority already contains a port (by looking for a colon). If a port is explicitly present in the parsed URI (r->parsed_uri.port_str), it appends that port. Additionally, if the request is relative (no hostname in parsed URI) and the server port is non-default for the scheme, it appends the server's port. If no port is provided or if the provided port is the default port for the scheme, it leaves the port out so that a recipient may interpret it as default, which fully implements the spec's requirement.""}}]","The function implements the logic specified in the RFC by conditionally appending the port information to the authority field. When no port is provided or when the port is the default for the given scheme, the function leaves it out, thereby allowing the recipient to assume the default port. This visible handling in the function meets the labeled condition (C1) from the RFC spec.",success,
11380,h2_request_rcreate,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Fully Matches,"[{'C1': {'code': 'if (!r->method || !scheme || !r->hostname || !path) {\n    return APR_EINVAL;\n}', 'explanation': 'This segment verifies that r->hostname (the host identifier) is present. If it is empty, the function returns an error, thereby preventing generation of an HTTP URI with an empty host identifier.'}}]","The function explicitly checks that the hostname is provided by evaluating !r->hostname (among other parameters) and returns an error if any required component is missing. This ensures that an HTTP URI with an empty host identifier is not generated, which fully implements the specified RFC constraint.",success,
11381,h2_request_add_header,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (name[0] == \':\') {\n    /* pseudo header, see ch. 8.1.2.3, always should come first */\n    if (!apr_is_empty_table(req->headers)) {\n        ap_log_perror(APLOG_MARK, APLOG_ERR, 0, pool,\n                      APLOGNO(02917)\n                      ""h2_request: pseudo header after request start"");\n        return APR_EGENERAL;\n    }', 'explanation': 'This segment checks that pseudo headers are received first and rejects a pseudo header that appears after the request has started, which is an interpretation requirement of the RFC.'}}, {'C2': {'code': 'if (H2_HEADER_METHOD_LEN == nlen && !strncmp(H2_HEADER_METHOD, name, nlen)) {\n    req->method = apr_pstrndup(pool, value, vlen);\n}\nelse if (H2_HEADER_SCHEME_LEN == nlen && !strncmp(H2_HEADER_SCHEME, name, nlen)) {\n    req->scheme = apr_pstrndup(pool, value, vlen);\n}\nelse if (H2_HEADER_PATH_LEN == nlen && !strncmp(H2_HEADER_PATH, name, nlen)) {\n    req->path = apr_pstrndup(pool, value, vlen);\n}\nelse if (H2_HEADER_AUTH_LEN == nlen && !strncmp(H2_HEADER_AUTH, name, nlen)) {\n    req->authority = apr_pstrndup(pool, value, vlen);\n}\nelse if (H2_HEADER_PROTO_LEN == nlen && !strncmp(H2_HEADER_PROTO, name, nlen)) {\n    req->protocol = apr_pstrndup(pool, value, vlen);\n}', 'explanation': 'This part interprets known pseudo headers by comparing names and storing their corresponding values into designated request fields, aligning with the RFC requirement to interpret protocol semantics.'}}, {'A1': {'code': 'else {\n    char buffer[32];\n    memset(buffer, 0, 32);\n    strncpy(buffer, name, (nlen > 31)? 31 : nlen);\n    ap_log_perror(APLOG_MARK, APLOG_WARNING, 0, pool,\n                  APLOGNO(02954)\n                  ""h2_request: ignoring unknown pseudo header %s"",\n                  buffer);\n}', 'explanation': 'This segment logs a warning and ignores any unknown pseudo headers, which can be seen as an attempt to recover a usable protocol element from an unrecognized construct.'}}]","The function h2_request_add_header examines incoming header fields and addresses some aspects of the RFC's requirement that a recipient must interpret a protocol element according to its defined semantics. It enforces that pseudo headers come first (C1) and maps known pseudo headers to their respective fields (C2). It also handles unknown pseudo headers gracefully by issuing a warning (A1). However, not all aspects of the RFC (such as broader error recovery strategies or additional semantic validations) are handled by this function alone, leading to the conclusion that it only partially matches the full specification requirements.",success,
11381,h2_request_add_header,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (name[0] == \':\') {\n    /* pseudo header, see ch. 8.1.2.3, always should come first */\n    if (!apr_is_empty_table(req->headers)) {\n        ap_log_perror(APLOG_MARK, APLOG_ERR, 0, pool,\n                      APLOGNO(02917)\n                      ""h2_request: pseudo header after request start"");\n        return APR_EGENERAL;\n    }', 'explanation': ""This code segment enforces that pseudo headers (which are protocol elements assigned to specific roles) must be added before any other headers, ensuring that a sender doesn't generate pseudo headers after the request has started, in accordance with the specification.""}}]","The function partially implements the spec by verifying that pseudo headers are added only at the beginning of the header list, which prevents a sender from later injecting protocol elements that are reserved for specific roles. While this directly relates to the requirement specified, the function does not implement additional checks or actions related to syntax alternatives or other aspects of role-specific protocol element generation. Therefore, the match is only partial.",success,
11381,h2_request_add_header,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (name[0] == \':\') {\n    /* pseudo header, see ch. 8.1.2.3, always should come first */\n    if (!apr_is_empty_table(req->headers)) {\n        ap_log_perror(APLOG_MARK, APLOG_ERR, 0, pool,\n                      APLOGNO(02917)\n                      ""h2_request: pseudo header after request start"");\n        return APR_EGENERAL;\n    }\n    ...\n}', 'explanation': 'This segment checks that pseudo headers (which are part of the protocol grammar) appear only at the start of the header list. By enforcing that a pseudo header must come before any regular header, it partially addresses the requirement that protocol elements conform to the ABNF-defined grammar. However, the function does not perform comprehensive ABNF validation on header names or values.'}}]","The code function enforces part of the grammar requirements by ensuring that pseudo headers are only processed at the beginning of the header sequence (as dictated by the protocol's grammar). This is a partial implementation of the spec constraint that prohibits generating protocol elements not matching the ABNF grammar. Other aspects of grammar validation are either handled elsewhere or not implemented within this function, hence the outcome is 'Partially Matches'.",success,
11384,assign_headers,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Partially Matches,[],"The RFC requires that a sender must not include a Content-Length header in any message that also contains a Transfer-Encoding header. In the function, when no Content-Length header is found (cl is NULL), the code adds a 'Transfer-Encoding: chunked' header. This ensures that if Transfer-Encoding is being added, then a Content-Length header (at least from this branch) is not introduced. However, if a Content-Length header is already present in req->headers, the function simply clones it into r->headers_in and does not remove it even if transfer encoding might be applied elsewhere. Therefore, while the function attempts to avoid sending both headers by conditionally adding Transfer-Encoding only when Content-Length is absent, it does not fully enforce the RFC requirement by removing an existing Content-Length header if a Transfer-Encoding header is or will be present. This limited handling leads to the judgment of a partial match.",success,
11384,assign_headers,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'C1': {'code': 'if (req->authority && !is_connect) {\n    const char *orig_host = apr_table_get(req->headers, ""Host"");\n    if (orig_host && strcmp(req->authority, orig_host)) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(10401)\n                      ""overwriting \'Host: %s\' with :authority: %s\'"",\n                      orig_host, req->authority);\n        apr_table_setn(r->subprocess_env, ""H2_ORIGINAL_HOST"", orig_host);\n    }\n    apr_table_setn(r->headers_in, ""Host"", req->authority);\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                  ""set \'Host: %s\' from :authority"", req->authority);\n}\n\n... (further below, similar logic is applied for ensuring proper header handling)', 'explanation': ""The function replaces any existing 'Host' header with the provided :authority value using apr_table_setn. This ensures that multiple 'Host' headers are not generated, meeting the prohibition on duplicate header fields for headers not allowed to be combined.""}}, {'A1': {'code': '#if !AP_HAS_RESPONSE_BUCKETS\n    else if (!cl) {\n        apr_table_mergen(r->headers_in, ""Transfer-Encoding"", ""chunked"");\n    }\n#endif /* else AP_HAS_RESPONSE_BUCKETS */', 'explanation': ""For the 'Transfer-Encoding' header, which is permitted to be combined as a comma-separated list, the function uses apr_table_mergen to append 'chunked'. This shows an attempt to merge multiple values in accordance with the RFC's allowance for certain headers.""}}]","The function includes logic to prevent multiple identical header field lines for 'Host' by unconditionally setting (and thereby overwriting) that header when an :authority value is present. It also merges values for 'Transfer-Encoding', which is allowed to be combined as a comma‐separated list. However, aside from these specific treatments, the function does not explicitly address the preservation of header field order or other potential duplicate header issues that the RFC specifies. As such, the code partially implements the spec constraints related to handling and merging header field lines, but does not fully address all aspects outlined in the RFC.",success,
11384,assign_headers,A server MUST NOT send a Transfer-Encoding header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6 of [HTTP]).,194,Partially Matches,"[{'C1': {'code': 'if (!is_connect) {\n    ...\n    apr_table_mergen(r->headers_in, ""Transfer-Encoding"", ""chunked"");\n}', 'explanation': 'This code block ensures that the function only adds a Transfer-Encoding header when is_connect is false, thereby avoiding the addition of a Transfer-Encoding header in CONNECT requests. However, it does not remove or guard against an existing Transfer-Encoding header that may have been cloned from req->headers if already present in a CONNECT request.'}}]","The RFC requires that a server must not send a Transfer-Encoding header in any 2xx response to a CONNECT request. The function distinguishes CONNECT requests by using the is_connect flag to selectively apply logic for adding chunked transfer encoding. This check prevents the function itself from injecting a Transfer-Encoding header into CONNECT responses. However, because the function clones all request headers at the beginning, any existing Transfer-Encoding header in req->headers remains unmodified for CONNECT requests. This means that while the function partially addresses the RFC requirement by not adding new Transfer-Encoding headers for CONNECT requests, it does not fully enforce the prohibition since it doesn't remove a pre-existing Transfer-Encoding header. As a result, the implementation only partially matches the specified constraint.",success,
11384,assign_headers,"Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",308,Does Not Match,[],"The provided function assigns and manipulates various HTTP headers such as 'Host', 'Content-Length', and 'Transfer-Encoding', but it does not include any logic to check or enforce that parameters called 'q' (case-insensitively) are not defined in transfer codings. No part of the function_body inspects or rejects a 'q' parameter, which is the core of the RFC specification. Therefore, this function does not address the spec constraint regarding prohibition of the parameter 'q'.",success,
11384,assign_headers,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The provided function does not validate the correctness of the Content-Length header. The RFC requires that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect. However, the function only copies or sets Content-Length (e.g., setting it to ""0"" when there is no body) without performing any verification for correctness or handling duplicate comma‐separated values. No logic is present in the function that would detect or discard an incorrect Content-Length header field as required by the spec.",success,
11385,h2_create_request_rec,A server that receives an Expect field value containing a member other than 100-continue MAY respond with a 417 (Expectation Failed) status code to indicate that the unexpected expectation cannot be met.,79,Partially Matches,[],"The HTTP RFC requires that a server receiving an Expect header with a value other than '100-continue' MAY respond with a 417 (Expectation Failed) status code. In the provided function_body the check for the Expect header is implemented only in the legacy branch (the #else block for older module versions), where the code retrieves the Expect header and, if its value is not '100-continue', sets the response status to HTTP_EXPECTATION_FAILED and jumps to error handling. However, in the branch compiled for newer module versions (AP_MODULE_MAGIC_AT_LEAST(20120211, 107)), there is no logic that inspects the Expect header. Since the function does not unconditionally or fully provide the required behavior across all its code paths, it only partially matches the specification constraint.",success,
11385,h2_create_request_rec,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (req->http_status != H2_HTTP_STATUS_UNSET) {\n    access_status = req->http_status;\n    goto die;\n}\n\n... // Later, tests for CONNECT method\nif (is_connect) {\n    r->the_request = apr_psprintf(r->pool, ""%s %s HTTP/2.0"", req->method, req->authority);\n    if (req->scheme) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, ""\':scheme: %s\' header present in CONNECT request"", req->scheme);\n        access_status = HTTP_BAD_REQUEST;\n        goto die;\n    } else if (req->path) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, ""\':path: %s\' header present in CONNECT request"", req->path);\n        access_status = HTTP_BAD_REQUEST;\n        goto die;\n    }\n}\n', 'explanation': 'The function examines incoming pseudo-header fields (e.g. :authority, :scheme, :path) and sets error conditions when they conflict with the requirements (such as for CONNECT requests), which is in line with interpreting the received protocol elements as defined by the specification.'}}, {'A1': {'code': 'r->the_request = apr_psprintf(r->pool, ""%s %s HTTP/2.0"", req->method, req->path);\n\n... \nif (!ap_parse_request_line(r) || !ap_check_request_header(r)) {\n    r->per_dir_config = r->server->lookup_defaults;\n    if (req->http_status != H2_HTTP_STATUS_UNSET) {\n        access_status = req->http_status;\n        c->keepalive = AP_CONN_CLOSE;\n    } else {\n        access_status = r->status;\n    }\n    r->status = HTTP_OK;\n    goto die;\n}\n', 'explanation': 'This segment shows an attempt to construct a proper request line (a usable protocol element) from the input headers and then validate it. In case of problems, it branches to error handling, aligning with the action of processing or recovering a protocol element when encountered with potential errors.'}}]","The function partially implements the RFC requirement by explicitly checking and processing HTTP/2 pseudo header fields, interpreting them per the defined semantics (for instance, validating CONNECT requests and constructing request lines). It includes explicit error handling if discrepancies are found. However, while parts of the received protocol element are verified and errors are managed, not every aspect of the RFC’s detailed error recovery or full semantic interpretation is entirely handled within this function alone. Thus, only some of the labeled constraints are visibly addressed in this code.",success,
11385,h2_create_request_rec,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Fully Matches,"[{'C1': {'code': 'if (is_connect) {\n    /* CONNECT MUST NOT have scheme or path */\n    r->the_request = apr_psprintf(r->pool, ""%s %s HTTP/2.0"",\n                                  req->method, req->authority);\n    if (req->scheme) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(10458)\n                      ""\':scheme: %s\' header present in CONNECT request"",\n                      req->scheme);\n        access_status = HTTP_BAD_REQUEST;\n        goto die;\n    }\n    else if (req->path) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(10459)\n                      ""\':path: %s\' header present in CONNECT request"",\n                      req->path);\n        access_status = HTTP_BAD_REQUEST;\n        goto die;\n    }\n}\nelse if (req->protocol) {\n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(10470)\n                  ""\':protocol: %s\' header present in %s request"",\n                  req->protocol, req->method);\n    access_status = HTTP_BAD_REQUEST;\n    goto die;\n}', 'explanation': ""This code segment ensures that for a CONNECT request, forbidden protocol elements (such as :scheme and :path) are not present, and for non-CONNECT requests, if a :protocol pseudo header is provided (which is not allowed for the sender's role), the request is rejected. This directly implements the requirement that a sender must not generate protocol elements that are only allowed for other roles.""}}]","The function h2_create_request_rec contains explicit checks against generating forbidden pseudo header fields. For CONNECT requests, it ensures that :scheme and :path are absent, and for other requests, it checks for the presence of a :protocol header, rejecting the request if found. These validations directly reflect the constraint from the RFC specification that a sender must not produce protocol elements reserved for other roles, and therefore the function fully meets the intended requirement as implemented within its own logic.",success,
11507,close_input,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The RFC mandates that a recipient MUST NOT merge trailer fields into a header section unless it explicitly understands and verifies that the corresponding header field definition permits safe merging. In the function, when trailer fields are present (i.e. when stream->trailers_in is non‐empty and no reset error exists), the code simply creates a bucket from those trailers and appends it to the input, effectively merging trailers into the header section. There is no logic in the function to verify whether the trailer field definitions explicitly permit this merge or whether they can be safely merged. Therefore, while the function does perform a merge of trailer fields, it does not address the safety and permit verification requirement mandated by the RFC, and as such it does not match the specification.",success,
11515,h2_stream_send_frame,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'new_state = on_frame_send(stream->state, ftype);\nif (new_state < 0) {\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c1,\n                  H2_STRM_MSG(stream, ""invalid frame %d send""), ftype);\n    AP_DEBUG_ASSERT(new_state > S_XXX);\n    return transit(stream, new_state);\n}', 'explanation': ""This segment calls on_frame_send to compute the new state based on the frame type, and if the computed state is negative (invalid) it logs an error and aborts the frame send operation. This mechanism indirectly prevents the generation of protocol elements (frames) that do not belong to the sender's role as defined by the state machine. It partially addresses the RFC requirement that a sender must not generate protocol elements or syntax alternatives that are reserved for other roles.""}}]","The function implements a state transition check via on_frame_send and acts on invalid transitions by not sending frames. This check is an attempt to prevent sending frame types that might be reserved for other roles, which is in line with the RFC's requirement. However, the function does not explicitly verify the sender’s role against the type of frame being sent, relying instead on the state machine encapsulated in on_frame_send. Because of this indirect approach, the implementation only partially matches the specification.",success,
11515,h2_stream_send_frame,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function h2_stream_send_frame primarily manages state transitions and frame sending for different frame types. Although it performs a check for an invalid frame via the on_frame_send call and logs an error when an invalid frame type is encountered, it does not include any explicit logic to validate or enforce that the generated protocol elements conform to the grammar defined by the corresponding ABNF rules. There is no code present that examines or transforms frame values against an ABNF specification. Consequently, the function does not visibly attempt to implement the spec constraint that a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.",success,
11516,h2_stream_recv_frame,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Partially Matches,"[{'C1': {'code': 'case NGHTTP2_HEADERS:\n    eos = (flags & NGHTTP2_FLAG_END_STREAM);\n    if (h2_stream_is_at_or_past(stream, H2_SS_OPEN)) {\n        /* trailer HEADER */\n        if (!eos) {\n            h2_stream_rst(stream, H2_ERR_PROTOCOL_ERROR);\n        }\n        stream->in_trailer_octets += frame_len;\n    }', 'explanation': 'This segment distinguishes between request headers and trailer headers by checking the stream state. In the trailer case, it ensures that if the trailer header frame is received without the end-of-stream flag it triggers a protocol error, thereby attempting to avoid improper merging of trailer fields into the header section, as required by the spec. However, it does not verify if the header definition explicitly permits safe merging.'}}]","The function includes logic to detect and handle trailer header frames by checking the stream state and the EOS flag, which partially addresses the RFC requirement that a recipient must not merge trailer fields into the header section unless allowed. Yet, it does not fully implement the aspect of verifying that the trailer field definition permits such merging. Thus, only part of the spec constraint is addressed within this function.",success,
11525,add_trailer,"A recipient MAY combine multiple field lines within a field section that have the same field name into one field line, without changing the semantics of the message, by appending each subsequent field line value to the initial field line value in order, separated by a comma ("","") and optional whitespace (OWS, defined in Section 5.6.3).",231,Fully Matches,"[{'C1': {'code': 'existing = apr_table_get(stream->trailers_in, hname);\n...\nif (!existing) *pwas_added = 1;\n...\nhvalue = apr_pstrndup(stream->pool, value, vlen);\napr_table_mergen(stream->trailers_in, hname, hvalue);', 'explanation': ""The function checks if a trailer with the given header name already exists and, if so, merges the new trailer value with the existing one using 'apr_table_mergen'. This effectively appends the new field line (likely inserting a comma and space between values, as per Apache’s implementation) in order, thus fulfilling the RFC’s requirement to combine multiple field lines with the same field name.""}}]","The analyzed function implements the RFC specification for combining multiple header lines by checking for an existing header value and then merging a new value into it. Although the actual mechanism of inserting a comma and optional whitespace is encapsulated within the call to 'apr_table_mergen', the code within the function directly addresses the requirement described in the RFC. Therefore, the function visibly implements the labeled constraint.",success,
11526,h2_stream_add_header,"At a minimum, a recipient MUST be able to parse and process protocol element lengths that are at least as long as the values that it generates for those same protocol elements in other messages.",218,Partially Matches,"[{'C1': {'code': ""if (name[0] == ':') {\n    if (vlen > APR_INT32_MAX || (int)vlen > session->s->limit_req_line) {\n        /* pseudo header: approximation of request line size check */\n        ...\n    }\n}"", 'explanation': 'This segment checks the length of pseudo headers against a configured maximum (limit_req_line), which is one way to ensure the recipient can process header elements up to a certain length. It reflects an attempt to set a minimum acceptable processing capability (matching header lengths it may later generate) even though it is implemented as a maximum limit check.'}}, {'A1': {'code': 'status = h2_request_add_header(stream->rtmp, stream->pool,\n                                   name, nlen, value, vlen,\n                                   session->s->limit_req_fieldsize, &was_added);\n\nif (APR_EINVAL == status) {\n    /* header too long */\n    ...\n}', 'explanation': 'This call (and its subsequent error handling) uses the limit_req_fieldsize as a maximum allowed header size when adding headers. It enforces the idea that the system accepts headers up to a certain length that is expected to be no smaller than what it might generate on outbound messages.'}}]","The RFC specification requires that a recipient must be able to process protocol element lengths at least as long as those it produces. In this function, there are visible checks on header sizes for both pseudo headers and regular headers using configured limits (limit_req_line and limit_req_fieldsize). These checks ensure that incoming headers longer than these limits are rejected. While the mechanism is implemented as a strict maximum length check rather than a dynamic adjustment based on outbound header lengths, the logic indicates an attempt to enforce a minimum processing capability. However, because the function does not explicitly compare incoming header lengths with values it produces, it only partially meets the specification.",success,
11526,h2_stream_add_header,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (name[0] == \':\') {\n    if (vlen > APR_INT32_MAX || (int)vlen > session->s->limit_req_line) {\n        /* pseudo header: approximation of request line size check */\n        if (!h2_stream_is_ready(stream)) {\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, session->c1,\n                          H2_STRM_LOG(APLOGNO(10178), stream,\n                                      ""Request pseudo header exceeds ""\n                                      ""LimitRequestFieldSize: %s""), name);\n        }\n        error = HTTP_REQUEST_URI_TOO_LARGE;\n        goto cleanup;\n    }\n}', 'explanation': 'This code segment checks the length of pseudo headers and ensures that the header field does not exceed a certain limit, directly implementing a defensive parsing check for header buffer sizes as recommended by the RFC.'}}, {'A1': {'code': 'status = h2_request_add_header(stream->rtmp, stream->pool,\n                                   name, nlen, value, vlen,\n                                   session->s->limit_req_fieldsize, &was_added);\n...\nif (APR_EINVAL == status) {\n    /* header too long */\n    if (!h2_stream_is_ready(stream)) {\n        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, session->c1,\n                      H2_STRM_LOG(APLOGNO(10180), stream,""Request header exceeds ""\n                                  ""LimitRequestFieldSize: %.*s""),\n                      (int)H2MIN(nlen, 80), name);\n    }\n    error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n    goto cleanup;\n}', 'explanation': 'This segment enforces a maximum header field size by passing a limit to the header‐addition function and then checking the return status. It logs an appropriate error and sets an error code when the header is too long, fulfilling the requirement to parse defensively by considering reasonable header lengths.'}}]","The function h2_stream_add_header implements defensive parsing in direct response to the RFC specification by validating header sizes and counts. It checks pseudo headers against a defined request line limit and passes size limits for regular headers to helper functions, logging errors and aborting processing when limits are exceeded. These checks ensure that the protocol element fits within a reasonable buffer size and demonstrate a defensive approach to parsing, thereby fully meeting the intent of the specified constraints.",success,
11526,h2_stream_add_header,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The HTTP RFC requires that a recipient MUST NOT merge a trailer field into a header section unless it understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged. In the provided code, while there is a branch that handles the trailer (i.e., when stream->state is H2_SS_OPEN and the function calls add_trailer), there is no visible check or logic within this function that verifies whether the trailer field being merged is allowed or safe as per the specification. The decision to merge trailers safely is delegated to add_trailer without an accompanying validation in this function. Therefore, it does not fully implement the spec constraint by itself.",success,
11528,h2_stream_end_headers,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': '    else if (is_http_or_https) {\n        if (!req->path) {\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, stream->session->c1,\n                          H2_STRM_LOG(APLOGNO(10385), stream, ""Request for http(s) resource without :path, sending 400 answer""));\n            set_error_response(stream, HTTP_BAD_REQUEST);\n            goto cleanup;\n        }\n        if (!req->scheme) {\n            req->scheme = ap_ssl_conn_is_ssl(stream->session->c1)? ""https"" : ""http"";\n        }\n    }\n\n    if (req->scheme && (req->path && req->path[0] != \'/\')) {\n        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, stream->session->c1,\n                      H2_STRM_LOG(APLOGNO(10379), stream, ""Request :scheme \'%s\' and path \'%s\' do not allow creating an absolute URL. Failing request with 400.""), req->scheme, req->path);\n        set_error_response(stream, HTTP_BAD_REQUEST);\n        goto cleanup;\n    }', 'explanation': ""This segment checks that for HTTP/HTTPS requests the necessary pseudo-header fields (':path' and ':scheme') meet the protocol requirements, rejecting requests where ':path' is missing or does not start with '/' (to support the creation of an absolute URL), which aligns with the RFC requirement to interpret received protocol elements according to the specification.""}}, {'A1': {'code': '    if (ctx.failed_key) {\n        if (!h2_stream_is_ready(stream)) {\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, stream->session->c1,\n                          H2_STRM_LOG(APLOGNO(10230), stream,""Request header exceeds LimitRequestFieldSize: %.*s""),\n                          (int)H2MIN(strlen(ctx.failed_key), 80), ctx.failed_key);\n        }\n        set_error_response(stream, HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE);\n        goto cleanup;\n    }\n\n    if (!ap_cstr_casecmp(req->method, ""CONNECT"")) {\n        /* ... handling CONNECT specific pseudo-header requirements ... */\n        if (req->protocol) {\n            if (!strcmp(""websocket"", req->protocol)) {\n                if (!req->scheme || !req->path) {\n                    ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, stream->session->c1,\n                                  H2_STRM_LOG(APLOGNO(10457), stream, ""Request to websocket CONNECT without :scheme or :path, sending 400 answer""));\n                    set_error_response(stream, HTTP_BAD_REQUEST);\n                    goto cleanup;\n                }\n            } else {\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, stream->session->c1, APLOGNO(10460)\n                              ""\':protocol: %s\' header present in %s request"",\n                              req->protocol, req->method);\n                set_error_response(stream, HTTP_NOT_IMPLEMENTED);\n                goto cleanup;\n            }\n        } else if (req->scheme || req->path) {\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, stream->session->c1,\n                          H2_STRM_LOG(APLOGNO(10384), stream, ""Request to CONNECT with :scheme or :path specified, sending 400 answer""));\n            set_error_response(stream, HTTP_BAD_REQUEST);\n            goto cleanup;\n        }\n    }', 'explanation': 'This segment implements error handling actions by validating header field sizes and the correct composition of pseudo-header fields for CONNECT requests. When inconsistencies are detected, it recovers by setting an error response (such as HTTP_BAD_REQUEST or HTTP_NOT_IMPLEMENTED), thus fulfilling the action requirement of recovering a usable protocol element or appropriately rejecting malformed ones.'}}]","The function attempts to interpret the received HTTP/2 header fields according to the RFC‐7540 semantics by validating mandatory pseudo-header fields (e.g., ':method', ':scheme', ':path') and applying specific rules for CONNECT requests. It implements error recovery actions by logging issues and setting error responses when the header fields do not comply. However, while these validations and error recoveries address significant parts of the RFC’s requirements, not all possible conditions are entirely handled within this function, and some dependencies are offloaded to other functions. Therefore, the implementation in this function partially meets the spec constraints.",success,
11528,h2_stream_end_headers,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'ctx.maxlen = stream->session->s->limit_req_fieldsize;\nctx.failed_key = NULL;\napr_table_do(table_check_val_len, &ctx, req->headers, NULL);', 'explanation': 'This segment sets a maximum header size and then iterates over the header table to verify that each header field conforms to this limit. This defensive check corresponds to the requirement to validate that protocol elements fit within a reasonable buffer size.'}}, {'A1': {'code': 'if (ctx.failed_key) {\n    if (!h2_stream_is_ready(stream)) {\n        ap_log_cerror(...);\n    }\n    set_error_response(stream, HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE);\n    goto cleanup;\n}', 'explanation': 'If any header field exceeds the allowed length, an error response is set. This action demonstrates a defensive parsing behavior by not assuming all input conforms to expectations.'}}]","The function implements defensive parsing for HTTP header elements by enforcing a maximum length and checking for required pseudo-header fields. While it addresses header field size concerns (relating to the 'reasonable buffer size' aspect of the RFC) and includes error responses for malformed requests, it does not cover all aspects of the ABNF grammar or other potential protocol variations. Thus, only a subset of the RFC's defensive parsing principles is handled within this function, resulting in a 'Partially Matches' judgment.",success,
11528,h2_stream_end_headers,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (is_http_or_https) {\n    if (!req->path) {\n        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, stream->session->c1,\n                      H2_STRM_LOG(APLOGNO(10385), stream, ""Request for http(s) resource without :path, sending 400 answer""));\n        set_error_response(stream, HTTP_BAD_REQUEST);\n        goto cleanup;\n    }\n    if (!req->scheme) {\n        req->scheme = ap_ssl_conn_is_ssl(stream->session->c1)? ""https"" : ""http"";\n    }\n}\n\n...\n\nif (req->scheme && (req->path && req->path[0] != \'/\')) {\n    ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, stream->session->c1,\n                  H2_STRM_LOG(APLOGNO(10379), stream, ""Request :scheme \'%s\' and path \'%s\' do not allow creating an absolute URL. Failing request with 400.""), req->scheme, req->path);\n    set_error_response(stream, HTTP_BAD_REQUEST);\n    goto cleanup;\n}', 'explanation': ""This segment checks that for HTTP/HTTPS requests the mandatory pseudo-header fields (:scheme and :path) obey the expected format (e.g. non-empty :path and a path that starts with '/'), which is part of enforcing that protocol elements match the expected grammar. However, it only covers a subset of the overall ABNF grammar constraints.""}}, {'A1': {'code': 'if (!ap_cstr_casecmp(req->method, ""CONNECT"")) {\n    ...\n    else if (req->scheme || req->path) {\n        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, stream->session->c1,\n                      H2_STRM_LOG(APLOGNO(10384), stream, ""Request to CONNECT with :scheme or :path specified, sending 400 answer""));\n        set_error_response(stream, HTTP_BAD_REQUEST);\n        goto cleanup;\n    }\n}', 'explanation': 'This code implements the action to reject or modify messages that violate the grammar rules for CONNECT requests. It ensures that CONNECT requests do not mistakenly include pseudo-header fields (like :scheme or :path) that are disallowed by the RFC.'}}]","The function attempts to enforce specific portions of the HTTP messaging grammar – for example, validating that HTTP/HTTPS requests include a non-empty, properly formatted :path, and ensuring CONNECT requests do not include disallowed pseudo-header fields. These checks mirror parts of the ABNF-based requirements of the RFC. However, the function does not perform a comprehensive check against the full ABNF grammar of the protocol; rather, it verifies only a subset of the required conditions. Thus, while there is visible logic addressing some of the spec constraints (labeled here as C1 and A1), it does not wholly implement all aspects of the RFC requirement that a sender must only generate protocol elements matching the defined grammar. This leads to the 'Partially Matches' judgment.",success,
11531,buffer_output_receive,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'A1': {'code': 'if (buf_len > APR_INT32_MAX\n            || (apr_size_t)buf_len >= stream->session->max_stream_mem) {\n        /* we have buffered enough. No need to read more. */\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, rv, c1,\n                      H2_STRM_MSG(stream, ""out_buffer, already has %ld length""),\n                      (long)buf_len);\n        rv = APR_SUCCESS;\n        goto cleanup;\n    }', 'explanation': ""This segment enforces a limit on the buffered data size, ensuring that the application does not assume unbounded length. It defends against oversized protocol elements, which aligns with the RFC's recommendation to use only marginal expectations on element size.""}}, {'A2': {'code': 'if (stream->rst_error) {\n        rv = APR_ECONNRESET;\n        goto cleanup;\n    }', 'explanation': 'This code checks for a stream error condition and handles it safely by aborting further processing. This defensive check is in line with a robust approach to parsing received protocol elements.'}}]","The function implements several defensive measures—for instance, checking error conditions and limiting the amount of data buffered—to prevent issues related to unexpectedly large or malformed input. These measures address key aspects of defensive parsing as recommended by the RFC. However, the function does not perform explicit parsing or validation of the data against an ABNF grammar. As such, while it incorporates defensive handling of memory usage and errors, it only partially implements the overall defensive parsing requirement described in the RFC.",success,
11534,stream_do_trailers,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function processes and submits trailer header elements but does not include any explicit logic that checks or enforces the constraint from the RFC specification – that is, it does not prevent the generation of protocol elements or syntax alternatives that are reserved for other roles. The code simply extracts trailer headers from the outgoing buffer, converts them, and submits them via nghttp2 without verifying that the sender is authorized to generate such protocol elements. Therefore, none of the labeled spec constraints (e.g., C1 or A1) are visibly implemented within this function.",success,
11534,stream_do_trailers,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Fully Matches,"[{'C1': {'code': 'if (AP_BUCKET_IS_HEADERS(b)) {\n    headers = b->data;\n    APR_BUCKET_REMOVE(b);\n    apr_bucket_destroy(b);\n    ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, c1,\n                  H2_STRM_MSG(stream, ""process trailers""));\n    break;\n}', 'explanation': 'This code explicitly checks for a headers bucket—in this case representing trailer headers—and extracts them without merging them back into the main header section. It thereby avoids merging trailer fields unless they are explicitly handled, which aligns with the RFC requirement.'}}, {'A1': {'code': 'rv = h2_res_create_ngtrailer(&nh, stream->pool, headers);\nif (APR_SUCCESS != rv) {\n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c1,\n                  H2_STRM_LOG(APLOGNO(10024), stream, ""invalid trailers""));\n    h2_stream_rst(stream, NGHTTP2_PROTOCOL_ERROR);\n    goto cleanup;\n}\n...\nngrv = nghttp2_submit_trailer(stream->session->ngh2, stream->id, nh->nv, nh->nvlen);', 'explanation': 'After isolating the trailer header bucket, the function validates the trailer fields (via h2_res_create_ngtrailer) and submits them using the appropriate HTTP/2 API. This sequence ensures that only properly understood and permitted trailer fields are processed, satisfying the safe handling requirement stated in the RFC.'}}]","The function identifies trailer header buckets separately from the main headers, validates their content before submission, and uses the HTTP/2 API to deliver trailers without merging them into the header section. This behavior directly addresses the RFC specification that a recipient must not merge trailer fields into a header section unless it explicitly understands and permits such an operation. All the necessary logic is implemented within the function, independent of its dependencies.",success,
11536,h2_stream_get_trailers,"Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",308,Does Not Match,[],"The function h2_stream_get_trailers only performs a magic assertion on the stream and then returns NULL. There is no logic in the function that addresses the RFC specification regarding avoiding the definition of a transfer coding parameter named ""q"" (case-insensitively), nor does it handle any comparison between transfer and content codings as mentioned in the specification. Since the function does not contain any logic that corresponds to any of the labeled conditions or actions from the spec constraints, it does not match the specification.",success,
11536,h2_stream_get_trailers,A sender MUST NOT generate a trailer field unless the sender knows the corresponding header field name's definition permits the field to be sent in trailers.,10,Does Not Match,[],"The provided function only asserts a stream magic using H2_STRM_ASSERT_MAGIC and then returns NULL. There is no code that checks or implements any condition related to ensuring that a trailer field is only generated if its header field name's definition permits trailers (e.g., inspecting headers, framing mechanisms, or HTTP version support). Therefore, the function does not visibly address the RFC specification or its constraints.",success,
11536,h2_stream_get_trailers,"Because of the potential for trailer fields to be discarded in transit, a server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive.",12,Fully Matches,"[{'C1': {'code': 'return NULL;', 'explanation': ""The function always returns NULL, meaning no trailer fields are generated. This directly implements the RFC's recommendation that a server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive.""}}]","The function h2_stream_get_trailers does not attempt to generate or retrieve any trailer fields; it simply returns NULL. In doing so, it fully addresses the RFC specification which advises against generating trailer fields deemed necessary for user agent processing. The logic is contained entirely within the function, and no trailers are created or returned.",success,
11536,h2_stream_get_trailers,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The provided function only asserts a magic value on the stream and returns NULL. There is no logic that checks for or processes trailer fields, nor is there any evidence of handling the merging of trailer fields into header sections as required by the specification. Since no part of the function implements the necessary checks or merging actions (e.g., verifying that the recipient understands the header definition or that the definition permits safe merging), the function does not match any of the labeled conditions or actions stated in the RFC constraints.",success,
11542,h2_stream_in_consumed,"Since there is no predefined limit to the length of content, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer conversion (Section 17.5).",261,Fully Matches,"[{'C1': {'code': 'while (consumed > 0) {\n    int len = (consumed > INT_MAX)? INT_MAX : (int)consumed;\n    nghttp2_session_consume(session->ngh2, stream->id, len);\n    consumed -= len;\n}', 'explanation': ""This loop explicitly divides the potentially very large 'amount' (of type apr_off_t) into chunks not exceeding INT_MAX before converting to an int, thereby preventing integer conversion overflows or precision loss. This directly addresses the RFC requirement to handle arbitrarily large decimal numerals safely.""}}]","The provided code function includes a loop that checks if the 'amount' exceeds INT_MAX and, if so, breaks it into smaller chunks that fit into an int. This mechanism ensures that very large values are handled without causing integer conversion errors, which fully meets the specification's requirement to prevent parsing errors due to integer conversion overflows or precision loss.",success,
11545,stream_do_response,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'else {\n            /* data buckets before response headers, an error */\n            h2_stream_rst(stream, H2_ERR_INTERNAL_ERROR);\n            rv = APR_EINVAL;\n            goto cleanup;\n        }', 'explanation': 'This code segment checks for the presence of non‐metadata (data) buckets before a valid response header bucket is encountered and resets the stream when such an error is found. This helps ensure that the sender does not generate or process protocol elements (in this case, data buckets) out of the allowed order (i.e., before headers), which partially enforces the RFC requirement that a sender must not generate elements that are reserved for other roles.'}}]","The function 'stream_do_response' processes the brigade of buckets and explicitly checks that response headers appear in the correct order. In particular, it detects if data buckets (which are not valid protocol elements for the sender’s role in this context) appear before the expected header bucket and then resets the stream. This logic partially implements the RFC specification that a sender must not generate protocol elements reserved for other participant roles. However, the function does not exhaustively check all aspects of the spec (for example, it does not inspect or filter all protocol elements that might be produced by other roles), so it only partially matches the overall requirement.",success,
11552,h2_c1_run,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'do {\n    ...\n    status = h2_session_process(conn_ctx->session, async_mpm, &keepalive);\n    if (status != APR_SUCCESS) {\n        ...\n        c->keepalive = AP_CONN_CLOSE;\n    }\n    else {\n        c->keepalive = AP_CONN_KEEPALIVE;\n    }\n    ...\n} while (!async_mpm && c->keepalive == AP_CONN_KEEPALIVE && mpm_state != AP_MPMQ_STOPPING);', 'explanation': 'This loop repeatedly processes the session as long as keepalive is signaled (i.e. AP_CONN_KEEPALIVE), thereby attempting to sustain the persistent connection behavior required by the spec.'}}, {'A1': {'code': 'if (c->cs) {\n    switch (conn_ctx->session->state) {\n        case H2_SESSION_ST_INIT:\n        case H2_SESSION_ST_IDLE:\n        case H2_SESSION_ST_BUSY:\n        case H2_SESSION_ST_WAIT:\n            if (keepalive) {\n                /* Flush then keep-alive */\n                c->cs->sense = CONN_SENSE_DEFAULT;\n                c->cs->state = CONN_STATE_WRITE_COMPLETION;\n            }\n            else {\n                /* Use read-wait mechanism instead of immediate termination */\n                c->cs->sense = CONN_SENSE_WANT_READ;\n#ifdef AP_MPMQ_CAN_WAITIO\n                if (mpm_can_waitio) {\n                    c->cs->state = CONN_STATE_ASYNC_WAITIO;\n                }\n                else\n#endif\n                {\n                    c->cs->state = CONN_STATE_WRITE_COMPLETION;\n                    c->clogging_input_filters = 1;\n                }\n            }\n            break;\n        ...\n    }\n}', 'explanation': 'This switch-case block distinguishes between connection states; when keepalive isn’t available it opts to wait for incoming data (using CONN_SENSE_WANT_READ and potentially asynchronous IO) rather than closing the connection immediately. This shows an intent to use underlying transport mechanisms (like waiting for readability/timeout) to resolve transient issues.'}}]","The function implements persistent connection handling by looping as long as the connection is marked for keepalive (addressing C1) and by switching to states where it waits for client data when the connection would otherwise be closed (addressing A1). However, while it adjusts connection state to indirectly allow underlying flow-control (e.g., via asynchronous wait for readability), it does not explicitly test or manage flow‐control signals or overload conditions. Thus, the function only partially implements the RFC specification within its own scope.",success,
11552,h2_c1_run,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'C1': {'code': 'if (status != APR_SUCCESS) {\n    ...\n    c->keepalive = AP_CONN_CLOSE;\n}\nelse {\n    c->keepalive = AP_CONN_KEEPALIVE;\n}', 'explanation': 'This segment explicitly sets the connection state to persistent (AP_CONN_KEEPALIVE) when the session process is successful, fulfilling the condition that HTTP implementations should support persistent (i.e., keep‐alive) connections.'}}, {'A1': {'code': 'do {\n    ...\n} while (!async_mpm && c->keepalive == AP_CONN_KEEPALIVE && mpm_state != AP_MPMQ_STOPPING);', 'explanation': 'This looping construct ensures that the connection remains open (persistent) if the keepalive flag is set, directly implementing the action of supporting subsequent requests on the same connection per HTTP/1.1 persistent connection semantics.'}}]","The function 'h2_c1_run' clearly implements logic for persistent connections by checking the status of session processing and setting 'c->keepalive' to either AP_CONN_KEEPALIVE or AP_CONN_CLOSE accordingly. Additionally, the use of a do-while loop that continues processing while the connection remains in a keepalive state demonstrates that the function supports keeping the connection open for multiple requests, in accordance with the HTTP/1.1 specification on persistent connections.",success,
11556,h2_c1_hook_process_connection,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function_body deals with connection handling, protocol detection, and the setup of HTTP/2 direct mode, but it does not contain any logic that enforces the RFC requirement that a sender MUST NOT generate protocol elements or syntax alternatives reserved for another role. There is no visible check or constraint within this function that restricts the generation of protocol elements based on the sender's role as specified in the RFC.",success,
11587,h2_push_collect,"It MUST conform to the field-name syntax defined in Section 5.1, and it SHOULD be restricted to just letters, digits, and hyphen ('-') characters, with the first character being a letter.",293,Does Not Match,[],"The provided function (h2_push_collect) focuses on collecting push candidates from response headers and setting a push-policy header, primarily handling aspects related to HTTP/2 push. It does not validate or enforce the specification requirements regarding field names (i.e., ensuring they conform to the field-name syntax with only letters, digits, and hyphen characters and a leading letter) or handle registration request statuses ('permanent', 'provisional', 'deprecated', or 'obsoleted'). As such, none of the spec constraints (e.g., C1 regarding field-name syntax or A1 regarding registration status) are addressed within this function.",success,
11621,on_begin_headers_cb,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Does Not Match,[],"The provided function does not visibly implement any logic that corresponds to the RFC requirement of interpreting a received protocol element according to the defined semantics. The RFC condition (labeled as C1 in the constraints) requires that the recipient analyze and interpret protocol elements (potentially including error recovery and semantic validation), but the function only retrieves an existing stream or opens a new one if allowed. There is no logic within the function that performs any semantic interpretation, validation of header content, or error recovery mechanism as described in the RFC specification. All decision making is centered on the existence of a stream and a basic check of the accepting flag, without addressing or recovering from potentially invalid constructs. Thus, none of the labeled conditions or actions (like C1, A1, etc.) are implemented by this function alone.",success,
11623,on_frame_recv_cb,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Does Not Match,[],"The provided function processes incoming HTTP/2 frames and updates various session metrics (such as frame counts and idle delays) but does not implement any logic that directly corresponds to the RFC requirement to sustain persistent connections by leveraging flow-control mechanisms instead of terminating connections. Although the idle frame logic adjusts an idle_delay value when the session remains idle, it does not explicitly implement the persistent connection sustaining behavior or the flow-control resolution described in the spec constraints. The key actions—such as continuously keeping the connection alive under temporary overload conditions and avoiding premature termination—are not visibly addressed within the function_body itself.",success,
11625,on_frame_send_cb,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function focuses on sending frames, logging, and invoking related stream functions without any visible logic that checks whether the generated protocol elements conform to a given role. In other words, it does not enforce the restriction that a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed for other roles as required by the RFC. No parts of this function implement role-based verification or generate elements conditionally based on the sender’s role, so the specified RFC constraint is not addressed in the function body.",success,
11625,on_frame_send_cb,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function does not include any logic that validates or ensures that the protocol elements conform to the grammar defined by the corresponding ABNF rules as required by the RFC spec. The function primarily logs frame sending details and dispatches frames via h2_stream_send_frame without implementing any checks on the generated protocol element syntax. Thus, none of the spec constraints (e.g., C1) are visibly addressed within this function.",success,
11634,h2_session_start,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 's = apr_table_get(session->r->headers_in, ""HTTP2-Settings"");\nif (!s) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, APR_EINVAL, session->r,\n                  APLOGNO(02931) ""HTTP2-Settings header missing in request"");\n    return APR_EINVAL;\n}', 'explanation': 'This segment checks for the presence of the HTTP2-Settings header when in h2c mode. Under the HTTP upgrade rules the client is required to provide this header. By verifying its existence, the function indirectly ensures that the server does not generate or substitute this header—i.e. that it avoids creating protocol elements which only the client should provide. This addresses part of the requirement that a sender must not generate elements that belong to another role.'}}, {'A1': {'code': '*rv = nghttp2_submit_settings(session->ngh2, NGHTTP2_FLAG_NONE,\n                              settings, slen);', 'explanation': 'This call sends a SETTINGS frame that is appropriate for the sender’s role. Unlike the HTTP2-Settings header (which is client-only), sending a SETTINGS is allowed. This complies with the RFC in that the sender is not introducing protocol elements reserved for other roles.'}}]","The function initiates an HTTP/2 session by checking for the HTTP2-Settings header in upgrade (h2c) requests and then conditionally submits protocol elements (SETTINGS and WINDOW_UPDATE frames) that are allowed for the sender’s role. This demonstrates an intent to adhere to the RFC requirement that a sender must avoid generating protocol elements that are reserved for other roles. However, the function does not explicitly enforce restrictions against generating any disallowed elements beyond this check; rather, it follows the standard upgrade and session-start procedure. Thus, only some aspects of the RFC constraint are visibly handled directly within this function.",success,
11634,h2_session_start,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': '/* Construct and send SETTINGS frame */\nsettings[slen].settings_id = NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS;\nsettings[slen].value = (uint32_t)session->max_stream_count;\n++slen;\nwin_size = h2_config_sgeti(session->s, H2_CONF_WIN_SIZE);\nif (win_size != H2_INITIAL_WINDOW_SIZE) {\n    settings[slen].settings_id = NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE;\n    settings[slen].value = win_size;\n    ++slen;\n}\n\n*rv = nghttp2_submit_settings(session->ngh2, NGHTTP2_FLAG_NONE, settings, slen);\n\n/* Submit connection window update with a calculated valid size */\n*rv = nghttp2_submit_window_update(session->ngh2, NGHTTP2_FLAG_NONE, 0, NGHTTP2_MAX_WINDOW_SIZE - win_size);', 'explanation': 'The RFC specifies that a sender must not generate protocol elements that do not conform to the ABNF grammar. This function builds its protocol elements (a SETTINGS frame and a WINDOW_UPDATE frame) using controlled, well‐defined values and delegates the low‐level frame encoding to the nghttp2 library functions. By doing so, it ensures that only valid, grammar-conforming frames are generated.'}}, {'C1': {'code': 'cs = NULL;\ndlen = h2_util_base64url_decode(&cs, s, session->pool);\n\n*rv = nghttp2_session_upgrade(session->ngh2, (uint8_t*)cs, dlen, NULL);', 'explanation': 'Before generating protocol elements, the function checks for the presence of the HTTP2-Settings header and decodes it. The subsequent use of nghttp2_session_upgrade ensures that the input for protocol negotiation follows expected encoding rules, thereby not permitting the generation of nonconforming protocol elements.'}}]","The function h2_session_start visibly implements the RFC requirement that a sender must not generate protocol elements deviating from the defined ABNF grammar. It does so by constructing its SETTINGS and WINDOW_UPDATE frames with predetermined, validated values and using nghttp2 library functions (for both upgrade and frame submission) to guarantee that the low-level details adhere to the protocol's grammar. All these operations are contained within the function itself, and no reliance on external logic is assumed for this particular conformance.",success,
11635,h2_session_push,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'status = h2_req_create_ngheader(&ngh, is->pool, push->req);\nif (status != APR_SUCCESS || nid <= 0) {\n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, status, session->c1,\n                  H2_STRM_LOG(APLOGNO(03075), is, ""submitting push promise fail: %s""), nghttp2_strerror(nid));\n    return NULL;\n}', 'explanation': 'This code checks that the header conversion succeeds (which implies that the headers conform to the expected ABNF grammar) before a push promise is submitted. If the header creation fails (or if the push promise submission returns an invalid id), the function aborts further processing, thereby ensuring that no protocol elements that do not match the grammar are generated.'}}, {'A1': {'code': 'nid = nghttp2_submit_push_promise(session->ngh2, 0, is->id, \n                                      ngh->nv, ngh->nvlen, NULL);', 'explanation': 'This action submits the push promise only after successful header creation, ensuring that the protocol elements being generated are based on headers that have already passed validation. This behavior supports the requirement that only valid protocol elements be generated.'}}]","The function h2_session_push generates a push promise only after successfully converting request headers into a valid format. It explicitly checks the outcome of the header creation via h2_req_create_ngheader and validates the result of the push promise submission. If either validation fails, the function logs the error and returns NULL, thereby preventing the generation of invalid protocol elements. This visible logic within the function fulfills the spec requirement that a sender must not generate protocol elements that do not match the defined ABNF grammar.",success,
11635,h2_session_push,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function h2_session_push is responsible for generating a server push promise using the nghttp2_submit_push_promise API and then opening a new stream. While it implements the mechanics of sending a push promise, it does not contain any explicit logic to verify or enforce that protocol elements are only generated by the appropriate sender role as required by the RFC. In other words, it does not check or restrict whether a sender is allowed to generate certain protocol elements (i.e. those that are only permitted for a specific role). This means that, by itself, the function does not visibly address the condition stated in the RFC specification regarding a sender not generating elements allowed only for other roles.",success,
11640,h2_session_send,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC requirement specifies that within a given message, a sender must not generate protocol elements or syntax alternatives that are only permitted for other roles. In the provided function, h2_session_send(), the logic primarily handles sending data via the underlying nghttp2_session_send call and managing I/O flushing and error events. There is no explicit code that checks or restricts the generation of protocol elements based on the sender's role. Error handling (dispatching protocol error events) is present, but it does not enforce that only permitted elements are generated; it only reacts when a fatal error is detected. Therefore, the function does not visibly address the specified requirement within its own code.",success,
11652,h2_session_ev_conn_timeout,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (!session->local.shutdown) {\n        h2_session_shutdown(session, arg, msg, 1);\n    }', 'explanation': 'This segment checks whether a shutdown has not yet been initiated and then calls the shutdown function, which aligns with the condition that a client, server, or proxy MAY close the transport connection at any time.'}}, {'A1': {'code': 'transit(session, msg, H2_SESSION_ST_DONE);', 'explanation': 'This call transitions the session state toward closure as part of a graceful close on connection timeout, reflecting the spec’s recommendation to gracefully close the connection.'}}]","The function h2_session_ev_conn_timeout handles a connection timeout event by transitioning the session state and initiating a shutdown if needed. This behavior attempts to meet the spec’s guidance regarding connection closure. However, while it demonstrates elements of a graceful shutdown upon timeout (i.e., changing state and checking the shutdown flag), it only partially addresses the broader system recommendations about monitoring open connections and ensuring full resource reclamation. Therefore, the function partially matches the specified RFC behavior in its isolated logic.",success,
11652,h2_session_ev_conn_timeout,A client or server that wishes to time out SHOULD issue a graceful close on the connection.,314,Partially Matches,"[{'A1': {'code': 'if (!session->local.shutdown) {\n    h2_session_shutdown(session, arg, msg, 1);\n}', 'explanation': ""This code checks if the session has not already initiated a shutdown and then calls h2_session_shutdown to gracefully close the connection, which corresponds to the RFC's requirement for issuing a graceful close on timeout.""}}]","The function is triggered on a connection timeout event and immediately transitions the session state and then checks if shutdown has already begun. If not, it issues a graceful close by invoking h2_session_shutdown. This directly addresses the action specified in the RFC (i.e., graceful close on timeout), although it does not cover other monitoring aspects mentioned in the broader specification. Thus, only a subset of the RFC constraints is visibly implemented in this function.",success,
11656,h2_session_ev_no_more_streams,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'A1': {'code': 'if (session->local.accepting) {\n    /* We wait for new frames on c1 only. */\n    transit(session, ""all streams done"", H2_SESSION_ST_IDLE);\n}', 'explanation': ""This branch checks if the session is still accepting new streams. When true, it transitions the session to an idle state, thereby keeping the connection persistent as long as possible. This reflects the RFC's requirement to sustain persistent connections when possible.""}}]","The function partially addresses the HTTP RFC by attempting to maintain a persistent connection via the idle state when no more streams are active yet the session still accepts new ones. However, it does not explicitly incorporate any mechanisms to leverage underlying transport flow-control to mitigate temporary overloads, nor does it cover other aspects of the RFC such as handling in-flight message body transmission errors. As a result, only part of the specification (maintaining persistence under certain conditions) is implemented within this function.",success,
11660,on_stream_state_enter,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Does Not Match,[],"The provided function is responsible for handling stream state transitions (logging, calling ev_stream_* functions, and submitting resets for some stream states) and does not contain any logic that clearly implements the RFC specification of sustaining persistent connections or leveraging the underlying transport flow-control to resolve overloads. There is no code segment within this function that addresses monitoring for error responses during a message body transfer or stopping transmission if a connection is closing. Therefore, none of the spec's labeled conditions or actions are visibly met by the function itself.",success,
11666,h2_session_process,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': ' *pkeepalive = (session->open_streams == 0 && session->remote.emitted_count);\n    ...\n    h2_mplx_c1_going_keepalive(session);', 'explanation': 'This code sets the keepalive flag once the session has no active streams and at least one stream has been processed, which corresponds to sustaining persistent connections as suggested by the RFC.'}}, {'A1': {'code': 'if (async && h2_send_flow_blocked(session)) {\n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, status, c, ""... BLOCKED ..."");\n    goto leaving;\n}\n...\nstatus = h2_mplx_c1_poll(session->mplx, session->s->timeout, on_stream_input, on_stream_output, session);\nif (APR_STATUS_IS_TIMEUP(status)) { ... }', 'explanation': 'This segment checks if the send side is blocked due to flow control and employs a polling mechanism to wait for further client updates, thereby allowing the underlying transport flow-control mechanisms to resolve temporary overloads rather than immediately terminating the connection.'}}]","The function shows visible efforts to implement key aspects of the spec. It uses timeout polling and checks for flow-control block conditions to delay termination, and it sets conditions for keeping a connection alive if no streams are active. However, some of the broader session management responsibilities (such as comprehensive error signaling and complete timeout handling) are delegated to other functions, meaning the function only partially implements the complete spec requirement on its own.",success,
11764,strip_field_value_ws,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': ""while(nv->valuelen && (nv->value[0] == ' ' || nv->value[0] == '\\t')) { nv->value++; nv->valuelen--; }"", 'explanation': 'This code snippet removes any leading whitespace (spaces or tabs) as required by the BWS specification.'}}, {'A1': {'code': ""while(nv->valuelen && (nv->value[nv->valuelen-1] == ' ' || nv->value[nv->valuelen-1] == '\\t')) { nv->valuelen--; }"", 'explanation': 'This snippet removes trailing whitespace, fulfilling the RFC requirement that BWS can be removed before processing.'}}]","The function 'strip_field_value_ws' directly implements the removal of both leading and trailing whitespace from a field value. This aligns with the RFC specification that content defined as BWS may be removed before further interpretation. Both the removal of leading spaces/tabs (C1) and the removal of trailing spaces/tabs (A1) are handled explicitly in the function, indicating that it fully matches the required constraints.",success,
11764,strip_field_value_ws,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': ""while(nv->valuelen && (nv->value[0] == ' ' || nv->value[0] == '\\t')) {\n    nv->value++; nv->valuelen--;\n}"", 'explanation': 'This loop removes all leading whitespace (spaces and tabs), directly addressing the need to parse and remove bad whitespace before interpretation.'}}, {'A1': {'code': ""while(nv->valuelen && (nv->value[nv->valuelen-1] == ' ' || nv->value[nv->valuelen-1] == '\\t')) {\n    nv->valuelen--;\n}"", 'explanation': 'This loop removes all trailing whitespace (spaces and tabs), further ensuring that any extraneous whitespace is eliminated as required by the specification.'}}]","The function 'strip_field_value_ws' implements the requirement from the RFC specification by explicitly removing any leading and trailing whitespace (specifically space and tab characters) from the field's value. The two loops in the function directly correspond to the actions needed to remove bad whitespace, thus the function fully meets the relevant constraint as specified.",success,
11764,strip_field_value_ws,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'A1': {'code': ""while(nv->valuelen && (nv->value[0] == ' ' || nv->value[0] == '\\t')) { nv->value++; nv->valuelen--; }\nwhile(nv->valuelen && (nv->value[nv->valuelen-1] == ' ' || nv->value[nv->valuelen-1] == '\\t')) { nv->valuelen--; }"", 'explanation': 'This code removes any leading and trailing spaces and horizontal tabs from the field value. It directly implements the requirement that any whitespace allowed in the raw HTTP message must be excluded before the field value is evaluated.'}}]","The function strip_field_value_ws contains two while loops that trim whitespace from both the beginning and end of the field value. This behavior meets the RFC specification which requires that leading and trailing whitespace not be part of the evaluated field value. Since all whitespace exclusion logic is implemented within this function, it fully matches the specified constraint.",success,
11765,add_header,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'A1': {'code': 'strip_field_value_ws(nv);', 'explanation': 'The function calls strip_field_value_ws(nv) after assigning the header values. This call demonstrates that the function is removing bad whitespace from the header field value before further processing, which directly addresses the RFC requirement that a recipient MUST remove such whitespace before interpreting the protocol element.'}}]","The RFC requires that any bad whitespace present be removed before interpreting a protocol element. In the provided function, after setting the header name and value, the call to strip_field_value_ws(nv) indicates that the function actively strips out unwanted whitespace. This fulfills the specification's requirement within the scope of this function, thus leading to the outcome 'Fully Matches'. Dependencies or caller logic are not counted, and the relevant implementation is clearly within function_body.",success,
11765,add_header,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': 'if (!ctx->unsafe) {\n    if ((p = inv_field_name_chr(key))) {\n        ...\n        return 0;\n    }\n    if ((p = inv_field_value_chr(value))) {\n        ...\n        return 0;\n    }\n}', 'explanation': ""The function checks the header field name and value for invalid characters, which is in line with ensuring that inputs do not contain improper whitespace or other forbidden characters as per the RFC requirement. This check helps ensure that unexpected or 'bad' whitespace (or any other invalid characters) are detected and handled.""}}, {'A1': {'code': 'strip_field_value_ws(nv);', 'explanation': 'After setting the header header values, the function explicitly calls strip_field_value_ws to remove extraneous whitespace from the header field value. This implements the RFC action stating that any content defined as bad whitespace (BWS) may be removed before interpretation.'}}]","The provided function implements the RFC requirement by first validating the header field name and value against invalid characters, thereby guarding against the inclusion of unwanted whitespace or other illegal characters (condition C1). Then it explicitly removes any bad whitespace from the header field value via a call to strip_field_value_ws (action A1). Both these steps are done within the function itself, and they collectively and visibly address the relevant aspects of the RFC concerning BWS handling.",success,
11765,add_header,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'A1': {'code': 'strip_field_value_ws(nv);', 'explanation': 'The function calls strip_field_value_ws(nv) after setting up the header value, which is intended to remove any leading or trailing whitespace. This directly addresses the RFC requirement to exclude such whitespace prior to evaluating the field value.'}}]","The function explicitly invokes strip_field_value_ws(nv) to remove whitespace from the header's field value before further processing, thereby satisfying the specific RFC mandate that any allowed whitespace should be excluded before field evaluation. This logic is contained within the function_body, so it fully meets the labeled constraint.",success,
11770,h2_res_create_ngheader,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function h2_res_create_ngheader only creates a header element using fixed keys and values, and passes them along to ngheader_create without any explicit checks or logic that enforce or verify the sender's role restrictions as specified in the RFC. There is no visible implementation within this function that prevents generating protocol elements or syntax alternatives that are only allowed by other roles (i.e., no logic addressing the spec's condition, such as a check to ensure that only allowed header fields are generated by the sender). The use of is_unsafe(headers) does not directly address the RFC constraint regarding role-specific protocol element generation. Therefore, no labeled condition (C1, etc.) or action (A1, etc.) from the spec constraints is being visibly implemented in this function.",success,
11771,h2_req_create_ngheader,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function simply assembles a header block by extracting fields (scheme, authority, path, method) from the request and then passing them to ngheader_create(), along with additional headers. There is no logic in the function to check or enforce any role-based restrictions as required by the RFC (i.e., ensuring that a sender does not generate protocol elements or syntax alternatives that are only allowed by participants in other roles). The function does not explicitly validate whether the generated protocol elements match the sender's allowed set per the ABNF grammar or role constraints, and thus, in isolation, does not address the labeled conditions or actions specified.",success,
11775,h2_ignore_req_trailer,Other recipients SHOULD ignore unrecognized header and trailer fields.,0,Partially Matches,[],"The provided function appears to be part of the mechanism for determining whether a trailer header should be ignored, which is a requirement stated in the HTTP specification (i.e., that unrecognized headers/trailers be ignored). In the function, the header name is wrapped into an nv object and then passed to helper functions (h2_req_ignore_header and contains_name with a list of IgnoredRequestTrailers) to decide whether this header should be ignored. However, the actual logic of what constitutes an 'unrecognized' header and the act of ignoring it is encapsulated in these helper functions. Since none of the labeled spec constraints (for example, a condition such as C1 for ignoring unrecognized header/trailer fields) are completely and explicitly implemented within the body of the function itself—and instead the function relies on external functionality—the implementation only partially matches the requirement. Dependencies are not counted, so the function in isolation partially meets the RFC's intended behavior.",success,
11776,h2_ignore_resp_trailer,Other recipients SHOULD ignore unrecognized header and trailer fields.,0,Partially Matches,"[{'C1': {'code': 'return (contains_name(H2_LIT_ARGS(IgnoredResponseHeaders), &nv)\n            || contains_name(H2_LIT_ARGS(IgnoredResponseTrailers), &nv));', 'explanation': 'This code segment checks whether the header field corresponds to a predefined list of ignored header or trailer fields. It is an attempt to implement the RFC requirement that recipients ignore unrecognized header and trailer fields. However, the function only performs a lookup (i.e. determines if the field should be ignored) and does not itself perform any additional mechanism (like processing or discarding) required by the full spec.'}}]","The RFC states that recipients SHOULD ignore unrecognized header and trailer fields. The h2_ignore_resp_trailer function inspects the header field name by comparing it against two predefined lists (IgnoredResponseHeaders and IgnoredResponseTrailers). This logic is the function’s attempt to determine if a field is one that should be ignored. However, while the function correctly identifies such fields through a lookup, it does not itself perform further actions (such as actually discarding the field) beyond returning a flag. Therefore, although the function addresses one aspect of the RFC’s requirement, it only partially implements the complete behavior expected from the specification.",success,
11777,req_add_header,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': 'strip_field_value_ws(nv);', 'explanation': ""This function call is used at the very start of the function to remove any bad whitespace (BWS) from the header's value, directly addressing the RFC requirement to remove BWS before interpretation.""}}]","The RFC specifies that any content known to be defined as BWS may be removed before interpreting or forwarding the message downstream. The function implements this by immediately calling strip_field_value_ws(nv) to strip such whitespace. All logic addressing the BWS removal is contained within this function, ignoring any behavior that might be implemented in dependencies. Therefore, the code function fully addresses the relevant RFC behavior.",success,
11777,req_add_header,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': 'strip_field_value_ws(nv);', 'explanation': 'This call at the very start of the function indicates that the header value is preprocessed to remove any bad whitespace before any further handling, which directly addresses the specification that a recipient must remove such whitespace.'}}]","The function explicitly calls strip_field_value_ws(nv) before any other processing, thereby ensuring that any bad whitespace is removed from the header field value. This directly satisfies the RFC's requirement that a recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element. Although the helper function's internal implementation is not shown, its invocation within the function body qualifies as addressing the specified constraint.",success,
11777,req_add_header,A sender MUST NOT generate BWS in messages.,239,Partially Matches,"[{'C1': {'code': 'strip_field_value_ws(nv);', 'explanation': 'The function begins by invoking strip_field_value_ws(nv), which appears intended to remove extraneous (bad) whitespace from the header value before further processing. This is an attempt to comply with the RFC requirement that a sender must not generate BWS in messages.'}}]","The RFC specifies that a sender MUST NOT generate bad whitespace (BWS) in messages. In this code, the only visible effort toward meeting that requirement is the call to strip_field_value_ws(nv) at the beginning of the function. This demonstrates an awareness of the need to remove extra or improperly formatted whitespace. However, aside from this call, the function does not include additional logic explicitly dedicated to ensuring that no BWS is generated (for example, in subsequent header construction or merging operations). Hence, the function partially implements the spec constraint on BWS solely by pre-stripping whitespace.",success,
11777,req_add_header,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'C1': {'code': 'else if (nv->namelen == sizeof(""host"")-1\n             && !ap_cstr_casecmp(""host"", (const char *)nv->name)) {\n        if (apr_table_get(headers, ""Host"")) {\n            return APR_SUCCESS; /* ignore duplicate */\n        }\n    }', 'explanation': ""This segment checks for a duplicate 'Host' header and, if one exists, prevents adding another field line, addressing the requirement to not generate multiple header lines for this header.""}}, {'A1': {'code': 'if (existing) {\n    /* Cookie header come separately in HTTP/2, but need\n     * to be merged by ""; "" (instead of default "", "")\n     */\n    hvalue = apr_pstrndup(pool, (const char*)nv->value, nv->valuelen);\n    apr_table_setn(headers, ""Cookie"",\n                   apr_psprintf(pool, ""%s; %s"", existing, hvalue));\n    return APR_SUCCESS;\n}\n\n...\n\nif (!existing) *pwas_added = 1;\nhvalue = apr_pstrndup(pool, (const char*)nv->value, nv->valuelen);\napr_table_mergen(headers, hname, hvalue);', 'explanation': ""This part handles merging duplicate header values. For the 'Cookie' header, it merges using a semicolon separator. For other headers, it uses apr_table_mergen to combine values into a single header line, which implements the allowed merging behavior as per the RFC for headers that can have comma‐separated lists.""}}]","The function shows visible logic to implement aspects of the HTTP RFC pertaining to how duplicate headers should be handled. It prevents duplicate 'Host' headers from being added and merges 'Cookie' headers using a specialized concatenation. For all other headers, it uses a merging function (apr_table_mergen) to avoid generating separate header lines. However, the logic is applied only to specific cases and does not generically verify whether a header's definition permits merging, so while the function addresses important parts of the specification, it does so only partially.",success,
11777,req_add_header,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'A1': {'code': 'strip_field_value_ws(nv);', 'explanation': 'The function immediately invokes strip_field_value_ws(nv) to remove any leading or trailing whitespace from the field value before any further processing, thereby addressing the RFC requirement that whitespace should be excluded prior to evaluation.'}}]","The provided function begins by explicitly calling strip_field_value_ws(nv), which implements the action required by the RFC to remove whitespace before further processing of the field value. This logic is contained within the function itself and directly addresses the spec's mandate, hence the function fully matches the constraint.",success,
11778,h2_req_add_header,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function h2_req_add_header merely initializes a header structure (nghttp2_nv) and delegates the actual header addition to req_add_header. There is no logic within this function that checks or restricts which protocol elements may be generated based on sender roles as required by the RFC specification. Therefore, it does not visibly address any of the conditions or actions (e.g., C1, A1) specified in the RFC.",success,
11779,h2_util_frame_print,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function only generates string representations of various HTTP/2 frame types. It does not implement any logic to check or enforce that the sender should not generate protocol elements or syntax alternatives reserved for other roles, as specified in the RFC. There is no conditional check or restriction within the function_body that prevents generating elements that are only allowed for other participants, hence it does not visibly address the labeled condition in the RFC specification.",success,
11779,h2_util_frame_print,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The function h2_util_frame_print merely formats and returns human‐readable strings based on the frame's fields. It does not include any logic to ensure that the generated protocol elements conform to the ABNF grammar required by the RFC. None of the spec constraints (for example, the condition requiring that a sender not generate elements that do not match the defined grammar) are enforced within the function; it simply prints predefined string formats without validating their conformance to any specific grammar.",success,
11780,h2_push_policy_determine,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (push_enabled) {\n    const char *val = apr_table_get(headers, ""accept-push-policy"");\n    if (val) {\n        ...\n    }\n    else {\n        policy = H2_PUSH_DEFAULT;\n    }\n}', 'explanation': ""This segment shows that the function checks for the presence of a protocol element (the 'accept-push-policy' header) and then interprets its content by checking for known tokens. It also recovers by falling back to a default value if the header is absent.""}}, {'A1': {'code': 'if (val) {\n    if (ap_find_token(p, val, ""fast-load"")) {\n        policy = H2_PUSH_FAST_LOAD;\n    }\n    else if (ap_find_token(p, val, ""head"")) {\n        policy = H2_PUSH_HEAD;\n    }\n    else if (ap_find_token(p, val, ""default"")) {\n        policy = H2_PUSH_DEFAULT;\n    }\n    else if (ap_find_token(p, val, ""none"")) {\n        policy = H2_PUSH_NONE;\n    }\n    else {\n        /* nothing known found in this header, go by default */\n        policy = H2_PUSH_DEFAULT;\n    }\n}', 'explanation': 'This part of the code implements a decision mechanism based on the semantics defined for the header field. It selects a policy according to the value token or recovers by assigning a default if the token is unrecognized. This is in line with the idea of recovering a usable protocol element from an invalid construct.'}}]","The function examines the 'accept-push-policy' header and applies token-based interpretation to decide a push policy, with a fallback to a default policy when the header is missing or its token is not recognized. This behavior partially addresses the specification which requires that a recipient interpret a received protocol element according to defined semantics and attempt recovery from invalid constructs. However, the function does not implement any logic to determine from experience or configuration that the sender incorrectly implements the semantics, nor does it address potential error handling strategies related to security, which are aspects touched on in the provided RFC context. Therefore, the function partially matches the spec constraints.",success,
11830,proxy_http2_canon,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'port = def_port = ap_proxy_port_of_scheme(http_scheme);\n...\nif (port != def_port) {\n    apr_snprintf(sport, sizeof(sport), "":%d"", port);\n} else {\n    sport[0] = \'\\0\';\n}', 'explanation': ""The RFC states that if a port is not provided, the default port for the received protocol should be assumed. The code retrieves the default port based on the protocol via 'ap_proxy_port_of_scheme', stores it in both 'port' and 'def_port', and later only appends a port to the URL if 'port' differs from 'def_port'. This clearly implements the spec's requirement.""}}]","The function 'proxy_http2_canon' implements the requirement from the RFC by obtaining the default port for the protocol and checking if the parsed port matches this default. When a port is not provided, the default remains unchanged, and no explicit port is appended to the canonical URL, thereby correctly interpreting the absence of a port as the use of the default port.",success,
11830,proxy_http2_canon,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Fully Matches,"[{'C1': {'code': 'err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);\n...\n#ifdef PROXY_CANONENC_NOENCODEDSLASHENCODING\n    path = ap_proxy_canonenc_ex(r->pool, url, (int)strlen(url),\n                                enc_path, flags, r->proxyreq);\n#else\n    path = ap_proxy_canonenc(r->pool, url, (int)strlen(url),\n                             enc_path, 0, r->proxyreq);\n#endif', 'explanation': 'This section first splits the URL into its netloc components (host and port) and then applies canonicalization to the URL’s path using dedicated encoding routines. This normalization of URL components directly addresses the RFC’s requirement that equivalent HTTP URIs (after normalization) identify the same resource.'}}, {'A1': {'code': 'r->filename = apr_pstrcat(r->pool, ""proxy:"", scheme, ""://"", host, sport,\n                              ""/"", path, (search) ? ""?"" : """", (search) ? search : """", NULL);', 'explanation': 'This final assembly of the canonicalized URL ensures that after normalization, the URI is in a consistent format. It reflects the action part of the spec by constructing a normalized URI that can be compared against others for equivalence.'}}]","The function 'proxy_http2_canon' visibly implements canonicalization as required by the RFC. It extracts and normalizes the host, port, and path via routines such as ap_proxy_canon_netloc and ap_proxy_canonenc (or its variant), and then reconstructs a uniform proxy URL. This fulfills both the normalization condition (C1) and the action of forming a consistently normalized URL (A1), thereby fully addressing the spec constraints within the function itself.",success,
11830,proxy_http2_canon,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'C1': {'code': 'if (path == url && *ap_scan_vchar_obstext(path)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10420)\n                  ""To be forwarded path contains control ""\n                  ""characters or spaces"");\n    return HTTP_FORBIDDEN;\n}\nif (search && *ap_scan_vchar_obstext(search)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10412)\n                  ""To be forwarded query string contains control ""\n                  ""characters or spaces"");\n    return HTTP_FORBIDDEN;\n}', 'explanation': 'This segment checks for disallowed control characters or spaces within the request-target (both path and query) and rejects the request when such characters are found, which aligns with the requirement that no whitespace is allowed in the request-target.'}}, {'A1': {'code': 'if (err) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(03350)\n                  ""error parsing URL %s: %s"", url, err);\n    return HTTP_BAD_REQUEST;\n}\n...\nif (!path) {\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'These code segments handle errors during URL parsing by returning a 400 (Bad Request) error, which is one of the allowed responses for an invalid request-line per the RFC. However, the alternative of issuing a 301 redirect with a properly encoded request-target is not implemented.'}}]","The function partially meets the RFC spec constraints. It validates the request-target by checking for disallowed characters (fulfilling condition C1) and in cases of parsing errors returns a 400 (Bad Request) error (one acceptable action under A1). However, it does not implement the alternative behavior of issuing a 301 (Moved Permanently) redirect with the properly encoded request-target. As a result, while parts of the spec constraints are addressed, the function does not fully implement all expected behaviors from the RFC.",success,
11830,proxy_http2_canon,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",175,Partially Matches,"[{'C1': {'code': 'err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);\nif (err) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(03350)\n                  ""error parsing URL %s: %s"", url, err);\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'This segment checks whether the URL (a component of the HTTP request) adheres to the expected format. In case of a parsing error, the function responds with an HTTP_BAD_REQUEST (400) error, which is an action suggested by the RFC when the message grammar does not match expectations. However, only part of the overall spec (i.e. malformed URL handling) is addressed here.'}}, {'A1': {'code': 'if (!path) {\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'When canonicalization of the path fails, the function again returns a 400 error, fulfilling an aspect of the requirement to reject malformed inputs.'}}]","The function attempts to validate and canonicalize a URL by parsing its components and checking for control characters and spaces. When failures occur during parsing or encoding, it returns HTTP_BAD_REQUEST, thereby partially addressing the RFC specification's requirement to reject non-conforming HTTP request components. However, this function only handles errors related to URL canonicalization and not the full scope of HTTP-message grammar (including, for example, the proper handling or ignoring of whitespace-preceded header lines). As a result, while some conditions (and corresponding actions) of the spec are addressed, the implementation only partially matches the RFC requirements.",success,
11847,ping_ev_frame_received,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function, ping_ev_frame_received, is responsible for handling ping events and managing state transitions based on the type of frame received. It does not contain any logic for generating or validating protocol elements against the ABNF grammar defined in the HTTP specification. In particular, the requirement that 'A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules' is not addressed within the code of this function. The logic in the function strictly manages state transitions for ping events and does not implement any grammar checking or protocol element generation, hence it does not visibly address any labeled spec constraints (C1, A1, etc.) within its own body.",success,
11847,ping_ev_frame_received,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The code function 'ping_ev_frame_received' is designed solely for receiving and handling ping frames by updating state and timestamps. It does not implement any logic to enforce the RFC requirement that a sender must not generate protocol elements or syntax alternatives that are reserved for other roles. There is no visible code in the function that checks or prevents generation of protocol elements based on sender role, so it does not address the spec constraint.",success,
11851,on_frame_recv,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Does Not Match,[],"The provided function on_frame_recv handles various HTTP/2 frame types such as HEADERS, PING, SETTINGS, and GOAWAY. However, none of its logic explicitly implements the spec constraint of sustaining persistent connections or allowing the flow‐control mechanism to resolve temporary overloads rather than terminating connections. There are no direct references or code segments that implement the behavior described in the spec regarding persistent connection management or handling a busy network scenario. All logic in this function is focused on frame reception and handling intermediate responses, and does not address the labeled conditions (e.g., C1, etc.) or actions (e.g., A1, etc.) required by the RFC specification.",success,
11851,on_frame_recv,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The RFC specification requires that an origin server MUST NOT use the transitory context information (such as Content-Location) to alter request semantics. The provided code function 'on_frame_recv' does not inspect or process any Content-Location header or similar context-related data. Its logic is focused on handling HTTP/2 frame types (such as HEADERS, PING, SETTINGS, GOAWAY) and handling interim response forwarding. There is no logic within the function that implements or enforces the constraint of not altering request semantics based on any context. Therefore, the function does not attempt to implement the specified RFC constraint.",success,
11857,h2_proxy_stream_end_headers_out,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,"[{'A1': {'code': 'if ((buf = apr_table_get(r->headers_out, ""Content-Type""))) {\n    ap_set_content_type(r, apr_pstrdup(p, buf));\n}', 'explanation': ""This segment checks if a Content-Type header exists in r->headers_out and, if so, sets the response's content type accordingly. It addresses the RFC requirement to include a Content-Type header when the media type is known. However, the function does not generate a Content-Type header on its own if none exists, so it only partially implements the spec constraint.""}}]","The RFC specifies that a sender should include a Content-Type header field when its representation's media type is known. The function contains logic that retrieves and sets the Content-Type header if it exists, which aligns with this requirement. However, it does not create or generate a Content-Type header if missing, meaning it does not fully implement the entire requirement within this function alone. Therefore, the implementation is considered a partial match.",success,
11864,open_stream,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Does Not Match,[],"The RFC specifies that a sender MUST NOT generate an ""http"" URI with an empty host identifier. In the function, while authority is derived from either the request headers or parsed URI, there is no explicit check to ensure that the host (authority) is non-empty. The code does not validate or reject an empty host identifier before generating the URI, and thus does not implement the required constraint within this function.",success,
11864,open_stream,"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",225,Does Not Match,[],"The RFC requires that a sender must not generate an ""https"" URI with an empty host identifier. In the provided function, although the code extracts the authority component from either the request headers or the parsed URI, it does not enforce a check to ensure that the host is not empty when the scheme is ""https"". There is no validation or error handling within the function to reject or avoid generating an ""https"" URI with an empty host identifier. Therefore, the function does not meet the specified constraint within its own logic.",success,
11865,submit_stream,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (stream->waiting_on_100 || stream->waiting_on_ping) {\n    /* make a small test if we get an EOF/EOS immediately */\n    status = ap_get_brigade(stream->r->input_filters, stream->input,\n                             AP_MODE_READBYTES, APR_NONBLOCK_READ,\n                             APR_BUCKET_BUFF_SIZE);\n    may_have_request_body = APR_STATUS_IS_EAGAIN(status)\n                            || (status == APR_SUCCESS \n                                && !APR_BUCKET_IS_EOS(APR_BRIGADE_FIRST(stream->input)));\n}', 'explanation': 'This code segment comments and logic ensure that when the stream is waiting on a 100-continue or a ping, it deliberately avoids reading input data that could trigger the generation of a 100-continue message—a protocol element that should only be generated by the proper participant role. This aligns with the RFC requirement that a sender must not generate protocol elements or syntax alternatives that are reserved for others.'}}]","The function partially implements the RFC requirement by including a specific check that prevents input reading (which might inadvertently trigger the generation of a 100-continue response) when the stream is in a state that expects such a response. This indicates an awareness of the need to avoid generating protocol elements that are reserved for other roles. However, the function does not address other potential protocol element constraints or comprehensively cover all role-based restrictions as laid out by the RFC, so its treatment is only partial.",success,
11866,submit_trailers,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function simply constructs and submits trailer header data by calling h2_proxy_util_nghd_make and nghttp2_submit_trailer. It does not contain any logic to validate whether the protocol element being generated (i.e., the trailers) is authorized for the sender role, as mandated by the spec constraint (e.g., ensuring that the sender does not generate protocol elements reserved for other roles). Therefore, no labeled condition or action (such as C1 or A1) is visibly addressed within this function.",success,
11866,submit_trailers,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The function submit_trailers merely prepares and submits trailer headers using nghttp2_submit_trailer. It does not include any logic to verify whether the recipient understands the corresponding header field or that its definition explicitly permits merging trailer fields into the header section. There are no checks or conditions within the function body that implement the spec requirement regarding safely merging trailer field values, so it does not address the constraint as specified.",success,
11881,ev_proto_error,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'A1': {'code': 'session_shutdown(session, arg, msg);', 'explanation': 'When the session state is not already DONE or in a local shutdown, the function calls session_shutdown(), thereby directly closing the transport connection in response to a protocol error. This aligns with the RFC clause that a client, server, or proxy MAY close the transport connection at any time.'}}]","The function ev_proto_error implements part of the RFC requirement by closing the connection on a protocol error via session_shutdown. In cases where the session state is already shutdown, it instead performs a state transition. However, it does not implement other aspects mentioned in the spec context (such as monitoring for incoming closure signals or handling timeouts gracefully by itself). Because only the connection shutdown on error is visibly addressed in the function body, the implementation is only partially matching the overall RFC specification.",success,
11882,ev_conn_timeout,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'case H2_PROXYS_ST_LOCAL_SHUTDOWN:\n    transit(session, ""conn timeout"", H2_PROXYS_ST_DONE);\n    break;', 'explanation': 'When the session is already in a shutdown state (H2_PROXYS_ST_LOCAL_SHUTDOWN), the function immediately transitions the connection to a DONE state. This handles the scenario where the connection is already scheduled for closure.'}}, {'A1': {'code': 'default:\n    session_shutdown(session, arg, msg);\n    transit(session, ""conn timeout"", H2_PROXYS_ST_DONE);\n    break;', 'explanation': 'In the default case, the function invokes a shutdown of the session (presumably in a graceful manner) before transitioning to the DONE state, addressing the spec’s guidance that a connection timeout should lead to a graceful close.'}}]","The RFC spec indicates that a client, server, or proxy may close a transport connection at any time, and the specification context recommends a graceful shutdown on timeout. This function ev_conn_timeout implements a graceful closure strategy upon a timeout by checking the session state and then invoking session_shutdown (in the default case) or simply transitioning state if already in shutdown mode. However, it only handles the shutdown on a timeout event and does not address continuous monitoring or other scenarios mentioned in the broader spec context. As such, it partially matches the constraints by implementing the graceful shutdown on timeout without covering all recommended behaviors.",success,
11882,ev_conn_timeout,A client or server that wishes to time out SHOULD issue a graceful close on the connection.,314,Fully Matches,"[{'C1': {'code': 'switch (session->state) {\n    case H2_PROXYS_ST_LOCAL_SHUTDOWN:\n        transit(session, ""conn timeout"", H2_PROXYS_ST_DONE);\n        break;\n    default:\n        session_shutdown(session, arg, msg);\n        transit(session, ""conn timeout"", H2_PROXYS_ST_DONE);\n        break;\n}', 'explanation': 'The function distinguishes whether the session is already in a local shutdown state (in which case it simply transitions to the DONE state) or not. This conditional handling of the session state on a timeout is a direct implementation of monitoring the connection state for timeout events.'}}, {'A1': {'code': 'session_shutdown(session, arg, msg);', 'explanation': 'In the default case for a timeout event, the function calls session_shutdown to initiate a graceful closure of the connection, which fulfills the RFC requirement that a client or server wishing to time out SHOULD issue a graceful close.'}}]","The function ev_conn_timeout is invoked on a timeout event and its logic directly addresses the RFC specification. It checks the session state and, if not already shutting down, calls session_shutdown to gracefully close the connection before transitioning to a 'done' state. This visible use of the shutdown operation to initiate a graceful close meets the specified action from the RFC.",success,
11892,h2_proxy_session_process,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'return APR_SUCCESS; /* needs to be called again */', 'explanation': 'The function operates within a loop (using goto run_loop) and only terminates (returns APR_EOF) when the state is H2_PROXYS_ST_DONE. This indicates an attempt to sustain a persistent connection rather than closing it immediately.'}}, {'A1': {'code': 'if (!have_written && !have_read && !nghttp2_session_want_write(session->ngh2)) {\n    dispatch_event(session, H2_PROXYS_EV_NO_IO, 0, NULL);\n    goto run_loop;\n}', 'explanation': ""This code checks for idle states and does not close the connection when there is no current IO activity. By relying on nghttp2's indications of read/write readiness, it defers connection termination, implicitly allowing the underlying transport’s flow-control to manage temporary overloads.""}}]","The function implements a session-processing loop that preserves a persistent connection by continually handling read/write events and only closing the connection when explicitly marked as done. It does not, however, cover all aspects of the RFC—such as monitoring client message body transmission for error responses—nor does it explicitly manage every detail of transport flow control. Thus, while it partially addresses the RFC by sustaining persistent connections and deferring closure in idle conditions, it does not fully implement all stipulated behaviors.",success,
11895,done_iter,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function primarily handles cleanup operations and error bucket insertion for a stream. It does not contain any logic that verifies or restricts the generation of protocol elements based on sender roles as specified by the HTTP RFC requirement. There are no sections of the code that check or enforce that only allowed protocol elements (according to the sender's role) are generated, hence the function does not implement any of the spec constraints (e.g., C1, A1, etc.).",success,
11904,uniq_field_values,"In any production that uses the list construct, a sender MUST NOT generate empty list elements.",236,Fully Matches,"[{'C1': {'code': ""while (*e == ',' || apr_isspace(*e)) {\n    ++e;\n}\nif (*e == '\\0') {\n    break;\n}"", 'explanation': 'This segment explicitly skips commas and whitespace before processing a field, ensuring that empty list elements are not generated as required by the RFC spec.'}}]","The function processes a comma-delimited string and skips any commas or whitespace at the beginning of each field. By advancing past these characters and only processing non-empty tokens, it directly implements the requirement that empty list elements must not be generated.",success,
11904,uniq_field_values,"A recipient MUST parse and ignore a reasonable number of empty list elements: enough to handle common mistakes by senders that merge values, but not so much that they could be used as a denial-of-service mechanism.",237,Fully Matches,"[{'C1': {'code': ""do {\n    /* Find a non-empty fieldname */\n\n    while (*e == ',' || apr_isspace(*e)) {\n        ++e;\n    }\n    if (*e == '\\0') {\n        break;\n    }\n    start = e;\n    while (*e != '\\0' && *e != ',' && !apr_isspace(*e)) {\n        ++e;\n    }\n    if (*e != '\\0') {\n        *e++ = '\\0';\n    }\n    ...\n} while (*e != '\\0');"", 'explanation': 'This code segment skips over commas and whitespace at the beginning of each iteration to ignore empty list elements. This behavior satisfies the RFC requirement to parse and ignore a reasonable number of empty list elements.'}}]","The function 'uniq_field_values' processes the input string by repeatedly skipping over commas and whitespace before extracting non-empty tokens. This directly implements the RFC specification by ignoring empty list elements. Although the function does not enforce an upper bound on the number of empty tokens (which might be relevant for denial-of-service concerns), the specification only mandates that empty elements be ignored rather than limiting their count. Therefore, in isolation, the code function fully matches the RFC requirement as specified.",success,
11904,uniq_field_values,"In other words, a recipient MUST accept lists that satisfy the following syntax:",238,Partially Matches,"[{'C1': {'code': ""while (*e == ',' || apr_isspace(*e)) { ++e; }"", 'explanation': 'This loop ensures that empty list elements (i.e. extra commas or whitespace) are skipped, which addresses the requirement to accept lists with empty elements as allowed by the RFC.'}}]","The function parses a comma-separated list, skips over empty elements, and collects unique tokens, which partially addresses the RFC requirement to accept lists with possibly empty elements. However, it does not fully implement all aspects of the specified ABNF or any additional conditions/actions (e.g., managing explicit cardinality rules) because such parts of the specification are either not represented or are delegated elsewhere in the system. Thus, the code function partially matches the spec constraints.",success,
11905,fix_vary,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Fully Matches,"[{'C1': {'code': 'apr_table_do(uniq_field_values, varies, r->headers_out, ""Vary"", NULL);', 'explanation': ""This line iterates over all instances of the 'Vary' header, ensuring that duplicate field lines are processed only once, which addresses the RFC requirement to not generate multiple field lines with the same name.""}}, {'A1': {'code': 'if (varies->nelts > 0) {\n    apr_table_setn(r->headers_out, ""Vary"", apr_array_pstrcat(r->pool, varies, \',\'));\n}', 'explanation': ""After extracting and de-duplicating the header values, this block recombines them into a single, comma-separated string and resets the 'Vary' header. This directly implements the action of combining multiple field lines as allowed by the RFC.""}}]","The function 'fix_vary' directly addresses the RFC requirements by first extracting all occurrences of the 'Vary' header and then using logic (via 'uniq_field_values' and array concatenation) to create a single header line with a comma-separated list. This ensures that multiple header lines are not generated, fulfilling both the condition and the corresponding action as specified in the RFC.",success,
11905,fix_vary,"A recipient MAY combine multiple field lines within a field section that have the same field name into one field line, without changing the semantics of the message, by appending each subsequent field line value to the initial field line value in order, separated by a comma ("","") and optional whitespace (OWS, defined in Section 5.6.3).",231,Partially Matches,"[{'C1': {'code': 'apr_table_do(uniq_field_values, varies, r->headers_out, ""Vary"", NULL);', 'explanation': 'This call gathers all Vary header values, which is the first step in combining multiple field lines having the same name.'}}, {'A1': {'code': 'apr_table_setn(r->headers_out, ""Vary"", apr_array_pstrcat(r->pool, varies, \',\'));', 'explanation': ""This code concatenates the collected header values into one string separated by a comma. However, the spec context requires a comma followed by a single space ('comma SP') for consistency, which is not adhered to here.""}}]","The function fix_vary attempts to implement the RFC directive by collecting multiple 'Vary' header field lines and merging them into one header line. It preserves the order and removes duplicate values. However, while it uses a comma as a separator, it does not incorporate the single space after the comma ('comma SP') as specified in the RFC and its context. Consequently, although the function addresses some parts of the constraints, it does not fully implement the required separator format, resulting in a partial match.",success,
11906,create_response,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'C1': {'code': 'if (r->chunked) {\n    apr_table_mergen(r->headers_out, ""Transfer-Encoding"", ""chunked"");\n    apr_table_unset(r->headers_out, ""Content-Length"");\n}\n\nif (!apr_is_empty_array(r->content_languages)) {\n    ...\n    field = apr_array_pstrcat(r->pool, r->content_languages, \',\');\n    apr_table_setn(r->headers_out, ""Content-Language"", field);\n}', 'explanation': ""The function uses apr_table_mergen to combine the 'Transfer-Encoding' header properly and concatenates content languages into a comma‐separated list. These actions indicate an attempt to avoid creating multiple field lines for these headers, which aligns with the RFC requirement (i.e. not adding multiple header lines for the same name unless defined to allow comma-separated merging).""}}]","The function makes visible attempts to consolidate specific headers (e.g. Transfer-Encoding and Content-Language) by merging values or overriding duplicate settings (using functions such as apr_table_setn and apr_table_mergen), which partially addresses the RFC constraint that the sender must not generate multiple field lines with the same name unless allowed. However, the function does not include comprehensive logic to preserve the order of all received header fields or to check for duplication in every header field, so it only partially meets the spec constraints within its own body.",success,
11906,create_response,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'else if (r->chunked) {\n        apr_table_mergen(r->headers_out, ""Transfer-Encoding"", ""chunked"");\n        apr_table_unset(r->headers_out, ""Content-Length"");\n    }', 'explanation': 'This code branch explicitly adds the Transfer-Encoding header (with the value ""chunked"") and then unsets the Content-Length header. This directly enforces the RFC requirement that a message which includes a Transfer-Encoding header must not contain a Content-Length header.'}}]","The function includes clear logic to ensure that when a message is to be sent with chunked transfer encoding (i.e., r->chunked is true), it sets the Transfer-Encoding header and then removes the Content-Length header. This behavior implements the RFC specification stating that a sender MUST NOT send a Content-Length header in any message that contains a Transfer-Encoding header field.",success,
11906,create_response,HTTP implementations SHOULD support persistent connections.,311,Partially Matches,"[{'A1': {'code': '/* determine the protocol and whether we should use keepalives. */\n    ap_set_keepalive(r);', 'explanation': 'The function explicitly calls ap_set_keepalive(r) to handle connection persistence, demonstrating an attempt to support persistent connections as specified. However, the actual logic for determining or setting the keepalive behavior is delegated to the helper function, which means that while the function acknowledges this requirement, it only partially implements it within its own body.'}}]","The RFC states that HTTP implementations SHOULD support persistent connections. In this function, the persistent connection requirement is approached by calling ap_set_keepalive(r), which is the only visible indication of handling persistent connections within the function. Since the detailed implementation is deferred to a helper function rather than being fully realized in the code of create_response itself, the function only partially matches the specification.",success,
11906,create_response,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Partially Matches,"[{'A1': {'code': 'else if (r->chunked) {\n    apr_table_mergen(r->headers_out, ""Transfer-Encoding"", ""chunked"");\n    apr_table_unset(r->headers_out, ""Content-Length"");\n}', 'explanation': ""When the r->chunked flag is true, the function sets the 'Transfer-Encoding' header to 'chunked' and removes any 'Content-Length' header. This is in line with the RFC suggestion to use an encoding-delimited message when possible.""}}, {'A2': {'code': 'if (AP_STATUS_IS_HEADER_ONLY(r->status)) {\n    apr_table_unset(r->headers_out, ""Transfer-Encoding"");\n    apr_table_unset(r->headers_out, ""Content-Length"");\n    ...\n}', 'explanation': ""For header-only responses, the function explicitly removes both 'Transfer-Encoding' and 'Content-Length', preventing the sending of an inappropriate length header. This indirectly relates to proper framing of messages.""}}]","The function partially implements the RFC requirement that a server should generate encoding or length-delimited messages whenever possible. It does so by explicitly handling two cases: one for header-only responses (removing Transfer-Encoding and Content-Length) and one for responses using chunked encoding (setting Transfer-Encoding to 'chunked' and unsetting Content-Length). However, it does not handle other aspects of the RFC specification, such as validating or processing an invalid Content-Length header field. As a result, while some spec actions are visibly addressed, the implementation in this function does not cover all the labeled conditions and actions.",success,
11906,create_response,"A server MAY send an HTTP/1.0 response to an HTTP/1.1 request if it is known or suspected that the client incorrectly implements the HTTP specification and is incapable of correctly processing later version responses, such as when a client fails to parse the version number correctly or when an intermediary is known to blindly forward the HTTP-version even when it doesn't conform to the given minor version of the protocol.",297,Partially Matches,"[{'A1': {'code': 'if (apr_table_get(r->subprocess_env, ""force-no-vary"") != NULL) {\n    apr_table_unset(r->headers_out, ""Vary"");\n    r->proto_num = HTTP_VERSION(1,0);\n    apr_table_setn(r->subprocess_env, ""force-response-1.0"", ""1"");\n}', 'explanation': ""This code block checks for a client-related trigger (the 'force-no-vary' flag) and then removes the 'Vary' header while downgrading the response to HTTP/1.0. This matches part of the RFC's allowance for sending an HTTP/1.0 response when the client is suspected to be unable to handle later version responses. However, the RFC also mentions triggering based on specific client attributes (e.g., User-Agent), which is not fully covered here.""}}]","The function contains explicit logic to downgrade the HTTP version (via r->proto_num = HTTP_VERSION(1,0)) when a specific workaround flag ('force-no-vary') is present, which aligns with part of the RFC specification regarding protocol downgrading for certain clients. Nevertheless, it does not implement the full range of conditions (such as specific client header matching) described in the spec context, hence only partially matching the intended constraints.",success,
11906,create_response,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,61,Fully Matches,"[{'C1': {'code': 'if (AP_STATUS_IS_HEADER_ONLY(r->status)) {\n    apr_table_unset(r->headers_out, ""Transfer-Encoding"");\n    apr_table_unset(r->headers_out, ""Content-Length"");\n    r->content_type = r->content_encoding = NULL;\n    r->content_languages = NULL;\n    r->clength = r->chunked = 0;\n}', 'explanation': 'This branch detects a header-only (i.e. HEAD) response and removes headers related to content (Transfer-Encoding and Content-Length) while nullifying content-specific fields. This directly addresses the RFC requirement that a HEAD response MUST NOT send content.'}}, {'A1': {'code': 'if (r->header_only\n    && (clheader = apr_table_get(r->headers_out, ""Content-Length""))\n    && !strcmp(clheader, ""0"")) {\n    apr_table_unset(r->headers_out, ""Content-Length"");\n}', 'explanation': 'This later check prevents a header with a zero Content-Length from being sent, which supports the requirement by ensuring that no misleading content-length information is included in a HEAD response.'}}]","The provided function builds the response headers for a request and includes specific logic for HEAD requests. It merges header tables similar to how a GET would be processed, then—if the response is header-only—removes all content-related headers and nullifies content-specific fields so that no actual response body is transmitted. This implementation fulfills the RFC’s requirement that HEAD is identical to GET in terms of header fields, with the explicit exception that no content is sent.",success,
11906,create_response,Content-Language MAY be applied to any media type --it is not limited to textual documents.,42,Fully Matches,"[{'C1': {'code': 'if (!apr_is_empty_array(r->content_languages)) {\n    int i;\n    char *token;\n    char **languages = (char **)(r->content_languages->elts);\n    const char *field = apr_table_get(r->headers_out, ""Content-Language"");\n\n    while (field && (token = ap_get_list_item(r->pool, &field)) != NULL) {\n        for (i = 0; i < r->content_languages->nelts; ++i) {\n            if (!ap_cstr_casecmp(token, languages[i]) )\n                break;\n        }\n        if (i == r->content_languages->nelts) {\n            *((char **) apr_array_push(r->content_languages)) = token;\n        }\n    }\n\n    field = apr_array_pstrcat(r->pool, r->content_languages, \',\');\n    apr_table_setn(r->headers_out, ""Content-Language"", field);\n}', 'explanation': ""This code block unconditionally sets the 'Content-Language' header when the content_languages array is not empty, without limiting the header only to textual media types. This directly implements the RFC specification that Content-Language MAY be applied to any media type.""}}]","The function checks if the content_languages array is non-empty and then constructs and sets the 'Content-Language' header accordingly. It does not impose any restrictions based on the media type, thereby ensuring that the header can be applied to any representation as outlined in the RFC. Thus, the logic directly addresses the RFC requirement.",success,
11906,create_response,"If one or more encodings have been applied to a representation, the sender that applied the encodings MUST generate a Content-Encoding header field that lists the content codings in the order in which they were applied.",37,Partially Matches,"[{'A1': {'code': 'if (r->content_encoding) {\n    apr_table_setn(r->headers_out, ""Content-Encoding"", r->content_encoding);\n}', 'explanation': ""The function sets the 'Content-Encoding' header if r->content_encoding is provided. This partially addresses the RFC requirement by ensuring that a Content-Encoding header is generated when an encoding is applied. However, it does not explicitly handle multiple encodings (e.g., ensuring they are listed in the order applied or filtering out the 'identity' coding), which means the implementation is only partial.""}}]","The RFC specifies that when one or more encodings have been applied, the Content-Encoding header must list all the codings in the order they were applied. The code function does check for an existing r->content_encoding and sets it as the Content-Encoding header, meeting the basic requirement of generating the header. However, it does not implement any logic to support multiple encodings or control their order, and it does not ensure that the reserved 'identity' coding is avoided. Since these additional requirements are not handled within this function, the implementation only partially matches the RFC specification.",success,
11906,create_response,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'ctype = ap_make_content_type(r, r->content_type);\n    if (ctype) {\n        apr_table_setn(r->headers_out, ""Content-Type"", ctype);\n    }', 'explanation': ""This code segment checks if a valid Content-Type can be generated via ap_make_content_type. If it returns a non-null value (indicating that the intended media type is known), the function sets the 'Content-Type' header field. This directly implements the spec requirement that a message containing content should generate a Content-Type header field unless the media type is unknown.""}}]","The function clearly implements the RFC requirement by conditionally generating and setting the 'Content-Type' header when the media type is known. The key logic (A1) is contained within the function itself, making it fully compliant with the spec constraint.",success,
11906,create_response,A sender that generates a Date header field SHOULD generate its field value as the best available approximation of the date and time of message generation.,15,Fully Matches,"[{'C1': {'code': 'if (r->proxyreq == PROXYREQ_NONE\n        || !apr_table_get(r->headers_out, ""Date"")) {\n        char *date = apr_palloc(r->pool, APR_RFC822_DATE_LEN);\n        ap_recent_rfc822_date(date, r->request_time);\n        apr_table_setn(r->headers_out, ""Date"", date );\n    }', 'explanation': 'This code block generates the Date header using ap_recent_rfc822_date with r->request_time as the approximation of the message generation time, which meets the RFC requirement that the Date header be the best available approximation of the date and time of message generation.'}}]",The function explicitly checks for the presence of a Date header (or conditions under which it should be set) and then invokes a function to generate the date based on r->request_time. This directly addresses the RFC specification that mandates a sender generate a Date header field with the best available approximation of the time of message generation.,success,
11906,create_response,"A sender MUST NOT apply the chunked transfer coding more than once to a message body (i.e., chunking an already chunked message is not allowed).",188,Does Not Match,[],"The provided function sets the Transfer-Encoding header to ""chunked"" when the r->chunked flag is true, but it does not include any logic to ensure that chunked transfer coding is applied only once. There is no check to see if the Transfer-Encoding header already contains the ""chunked"" value, nor any mechanism to prevent merging it repeatedly. Therefore, the function does not visibly enforce the RFC requirement that a sender MUST NOT apply the chunked transfer coding more than once to a message body.",success,
11906,create_response,An origin server MAY generate a Server header field in its responses.,89,Fully Matches,"[{'A1': {'code': 'if (r->proxyreq == PROXYREQ_NONE\n        || !apr_table_get(r->headers_out, ""Server"")) {\n        const char *us = ap_get_server_banner();\n        if (us && *us) {\n            apr_table_setn(r->headers_out, ""Server"", us);\n        }\n    }', 'explanation': 'This code block implements the action of generating a Server header. It checks if the request is not a proxy request or if the Server header is not already present, retrieves the server banner (i.e., the server information) using ap_get_server_banner(), and then sets the Server header accordingly. This directly addresses the RFC specification regarding the optional generation of the Server header field.'}}]","The function 'create_response' includes logic that conditionally generates the Server header field in the HTTP response. The identified code segment clearly retrieves the server's banner and sets the Server header when appropriate, which is in line with the RFC specification stating that an origin server MAY generate a Server header field. The implementation is done entirely within the function, thereby fully matching the specified constraint.",success,
11907,parse_header,"A recipient of ""message/http"" data MUST replace any obsolete line folding with one or more SP characters when the message is consumed.",213,Fully Matches,"[{'C1': {'code': 'if (line[0] == \' \' || line[0] == \'\\t\') {\n    while (line[0] == \' \' || line[0] == \'\\t\') {\n        ++line;\n    }\n    plast = apr_array_pop(parser->hlines);\n    if (plast == NULL) {\n        return APR_EINVAL;\n    }\n    hline = apr_psprintf(parser->pool, ""%s %s"", *plast, line);\n}', 'explanation': 'This code checks if the line starts with a space or tab (indicating obsolete line folding), strips the leading whitespace, and then concatenates it to the previous header using a space. This directly implements the RFC requirement to replace any obsolete line folding with one or more SP characters.'}}]","The function detects continuation lines (those beginning with space or tab) and replaces the obsolete line folding by concatenating the previous header with the current line using a single space, which aligns with the RFC specification that mandates replacing obsolete line folding with SP characters. Hence, the function fully meets the specified condition.",success,
11907,parse_header,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': ""if (line[0] == ' ' || line[0] == '\\t') {\n    /* continuation line from the header before this */\n    while (line[0] == ' ' || line[0] == '\\t') {\n        ++line;\n    }\n    ..."", 'explanation': 'This segment checks for a line beginning with whitespace (BWS) and then iteratively skips over it. This removal of bad whitespace on header continuation lines adheres to the specification that BWS may be removed before processing.'}}]","The RFC specifies that any content defined as BWS (bad whitespace) may be removed prior to interpretation. In the provided function, the code inspects if the header line begins with a space or tab and, if so, enters a loop to skip (i.e., remove) these whitespace characters before concatenating with the previous header line. This logic clearly implements the requirement for removing BWS, and since the only spec-related behavior provided is the handling of BWS, the function fully matches the RFC spec constraint.",success,
11907,parse_header,"A server that receives an obs-fold in a request message that is not within a ""message/http"" container MUST either reject the message by sending a 400 (Bad Request), preferably with a representation explaining that obsolete line folding is unacceptable, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.",186,Fully Matches,"[{'A1': {'code': 'if (line[0] == \' \' || line[0] == \'\\t\') {\n    /* continuation line from the header before this */\n    while (line[0] == \' \' || line[0] == \'\\t\') {\n        ++line;\n    }\n\n    plast = apr_array_pop(parser->hlines);\n    if (plast == NULL) {\n        /* not well formed */\n        return APR_EINVAL;\n    }\n    hline = apr_psprintf(parser->pool, ""%s %s"", *plast, line);\n}', 'explanation': 'The function examines if a header line is an obs-fold by checking if it begins with a space or tab. It then removes the leading whitespace and concatenates the continuation with the previous header value using a single SP inserted between them. This behavior directly implements the replacement action mandated by the RFC for obs-fold by replacing each fold with one or more SP octets. Additionally, if a continuation line is received without an existing header (i.e., apr_array_pop returns NULL), the function returns an error, effectively rejecting the malformed message.'}}]","The provided function detects header lines starting with whitespace (indicating an obs-fold) and processes them by stripping the whitespace and joining with the previous header using a single space. This directly corresponds to the RFC requirement to replace each received obs-fold with one or more SP octets. In the scenario where there is no prior header for a continuation (indicating malformed input), the function returns an error, which is consistent with the alternative of rejecting the message. Thus, within the confines of this function's logic, the code fully implements the specified RFC behavior as required.",success,
11907,parse_header,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,"[{'C1': {'code': ""if (line[0] == ' ' || line[0] == '\\t') {\n    while (line[0] == ' ' || line[0] == '\\t') {\n        ++line;\n    }\n    ...\n}"", 'explanation': 'The function checks if the header line starts with a space or tab and then skips (removes) that leading bad whitespace before processing the header line. This matches the requirement to remove bad whitespace from continuation lines.'}}]","The provided function partially addresses the RFC specification by explicitly removing leading whitespace from lines that are continuations (i.e., lines beginning with a space or tab). However, for new header lines it simply duplicates the line without any additional whitespace normalization, and the RFC may require additional handling of optional whitespace (such as collapsing OWS/RWS to a single space) in some contexts. Thus, while the code implements removal of bad whitespace in one scenario (C1), it does not fully cover all aspects of the RFC requirement.",success,
11907,parse_header,A sender SHOULD generate RWS as a single SP.,6,Fully Matches,"[{'A1': {'code': 'while (line[0] == \' \' || line[0] == \'\\t\') { ++line; }  ...  hline = apr_psprintf(parser->pool, ""%s %s"", *plast, line);', 'explanation': 'The function detects header continuation lines that begin with linear whitespace and removes all such whitespace with a loop (thereby discarding extra SP or TAB characters). It then concatenates the previous header string with the continuation using a literal "" %s"" format string that inserts exactly one space. This implements the RFC requirement that RWS be generated as a single SP.'}}]","The code function processes header continuation lines by stripping off extra linear whitespace and concatenating the continuation with a preceding header value using an explicit single space. This logic directly enforces the RFC specification which states that a sender SHOULD generate RWS as a single SP. Thus, within this function, the relevant action (labeled A1) is fully implemented.",success,
11907,parse_header,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': ""if (line[0] == ' ' || line[0] == '\\t') {\n    while (line[0] == ' ' || line[0] == '\\t') {\n        ++line;\n    }\n    ..."", 'explanation': 'The code checks if a header line starts with whitespace (indicating a continuation) and then enters a loop to advance past all leading white space before appending it to the previous header. This behavior directly implements the RFC requirement to exclude such whitespace from the field value.'}}]","The function 'parse_header' inspects each header line to determine if it begins with SP or HTAB. In the case of a continuation line, the loop explicitly skips over the whitespace characters, thereby removing them before the field value is evaluated. This approach directly addresses the RFC mandate that any allowed whitespace in the header message must be removed prior to processing the field's value.",success,
11907,parse_header,Any content known to be defined as OWS or RWS MAY be replaced with a single SP before interpreting it or forwarding the message downstream.,7,Partially Matches,"[{'C1': {'code': 'if (line[0] == \' \' || line[0] == \'\\t\') {\n    while (line[0] == \' \' || line[0] == \'\\t\') {\n        ++line;\n    }\n    plast = apr_array_pop(parser->hlines);\n    if (plast == NULL) {\n        return APR_EINVAL;\n    }\n    hline = apr_psprintf(parser->pool, ""%s %s"", *plast, line);\n}', 'explanation': 'The code detects if a header line starts with whitespace (space or tab) and, by looping to skip all leading spaces/tabs and then concatenating with a preceding header line via sprintf inserting a single space, it effectively replaces a block of OWS/RWS with a single SP. This implements the specification that suggests any content defined as OWS or RWS may be replaced with a single SP before processing.'}}]","The function clearly addresses the whitespace normalization for header continuation lines by removing multiple whitespace characters at the beginning and inserting a single space in their place. This corresponds to the RFC specification regarding the treatment of OWS and RWS. However, since the RFC contains several requirements and nuances (including BWS handling, which is not addressed in this function), the implementation within this function only covers the relevant whitespace replacement for header continuations. Therefore, the function partially matches the spec constraints.",success,
11908,get_line,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': ""status = apr_brigade_split_line(parser->tmp, bb, APR_BLOCK_READ, len);\n...\nif (status == APR_SUCCESS) {\n    --len;\n    status = apr_brigade_flatten(parser->tmp, line, &len);\n    if (status == APR_SUCCESS) {\n        /* we assume a non-0 containing line and remove trailing crlf. */\n        line[len] = '\\0';\n        if (len >= 2 && !strcmp(H2_CRLF, line + len - 2)) {\n            len -= 2;\n            line[len] = '\\0';\n            ...\n        }\n        else {\n            ...\n        }\n    }\n}"", 'explanation': 'This segment shows that the function defensively reads a line from the input, checking for proper termination (a CRLF sequence) and handling incomplete lines. It implements a defensive parsing approach with only a marginal expectation on conformance.'}}, {'A1': {'code': '...\nif ((status != APR_SUCCESS) || (brigade_length > (apr_off_t)len)) {\n    ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, parser->c, APLOGNO(10257)\n                  ""h2_c2(%s): read response, line too long"",\n                  parser->id);\n    return APR_ENOSPC;\n}\n...', 'explanation': 'This code checks that the buffered data does not exceed the available space (buffer size), thereby ensuring that the protocol element fits within a reasonable limit. It is a defensive measure against overly long lines.'}}]","The function attempts to implement defensive parsing of a protocol element by reading a line from the input with a fixed-length buffer, checking for proper CRLF termination, and handling the case where the line is incomplete or too long. This corresponds to the spec's recommendation to parse defensively with only marginal expectations regarding format or size. However, the function does not attempt to fully validate conformance to an ABNF grammar and its approach to buffer sizing is partly dependent on external limits (e.g., HUGE_STRING_LEN noted in comments). As a result, while the function addresses aspects of the spec defensively, it only partially meets all of the intended constraints solely within its own logic.",success,
11908,get_line,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'if (status == APR_SUCCESS) {\n    --len;\n    status = apr_brigade_flatten(parser->tmp, line, &len);\n    if (status == APR_SUCCESS) {\n        /* we assume a non-0 containing line and remove trailing crlf. */\n        line[len] = \'\\0\';\n        if (len >= 2 && !strcmp(H2_CRLF, line + len - 2)) {\n            len -= 2;\n            line[len] = \'\\0\';\n            apr_brigade_cleanup(parser->tmp);\n            ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, parser->c,\n                          ""h2_c2(%s): read response line: %s"",\n                          parser->id, line);\n        }\n        else {\n            /* Incomplete line handling */\n            ...\n            return APR_EAGAIN;\n        }\n    }\n}', 'explanation': 'The function examines the received line and, when the expected CRLF is not present (or the line appears incomplete), it takes steps to recover by preserving the current buffer state and returning APR_EAGAIN so that additional data can be read later. This partially implements the specification’s allowance for recovery from an invalid or incomplete construct, as it attempts to recover a usable protocol element.'}}]","The code function shows an attempt to recover from incomplete or partially invalid input by checking for the CRLF terminator and, if absent, preserving the partial data and signaling that more data is needed via APR_EAGAIN. This addresses the RFC statement that a recipient MAY attempt to recover a usable protocol element from an invalid construct. However, it leaves some aspects unaddressed (for example, how to handle the case of LF without CR, as noted in the comment), and thus only partially fulfills the specification’s intended error recovery strategy.",success,
11909,make_table,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Partially Matches,"[{'C1': {'code': ""while (*sep == ' ' || *sep == '\\t') {\n    ++sep;\n}"", 'explanation': 'This loop removes any whitespace characters (space or tab) immediately following the colon, which is in line with the RFC requirement to remove BWS before processing the header value.'}}]","The function makes a visible attempt to address the RFC's requirement regarding the removal of bad whitespace (BWS) by explicitly skipping over spaces and tabs after extracting the header key. However, it only covers the BWS removal aspect and does not address other parts of the specification. Thus, while it does implement one key condition (C1), it only partially matches the overall specification.",success,
11909,make_table,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': ""while (*sep == ' ' || *sep == '\\t') { ++sep; }"", 'explanation': ""This code snippet iterates over and removes any whitespace (spaces or tabs) following the header field separator (':'). It directly implements the requirement to parse for and remove bad whitespace before processing the header value, as mandated by the RFC.""}}]",The function processes each header line by first splitting it at the colon and then using a loop to skip over any spaces or tabs following the colon. This removal of whitespace directly addresses the RFC specification that a recipient MUST parse for any bad whitespace and remove it before interpreting the protocol element.,success,
11909,make_table,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'A1': {'code': ""while (*sep == ' ' || *sep == '\\t') {\n    ++sep;\n}"", 'explanation': 'This loop explicitly trims any leading spaces or horizontal tabs from the header field value right after the colon separator, thereby ensuring that no whitespace remains when evaluating the field value in accordance with the HTTP RFC specification.'}}]","The function parses header lines by splitting them at the colon and then uses a loop to remove any whitespace characters (spaces or tabs) from the beginning of the header value. This directly implements the requirement specified in the RFC—that any allowed whitespace in a message be excluded prior to evaluating the field value. As this logic is wholly contained within the function, it fully meets the relevant spec constraint.",success,
11910,pass_response,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function 'pass_response' processes and forwards response headers by creating a header bucket, inserting it into an APR brigade, and then passing the brigade to the next filter. It does not include any logic to verify or enforce that the protocol elements (such as headers) generated are permitted only for the sender’s role. In other words, there is no visible check within this function that prevents the generation of protocol elements or syntax alternatives which should only be produced by participants in another role. Therefore, the function does not address the specified HTTP RFC constraint.",success,
11911,parse_status,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'int sindex = (apr_date_checkmask(line, ""HTTP/#.# ###*"")? 9 :\n                  (apr_date_checkmask(line, ""HTTP/# ###*"")? 7 : 0));\n    if (sindex > 0) {\n        ...\n    } else {\n        ap_log_cerror(...);\n        return APR_EINVAL;\n    }', 'explanation': 'The code checks if the input line matches one of two specific HTTP status line patterns using apr_date_checkmask, which is an attempt at defensive parsing. It then conditionally parses the status code or logs an error if the check fails. This addresses the spec’s recommendation to parse defensively when the protocol element may only marginally conform to the expected format.'}}]","The function demonstrates defensive parsing by attempting to match the received status line against two expected patterns before extracting the status code. However, it does not incorporate additional safeguards such as verifying that the input buffer is of a reasonable size, even though the RFC suggests being cautious about buffer sizes. Thus, while it partially implements the RFC requirement (specifically for defensive parsing), it does not fully cover all aspects of the recommended defensive approach.",success,
11911,parse_status,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'int sindex = (apr_date_checkmask(line, ""HTTP/#.# ###*"")? 9 :\n                  (apr_date_checkmask(line, ""HTTP/# ###*"")? 7 : 0));\nif (sindex > 0) { ... }', 'explanation': 'The function checks the input line against two HTTP status line formats, thus attempting to recover a usable protocol element when the line matches one of the expected patterns.'}}, {'A1': {'code': 'parser->http_status = atoi(&line[sindex]);', 'explanation': 'By isolating the section of the string containing the numeric status code and converting it to an integer, the function directly implements the interpretation of the protocol element as described by the specification.'}}]","The code function inspects the status line from an HTTP response using two pattern checks to determine if the format is valid. When one of the expected formats is found, it extracts and converts the status code, thereby recovering a usable protocol element as allowed by the RFC. However, if the input does not match either format, the function logs an error and fails instead of providing a more flexible recovery strategy for invalid constructs. As such, while it implements parts of the spec (checking and recovering a valid status line), it does not fully embrace the broader error recovery flexibility detailed in the RFC, leading to a partially matching implementation.",success,
11914,h2_c2_filter_response_out,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function does not contain explicit logic that validates or enforces that the generated protocol elements conform to the ABNF grammar as required by the specification. Although it creates and inserts response headers via the create_response and h2_bucket_headers_create calls, there is no visible check that these headers, or any other protocol elements generated by this function, strictly match the grammar. The function mainly handles error buckets, EOS/EOR processing, and filter removal, but it does not implement any logic that verifies the conformance of protocol elements to the ABNF rules, and thus does not fully address the constraint from the spec.",success,
11914,h2_c2_filter_response_out,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,[],"The RFC requirement directs that within a given message the sender must avoid generating protocol elements or syntax alternatives that are reserved for another role. In the code, there is logic that conditionally creates and inserts a response header bucket (via create_response and subsequent insertion into the brigade) only when no final response has been sent, and it removes the filter when a terminal state (EOS/EOR/EOC) is encountered. This shows an attempt to control when and how protocol elements are generated. However, the function does not explicitly enforce or check that the generated protocol elements fully conform to the role restrictions defined by the RFC. In other words, while the function “tries” to gate the insertion of response elements based on connection state, it does not clearly verify (or document) that its generated elements are not those exclusively reserved for a different role. Thus, only part of the intended constraint is visibly handled within this function’s code, leading to a partial match of the spec.",success,
11915,make_chunk,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Error,[],'str' object has no attribute 'keys',failed,'str' object has no attribute 'keys'
11915,make_chunk,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,36,Fully Matches,"[{'C1': {'code': 'len = (apr_size_t)apr_snprintf(buffer, H2_ALEN(buffer), ""%', '\r\n"");\n    b = apr_bucket_heap_create(buffer, len, NULL, bb->bucket_alloc);\n    \n    b = apr_bucket_immortal_create(""\r\n"", 2, bb->bucket_alloc);   \n    if (tail) {\n        APR_BUCKET_INSERT_BEFORE(tail, b);\n    }\n    else {\n        APR_BRIGADE_INSERT_TAIL(bb, b);\n    }': '', 'explanation': 'The function constructs a chunk header by appending ""\\r\\n"" immediately after the chunk size and later adds an extra ""\\r\\n"" as a trailer. This ensures that only CRLF sequences are used for line breaks, directly fulfilling the RFC requirement.'}}]","The RFC mandates that only CRLF should be used to represent line breaks between body parts. Within the function, the use of ""\r\n"" in the chunk header (via apr_snprintf) and again in the bucket creation for the chunk trailer shows that the function itself implements this aspect of the spec. Therefore, the code function fully matches the specific HTTP RFC condition regarding CRLF usage.",success,
11916,ser_header,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function 'ser_header' simply formats and writes a header line using a provided name and value, without any logic to determine if the header is allowed for the sender's role or if it conforms to the role-specific grammar restrictions as required by the specification. There is no check or condition within this function that ensures it does not generate protocol elements or syntax alternatives that are only allowed for participants in other roles, nor is there any logic enforcing or verifying the messaging syntax per the HTTP RFC requirement. Hence, the function does not visibly address any of the spec constraints.",success,
11917,read_and_chunk,A recipient that removes the chunked coding from a message MAY selectively retain or discard the received trailer fields.,205,Fully Matches,"[{'C1': {'code': 'if (H2_BUCKET_IS_HEADERS(b)) {\n    h2_headers *headers = h2_bucket_headers_get(b);\n    ...\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                  ""h2_c2(%s-%d): receiving trailers"",\n                  conn_ctx->id, conn_ctx->stream_id);\n    tmp = apr_brigade_split_ex(fctx->bbchunk, b, NULL);\n    if (!apr_is_empty_table(headers->headers)) {\n        status = apr_brigade_puts(fctx->bbchunk, NULL, NULL, ""0\\r\\n"");\n        apr_table_do(ser_header, fctx->bbchunk, headers->headers, NULL);\n        status = apr_brigade_puts(fctx->bbchunk, NULL, NULL, ""\\r\\n"");\n    }\n    else {\n        status = apr_brigade_puts(fctx->bbchunk, NULL, NULL, ""0\\r\\n\\r\\n"");\n    }\n    ...\n}', 'explanation': 'This segment detects when a trailer (headers bucket) is received in the chunked message. It processes the trailer section by splitting the brigade and appending the correct chunk terminators, which addresses the condition that a recipient MAY selectively retain or discard trailer fields.'}}, {'A1': {'code': 'r->trailers_in = apr_table_clone(r->pool, headers->headers);', 'explanation': 'Here the function retains the received trailer fields separately by cloning them into r->trailers_in. This implements the action that a recipient that retains trailer fields must store/forward them separately from the received header fields.'}}]",The function 'read_and_chunk' visibly implements the specified RFC behavior by handling trailer fields when chunked coding is removed. It selectively processes trailer parts by detecting a headers bucket (as seen in the H2_BUCKET_IS_HEADERS check) and then either forms the proper chunk ending or clones the trailer headers to 'r->trailers_in'. Both behaviors directly meet the conditions and actions described in the spec context regarding trailer field handling.,success,
11917,read_and_chunk,"Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",308,Does Not Match,[],"The provided function does not contain any logic that checks or enforces the constraint regarding the prohibition of transfer coding parameters named ""q"". The spec requirement focuses on forbidding the registration of such parameters to avoid ambiguities, but the function solely handles reading a brigade, chunking data, and processing buckets (including headers and EOS). There is no code segment within this function that inspects, validates, or restricts parameters named ""q"". Thus, in isolation, this function does not address any of the spec constraints.",success,
11917,read_and_chunk,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The RFC requires that a recipient must only merge trailer fields into a header section if it understands the corresponding header field definitions and those definitions allow for safe merging. In the provided function, while trailer fields are detected (e.g., with H2_BUCKET_IS_HEADERS) and then processed by cloning headers into r->trailers_in and appending chunk boundaries, there is no conditional logic verifying that the header fields being merged are defined to allow such merging. The function does not check or enforce that the trailer fields may be safely merged per the RFC’s requirement. As such, no part of the function’s logic satisfies the spec’s mandate.",success,
11918,h2_c2_filter_request_in,A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance.,187,Partially Matches,"[{'C1': {'code': 'if (conn_ctx->input_chunked) {\n    if ((status = read_and_chunk(f, conn_ctx, block)) != APR_SUCCESS) {\n        return status;\n    }\n    ...\n}', 'explanation': 'The spec requires that a recipient MUST be able to parse the chunked transfer coding. In the code, when input is identified as chunked (conn_ctx->input_chunked is true), it calls read_and_chunk() to simulate chunked encoding. This indicates an attempt to comply with the RFC requirement, although the actual parsing logic is delegated to read_and_chunk rather than implemented inline.'}}, {'A1': {'code': 'for (b = APR_BRIGADE_FIRST(bb);\n     b != APR_BRIGADE_SENTINEL(bb);\n     b = next) {\n    next = APR_BUCKET_NEXT(b);\n    if (H2_BUCKET_IS_HEADERS(b)) {\n        h2_headers *headers = h2_bucket_headers_get(b);\n        ...\n        r->trailers_in = headers->headers;\n        if (conf && conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE) {\n            r->headers_in = apr_table_overlay(r->pool, r->headers_in, r->trailers_in);\n        }\n        APR_BUCKET_REMOVE(b);\n        apr_bucket_destroy(b);\n        ap_remove_input_filter(f);\n        ...\n        break;\n    }\n}', 'explanation': 'The code inspects the bucket brigade for header buckets (representing trailer fields) and processes them by overlaying them into the request headers. This handling of trailers is in line with the RFC’s requirements regarding chunked transfer codings when trailers are present.'}}]","The function makes a visible attempt to address aspects of the RFC. It distinguishes between non‐chunked and chunked inputs. For chunked inputs, it calls read_and_chunk() to simulate the necessary processing for chunked transfer coding so that the standard HTTP input filter accepts the data. It also handles trailer headers by detecting header buckets in the brigade and processing them accordingly. However, the core chunked parsing is delegated to another function (read_and_chunk), meaning the full logic is not contained solely within this function. Therefore, the implementation only partially meets the RFC requirements on its own.",success,
11918,h2_c2_filter_request_in,A recipient that removes the chunked coding from a message MAY selectively retain or discard the received trailer fields.,205,Fully Matches,"[{'C1': {'code': 'if (H2_BUCKET_IS_HEADERS(b)) {\n    h2_headers *headers = h2_bucket_headers_get(b);\n    ...\n    ap_log_rerror(..., ""h2_c2(%s-%d): receiving trailers"", ...);\n    r->trailers_in = headers->headers;\n    ...\n}', 'explanation': 'This segment inspects the bucket for trailer headers and assigns them to r->trailers_in, fulfilling the requirement to separately retain trailer fields when removing chunked coding.'}}, {'A1': {'code': 'if (conf && conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE) {\n    r->headers_in = apr_table_overlay(r->pool, r->headers_in, r->trailers_in);\n}', 'explanation': 'This branch conditionally merges the trailer headers into the main headers if permitted by configuration, which aligns with the requirement that a recipient MUST either store/forward trailer fields separately or merge them when allowed.'}}]","The function checks for trailer headers in the incoming bucket brigade and, upon detecting them, stores them separately in r->trailers_in. Additionally, via a configuration check, it conditionally merges the trailer headers into the request headers (r->headers_in) if allowed. This implementation directly reflects the RFC specification regarding the management of trailer fields when removing chunked coding.",success,
11918,h2_c2_filter_request_in,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (!conn_ctx->input_chunked) {\n    status = ap_get_brigade(f->next, bb, mode, block, readbytes);\n    /* pipe data through, just take care of trailers */\n    for (b = APR_BRIGADE_FIRST(bb);\n         b != APR_BRIGADE_SENTINEL(bb); b = next) {\n        next = APR_BUCKET_NEXT(b);\n        if (H2_BUCKET_IS_HEADERS(b)) {\n            h2_headers *headers = h2_bucket_headers_get(b);\n            ...\n            r->trailers_in = headers->headers;\n            if (conf && conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE) {\n                r->headers_in = apr_table_overlay(r->pool, r->headers_in,\n                                                  r->trailers_in);\n            }\n            APR_BUCKET_REMOVE(b);\n            apr_bucket_destroy(b);\n            ap_remove_input_filter(f);\n            ...\n            break;\n        }\n    }\n    return status;\n}', 'explanation': 'This segment addresses the RFC requirement to interpret received protocol elements (in this case, trailer headers). It shows that the filter examines incoming buckets, identifies header trailers, and processes them, which is in line with the semantics required by the specification.'}}, {'A1': {'code': 'if (mode == AP_MODE_EXHAUSTIVE) {\n    APR_BRIGADE_CONCAT(bb, fctx->bbchunk);\n}\nelse if (mode == AP_MODE_READBYTES) {\n    status = h2_brigade_concat_length(bb, fctx->bbchunk, readbytes);\n}\nelse if (mode == AP_MODE_SPECULATIVE) {\n    status = h2_brigade_copy_length(bb, fctx->bbchunk, readbytes);\n}\nelse if (mode == AP_MODE_GETLINE) {\n    status = apr_brigade_split_line(bb, fctx->bbchunk, block, HUGE_STRING_LEN);\n    ...\n}\nelse {\n    ap_log_cerror(APLOG_MARK, APLOG_ERR, APR_ENOTIMPL, f->c,\n                  APLOGNO(02942)\n                  ""h2_c2, unsupported READ mode %d"", mode);\n    status = APR_ENOTIMPL;\n}', 'explanation': 'This portion of the code demonstrates handling of different input reading modes, which contributes to the goal of recovering and correctly interpreting received protocol data. It shows some recovery strategies (for example, splitting a line in GETLINE mode) that align with the RFC suggestion to attempt recovery from invalid constructs.'}}]","The function implements logic to process the received protocol element by examining buckets for trailer headers, optionally merging them with the main headers, and handling different input modes. These behaviors are in line with the part of the RFC that requires recipients to interpret protocol elements based on defined semantics. However, the code does not include any mechanism to determine whether the sender has incorrectly implemented the protocol (e.g., through configuration or experience), a nuance mentioned in the RFC. As such, while parts of the specification are implemented visibly within this function, the complete behavior as required by the RFC is not fully addressed, resulting in a 'Partially Matches' outcome.",success,
11918,h2_c2_filter_request_in,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The HTTP spec requires that a sender must not generate protocol elements which do not adhere to the specified ABNF grammar (C1). While the function processes input data and even simulates chunked encoding (possibly as part of proper protocol element generation), there is no explicit logic within the function that validates or enforces that the generated protocol elements conform to the ABNF grammar. Instead, the function primarily delegates handling to other routines (such as read_and_chunk) and passes buckets through, leaving protocol element validation implicitly to lower‐level routines or configurations. Thus, within the function_body itself there is no visible implementation that ensures compliance with the ABNF grammar as required by the spec, and the function does not explicitly prevent generation of nonconformant protocol elements.",success,
11918,h2_c2_filter_request_in,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function h2_c2_filter_request_in() processes incoming request data, handles trailer headers, and simulates chunked encoding. However, there is no visible logic within the function that checks or enforces the requirement that a sender must not generate protocol elements or syntax alternatives not allowed for its role. In other words, while the function manages incoming protocol elements (such as processing trailer headers), it does not implement any checks to prevent generating elements that are only permitted from other roles. Therefore, the function does not visibly address the RFC requirement stated in the specification by itself.",success,
11918,h2_c2_filter_request_in,A recipient that retains a received trailer field MUST either store/ forward the trailer field separately from the received header fields or merge the received trailer field into the header section.,206,Fully Matches,"[{'C1': {'code': 'r->trailers_in = headers->headers;', 'explanation': 'The function extracts the trailer headers from the headers bucket and stores them separately in r->trailers_in, fulfilling the requirement to retain the trailer field separately from the received header fields.'}}, {'A1': {'code': 'if (conf && conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE) {\n    r->headers_in = apr_table_overlay(r->pool, r->headers_in, r->trailers_in);\n}', 'explanation': 'When configured (conf->merge_trailers enabled), the function merges the trailer fields into the main header section, thereby meeting the alternative merging requirement as specified.'}}]","The function_body checks for a bucket marked as headers (used as trailers) and assigns its contents to r->trailers_in, thereby retaining the trailer field separately. Additionally, it conditionally merges these trailer headers into r->headers_in based on configuration, which fully complies with the RFC requirement that a recipient that retains a trailer field MUST either store/forward it separately or merge it into the header section.",success,
11918,h2_c2_filter_request_in,"At the end of a message, a recipient MAY treat the set of received trailer fields as a data structure of name/value pairs, similar to (but separate from) the header fields.",14,Fully Matches,"[{'C1': {'code': 'r->trailers_in = headers->headers;', 'explanation': ""The function detects a bucket that contains trailer fields (using H2_BUCKET_IS_HEADERS) and assigns these fields to the request's trailers_in member, thereby treating them as a separate set of name/value pairs as specified in the RFC.""}}, {'A1': {'code': 'if (conf && conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE) {\n                    r->headers_in = apr_table_overlay(r->pool, r->headers_in, r->trailers_in);\n                }', 'explanation': 'When configured (merge_trailers enabled), the function merges the trailer fields with the header fields via an overlay, which aligns with the optional processing directive in the RFC for additional handling of trailer fields.'}}]","The function explicitly checks for and retrieves trailer fields from the input bucket and assigns them to a separate data structure (r->trailers_in). Furthermore, it conditionally merges these trailer fields with the regular header fields when the configuration permits. These actions directly implement the RFC requirement that trailer fields be handled as a distinct set of name/value pairs, thus fully meeting the specified constraints.",success,
11919,h2_c2_filter_trailers_out,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The RFC requires that a recipient must not merge trailer fields into the header section unless it understands the corresponding header field definitions and if those definitions explicitly permit and define safe merge behavior. In the provided function, while trailer fields are detected and merged into a new header bucket at the end of the message (as seen in the loop detecting EOS/EOR buckets and the subsequent cloning and header creation), there is no logic implemented in the function to check whether the trailer field definitions are understood or explicitly permitted to be merged. Without such a safety check or validation, the function does not fully implement the RFC requirement by itself.",success,
11996,h2_protocol_propose,"A server MAY choose to ignore the order of preference indicated by the client and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.",258,Partially Matches,"[{'C1': {'code': 'if (r) {\n    const char *p;\n\n    if (!h2_c1_can_upgrade(r)) {\n        return DECLINED;\n    }\n     \n    p = apr_table_get(r->headers_in, ""HTTP2-Settings"");\n    if (!p) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03085)\n                      ""upgrade without HTTP2-Settings declined"");\n        return DECLINED;\n    }\n    \n    p = apr_table_get(r->headers_in, ""Connection"");\n    if (!ap_find_token(r->pool, p, ""http2-settings"")) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03086)\n                      ""upgrade without HTTP2-Settings declined"");\n        return DECLINED;\n    }\n\n    /* We also allow switching only for requests that have no body. */\n    p = apr_table_get(r->headers_in, ""Content-Length"");\n    if ((p && strcmp(p, ""0""))\n        || (!p && apr_table_get(r->headers_in, ""Transfer-Encoding""))) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03087)\n                      ""upgrade with body declined"");\n        return DECLINED;\n    }\n}', 'explanation': 'This segment enforces that the request contains the required upgrade indication (HTTP2-Settings header and token in the Connection header) and that it is eligible for an upgrade (i.e. no request body), which is a key requirement of the spec.'}}, {'A1': {'code': 'while (*protos) {\n    /* Add all protocols we know (tls or clear) and that\n     * are part of the offerings (if there have been any).\n     */\n    if (!offers || ap_array_str_contains(offers, *protos)) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, c,\n                      ""proposing protocol \'%s\'"", *protos);\n        APR_ARRAY_PUSH(proposals, const char*) = *protos;\n        proposed = 1;\n    }\n    ++protos;\n}', 'explanation': 'This loop proposes protocols based on an internally defined order (ignoring any client‐imposed ordering) by checking against the offered protocol list. This matches the spec’s permission for a server to ignore the client’s order of preference.'}}]","The function implements some of the key parts of the RFC in that it verifies the proper upgrade headers (HTTP2-Settings and Connection token) and ensures that the connection and request qualify for a protocol switch. It further selects protocols from a predetermined list – effectively ignoring the client’s order of preference – which is allowed by the specification. However, it does not, by itself, handle other aspects of the RFC such as constructing or sending the Upgrade header field in the response or ordering protocols in layer-ascending order. Thus, while it addresses important conditions, it does so only partially relative to the full spec requirements.",success,
12007,h2_c2_filter_in,"Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",308,Does Not Match,[],"The provided code function handles input data from an HTTP connection stream (e.g., reading bucket brigades, handling HTTP upgrades, logging, and error management) and does not implement any logic related to the RFC requirement regarding the prohibition or handling of a parameter named ""q"" in transfer codings. There is no visible code segment in the function that examines parameters, enforces restrictions, or otherwise processes transfer coding parameters, particularly the ""q"" parameter, as specified in the RFC. Therefore, the function does not address any of the labeled conditions (e.g., C1) or actions (e.g., A1) from the spec constraints.",success,
12011,check_early_hints,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (!r->expecting_100 && ((push_list && push_list->nelts > 0) ||\n         (early_headers && !apr_is_empty_table(early_headers)))) {', 'explanation': 'This condition checks that early hints are sent only when the request is not already expecting a 100‐continue. In effect, it avoids sending protocol elements (early hints) in messages where they may not be appropriate. This reflects an attempt at controlling which role-generated elements are added.'}}, {'A1': {'code': 'r->status = 103;\nr->status_line = ""103 Early Hints"";\nap_send_interim_response(r, 1);', 'explanation': ""This segment sets the response status to '103 Early Hints' and immediately sends an interim response. This directly implements sending the early hint protocol element in conformity with the RFC requirements.""}}]","The function 'check_early_hints' inspects the request and available early hint data (through push lists and extra headers) before sending a 103 Early Hints response. The check that avoids interfering with a 100 Continue expectation (C1) and the block that sets and sends a 103 response (A1) demonstrate an attempt to generate protocol elements in roles appropriate to the sender. However, while it partially enforces role‐related constraints (by not sending early hints when a 100-continue is expected), it does not perform a comprehensive verification of all role-specific restrictions. Thus, the function only partially matches the RFC constraint as expressed in the specification.",success,
12011,check_early_hints,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The function 'check_early_hints' implements logic to conditionally send a 103 Early Hints response by adding push-related Link headers and early headers. However, it does not include any explicit mechanism to verify that the protocol elements (such as header values or status lines) are produced in accordance with the ABNF grammar defined by the HTTP RFC. The function uses helper routines to add headers and send the response, but it does not perform any grammar validation to ensure that only valid protocol elements are generated. This means that the specific RFC requirement—a sender MUST NOT generate protocol elements that do not match the grammar—is not directly enforced within this function.",success,
12018,h2_c2_hook_post_read_request,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The provided function only sets up filters for processing requests, responses, and trailers by adding the ""H2_C2_TRAILERS_OUT"" filter, among others. It does not include any logic addressing the requirement specified in the RFC—that a recipient must not merge a trailer field into a header section unless it fully understands the header field definition and the safe merging process. There is no specific check or mechanism in this function that implements any condition (e.g., C1) or action (e.g., A1) related to safe trailer merging. Therefore, no part of the code function meets the labeled constraints from the specification.",success,
12097,h2_util_ignore_header,A sender MUST NOT send a connection option corresponding to a field that is intended for all recipients of the content.,252,Partially Matches,"[{'C1': {'code': 'return (H2_HD_MATCH_LIT_CS(""connection"", name)\n        || H2_HD_MATCH_LIT_CS(""proxy-connection"", name)\n        || H2_HD_MATCH_LIT_CS(""upgrade"", name)\n        || H2_HD_MATCH_LIT_CS(""keep-alive"", name)\n        || H2_HD_MATCH_LIT_CS(""transfer-encoding"", name));', 'explanation': ""This code explicitly filters out several connection‐specific headers as described in the RFC context (e.g. 'connection', 'proxy-connection', 'upgrade', etc.). This shows an attempt to prevent headers used as connection options from being forwarded. However, note that the RFC example mentions that options like 'Cache-Control' (a header intended for all recipients) should never be used as a connection option, which is not checked for here. Hence, while the function captures a subset of the relevant header filtering, it does not fully cover all the potential cases dictated by the RFC.""}}]","The function h2_util_ignore_header contains logic to ignore a hard-coded set of connection-specific header fields, which is in line with part of the RFC specification that a sender MUST NOT send a connection option corresponding to a field that is intended for all recipients. However, since the function only checks for a limited set of header names and does not address all possibilities like the explicit example of 'Cache-Control' mentioned in the RFC context, it results in a partial match.",success,
12097,h2_util_ignore_header,A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection.,25,Fully Matches,"[{'A1': {'code': '|| H2_HD_MATCH_LIT_CS(""upgrade"", name)', 'explanation': ""This segment checks if the header name is 'upgrade'. By returning true for this header, the function causes the Upgrade header to be ignored, which is in line with the RFC specification that a server may ignore a received Upgrade header field if it wishes to continue using the current protocol.""}}]","The function 'h2_util_ignore_header' explicitly tests for the 'upgrade' header among others and returns true when it is detected, which means that the header will not be forwarded. This behavior directly implements the RFC requirement allowing a server to ignore the Upgrade header. The logic is entirely contained within the function, meeting the spec constraint without relying on external dependencies.",success,
12101,h2_proxy_util_nghd_make_req,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function simply constructs a header structure by copying the required fields (such as :scheme, :authority, :path, and :method) from the provided request without any role validation or mechanism to ensure that the sender does not generate protocol elements or syntax alternatives that are only allowed for other roles. There is no logic within the function that distinguishes between allowed and disallowed protocol elements based on the sender’s role. Therefore, the function does not visibly meet the specified RFC constraint that prohibits generating role-specific protocol elements outside of the appropriate role.",success,
12107,h2_headers_add_h1,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Fully Matches,"[{'C1': {'code': 'else if (H2_HD_MATCH_LIT(""cookie"", name, nlen)) {\n    const char *existing = apr_table_get(headers, ""cookie"");\n    if (existing) {\n        char *nval;\n        /* Cookie header come separately in HTTP/2, but need\n         * to be merged by ""; "" (instead of default "", "")\n         */\n        hvalue = apr_pstrndup(pool, value, vlen);\n        nval = apr_psprintf(pool, ""%s; %s"", existing, hvalue);\n        apr_table_setn(headers, ""Cookie"", nval);\n        return APR_SUCCESS;\n    }\n}\nelse if (H2_HD_MATCH_LIT(""host"", name, nlen)) {\n    if (apr_table_get(headers, ""Host"")) {\n        return APR_SUCCESS; /* ignore duplicate */\n    }\n}\n...\nhname = apr_pstrndup(pool, name, nlen);\nhvalue = apr_pstrndup(pool, value, vlen);\nh2_proxy_util_camel_case_header(hname, nlen);\napr_table_mergen(headers, hname, hvalue);', 'explanation': ""The function prevents generating multiple header field lines by merging values when allowed and ignoring duplicates otherwise. For 'cookie', it specifically merges multiple cookie headers using a semicolon (in adherence with the RFC exception), for 'host' it ignores duplicate headers since merging is not allowed, and for all other headers, it uses apr_table_mergen to combine values (typically as a comma separated list). This logic directly follows the RFC requirement to not generate multiple field lines with the same name unless the header definition explicitly allows recombination.""}}]","The function explicitly implements the RFC's requirements regarding duplicate header fields by checking for special cases ('cookie' and 'host') and handling them accordingly. It merges cookie headers using a semicolon, ignores additional host headers, and merges other header values via apr_table_mergen. All core aspects of the RFC's constraint on not generating multiple field lines unless allowed are addressed directly within the function, fulfilling the spec constraints.",success,
12107,h2_headers_add_h1,"In any production that uses the list construct, a sender MUST NOT generate empty list elements.",236,Does Not Match,[],"The RFC spec requires that in any production using the list construct, a sender MUST NOT generate empty list elements. This function does not contain any logic that verifies or prevents the generation of empty list elements; instead, it primarily handles header merging and specific header treatment (such as for ""cookie"" and ""host""). No part of the function checks that list elements produced (for example, via apr_table_mergen or the semicolon-based cookie merging) are not empty. Therefore, the function does not visibly address the RFC constraint within its code.",success,
12112,h2_proxy_util_frame_print,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function primarily formats and prints data from an HTTP/2 frame structure. There is no logic in the function that validates whether the generated protocol elements match the ABNF grammar or ensures that elements specific to other roles are not generated. Therefore, the function does not address the spec constraint that 'a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.'",success,
12112,h2_proxy_util_frame_print,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function is solely responsible for printing a textual representation of various HTTP/2 frame types. It formats and outputs frame details based on the frame type. However, it does not contain any logic to enforce or inspect role-based restrictions or to prevent a sender from generating protocol elements that are only allowed for other roles. Thus, it does not address the constraint from the RFC specification, which requires that a sender must not generate protocol elements or syntax alternatives reserved for other roles within a given message.",success,
12126,map_link,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function performs string manipulation to construct a modified URI for a link header and logs the mapping process. However, it does not implement any explicit checks or validations to ensure that the generated protocol element strictly conforms to the ABNF grammar as prescribed by the RFC. There is no logic within function_body that verifies or enforces that the constructed URI matches the grammar, which is the core requirement of the spec constraint. Therefore, the function does not visibly address the condition that 'a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.'",success,
12126,map_link,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (need_len > sizeof(buffer)) {\n    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, ctx->r, APLOGNO(03482) \n                  ""link_reverse_map uri too long, skipped: %s"", ctx->s);\n    return;\n}', 'explanation': ""This segment checks whether the calculated needed length (based on the incoming protocol element) exceeds the allocated buffer size. Such a defensive check helps ensure that unexpected lengths (or malformed input) do not lead to buffer overruns, which is in line with the specification's emphasis on defensive parsing.""}}]","The function demonstrates defensive parsing by verifying that the length of the protocol element (link) does not exceed a reasonable buffer size before processing it further. This directly addresses part of the spec which advises defensive parsing with the expectation that the incoming element might not conform exactly to its ABNF grammar or expected length. However, the function does not include additional logic (for example, deeper validation against the grammar itself) that might be required for a full implementation of all defensive parsing measures described in the RFC specification. As a result, while the code visibly implements the check for excessive lengths (matching condition C1), it only partially covers the comprehensive defensive parsing requirements outlined in the spec.",success,
12172,h2_cconfig_get_priority,The type/subtype MAY be followed by semicolon-delimited parameters (Section 5.6.6) in the form of name/value pairs.,259,Partially Matches,"[{'C1': {'code': 'apr_ssize_t len = (apr_ssize_t)strcspn(content_type, ""; \\t"");', 'explanation': 'This line extracts the type/subtype part of the content_type string by stopping at the first semicolon (or whitespace), which addresses the aspect of the RFC that allows semicolon-delimited parameters to follow the type/subtype.'}}]","The function demonstrates an attempt to implement part of the RFC by stripping off any semicolon-delimited parameters from the media type string before using it to look up a priority. This behavior acknowledges that the media type may include parameters, addressing that portion of the specification. However, the function does not perform case-insensitive matching of the type/subtype tokens as required by the spec, nor does it process any parameters beyond simply cutting them off. Thus, while it meets some aspects of the RFC (namely extracting the base media type), it does not fully implement all the requirements, resulting in a 'Partially Matches' judgment.",success,
12177,h2_conf_set_max_worker_idle_limit,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'if (timeout <= 0) {\n    timeout = DEF_VAL;\n}', 'explanation': 'This code segment checks if the parsed timeout value is non-positive and recovers by assigning a default value (DEF_VAL). This behavior aligns with the RFC allowance to recover a usable protocol element from an invalid construct.'}}]","The function partially meets the RFC specification by attempting to recover a usable value when the timeout is non-positive (i.e. an invalid construct) by setting a default value. However, when the parsing itself fails (i.e., ap_timeout_parameter_parse returns an error), the function returns an error message, rather than recovering. Hence, while it implements some recovery logic (C1), it does not fully cover all aspects that might be expected by the RFC in handling all kinds of invalid constructs.",success,
12177,h2_conf_set_max_worker_idle_limit,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'apr_status_t rv = ap_timeout_parameter_parse(value, &timeout, ""s"");\nif (rv != APR_SUCCESS) {\n    return ""Invalid idle limit value"";\n}', 'explanation': 'The function defensively parses the input value using ap_timeout_parameter_parse and immediately handles parsing errors by returning an error message. This is aligned with the RFC recommendation to parse protocol elements defensively with marginal assumptions about their structure.'}}]","The provided function attempts to implement a part of the HTTP RFC guideline by performing a defensive parse of a configuration element. It checks whether the parsing succeeded and returns an error if not, which reflects the principle of not over-expecting the format of the input. However, the function does not explicitly verify properties such as buffer-size limitations, nor does it inspect the input against its full ABNF grammar; it relies on an external function (ap_timeout_parameter_parse) for parsing. Therefore, while it addresses the defensive parsing requirement (C1) to some extent, it only partially implements the overall RFC directive.",success,
12178,h2_conf_set_stream_max_mem_size,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Does Not Match,[],"The function simply converts the input string to an integer and checks if the value is at least 1024, which does not address the RFC requirement to defensively parse a protocol element with marginal expectations regarding its conformity to an ABNF grammar or its fitting within a reasonable buffer size. No logic within the function deals with parsing or validating protocol element structure as described in the spec constraints.",success,
12184,h2_conf_set_websockets,"Although protocol names are registered with a preferred case, recipients SHOULD use case-insensitive comparison when matching each protocol-name to supported protocols.",257,Does Not Match,[],"The provided function h2_conf_set_websockets is concerned with enabling or disabling HTTP/2 WebSockets based on a configuration value ('On' or 'Off'). Although it performs case-insensitive comparisons using strcasecmp—which in isolation is a technique called for by the RFC for matching protocol names—the function does not address any of the specific requirements detailed in the RFC specification regarding protocol name matching in Upgrade header fields. No logic is present to handle the list of protocol names, compare them with supported protocols, or take actions based on the order of preference, as required by the RFC. Consequently, the function does not implement the labeled conditions or actions (such as those implied by C1, A1, etc.) specified in the RFC context.",success,
12185,h2_conf_add_push_priority,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,[],"The RFC requires that a recipient should parse a received protocol element defensively - for example, by verifying conformance to an ABNF grammar and checking against a reasonable buffer size. In this function, there are basic defensive checks: it ensures that the MIME type (ctype) is provided, validates that the dependency parameter is one of the allowed values, and checks that the weight is above a minimal threshold. These checks demonstrate an attempt to validate input parameters and avoid misinterpretation of malformed input. However, the function does not fully implement a comprehensive defensive parsing mechanism in line with the RFC – it does not validate conformity to an ABNF grammar nor does it explicitly check for buffer size limitations, which are part of the broader defensive parsing requirements articulated by the RFC. As a consequence, while the function addresses some defensive aspects, it does not completely fulfill the specified RFC requirements on its own.",success,
12187,h2_conf_set_upgrade,"Although protocol names are registered with a preferred case, recipients SHOULD use case-insensitive comparison when matching each protocol-name to supported protocols.",257,Partially Matches,"[{'C1': {'code': 'if (!strcasecmp(value, ""On"")) {\n    CONFIG_CMD_SET(cmd, dirconf, H2_CONF_UPGRADE, 1);\n    return NULL;\n}\nelse if (!strcasecmp(value, ""Off"")) {\n    CONFIG_CMD_SET(cmd, dirconf, H2_CONF_UPGRADE, 0);\n    return NULL;\n}', 'explanation': ""This segment uses 'strcasecmp' for comparing the input value with 'On' and 'Off', ensuring a case-insensitive comparison. This aligns with the RFC requirement that protocol names should be matched in a case-insensitive manner.""}}]","The function focuses solely on handling configuration values 'On' and 'Off' using a case-insensitive comparison, which meets the requirement expressed in the RFC regarding case-insensitive matching (C1). However, it does not implement any additional logic related to processing protocol lists or enforcing the upgrade header protocol negotiation as described in the complete spec context. Therefore, while it partially addresses the specification by implementing case-insensitive checking, it does not fully implement all aspects of the RFC.",success,
12194,h2_conf_add_early_hint,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that a sender must not generate protocol elements or syntax alternatives reserved for other roles. The provided function only validates that the header name and value are not empty and conform to basic character rules. It does not include any logic to verify that the generated header elements are permitted for the sender’s role or to restrict syntax alternatives based on role. Therefore, this function does not address the RFC’s requirement regarding role-specific generation of protocol elements.",success,
12194,h2_conf_add_early_hint,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if(!name || !*name)\n  return ""Early Hint header name must not be empty"";', 'explanation': 'This check ensures that a header name is provided, which is part of a defensive approach.'}}, {'C2': {'code': 'if(!value)\n  return ""Early Hint header value must not be empty"";\nwhile (apr_isspace(*value))\n    ++value;\nif(!*value)\n  return ""Early Hint header value must not be empty/only space"";', 'explanation': 'This segment defends against empty or whitespace-only header values, matching a defensive parsing requirement.'}}, {'C3': {'code': 'if (*ap_scan_http_field_content(value))\n  return ""Early Hint header value contains invalid characters"";', 'explanation': 'This validation uses an HTTP field content scanner, ensuring the value conforms marginally to ABNF grammar rules.'}}]","The function implements several defensive checks—ensuring that header names and values are non-empty, trimming excessive whitespace, and verifying that the header value contains only valid characters—which address a defense-in-depth approach as suggested by the RFC. However, while it does validate the content as per ABNF expectations minimally, it does not enforce limits on the length (i.e., a check to ensure the element fits within a reasonable buffer) directly in this function. As a result, the function partially matches the RFC specification because some aspects (like buffer size validation) are not handled here.",success,
12194,h2_conf_add_early_hint,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (*ap_scan_http_field_content(value))\n    return ""Early Hint header value contains invalid characters"";', 'explanation': 'This segment validates the header value by checking that it contains only valid characters as allowed by HTTP grammar. It prevents generation of a malformed header value by using the helper function ap_scan_http_field_content.'}}]","The function performs several sanity checks: it ensures the header name is non-empty, trims whitespace, confirms the header value is not empty or just spaces, and validates the header value’s characters. This addresses part of the RFC requirement to only generate protocol elements conforming to the defined ABNF grammar. However, the function does not fully enforce the complete set of grammar rules for all protocol elements (for example, it only verifies non-emptiness for the header name without a complete grammar check), and it does not address other protocol elements that might require validation. Thus, the implementation only partially meets the specification constraints in this isolated function.",success,
12194,h2_conf_add_early_hint,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,[],"The target function attempts to remove bad whitespace by skipping leading whitespace characters (using the loop: while (apr_isspace(*value)) ++value;), which addresses part of the RFC requirement. However, the RFC specifies that a recipient MUST parse for all instances of such bad whitespace and remove them before interpreting the protocol element. The code only removes leading whitespace and does not handle other potential cases (such as trailing or embedded extra whitespace), so it does not fully implement the RFC's whitespace removal requirement.",success,
12194,h2_conf_add_early_hint,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Partially Matches,"[{'C1': {'code': 'while (apr_isspace(*value))\n    ++value;', 'explanation': 'This loop removes leading whitespace from the header value, which is an attempt to remove BWS (bad whitespace) before interpreting the protocol element as described in the spec.'}}]","The RFC specifies that any content defined as BWS may be removed before interpretation. The code does check for and skip over leading white space, which meets part of that requirement (namely, the removal of leading BWS). However, it only handles leading whitespace and does not attempt to remove any other portions of BWS (for example, trailing or interstitial whitespace) that might be present. Since the implementation only partially addresses the full potential scope of BWS as described by the spec, the function is judged to partially match the specification.",success,
12194,h2_conf_add_early_hint,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Partially Matches,"[{'C1': {'code': 'while (apr_isspace(*value))\n        ++value;', 'explanation': 'This code segment removes leading whitespace from the field value before evaluation. However, while the RFC specifies exclusion of both leading and trailing whitespace, the function only removes leading whitespace.'}}]","The function implements the removal of leading whitespace from the header value, which partially meets the spec requirement of excluding whitespace prior to evaluation. However, it does not remove trailing whitespace, and therefore does not fully satisfy the RFC's mandate that field values must not include any leading or trailing whitespace.",success,
12215,h2_c1_io_bb_log,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function h2_c1_io_bb_log only logs information about bucket brigade elements and does not contain any logic that enforces or checks that a sender does not generate protocol elements or syntax alternatives reserved for other roles. It does not implement any specific constraints (such as those labeled C1, A1, etc.) from the specification regarding role-based generation of protocol elements. All operations in the function are limited to formatting and logging, with no attempt to validate or restrict the generation of protocol elements as defined in the spec.",success,
12215,h2_c1_io_bb_log,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function h2_c1_io_bb_log primarily logs information about bucket brigades and their metadata, and does not contain any logic related to ensuring that generated protocol elements conform to the ABNF grammar as required by the RFC specification. There is no code within the function that validates or enforces the grammar rules, so it does not address the condition that a sender MUST NOT generate protocol elements that do not match the defined grammar.",success,
12230,h2_c1_read,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'A1': {'code': 'else if (APR_STATUS_IS_EAGAIN(rv)) {\n        /* Signal that we have exhausted the input momentarily.\n         * This might switch to polling the socket */\n        h2_session_dispatch_event(session, H2_SESSION_EV_INPUT_EXHAUSTED, 0, NULL);\n    }', 'explanation': ""This branch detects a temporary input exhaustion (EAGAIN) and dispatches an event instead of terminating the connection immediately. This behavior partially implements the spec's recommendation to allow the transport's flow control to resolve temporary overloads rather than closing the connection.""}}]","The function 'h2_c1_read' reads data from the connection and discriminates among different read outcomes. The handling of APR_STATUS_IS_EAGAIN indicates an attempt to avoid closing the connection when input is temporarily unavailable, which aligns partially with the spec's requirement for sustaining persistent connections via underlying flow-controlled conditions. However, no additional logic in this function explicitly maintains overall session persistence or broader connection management, so only part of the RFC recommendation is visibly addressed within this code segment.",success,
12231,ap_set_byterange,"A server MUST NOT generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses.",288,Fully Matches,"[{'C1': {'code': 'if (apr_table_get(r->headers_out, ""Content-Range"")) {\n    return 0;\n}', 'explanation': 'This check ensures that if a single range response (indicated by an existing Content-Range header) is already set, the function does not proceed with further processing that could lead to a multipart response. This directly addresses the RFC requirement that a server MUST NOT generate a multipart response to a request for a single range.'}}]","The function examines the incoming Range header and checks if a single range response is already in progress (by checking for a 'Content-Range' header) before performing any multipart processing. By returning early in that case, it ensures that it does not inadvertently generate a multipart/byteranges response when only one range is requested. Overall, the logic in the function directly implements the specified constraint from the HTTP RFC.",success,
12231,ap_set_byterange,A server MUST ignore an If-Range header field received in a request that does not contain a Range header field.,119,Fully Matches,"[{'C1': {'code': 'range = apr_table_get(r->headers_in, ""Range"");\nif (!range || ap_cstr_casecmpn(range, ""bytes="", 6) || r->status != HTTP_OK) {\n    return 0;\n}', 'explanation': 'This code checks for the presence of a Range header. If the Range header is missing, the function returns immediately, which means any If-Range header present is effectively ignored in accordance with the RFC requirement.'}}, {'A1': {'code': 'if (AP_CONDITION_NOMATCH == ap_condition_if_range(r, r->headers_out)) {\n    return 0;\n}', 'explanation': 'Although the RFC requirement specifically mandates ignoring an If-Range header when there is no Range header, when a Range header is present, this check validates the If-Range header. This is consistent with the context provided by the spec.'}}]","The function first confirms the presence of a Range header. If the Range header is absent it exits early, thereby ignoring any If-Range header in the request, which directly implements the RFC specification. In cases where a Range header is present, it further validates the If-Range header, aligning with the broader context of proper Range request handling as defined in the spec.",success,
12231,ap_set_byterange,An origin server MUST ignore an If-Range header field received in a request for a target resource that does not support Range requests.,120,Partially Matches,[],"The provided function does include logic to process Range and If-Range headers—it checks for a Range header and then calls ap_condition_if_range to decide whether to proceed with range processing. However, the RFC requirement we are examining specifically mandates that an origin server MUST ignore an If-Range header if the target resource does not support Range requests. In this function, there is no explicit check to determine if the target resource supports Range requests. Although the function returns early (ignoring the header) when certain conditions are not met (for example, if no Range header is found or if the result of ap_condition_if_range is AP_CONDITION_NOMATCH), it does not address the case where the resource itself does not support Range requests. Therefore, while some aspects of header processing are implemented, the function does not fully meet the specified RFC condition, resulting in a partially matching implementation.",success,
12231,ap_set_byterange,A server that receives an If-Range header field on a Range request MUST evaluate the condition per Section 13.2 prior to performing the method.,121,Partially Matches,"[{'C1': {'code': '/* Check the If-Range header for Etag or Date. */\nif (AP_CONDITION_NOMATCH == ap_condition_if_range(r, r->headers_out)) {\n    return 0;\n}', 'explanation': 'This code segment checks the If-Range header condition before processing the Range request by invoking ap_condition_if_range. It clearly attempts to enforce the RFC requirement that the condition must be evaluated. However, the detailed evaluation per Section 13.2 (such as checking HTTP-date validators or ETags) is delegated to the external dependency and is not fully implemented within this function.'}}]","The function verifies that the client’s Range request includes an If-Range header and calls ap_condition_if_range to evaluate the condition before proceeding. This demonstrates an attempt to satisfy the RFC requirement that such conditions be checked prior to processing the method. Nonetheless, since the actual logic for detailed evaluation is outsourced to another function (ap_condition_if_range) rather than being implemented directly within this function, the requirement is only partially met by the code function in isolation.",success,
12231,ap_set_byterange,A recipient of an If-Range header field MUST ignore the Range header field if the If-Range condition evaluates to false.,122,Fully Matches,"[{'C1': {'code': 'if (AP_CONDITION_NOMATCH == ap_condition_if_range(r, r->headers_out)) {\n        return 0;\n    }', 'explanation': 'This code directly checks the If-Range condition by calling ap_condition_if_range. If the condition evaluates to false (AP_CONDITION_NOMATCH), the function returns 0, effectively ignoring the Range header field as required by the spec.'}}]","The function implements the specified RFC requirement by evaluating the If-Range header condition and, if the condition is false, it ignores the Range header by returning 0. This logic within the function_body clearly addresses the mandate that a recipient of an If-Range header field must ignore the Range header if the condition is false; thus, the function fully matches the specification constraint.",success,
12231,ap_set_byterange,"Otherwise, the recipient SHOULD process the Range header field as requested.",123,Fully Matches,"[{'C1': {'code': 'if (AP_CONDITION_NOMATCH == ap_condition_if_range(r, r->headers_out)) {\n    return 0;\n}', 'explanation': 'This code checks the If-Range condition. If the condition fails (i.e. the validator does not match), the function immediately returns 0, effectively ignoring the Range header field as required by the spec.'}}, {'A1': {'code': '/* ... */\n/* After this check the function continues to parse and process the Range header field as requested */', 'explanation': ""Following the If-Range check, the function parses the Range header and schedules processing of the byte ranges (by setting r->range and changing r->status) which implements the 'should process the Range header field as requested' action stated in the spec.""}}]","The function directly addresses the RFC requirement by first checking the If-Range header condition using ap_condition_if_range. If the condition evaluates to false, it immediately stops processing the Range header, which is in line with the spec that mandates ignoring the Range header under that circumstance. Otherwise, it continues to process the Range header and creates the necessary byte ranges. Therefore, the function visibly implements both the condition (C1) and the action (A1) required by the spec.",success,
12231,ap_set_byterange,A server MAY ignore the Range header field.,126,Fully Matches,"[{'C1': {'code': 'if (!range || ap_cstr_casecmpn(range, ""bytes="", 6) || r->status != HTTP_OK) {\n    return 0;\n}\n\nif (apr_table_get(r->headers_out, ""Content-Range"")) {\n    return 0;\n}\n\nif ((ct = apr_table_get(r->headers_out, ""Content-Type"")) && ap_cstr_casecmpn(ct, ""multipart/byteranges"", 20) == 0) {\n    return 0;\n}\n\nif (AP_CONDITION_NOMATCH == ap_condition_if_range(r, r->headers_out)) {\n    return 0;\n}', 'explanation': 'These segments check for the presence of the Range header and other conditions (such as an invalid method status, pre-existing range-bound headers, or a failed If-Range check) under which the server is allowed to ignore the Range header in accordance with the specification.'}}, {'A1': {'code': ""r->status = HTTP_PARTIAL_CONTENT;\n...\nr->range = apr_array_pstrcat(r->pool, merged, ',');"", 'explanation': 'When valid byte ranges are determined, this portion of the code sets the response status to HTTP_PARTIAL_CONTENT and prepares the Range string for the response, thereby implementing the range semantics defined for GET requests.'}}]","The function 'ap_set_byterange' implements the RFC requirement by conditionally processing the Range header: it explicitly checks if the header exists and if conditions are met (such as the request status being HTTP_OK, absence of pre-existing Content-Range or multipart indicators, and passing the If-Range check). If the conditions are not met, it ignores the Range header (by returning 0), which is in line with the spec stating that a server MAY ignore the header. When valid, the function processes and merges range specifications and sets the status to HTTP_PARTIAL_CONTENT, fulfilling the action required for supported range requests. Thus, the code by itself fully addresses the constraints derived from the specification.",success,
12231,ap_set_byterange,"When multiple ranges are requested, a server MAY coalesce any of the ranges that overlap, or that are separated by a gap that is smaller than the overhead of sending multiple parts, regardless of the order in which the corresponding range-spec appeared in the received Range header field.",151,Partially Matches,"[{'C1': {'code': 'if (start < ostart && end >= ostart-1) {\n    ostart = start;\n    ++*reversals;\n    in_merge = 1;\n}\nif (end >= oend && start <= oend+1 ) {\n    oend = end;\n    in_merge = 1;\n}', 'explanation': ""The function contains logic to merge overlapping ranges and those that abut (i.e. with a gap of 0 or 1 byte). This partially addresses the spec's requirement to coalesce ranges that overlap or are separated by a gap smaller than the overhead of sending multiple parts. However, the code does not compare the gap size against the typical overhead (around 80 bytes), instead it only merges when the gap is essentially nonexistent (or off by one byte).""}}]","The function parses a Range header and attempts to merge multiple ranges if they overlap or are contiguous. It implements logic that detects when one range is within or immediately adjacent to another, and merges them accordingly. This implementation partially matches the RFC specification because it coalesces overlapping or contiguous ranges, but it does not allow for a configurable gap threshold (e.g., a gap less than the expected overhead of approximately 80 bytes) as described in the RFC. Therefore, only part of the spec constraint is met within the function.",success,
12231,ap_set_byterange,An origin server MUST ignore a Range header field that contains a range unit it does not understand.,128,Fully Matches,"[{'C1': {'code': 'if (!range || ap_cstr_casecmpn(range, ""bytes="", 6) || r->status != HTTP_OK) {\n    return 0;\n}', 'explanation': ""This code segment checks that the Range header exists and starts with 'bytes='. If the range unit is not 'bytes', the function returns 0, thereby ignoring the Range header as required by the RFC.""}}]","The function explicitly validates that the Range header uses the 'bytes' range unit. By returning 0 when the header is missing, not starting with 'bytes=', or when status is not HTTP_OK, it effectively ignores Range headers with unsupported range units. This logic directly addresses the RFC requirement, and no additional conditions or actions from the spec are expected in this function.",success,
12231,ap_set_byterange,"A server that supports range requests MAY ignore or reject a Range header field that contains an invalid ranges-specifier (Section 14.1.1), a ranges-specifier with more than two overlapping ranges, or a set of many small ranges that are not listed in ascending order, since these are indications of either a broken client or a deliberate denial-of-service attack (Section 17.15).",129,Partially Matches,"[{'C1': {'code': 'if (!(dash = strchr(cur, \'-\'))) {\n    return 0;\n}\n\nif (!ap_parse_strict_length(&number, cur)) {\n    return 0;\n}\n\n/* Also note the similar check for ""-5"" ranges:\n   if (!ap_parse_strict_length(&number, dash+1)) {\n       return 0;\n   } */', 'explanation': 'The function checks the syntax of each byte-range-spec and returns 0 (ignoring the header) if a syntactically invalid range is encountered. This follows the RFC requirement to ignore a Range header when any range-spec is invalid.'}}]","The function implements logic to parse and validate the Range header as specified by RFC 2616 Section 14.35.1, thus handling syntactically invalid ranges by ignoring the header. However, it does not explicitly enforce other parts of the RFC specification such as rejecting a ranges-specifier with more than two overlapping ranges or handling multiple small unsorted ranges. While the function does perform merging of ranges and counts overlaps and reversals, these values are only logged and not used to reject the header. As such, only part of the RFC constraints are handled by this function.",success,
12231,ap_set_byterange,"If all of the preconditions are true, the server supports the Range header field for the target resource, the received Range field-value contains a valid ranges-specifier with a range-unit supported for that target resource, and that ranges-specifier is satisfiable with respect to the selected representation, the server SHOULD send a 206 (Partial Content) response with content containing one or more partial representations that correspond to the satisfiable range-spec(s) requested.",131,Fully Matches,"[{'C1': {'code': 'if (!range || ap_cstr_casecmpn(range, ""bytes="", 6) || r->status != HTTP_OK) {\n    return 0;\n}\n\n...\n\nif (AP_CONDITION_NOMATCH == ap_condition_if_range(r, r->headers_out)) {\n    return 0;\n}', 'explanation': 'This segment verifies the preconditions required by the RFC: it checks for the existence and correct format of the Range header, ensures the request is in an OK state, and applies the If-Range condition. These checks correspond to ensuring that the request satisfies the conditions for processing a Range request.'}}, {'A1': {'code': ""r->status = HTTP_PARTIAL_CONTENT;\nr->range = apr_array_pstrcat(r->pool, merged, ',');"", 'explanation': 'After computing the satisfiable ranges, the function sets the response status to HTTP 206 Partial Content and constructs the Range header for the response, fulfilling the action specified in the RFC.'}}]","The function implements key parts of the RFC requirement by first validating that the Range header is present, correctly formatted, and that the preconditions (including the If-Range header condition) are satisfied (C1). It then processes the range values, checks for unsatisfiable ranges, and finally sets the response status to HTTP 206 Partial Content with the partial ranges response (A1). Thus, the code function visibly addresses all the required conditions and actions specified in the RFC.",success,
12231,ap_set_byterange,"If all of the preconditions are true, the server supports the Range header field for the target resource, the received Range field-value contains a valid ranges-specifier, and either the range-unit is not supported for that target resource or the ranges-specifier is unsatisfiable with respect to the selected representation, the server SHOULD send a 416 (Range Not Satisfiable) response.",132,Partially Matches,"[{'A1': {'code': '...\n    else if (num_ranges == 0 && unsatisfiable) {\n        /* If all ranges are unsatisfiable, we should return 416 */\n        return -1;\n    }', 'explanation': 'This code segment detects the situation in which no valid range was extracted (i.e. all ranges are unsatisfiable) and returns -1, which is later used to trigger a 416 (Range Not Satisfiable) response. This directly corresponds to the RFC action of sending a 416 response when the range-specifier is unsatisfiable.'}}]","The function inspects the Range header, parses the ranges, and validates the byte-range specifications. In particular, if it finds that all provided ranges are unsatisfiable (for example, when the specified start is beyond the content length), it returns -1 to indicate that a 416 response should be sent. This behavior partially implements the specification’s requirement to send a 416 when the conditions are met. However, several other preconditions mentioned in the spec (such as checking for supported range units) are either handled elsewhere or not fully addressed within the isolated function. Therefore, while one major action (A1) is visibly implemented, the entire set of conditions and actions described in the RFC is only partially matched by the function.",success,
12233,send_416,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,44,Does Not Match,[],"The provided function, send_416, does not contain any logic to handle Content-Length header rules as specified in the RFC. The RFC requires specific handling for responses such as 304 or HEAD responses regarding the Content-Length header, yet this function only creates an error bucket for HTTP_RANGE_NOT_SATISFIABLE and sets the response status to HTTP_OK. There is no visible implementation in this function addressing any condition or action related to ensuring that a Content-Length header field (if sent) equals the exact content octets for a 200 OK or GET response. Thus, no spec constraint (e.g., C1, A1) is met by this function.",success,
12234,ap_byterange_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The RFC requires that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect. In the function_body, although there is a removal of the ""Content-Length"" header in a specific block (when processing multiple byte ranges), the function does not implement any logic that validates whether the Content-Length header value is correct or incorrect before forwarding the message. It does not compare the computed length (clength) with the Content-Length header received nor does it perform any error handling specific to an incorrect Content-Length value. Therefore, no logic in this function fully satisfies the specified constraint.",success,
12234,ap_byterange_filter,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,36,Fully Matches,"[{'C1': {'code': 'bound_head = apr_pstrcat(r->pool,\n                             CRLF ""--"", ap_multipart_boundary,\n                             CRLF ""Content-type: "", orig_ct,\n                             CRLF ""Content-range: bytes "",\n                             NULL);\n\n...\n\nts = apr_psprintf(r->pool, BYTERANGE_FMT CRLF CRLF, range_start, range_end, clength);\n\n...\n\nend = apr_pstrcat(r->pool, CRLF ""--"", ap_multipart_boundary, ""--"" CRLF, NULL);', 'explanation': 'The function constructs multipart response parts and boundaries by explicitly concatenating CRLF with delimiters and header strings. This ensures that only CRLF is used to mark line breaks between body parts, which directly addresses the RFC requirement that a sender MUST generate only CRLF for line breaks.'}}]","The code within the function 'ap_byterange_filter' directly implements the RFC specification by ensuring that all multipart boundaries and header lines are constructed using the CRLF constant. The use of CRLF in the construction of the 'bound_head', the 'ts' segment for each range, and the final boundary 'end' shows that the function adheres to the requirement that only CRLF is used for line breaks in the multipart body.",success,
12234,ap_byterange_filter,"If all of the preconditions are true, the server supports the Range header field for the target resource, the received Range field-value contains a valid ranges-specifier, and either the range-unit is not supported for that target resource or the ranges-specifier is unsatisfiable with respect to the selected representation, the server SHOULD send a 416 (Range Not Satisfiable) response.",132,Partially Matches,"[{'A1': {'code': 'if (num_ranges < 0)\n    return send_416(f, bsend);\n\n... \n\nif (found == 0) {\n    /* bsend is assumed to be empty if we get here. */\n    return send_416(f, bsend);\n}', 'explanation': ""The RFC requires that if the range header is valid but the range-specifier is unsatisfiable (or the range-unit is not supported), the server SHOULD send a 416 response. In the code, when 'ap_set_byterange' returns a negative value (indicating an unsatisfiable range) or when no valid content is found ('found == 0'), the function calls 'send_416', which sends a 416 (Range Not Satisfiable) response. This addresses the action prescribed by the RFC, although the complete set of preconditions is not explicitly verified within this function.""}}]","The provided function contains logic that detects unsatisfiable range requests by checking if 'ap_set_byterange' returns a negative number or if no valid range content is found. In such cases, it calls 'send_416' to respond with a 416 status. This matches the action (A1) described in the RFC spec. However, other aspects of the preconditions—such as verifying that the Range header field is supported or that the ranges-specifier is valid—are not all handled directly in this function, suggesting that some precondition checks are likely delegated to other parts of the system (for example, within 'ap_set_byterange'). Therefore, the implementation only partially addresses the RFC requirement on its own.",success,
12234,ap_byterange_filter,"To avoid confusion with single-part responses, a server MUST NOT generate a Content-Range header field in the HTTP header section of a multiple part response (this field will be sent in each part instead).",148,Fully Matches,"[{'C1': {'code': 'if (num_ranges == 1) {\n    apr_table_setn(r->headers_out, ""Content-Range"",\n                   apr_psprintf(r->pool, ""bytes "" BYTERANGE_FMT,\n                                range_start, range_end, clength));\n} else {\n    char *ts;\n\n    e = apr_bucket_pool_create(bound_head, strlen(bound_head),\n                                 r->pool, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bsend, e);\n\n    ts = apr_psprintf(r->pool, BYTERANGE_FMT CRLF CRLF,\n                      range_start, range_end, clength);\n    ap_xlate_proto_to_ascii(ts, strlen(ts));\n    e = apr_bucket_pool_create(ts, strlen(ts), r->pool, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bsend, e);\n}', 'explanation': 'The code clearly differentiates between single and multipart (multiple ranges) responses. For a single range request, it adds a top-level Content-Range header. For multipart responses, it avoids inserting a Content-Range header in the global HTTP header, and instead embeds it within each part body, which is in strict adherence to the RFC requirement.'}}]",The function 'ap_byterange_filter' implements logic that checks the number of ranges and then determines whether to include a single top-level Content-Range header (for single range responses) or to construct multipart boundaries with their own Content-Range headers (for multipart responses). This directly fulfills the specification constraint that a Content-Range header must not be generated in the HTTP header section for multipart responses.,success,
12234,ap_byterange_filter,"Within the header area of each body part in the multipart content, the server MUST generate a Content-Range header field corresponding to the range being enclosed in that body part.",149,Fully Matches,"[{'C1': {'code': 'if (num_ranges == 1) {\n    apr_table_setn(r->headers_out, ""Content-Range"",\n                   apr_psprintf(r->pool, ""bytes "" BYTERANGE_FMT,\n                                range_start, range_end, clength));\n} else {\n    /* ... for multipart response, build the header for each part ... */\n    bound_head = apr_pstrcat(r->pool,\n                             CRLF ""--"", ap_multipart_boundary,\n                             CRLF ""Content-type: "", orig_ct ? orig_ct : """",\n                             CRLF ""Content-range: bytes "",\n                             NULL);\n    /* within the loop for each range */\n    e = apr_bucket_pool_create(bound_head, strlen(bound_head), r->pool, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bsend, e);\n    ts = apr_psprintf(r->pool, BYTERANGE_FMT CRLF CRLF,\n                      range_start, range_end, clength);\n    e = apr_bucket_pool_create(ts, strlen(ts), r->pool, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bsend, e);\n}', 'explanation': ""The function handles both single and multipart byterange responses. For a single range request, it sets the 'Content-Range' header in the HTTP header section. For multipart responses, it builds each part with its own header that includes a 'Content-range: bytes' line. This directly implements the RFC requirement to include a Content-Range header field within the header area of each body part.""}}]","The function 'ap_byterange_filter' explicitly implements the logic required by the HTTP RFC for byte-range requests by ensuring that a Content-Range header is present. For single range requests, the header is set in the top-level response, and for multipart responses, the header is generated within each body part. This meets the specified constraint from the RFC.",success,
12234,ap_byterange_filter,"For byte ranges, a sender SHOULD indicate the complete length of the representation from which the range has been extracted, unless the complete length is unknown or difficult to determine.",287,Fully Matches,"[{'C1': {'code': 'for (e = APR_BRIGADE_FIRST(bb);\n     (e != APR_BRIGADE_SENTINEL(bb) && !APR_BUCKET_IS_EOS(e)\n      && e->length != (apr_size_t)-1);\n     e = APR_BUCKET_NEXT(e)) {\n    clength += e->length;\n}\n\nif (!APR_BUCKET_IS_EOS(e) || clength <= 0) {\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}', 'explanation': 'This code iterates through the buckets to calculate the total known content length and only processes byte ranges if the complete length is known. This logic adheres to the RFC requirement to indicate the complete length when it is known, and to avoid range processing when it is unknown or difficult to determine.'}}, {'A1': {'code': 'if (num_ranges == 1) {\n    apr_table_setn(r->headers_out, ""Content-Range"",\n                   apr_psprintf(r->pool, ""bytes "" BYTERANGE_FMT,\n                                range_start, range_end, clength));\n}\n', 'explanation': 'For single range requests, the function sets the Content-Range header with the start, end, and complete length of the representation. This directly implements the RFC action to indicate the complete length in a byte range response.'}}]","The function calculates the total length of the representation prior to applying byte ranges and uses this value when setting the Content-Range header. It correctly avoids applying range logic if the complete length is unknown, aligning fully with the RFC specification which advises indicating the complete length if known. Thus, the function visibly addresses the constraints by itself.",success,
12234,ap_byterange_filter,"A server MUST NOT generate a multipart response to a request for a single range, since a client that does not request multiple parts might not support multipart responses.",288,Fully Matches,"[{'C1': {'code': 'if (num_ranges == 1) {\n    apr_table_setn(r->headers_out, ""Content-Range"",\n                    apr_psprintf(r->pool, ""bytes "" BYTERANGE_FMT, range_start, range_end, clength));\n}', 'explanation': 'This code path handles the case when only one range is requested by directly setting the Content-Range header, thereby avoiding the creation of a multipart response. This adheres to the requirement that the server MUST NOT generate a multipart response for a single range.'}}, {'A1': {'code': 'if (num_ranges > 1) {\n    const char *orig_ct = ap_make_content_type(r, r->content_type);\n    ap_set_content_type_ex(r, apr_pstrcat(r->pool, ""multipart/byteranges; boundary="", ap_multipart_boundary, NULL), 1);\n    /* prepares and inserts multipart boundaries and associated headers */\n}', 'explanation': ""When more than one range is present, the code sets the content type to 'multipart/byteranges' and generates the multipart boundaries, which is consistent with the RFC's allowance for multipart responses when multiple ranges are requested.""}}]","The function clearly distinguishes between a single range request and multiple range requests. For a single range request, it sets the Content-Range header without constructing a multipart message (thereby avoiding a multipart response as mandated by the RFC). Conversely, when multiple ranges are requested, it constructs a multipart/byteranges response with appropriate boundaries and headers. Thus, by implementing both branches within the function, the code fully meets the specified RFC constraints.",success,
12234,ap_byterange_filter,"If a single part is being transferred, the server generating the 206 response MUST generate a Content-Range header field, describing what range of the selected representation is enclosed, and a content consisting of the range.",146,Fully Matches,"[{'C1': {'code': 'if (num_ranges == 1) {\n    apr_table_setn(r->headers_out, ""Content-Range"",\n                   apr_psprintf(r->pool, ""bytes "" BYTERANGE_FMT, range_start, range_end, clength));\n}', 'explanation': 'For a single range request, the function sets the Content-Range header, fulfilling the RFC requirement to describe what range of the representation is contained.'}}, {'A1': {'code': 'rv = copy_brigade_range(bb, tmpbb, range_start, range_end);\n...\nAPR_BRIGADE_CONCAT(bsend, tmpbb);', 'explanation': 'The function extracts the requested range from the original content and constructs a new brigade (bsend) with only that range, ensuring the content consists of that range as required by the RFC.'}}]","The function visibly implements the RFC requirement by checking if exactly one range is requested, setting the Content-Range header (C1) accordingly, and copying only the specified range into the output content (A1). Thus, by itself, the function fully addresses the constraint of generating a Content-Range header field and providing content consisting solely of the requested portion.",success,
12246,zap_sp,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Partially Matches,"[{'A1': {'code': ""for (; *s == ' ' || *s == '\\t' || *s == '\\n'; s++)\n    ;"", 'explanation': 'This loop skips over leading whitespace characters (spaces, tabs, and newlines), which is in line with excluding prefixed whitespace before evaluating the field value. However, the function does not address the removal of trailing whitespace, so it only partially implements the spec requirement.'}}]","The RFC specifies that implementations must exclude whitespace from field values before evaluation. The provided function 'zap_sp' removes prefixed whitespace by advancing the pointer past any leading spaces, tabs, or newlines. This addresses the need to trim leading whitespace (action A1). However, since the RFC (and accompanying context) indicate that field values should not include either leading or trailing whitespace, the lack of logic to remove trailing whitespace means that the function only partially meets the overall specification.",success,
12246,zap_sp,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': ""for (; *s == ' ' || *s == '\\t' || *s == '\\n'; s++)"", 'explanation': 'This loop scans and skips over any prefixed whitespace characters (spaces, tabs, or newlines) which addresses the RFC requirement to remove bad whitespace before further interpretation.'}}]","The provided function 'zap_sp' directly implements the removal of leading whitespace as required by the HTTP RFC specification regarding BWS. It checks for a NULL pointer, handles an empty string, and then iterates over the input to skip any whitespace characters before returning the pointer to the first non‐whitespace character. This logic fully satisfies the condition (labeled as C1) that mandates that any recognized BWS be removed prior to further processing.",success,
12246,zap_sp,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,[],"The RFC specification requires that a recipient parse for bad whitespace and remove it before interpreting the protocol element. The function zap_sp attempts to do this by advancing the pointer past any leading whitespace characters (specifically, ' ', '\t', and '\n'). However, the implementation only handles a subset of whitespace characters that might be considered bad and only removes them from the beginning of the string. It does not account for all cases (for example, other whitespace forms such as carriage return '\r' or potential internal whitespace issues) compared to the full semantics described in the spec context. Therefore, while the function shows an effort to address the requirement, it only partially meets the specification constraints on its own.",success,
12251,analyze_ct,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': 'while (apr_isspace(*cp)) { cp++; }  ...  cp = zap_sp(cp);', 'explanation': 'The function explicitly skips leading whitespace before parsing the media type, subtype, and parameter values by using loops that call apr_isspace and helper functions such as zap_sp. This logic directly fulfills the RFC requirement of excluding whitespace prior to evaluating the field value.'}}]","The provided function 'analyze_ct' eliminates whitespace from the input string at multiple stages—when processing the type, subtype, and parameters—ensuring that no leading or trailing whitespace interferes with parsing. This behavior fully addresses the RFC specification that mandates the removal of such whitespace before field evaluation, thereby fully matching the constraint labeled C1.",success,
12251,analyze_ct,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': 'while (apr_isspace(*cp)) { cp++; } ... cp = zap_sp(cp);', 'explanation': 'The function repeatedly advances the pointer over whitespace (using apr_isspace and zap_sp) before interpreting parts of the media type (type, subtype, and parameters). This demonstrates that it removes bad whitespace (BWS) in accordance with the RFC requirement that any BWS MAY be removed before further interpretation.'}}]","The provided function analyze_ct implements the necessary whitespace (BWS) removal logic by skipping leading and interstitial whitespace before processing the content type components. Thus, with respect to the RFC specification stating that bad whitespace should be removed before interpreting protocol elements, the function fully addresses this (labeled as C1) constraint within its own code.",success,
12251,analyze_ct,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': ""while (apr_isspace(*cp)) { cp++; } // initial whitespace removal\n\n...\n\ncp = zap_sp(cp);    // used after the ';'\n\n...\n\nattribute = zap_sp_and_dup(p, mp, cp, NULL);    // create trimmed token from attribute\nvalue = zap_sp_and_dup(p, mp, cp, NULL);          // create trimmed token from value"", 'explanation': 'The RFC requires that bad whitespace be parsed for and removed before interpreting protocol elements. The function repeatedly skips over whitespace (using while loops with apr_isspace) in multiple stages (for type, subtype, and parameters). In addition, the helper functions zap_sp and zap_sp_and_dup are used to trim out extra whitespace before further processing. This demonstrates that the function itself explicitly implements the whitespace removal as required by the spec.'}}]","The function 'analyze_ct' takes steps to remove unwanted whitespace by skipping over whitespace characters and using dedicated helper functions that trim extra spacing, directly addressing the RFC requirement that a recipient must parse for and remove bad whitespace prior to interpreting protocol elements. All relevant logic resides within the function, so it fully meets the spec constraint.",success,
12251,analyze_ct,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': ""    /* getting a type */\n    cp = mp;\n    while (apr_isspace(*cp)) { cp++; }\n    if (!*cp) { ... return (NULL); }\n    ctp->type = cp;\n    do { cp++; } while (*cp && (*cp != '/') && !apr_isspace(*cp) && (*cp != ';'));\n    if (!*cp || (*cp == ';')) { ... return (NULL); }\n    while (apr_isspace(*cp)) { cp++; }\n    if (*cp != '/') { ... return (NULL); }\n    ctp->type_len = cp - ctp->type;\n\n    cp++; /* skip the '/' */\n    \n    /* getting a subtype */\n    while (apr_isspace(*cp)) { cp++; }\n    if (!*cp) { ... return (NULL); }\n    ctp->subtype = cp;\n    do { cp++; } while (*cp && !apr_isspace(*cp) && (*cp != ';'));\n    ctp->subtype_len = cp - ctp->subtype;"", 'explanation': ""This segment fully implements the extraction and basic validation of the media type and subtype from the input, which is a core aspect of interpreting the protocol element as required by the RFC. It checks for correct delimiter (the '/') and skips whitespace as prescribed. However, recovery from invalid constructs is handled by logging errors and returning NULL rather than attempting to recover, so only part of the overall RFC requirement is addressed.""}}]","The function 'analyze_ct' attempts to parse a Content-Type header field by extracting the media type, subtype, and parameters, which is a central part of interpreting a received protocol element as indicated by the RFC. It demonstrates logic for tokenizing and validating the basic components (e.g., type/subtype separated by '/'), and it uses error logging to flag improper constructs. However, aside from this basic parsing, the function does not implement more advanced error recovery strategies (e.g., reconstitution of a usable media type from an invalid construct) or configuration/experience‐based rejection of sender errors. In isolation, it addresses some conditions (like extracting and validating the type and subtype, here labeled as C1) but does not cover all aspects of the RFC’s stipulations, leading to a “Partially Matches” judgment.",success,
12251,analyze_ct,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'while (apr_isspace(*cp)) { cp++; }\nif (!*cp) {\n    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01598)\n                 ""mod_mime: analyze_ct: cannot get media type from \'%s\'"",\n                 (const char *) mp);\n    return (NULL);\n}', 'explanation': ""The function begins by skipping whitespace and checking if the input string is empty, logging an error and returning NULL if no valid media type is found. This defensive check is in line with the RFC's suggestion to not assume that the element conforms to the expected grammar.""}}, {'A1': {'code': 'if (*cp != \'/\') {\n    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01600)\n                 ""mod_mime: analyze_ct: cannot get media type from \'%s\'"",\n                 (const char *) mp);\n    return (NULL);\n}\n\n...\n\nif (attribute == NULL) {\n    ...\n    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, ss, APLOGNO(01605)\n                 ""Cannot get media parameter."");\n    return (NULL);\n}', 'explanation': ""Throughout the function, whenever the expected ABNF constructs (like the '/' delimiter or valid tokens for parameters) are absent, the code logs a warning and safely exits. This multiple error-check and logging behavior demonstrates a defensive approach to parsing, as recommended by the spec.""}}]","The function 'analyze_ct' shows evidence of defensive parsing by carefully checking for the existence of expected tokens (media type, '/', subtype, parameters) and by logging errors and returning early when invalid data is found. This mirrors the intent of the RFC which advises a recipient to parse protocol elements defensively, though the function does not address all aspects (such as checking for a 'reasonable buffer size'). Thus, while it implements many of the defensive checks (e.g., C1 and A1) within its own logic, it only partially fulfills the entirety of the specification constraints.",success,
12252,find_ct,Content-Language MAY be applied to any media type --it is not limited to textual documents.,42,Fully Matches,"[{'C1': {'code': 'if (exinfo->language_type) {\n    if (!r->content_languages) {\n        r->content_languages = apr_array_make(r->pool, 2, sizeof(char *));\n    }\n    *((const char **)apr_array_push(r->content_languages)) = exinfo->language_type;\n    found = 1;\n}', 'explanation': ""This segment checks if an extension mapping specifies a language (exinfo->language_type) and adds it to the request’s content_languages array. It demonstrates that the function applies the Content-Language header based on the file's metadata, regardless of whether the resource is textual.""}}, {'A1': {'code': 'if (!r->content_languages && conf->default_language) {\n    const char **new;\n    r->content_languages = apr_array_make(r->pool, 2, sizeof(char *));\n    new = (const char **)apr_array_push(r->content_languages);\n    *new = conf->default_language;\n}', 'explanation': 'This code ensures that if no language has been set via the file’s extension, a default language (from the configuration) is applied. This supports the spec requirement by allowing Content-Language to be associated with any media type.'}}]","The function 'find_ct' implements logic for assigning a Content-Language header based on file extensions and falls back to a default language if none is provided. This implementation applies the Content-Language header to any media type without limiting it to textual documents, thereby addressing the RFC specification that 'Content-Language MAY be applied to any media type.' As such, the function meets the spec constraints fully within its own body.",success,
12252,find_ct,"In any production that uses the list construct, a sender MUST NOT generate empty list elements.",236,Fully Matches,"[{'C1': {'code': 'if (*ext == \'\\0\') {  /* ignore empty extensions ""bad..html"" */\n            continue;\n        }', 'explanation': 'This code segment validates each extracted list element (extension) and explicitly skips empty ones, which directly addresses the RFC requirement that a sender MUST NOT generate empty list elements.'}}]","The function processes filename extensions using a list construct and includes a condition to ignore empty elements (as seen in the check for *ext == '\0'). This visible logic fully implements the requirement specified by the RFC that empty list elements should not be generated, thus the function fully matches the relevant spec constraint.",success,
12252,find_ct,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'if (!r->filename) {\n    return DECLINED;\n}\n...\nif (r->content_type) {\n    content_type *ctp;\n    ...\n    while (pp != NULL) {\n        if (charset && !strcmp(pp->attr, ""charset"")) {\n            ...\n            ap_set_content_type_ex(r, apr_pstrcat(r->pool, r->content_type, ""; charset="", charset, NULL), AP_REQUEST_IS_TRUSTED_CT(r));\n            ...\n        } else {\n            ap_set_content_type_ex(r, apr_pstrcat(r->pool, r->content_type, ""; "", pp->attr, ""="", pp->val, NULL), AP_REQUEST_IS_TRUSTED_CT(r));\n        }\n        pp = pp->next;\n    }\n    if (charset && !override) {\n        ap_set_content_type_ex(r, apr_pstrcat(r->pool, r->content_type, ""; charset="", charset, NULL), AP_REQUEST_IS_TRUSTED_CT(r));\n    }\n}', 'explanation': 'This block confirms that a Content-Type is generated or adjusted (by appending charset or other parameters) when a valid content type has been determined. It embodies the RFC requirement to generate a Content-Type header if the enclosed representation’s media type is known.'}}, {'A1': {'code': 'if ((type = apr_hash_get(mime_type_extensions, ext, APR_HASH_KEY_STRING)) != NULL) {\n    ap_set_content_type_ex(r, (char*) type, 1);\n    found = 1;\n}\n...\nif (exinfo != NULL) {\n    if ((exinfo->forced_type && *exinfo->forced_type) && !skipct) {\n        ap_set_content_type_ex(r, exinfo->forced_type, 1);\n        found = 1;\n    }\n}', 'explanation': 'These code segments set the Content-Type header field using ap_set_content_type_ex when a known media type is found from the file extension or from forced type mappings. This meets the RFC guideline that a Content-Type header field should be generated if the media type is known.'}}]","The function 'find_ct' is designed to determine and set the Content-Type header field based on the file’s extension and associated metadata. It first checks for conditions such as whether the filename exists and whether the file represents a directory or a file, then it parses extensions and looks up the corresponding media type. When a known media type is found, it sets the Content-Type header using ap_set_content_type_ex(), optionally appending charset or additional parameters. In cases where no known media type is determined, the function refrains from setting the header (returning DECLINED), which aligns with the RFC’s clause that the header need not be generated if the media type is unknown. Thus, by addressing both the condition (a content-containing message should carry a Content-Type if known) and the action (setting the header), the function fully implements the specified HTTP RFC requirement.",success,
12252,find_ct,The type/subtype MAY be followed by semicolon-delimited parameters (Section 5.6.6) in the form of name/value pairs.,259,Partially Matches,"[{'C1': {'code': 'if (r->content_type) {\n    content_type *ctp;\n    if ((ctp = analyze_ct(r, r->content_type))) {\n        /* Build base_content_type from ctp->type and ctp->subtype */\n        /* Then, for each parameter in ctp->param do:\n             ap_set_content_type_ex(r, apr_pstrcat(r->pool, r->content_type, ""; "", pp->attr, ""="", pp->val, NULL), AP_REQUEST_IS_TRUSTED_CT(r));\n        */\n    }\n}\n', 'explanation': 'This section calls analyze_ct to break up the content type into its base type (type/subtype) and its parameters, then reassembles the content type using semicolon‐delimited name/value pairs. This addresses the RFC requirement that the type/subtype MAY be followed by such parameters.'}}, {'A1': {'code': 'if (charset && !override) {\n    ap_set_content_type_ex(r, apr_pstrcat(r->pool, r->content_type, ""; charset="", charset, NULL), AP_REQUEST_IS_TRUSTED_CT(r));\n}\n', 'explanation': 'This code appends the ""charset"" parameter when present, ensuring that a semicolon-delimited parameter is added, which is in line with the RFC specification.'}}]","The function attempts to implement the RFC’s allowance for a type/subtype to be followed by semicolon-delimited parameters. It does so by using analyze_ct to parse the base media type and its parameters and then reconstructs the content type string with appended parameters including a special check for the charset parameter. However, some aspects (such as complete case-insensitive handling of the type/subtype tokens or full parsing of all parameters) appear to be delegated to analyze_ct or assumed to be handled elsewhere. Therefore, while the function clearly attempts to address key aspects of the RFC specification, it only partially matches by implementing some, but not necessarily all, of the expected behaviors within this function alone.",success,
12252,find_ct,Multiple languages MAY be listed for content that is intended for multiple audiences.,260,Fully Matches,"[{'C1': {'code': 'if (exinfo->language_type) {\n    if (!r->content_languages) {\n        r->content_languages = apr_array_make(r->pool, 2, sizeof(char *));\n    }\n    *((const char **)apr_array_push(r->content_languages)) = exinfo->language_type;\n    found = 1;\n}', 'explanation': 'This code block examines the extension language type (exinfo->language_type) and, if present, initializes (if needed) the content_languages array and appends the language. This addresses the RFC specification that multiple languages MAY be listed for content intended for multiple audiences.'}}, {'A1': {'code': 'if (!r->content_languages && conf->default_language) {\n    const char **new;\n\n    r->content_languages = apr_array_make(r->pool, 2, sizeof(char *));\n    new = (const char **)apr_array_push(r->content_languages);\n    *new = conf->default_language;\n}', 'explanation': 'This segment sets a default language when no Content-Language has been specified, matching the spec context where the default is that the content is intended for all language audiences.'}}]","The function 'find_ct' clearly includes logic to process language information from file extensions by adding them to a languages array, allowing multiple languages to be listed. In addition, it checks for and applies a default language if no content language has been determined. Both aspects fulfill the corresponding requirements of the RFC specification regarding multiple language handling.",success,
12257,parse_chunk_size,"Therefore, recipients MUST anticipate potentially large hexadecimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer representation.",305,Partially Matches,"[{'C1': {'code': 'ctx->chunkbits = sizeof(apr_off_t) * 8 - 4;\n...\nif (ctx->chunkbits < 0) {\n    /* overflow */\n    return APR_ENOSPC;\n}\n\n...\nctx->remaining = (ctx->remaining << 4) | xvalue;', 'explanation': 'The function sets a limit on the number of bits (ctx->chunkbits) available for the chunk size (derived from the size of apr_off_t) and decrements it by 4 for each hexadecimal digit processed. When the available bits drop below zero, it returns an error, thereby attempting to prevent integer conversion overflow. This addresses the spec’s requirement to anticipate large hexadecimal numerals and prevent parsing errors from overflow.'}}]","The provided function implements logic to process hexadecimal chunk sizes by carefully shifting and accumulating digit values while decrementing a bit counter (ctx->chunkbits). This mechanism is used to catch cases where too many hexadecimal digits are present, thus preventing an overflow in the integer conversion. However, while it does address integer overflows linked to very large hexadecimal values (as required by the spec), the function does not explicitly handle issues related to precision loss in every scenario. Therefore, it partially matches the spec constraint by addressing some, but not all, of the conditions and actions outlined in the specification context.",success,
12257,parse_chunk_size,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': ""if (ctx->state == BODY_CHUNK) {\n    if (!apr_isxdigit(c)) {\n        /* Detect invalid character at beginning. This also works for\n         * empty chunk size lines. */\n        return APR_EINVAL;\n    } else {\n        ctx->state = BODY_CHUNK_PART;\n    }\n    ctx->remaining = 0;\n    ctx->chunkbits = sizeof(apr_off_t) * 8 - 4;\n    ctx->chunk_used = 0;\n    ctx->chunk_bws = 0;\n}\n...\nif (ctx->state == BODY_CHUNK_PART) {\n    int xvalue;\n\n    /* ignore leading zeros */\n    if (!ctx->remaining && c == '0') {\n        i++;\n        continue;\n    }\n\n    ctx->chunkbits -= 4;\n    if (ctx->chunkbits < 0) {\n        /* overflow */\n        return APR_ENOSPC;\n    }\n\n    if (c >= '0' && c <= '9') {\n        xvalue = c - '0';\n    }\n    else if (c >= 'A' && c <= 'F') {\n        xvalue = c - 'A' + 0xa;\n    }\n    else if (c >= 'a' && c <= 'f') {\n        xvalue = c - 'a' + 0xa;\n    }\n    else {\n        /* bogus character */\n        return APR_EINVAL;\n    }\n\n    ctx->remaining = (ctx->remaining << 4) | xvalue;\n    if (ctx->remaining < 0) {\n        /* Overflow - should be unreachable since the\n         * chunkbits limit will be reached first. */\n        return APR_ENOSPC;\n    }\n}"", 'explanation': 'This segment verifies that the received chunk-size field is composed of valid hexadecimal digits and converts it in accordance with the RFC requirement that the recipient interpret the protocol element per defined semantics.'}}]","The function parse_chunk_size implements significant portions of the RFC requirement by parsing the chunk-size line, checking for valid hexadecimal characters, and handling the CRLF sequence. It validates protocol elements as required by the spec (e.g., verifying the integrity of the chunk size) and returns errors when the received data deviates from expected formats. However, the function does not implement comprehensive error recovery strategies or cover all possible extensions noted in the RFC context (for example, it returns errors rather than attempting to recover a usable protocol element when the construct is slightly invalid). Therefore, while it visibly attempts to address condition C1, it only partially meets the overall set of constraints implied by the RFC.",success,
12257,parse_chunk_size,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': ""while (i < len) {\n    char c = buffer[i];\n    ...\n    if (ctx->state == BODY_CHUNK) {\n        if (!apr_isxdigit(c)) {\n            return APR_EINVAL;\n        } else {\n            ctx->state = BODY_CHUNK_PART;\n        }\n        ...\n    }\n    ...\n    if (ctx->state == BODY_CHUNK_PART) {\n        ...\n        if (c >= '0' && c <= '9') {\n            xvalue = c - '0';\n        } else if (c >= 'A' && c <= 'F') {\n            xvalue = c - 'A' + 0xa;\n        } else if (c >= 'a' && c <= 'f') {\n            xvalue = c - 'a' + 0xa;\n        } else {\n            return APR_EINVAL;\n        }\n        ctx->remaining = (ctx->remaining << 4) | xvalue;\n        ...\n    }\n    ...\n    if (c == LF) {\n        if (strict && (ctx->state != BODY_CHUNK_LF)) {\n            return APR_EINVAL;\n        }\n        ...\n    }\n    ...\n}"", 'explanation': 'The function inspects each incoming character defensively, ensuring that only valid characters (hex digits, proper CRLF, space, etc.) are processed. If any unexpected character is encountered, it returns an error, thereby implementing a defensive parsing strategy as required by the specification.'}}, {'A1': {'code': 'ctx->chunk_used += len;\nif (ctx->chunk_used < 0 || ctx->chunk_used > linelimit) {\n    return APR_ENOSPC;\n}', 'explanation': ""The function tracks the total number of processed characters and ensures it does not exceed the provided 'linelimit', thereby enforcing a reasonable buffer size constraint.""}}]","The parse_chunk_size function implements defensive parsing following the HTTP spec's requirement by validating each character of the chunk size input, handling CRLF sequences accurately, and ensuring that any deviation from the expected format leads to an error. Additionally, by checking that the total processed length does not exceed a specified line limit, it enforces a reasonable buffer size condition. Both of these are directly handled within the function, fulfilling the spec's intent.",success,
12257,parse_chunk_size,"Since there is no predefined limit to the length of content, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer conversion (Section 17.5).",261,Partially Matches,"[{'C1': {'code': 'ctx->chunkbits = sizeof(apr_off_t) * 8 - 4;\n...\nctx->chunkbits -= 4;\nif (ctx->chunkbits < 0) {\n    /* overflow */\n    return APR_ENOSPC;\n}', 'explanation': 'The code uses a counter (ctx->chunkbits) to track the number of bits available when reading the chunk size and decrements it by 4 for each hexadecimal digit processed. This logic is intended to prevent integer conversion overflow by aborting (returning APR_ENOSPC) when the number exceeds the safe limit. This approach partially implements the RFC requirement to anticipate large numeral values and prevent overflows. However, the RFC explicitly discusses potentially large decimal numerals (as in Content-Length) while this function processes hexadecimal chunk sizes. Thus, the overflow prevention is only partially aligned with the specified constraint.'}}]","The function implements logic to prevent integer conversion overflow by limiting the number of bits used during the parsing of chunk sizes. It carefully checks for overflow conditions (e.g., ctx->chunkbits becoming negative) and returns an error if the size is too large. While this demonstrates an awareness of the potential for large numbers causing overflow errors, the RFC specifically addresses large decimal numeral parsing in the context of Content-Length, not hexadecimal chunk sizes. Therefore, the implementation only partially matches the spec constraints as the parsing and overflow protection is applied in a different context than that described in the RFC.",success,
12257,parse_chunk_size,"Since there is no predefined limit to the length of content, recipients MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows.",285,Fully Matches,"[{'C1': {'code': 'ctx->chunkbits = sizeof(apr_off_t) * 8 - 4;\n...\nif (ctx->chunkbits < 0) {\n    /* overflow */\n    return APR_ENOSPC;\n}', 'explanation': 'The specification requires that recipients must anticipate very large numerical values and thus avoid integer conversion overflows. In the function, the code initializes a chunkbits variable to a limit (based on the size of apr_off_t) and subtracts 4 bits for safety. Then, during the parsing of each hex digit (chunk part), it checks if chunkbits has dropped below 0, which indicates that further bit shifting could cause an overflow. By returning APR_ENOSPC in such cases, the function actively prevents parsing errors due to integer conversion overflows.'}}]",The function 'parse_chunk_size' includes explicit logic to handle potentially large numerals by managing a 'chunkbits' counter and checking for overflow conditions during the parsing process. This directly addresses the specification's requirement to prevent parsing errors due to integer conversion overflows. All necessary logic to satisfy this condition is implemented within the function itself.,success,
12257,parse_chunk_size,A recipient MUST parse an HTTP message as a sequence of octets in an encoding that is a superset of US-ASCII [USASCII].,294,Partially Matches,"[{'C1': {'code': 'ap_xlate_proto_from_ascii(&c, 1);', 'explanation': 'This call translates the incoming octet from ASCII, ensuring that the parser operates on individual octets rather than on a higher-level Unicode representation. This addresses the requirement to treat the HTTP message as a sequence of octets from an encoding that is a superset of US‐ASCII.'}}, {'A1': {'code': 'if (c == LF) {\n    if (strict && (ctx->state != BODY_CHUNK_END_LF)) {\n        return APR_EINVAL;\n    }\n    ctx->state = BODY_CHUNK;\n}\nelse if (c == CR && ctx->state == BODY_CHUNK_END) {\n    ctx->state = BODY_CHUNK_END_LF;\n}', 'explanation': 'These code segments handle the CRLF sequence (or recognition of a lone LF when not in strict mode), conforming to the RFC’s allowance for a single LF when preceded by an optional CR.'}}]","The function 'parse_chunk_size' processes the chunk size portion by iterating byte‐by‐byte over the input buffer. It explicitly converts each octet using an ASCII translation function and handles the CR and LF characters in a way that aligns with the RFC’s guidance on line termination. However, the function only tackles one aspect (chunk size processing) of the overall HTTP message parsing procedure, and its logic is focused on the proper handling of chunk boundaries rather than implementing the complete set of message parsing steps as described in the RFC context. Therefore, while portions of the spec are addressed (notably C1 and A1 as outlined), the implementation only partially matches the full specification requirements.",success,
12257,parse_chunk_size,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Fully Matches,"[{'C1': {'code': 'if (c == LF) {\n    if (strict && (ctx->state != BODY_CHUNK_END_LF)) {\n        /* CR missing before LF. */\n        return APR_EINVAL;\n    }\n    ctx->state = BODY_CHUNK;\n}', 'explanation': 'This segment shows that when an LF is encountered, the function checks whether it has been properly preceded by a CR (when in strict mode) or accepts a lone LF otherwise. This behavior matches the RFC specification that a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.'}}, {'A1': {'code': 'else if (c == CR && ctx->state == BODY_CHUNK_END) {\n    ctx->state = BODY_CHUNK_END_LF;\n} else {\n    /* CRLF expected. */\n    return APR_EINVAL;\n}', 'explanation': 'This code handles the case for CR by expecting it to be immediately followed by LF. If it is not (or if an unexpected bare CR appears), the function returns an error (APR_EINVAL), effectively treating a bare CR as an invalid element. This is in accord with the RFC requirement to consider a bare CR invalid (or replace it).'}}]","The function implements the line terminator handling logic in accordance with the RFC. It distinguishes between the correct CRLF sequence and a lone LF, accepting the latter when not enforcing strict CRLF (strict mode disabled). It also identifies and rejects bare CR instances when they do not meet the proper CRLF sequence requirement. Hence, within its own logic, the function fully addresses the conditions and actions specified by the RFC.",success,
12258,read_chunked_trailers,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The RFC requires that a recipient must not merge a trailer field into the header section unless it understands and explicitly permits safe merging per the header field definition. In the provided code function, while trailer headers are collected and later merged into a bucket, there is no visible check or logic that verifies whether the trailer field definitions explicitly allow safe merging. The function merely replaces the current header table with a new one to capture trailers via ap_get_mime_headers() and then, if successful, creates a header bucket without performing any validation against the trailer field definitions. Thus, the function does not implement the key constraint of the spec within its own logic.",success,
12258,read_chunked_trailers,"At the end of a message, a recipient MAY treat the set of received trailer fields as a data structure of name/value pairs, similar to (but separate from) the header fields.",14,Fully Matches,"[{'C1': {'code': 'trailers = apr_table_make(r->pool, 5);\nr->headers_in = trailers;\nap_get_mime_headers(r);\nr->headers_in = saved_headers_in;', 'explanation': 'This code creates a separate table for trailer fields and temporarily reassigns r->headers_in to this table to parse trailer headers separately. This corresponds to the requirement of treating trailer fields as a separate name/value pair structure.'}}, {'A1': {'code': 'if (!apr_is_empty_table(trailers)) {\n    e = ap_bucket_headers_create(trailers, r->pool, b->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(b, e);\n}\ne = apr_bucket_eos_create(f->c->bucket_alloc);\nAPR_BRIGADE_INSERT_TAIL(b, e);', 'explanation': 'This code appends the parsed trailer headers into the output bucket brigade, and then also appends an EOS marker, thereby integrating the trailer fields into the response processing as specified.'}}]","The function 'read_chunked_trailers' directly implements the RFC requirement by creating a separate header table for trailer fields (C1) and then appending these trailers as a header bucket (A1). The logic within the function handles parsing of the trailers and then conditionally adds them to the processing pipeline, fulfilling the specification for trailer field processing as described.",success,
12259,ap_http_filter,A recipient that retains a received trailer field MUST either store/ forward the trailer field separately from the received header fields or merge the received trailer field into the header section.,206,Fully Matches,"[{'C1': {'code': 'if (AP_BUCKET_IS_HEADERS(e)) {\n    /* trailers */\n    ap_bucket_headers * hdrs = e->data;\n\n    /* Allow multiple HEADERS buckets carrying trailers here, ... */\n    ctx->at_trailers = 1;\n    if (!apr_is_empty_table(hdrs->headers)) {\n        r->trailers_in = apr_table_overlay(r->pool, r->trailers_in, hdrs->headers);\n    }\n    apr_bucket_delete(e);\n}', 'explanation': ""This code segment detects trailer fields (marked as HEADERS buckets) and stores them separately in 'r->trailers_in', which satisfies the requirement to store or forward trailer fields separately from the received header fields.""}}, {'A1': {'code': 'if (APR_BUCKET_IS_EOS(e)) {\n    ctx->at_eos = 1;\n    if (!apr_is_empty_table(r->trailers_in)) {\n        core_server_config *conf = ap_get_module_config(r->server->module_config, &core_module);\n        if (conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE) {\n            r->headers_in = apr_table_overlay(r->pool, r->headers_in, r->trailers_in);\n        }\n    }\n    goto cleanup;\n}', 'explanation': 'Upon reaching the end of the stream, this segment examines the separate trailer data and, if merging is enabled by configuration, merges it into the main header table (r->headers_in). This implements the alternate action specified by the RFC.'}}]","The function clearly implements both parts of the RFC requirement for handling trailer fields. It stores the received trailer fields separately (C1) and then, based on a configuration flag, merges them into the header section (A1). This fulfills the requirement that a recipient must either store/forward the trailer fields separately or merge them into the header section.",success,
12259,ap_http_filter,A recipient that removes the chunked coding from a message MAY selectively retain or discard the received trailer fields.,205,Fully Matches,"[{'C1': {'code': 'if (AP_BUCKET_IS_HEADERS(e)) {\n    /* trailers */\n    ap_bucket_headers * hdrs = e->data;\n\n    /* Allow multiple HEADERS buckets carrying trailers here,\n     * will not happen from HTTP/1.x and current H2 implementation,\n     * but is an option. */\n    ctx->at_trailers = 1;\n    if (!apr_is_empty_table(hdrs->headers)) {\n        r->trailers_in = apr_table_overlay(r->pool, r->trailers_in, hdrs->headers);\n    }\n    apr_bucket_delete(e);\n}', 'explanation': 'This code segment detects trailer buckets and preserves the trailer fields by storing them separately in r->trailers_in, which aligns with the RFC requirement to retain trailer fields separately from header fields.'}}, {'A1': {'code': 'if (APR_BUCKET_IS_EOS(e)) {\n    ctx->at_eos = 1;\n    if (!apr_is_empty_table(r->trailers_in)) {\n        core_server_config *conf = ap_get_module_config(r->server->module_config, &core_module);\n        if (conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE) {\n            r->headers_in = apr_table_overlay(r->pool, r->headers_in, r->trailers_in);\n        }\n    }\n    goto cleanup;\n}', 'explanation': 'This segment conditionally merges the stored trailer fields into the header section if allowed by the configuration. It follows the RFC guidance that merging of trailers should only occur when explicitly permitted.'}}]","The function processes chunked message trailers by first detecting and storing trailers in a separate table (r->trailers_in) and then, upon reaching the end of the stream, optionally merging them into the header fields (r->headers_in) based on configuration. This logic directly implements the RFC specification that a recipient may selectively retain or discard trailer fields, and if retained, must handle them separately or merge them under controlled conditions.",success,
12259,ap_http_filter,"* A server MAY omit sending a 100 (Continue) response if it has already received some or all of the content for the corresponding request, or if the framing indicates that there is no content.",81,Fully Matches,"[{'C1': {'code': 'if (block == APR_BLOCK_READ\n        && r->expecting_100 && r->proto_num >= HTTP_VERSION(1,1)\n        && !(ctx->at_eos || r->eos_sent || r->bytes_sent)) {', 'explanation': 'This conditional ensures that only HTTP/1.1 (or higher) requests that are blocking and have the 100-continue expectation set will be evaluated for sending an interim 100 response. It also confirms that no end-of-stream conditions have been met yet.'}}, {'A1': {'code': 'else if (!ctx->seen_data) {\n    int saved_status = r->status;\n    const char *saved_status_line = r->status_line;\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                  ""ap_http_in_filter: sending 100-continue"");\n    r->status = HTTP_CONTINUE;\n    r->status_line = NULL;\n    ap_send_interim_response(r, 0);\n    AP_DEBUG_ASSERT(!r->expecting_100);\n    r->status_line = saved_status_line;\n    r->status = saved_status;\n}', 'explanation': 'This segment sends a 100 (Continue) interim response when no request body data has yet been read, fulfilling the action of sending an interim response as required when the conditions allow it.'}}, {'A2': {'code': 'else {\n    /* https://tools.ietf.org/html/rfc7231#section-5.1.1\n     *   A server MAY omit sending a 100 (Continue) response if it\n     *   has already received some or all of the message body for\n     *   the corresponding request [...] \n     */\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(10260)\n                  ""request body already/partly received while ""\n                  ""100-continue is expected, omit sending interim ""\n                  ""response"");\n    r->expecting_100 = 0;\n}', 'explanation': ""If some or all of the request body has already been received (indicated by ctx->seen_data being true), this block logs and then omits sending the interim 100 response, directly aligning with the RFC's allowance to omit the 100-continue response.""}}]","The provided function inspects whether it should send a 100 (Continue) interim response by checking if the request is using HTTP/1.1 or higher, whether the 100-continue expectation is set, and whether any request body data has been received. If no data has been read, it sends a 100 response; otherwise, it omits the response as permitted by the RFC. This implementation directly addresses the conditions and actions outlined in the RFC specification.",success,
12259,ap_http_filter,The origin server MUST NOT wait for the content before sending the 100 (Continue) response.,84,Fully Matches,"[{'C1': {'code': 'if (block == APR_BLOCK_READ && r->expecting_100 && r->proto_num >= HTTP_VERSION(1,1) && !(ctx->at_eos || r->eos_sent || r->bytes_sent)) { ... }', 'explanation': 'The function checks if the request has a 100-continue expectation (r->expecting_100), is using a blocking read, and that no part of the request body has been sent or received (using ctx->at_eos, r->eos_sent, and r->bytes_sent). This meets the condition that the server should be ready to send 100 (Continue) immediately without waiting for the content.'}}, {'A1': {'code': 'else if (!ctx->seen_data) { ... r->status = HTTP_CONTINUE; r->status_line = NULL; ap_send_interim_response(r, 0); ... }', 'explanation': 'Once the conditions are satisfied and no part of the body has been received (i.e., !ctx->seen_data), the function immediately sends a 100 (Continue) response using ap_send_interim_response. This fulfills the RFC action requirement to not wait for the content before sending the 100 response.'}}]","The code function implements the RFC specification by immediately sending a 100 (Continue) response when the conditions are met, without waiting for any part of the request body to be received. The checks and subsequent call to ap_send_interim_response within the function directly address the spec constraint.",success,
12259,ap_http_filter,"At the end of a message, a recipient MAY treat the set of received trailer fields as a data structure of name/value pairs, similar to (but separate from) the header fields.",14,Fully Matches,"[{'C1': {'code': 'if (AP_BUCKET_IS_HEADERS(e)) {\n    /* trailers */\n    ap_bucket_headers * hdrs = e->data;\n\n    /* Allow multiple HEADERS buckets carrying trailers here, ... */\n    ctx->at_trailers = 1;\n    if (!apr_is_empty_table(hdrs->headers)) {\n        r->trailers_in = apr_table_overlay(r->pool, r->trailers_in, hdrs->headers);\n    }\n    apr_bucket_delete(e);\n}\n...\nif (APR_BUCKET_IS_EOS(e)) {\n    ctx->at_eos = 1;\n    if (!apr_is_empty_table(r->trailers_in)) {\n        core_server_config *conf = ap_get_module_config(r->server->module_config, &core_module);\n        if (conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE) {\n            r->headers_in = apr_table_overlay(r->pool, r->headers_in, r->trailers_in);\n        }\n    }\n    goto cleanup;\n}', 'explanation': 'The RFC states that at the end of a message, trailer fields may be treated as a separate set of name/value pairs. The code above detects HEADER buckets that represent trailers, stores them in a separate table (r->trailers_in), and conditionally merges them with headers based on configuration. This behavior clearly implements the separation and processing of trailer fields as prescribed by the RFC.'}}]","The function inspects incoming data buckets to detect trailer header fields (using AP_BUCKET_IS_HEADERS) and handles them by placing them into a distinct structure (r->trailers_in). Later, when an EOS bucket is encountered, it optionally overlays these trailer fields onto the main headers if enabled by configuration. This logic directly addresses the RFC's requirement to treat trailer fields as a separate data structure at the end of a message, showing that the function alone attempts to implement the RFC specification.",success,
12260,ap_h1_body_in_filter,A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 (Not Implemented).,195,Fully Matches,"[{'C1': {'code': 'if (tenc) {\n    if (ap_is_chunked(f->r->pool, tenc)) {\n        ctx->state = BODY_CHUNK;\n    }\n    else if (f->r->proxyreq == PROXYREQ_RESPONSE) {\n        /* ... use read-until-close for proxy responses */\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02555)\n                      ""Unknown Transfer-Encoding: %s; using read-until-close"", tenc);\n        tenc = NULL;\n    }\n    else {\n        /* Unknown Transfer-Encoding; adhere to RFC to signal 501 */\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)\n                      ""Unknown Transfer-Encoding: %s"", tenc);\n        ap_die(HTTP_NOT_IMPLEMENTED, f->r);\n        return APR_EGENERAL;\n    }\n    lenp = NULL;\n}', 'explanation': ""This code first checks if the request has a Transfer-Encoding header (tenc). If present and not recognized (i.e. not 'chunked' and not a proxied response), it logs the error and calls 'ap_die' with HTTP_NOT_IMPLEMENTED. This directly addresses the RFC specification that a server should respond with 501 (Not Implemented) when it receives a transfer coding it does not understand.""}}]","The function inspects the Transfer-Encoding header in incoming requests. When the value of Transfer-Encoding is not 'chunked' (and the request is not a proxied response), the function logs the issue and terminates the request with a 501 error. This behavior directly implements the specification requirement, thereby fully matching the labeled constraint.",success,
12260,ap_h1_body_in_filter,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'tenc = apr_table_get(f->r->headers_in, ""Transfer-Encoding"");\nlenp = apr_table_get(f->r->headers_in, ""Content-Length"");\n\nif (tenc) {\n    if (ap_is_chunked(f->r->pool, tenc)) {\n        ctx->state = BODY_CHUNK;\n    } else if (f->r->proxyreq == PROXYREQ_RESPONSE) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02555)\n                      ""Unknown Transfer-Encoding: %s; using read-until-close"", tenc);\n        tenc = NULL;\n    } else {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)\n                      ""Unknown Transfer-Encoding: %s"", tenc);\n        ap_die(HTTP_NOT_IMPLEMENTED, f->r);\n        return APR_EGENERAL;\n    }\n    lenp = NULL;\n}\nif (lenp) {\n    ctx->state = BODY_LENGTH;\n    ... /* Content-Length processing code */\n}', 'explanation': ""This segment checks for a Transfer-Encoding header and, if present, nullifies the Content-Length header (by setting 'lenp' to NULL). This directly ensures that the Content-Length header is ignored when a Transfer-Encoding header is included, thereby conforming to the RFC specification that a sender MUST NOT send a Content-Length header when Transfer-Encoding is present.""}}]","The function inspects the incoming headers and, upon detecting a Transfer-Encoding header, explicitly disregards any Content-Length header by setting it to NULL. This behavior fully implements the RFC requirement that forbids the inclusion of a Content-Length header when a Transfer-Encoding header is present.",success,
12260,ap_h1_body_in_filter,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n    ctx->remaining = 0;\n    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)\n                  ""Invalid Content-Length"");\n    return APR_EINVAL;\n}\n\nif (tenc) {\n    if (ap_is_chunked(f->r->pool, tenc)) {\n        ctx->state = BODY_CHUNK;\n    } else if (f->r->proxyreq == PROXYREQ_RESPONSE) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02555)\n                      ""Unknown Transfer-Encoding: %s; using read-until-close"", tenc);\n        tenc = NULL;\n    } else {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)\n                      ""Unknown Transfer-Encoding: %s"", tenc);\n        ap_die(HTTP_NOT_IMPLEMENTED, f->r);\n        return APR_EGENERAL;\n    }\n}', 'explanation': 'The function defensively parses incoming protocol elements by rigorously checking the validity of headers such as Content-Length and Transfer-Encoding. It uses strict parsing (ap_parse_strict_length) and validates the transfer encoding, ensuring that only marginal conformance is assumed.'}}, {'A1': {'code': 'if (ctx->limit && ctx->limit < ctx->remaining) {\n    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r,\n                  APLOGNO(01588) ""Requested content-length of %"" APR_OFF_T_FMT\n                  "" is larger than the configured limit of %"" APR_OFF_T_FMT,\n                  ctx->remaining, ctx->limit);\n    return APR_ENOSPC;\n}', 'explanation': 'The function enforces a reasonable buffer size by comparing the reported Content-Length against a preconfigured limit. If the incoming request exceeds the limit, it logs an error and aborts processing, ensuring robust, defensive behavior.'}}]","The provided function implements defensive parsing as recommended by the RFC. It applies strict parsing to critical header fields (such as Content-Length) and checks for acceptable transfer encodings. Additionally, it verifies that the incoming body does not exceed a predefined size limit, thereby handling the protocol element in a defensive manner. All these measures are implemented within the function itself, ensuring it fully addresses the key points of the RFC specification.",success,
12260,ap_h1_body_in_filter,A recipient MUST be able to parse and decode the chunked transfer coding.,204,Fully Matches,"[{'C1': {'code': 'tenc = apr_table_get(f->r->headers_in, ""Transfer-Encoding"");\nif (tenc) {\n    if (ap_is_chunked(f->r->pool, tenc)) {\n        ctx->state = BODY_CHUNK;\n    } ...', 'explanation': 'The function checks for the Transfer-Encoding header and, if it indicates chunked encoding, sets the internal state (BODY_CHUNK) to trigger chunked processing. This addresses the requirement that a recipient must be able to parse and decode chunked transfer coding as specified in the RFC.'}}, {'A1': {'code': 'rv = parse_chunk_size(ctx, buffer, len, f->r->server->limit_req_fieldsize, strict);\nif (rv != APR_SUCCESS) {\n    ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, f->r, ... ""Error reading/parsing chunk %s "", (APR_ENOSPC == rv) ? ""(overflow)"" : """");\n    return rv;\n}', 'explanation': 'This segment calls parse_chunk_size with parameters that include a field size limit and a strict flag to properly parse hexadecimal chunk sizes. It also checks for errors (including potential overflows or precision issues) and logs an error if parsing fails, thereby preventing parsing errors related to integer conversion overflows or precision loss.'}}]","The function explicitly handles HTTP chunked transfer coding by examining the Transfer-Encoding header and setting a state machine to process chunks. It retrieves the chunk-size (hexadecimal numeral) and passes it to parse_chunk_size which is configured to reject invalid or overly large values. By managing state transitions (including trailer processing and detecting end-of-stream), the function directly implements the RFC requirement that a recipient must be able to parse and decode chunked transfer coding while safeguarding against potential integer parsing issues.",success,
12260,ap_h1_body_in_filter,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'tenc = apr_table_get(f->r->headers_in, ""Transfer-Encoding"");\nlenp = apr_table_get(f->r->headers_in, ""Content-Length"");\n\nif (tenc) {\n    if (ap_is_chunked(f->r->pool, tenc)) {\n        ctx->state = BODY_CHUNK;\n    }\n    else if (f->r->proxyreq == PROXYREQ_RESPONSE) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02555)\n                      ""Unknown Transfer-Encoding: %s; using read-until-close"", tenc);\n        tenc = NULL;\n    }\n    else {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)\n                      ""Unknown Transfer-Encoding: %s"", tenc);\n        ap_die(HTTP_NOT_IMPLEMENTED, f->r);\n        return APR_EGENERAL;\n    }\n    lenp = NULL;\n}\nif (lenp) {\n    ctx->state = BODY_LENGTH;\n    if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n        ctx->remaining = 0;\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)\n                      ""Invalid Content-Length"");\n        return APR_EINVAL;\n    }\n    if (ctx->limit && ctx->limit < ctx->remaining) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01588)\n                      ""Requested content-length of %"" APR_OFF_T_FMT "" is larger than the configured limit of %"" APR_OFF_T_FMT,\n                      ctx->remaining, ctx->limit);\n        return APR_ENOSPC;\n    }\n}', 'explanation': 'This segment inspects the Transfer-Encoding and Content-Length headers to determine how the HTTP body should be interpreted, which aligns with the specification that a recipient must interpret the received protocol element according to its semantics.'}}, {'A1': {'code': 'if (ctx->state == BODY_LENGTH && ctx->remaining == 0) {\n    e = apr_bucket_eos_create(f->c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(b, e);\n    ctx->at_eos = 1;\n}', 'explanation': 'This code creates an end-of-stream marker (EOS) when the content-length has been fully read, an action that helps in recovering a usable protocol element even if no more data remains.'}}]","The function implements logic to interpret HTTP message bodies by examining the Transfer-Encoding and Content-Length headers in line with the RFC requirement that a recipient must interpret a received protocol element according to its defined semantics. It distinguishes between proper chunked encoding and other cases by logging errors or terminating the connection. Additionally, it attempts to recover valid states by generating an EOS when the body has been completely read. However, while these measures address part of the RFC’s requirements, other aspects (such as full extensibility for handling invalid constructs or additional error recovery strategies) appear to be either handled in other parts of the system or are not explicitly covered within this function, resulting in a partial match.",success,
12260,ap_h1_body_in_filter,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n    ctx->remaining = 0;\n    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)\n                  ""Invalid Content-Length"");\n    return APR_EINVAL;\n}', 'explanation': 'This segment validates the Content-Length header and, upon detecting an invalid construct, logs the issue and aborts the processing. It reflects an attempt to recover (or at least fail gracefully) from an invalid request element per the RFC note that a recipient MAY try to recover a usable protocol element.'}}, {'A1': {'code': 'if (tenc) {\n    if (ap_is_chunked(f->r->pool, tenc)) {\n        ctx->state = BODY_CHUNK;\n    }\n    else if (f->r->proxyreq == PROXYREQ_RESPONSE) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02555)\n                      ""Unknown Transfer-Encoding: %s; using read-until-close"", tenc);\n        tenc = NULL;\n    }\n    else {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)\n                      ""Unknown Transfer-Encoding: %s"", tenc);\n        ap_die(HTTP_NOT_IMPLEMENTED, f->r);\n        return APR_EGENERAL;\n    }\n    lenp = NULL;\n}', 'explanation': ""This code detects the Transfer-Encoding header. It properly sets the state to handle 'chunked' encoding and, for non-chunked encodings in non-proxy responses, it logs the error and aborts. This selective recovery aligns with the RFC's guideline that error recovery is allowed though not mandatory in every circumstance.""}}]","The function implements error-handling logic that partially meets the RFC's guidance of attempting to recover from invalid constructs. For instance, it parses the Content-Length header strictly and handles valid chunked Transfer-Encoding as well as certain fallbacks (such as read-until-close for proxy responses). However, in some cases (like unsupported Transfer-Encoding in non-proxy responses) it deliberately aborts processing rather than recovering. This means that while some aspects of the spec constraints are addressed within the function itself, not all error cases are recovered, yielding a partial match.",success,
12260,ap_h1_body_in_filter,"If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value).",201,Partially Matches,"[{'C1': {'code': 'if (lenp) {\n    ctx->state = BODY_LENGTH;\n    if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n        ctx->remaining = 0;\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)\n                      ""Invalid Content-Length"");\n        return APR_EINVAL;\n    }\n    ...\n}', 'explanation': 'This segment checks for the presence of a Content-Length header. In the absence of Transfer-Encoding and if the Content-Length value fails strict parsing (indicating an invalid header field), the code logs an error and returns an error status (APR_EINVAL), thereby treating the framing as invalid. However, it does not attempt to parse a comma‐separated list as allowed by the RFC when all values are identical.'}}]","The function implements logic that addresses the case where a message is received without a Transfer-Encoding header and with an invalid Content-Length header by strictly parsing the Content-Length value and returning an error if the parsing fails. This corresponds to the RFC requirement for treating such messages as framing errors. However, the RFC specifies an exception: if the header value can be parsed as a comma-separated list, and all values are valid and identical, then the message should be processed. The function does not implement this exception, and therefore only partially matches the RFC specification.",success,
12260,ap_h1_body_in_filter,A recipient MUST be able to parse the chunked transfer coding (Section 7.1) because it plays a crucial role in framing messages when the content size is not known in advance.,187,Fully Matches,"[{'C1': {'code': 'tenc = apr_table_get(f->r->headers_in, ""Transfer-Encoding"");\nif (tenc) {\n    if (ap_is_chunked(f->r->pool, tenc)) {\n        ctx->state = BODY_CHUNK;\n    } else if (f->r->proxyreq == PROXYREQ_RESPONSE) {\n        // Log and use read-until-close logic\n        ap_log_rerror(..., ""Unknown Transfer-Encoding: %s; using read-until-close"", tenc);\n        tenc = NULL;\n    } else {\n        ap_log_rerror(..., ""Unknown Transfer-Encoding: %s"", tenc);\n        ap_die(HTTP_NOT_IMPLEMENTED, f->r);\n        return APR_EGENERAL;\n    }\n    lenp = NULL;\n}\n...\n\nswitch (ctx->state) {\n    case BODY_CHUNK:\n    case BODY_CHUNK_PART:\n    case BODY_CHUNK_EXT:\n    case BODY_CHUNK_CR:\n    case BODY_CHUNK_LF:\n    case BODY_CHUNK_END:\n    case BODY_CHUNK_END_LF: {\n        rv = ap_get_brigade(f->next, b, AP_MODE_GETLINE, block, 0);\n        ...\n        rv = parse_chunk_size(ctx, buffer, len, f->r->server->limit_req_fieldsize, strict);\n        ...\n        if (ctx->state == BODY_CHUNK_TRAILER) {\n            return read_chunked_trailers(ctx, f, b);\n        }\n        break;\n    }\n    ...\n}', 'explanation': ""The function reads the Transfer-Encoding header and, if it contains 'chunked', sets the state to process chunked encoding. The state machine implemented via the switch-case (with states like BODY_CHUNK, BODY_CHUNK_PART, and handling of trailers) demonstrates that the function is explicitly designed to parse and handle chunked transfer coding as required by the HTTP RFC.""}}]","The code function clearly implements the ability to parse chunked transfer coding by checking for the 'Transfer-Encoding' header and processing the message in a state machine tailored for various parts of a chunked message (e.g., chunk size, chunk data, trailers). This directly addresses the spec requirement that a recipient MUST be able to handle chunked transfer coding when the content size is not known in advance. All the necessary logic for parsing and delineating the chunk boundaries is handled within this function, thereby fully matching the specification.",success,
12260,ap_h1_body_in_filter,"Since there is no predefined limit to the length of content, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer conversion (Section 17.5).",261,Fully Matches,"[{'C1': {'code': 'if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n    ctx->remaining = 0;\n    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587) ""Invalid Content-Length"");\n    return APR_EINVAL;\n}', 'explanation': 'This segment validates the Content-Length header strictly by calling ap_parse_strict_length, which according to the comment protects against numeric under/overflow, non-digit characters, and improper formatting. This directly addresses the RFC requirement to prevent parsing errors caused by large decimal numerals and integer conversion issues.'}}]","The function contains explicit logic to validate the Content-Length header by enforcing a strict integer parsing routine, which is intended to prevent overflow or precision loss in conversion, exactly as required by the RFC. This logic is implemented directly within the function_body, so the function visibly addresses the spec's constraint.",success,
12260,ap_h1_body_in_filter,"Since there is no predefined limit to the length of content, recipients MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows.",285,Fully Matches,"[{'C1': {'code': 'if (lenp) {\n    ctx->state = BODY_LENGTH;\n\n    /* Protects against over/underflow, non-digit chars in the\n     * string, leading plus/minus signs, trailing characters and\n     * a negative number.\n     */\n    if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n        ctx->remaining = 0;\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)\n                      ""Invalid Content-Length"");\n        return APR_EINVAL;\n    }\n\n    /* If we have a limit in effect and we know the C-L ahead of\n     * time, stop it here if it is invalid.\n     */\n    if (ctx->limit && ctx->limit < ctx->remaining) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01588)\n                      ""Requested content-length of %"" APR_OFF_T_FMT\n                      "" is larger than the configured limit of %"" APR_OFF_T_FMT,\n                      ctx->remaining, ctx->limit);\n        return APR_ENOSPC;\n    }\n}', 'explanation': 'This code segment strictly parses the Content-Length header (a potentially very large decimal numeral) using the function ap_parse_strict_length. It checks for overflow, non-digit characters, and other invalid input, thereby preventing integer conversion errors as required by the spec.'}}]",The target function directly implements logic to safely handle and validate large decimal numeral values in the Content-Length header by using a strict parsing function. This properly addresses the RFC specification requirement to anticipate potentially large values and prevent integer conversion overflows within the function itself.,success,
12260,ap_h1_body_in_filter,"If the sender closes the connection or the recipient times out before the indicated number of octets are received, the recipient MUST consider the message to be incomplete and close the connection",303,Fully Matches,"[{'C1': {'code': 'if (rv == APR_EOF && ctx->state != BODY_NONE\n        && ctx->remaining > 0) {\n            return APR_INCOMPLETE;\n        }', 'explanation': 'This code snippet checks for the case when an EOF is received (i.e. the sender closed the connection) but there are still remaining bytes expected (as defined by Content-Length). By returning APR_INCOMPLETE, the function signals that the message is incomplete as required by the RFC.'}}]","The function explicitly implements logic to detect if the connection is closed before the entire expected body has been received. In particular, it returns APR_INCOMPLETE in cases where an EOF occurs while data is still expected, which is in line with the RFC requirement to treat such messages as incomplete and close the connection. This logic is contained within the function itself, not deferred to any dependencies, and thus it fully meets the specified constraint.",success,
12260,ap_h1_body_in_filter,"Therefore, recipients MUST anticipate potentially large hexadecimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer representation.",305,Fully Matches,"[{'C1': {'code': 'if (lenp) {\n    ctx->state = BODY_LENGTH;\n\n    /* Protects against over/underflow, non-digit chars in the\n     * string, leading plus/minus signs, trailing characters and\n     * a negative number.\n     */\n    if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n        ctx->remaining = 0;\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)\n                      ""Invalid Content-Length"");\n\n        return APR_EINVAL;\n    }\n    ...\n}\n\n...\n\nrv = parse_chunk_size(ctx, buffer, len,\n        f->r->server->limit_req_fieldsize, strict);\nif (rv != APR_SUCCESS) {\n    ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, f->r, APLOGNO(01590)\n                  ""Error reading/parsing chunk %s "",\n                  (APR_ENOSPC == rv) ? ""(overflow)"" : """");\n    return rv;\n}', 'explanation': 'The function uses a strict parsing function for Content-Length and calls parse_chunk_size for chunked transfer coding. Both approaches include checks to prevent integer conversion overflows or imprecise representation when handling potentially large hexadecimal numerals.'}}]","The code function directly addresses the RFC requirement by employing strict numeric conversion routines to parse Content-Length and chunk sizes. This prevents overflows and loss of precision when handling large hexadecimal numbers, thereby fully matching the specified condition (C1) from the RFC.",success,
12261,check_header,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'A1': {'code': 'for (pos = *val; *pos; pos = end) {\n    end = ap_scan_http_field_content(pos);\n    if (*end) {\n        if (end[0] != CR || end[1] != LF || (end[2] != \' \' && end[2] != \'\\t\')) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                          ""Response header \'%s\' value of \'%s\' contains ""\n                          ""invalid characters, aborting request"",\n                          name, pos);\n            return 0;\n        }\n        if (!dst) {\n            *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n        }\n    }\n    if (dst) {\n        memcpy(dst, pos, end - pos);\n        dst += end - pos;\n        if (*end) {\n            /* skip folding and replace with a single space */\n            end += 3 + strspn(end + 3, ""\\t "");\n            *dst++ = \' \';\n        }\n    }\n}', 'explanation': 'The code explicitly scans the header value for folded lines (indicated by a CRLF followed by a space or tab) and removes the line break by replacing the entire fold sequence with a single space. This directly implements the specification that requires parsing for bad whitespace and removing it before interpretation.'}}]","The function 'check_header' processes HTTP header values by iterating through the text and detecting folded whitespace. When it finds a CRLF followed by a space or tab, it skips over the folded segment and replaces it with a single space. This fulfills the RFC requirement that the recipient must remove bad whitespace (i.e. replace OWS/RWS with a single SP) before interpreting the protocol element. All of this logic is contained within the function itself, thereby fully matching the specified constraint.",success,
12261,check_header,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'A1': {'code': 'for (pos = *val; *pos; pos = end) {\n    end = ap_scan_http_field_content(pos);\n    if (*end) {\n        if (end[0] != CR || end[1] != LF || (end[2] != \' \' && end[2] != \'\\t\')) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                          ""Response header \'%s\' value of \'%s\' contains invalid characters, aborting request"",\n                          name, pos);\n            return 0;\n        }\n        if (!dst) {\n            *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n        }\n    }\n    if (dst) {\n        memcpy(dst, pos, end - pos);\n        dst += end - pos;\n        if (*end) {\n            /* skip folding and replace with a single space */\n            end += 3 + strspn(end + 3, ""\\t "");\n            *dst++ = \' \';\n        }\n    }\n}\nif (dst) {\n    *dst = \'\\0\';\n}\nreturn 1;', 'explanation': 'The RFC requires that any folding whitespace (such as a CRLF followed by SP or HTAB) in header field values be excluded before the header value is evaluated. This code checks if after scanning the header field content it encounters a CRLF followed immediately by a space or tab. It then skips over the folding sequence and replaces it by inserting a single space in the output, effectively removing the original folding whitespace. This behavior fully implements the specified requirement.'}}]","The function processes the header value by scanning through its content and detecting any CRLF followed by SP or HTAB, which is indicative of folded whitespace. Upon finding such a sequence, it skips over the folding whitespace and inserts a single space in its place. This normalization of the header value ensures that any extraneous whitespace as allowed in some HTTP versions is removed prior to further evaluation. Since this behavior directly addresses the requirement stated in the RFC, the function fully matches the specified constraint within its own logic.",success,
12261,check_header,"A recipient of ""message/http"" data MUST replace any obsolete line folding with one or more SP characters when the message is consumed.",213,Fully Matches,"[{'A1': {'code': 'if (*end) {\n                /* skip folding and replace with a single space */\n                end += 3 + strspn(end + 3, ""\\t "");\n                *dst++ = \' \';\n            }', 'explanation': 'This code block detects the obsolete line folding sequence (CRLF followed by a space or horizontal tab) and replaces it with a single space, thereby fulfilling the RFC requirement that any obs-fold must be replaced with one or more SP characters.'}}]","The function iterates over the header value and, upon encountering a folding sequence, it validates the sequence and then replaces the entire sequence with a single space. This directly addresses the RFC mandate on processing obsolete line folding in 'message/http' data. All logic necessary for this behavior is contained within this function, meaning it fully matches the specified requirement.",success,
12261,check_header,"A server that receives an obs-fold in a request message that is not within a ""message/http"" container MUST either reject the message by sending a 400 (Bad Request), preferably with a representation explaining that obsolete line folding is unacceptable, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.",186,Fully Matches,"[{'C1': {'code': 'for (pos = *val; *pos; pos = end) {\n    end = ap_scan_http_field_content(pos);\n    if (*end) {\n        if (end[0] != CR || end[1] != LF || (end[2] != \' \' && end[2] != \'\\t\')) {\n            ap_log_rerror(..., ""Response header \'%s\' value of \'%s\' contains invalid characters, aborting request"", name, pos);\n            return 0;\n        }\n        ...\n    }\n    ...\n}', 'explanation': 'This segment checks for an obs-fold in a header value by scanning for a CRLF sequence followed by a space or horizontal tab. If the sequence is not valid (i.e. not CRLF followed by SP or HT), the function logs an error and rejects the message, thereby fulfilling the RFC’s condition to reject invalid obs-fold usage.'}}, {'A1': {'code': 'if (dst) {\n    memcpy(dst, pos, end - pos);\n    dst += end - pos;\n    if (*end) {\n        /* skip folding and replace with a single space */\n        end += 3 + strspn(end + 3, ""\\t "");\n        *dst++ = \' \';\n    }\n}\nif (dst) {\n    *dst = \'\\0\';\n}', 'explanation': 'This code replaces each valid obs-fold with a single space (SP), which is compliant with the RFC requirement to replace each received obs-fold with one or more SP octets before further interpretation.'}}]","The function 'check_header' examines header names and values, and specifically handles the obs-fold scenario. It verifies that any folding in header values follows the acceptable format — a CRLF immediately followed by a space or horizontal tab — and if not, it aborts processing (rejects the message with an error log). For valid folded lines, the function strips the CRLF and replaces the fold with a single space. This approach fully meets the specified requirement from the RFC that a server must either reject a message with an obs-fold or replace it before further processing.",success,
12261,check_header,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': 'if (*end) {\n    if (end[0] != CR || end[1] != LF || (end[2] != \' \' && end[2] != \'\\t\')) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                      ""Response header \'%s\' value of \'%s\' contains invalid characters, aborting request"",\n                      name, pos);\n        return 0;\n    }', 'explanation': 'This segment validates that whenever there is additional content after scanning a header field, it must follow the folding rule (CRLF followed by a space or horizontal tab). This ensures that improper whitespace is detected and rejected, addressing the detection part of the BWS specification.'}}, {'A1': {'code': 'if (dst) {\n    memcpy(dst, pos, end - pos);\n    dst += end - pos;\n    if (*end) {\n        /* skip folding and replace with a single space */\n        end += 3 + strspn(end + 3, ""\\t "");\n        *dst++ = \' \';\n    }\n}\nif (dst) {\n    *dst = \'\\0\';\n}', 'explanation': 'This segment allocates a new buffer (if needed) and, upon encountering a valid folding indicator (CRLF followed by space/tab), it skips the folded whitespace and replaces it with a single space. This directly implements the action of removing or normalizing BWS as per the HTTP RFC.'}}]","The function 'check_header' processes header names and values. For header values, it scans for folding whitespace (BWS) sequences and replaces them with a single space. The code both detects invalid BWS (by checking that any CRLF is correctly followed by a space or tab) and then removes unnecessary whitespace. This behavior directly addresses the RFC requirement that any content defined as BWS may be removed before further processing, hence the function fully matches the intended spec constraints.",success,
12261,check_header,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Fully Matches,"[{'C1': {'code': 'if (*end) {\n    if (end[0] != CR || end[1] != LF || (end[2] != \' \' &&\n                                   end[2] != \'\\t\')) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                      ""Response header \'%s\' value of \'%s\' contains ""\n                      ""invalid characters, aborting request"",\n                      name, pos);\n        return 0;\n    }\n    // ... additional processing follows\n}', 'explanation': 'This segment ensures that within the header value, whenever a CR is encountered it is immediately followed by an LF and then a space or tab. This check directly addresses the RFC specification that a sender MUST NOT generate a bare CR, and that any such occurrence should result in the element being rejected.'}}]","The function 'check_header' validates HTTP header names and values. In particular, the loop scanning the header value uses a check that invalidates any occurrence of a CR not immediately followed by an LF and a whitespace character. This behavior directly reflects the RFC requirement regarding bare CR characters in protocol elements (other than content), making the implementation fully match the specification in the context of header validation.",success,
12261,check_header,Any content known to be defined as OWS or RWS MAY be replaced with a single SP before interpreting it or forwarding the message downstream.,7,Fully Matches,"[{'A1': {'code': 'for (pos = *val; *pos; pos = end) {\n    end = ap_scan_http_field_content(pos);\n    if (*end) {\n        if (end[0] != CR || end[1] != LF || (end[2] != \' \' && end[2] != \'\\t\')) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                          ""Response header \'%s\' value of \'%s\' contains \n                          invalid characters, aborting request"",\n                          name, pos);\n            return 0;\n        }\n        if (!dst) {\n            *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n        }\n    }\n    if (dst) {\n        memcpy(dst, pos, end - pos);\n        dst += end - pos;\n        if (*end) {\n            /* skip folding and replace with a single space */\n            end += 3 + strspn(end + 3, ""\\t "");\n            *dst++ = \' \';\n        }\n    }\n}\nif (dst) {\n    *dst = \'\\0\';\n}', 'explanation': 'This segment of code identifies folded header lines (detecting CRLF followed by a single SP or horizontal tab) and replaces the entire folding sequence with a single space. This matches the RFC requirement that any occurrence of OWS/RWS in header values may be normalized to a single SP before further processing.'}}]","The function 'check_header' contains explicit logic to process header field contents so that any encountered folded linear whitespace (as defined by CRLF followed by SP or HTAB) is replaced with a single space. This behavior directly implements the RFC specification that permits replacing any OWS/RWS with a single SP before interpreting the message, and thus the function fully addresses the corresponding constraint.",success,
12261,check_header,A sender SHOULD generate RWS as a single SP.,6,Fully Matches,"[{'A1': {'code': 'if (*end) {\n    if (end[0] != CR || end[1] != LF || (end[2] != \' \' && end[2] != \'\\t\')) {\n        ...\n    }\n    if (!dst) {\n        *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n    }\n}\n... \nif (dst) {\n    memcpy(dst, pos, end - pos);\n    dst += end - pos;\n    if (*end) {\n        /* skip folding and replace with a single space */\n        end += 3 + strspn(end + 3, ""\\t "");\n        *dst++ = \' \';\n    }\n}\nif (dst) {\n    *dst = \'\\0\';\n}', 'explanation': 'This segment checks for the folded header line pattern (CRLF followed by SP or HTAB) and replaces it with a single space, which is in direct accordance with the RFC requirement for generating RWS as a single SP.'}}]","The function 'check_header' inspects header values, detects header line folding based on CRLF sequences followed by whitespace, and then replaces the folding (whether SP or HTAB) with a single space. This behavior directly implements the RFC requirement that a sender SHOULD generate RWS as a single SP. All logic to detect the folding and replace the whitespace is contained within the function, thereby fully addressing the labeled action A1 of the specification.",success,
12261,check_header,"Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message.",3,Fully Matches,"[{'C1': {'code': 'for (pos = *val; *pos; pos = end) {\n    end = ap_scan_http_field_content(pos);\n    if (*end) {\n        if (end[0] != CR || end[1] != LF || (end[2] != \' \' &&\n                                             end[2] != \'\\t\')) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                          ""Response header \'%s\' value of \'%s\' contains ""\n                          ""invalid characters, aborting request"",\n                          name, pos);\n            return 0;\n        }\n        if (!dst) {\n            *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n        }\n    }\n    if (dst) {\n        memcpy(dst, pos, end - pos);\n        dst += end - pos;\n        if (*end) {\n            /* skip folding and replace with a single space */\n            end += 3 + strspn(end + 3, ""\\t "");\n            *dst++ = \' \';\n        }\n    }\n}', 'explanation': 'This segment scans the header field content and detects occurrences of CR and LF. It verifies whether a CR is immediately followed by LF and then a space or horizontal tab (valid folding). If not, it rejects the header. This directly reflects the RFC requirement that any CR, LF, or NUL in a field value must either cause rejection of the message or be replaced with a space.'}}, {'A1': {'code': 'if (*end) {\n    /* skip folding and replace with a single space */\n    end += 3 + strspn(end + 3, ""\\t "");\n    *dst++ = \' \';\n}', 'explanation': 'This code explicitly replaces a valid folding sequence (CRLF followed by space/HTAB) with a single space, thereby implementing the normalization action described in the RFC.'}}]","The function checks header names and values to ensure they do not include dangerous characters such as CR, LF, or NUL unless they appear as part of valid header folding. It uses a scanning function to parse the field content, rejects headers when invalid sequences are found, and replaces valid folded sequences with a single space. This in-function logic directly implements the RFC requirement that any occurrence of these characters must result in either rejection or normalization of the header field value.",success,
12261,check_header,"Specifications for newly defined fields SHOULD limit their values to visible US-ASCII octets (VCHAR), SP, and HTAB",2,Partially Matches,"[{'A1': {'code': 'if (*end) {\n    if (end[0] != CR || end[1] != LF || (end[2] != \' \' && end[2] != \'\\t\')) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                      ""Response header \'%s\' value of \'%s\' contains ""\n                      ""invalid characters, aborting request"",\n                      name, pos);\n        return 0;\n    }\n    if (!dst) {\n        *val = dst = apr_palloc(ctx->r->pool, strlen(*val) + 1);\n    }\n}\n...\nif (dst) {\n    memcpy(dst, pos, end - pos);\n    dst += end - pos;\n    if (*end) {\n        /* skip folding and replace with a single space */\n        end += 3 + strspn(end + 3, ""\\t "");\n        *dst++ = \' \';\n    }\n}', 'explanation': 'This segment checks for folded header field lines (i.e. CRLF followed by either SP or HTAB) and replaces the folding sequence with a single space, thus directly implementing the action requiring replacement of folding whitespace with a single SP before further processing.'}}]","The function_body makes an effort to validate header names and values in accordance with HTTP field parsing requirements by calling scanning functions and applying logic to handle folded headers. In particular, it explicitly detects and replaces valid folding sequences (thus satisfying A1). However, the enforcement of limiting field values to visible US-ASCII octets (VCHAR), SP, and HTAB (as suggested by the RFC specification context) is not fully implemented within this function; it largely relies on external scanning functions such as ap_scan_http_token, ap_scan_vchar_obstext, and ap_scan_http_field_content. Therefore, while some of the constraints are addressed (notably the folding replacement action A1), the function does not fully implement all aspects of the RFC spec constraints on field content. This leads to the judgment of a ""Partially Matches"" outcome.",success,
12261,check_header,A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.,173,Fully Matches,"[{'C1': {'code': 'if (*end) {\n    if (end[0] != CR || end[1] != LF || (end[2] != \' \' && end[2] != \'\\t\')) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(02430)\n                      ""Response header \'%s\' value of \'%s\' contains invalid characters, aborting request"",\n                      name, pos);\n        return 0;\n    }', 'explanation': 'This segment checks that whenever a CR is encountered in the header field value, it must be immediately followed by an LF and then a white-space character (space or tab). If not, it considers the element invalid, as required by the RFC.'}}, {'A1': {'code': 'if (*end) {\n    ...\n    /* skip folding and replace with a single space */\n    end += 3 + strspn(end + 3, ""\\t "");\n    *dst++ = \' \';\n}', 'explanation': 'This code replaces a valid header folding sequence (CRLF followed by space/tab) with a single SP. This effectively transforms the folding into a single space, satisfying the alternative action in the RFC.'}}]","The function 'check_header' implements the RFC requirement for processing bare CR characters within header field values. It validates that any CR must be part of a CRLF followed by space/HT sequence. If not, it deems the element invalid (logging an error and aborting the request), and when valid, it replaces the CRLF folding with a single space. Thus, the function fully addresses the specified RFC constraint within its own code.",success,
12263,check_headers,A server MAY reject a request that contains both Content-Length and Transfer-Encoding or process such a request in accordance with the Transfer-Encoding alone.,198,Fully Matches,"[{'C1': {'code': 'if ((val = apr_table_get(r->headers_out, ""Transfer-Encoding""))) {\n    if (apr_table_get(r->headers_out, ""Content-Length"")) {\n        apr_table_unset(r->headers_out, ""Content-Length"");\n        r->connection->keepalive = AP_CONN_CLOSE;\n    }\n    ...', 'explanation': 'This segment checks if both Transfer-Encoding and Content-Length headers are present. When both are found, it removes the Content-Length header so that the Transfer-Encoding is used exclusively, as the spec permits.'}}, {'A1': {'code': 'if (!ap_is_chunked(r->pool, val)) {\n    r->connection->keepalive = AP_CONN_CLOSE;\n    return 0;\n}', 'explanation': ""This code ensures that if the Transfer-Encoding header does not signify a chunked transfer, the connection is forcibly closed. This complies with the spec's requirement to close the connection in such cases to avoid potential vulnerabilities.""}}]","The function properly implements the RFC's allowance to either reject or process requests that contain both Content-Length and Transfer-Encoding headers. It does so by removing the Content-Length header when both are present (thus processing the request according to the Transfer-Encoding header alone) and ensuring that the connection is closed afterward. All relevant logic is contained within the function, fully addressing the specified conditions and actions.",success,
12263,check_headers,"A server or client that receives an HTTP/1.0 message containing a Transfer-Encoding header field MUST treat the message as if the framing is faulty, even if a Content-Length is present, and close the connection after processing the message.",199,Partially Matches,"[{'C1': {'code': 'if ((val = apr_table_get(r->headers_out, ""Transfer-Encoding""))) { ... }', 'explanation': 'The function checks for the existence of a Transfer-Encoding header, which is related to the condition that a message with this header should be treated as having faulty framing.'}}, {'A1': {'code': 'if (apr_table_get(r->headers_out, ""Content-Length"")) {\n    apr_table_unset(r->headers_out, ""Content-Length"");\n    r->connection->keepalive = AP_CONN_CLOSE;\n}', 'explanation': ""When both Transfer-Encoding and Content-Length are present, the function removes the Content-Length header and forces the connection to close, which is in line with the RFC's requirement to treat the framing as faulty.""}}, {'A2': {'code': 'if (!ap_is_chunked(r->pool, val)) {\n    r->connection->keepalive = AP_CONN_CLOSE;\n    return 0;\n}', 'explanation': 'The function further checks if the Transfer-Encoding indicates chunked encoding. If not, it closes the connection, conforming to the need to treat the framing as faulty.'}}]","The provided function inspects the headers for a Transfer-Encoding field and, if found, removes any conflicting Content-Length header and closes the connection to handle potentially faulty framing. This is consistent with the RFC requirement that a message with a Transfer-Encoding header (especially problematic in HTTP/1.0) should be treated as having faulty framing and the connection then closed. However, the code does not explicitly check whether the message is HTTP/1.0, applying these actions to any message with a Transfer-Encoding header, which means it does not entirely capture the specificity of the spec. As a result, while the key actions are implemented, the function only partially matches the detailed requirements of the RFC.",success,
12263,check_headers,"If any transfer coding other than chunked is applied to a response's content, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection.",190,Fully Matches,"[{'C1': {'code': 'if ((val = apr_table_get(r->headers_out, ""Transfer-Encoding""))) {\n    if (apr_table_get(r->headers_out, ""Content-Length"")) {\n        apr_table_unset(r->headers_out, ""Content-Length"");\n        r->connection->keepalive = AP_CONN_CLOSE;\n    }\n    if (!ap_is_chunked(r->pool, val)) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n        return 0;\n    }\n}', 'explanation': ""This segment verifies that if a Transfer-Encoding header exists, then it checks if the transfer coding is not 'chunked' (via ap_is_chunked()). If it isn’t chunked, it forces the connection to close (by setting keepalive to AP_CONN_CLOSE) and returns an error value. This fulfills the RFC requirement that if any transfer coding other than chunked is used, the message must either end with chunked or the connection must be terminated.""}}]","The function explicitly inspects the Transfer-Encoding header and, if present, ensures that the encoding is 'chunked'. If it detects that the header indicates a transfer coding other than chunked (or if a Content-Length header is also present), it unsets the Content-Length header and forces the connection to close. This behavior directly implements the RFC specification that requires either chunked coding as the final transfer coding or message termination by closing the connection. All logic addressing the constraint is contained within this function, resulting in a fully matching implementation.",success,
12263,check_headers,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'if ((val = apr_table_get(r->headers_out, ""Transfer-Encoding""))) {\n    if (apr_table_get(r->headers_out, ""Content-Length"")) {\n        apr_table_unset(r->headers_out, ""Content-Length"");\n        r->connection->keepalive = AP_CONN_CLOSE;\n    }\n    ...\n}', 'explanation': 'This segment checks if a Transfer-Encoding header is present and, if so, looks for a Content-Length header, which it then removes. This directly enforces the RFC requirement that no message containing a Transfer-Encoding header should also include a Content-Length header.'}}, {'A1': {'code': 'apr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'This action explicitly removes the Content-Length header from the response when the Transfer-Encoding header is present, which is the exact behavior mandated by the RFC.'}}]","The function 'check_headers' inspects the outgoing headers and, upon detecting a Transfer-Encoding header, checks for and removes any existing Content-Length header. This behavior directly complies with the RFC that prohibits sending a Content-Length header in messages that include Transfer-Encoding. The code within the function is self-contained and fully addresses the RFC constraint, thereby fully matching the specified requirement.",success,
12263,check_headers,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'C1': {'code': 'if ((val = apr_table_get(r->headers_out, ""Transfer-Encoding""))) {\n    if (apr_table_get(r->headers_out, ""Content-Length"")) {\n        apr_table_unset(r->headers_out, ""Content-Length"");\n        r->connection->keepalive = AP_CONN_CLOSE;\n    }\n    if (!ap_is_chunked(r->pool, val)) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n        return 0;\n    }\n}', 'explanation': 'This block checks if a Transfer-Encoding header exists and, if so, removes any Content-Length header and takes additional action (closing the connection if the encoding is not chunked). This suggests an attempt to avoid forwarding a message with a potentially incorrect Content-Length header when a conflicting Transfer-Encoding is in use, partially addressing the RFC requirement.'}}]","The RFC requires that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect. The function attempts to implement this by inspecting outgoing headers: if a Transfer-Encoding header is present, it unconditionally removes any Content-Length header and, in one case, closes the connection if the encoding is not chunked. This prevents forwarding a message where Transfer-Encoding and Content-Length might conflict. However, the function does not handle other cases such as validating the Content-Length header value against its ABNF, or managing duplicate numeric values (e.g., ""42, 42"") as described in the spec. Therefore, while the function implements part of the spec condition (identified here as C1), it does not fully cover all aspects of the RFC constraint.",success,
12263,check_headers,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Partially Matches,"[{'A1': {'code': 'if ((val = apr_table_get(r->headers_out, ""Transfer-Encoding""))) {\n    if (apr_table_get(r->headers_out, ""Content-Length"")) {\n        apr_table_unset(r->headers_out, ""Content-Length"");\n        r->connection->keepalive = AP_CONN_CLOSE;\n    }\n    if (!ap_is_chunked(r->pool, val)) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n        return 0;\n    }\n}', 'explanation': ""This code segment detects when a Transfer-Encoding header is set and then removes any existing Content-Length header, closing the connection if the Transfer-Encoding is not 'chunked'. This approach helps avoid framing conflicts and partially implements the RFC guidance that a server should use encoding (or length-delimited messages) to clearly delimit message bodies. However, it does not cover other parts of the RFC such as handling invalid Content-Length values where no Transfer-Encoding is present.""}}]","The function partially implements the RFC constraints by addressing one aspect of message framing: ensuring that if the Transfer-Encoding header is present, any conflicting Content-Length header is removed and non‑chunked encoding results in connection closure. This mechanism helps enforce unambiguous message framing. However, the function does not cover other portions of the RFC—such as proper handling of invalid Content-Length headers in the absence of Transfer-Encoding or ensuring length-delimited messages when possible—so it only partially matches the specification.",success,
12266,uniq_field_values,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Does Not Match,[],"The provided function performs basic tokenization of a comma/whitespace-separated string and adds unique tokens to an array. However, it does not implement any explicit defensive parsing measures as described in the RFC specification. It does not validate the input against the ABNF grammar or check for reasonable buffer sizes, and it lacks explicit error handling or length limiting logic. Thus, no labeled constraints (e.g., C1 for defensive parsing or A1 for marginal expectations on format and length) are fully implemented within this function.",success,
12266,uniq_field_values,"In other words, a recipient MUST accept lists that satisfy the following syntax:",238,Fully Matches,"[{'C1': {'code': ""while (*e == ',' || apr_isspace(*e)) { ++e; }"", 'explanation': 'This loop skips over commas and spacing characters, effectively ignoring empty list elements as required by the spec.'}}, {'A1': {'code': 'for (i = 0, strpp = (char **) values->elts; i < values->nelts; ++i, ++strpp) {\n    if (*strpp && ap_cstr_casecmp(*strpp, start) == 0) {\n        break;\n    }\n}\nif (i == values->nelts) {\n    *(char **)apr_array_push(values) = start;\n}', 'explanation': 'This segment ensures that only unique non-empty tokens are added to the list, which aligns with the RFC’s expectation for handling merged values and avoiding counting empty tokens.'}}]","The function 'uniq_field_values' parses a comma-separated list, explicitly skips empty tokens, and collects only unique field values. These behaviors directly address the RFC requirement to accept lists while ignoring a reasonable number of empty list elements and handling merged values, thus the function fully implements the intended conditions and actions within its own scope.",success,
12267,fixup_vary,"In any production that uses the list construct, a sender MUST NOT generate empty list elements.",236,Does Not Match,[],"The provided function 'fixup_vary' processes the Vary header by collecting field name values, splitting comma‐separated values, and then concatenating them back into a single header. However, within its own logic there is no explicit handling or validation to ensure that no empty list elements are generated, as required by the specification. Although it invokes the 'uniq_field_values' callback, this external function is not part of the function body itself, and no code in 'fixup_vary' directly enforces the constraint that empty list elements must not be produced.",success,
12267,fixup_vary,"A recipient MAY combine multiple field lines within a field section that have the same field name into one field line, without changing the semantics of the message, by appending each subsequent field line value to the initial field line value in order, separated by a comma ("","") and optional whitespace (OWS, defined in Section 5.6.3).",231,Partially Matches,"[{'C1': {'code': 'if (varies->nelts > 0) {\n    apr_table_setn(r->headers_out, ""Vary"",\n                   apr_array_pstrcat(r->pool, varies, \',\'));\n}', 'explanation': 'This code block combines the multiple Vary header field values into one by concatenating them with a comma. This addresses the RFC specification to merge multiple header lines. However, it does not add the space after the comma (i.e. comma SP) as recommended for consistency, hence the match is only partial.'}}]","The function 'fixup_vary' extracts all Vary header values, splits them by commas, and then reassembles them into a single header using a comma as the delimiter. This implements the core idea of combining multiple headers into one. However, according to the spec context, the concatenation should use a comma followed by a space (comma SP) for consistency. Since the function uses only a comma, it only partially implements the RFC's recommendations.",success,
12267,fixup_vary,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Fully Matches,"[{'C1': {'code': 'apr_table_do(uniq_field_values, varies, r->headers_out, ""Vary"", NULL);', 'explanation': ""This line extracts all instances of the Vary header from the outgoing headers and uses the callback (uniq_field_values) to ensure that duplicate field names are not added repeatedly, aligning with the RFC's mandate that a sender MUST NOT generate multiple field lines with the same name (unless the field definition permits combining via commas).""}}, {'A1': {'code': 'if (varies->nelts > 0) {\n    apr_table_setn(r->headers_out, ""Vary"",\n                       apr_array_pstrcat(r->pool, varies, \',\'));\n}', 'explanation': 'This code recombines any collected unique Vary header values into a single, comma-separated string and replaces the old header fields with the unified value. This is in keeping with the specification that permits combining values into a comma‐separated list when the definition allows it.'}}]","The function fixup_vary visibly addresses the RFC requirement for handling duplicate header fields for Vary. It calls a callback (uniq_field_values) to collect unique field values and then recombines them into one header line using a comma separator, thereby ensuring that multiple 'Vary' header lines are not present as per the spec. All logic to perform this transformation is within this function, so it fully meets the specified constraint.",success,
12268,validate_status_line,"A server MUST send the space that separates the status-code from the reason-phrase even when the reason-phrase is absent (i.e., the status-line would end with the space).",300,Fully Matches,"[{'C1': {'code': 'if (len >= 4 && ! apr_isspace(r->status_line[3])) { ... }', 'explanation': 'This segment checks that if the status_line is longer than 3 characters, the fourth character (index 3) is a whitespace. This enforces that the space separator is present when a reason-phrase (or its placeholder) follows the three-digit status code.'}}, {'A1': {'code': 'if (len == 3) {\n    r->status_line = apr_pstrcat(r->pool, r->status_line, "" "", NULL);\n    return APR_EGENERAL;\n}', 'explanation': 'When the status_line is exactly three characters long (only the numeric status code), this code appends a trailing space, thereby meeting the RFC requirement to always include the space even when the reason-phrase is absent.'}}]","The function validate_status_line checks that the status_line contains the required trailing space separating the 3-digit status code from any reason-phrase. If the line is exactly three digits (i.e., without the space), it appends a space. In the case where the status_line is longer than 3 characters, it validates that the fourth character is a whitespace. These implementations directly fulfill the RFC mandate described in the specification.",success,
12268,validate_status_line,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (len < 3\n            || apr_strtoi64(r->status_line, &end, 10) != r->status\n            || (end - 3) != r->status_line\n            || (len >= 4 && ! apr_isspace(r->status_line[3]))) {\n            r->status_line = NULL;\n            return APR_EGENERAL;\n        }', 'explanation': 'This block checks that the status line conforms to a basic ABNF requirement – it must consist of exactly three digits (matching the expected numeric status) and, if longer, must have a space following those digits. This reflects an attempt to enforce that only properly formed status lines (i.e. protocol elements) are generated.'}}, {'A1': {'code': 'if (len == 3) {\n            r->status_line = apr_pstrcat(r->pool, r->status_line, "" "", NULL);\n            return APR_EGENERAL;\n        }', 'explanation': 'This segment addresses the RFC2616 mandate for a trailing space after the three‑digit status code. It deliberately appends a space when only the three-digit code is present, attempting to align with the protocol’s grammar requirements.'}}]","The function performs localized checks on the status_line to ensure it matches a very specific grammar – namely, that it comprises a three-digit number (which must match a given status) and, when applicable, is followed immediately by a space. This reflects an attempt to enforce the RFC specification that a sender must not generate protocol elements that deviate from the defined ABNF rules. However, by, for example, appending a space and then returning an error status (APR_EGENERAL), the function’s handling appears to expect further intervention from the caller and does not fully resolve the issue on its own. Hence, while it does address key constraints (labeled here as C1 and A1) directly within its logic, it only partially matches the entire specification requirement.",success,
12269,basic_http_header_check,"A server MAY send an HTTP/1.0 response to an HTTP/1.1 request if it is known or suspected that the client incorrectly implements the HTTP specification and is incapable of correctly processing later version responses, such as when a client fails to parse the version number correctly or when an intermediary is known to blindly forward the HTTP-version even when it doesn't conform to the given minor version of the protocol.",297,Partially Matches,"[{'A1': {'code': 'if (r->proto_num > HTTP_VERSION(1,0)\n        && apr_table_get(r->subprocess_env, ""downgrade-1.0"")) {\n        r->proto_num = HTTP_VERSION(1,0);\n    }', 'explanation': ""This code segment downgrades the HTTP protocol version from HTTP/1.1 (or higher) to HTTP/1.0 only if the environment variable 'downgrade-1.0' is present. This aligns with the RFC statement that a server may downgrade the response when it is known or suspected that the client is incapable of correctly processing later versions. However, the decision is based solely on a flag (environment variable) without checking specific client attributes (e.g., headers like User-Agent) mentioned in the spec. Thus, the implementation only partially covers the downgrade requirements as specified.""}}]","The function contains logic to downgrade the HTTP version from HTTP/1.1 to HTTP/1.0 when an environment variable flag is set, which reflects an attempt to implement the RFC's allowance for protocol downgrades. However, it does not incorporate the full set of conditions—such as verifying detailed client attributes—to decide when such a downgrade should occur. Since the function only implements a subset of the detailed behaviors described in the spec, it is determined to only partially match the specification constraints.",success,
12271,ap_send_http_trace,"An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",60,Fully Matches,"[{'C1': {'code': 'if (conf->trace_enable == AP_TRACE_DISABLE) {\n    apr_table_setn(r->notes, ""error-notes"", ""TRACE denied by server configuration"");\n    return HTTP_METHOD_NOT_ALLOWED;\n}', 'explanation': 'This code segment checks if the TRACE method is not allowed by configuration and, if so, returns the HTTP 405 status code as required by the RFC specification. It directly implements the behavior specified for recognized and implemented methods that are not allowed for the target resource.'}}]","The function ap_send_http_trace directly inspects the TRACE method and, when the server configuration disables it (i.e., TRACE is recognized but not allowed), it responds with HTTP_METHOD_NOT_ALLOWED (405). This behavior matches the RFC requirement that an origin server, when receiving a request with a recognized and implemented method that is not allowed, should respond with a 405 status code. No additional constraints outside this check are required for the given specification context, so the function fully meets the given constraint.",success,
12271,ap_send_http_trace,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'ap_set_content_type_ex(r, ""message/http"", 1);', 'explanation': 'This line explicitly sets the Content-Type header field for the outgoing response. The RFC spec requires that a sender generating a message with content should include a Content-Type header if the media type is known. Here, the function sets it to ""message/http"", thereby fulfilling the constraint.'}}]","The function ap_send_http_trace clearly addresses the specified RFC requirement by setting the Content-Type header via the call to ap_set_content_type_ex. This ensures that any message generated (which includes the rebuilt request and optional body) contains an explicit Content-Type header. Since the header is generated directly in this function, it fully implements the relevant spec constraint.",success,
12273,ap_map_http_request_error,An origin server that receives a request method that is unrecognized or not implemented SHOULD respond with the 501 (Not Implemented) status code.,59,Fully Matches,"[{'C1': {'code': 'case APR_ENOTIMPL:\n    return HTTP_NOT_IMPLEMENTED;', 'explanation': 'This segment directly maps the APR_ENOTIMPL error to the HTTP_NOT_IMPLEMENTED status code (501), which aligns with the RFC requirement that an unrecognized or not implemented method should receive a 501 response.'}}]","The function ap_map_http_request_error checks for various APR error codes and returns corresponding HTTP status codes. In particular, the case handling APR_ENOTIMPL fulfills the RFC specification by returning HTTP_NOT_IMPLEMENTED (501) when a request method is not recognized or implemented. Since this logic is implemented directly in the function body, it fully meets the given RFC constraint.",success,
12274,ap_discard_request_body,HTTP implementations SHOULD support persistent connections.,311,Partially Matches,"[{'C1': {'code': 'if (r->main || c->keepalive == AP_CONN_CLOSE) {\n    return OK;\n}\nif (ap_status_drops_connection(r->status)) {\n    c->keepalive = AP_CONN_CLOSE;\n    return OK;\n}\n...\nif (rc != OK) {\n    c->keepalive = AP_CONN_CLOSE;\n}', 'explanation': ""The function contains logic that respects persistent connection usage by checking the connection's keepalive flag and only discarding the request body if appropriate. If the request is a subrequest or the connection is already flagged for closure, it immediately returns. In error scenarios, it explicitly sets the keepalive flag to force connection closure, thereby indirectly managing persistent connections as required by the spec.""}}]","The provided function is primarily focused on discarding the request body. However, it includes checks related to persistent connections—such as verifying if the request is a subrequest or if the connection should be closed based on error conditions—and modifies the keepalive flag accordingly. This demonstrates a partial implementation of the HTTP RFC's requirement that implementations SHOULD support persistent connections. The function does not fully implement all aspects of connection persistence (for example, managing or evaluating 'Connection' header details) on its own, so it is considered a partial match.",success,
12274,ap_discard_request_body,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'if (r->main || c->keepalive == AP_CONN_CLOSE) {\n    return OK;\n}\n\nif (ap_status_drops_connection(r->status)) {\n    c->keepalive = AP_CONN_CLOSE;\n    return OK;\n}', 'explanation': 'This segment checks if the connection should be maintained (i.e. persistent) by early returning when the connection is already marked to close or when an error status suggests closing. This indirectly supports sustaining persistent connections when possible, as recommended by the RFC.'}}, {'A1': {'code': 'if (rc != OK) {\n    c->keepalive = AP_CONN_CLOSE;\n}\nreturn rc;', 'explanation': 'This final piece ensures that if an error occurs while discarding the request body, the connection is explicitly marked to be closed. This logic helps avoid further network congestion or server load as described in the RFC.'}}]","The function implements logic that indirectly supports the RFC requirement of sustaining persistent connections by carefully discarding the request body and selectively closing connections only when errors are detected. It checks and preserves connection state (e.g., via the 'keepalive' flag), which is in line with maintaining persistence when possible. However, the function does not explicitly implement mechanisms allowing the underlying transport's flow-control to resolve temporary overloads, so only part of the spec is addressed.",success,
12274,ap_discard_request_body,"A server MUST read the entire request message body or close the connection after sending its response; otherwise, the remaining data on a persistent connection would be misinterpreted as the next request.",312,Fully Matches,"[{'C1': {'code': 'if (ap_status_drops_connection(r->status)) {\n        c->keepalive = AP_CONN_CLOSE;\n        return OK;\n    }', 'explanation': 'This code checks the request status, and if an error has been detected, it closes the connection, thereby ensuring that a connection with an error does not remain persistent with a partially read body.'}}, {'A1': {'code': 'for (;;) {\n    apr_status_t rv;\n\n    rv = ap_get_brigade(r->input_filters, bb, AP_MODE_READBYTES,\n                        APR_BLOCK_READ, HUGE_STRING_LEN);\n    if (rv != APR_SUCCESS) {\n        rc = ap_map_http_request_error(rv, HTTP_BAD_REQUEST);\n        goto cleanup;\n    }\n\n    while (!APR_BRIGADE_EMPTY(bb)) {\n        apr_bucket *b = APR_BRIGADE_FIRST(bb);\n\n        if (APR_BUCKET_IS_EOS(b)) {\n            goto cleanup;\n        }\n\n        if (b->length == (apr_size_t)-1) {\n            apr_size_t len;\n            const char *data;\n\n            rv = apr_bucket_read(b, &data, &len, APR_BLOCK_READ);\n            if (rv != APR_SUCCESS) {\n                rc = HTTP_BAD_REQUEST;\n                goto cleanup;\n            }\n        }\n\n        apr_bucket_delete(b);\n    }\n}', 'explanation': 'This loop continuously reads data from the request body until the end-of-stream (EOS) bucket is encountered, ensuring that the entire message body is read. This fully implements the action of reading the entire request body as mandated by the RFC.'}}]","The provided function 'ap_discard_request_body' exclusively handles the reading (and discarding) of the request message body. It explicitly reads all buckets until an EOS bucket is reached, and if any error occurs or if the connection is marked for closure (via ap_status_drops_connection), it immediately sets the connection to close, thereby preventing any leftover data from being misinterpreted as subsequent requests. This directly satisfies the RFC requirement that a server must read the entire request message body or close the connection.",success,
12275,ap_setup_client_block,A server MAY reject a request that contains a message body but not a Content-Length by responding with 411 (Length Required).,203,Fully Matches,"[{'C1': {'code': 'if (r->body_indeterminate) {\n    if (r->read_body == REQUEST_CHUNKED_ERROR) {\n        ...\n        return (lenp) ? HTTP_BAD_REQUEST : HTTP_LENGTH_REQUIRED;\n    }\n    r->read_chunked = 1;\n}', 'explanation': ""This segment checks if the request body length is indeterminate (i.e. not provided via a Content-Length header). If the read_body policy indicates an error when chunked encoding is not acceptable (REQUEST_CHUNKED_ERROR) and there's no Content-Length header (lenp is NULL), it returns HTTP_LENGTH_REQUIRED, which directly implements the RFC requirement to reject a request with a message body but lacking a Content-Length header.""}}]","The code function explicitly detects when the request has a body but no explicit Content-Length header by evaluating the body_indeterminate flag and the presence of the Content-Length header. When the conditions specified in the RFC are met, it responds with HTTP_LENGTH_REQUIRED (411). Therefore, within this function, the logic fully addresses the pertinent constraint defined in the spec.",success,
12275,ap_setup_client_block,"If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value).",201,Partially Matches,"[{'C1': {'code': 'else if (lenp) {\n    if (!ap_parse_strict_length(&r->remaining, lenp)) {\n        r->remaining = 0;\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01594)\n                      ""Invalid Content-Length \'%s\'"", lenp);\n        return HTTP_BAD_REQUEST;\n    }\n}', 'explanation': 'This segment checks if a Content-Length header is present and attempts to strictly parse it. If parsing fails, it logs the error and returns an HTTP_BAD_REQUEST, which addresses the requirement for treating invalid Content-Length values as framing errors. However, it does not show logic for handling the exception where a comma‐separated list of valid identical values should be accepted, hence the implementation is only partial.'}}]","The function implements client body block setup by checking for the presence of the Content-Length header and validating it via a strict parser. On failure to parse, it returns an error, meeting a portion of the RFC specification (specifically, the requirement to treat an invalid Content-Length as an unrecoverable error). However, it does not provide logic to parse a comma‐separated list of Content-Length values and verify that all values are valid and identical, as required by the RFC. Therefore, while some of the labeled constraints are addressed, the function does not fully implement the complete behavior expected by the specification.",success,
12275,ap_setup_client_block,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'C1': {'code': 'else if (lenp) {\n        if (!ap_parse_strict_length(&r->remaining, lenp)) {\n            r->remaining = 0;\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01594)\n                          ""Invalid Content-Length \'%s\'"", lenp);\n            return HTTP_BAD_REQUEST;\n        }\n    }', 'explanation': 'This segment checks the Content-Length header value using a strict parser. If the parsed value is invalid, it logs an error and returns HTTP_BAD_REQUEST, thereby preventing forwarding a message with an incorrect Content-Length, which addresses the core requirement. However, the exception for duplicate valid decimal values (e.g., ""42, 42"") is not handled.'}}]","The function includes logic that verifies the Content-Length header value and rejects the request if it fails the strict parsing check, which implements part of the spec constraint that a message with a known incorrect Content-Length must not be forwarded. However, it does not implement the exception for handling duplicate Content-Length values as allowed by the spec, so it only partially meets the specification.",success,
12277,ap_get_client_block,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Does Not Match,[],"The RFC requires that a recipient interpret a received protocol element according to its defined semantics (and extensions), which implies actively processing and validating the content based on those semantics. The provided function, ap_get_client_block, primarily focuses on reading raw data from the client, handling errors, and managing I/O buffering. It does not contain logic that interprets the received data in accordance with the protocol semantics or its extensions. Therefore, within this function's body, there is no visible implementation that directly addresses any labeled conditions or actions derived from the RFC specification.",success,
12279,h1_append_response_head,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'vec[0].iov_base = (void *)protocol;\nvec[1].iov_base = (void *)"" "";\nvec[2].iov_base = (void *)(status_line);\nvec[3].iov_base = (void *)CRLF;', 'explanation': 'The function constructs the status line by concatenating the protocol, a space, the status_line (obtained via apr_psprintf or ap_get_status_line_ex), and a CRLF, which implies an effort to adhere to the required HTTP/1.x ABNF format. However, it does not explicitly validate or check that these components fully conform to the ABNF grammar, relying instead on correct inputs and helper functions.'}}]","The provided function assembles the HTTP response head by formatting the response line and appending required header elements (Date and Server) in a fixed order, which suggests an attempt to comply with the HTTP message syntax. This aligns with the spirit of the requirement that 'A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.' Nonetheless, the function does not incorporate explicit validation of the individual elements against the ABNF, and it relies on other functions (like ap_get_status_line_ex) to produce properly formatted strings. Thus, while the function visibly addresses portions of the constraint, it does not fully implement all aspects mandated by the spec within its own logic.",success,
12279,h1_append_response_head,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,[],"The provided function implements part of the RFC‐related behavior by ensuring that, in cases where the request indicates an HTTP/0.9 (assbackwards) scenario, no headers are generated. In doing so, it avoids sending protocol elements (like headers) when they are not allowed, which is in line with the directive that a sender must not generate protocol elements reserved for other roles. However, aside from this check (seen in the 'if (r->assbackwards)' block), the function simply builds and outputs a valid HTTP/1.x response head without any explicit verification that it is not generating syntax alternatives intended solely for other participants. There is no further logic within this function that explicitly checks or discriminates among protocol elements based on roles. Therefore, while the code visibly addresses part of the requirements, it does not fully implement all aspects of the RFC constraint within its own logic.",success,
12279,h1_append_response_head,An origin server MAY generate a Server header field in its responses.,89,Fully Matches,"[{'C1': {'code': 'server = apr_table_get(resp->headers, ""Server"");\nif (server) {\n    ap_h1_append_header(bb, r->pool, ""Server"", server);\n    apr_table_unset(resp->headers, ""Server"");\n}', 'explanation': ""This code retrieves the 'Server' header from the response table and appends it to the HTTP response if it exists, directly addressing the RFC specification that an origin server MAY generate a Server header field.""}}]","The function explicitly checks for the presence of a 'Server' header and outputs it if available. Since the HTTP RFC indicates that the Server header field generation is optional (MAY generate), this code segment satisfies that requirement by conditionally handling and appending the header. All relevant logic is contained within the function_body, making this a fully matching implementation with respect to the specified RFC behavior.",success,
12279,h1_append_response_head,A sender MUST NOT send whitespace between the start-line and the first header field.,295,Fully Matches,"[{'C1': {'code': 'vec[0].iov_base = (void *)protocol;\nvec[0].iov_len  = strlen(protocol);\nvec[1].iov_base = (void *)"" "";\nvec[1].iov_len  = sizeof("" "") - 1;\nvec[2].iov_base = (void *)(status_line);\nvec[2].iov_len  = strlen(status_line);\nvec[3].iov_base = (void *)CRLF;\nvec[3].iov_len  = sizeof(CRLF) - 1;\n...\napr_brigade_writev(bb, NULL, NULL, vec, 4);', 'explanation': 'This function constructs the HTTP/1.x status-line by concatenating the protocol, a single required space, the status line, and the CRLF. There is no extra whitespace (such as additional empty lines or CRLFs) inserted between the start-line and the first header field, which complies with the RFC requirement that a sender must not send whitespace in that location.'}}]","The code in h1_append_response_head directly formats the response start-line without inserting any extra whitespace between it and the header fields. The use of a controlled concatenation of the protocol, a single space, the status line, and a terminating CRLF demonstrates that the function itself ensures no additional whitespace is output between the start-line and the first header field, fully implementing the specified RFC constraint.",success,
12280,ap_h1_response_out_filter,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'A1': {'code': 'else if (r->chunked) {\n    apr_table_mergen(resp->headers, ""Transfer-Encoding"", ""chunked"");\n    apr_table_unset(resp->headers, ""Content-Length"");\n}', 'explanation': ""When the response is marked as using chunked encoding (i.e. Transfer-Encoding is being used), the code explicitly merges the 'Transfer-Encoding' header with the value 'chunked' and then unsets the 'Content-Length' header. This directly ensures that a message with a Transfer-Encoding header does not send a Content-Length header, thereby implementing the RFC specification.""}}]","The function directly enforces the RFC requirement by checking if the response should use chunked encoding (r->chunked). In that case, it adds the 'Transfer-Encoding' header and explicitly removes the 'Content-Length' header. This logic within the function_body fully addresses the spec constraint that a sender MUST NOT send a Content-Length header in any message that includes a Transfer-Encoding header.",success,
12280,ap_h1_response_out_filter,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'else if (!ctx->final_response_sent && strict) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10390)\n                  ""ap_h1_response_out_filter seeing data before headers, %ld bytes "",\n                  (long)e->length);\n    rv = AP_FILTER_ERROR;\n    goto cleanup;\n}', 'explanation': 'This segment ensures that if data buckets (which may represent protocol elements) are encountered before a final response header is sent – in strict mode – an error is reported. In effect, it prevents the function from inadvertently generating or passing along protocol elements out of the proper order, which is related to not emitting elements reserved for other roles.'}}, {'A1': {'code': 'if (strict && resp->status < 100) {\n    /* error, not a valid http status */\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10386)\n                  ""ap_h1_response_out_filter seeing headers status=%d in strict mode"",\n                  resp->status);\n    rv = AP_FILTER_ERROR;\n    goto cleanup;\n}', 'explanation': 'This check prevents sending a response header bucket with an invalid status (status < 100) when in strict mode. By flagging such cases, the function avoids generating protocol elements that fall outside the allowed range, indirectly fulfilling part of the role-based constraints.'}}]","The function implements several internal checks that enforce proper ordering and validity of the response headers (i.e. only sending them once and only when appropriate). In strict mode, it errors out when encountering unexpected protocol elements (for example, data before header or an invalid status code), which relates to the RFC requirement that a sender must not generate protocol elements that are not within its allocated role. However, the function does not explicitly inspect or block every case of generating elements reserved for other roles, so while it addresses some aspects of the constraint, it does not fully implement all parts of the spec in isolation. Therefore, the implementation only partially matches the specification constraints.",success,
12280,ap_h1_response_out_filter,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'C1': {'code': 'if (ctx->final_response_sent) {\n    ap_h1_set_keepalive(r, resp);\n    \n    if (r->proto_num == HTTP_VERSION(1,0)\n        && apr_table_get(r->subprocess_env, ""force-response-1.0"")) {\n        r->connection->keepalive = AP_CONN_CLOSE;\n        proto = ""HTTP/1.0"";\n    }\n    ...\n}', 'explanation': ""The function explicitly makes a decision about persistent connections. When the final response is sent (i.e. 'ctx->final_response_sent' is true), it calls 'ap_h1_set_keepalive(r, resp)' to establish keepalive behavior, which is the basis for persistent connections in HTTP/1.1. Additionally, it checks if the protocol is forced to HTTP/1.0 (which does not default to persistent connections) and then sets 'r->connection->keepalive' to close the connection. This logic shows that the function is addressing the requirement that HTTP/1.1 implementations should support persistent connections.""}}]","The provided function processes response buckets and determines how to handle connection persistence based on response status and protocol version. It explicitly calls a function to set keepalive for HTTP/1.1 responses and disables it when the request is forced to HTTP/1.0. Thus, within its logic, it visibly implements the RFC requirement that HTTP implementations SHOULD support persistent connections.",success,
12280,ap_h1_response_out_filter,"A sender MUST NOT apply the chunked transfer coding more than once to a message body (i.e., chunking an already chunked message is not allowed).",188,Partially Matches,"[{'A1': {'code': 'if (ctx->final_response_sent && r->chunked) {\n    /* ... headers have been sent, now add chunk filter */\n    rv = ap_pass_brigade(f->next, b);\n    apr_brigade_cleanup(b);\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, rv, r,\n                  ""ap_h1_response_out_filter passed response, add CHUNK filter"");\n    if (APR_SUCCESS != rv) {\n        apr_brigade_cleanup(ctx->tmpbb);\n        goto cleanup;\n    }\n    ap_add_output_filter(""CHUNK"", NULL, r, r->connection);\n}', 'explanation': 'This code segment adds the chunked transfer coding filter (named ""CHUNK"") only after the final response headers have been sent and only when the request indicates, via r->chunked, that chunking is used. In doing so, it attempts to ensure that the chunked transfer coding is applied as the final transfer coding. However, there is no explicit safeguard to detect if the transfer coding was already applied, meaning the prevention of reapplying the chunked coding is handled implicitly by the filter-chain control and the one-time addition of the filter, rather than by an explicit check.'}}]","The provided function implements logic related to the chunked transfer coding requirement by adding the CHUNK filter only after sending the headers, based on the conditions (such as final_response_sent and r->chunked). This demonstrates an attempt to ensure that the transfer coding is applied only once. However, since there is no explicit check to prevent multiple applications if the function were to be called multiple times or under unusual circumstances, the function only partially fulfills the spec constraint that a sender MUST NOT apply the chunked transfer coding more than once.",success,
12281,get_status_reason,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'A1': {'code': 'if (status_line && strlen(status_line) > 4) {\n    return status_line + 4;\n}\nreturn NULL;', 'explanation': 'The function performs a minimal defensive check by ensuring that the input pointer is not NULL and that the string is longer than 4 characters before accessing its content. This is a basic form of defensive parsing; however, it does not fully validate the input against its ABNF grammar or enforce any comprehensive buffer size constraints as suggested by the RFC.'}}]","The RFC advises that a recipient SHOULD parse received protocol elements defensively, not making strong assumptions about their conformity to the ABNF grammar or their size. While the function checks that the input status line is non-NULL and has a minimal length (thus partially meeting the notion of safe parsing), it does not attempt to validate the format or ensure the buffer is of a 'reasonable' size beyond this trivial check. The minimal length check (strlen(status_line) > 4) is the only visible measure addressing defensive parsing within this function, so the implementation only partially matches the spec constraints.",success,
12282,merge_response_headers,A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content).,193,Fully Matches,"[{'A1': {'code': 'if (AP_STATUS_IS_HEADER_ONLY(r->status)) {\n    apr_table_unset(r->headers_out, ""Transfer-Encoding"");\n    apr_table_unset(r->headers_out, ""Content-Length"");\n    r->content_type = r->content_encoding = NULL;\n    r->content_languages = NULL;\n    r->clength = r->chunked = 0;\n}', 'explanation': ""This code block checks whether the response is header-only (which covers responses without a body, such as those with 1xx or 204 status codes) and unsets the 'Transfer-Encoding' header. This directly implements the RFC requirement that a server MUST NOT send the Transfer-Encoding header in responses with status codes 1xx or 204.""}}]","The merge_response_headers function directly addresses the specified HTTP RFC by ensuring that if the response is a header-only response (i.e., one that would correspond to status codes like 1xx or 204), it explicitly removes the 'Transfer-Encoding' header. The conditional block using AP_STATUS_IS_HEADER_ONLY encapsulates the removal of both 'Transfer-Encoding' and 'Content-Length', thereby complying with the RFC mandate. Since the implementation in the function itself handles this behavior without relying on external dependencies, the code function fully matches the intended requirements.",success,
12282,merge_response_headers,"Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response (Section 15.4.5 of [HTTP]) to a GET request, neither of which includes a message body, to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET.",192,Fully Matches,"[{'A1': {'code': 'if (AP_STATUS_IS_HEADER_ONLY(r->status)) {\n    apr_table_unset(r->headers_out, ""Transfer-Encoding"");\n    apr_table_unset(r->headers_out, ""Content-Length"");\n    r->content_type = r->content_encoding = NULL;\n    r->content_languages = NULL;\n    r->clength = r->chunked = 0;\n}', 'explanation': 'This code block checks whether the response is header-only (which covers cases such as 304, 204, and HEAD requests) and unsets the Transfer-Encoding header accordingly. This directly implements the RFC requirement that a Transfer-Encoding header must not be sent when there is no message body.'}}]","The function merge_response_headers includes logic that, when the response is determined to be header-only (using the AP_STATUS_IS_HEADER_ONLY check), explicitly removes the Transfer-Encoding header. This behavior directly addresses the RFC guidance (and restrictions) regarding the use of Transfer-Encoding in responses without a message body. All relevant aspects of the spec are implemented visibly within this function, satisfying the conditions of the RFC.",success,
12282,merge_response_headers,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'C1': {'code': 'if (!apr_is_empty_array(r->content_languages)) {\n    int i;\n    char *token;\n    char **languages = (char **)(r->content_languages->elts);\n    const char *field = apr_table_get(r->headers_out, ""Content-Language"");\n\n    while (field && (token = ap_get_list_item(r->pool, &field)) != NULL) {\n        for (i = 0; i < r->content_languages->nelts; ++i) {\n            if (!ap_cstr_casecmp(token, languages[i]) )\n                break;\n        }\n        if (i == r->content_languages->nelts) {\n            *((char **) apr_array_push(r->content_languages)) = token;\n        }\n    }\n\n    field = apr_array_pstrcat(r->pool, r->content_languages, \',\');\n    apr_table_setn(r->headers_out, ""Content-Language"", field);\n}', 'explanation': 'This segment recombines multiple Content-Language header values into a single comma‐separated string. In doing so it follows the RFC requirement to merge header values when the header’s definition allows multiple values.'}}]","The function attempts to merge and adjust response headers prior to sending the response. In particular, it ensures that for the Content-Language header—one header field that may allow a comma‐separated list—the multiple header values are combined rather than being left as separate header lines. However, aside from this header, the function primarily delegates header merging and manipulation to APR library functions (e.g., apr_table_overlay, apr_table_setn, and apr_table_unset) without explicit logic to verify whether multiple header lines are generated for fields that do not allow comma-separated concatenation. Thus, it only partially addresses the RFC constraint regarding duplicate field lines and their ordering, because only the Content-Language header is handled in a way that fully meets the spec. Other header fields rely on general table operations, which may not explicitly enforce the RFC’s prohibition on multiple header lines.",success,
12282,merge_response_headers,"In any production that uses the list construct, a sender MUST NOT generate empty list elements.",236,Does Not Match,[],"The specification requires that any production using the list construct must not generate empty list elements. In the function_body, although a comma-delimited list is constructed for the Content-Language header (using apr_array_pstrcat and iteration via ap_get_list_item), there is no explicit check or logic ensuring that empty elements are not produced. The code simply iterates over tokens and concatenates them without validating that each token is non-empty. Therefore, this function does not implement the required constraint within its own logic.",success,
12282,merge_response_headers,Multiple languages MAY be listed for content that is intended for multiple audiences.,260,Partially Matches,"[{'A1': {'code': 'if (!apr_is_empty_array(r->content_languages)) {\n    int i;\n    char *token;\n    char **languages = (char **)(r->content_languages->elts);\n    const char *field = apr_table_get(r->headers_out, ""Content-Language"");\n\n    while (field && (token = ap_get_list_item(r->pool, &field)) != NULL) {\n        for (i = 0; i < r->content_languages->nelts; ++i) {\n            if (!ap_cstr_casecmp(token, languages[i]) )\n                break;\n        }\n        if (i == r->content_languages->nelts) {\n            *((char **) apr_array_push(r->content_languages)) = token;\n        }\n    }\n\n    field = apr_array_pstrcat(r->pool, r->content_languages, \',\');\n    apr_table_setn(r->headers_out, ""Content-Language"", field);\n}', 'explanation': ""The code concatenates multiple language tokens (if present in the content_languages array) into a comma-separated string and sets the 'Content-Language' header. This behavior addresses the RFC requirement that 'Multiple languages MAY be listed for content that is intended for multiple audiences.'""}}]","The function merge_response_headers partially implements the RFC specification by handling the case when multiple languages are provided. It checks if the content_languages array is non-empty and then constructs a Content-Language header with a comma-separated list of language tags. However, it does not provide logic for the default case when no Content-Language is specified (i.e., assuming the content is intended for all language audiences), leaving part of the RFC requirement unaddressed within this function.",success,
12282,merge_response_headers,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Fully Matches,"[{'C1': {'code': 'if (AP_STATUS_IS_HEADER_ONLY(r->status)) {\n    apr_table_unset(r->headers_out, ""Transfer-Encoding"");\n    apr_table_unset(r->headers_out, ""Content-Length"");\n    r->content_type = r->content_encoding = NULL;\n    r->content_languages = NULL;\n    r->clength = r->chunked = 0;\n}', 'explanation': ""This block checks if the response is 'header only' (which applies to responses with status codes 1xx and 204, among others) and explicitly removes the 'Content-Length' header. This directly implements the RFC requirement that a server MUST NOT send a Content-Length header field in any response with these status codes.""}}]","The function contains a clear check for header-only responses using the AP_STATUS_IS_HEADER_ONLY macro and unsets the 'Content-Length' header accordingly. This ensures that responses such as 1xx and 204 do not include a Content-Length header, thereby satisfying the specified part of the HTTP RFC.",success,
12282,merge_response_headers,Content-Language MAY be applied to any media type --it is not limited to textual documents.,42,Partially Matches,"[{'C1': {'code': 'if (!apr_is_empty_array(r->content_languages)) {\n    int i;\n    char *token;\n    char **languages = (char **)(r->content_languages->elts);\n    const char *field = apr_table_get(r->headers_out, ""Content-Language"");\n\n    while (field && (token = ap_get_list_item(r->pool, &field)) != NULL) {\n        for (i = 0; i < r->content_languages->nelts; ++i) {\n            if (!ap_cstr_casecmp(token, languages[i]) )\n                break;\n        }\n        if (i == r->content_languages->nelts) {\n            *((char **) apr_array_push(r->content_languages)) = token;\n        }\n    }\n\n    field = apr_array_pstrcat(r->pool, r->content_languages, \',\');\n    apr_table_setn(r->headers_out, ""Content-Language"", field);\n}', 'explanation': ""This segment handles the merging and setting of the Content-Language header by incorporating language tokens stored in r->content_languages along with any pre-existing header values. This represents an attempt to implement the RFC's provision for applying Content-Language regardless of media type. However, it does not include logic to differentiate between media types or select a particular language (e.g., enforcing a single language like 'en' when applicable), which is part of the broader intent outlined in the RFC and its context.""}}]","The function visibly addresses the handling of the 'Content-Language' header by checking if the content_languages array is not empty, merging it with any headers already set, and then updating the outgoing response header. This indicates an attempt to implement the RFC’s mandate that Content-Language may be applied to any media type. However, the function does not incorporate additional logic such as distinguishing between multiple languages versus a deliberately singular audience as described in the specification's context. Therefore, while some aspects of the RFC are handled, the implementation is only partial.",success,
12282,merge_response_headers,"A server MAY send an HTTP/1.0 response to an HTTP/1.1 request if it is known or suspected that the client incorrectly implements the HTTP specification and is incapable of correctly processing later version responses, such as when a client fails to parse the version number correctly or when an intermediary is known to blindly forward the HTTP-version even when it doesn't conform to the given minor version of the protocol.",297,Fully Matches,"[{'A1': {'code': 'if (apr_table_get(r->subprocess_env, ""force-no-vary"") != NULL) {\n    apr_table_unset(r->headers_out, ""Vary"");\n    r->proto_num = HTTP_VERSION(1,0);\n    apr_table_setn(r->subprocess_env, ""force-response-1.0"", ""1"");\n}', 'explanation': ""This code block directly implements the RFC provision whereby the server downgrades the response to HTTP/1.0 if the client or intermediary is suspected of mishandling the 'Vary' header. The check for the 'force-no-vary' flag, removal of the 'Vary' header, and setting of the protocol version to HTTP/1.0 clearly address the requirement described in the spec.""}}]","The merge_response_headers function includes logic that downgrades the HTTP protocol version to 1.0 based on the client's (or intermediary's) inability to correctly handle the 'Vary' header. This directly corresponds to the RFC specification stating that a server MAY send an HTTP/1.0 response when the client is suspected of mis-handling later version responses. All relevant logic for the described condition and action is contained within the function, thereby fully matching the spec constraints.",success,
12282,merge_response_headers,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'ctype = ap_make_content_type(r, r->content_type);\nif (ctype) {\n    apr_table_setn(r->headers_out, ""Content-Type"", ctype);\n}', 'explanation': ""This code generates a Content-Type header field if the media type is known (i.e. ap_make_content_type returns a non-null value), which directly implements the RFC requirement that a sender SHOULD generate a Content-Type header field when the representation's media type is known.""}}]","The function 'merge_response_headers' contains explicit logic to set the Content-Type header. It does so by computing the content type using 'ap_make_content_type' and, if the resulting value is non-null (indicating that the media type is known), setting the 'Content-Type' header. This approach fully matches the RFC specification which mandates generating a Content-Type header unless the media type is unknown.",success,
12283,create_response_bucket,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function 'create_response_bucket' only creates a response bucket by wrapping the call to 'ap_bucket_response_create' without any logic addressing the RFC requirement that a sender must not generate protocol elements reserved for other roles. There is no code within the function that checks or restricts protocol element generation based on sender roles, so none of the spec constraints (e.g., C1, A1) are visibly implemented in this function.",success,
12284,create_trailers_bucket,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The provided function solely checks if the 'trailers_out' field is present and non-empty, then creates and returns an apr_bucket with those trailer headers. It does not implement any logic to verify that the recipient understands the corresponding header field definitions nor does it perform any safe merging of trailer fields into the header section as mandated by the RFC. There is no code checking that only permitted trailer fields are merged, so the function fails to address the specified condition.",success,
12285,read_request_line,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'do {\n    ctx->request_line = NULL;\n    len = 0;\n    rv = ap_rgetline(&ctx->request_line, (apr_size_t)(ctx->r->server->limit_req_line + 2),\n                     &len, ctx->r, strict ? AP_GETLINE_CRLF : 0, bb);\n\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n    else if (len > 0) {\n        return APR_SUCCESS;\n    }\n} while (--num_blank_lines >= 0);\nreturn APR_EINVAL;', 'explanation': 'This loop shows a defensive parsing strategy by repeatedly reading lines, skipping empty ones and limiting the number of blank lines to prevent excessive input processing.'}}, {'A1': {'code': 'rv = ap_rgetline(&ctx->request_line, (apr_size_t)(ctx->r->server->limit_req_line + 2), &len, ctx->r, strict ? AP_GETLINE_CRLF : 0, bb);', 'explanation': 'The use of a fixed maximum line length (limit_req_line + 2) enforces a reasonable buffer size constraint, which is in line with the specification to only assume marginal conformance of the protocol element.'}}]","The function attempts to implement defensive parsing by limiting the number of consecutive blank lines and enforcing a maximum acceptable size for the request line. However, while it addresses some aspects of the RFC spec (such as not assuming full conformance and guarding against abnormally long inputs), it does not completely cover all aspects of defensive parsing (for example, detailed grammatical validation) within the function itself. Thus, it only partially meets the overall spec constraints.",success,
12285,read_request_line,A recipient MAY employ such workarounds while remaining conformant to this protocol if the workarounds are limited to the implementations at fault.,216,Partially Matches,"[{'C1': {'code': 'do {\n    /* ensure ap_rgetline allocates memory each time thru the loop\n     * if there are empty lines\n     */\n    ctx->request_line = NULL;\n    len = 0;\n    rv = ap_rgetline(&ctx->request_line, (apr_size_t)(ctx->r->server->limit_req_line + 2),\n                     &len, ctx->r, strict ? AP_GETLINE_CRLF : 0, bb);\n\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n    else if (len > 0) {\n        /* got the line in ctx->r->the_request */\n        return APR_SUCCESS;\n    }\n} while (--num_blank_lines >= 0);', 'explanation': 'This loop explicitly skips over blank lines, implementing a workaround consistent with the RFC guidance that allows a recipient to ignore extra CRLFs (for example, those added by browsers supporting older servers). This corresponds to one of the spec conditions (C1).'}}]","The function implements a workaround by looping to skip over empty lines before processing a real request line. This is in line with the RFC statement that permits employing workarounds when necessary. However, aside from this handling of extra blank lines, the function does not visibly implement any additional conditions or actions (such as validating user choices or reflecting precise protocol element semantics) detailed in the broader spec context. Consequently, while it addresses part of the specification (C1), it does not fully cover all labeled constraints from the spec.",success,
12285,read_request_line,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'read_request_line' is solely responsible for reading an incoming request line and skipping over empty lines. It does not implement any logic related to the RFC requirement that a sender must not generate protocol elements or syntax alternatives reserved for other roles. In other words, the function does not contain any code segments that enforce or address the role-specific generation of protocol elements (i.e., it does not check or prevent generating such elements) as specified in the RFC. Therefore, none of the labeled spec constraints (e.g., C1, A1) are visibly addressed within this function.",success,
12285,read_request_line,"In the interest of robustness, a server that is expecting to receive and parse a request-line SHOULD ignore at least one empty line (CRLF) received prior to the request-line.",174,Fully Matches,"[{'C1': {'code': 'do {\n    ctx->request_line = NULL;\n    len = 0;\n    rv = ap_rgetline(&ctx->request_line, (apr_size_t)(ctx->r->server->limit_req_line + 2),\n                     &len, ctx->r, strict ? AP_GETLINE_CRLF : 0, bb);\n\n    if (rv != APR_SUCCESS) {\n        return rv;\n    }\n    else if (len > 0) {\n        return APR_SUCCESS;\n    }\n} while (--num_blank_lines >= 0);', 'explanation': 'This loop repeatedly calls ap_rgetline and checks if the line length (len) is greater than 0. If the line is empty (i.e. a CRLF with no content), it continues reading until a non-empty line is found or the limit of blank lines is reached. This behavior directly implements the spec requirement that the server SHOULD ignore at least one empty line (CRLF) received prior to the request-line.'}}]","The function 'read_request_line' clearly addresses the RFC specification by ignoring any initial empty (CRLF) lines before encountering the actual request-line. The loop that decrements 'num_blank_lines' and only returns success when a non-empty line (len > 0) is detected matches the spec constraint. Therefore, the function fully implements this requirement within its own logic.",success,
12287,ap_h1_request_in_filter,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function strictly handles the parsing and reading of an HTTP request—specifically processing the request line and headers, and creating corresponding request or error buckets. There is no explicit logic within this function that prevents the generation of protocol elements or syntax alternatives that are reserved for another role, as required by the specified RFC constraint (i.e., ensuring that a sender does not generate elements only allowed for participants in other roles). Consequently, the function does not visibly address the labeled condition/action of the RFC specification.",success,
12287,ap_h1_request_in_filter,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if ((rv = read_request_line(ctx, bb)) != APR_SUCCESS) {\n    /* certain failures are answered with a HTTP error bucket\n     * and are terminal for parsing a request */\n    ctx->method = ctx->uri = ""-"";\n    ctx->protocol = ""HTTP/1.0"";\n    if (APR_STATUS_IS_ENOSPC(rv)) {\n        http_status = HTTP_REQUEST_URI_TOO_LARGE;\n    }\n    else if (APR_STATUS_IS_TIMEUP(rv)) {\n        http_status = HTTP_REQUEST_TIME_OUT;\n    }\n    else if (APR_STATUS_IS_BADARG(rv)) {\n        http_status = HTTP_BAD_REQUEST;\n    }\n    else if (APR_STATUS_IS_EINVAL(rv)) {\n        http_status = HTTP_BAD_REQUEST;\n    }\n    goto cleanup;\n}', 'explanation': 'This section demonstrates defensive parsing by checking the outcome of reading the request line. It anticipates that the incoming data may not conform to expected length or format (e.g. not enough space, bad or invalid arguments) and assigns appropriate HTTP error status codes.'}}, {'A1': {'code': 'apr_brigade_cleanup(bb);\ne = ap_bucket_error_create(http_status, NULL, r->pool,\n                               f->c->bucket_alloc);\nAPR_BRIGADE_INSERT_TAIL(bb, e);', 'explanation': 'Upon detecting an error in the parsing process, the function creates an error bucket, cleans up the input bucket brigade, and logs the error. This is an action to recover from (or report) malformed input, aligning with defensive parsing expectations.'}}]","The function attempts to implement the RFC’s guidance for defensive parsing by verifying that the HTTP request elements (such as the request line) meet minimal criteria before proceeding. It checks for various error conditions (e.g., insufficient space, timeout, invalid arguments) and handles them by setting the proper HTTP error codes and returning error buckets. However, detailed concerns such as comprehensive conformity to an ABNF grammar and dynamic buffer size management are handled by other functions (like read_request_line and ap_h1_tokenize_request_line) rather than fully inside this function. Thus, while the function embodies a defensive parsing approach and takes appropriate actions for errors, the implementation is partial within this scope.",success,
12287,ap_h1_request_in_filter,"A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain.",298,Fully Matches,"[{'A1': {'code': 'if (!ap_h1_tokenize_request_line(r, ctx->request_line,\n                                             &ctx->method, &ctx->uri, &ctx->protocol)) {\n                http_status = HTTP_BAD_REQUEST;\n                goto cleanup;\n            }', 'explanation': 'The RFC mandates that for a malformed request-line, the recipient SHOULD NOT attempt to autocorrect and then process the request; instead it should respond with either a 400 error or a 301 redirect. This code checks for failure to properly tokenize the request-line and, rather than trying to autocorrect it, sets the HTTP status to 400 (Bad Request) and ultimately returns an error bucket. This fully addresses the requirement.'}}]","The function reads the request-line and, if it fails to parse correctly, it immediately sets an error status and returns an error bucket without attempting any autocorrection. Although the RFC allows for either sending a 400 response or a 301 redirect provided the request-target is properly encoded, the function’s approach of consistently returning a 400 error on a malformed request-line is compliant with the specification. All of the necessary handling is done within the function itself, which means it fully meets the requirement.",success,
12287,ap_h1_request_in_filter,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'A1': {'code': 'if (!ap_h1_tokenize_request_line(r, ctx->request_line,\n                                     &ctx->method, &ctx->uri, &ctx->protocol)) {\n    http_status = HTTP_BAD_REQUEST;\n    goto cleanup;\n}\n...\ncleanup:\n    if (http_status != HTTP_OK) {\n        apr_brigade_cleanup(bb);\n        e = ap_bucket_error_create(http_status, NULL, r->pool,\n                                   f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n        ctx->state = REQ_ERROR;\n        return APR_SUCCESS;\n    }', 'explanation': 'This segment detects an invalid request-line (e.g. if tokenization fails) and responds by setting an appropriate HTTP error status (HTTP_BAD_REQUEST) and returning an error bucket. This aligns partially with the RFC requirement to respond with a 400 error when the request-line is invalid. However, the code does not attempt to perform a 301 redirect with proper encoding of the request-target.'}}]","The function checks the validity of the request-line and, upon detecting issues (such as via the failure of tokenization or errors in reading the request line), it responds with an error bucket containing an error status such as HTTP_BAD_REQUEST. This meets part of the HTTP RFC specification (action A1) by issuing an error response. However, the RFC allows for a 301 redirect with correct encoding of the request-target if applicable, and this function does not implement such a redirection mechanism. Additionally, the RFC's emphasis on disallowing whitespace in the request-target is not explicitly enforced in this function. Therefore, the code function only partially matches the spec constraints.",success,
12287,ap_h1_request_in_filter,A server that receives a request-target longer than any URI it wishes to parse MUST respond with a 414 (URI Too Long) status code (see Section 15.5.15 of [HTTP]).,179,Fully Matches,"[{'C1': {'code': 'if (APR_STATUS_IS_ENOSPC(rv)) {\n                    http_status = HTTP_REQUEST_URI_TOO_LARGE;\n                }', 'explanation': 'This check directly interprets an ENOSPC error from read_request_line as an overly long request-target, which aligns with the RFC requirement for a URI that is too long.'}}, {'A1': {'code': 'if (http_status != HTTP_OK) {\n        apr_brigade_cleanup(bb);\n        e = ap_bucket_error_create(http_status, NULL, r->pool, f->c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n        ctx->state = REQ_ERROR;\n        return APR_SUCCESS;\n    }', 'explanation': 'After detecting an error (including the 414 case from C1), the function creates an error bucket with the appropriate HTTP status (HTTP_REQUEST_URI_TOO_LARGE, i.e., 414) and returns it, fulfilling the RFC mandate for responding with 414.'}}]","The function_body directly handles the specific RFC requirement by conditionally checking the result of read_request_line. When a too-long request-target is detected (signaled by an ENOSPC error), it sets the status to HTTP_REQUEST_URI_TOO_LARGE (414) and creates an error bucket with that code. This internal logic fully implements the condition and response as detailed in the RFC specification.",success,
12290,ap_die_r,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Partially Matches,"[{'A1': {'code': 'if (custom_response && custom_response[0] != \'""\') {\n    if (ap_is_url(custom_response)) {\n        r->status = HTTP_MOVED_TEMPORARILY;\n        apr_table_setn(r->headers_out, ""Location"", custom_response);\n    }\n    ...\n}', 'explanation': 'When a custom response is provided and it qualifies as a URL (the call to ap_is_url(custom_response) returns true), the function explicitly sets the response status to HTTP_MOVED_TEMPORARILY (i.e. a 302 redirect) and adds a Location header with the URI by calling apr_table_setn. This directly implements the action described in the spec to generate a Location header field containing a URI reference.'}}]","The function contains logic that addresses part of the RFC requirement: it checks if a custom redirection URL is provided and, if valid, it sets the HTTP status code to 302 (Found) and generates a Location header field with the URL. However, the redirection handling also includes other branches (such as internal redirects for local URLs) that do not explicitly generate a Location header. Therefore, while the function implements the core action for URL-based redirection, it does not fully address every possible condition outlined by the RFC spec. As such, it is considered a partial implementation.",success,
12290,ap_die_r,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Partially Matches,"[{'A1': {'code': 'if (custom_response && custom_response[0] != \'""\') {\n    if (ap_is_url(custom_response)) {\n        r->status = HTTP_MOVED_TEMPORARILY;\n        apr_table_setn(r->headers_out, ""Location"", custom_response);\n    }', 'explanation': 'The function checks if a custom response exists and if it is a valid URL. In that case, it sets the response status to HTTP_MOVED_TEMPORARILY and explicitly sets the Location header with the given URI, which is an attempt to implement the spec requirement that the server should generate a Location header field.'}}]","The function implements logic for setting a Location header when a custom response is detected and qualifies as a URL. This directly addresses the spec’s requirement for generating a Location header field. However, the implementation is conditional—only applied when the custom_response is an absolute URL (checked via ap_is_url) and sets the status to HTTP_MOVED_TEMPORARILY (HTTP 302) rather than using a 307 Temporary Redirect as highlighted in the spec context. Thus, while it does include some address of the constraint, it does not fully meet the spec across all specified redirection scenarios.",success,
12290,ap_die_r,HTTP implementations SHOULD support persistent connections.,311,Partially Matches,"[{'C1': {'code': 'if (ap_status_drops_connection(r->status)) {\n    r->connection->keepalive = AP_CONN_CLOSE;\n}', 'explanation': 'This code snippet checks whether the response status requires dropping the connection and, if so, marks the connection as non-persistent by setting keepalive to AP_CONN_CLOSE. This is a partial attempt at managing persistent connections, as it ensures that error responses do not erroneously keep the connection alive. However, it does not explicitly enable or maintain persistent connections under normal operation.'}}]","The specification requires that HTTP implementations should support persistent connections. In the provided function, there is a section where the connection’s keepalive property is explicitly set to close if the response status mandates dropping the connection. This demonstrates some awareness of persistent connection management. However, beyond this error-related handling, the function does not contain logic to actively maintain or negotiate persistent connections during standard (non-error) operations. Consequently, while there is an element addressing the spec constraint, it only partially matches the complete intent of supporting persistent connections as described in the RFC.",success,
12292,ap_check_pipeline,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that a sender must not generate protocol elements or syntax alternatives that are reserved for other roles. The function provided (ap_check_pipeline) is focused solely on consuming and analyzing incoming pipelined data (e.g., checking for blank lines, handling CRLF sequences, and managing connection state) rather than on generating protocol elements. Since the function does not produce any protocol elements at all and does not enforce role-specific generation rules, it does not visibly implement the specified constraint within its own logic.",success,
12292,ap_check_pipeline,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'while (c->keepalive != AP_CONN_CLOSE && !c->aborted) { ... if (num_blank_lines > max_blank_lines) { c->keepalive = AP_CONN_CLOSE; rv = APR_NOTFOUND; break; } }', 'explanation': 'This loop defensively reads from the connection and counts blank lines, ensuring that abnormal or excessive empty lines (which may indicate nonconformant input) are detected and that the connection is closed if the limit is exceeded. This behavior embodies the principle that the parser makes only marginal assumptions about input conformance and buffer size.'}}, {'A1': {'code': 'rv = ap_get_brigade(c->input_filters, bb, mode, APR_NONBLOCK_READ, len); ... if (rv != APR_SUCCESS || APR_BRIGADE_EMPTY(bb)) { ... log error and close connection }', 'explanation': 'The code performs a non‐blocking read with defensive error checking. It handles unexpected outcomes (including partial data, empty brigades, or read errors) by logging the issue and altering connection state, fulfilling the spec action of defensive parsing with minimal assumptions.'}}]","The function 'ap_check_pipeline' reads pipelined input using a speculative mode and carefully checks for blank line sequences (either LF or CRLF). It sets limits on acceptable input (via max_blank_lines) and employs defensive error handling by verifying read success and logging errors when conditions are not met. This implementation directly addresses the RFC specification that a recipient SHOULD parse defensively with only marginal expectations about conformance, fully implementing the intended constraints within its own logic.",success,
12292,ap_check_pipeline,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'while (c->keepalive != AP_CONN_CLOSE && !c->aborted) { ... }', 'explanation': 'This loop ensures that processing continues as long as the connection remains active (i.e. not set to close), which aligns with the idea of sustaining persistent connections when possible.'}}, {'A1': {'code': 'if (rv != APR_SUCCESS && !APR_STATUS_IS_EAGAIN(rv)) {\n    c->keepalive = AP_CONN_CLOSE;\n} else {\n    rv = APR_EAGAIN;\n}', 'explanation': 'By distinguishing temporary conditions (returning APR_EAGAIN) from fatal errors (setting keepalive to close), the code attempts to defer connection termination and let underlying transport mechanisms handle temporary overloads.'}}]","The function partially implements the RFC specification. It uses a looping mechanism that continues processing as long as the connection is not explicitly marked closed (addressing persistent connection sustenance) and it treats non-critical, temporary read failures (APR_EAGAIN) without forcefully closing the connection, thereby allowing underlying transport flow-control to potentially resolve the condition. However, it does not cover all aspects of the RFC requirements exhaustively, nor does it implement additional flow-control strategies beyond these checks.",success,
12292,ap_check_pipeline,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Partially Matches,"[{'C1': {'code': 'else {\n    if (buf[0] == APR_ASCII_LF) {\n        /* consume this LF */\n        mode = AP_MODE_READBYTES;\n        num_blank_lines++;\n    }\n    else if (buf[0] == APR_ASCII_CR) {\n        cr = 1;\n    }\n    else {\n        /* Not [CR]LF, some data */\n        break;\n    }\n}\n\n... \n\nelse if (cr) {\n    AP_DEBUG_ASSERT(len == 2 && buf[0] == APR_ASCII_CR);\n    if (buf[1] == APR_ASCII_LF) {\n        /* consume this CRLF */\n        mode = AP_MODE_READBYTES;\n        num_blank_lines++;\n    }\n    else {\n        /* CR(?!LF) is data */\n        break;\n    }\n}', 'explanation': 'The function checks for a lone LF as a valid line terminator and handles a CR by checking that it is immediately followed by an LF (thereby effectively treating CRLF as a line terminator). This corresponds to the RFC wording that a recipient MAY recognize a single LF as a terminator and ignore any preceding CR. However, the code does not implement the additional logic for handling bare CR characters (e.g. replacing them with SP or marking them invalid), so while it partially addresses the spec, it does not cover all aspects.'}}]","The provided function contains logic to detect and consume blank lines using either a single LF or a CRLF pair. This directly addresses the spec constraint concerning flexible line termination in HTTP messages. However, beyond recognizing valid line terminators, the function does not implement other parsing requirements specified in the RFC (for example, handling of bare CR characters as described in the context). Therefore, only part of the RFC’s requirements is met by this function on its own.",success,
12292,ap_check_pipeline,"In the interest of robustness, a server that is expecting to receive and parse a request-line SHOULD ignore at least one empty line (CRLF) received prior to the request-line.",174,Partially Matches,"[{'C1': {'code': 'if (buf[0] == APR_ASCII_LF) {\n    /* consume this LF */\n    mode = AP_MODE_READBYTES;\n    num_blank_lines++;\n}\nelse if (buf[0] == APR_ASCII_CR) {\n    cr = 1;\n}\n...\nif (cr) {\n    AP_DEBUG_ASSERT(len == 2 && buf[0] == APR_ASCII_CR);\n    if (buf[1] == APR_ASCII_LF) {\n        /* consume this CRLF */\n        mode = AP_MODE_READBYTES;\n        num_blank_lines++;\n    } else {\n        /* CR(?!LF) is data */\n        break;\n    }\n}', 'explanation': 'The code explicitly checks for and consumes empty lines (CRLF or LF), thereby attempting to ignore at least one empty line before the request-line as required by the RFC. It increments a counter (num_blank_lines) upon consuming such a line. However, the function does not address all aspects of the HTTP RFC regarding extra CRLF or whitespace between the start-line and headers, so only a portion of the spec is handled by this function.'}}]","The function 'ap_check_pipeline' includes logic to inspect and consume empty lines (CRLF or LF) prior to reading actual request data. This directly corresponds to the RFC specification that a server SHOULD ignore at least one empty line before the request-line. The code segments that check for APR_ASCII_CR and APR_ASCII_LF and correctly consume them demonstrate an attempt to implement this part of the spec. However, the function does not fully implement all the RFC constraints (such as handling whitespace between the start-line and the first header field) within its own scope. Therefore, overall, the function partially matches the specified RFC behavior.",success,
12297,internal_internal_redirect,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Partially Matches,[],"The provided function does include logic related to the Location header in that it checks if the new response’s status is an HTTP redirect and then copies an existing ""Location"" header from the original request (see the block starting with 'if (ap_is_HTTP_REDIRECT(new->status)) {'). However, according to the spec requirement, the server SHOULD generate a Location header field containing a URI reference for the different URI. In this function the Location header is not generated by constructing it or ensuring its presence; it only copies one if already present in the old headers. Thus, while the function remotely addresses aspects of the required behavior, it does not fully implement the RFC specification within itself.",success,
12297,internal_internal_redirect,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Partially Matches,"[{'A1': {'code': 'if (ap_is_HTTP_REDIRECT(new->status)) {\n    const char *location = apr_table_get(r->headers_out, ""Location"");\n    if (location)\n        apr_table_setn(new->headers_out, ""Location"", location);\n}', 'explanation': ""This code segment checks if the response status is a HTTP redirect and, if so, retrieves the 'Location' header from the original request's headers and sets it in the new request's headers. This demonstrates an attempt to address the spec's requirement for a Location header. However, it solely propagates an existing location value instead of generating one based on the provided new URI when missing, thus only partially meeting the RFC specification.""}}]","The RFC requires that the server SHOULD generate a Location header field containing a URI reference for the different URI in a redirection response. Within function_body, the code does check if the response status indicates a redirection and copies the 'Location' header from the original request if it exists. However, it does not generate a new Location header using the new_uri parameter when no such header is already present. Given that the internal redirect function only propagates an already set Location header rather than creating one as demanded by the spec, the function partially matches the requirement.",success,
12309,ap_process_http_sync_connection,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'C1': {'code': 'while ((r = ap_read_request(c)) != NULL) {\n    ...\n    if (c->keepalive != AP_CONN_KEEPALIVE || c->aborted)\n        break;\n    ...\n}', 'explanation': 'This loop continuously reads HTTP requests from the connection and only exits when the keepalive flag isn’t set (or the connection is aborted). This demonstrates support for persistent connections.'}}, {'A1': {'code': 'apr_socket_timeout_set(csd, keep_alive_timeout);', 'explanation': 'By setting a keep-alive timeout on the connection socket, the code ensures that the connection remains open for additional requests, fulfilling the requirement to support persistent connections.'}}]","The function implements persistent connection support by maintaining a loop that reads and processes multiple HTTP requests on a single connection. It explicitly checks for connection keepalive conditions and sets an appropriate timeout, which directly addresses the RFC requirement that HTTP implementations SHOULD support persistent connections.",success,
12309,ap_process_http_sync_connection,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'while ((r = ap_read_request(c)) != NULL) {\n    ...\n    if (c->keepalive != AP_CONN_KEEPALIVE || c->aborted)\n        break;\n    ...\n    apr_socket_timeout_set(csd, keep_alive_timeout);\n    /* Go straight to select() to wait for the next request */\n}', 'explanation': 'This loop processes multiple HTTP requests over the same connection and uses a keep-alive timeout, thereby sustaining a persistent connection as required by the specification.'}}]","The function implements a loop that handles multiple HTTP requests on the same connection by checking the keepalive flag and setting a timeout, which addresses the requirement to sustain persistent connections (C1). However, while the RFC also advises that the server should allow underlying transport flow-control mechanisms to resolve temporary overloads (an aspect we may label A1), there is no explicit logic in the function that addresses this behavior beyond setting a socket timeout and an incomplete-read option. As such, only part of the spec constraints is visibly implemented in this function.",success,
12313,h1_post_read_request,A server MAY reject a request that contains both Content-Length and Transfer-Encoding or process such a request in accordance with the Transfer-Encoding alone.,198,Fully Matches,"[{'C1': {'code': 'if (tenc) {\n    r->body_indeterminate = 1;\n    if (!ap_is_chunked(r->pool, tenc)) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02539)\n                      ""client sent unknown Transfer-Encoding ""\n                      ""(%s): %s"", tenc, r->uri);\n        return HTTP_BAD_REQUEST;\n    }', 'explanation': ""This segment checks if there is a Transfer-Encoding header and proceeds to verify that it uses the 'chunked' coding as mandated by the specification. If not, it rejects the request as per the RFC.""}}, {'A1': {'code': 'if (apr_table_get(r->headers_in, ""Content-Length"")) {\n    apr_table_unset(r->headers_in, ""Content-Length"");\n    r->connection->keepalive = AP_CONN_CLOSE;\n}', 'explanation': 'This code confirms that when both Transfer-Encoding and Content-Length headers are present, the Content-Length header is removed and the connection is closed, enforcing the behavior described in the RFC to avoid potential attacks.'}}]","The function directly implements the key aspects of the RFC for handling requests with both Content-Length and Transfer-Encoding headers. It validates Transfer-Encoding is 'chunked' (rejecting non-chunked values) and, when both headers are present, removes the Content-Length header and marks the connection to be closed, which aligns fully with the specified RFC requirements.",success,
12313,h1_post_read_request,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'tenc = apr_table_get(r->headers_in, ""Transfer-Encoding"");\nif (tenc) {\n    r->body_indeterminate = 1;\n    ...', 'explanation': 'This portion of the code checks if a Transfer-Encoding header is present. It establishes the condition that if a Transfer-Encoding header exists (as required by the spec), then specific actions must be taken.'}}, {'A1': {'code': 'if (apr_table_get(r->headers_in, ""Content-Length"")) {\n    apr_table_unset(r->headers_in, ""Content-Length"");\n    r->connection->keepalive = AP_CONN_CLOSE;\n}', 'explanation': 'When a Transfer-Encoding header is detected, the code checks for the presence of a Content-Length header. If found, it removes the Content-Length header, ensuring that it will not be sent with the message, thereby fulfilling the action required by the RFC.'}}]","The function explicitly checks for the presence of a Transfer-Encoding header and, if found, removes any Content-Length header from the incoming headers. This behavior directly implements the RFC requirement that a sender must not send a Content-Length header in any message that contains a Transfer-Encoding header. All relevant conditions (C1) and actions (A1) from the specification are directly addressed within the function itself.",success,
12313,h1_post_read_request,"If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.",202,Partially Matches,"[{'C1': {'code': 'if (tenc) {\n    r->body_indeterminate = 1;\n\n    /* https://tools.ietf.org/html/rfc7230\n     * Section 3.3.3.3: ""If a Transfer-Encoding header field is\n     * present in a request and the chunked transfer coding is not\n     * the final encoding ...; the server MUST respond with the 400\n     * (Bad Request) status code and then close the connection"".\n     */\n    if (!ap_is_chunked(r->pool, tenc)) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02539)\n                      ""client sent unknown Transfer-Encoding ""\n                      ""(%s): %s"", tenc, r->uri);\n        return HTTP_BAD_REQUEST;\n    }', 'explanation': ""This segment checks if the Transfer-Encoding header is present and, if the final encoding is not 'chunked', it returns a 400 (Bad Request), matching the spec's requirement for handling an unrecoverable error in a request.""}}, {'A1': {'code': 'if (apr_table_get(r->headers_in, ""Content-Length"")) {\n    apr_table_unset(r->headers_in, ""Content-Length"");\n\n    /* Don\'t reuse this connection anyway to avoid confusion with\n     * intermediaries and request/reponse spltting.\n     */\n    r->connection->keepalive = AP_CONN_CLOSE;\n}', 'explanation': ""This segment addresses the condition when both Transfer-Encoding and Content-Length are present. It removes the Content-Length header and forces the connection to close, aligning with the spec's behavior of prioritizing Transfer-Encoding and avoiding potential smuggling issues.""}}]","The function inspects request headers to check for Transfer-Encoding. If it is present but not 'chunked', it returns a 400 Bad Request as required. Additionally, when both Transfer-Encoding and Content-Length headers exist, it unsets the Content-Length and shuts down connection reuse to avoid ambiguity. However, the function only partially implements the overall RFC handling, as it addresses only a subset of the framing and error conditions described in the spec.",success,
12313,h1_post_read_request,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'if (apr_table_get(r->headers_in, ""Content-Length"")) {\n    apr_table_unset(r->headers_in, ""Content-Length"");\n\n    /* Don\'t reuse this connection anyway to avoid confusion with\n     * intermediaries and request/reponse spltting.\n     */\n    r->connection->keepalive = AP_CONN_CLOSE;\n}', 'explanation': 'This code snippet removes the Content-Length header when a Transfer-Encoding header is present, which aligns with the RFC requirement that a sender MUST remove a Content-Length header (when it would be overridden) to avoid forwarding an incorrect value. However, the function does not attempt to verify if a Content-Length value is incorrect in cases outside of the presence of a Transfer-Encoding header.'}}]","The function partially implements the specified HTTP RFC. It addresses the scenario described in RFC7230 Section 3.3.3.3 by unsetting the Content-Length header when a Transfer-Encoding header is present, thereby preventing the forwarding of a potentially incorrect Content-Length. However, it does not perform any general validation of the Content-Length value to determine if it is known to be incorrect in other situations, so it does not fully meet the RFC requirement.",success,
12315,http_post_config,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,44,Does Not Match,[],"The provided function (http_post_config) does not contain any logic that addresses the Content-Length header field requirements specified in the RFC specification (e.g., conditions regarding 304 responses, HEAD requests, or other HTTP status codes). The function only performs configuration tasks related to asynchronous mode checking and multipart boundary generation, and does not interact with any HTTP header logic, thus it does not meet any of the labeled constraints (C1, A1, etc.) from the spec.",success,
12321,ap_h1_set_keepalive,"A sender SHOULD send a Connection header field (Section 7.6.1 of [HTTP]) containing the ""close"" connection option when it intends to close a connection.",212,Fully Matches,"[{'C1': {'code': 'r->connection->keepalive = AP_CONN_CLOSE;', 'explanation': 'This code explicitly marks the connection to be closed after the current response, addressing the condition that when the connection is not persistent, it will be closed.'}}, {'A1': {'code': 'if (!wimpy) {\n    apr_table_mergen(resp->headers, ""Connection"", ""close"");\n}\n\n... \nreturn 0;', 'explanation': ""In the scenario where the connection is not kept alive the function ensures that the response header includes 'Connection: close' as required by the RFC.""}}]","The provided function inspects various conditions to decide if the connection should be persistent. When those conditions fail, it marks the connection to be closed (C1) and adds the 'Connection: close' header (A1) to the response. This directly implements the RFC requirement that a sender SHOULD send a Connection header field with the 'close' option when intending to close the connection.",success,
12321,ap_h1_set_keepalive,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'if ((r->connection->keepalive != AP_CONN_CLOSE)\n    && !r->expecting_100\n    && (r->header_only\n        || AP_STATUS_IS_HEADER_ONLY(resp->status)\n        || apr_table_get(resp->headers, ""Content-Length"")\n        || ap_is_chunked(r->pool,\n                         apr_table_get(resp->headers, ""Transfer-Encoding""))\n        || ((r->proto_num >= HTTP_VERSION(1,1))\n            && (r->chunked = 1)))\n    && r->server->keep_alive\n    && (r->server->keep_alive_timeout > 0)\n    && ((r->server->keep_alive_max == 0)\n        || (left > 0))\n    && !ap_status_drops_connection(resp->status)\n    && !wimpy\n    && !ap_find_token(r->pool, conn, ""close"")\n    && (!apr_table_get(r->subprocess_env, ""nokeepalive"")\n        || apr_table_get(r->headers_in, ""Via""))\n    && ((ka_sent = ap_find_token(r->pool, conn, ""keep-alive""))\n        || (r->proto_num >= HTTP_VERSION(1,1)))\n    && is_mpm_running()) { ... }', 'explanation': 'This conditional block evaluates whether the conditions for sustaining a persistent (keep-alive) connection are met. It checks several connection and response attributes, the maximum allowed requests, and whether the client requested closure, thereby addressing the need to sustain persistent connections when possible (as per the spec).'}}, {'A1': {'code': 'if (ka_sent) {\n    if (r->server->keep_alive_max) {\n        apr_table_setn(resp->headers, ""Keep-Alive"",\n               apr_psprintf(r->pool, ""timeout=%d, max=%d"",\n                    (int)apr_time_sec(r->server->keep_alive_timeout),\n                    left));\n    }\n    else {\n        apr_table_setn(resp->headers, ""Keep-Alive"",\n              apr_psprintf(r->pool, ""timeout=%d"",\n                    (int)apr_time_sec(r->server->keep_alive_timeout)));\n    }\n    apr_table_mergen(resp->headers, ""Connection"", ""Keep-Alive"");\n}', 'explanation': ""This segment actively sets the 'Keep-Alive' header with appropriate timeout and max values if the client sent a keep-alive hint. It clearly implements part of the action to manage persistent connections by informing the client of the server's intended behavior.""}}]","The function implements logic to decide whether a connection should remain persistent or be closed. It performs a series of conditional checks (C1) to ensure the connection can be maintained under proper conditions and, if so, sets the proper headers (A1) to negotiate a keep-alive connection. However, while the code addresses sustaining persistent connections, it does not explicitly handle the secondary aspect of deferring to flow-control mechanisms as mentioned in the RFC. Therefore, only part of the specification is addressed directly in this function, leading to a determination of 'Partially Matches'.",success,
12321,ap_h1_set_keepalive,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'C1': {'code': 'if ((r->connection->keepalive != AP_CONN_CLOSE)\n    && !r->expecting_100\n    && (r->header_only || AP_STATUS_IS_HEADER_ONLY(resp->status) || apr_table_get(resp->headers, ""Content-Length"") || ap_is_chunked(r->pool, apr_table_get(resp->headers, ""Transfer-Encoding"")) || ((r->proto_num >= HTTP_VERSION(1,1)) && (r->chunked = 1)))\n    && r->server->keep_alive\n    && (r->server->keep_alive_timeout > 0)\n    && ((r->server->keep_alive_max == 0) || (left > 0))\n    && !ap_status_drops_connection(resp->status)\n    && !wimpy\n    && !ap_find_token(r->pool, conn, ""close"")\n    && (!apr_table_get(r->subprocess_env, ""nokeepalive"") || apr_table_get(r->headers_in, ""Via""))\n    && ((ka_sent = ap_find_token(r->pool, conn, ""keep-alive"")) || (r->proto_num >= HTTP_VERSION(1,1)))\n    && is_mpm_running()) {\n    r->connection->keepalive = AP_CONN_KEEPALIVE;\n    r->connection->keepalives++;\n    ...\n}', 'explanation': 'This block verifies multiple conditions (HTTP version, client headers, server configuration, and connection status) consistent with the requirement that HTTP/1.1 implementations support persistent (keep‐alive) connections. It determines if the current connection can remain persistent based solely on the logic within the function.'}}, {'A1': {'code': 'if (ka_sent) {\n    if (r->server->keep_alive_max) {\n        apr_table_setn(resp->headers, ""Keep-Alive"",\n               apr_psprintf(r->pool, ""timeout=%d, max=%d"",\n                    (int)apr_time_sec(r->server->keep_alive_timeout),\n                    left));\n    } else {\n        apr_table_setn(resp->headers, ""Keep-Alive"",\n              apr_psprintf(r->pool, ""timeout=%d"",\n                    (int)apr_time_sec(r->server->keep_alive_timeout)));\n    }\n    apr_table_mergen(resp->headers, ""Connection"", ""Keep-Alive"");\n}', 'explanation': ""This segment sets the appropriate Keep-Alive header in the response if the client indicated support for it (via a 'keep-alive' token). By doing so, it actively implements the action of maintaining a persistent connection as outlined in the HTTP specification.""}}]","The function ap_h1_set_keepalive explicitly implements the support for persistent connections required by the HTTP specification. It checks all necessary preconditions including the protocol version, connection tokens, and server configuration (C1) to decide whether the connection should remain active. Additionally, if the client supports it, the function adds the proper 'Keep-Alive' header (A1) to the response, satisfying the requirements set forth in the spec. The logic is entirely contained within the function, fulfilling the specification's intent.",success,
12323,ap_condition_if_match,"When an origin server receives a request that selects a representation and that request includes an If-Match header field, the origin server MUST evaluate the If-Match condition per Section 13.2 prior to performing the method.",98,Fully Matches,"[{'C1': {'code': 'if ((if_match = apr_table_get(r->headers_in, ""If-Match"")) != NULL) {\n    if (if_match[0] == \'*\'\n            || ((etag = apr_table_get(headers, ""ETag"")) != NULL\n                    && ap_find_etag_strong(r->pool, if_match, etag))) {', 'explanation': ""This segment checks whether the If-Match header field exists and first tests if its value is '*' (as required by the spec). If not, it retrieves the representation's ETag and proceeds to evaluate the condition using a strong comparison, thereby covering the evaluation of both the '*' special case and the list of entity tags.""}}, {'A1': {'code': 'ap_find_etag_strong(r->pool, if_match, etag)', 'explanation': 'This call implements the requirement to use the strong comparison function (per Section 13.3.3 of the RFC) for matching entity tags, ensuring that the criteria for strong validation are met.'}}]","The function 'ap_condition_if_match' checks for the presence of the If-Match header and evaluates it according to the specification: if the value is '*' it returns a strong match, otherwise it retrieves the ETag of the selected representation and uses a strong comparison function to determine if any of the provided entity tags match. This implementation addresses both the condition for '*' and the condition for a list of entity tags, fully fulfilling the RFC requirements in the function itself.",success,
12323,ap_condition_if_match,"An origin server MUST use the strong comparison function when comparing entity tags for If-Match (Section 8.8.3.2), since the client intends this precondition to prevent the method from being applied if there have been any changes to the representation data.",97,Fully Matches,"[{'C1': {'code': 'if (if_match[0] == \'*\' || ((etag = apr_table_get(headers, ""ETag"")) != NULL && ap_find_etag_strong(r->pool, if_match, etag))) { return AP_CONDITION_STRONG; }', 'explanation': ""This segment checks for the presence of an 'If-Match' header and, if it is not the wildcard '*', retrieves the 'ETag' header and uses 'ap_find_etag_strong' to perform a strong comparison according to the RFC requirement.""}}]","The function implements the RFC specification by verifying the 'If-Match' header and then using a strong comparison function (ap_find_etag_strong) to compare the entity tags, which directly satisfies the requirement that an origin server must use a strong comparison function when processing the If-Match precondition. All this logic resides within the function, thereby fulfilling the spec constraint.",success,
12325,ap_condition_if_none_match,A server MAY ignore the Range header field.,126,Does Not Match,[],"The RFC specifies that a server MAY ignore the Range header field, particularly for methods other than GET or in cases where range handling is not defined. The provided function, however, is focused on determining entity tag matching based on the If-None-Match header and adjusts the ETag comparison (strong vs weak) only when a Range header is present in a GET request. It does not implement logic to ignore or bypass the Range header as described in the RFC. Therefore, there is no visible code in the function that directly addresses the spec constraint.",success,
12325,ap_condition_if_none_match,"When an origin server receives a request that selects a representation and that request includes an If-None-Match header field, the origin server MUST evaluate the If-None-Match condition per Section 13.2 prior to performing the method.",103,Fully Matches,"[{'C1': {'code': ""if (if_nonematch[0] == '*') {\n    return AP_CONDITION_STRONG;\n}"", 'explanation': ""This segment checks if the If-None-Match header contains '*' and returns a strong match result, which is the function’s way of indicating that the condition should be evaluated as matched (i.e. the precondition fails) when a current representation exists.""}}, {'C2': {'code': 'if (r->method_number == M_GET) {\n    if ((etag = apr_table_get(headers, ""ETag"")) != NULL) {\n        if (apr_table_get(r->headers_in, ""Range"")) {\n            if (ap_find_etag_strong(r->pool, if_nonematch, etag)) {\n                return AP_CONDITION_STRONG;\n            }\n        } else {\n            if (ap_find_etag_weak(r->pool, if_nonematch, etag)) {\n                return AP_CONDITION_WEAK;\n            }\n        }\n    } else if ((etag = apr_table_get(headers, ""ETag"")) != NULL\n            && ap_find_etag_strong(r->pool, if_nonematch, etag)) {\n        return AP_CONDITION_STRONG;\n    }', 'explanation': 'This code block implements the evaluation when the header value is a list of entity tags. For GET requests, it uses a weak comparison (unless a Range header is present, in which case it forces a strong comparison) as specified by the RFC, while for other methods it uses a strong comparison. This logic directly reflects the requirements listed in the spec context.'}}]","The function 'ap_condition_if_none_match' inspects the If-None-Match header and distinguishes between the special '*' value and a list of entity tags. It then applies the appropriate comparison method (weak for GET/HEAD when possible, strong for unsafe methods or when a Range header forces strong comparison), which is in line with the RFC specification describing the evaluation of this header field. All required conditions for evaluating the If-None-Match header per the spec have been implemented in the function itself.",success,
12326,ap_condition_if_modified_since,"When an origin server receives a request that selects a representation and that request includes an If-Modified-Since header field without an If-None-Match header field, the origin server SHOULD evaluate the If-Modified-Since condition per Section 13.2 prior to performing the method.",109,Partially Matches,"[{'C1': {'code': 'if ((if_modified_since = apr_table_get(r->headers_in, ""If-Modified-Since"")) != NULL) { ... }', 'explanation': 'The function begins by checking for the presence of an If-Modified-Since header in the incoming request, which is in line with the condition requiring its evaluation. However, it does not check for the absence of an If-None-Match header as the RFC specifies.'}}, {'A1': {'code': 'mtime = apr_time_sec(apr_date_parse_http(apr_table_get(headers, ""Last-Modified"")));\n...\nims = apr_time_sec(apr_date_parse_http(if_modified_since));\n\nif (ims >= mtime && ims <= reqtime) {\n    if (reqtime < mtime + 60) {\n        if (apr_table_get(r->headers_in, ""Range"")) {\n            return AP_CONDITION_NOMATCH;\n        } else {\n            return AP_CONDITION_WEAK;\n        }\n    } else {\n        return AP_CONDITION_STRONG;\n    }\n} else {\n    return AP_CONDITION_NOMATCH;\n}', 'explanation': ""The function evaluates the If-Modified-Since condition by comparing the parsed header value against the selected representation's Last-Modified date and the request time in seconds. This comparison corresponds to the RFC’s requirement to check if the representation has been modified.""}}]","The code function partially implements the HTTP RFC for If-Modified-Since handling. It properly detects and processes the If-Modified-Since header by comparing it against the Last-Modified value and the current request time. However, it does not verify that the If-None-Match header is absent, a stipulation that is explicitly required by the RFC. Consequently, while some of the logical actions are addressed within the function, the full set of spec constraints is not entirely met by this implementation alone.",success,
12326,ap_condition_if_modified_since,A server MAY ignore the Range header field.,126,Partially Matches,"[{'A1': {'code': 'if (apr_table_get(r->headers_in, ""Range"")) {\n    /* weak matches not allowed with Range requests */\n    return AP_CONDITION_NOMATCH;\n}', 'explanation': 'Within the function, there is an explicit check for the presence of a Range header. When a Range header is found in a situation where a weak match might otherwise have been returned, the function deliberately avoids a weak match by returning AP_CONDITION_NOMATCH. This shows an attempt to handle Range header cases as per the HTTP specification, even though the spec permits the server to ignore the Range header and this function instead uses it to affect the validation outcome.'}}]","The HTTP RFC states that a server may ignore the Range header field on a GET request, but this function does not ignore the header. Instead, it uses the existence of a Range header to disallow a weak match when the conditions for an If-Modified-Since check are only marginally met. Therefore, while the function does inspect the Range header and alters its behavior accordingly (addressing part of the specification), it does not fully implement the optional ignoring behavior specified in the RFC. As a result, the implementation in this function only partially matches the specification.",success,
12327,ap_condition_if_range,A server MAY ignore the Range header field.,126,Does Not Match,[],"The provided function solely inspects and evaluates the 'If-Range' header in combination with the 'Range' header to determine if a strong or weak match exists. It does not implement any logic that explicitly ignores the 'Range' header or verifies that the request method is GET as specified by the RFC. Since the RFC’s primary allowance—'A server MAY ignore the Range header field'—is not addressed within this function's own logic, no labeled condition or action from the spec constraints is implemented here.",success,
12327,ap_condition_if_range,A server MUST ignore an If-Range header field received in a request that does not contain a Range header field.,119,Fully Matches,"[{'C1': {'code': 'if ((if_range = apr_table_get(r->headers_in, ""If-Range"")) && apr_table_get(r->headers_in, ""Range"")) { ... }', 'explanation': 'The function only processes the If-Range header if the Range header is present. If the Range header is absent, the function falls through and returns AP_CONDITION_NONE, thereby effectively ignoring the If-Range header in accordance with the RFC requirement.'}}]","The provided function checks for the presence of both If-Range and Range headers before proceeding. This ensures that if a request contains an If-Range header without a Range header, the function ignores it by returning AP_CONDITION_NONE. This behavior fully implements the specified RFC requirement that a server must ignore an If-Range header if no Range header is present.",success,
12327,ap_condition_if_range,An origin server MUST ignore an If-Range header field received in a request for a target resource that does not support Range requests.,120,Partially Matches,"[{'C1': {'code': 'if ((if_range = apr_table_get(r->headers_in, ""If-Range"")) && apr_table_get(r->headers_in, ""Range"")) { ... } ... return AP_CONDITION_NONE;', 'explanation': ""The code checks for the existence of both the 'If-Range' and 'Range' headers. If the 'Range' header is not present (or, by extension, if the target resource does not indicate range support via a Range header), the function returns AP_CONDITION_NONE, thereby ignoring the 'If-Range' header. This meets the requirement to ignore the header when no Range is specified; however, it does not explicitly verify whether the target resource supports range requests, so only part of the RFC requirement is handled within this function.""}}]","The function's logic implements the aspect of the RFC that requires the server to ignore an 'If-Range' header if the request does not include a 'Range' header. This is accomplished by checking for the presence of both headers and returning a default value (AP_CONDITION_NONE) if the 'Range' header is absent. However, the RFC also mandates that the 'If-Range' header be ignored for target resources that do not support range requests. The function does not include any explicit logic to verify whether the target resource actually supports range requests, relying solely on the existence of the 'Range' header in the request. Therefore, while it addresses part of the specification (C1), it only partially meets the overall requirement.",success,
12327,ap_condition_if_range,A server that receives an If-Range header field on a Range request MUST evaluate the condition per Section 13.2 prior to performing the method.,121,Partially Matches,"[{'C1': {'code': 'if (if_range[0] == \'""\') {\n\n    if ((etag = apr_table_get(headers, ""ETag""))\n            && !strcmp(if_range, etag)) {\n        return AP_CONDITION_STRONG;\n    }\n    else {\n        return AP_CONDITION_NOMATCH;\n    }\n\n}', 'explanation': ""This segment handles the case when the If-Range header contains an entity tag (identified by a leading double quote). It retrieves the ETag from the headers and performs an exact string comparison, returning a strong match if they are identical. This mirrors the spec's requirement for entity tag validation.""}}]","The function distinguishes between two formats for the If-Range header: an entity tag and an HTTP-date. The entity tag branch (C1) directly compares the If-Range value with the ETag header, which fully meets the corresponding spec requirement. However, the HTTP-date branch adds an extra step by comparing the parsed date (rtime) with Last-Modified (mtime) and then further checking the request's Date header (reqtime) against mtime+60 to decide if the match is strong or not. This extra logic deviates from the RFC specification, which simply requires that the provided HTTP-date exactly match Last-Modified to be considered a strong validator. As this branch does not fully align with the spec (and its handling of strength is not clearly in accordance with Section 8.8.2.2 or Section 13.2), the overall implementation in the function only partially addresses the spec constraints.",success,
12327,ap_condition_if_range,A recipient of an If-Range header field MUST ignore the Range header field if the If-Range condition evaluates to false.,122,Fully Matches,"[{'C1': {'code': 'if ((if_range = apr_table_get(r->headers_in, ""If-Range"")) && apr_table_get(r->headers_in, ""Range"")) {\n    if (if_range[0] == \'""\') {\n        if ((etag = apr_table_get(headers, ""ETag"")) && !strcmp(if_range, etag)) {\n            return AP_CONDITION_STRONG;\n        }\n        else {\n            return AP_CONDITION_NOMATCH;\n        }\n    }\n    else {\n        /* Date based comparison logic */\n        ...\n        if (rtime == mtime) {\n            if (reqtime < mtime + 60) {\n                return AP_CONDITION_NOMATCH;\n            }\n            else {\n                return AP_CONDITION_STRONG;\n            }\n        }\n        else {\n            return AP_CONDITION_NOMATCH;\n        }\n    }\n}\nreturn AP_CONDITION_NONE;', 'explanation': 'The code first checks if both an \'If-Range\' and a \'Range\' header are present. For an entity-tag (indicated by a leading \'""\'), it performs an exact (strong) comparison with the ETag header. If they match, it returns a success state (AP_CONDITION_STRONG), otherwise it returns AP_CONDITION_NOMATCH, effectively causing the Range header to be ignored as specified. In the non-tag (date) case the function similarly compares the parsed dates and returns AP_CONDITION_NOMATCH if the condition fails.'}}]","The function implements the RFC requirement by evaluating the If-Range condition in isolation. It checks for the presence of both the If-Range and Range headers and then performs an exact comparison—using a strong comparison for entity-tags and an equivalent check for HTTP-date values—to decide whether to process the Range header. Returning AP_CONDITION_NOMATCH when the condition is false fulfills the specified behavior to ignore the Range header, thereby fully matching the RFC specification as required.",success,
12327,ap_condition_if_range,"Otherwise, the recipient SHOULD process the Range header field as requested.",123,Fully Matches,"[{'C1': {'code': 'if (if_range[0] == \'""\') {\n    if ((etag = apr_table_get(headers, ""ETag"")) && !strcmp(if_range, etag)) {\n        return AP_CONDITION_STRONG;\n    } else {\n        return AP_CONDITION_NOMATCH;\n    }\n}', 'explanation': 'This block checks whether the If-Range header value is an entity-tag (indicated by a starting quote), and then performs an exact string comparison with the ETag header value using strcmp. This implements the RFC requirement that if the entity-tag exactly matches, the condition is true; otherwise it is false.'}}, {'A1': {'code': 'if (if_range = apr_table_get(r->headers_in, ""If-Range"")) && apr_table_get(r->headers_in, ""Range"") { ... return AP_CONDITION_STRONG or AP_CONDITION_NOMATCH; }', 'explanation': 'The function returns AP_CONDITION_STRONG when the If-Range condition is met (meaning the Range header SHOULD be processed) and returns AP_CONDITION_NOMATCH when it isn’t (implying that the Range header MUST be ignored). This conditional return behavior fulfills the action specified by the RFC.'}}]","The function_body inspects the If-Range header and distinguishes between an entity-tag and a date value. For an entity-tag (when the header value starts with a quote), it compares this value exactly with the ETag header value using strcmp. If they match, the function returns AP_CONDITION_STRONG, indicating that the Range header should be processed as requested; if not, it returns AP_CONDITION_NOMATCH, which leads to ignoring the Range header. This logic directly implements the constraint described in the RFC specification, fulfilling both the condition (C1) and the action (A1) within the function itself.",success,
12328,ap_meets_conditions,"An origin server that evaluates an If-None-Match condition MUST NOT perform the requested method if the condition evaluates to false; instead, the origin server MUST respond with either a) the 304 (Not Modified) status code if the request method is GET or HEAD or b) the 412 (Precondition Failed) status code for all other request methods.",104,Partially Matches,[],"The function includes logic to evaluate the If-None-Match header and takes action when the condition evaluates as false. In particular, it checks the result of ap_condition_if_none_match and, when the condition is met, it returns HTTP_PRECONDITION_FAILED for non-GET methods. However, the RFC requires that both GET and HEAD requests receive a 304 (Not Modified) response when the condition is false, but the code only explicitly checks for GET (r->method_number == M_GET). HEAD requests are not visibly addressed in the function, meaning that requirement (which can be labeled in our informal constraints as an action for GET/HEAD) is not fully implemented. Thus, while some of the spec constraints (e.g., responding with 412 for non-GET requests) are addressed, others (e.g., handling both GET and HEAD by sending 304) are only partially met by the function’s logic.",success,
12328,ap_meets_conditions,"When an origin server receives a request that selects a representation and that request includes an If-None-Match header field, the origin server MUST evaluate the If-None-Match condition per Section 13.2 prior to performing the method.",103,Partially Matches,"[{'C1': {'code': 'cond = ap_condition_if_none_match(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    not_modified = 0;\n}\nelse if (cond >= AP_CONDITION_WEAK) {\n    if (r->method_number == M_GET) {\n        if (not_modified) {\n            not_modified = 1;\n        }\n    }\n    else {\n        return HTTP_PRECONDITION_FAILED;\n    }\n}', 'explanation': ""This segment evaluates the If-None-Match header field as required by the RFC. It calls a helper function to compare the client’s entity-tags (or '*' value) with the resource's ETag and then sets a flag or returns an error status based on the HTTP method in use.""}}, {'A1': {'code': 'if (r->method_number == M_GET) {\n    if (not_modified) {\n        not_modified = 1;\n    }\n} else {\n    return HTTP_PRECONDITION_FAILED;\n}', 'explanation': 'This part applies the RFC-specified action by returning HTTP_NOT_MODIFIED (later used when not_modified equals 1) for GET requests and HTTP_PRECONDITION_FAILED for methods other than GET when the condition evaluates as matched.'}}]","The function contains explicit logic to evaluate the If-None-Match header and take an appropriate action based on the HTTP method. It checks for the '*' wildcard or matching ETags via a helper function and then decides whether to eventually return 304 Not Modified (for GET requests) or 412 Precondition Failed (for methods like PUT). However, the logic isn’t fully comprehensive as it does not separately handle all safe methods (e.g., HEAD) and relies on external condition helpers for parts of the evaluation. Thus, the code function only partially meets the RFC constraints on its own.",success,
12328,ap_meets_conditions,"Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code",100,Fully Matches,"[{'C1': {'code': 'cond = ap_condition_if_match(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    return HTTP_PRECONDITION_FAILED;\n}', 'explanation': 'This block implements the RFC requirement for evaluating an If‐Match header. It checks if the condition fails (i.e. when no matching ETag is found) and returns a 412 (Precondition Failed) status, exactly as specified.'}}, {'C2': {'code': 'cond = ap_condition_if_unmodified_since(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    not_modified = 0;\n}\nelse if (cond >= AP_CONDITION_WEAK) {\n    return HTTP_PRECONDITION_FAILED;\n}', 'explanation': 'This segment examines the If-Unmodified-Since header and enforces the precondition by returning a 412 status when the document has been modified since the given time.'}}, {'C3': {'code': 'cond = ap_condition_if_none_match(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    not_modified = 0;\n}\nelse if (cond >= AP_CONDITION_WEAK) {\n    if (r->method_number == M_GET) {\n        if (not_modified) {\n            not_modified = 1;\n        }\n    }\n    else {\n        return HTTP_PRECONDITION_FAILED;\n    }\n}', 'explanation': 'This code handles the If-None-Match header. For non-GET methods, if a match is found it returns a 412 status as required. For GET requests, it prepares to return a 304 (Not Modified), which is in line with the RFC’s allowances.'}}]","The function 'ap_meets_conditions' directly implements the RFC-mandated behavior for handling conditional requests. It checks the key conditional headers (If-Match, If-Unmodified-Since, and If-None-Match) and, when the necessary conditions are not met, returns a 412 (Precondition Failed) status code, thereby fulfilling the spec constraints. All the logic to evaluate and respond according to the conditions appears in the function itself, independently of its dependencies, so the implementation fully matches the intent of the RFC.",success,
12328,ap_meets_conditions,An origin server that evaluates an If-Match condition MUST NOT perform the requested method if the condition evaluates to false,99,Fully Matches,"[{'C1': {'code': 'cond = ap_condition_if_match(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    return HTTP_PRECONDITION_FAILED;\n}', 'explanation': 'This code segment retrieves the result of evaluating the If-Match header (using ap_condition_if_match) and, if the condition evaluates to false (AP_CONDITION_NOMATCH), it immediately returns a 412 (Precondition Failed) status, directly implementing the RFC requirement.'}}]","The function ap_meets_conditions explicitly checks the If-Match header condition. When the condition evaluates as false, the function returns HTTP_PRECONDITION_FAILED, thereby ensuring that the requested method is not performed—fulfilling the key RFC requirement stated in the specification. Although the function also handles other conditional headers (e.g., If-Unmodified-Since, If-None-Match, If-Modified-Since, and If-Range), the core RFC constraint regarding the If-Match condition is completely addressed within this function.",success,
12328,ap_meets_conditions,"When an origin server receives a request that selects a representation and that request includes an If-Match header field, the origin server MUST evaluate the If-Match condition per Section 13.2 prior to performing the method.",98,Fully Matches,"[{'C1': {'code': 'cond = ap_condition_if_match(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    return HTTP_PRECONDITION_FAILED;\n}', 'explanation': ""This code segment directly implements the evaluation of the If-Match header as specified. It checks if an If-Match header is present and, if the strong ETag of the selected representation does not match any entity tag in the header (and the header value is not '*'), it returns a 412 (Precondition Failed) status, thereby fulfilling the RFC requirement.""}}]","The function explicitly addresses the RFC requirement regarding If-Match header evaluation. By calling ap_condition_if_match and conditionally returning HTTP_PRECONDITION_FAILED, it meets the spec's mandate to evaluate the If-Match condition before performing the method. All necessary logic for this constraint is contained within the function_body, and thus the code fully matches the specified condition.",success,
12328,ap_meets_conditions,A server MAY ignore the Range header field.,126,Does Not Match,[],"The provided function (ap_meets_conditions) is primarily focused on evaluating conditional request headers such as If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since, and If-Range. Although there is a comment block that mentions the presence of an If-Range header and a Range header (""/* If an If-Range and an Range header is present, we must return 200 OK. The byterange filter will convert it to a range response. */""), this does not directly implement the RFC specification regarding ""A server MAY ignore the Range header field."" The function does not include any logic that selectively ignores a Range header based on the HTTP method (only GET being defined for range handling) or any other condition as described in the RFC. Instead, it defers range processing to later filters by returning OK when an If-Range condition is detected. Therefore, within the confines of this function alone, the specified RFC constraint is not visibly implemented.",success,
12328,ap_meets_conditions,"A server MUST ignore all received preconditions if its response to the same request without those conditions, prior to processing the request content, would have been a status code other than a 2xx (Successful) or 412 (Precondition Failed).",124,Fully Matches,"[{'C1': {'code': 'if (!ap_is_HTTP_SUCCESS(r->status) || r->no_local_copy) {\n    return OK;\n}', 'explanation': 'This code segment ensures that if the response status is not 2xx (successful) or if there is no local copy available, the function immediately returns OK without evaluating the conditional headers. This behavior mirrors the spec requirement that a server must ignore all received preconditions if the response (without evaluating them) would have been anything other than a 2xx or 412.'}}]","The function begins by checking whether the request's status indicates success. If not, it immediately returns OK, thus ignoring any preconditions as required by the RFC. For requests with successful status, the function then evaluates various conditional headers (If-Match, If-Unmodified-Since, If-None-Match, etc.) and returns HTTP_PRECONDITION_FAILED (412) or HTTP_NOT_MODIFIED (304) as appropriate. This direct handling of preconditions is fully in line with the spec constraints, and all the necessary conditions are visibly implemented within the function.",success,
12328,ap_meets_conditions,A server that receives an If-Range header field on a Range request MUST evaluate the condition per Section 13.2 prior to performing the method.,121,Partially Matches,"[{'C1': {'code': 'cond = ap_condition_if_range(r, r->headers_out);\n    if (cond > AP_CONDITION_NONE) {\n        return OK;\n    }', 'explanation': 'This segment examines the presence of an If‑Range header (by calling ap_condition_if_range) and then returns OK (i.e. defers to the byte‐range filter). It indicates an intent to address the RFC requirement that the server evaluate an If‑Range header before proceeding. However, the function does not itself implement the detailed evaluation of the HTTP‑date validator (e.g., checking for strong validators or comparing against Last-Modified) as specified in the RFC.'}}]","The function 'ap_meets_conditions' handles multiple conditional headers, including a branch for If‑Range. The code snippet for If‑Range shows that if an If‑Range header is present (and its condition returns a value greater than NONE), the function immediately returns OK, which aligns with the basic requirement to evaluate the header. However, the detailed RFC logic for how to process an HTTP-date (validator strength, exact match with Last-Modified, etc.) is not implemented directly within this function but likely deferred to the ap_condition_if_range call. Therefore, while the function visibly attempts to address the condition, it only partially meets the complete spec constraint on evaluating the condition per Section 13.2.",success,
12328,ap_meets_conditions,"Instead, the origin server MAY indicate that the conditional request failed by responding with a 412 (Precondition Failed) status code",117,Fully Matches,"[{'C1': {'code': 'cond = ap_condition_if_unmodified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        return HTTP_PRECONDITION_FAILED;\n    }', 'explanation': 'This segment directly examines the If-Unmodified-Since condition. It tests the header condition and, if the resource has been modified (i.e. condition fails), the function returns a 412 status, in line with the RFC requirement.'}}, {'A1': {'code': 'return HTTP_PRECONDITION_FAILED;', 'explanation': 'Multiple parts of the function (including the If-Match and If-None-Match checks) return HTTP_PRECONDITION_FAILED when a precondition fails, thus implementing the action of responding with a 412 status code when the conditional evaluation does not pass.'}}]","The function inspects various conditional headers such as If-Match and If-Unmodified-Since. In the case where the precondition fails (for example, when the resource has been modified since the date in the If-Unmodified-Since header), the function returns HTTP_PRECONDITION_FAILED (412) as specified by the RFC. This logic, contained entirely within the function body, directly corresponds to the conditions (C1) and action (A1) as required by the spec.",success,
12328,ap_meets_conditions,"When an origin server receives a request that selects a representation and that request includes an If-Unmodified-Since header field without an If-Match header field, the origin server MUST evaluate the If-Unmodified-Since condition per Section 13.2 prior to performing the method.",115,Partially Matches,"[{'C1': {'code': 'cond = ap_condition_if_unmodified_since(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    not_modified = 0;\n}\nelse if (cond >= AP_CONDITION_WEAK) {\n    return HTTP_PRECONDITION_FAILED;\n}', 'explanation': ""This block evaluates the If-Unmodified-Since condition and, if it determines that the resource has been modified (i.e. the condition evaluates to a value >= AP_CONDITION_WEAK), it returns a 412 Precondition Failed status, which aligns with the RFC's mandate to evaluate this header. However, the RFC specifies that this evaluation should occur only when an If-Unmodified-Since header is present without an If-Match header. The function handles If-Match in an earlier block, but does not explicitly check for the absence of the If-Match header before evaluating the If-Unmodified-Since condition within this same block.""}}]","The function implements logic to evaluate the If-Unmodified-Since condition according to the RFC (i.e., it returns HTTP_PRECONDITION_FAILED when the condition is not met). However, the RFC requires specifically that this evaluation occur only when the If-Unmodified-Since header is present and there is no accompanying If-Match header. Although the code separately handles the If-Match header check at the beginning, it does not couple that logic with the If-Unmodified-Since evaluation to explicitly satisfy the 'without an If-Match header' clause. Thus, while some of the constraint is implemented, it is only a partial match to the full specification.",success,
12328,ap_meets_conditions,"An origin server that evaluates an If-Modified-Since condition SHOULD NOT perform the requested method if the condition evaluates to false; instead, the origin server SHOULD generate a 304 (Not Modified) response, including only those metadata that are useful for identifying or updating a previously cached response.",110,Partially Matches,"[{'C1': {'code': 'cond = ap_condition_if_modified_since(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    not_modified = 0;\n}\nelse if (cond >= AP_CONDITION_WEAK) {\n    if (r->method_number == M_GET) {\n        if (not_modified) {\n            not_modified = 1;\n        }\n    }\n}', 'explanation': 'This segment attempts to evaluate the If-Modified-Since header by checking the modification condition. It follows the idea that if the resource has not been modified (i.e. the condition evaluates as false), then later a 304 response may be sent.'}}, {'A1': {'code': 'if (not_modified == 1) {\n    return HTTP_NOT_MODIFIED;\n}', 'explanation': 'This part of the code returns a 304 (Not Modified) response when the conditions (including If-Modified-Since) indicate that the resource has not been modified.'}}]","The function contains logic to evaluate conditional request headers, including If-Modified-Since, and returns a 304 response when the condition indicates that the resource is not modified. This covers part of the RFC specification regarding processing the If-Modified-Since header. However, the logic only explicitly checks for the GET method (instead of both GET and HEAD as specified) and does not handle the aspect of 'including only those metadata' in the response. Therefore, while key parts of the specification are addressed within the function, it does not fully implement all nuances of the RFC requirement.",success,
12328,ap_meets_conditions,An origin server that evaluates an If-Unmodified-Since condition MUST NOT perform the requested method if the condition evaluates to false,116,Fully Matches,"[{'C1': {'code': 'cond = ap_condition_if_unmodified_since(r, r->headers_out);\n    if (AP_CONDITION_NOMATCH == cond) {\n        not_modified = 0;\n    }\n    else if (cond >= AP_CONDITION_WEAK) {\n        return HTTP_PRECONDITION_FAILED;\n    }', 'explanation': ""This segment directly evaluates the If-Unmodified-Since header. If the condition evaluates as false (i.e., if the resource has been modified, indicated by a condition value '>= AP_CONDITION_WEAK'), the function returns HTTP_PRECONDITION_FAILED, thereby not performing the requested method, which aligns with the spec requirement.""}}]","The function 'ap_meets_conditions' includes a dedicated code block for evaluating the If-Unmodified-Since header field. When the condition evaluates false, it immediately returns a 412 (Precondition Failed) response, which prevents the request method from being performed. This directly implements the spec constraint that an origin server must not apply the method if the condition is false. Hence, within its own logic, the code fully meets the provided spec constraint.",success,
12328,ap_meets_conditions,A recipient cache or origin server MUST evaluate the request preconditions defined by this specification in the following order: 1.,284,Fully Matches,"[{'C1': {'code': 'cond = ap_condition_if_match(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    return HTTP_PRECONDITION_FAILED;\n}', 'explanation': 'This segment evaluates the If-Match precondition as required when the server is the origin. It checks the If-Match header and fails with an HTTP 412 status if the condition is not met.'}}, {'C2': {'code': 'cond = ap_condition_if_unmodified_since(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    not_modified = 0;\n}\nelse if (cond >= AP_CONDITION_WEAK) {\n    return HTTP_PRECONDITION_FAILED;\n}', 'explanation': 'This part evaluates the If-Unmodified-Since header, which applies when the If-Match is not present or has passed. It returns precondition failed when the resource has been modified after the specified time.'}}]","The function implements the RFC specification by first checking the If-Match precondition (C1) and, if that check does not cause an early return, then evaluating the If-Unmodified-Since precondition (C2). This ordering is in accordance with the spec constraints provided, thus the function visibly addresses both conditions within its own logic.",success,
12328,ap_meets_conditions,"Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method.",282,Fully Matches,"[{'C1': {'code': 'if (!ap_is_HTTP_SUCCESS(r->status) || r->no_local_copy) {\n    return OK;\n}', 'explanation': 'This check ensures that preconditions are only evaluated for requests that have passed the normal request processing (i.e. a 2xx response) and when a local copy is available. It mirrors the RFC requirement to postpone precondition evaluation until normal checks are successful.'}}, {'A1': {'code': 'cond = ap_condition_if_match(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    return HTTP_PRECONDITION_FAILED;\n}\n\ncond = ap_condition_if_unmodified_since(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    not_modified = 0;\n}\nelse if (cond >= AP_CONDITION_WEAK) {\n    return HTTP_PRECONDITION_FAILED;\n}\n\ncond = ap_condition_if_none_match(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    not_modified = 0;\n}\nelse if (cond >= AP_CONDITION_WEAK) {\n    if (r->method_number == M_GET) {\n        if (not_modified) {\n            not_modified = 1;\n        }\n    }\n    else {\n        return HTTP_PRECONDITION_FAILED;\n    }\n}\n\ncond = ap_condition_if_modified_since(r, r->headers_out);\nif (AP_CONDITION_NOMATCH == cond) {\n    not_modified = 0;\n}\nelse if (cond >= AP_CONDITION_WEAK) {\n    if (r->method_number == M_GET) {\n        if (not_modified) {\n            not_modified = 1;\n        }\n    }\n}\n\ncond = ap_condition_if_range(r, r->headers_out);\nif (cond > AP_CONDITION_NONE) {\n    return OK;\n}\n\nif (not_modified == 1) {\n    return HTTP_NOT_MODIFIED;\n}\n', 'explanation': 'This block evaluates each of the conditional headers (If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since, and If-Range) and returns the appropriate status codes (HTTP_PRECONDITION_FAILED, HTTP_NOT_MODIFIED, or OK) according to the RFC. It implements the action of failing the request when preconditions aren’t met and passing it otherwise, just before the request content would normally be processed.'}}]","The function ap_meets_conditions directly implements the RFC requirement by first ensuring that the request has passed basic success checks before evaluating any preconditions (C1). It then explicitly checks various conditional headers and returns the proper HTTP status codes (A1) in line with the RFC's mandates – for example, returning 412 Precondition Failed when a precondition is not met, and 304 Not Modified for GET/HEAD requests when appropriate. All of these checks occur inside this function, thereby fully addressing the specified requirements.",success,
12331,ap_method_registry_init,All general-purpose servers MUST support the methods GET and HEAD,58,Fully Matches,"[{'C1': {'code': 'register_one_method(p, ""GET"", M_GET);', 'explanation': 'This line registers the GET method, fulfilling the requirement that all general-purpose servers must support GET.'}}, {'C2': {'code': 'register_one_method(p, ""HEAD"", M_GET);', 'explanation': 'This line registers the HEAD method (as a special instance of GET), thereby fulfilling the requirement that HEAD must be supported.'}}]","The function 'ap_method_registry_init' initializes the methods registry by registering multiple HTTP methods. Specifically, it registers both GET and HEAD as required by the RFC specification, with HEAD sharing the same ID as GET. Since the RFC requirement stipulates that all general-purpose servers MUST support GET and HEAD, and this function explicitly registers both, the code within the function fully addresses the spec constraints on these two methods.",success,
12335,index_of_response,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Does Not Match,[],"The provided function simply performs numerical checks on the HTTP status code (ensuring it lies between 100 and 999) and computes an index based on arithmetic operations. It does not implement any defensive parsing of a protocol element, such as verifying conformity to an ABNF grammar or checking buffer sizes, as required by the RFC specification. Therefore, the function does not visibly address the spec constraint regarding defensive parsing.",success,
12338,ap_get_status_line,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function ap_get_status_line simply returns a status line string from a global array based on an index derived from the status code. It does not contain any logic that checks or enforces the RFC requirement that a sender must not generate protocol elements or syntax alternatives reserved for a different role. There is no validation of roles or restrictions regarding message syntax within the function itself, so it does not visibly address any of the labeled conditions or actions in the spec constraints.",success,
12340,ap_send_http_options,A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.,30,Fully Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Allow"", make_allow(r));\n\nreturn OK;', 'explanation': ""The function handles an OPTIONS request by setting the 'Allow' header and returns OK without attempting any protocol switch. This directly reflects the specification that an OPTIONS request can be honored by any protocol and that no protocol switching is performed.""}}]","The provided code function only deals with processing an OPTIONS request by setting the 'Allow' header and returning a success status. It does not attempt any protocol switching, which is acceptable because the RFC explicitly states that an OPTIONS request can be honored by any protocol. All necessary logic for OPTIONS handling is contained solely within this function, fulfilling the relevant spec requirements.",success,
12340,ap_send_http_options,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,44,Does Not Match,[],"The provided function, ap_send_http_options, only sets the 'Allow' header and returns OK; it does not interact with or implement any logic related to handling the Content-Length header in accordance with the HTTP RFC constraints. No part of the function addresses conditions such as checking for conditional GET requests or verifying that the Content-Length value matches a specific content size. Hence, none of the specified constraints (like those pertaining to Content-Length in the RFC) are met by this function.",success,
12340,ap_send_http_options,"A server generating a successful response to OPTIONS SHOULD send any header that might indicate optional features implemented by the server and applicable to the target resource (e.g., Allow), including potential extensions not defined by this specification.",77,Fully Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Allow"", make_allow(r));', 'explanation': ""This line sets the 'Allow' header in the response, directly addressing the spec requirement that a server generating a successful OPTIONS response SHOULD send a header indicating optional features (e.g., 'Allow') applicable to the target resource.""}}]","The function checks if the request is non-backwards, and when appropriate, it sets the 'Allow' header using the make_allow function. This action visibly implements the RFC requirement by sending a header that signals the optional features available for the target resource. All the relevant logic for this part of the spec is contained within this function.",success,
12342,ap_set_content_type_ex,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,[],"The RFC states that a sender generating a message containing content SHOULD generate a Content-Type header unless the intended media type is unknown to the sender. In the function, the call to ap_set_content_type(r, ct) clearly attempts to set the Content-Type header field. However, there is no logic within the function that checks whether the media type is unknown or not. Instead, it unconditionally sets the Content-Type based on the provided ct parameter. Because the function does not implement any condition to handle cases where the media type might be unknown, it only partially matches the RFC requirement. Note that any handling of unknown media types outside of this function (e.g., in callers or other modules) does not count toward this function’s implementation according to the instructions.",success,
12343,ap_set_accept_ranges,A server that does not support any kind of range request for the target resource MAY send,286,Fully Matches,"[{'C1': {'code': '(d->max_ranges == AP_MAXRANGES_NORANGES) ? ""none"" : ""bytes""', 'explanation': 'This segment checks if the server configuration indicates no range support (i.e. max_ranges equals AP_MAXRANGES_NORANGES) and accordingly selects ""none"". This meets the spec condition that a server that does not support any kind of range request MAY send Accept-Ranges: none.'}}, {'A1': {'code': 'apr_table_setn(r->headers_out, ""Accept-Ranges"", ...)', 'explanation': 'By setting the Accept-Ranges header to either ""none"" or ""bytes"" based on configuration, the function directly implements the action of sending an Accept-Ranges header that reflects the server\'s capability regarding range requests.'}}]","The function defines a logic branch based on the server's configuration to determine if range requests are supported. If not supported, it sets the Accept-Ranges header to ""none"", directly addressing the RFC requirement. When range requests are supported, it sets the header to ""bytes"". All logic needed to implement the specified constraints is contained within the function, thereby fully matching the constraints specified in the HTTP RFC.",success,
12343,ap_set_accept_ranges,"The Accept-Ranges field MAY be sent in a trailer section, but is preferred to be sent as a header field because the information is particularly useful for restarting large information transfers that have failed in mid-content (before the trailer section is received).",133,Fully Matches,"[{'C1': {'code': 'apr_table_setn(r->headers_out, ""Accept-Ranges"", (d->max_ranges == AP_MAXRANGES_NORANGES) ? ""none"" : ""bytes"");', 'explanation': 'This line ensures that the Accept-Ranges header is set as a header field (not in the trailer) which is preferred per the specification.'}}, {'A1': {'code': '(d->max_ranges == AP_MAXRANGES_NORANGES) ? ""none"" : ""bytes""', 'explanation': ""This conditional sets the value to 'none' when no range requests should be permitted (thereby advising against such requests) and 'bytes' otherwise, directly implementing the spec requirement regarding range handling.""}}]","The function directly implements the spec by using the server configuration (d->max_ranges) to determine whether to allow range requests. It then sets the Accept-Ranges header field accordingly: using 'none' to advise the client that range requests should not be attempted, or 'bytes' if they are supported. This satisfies both the requirement to use a header field for Accept-Ranges and the reservation of the 'none' value as described in the specification.",success,
12345,get_canned_error_string,A server that receives an Expect field value containing a member other than 100-continue MAY respond with a 417 (Expectation Failed) status code to indicate that the unexpected expectation cannot be met.,79,Partially Matches,"[{'C1': {'code': 'case HTTP_EXPECTATION_FAILED:\n    s1 = apr_table_get(r->headers_in, ""Expect"");\n    if (s1)\n        s1 = apr_pstrcat(p,\n                 ""<p>The expectation given in the Expect request-header\\n""\n                 ""field could not be met by this server.\\n""\n                 ""The client sent<pre>\\n    Expect: "",\n                 ap_escape_html(r->pool, s1), ""\\n</pre>\\n"",\n                 NULL);\n    else\n        s1 = ""<p>No expectation was seen, the Expect request-header \\n""\n             ""field was not presented by the client.\\n"";\n    return add_optional_notes(r, s1, ""error-notes"", ""</p>\\n""\n               ""<p>Only the 100-continue expectation is supported.</p>\\n"");', 'explanation': ""This segment handles the HTTP_EXPECTATION_FAILED case (417). It retrieves the 'Expect' header and constructs an error message that informs the client that only the 100-continue expectation is supported, which corresponds to the spec requirement that a server may respond with a 417 status if an unexpected expectation is received.""}}]","The function 'get_canned_error_string' provides canned error messages for various HTTP statuses. In the case for HTTP_EXPECTATION_FAILED, it clearly constructs an error message indicating that only the 100-continue expectation is supported. While this provides the expected error message as per the RFC specification, the function does not itself validate that the expectation in the header is not '100-continue' (it merely retrieves and prints the header value). Thus, it only partially addresses the spec requirement by handling the error response once the status is already set to HTTP_EXPECTATION_FAILED.",success,
12346,ap_send_error_response,An origin server MUST generate an Allow header field in a 405 (Method Not Allowed) response and MAY do so in any other response.,88,Fully Matches,"[{'C1': {'code': 'if ((status == HTTP_METHOD_NOT_ALLOWED) || (status == HTTP_NOT_IMPLEMENTED)) {\n            apr_table_setn(r->headers_out, ""Allow"", make_allow(r));\n        }', 'explanation': ""This block implements the RFC requirement by checking if the response status is HTTP_METHOD_NOT_ALLOWED (405) (and also covers HTTP_NOT_IMPLEMENTED as an additional case) and then explicitly setting the 'Allow' header field using the result of the make_allow(r) function.""}}]","The function_body explicitly addresses the RFC specification that mandates an origin server to generate an 'Allow' header in a 405 response. The check for HTTP_METHOD_NOT_ALLOWED (and HTTP_NOT_IMPLEMENTED) followed by setting the 'Allow' header ensures that this requirement is met directly within this function, independent of any external dependencies.",success,
12346,ap_send_error_response,"An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",60,Fully Matches,"[{'C1': {'code': 'if ((status == HTTP_METHOD_NOT_ALLOWED)\n            || (status == HTTP_NOT_IMPLEMENTED)) {\n            apr_table_setn(r->headers_out, ""Allow"", make_allow(r));\n        }', 'explanation': 'This code fragment directly checks if the error status is HTTP_METHOD_NOT_ALLOWED (405) – which corresponds to a recognized and implemented method not allowed for the target resource – and sets the Allow header accordingly. This implements the RFC requirement to include an Allow header with the 405 response.'}}]","The function ap_send_error_response processes error responses by checking the status code. In the case where the status is 405 (or even 501), it explicitly sets the Allow header using the make_allow function. This behavior directly implements the RFC directive, ensuring that for recognized but not allowed methods the origin server responds with a 405 status along with a list of allowed methods. Thus, the function visibly addresses the specified HTTP RFC condition within its own code.",success,
12346,ap_send_error_response,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,155,Partially Matches,"[{'A1': {'code': 'if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {\n    if ((location != NULL) && *location) {\n        apr_table_setn(r->headers_out, ""Location"", location);\n    }\n    else {\n        location = """";   /* avoids coredump when printing, below */\n    }\n}', 'explanation': 'For HTTP redirect responses (which include 301 Moved Permanently as part of the ap_is_HTTP_REDIRECT(status) check), the function ensures that if a Location header value exists (either originally in r->headers_out or from r->err_headers_out), it is re-set into the response headers. This is an attempt to satisfy the RFC requirement of including a Location header field. However, the function merely transfers an existing value rather than generating a preferred new permanent URI when one isn’t provided, which is why the match is partial.'}}]","The function shows clear logic for handling HTTP redirect responses by detecting a redirect status and then copying over a Location header into the outgoing headers. This addresses part of the RFC directive for 301 (Moved Permanently) responses. However, it does not actively generate a new preferred URI reference in cases where none is set; it only reuses an existing value if available. Thus, while the function does address the use of the Location header in redirect responses, it does not fully implement the spec's mandate to generate a new permanent URI if needed, leading to a partial match.",success,
12346,ap_send_error_response,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'A1': {'code': 'if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {\n    if ((location != NULL) && *location) {\n        apr_table_setn(r->headers_out, ""Location"", location);\n    }\n    else {\n        location = """";   /* avoids coredump when printing, below */\n    }\n}', 'explanation': 'This code block directly checks if the response status indicates a redirection (or a creation) and, if so, retrieves the Location header from the request (from either headers_out or err_headers_out) and explicitly sets it in the headers_out table. This behavior meets the RFC requirement that the server SHOULD include a Location header field with a URI reference for the different URI. The implementation is visible within this function and does not depend on external code.'}}]","The function implements the RFC requirement of generating a Location header by checking if the status code qualifies as a redirection (or creation) and, if a valid Location value exists, reassigns it to the outgoing headers. This directly addresses the action of including a Location header field in the redirection response as specified.",success,
12346,ap_send_error_response,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {\n    if ((location != NULL) && *location) {\n        apr_table_setn(r->headers_out, ""Location"", location);\n    }\n    else {\n        location = """";   /* avoids coredump when printing, below */\n    }\n}', 'explanation': 'This code branch specifically handles redirection responses. When the status is a redirect (which includes 307 if ap_is_HTTP_REDIRECT is defined accordingly) or HTTP_CREATED, it ensures that if a Location header exists (retrieved earlier from r->headers_out or r->err_headers_out), it is set in the outgoing headers. This behavior directly implements the RFC requirement that the server SHOULD generate a Location header for redirection responses.'}}]","The function clearly contains logic for generating a Location header when processing HTTP redirection responses. It clears the outgoing headers and then, in the appropriate status code branch (either a redirect or a creation), it checks for an existing Location value and reinserts it into r->headers_out. This implementation directly attempts to fulfill the RFC requirement that a Location header field be generated in such responses.",success,
12346,ap_send_error_response,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,160,Partially Matches,"[{'A1': {'code': 'if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {\n    if ((location != NULL) && *location) {\n        apr_table_setn(r->headers_out, ""Location"", location);\n    }\n    else {\n        location = """";   /* avoids coredump when printing, below */\n    }\n}', 'explanation': ""This code segment checks if the response status is a redirect (using ap_is_HTTP_REDIRECT) or HTTP_CREATED, and then sets the 'Location' header accordingly if a non-empty location exists. Although RFC 7538 (for 308 Permanent Redirect) is not explicitly checked, the function partially implements the action of generating a Location header field as required.""}}]","The function contains logic to set the 'Location' header for responses that are redirects (or HTTP_CREATED), which partially addresses the RFC requirement that a Location header should be generated for new permanent URIs. However, it does not explicitly check for or handle the 308 (Permanent Redirect) status code, and it only preserves the header if it already exists. Therefore, while some aspects of the spec are covered (action A1), the implementation is only a partial match to the complete specification.",success,
12346,ap_send_error_response,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'if (apr_table_get(r->subprocess_env, ""suppress-error-charset"") != NULL) {\n    core_request_config *request_conf = ap_get_core_module_config(r->request_config);\n    request_conf->suppress_charset = 1;\n    ap_set_content_type_ex(r, ""text/html"", 1);\n} else {\n    ap_set_content_type_ex(r, ""text/html; charset=iso-8859-1"", 1);\n}', 'explanation': ""This segment explicitly sets the Content-Type header for responses that include a message body. It checks for a condition (the 'suppress-error-charset') and then calls ap_set_content_type_ex with a valid content type, thus fulfilling the RFC requirement that a sender generating a message containing content should include a Content-Type header field.""}}]","The function ap_send_error_response constructs an error response that includes a body (unless header only). In doing so, it ensures a Content-Type header is set by explicitly calling ap_set_content_type_ex with an appropriate value. This directly addresses the spec constraint that a message containing content SHOULD have a Content-Type header, thereby fully matching the requirement.",success,
12346,ap_send_error_response,The origin server MUST generate an Allow header field in a 405 response containing a list of the target resource's currently supported methods.,164,Fully Matches,"[{'C1': {'code': 'if ((status == HTTP_METHOD_NOT_ALLOWED) || (status == HTTP_NOT_IMPLEMENTED)) {\n    apr_table_setn(r->headers_out, ""Allow"", make_allow(r));\n}', 'explanation': 'This code segment checks if the response status is 405 (Method Not Allowed) and, additionally, checks for 501 (Not Implemented). It then calls make_allow(r) to generate an Allow header field as required by the RFC.'}}, {'A1': {'code': 'apr_table_setn(r->headers_out, ""Allow"", make_allow(r));', 'explanation': ""This call fully implements the action of generating an Allow header field containing a list of the target resource's currently supported methods, fulfilling the RFC requirement.""}}]","The function explicitly handles the case for a 405 response (HTTP_METHOD_NOT_ALLOWED) and adds an 'Allow' header by calling make_allow(r). This directly satisfies the RFC specification that mandates the inclusion of the Allow header field in a 405 response. No other parts of the function hide or delegate this requirement, so the implementation fully meets the spec constraint within the function_body itself.",success,
12353,ap_h1_append_header,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function simply formats and appends a header field (concatenating the header name, a colon and a space, the header value, and a CRLF) to a bucket brigade. It does not implement any logic to verify or enforce the role-based restriction stated in the RFC (i.e., that a sender MUST NOT generate protocol elements only allowed by other roles). No condition or action logic is present in the function to check whether the header being appended adheres to the role-specific constraints of HTTP. Thus, it does not attempt to implement the specified RFC requirement within its isolated code.",success,
12354,ap_h1_append_headers,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function solely formats and appends HTTP header fields by constructing a string containing 'name: value CRLF'. It does not contain any logic to verify whether the protocol elements being generated are restricted to specific sender roles, nor does it enforce that elements only allowed to be generated by participants in other roles are not generated. In other words, it does not implement the requirement from the RFC specification regarding the generation of protocol elements based on the sender's role.",success,
12355,ap_h1_terminate_header,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function ap_h1_terminate_header simply writes a CRLF sequence to the output bucket and performs a protocol translation without any logic to verify or restrict the generation of protocol elements based on the sender's role. It lacks any checks or restrictions to ensure that elements generated are only those permitted for the sender's role, as required by the RFC specification. Therefore, none of the specified constraints (e.g., C1, A1) are addressed within the function itself.",success,
12359,tokenize_request_line,"Although the request-line grammar rule requires that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the CRLF terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR.",177,Partially Matches,[],"The function tokenizes a request‐line into method, URI, and protocol segments and checks for whitespace and separation by inspecting for SP characters. For example, it scans for leading whitespace in the method (lines 3–7) and then uses a loop (lines 27–29 and later) to advance over whitespace. However, although the RFC specifies that any form of whitespace (including HTAB, VT, FF, or bare CR) should be treated as the separator and ignored if preceding or trailing, the code explicitly raises errors when it encounters any whitespace other than a space (i.e. '*uri != ' '' or '*protocol != ' '). As such, while the code does attempt to parse the three distinct components (method, request-target, protocol) and enforce the expected order, it does not implement the RFC’s lenient treatment regarding multiple types of whitespace. Therefore, the function only partially matches the specification.",success,
12359,tokenize_request_line,"Although the status-line grammar rule requires that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the line terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR.",184,Partially Matches,[],"The function attempts to tokenize the request/status line by splitting it into method, URI, and protocol tokens and does include logic to detect and report abnormal whitespace conditions. For example, it explicitly skips leading whitespace (logging an error if found) and checks for extra or non‐space whitespace in between tokens, which relates to the RFC’s discussion on whitespace separation. However, the RFC allows recipients to treat any form of whitespace (SP, HTAB, VT, FF, or bare CR) as a separator and to ignore preceding or trailing whitespace. In contrast, the function enforces that the whitespace must be exactly the space character and raises errors when other whitespace characters are encountered or when extra whitespace is present. As a result, although the function contains elements addressing the spec, it does not fully implement the lenient whitespace parsing as described in the RFC, so only a partial match is achieved.",success,
12359,tokenize_request_line,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'if (strict) {\n    ll = (char*) ap_scan_http_token(method);\n} else {\n    ll = (char*) ap_scan_vchar_obstext(method);\n}\n\nif ((ll == method) || (*ll && !apr_isspace(*ll))) {\n    RRL_ERROR(e, etoken, rrl_badmethod, ll);\n    ll = strpbrk(ll, ""\\t\\n\\v\\f\\r "");\n}', 'explanation': 'This segment validates that the method token conforms to the HTTP ABNF rules by using a strict token scan (or a more permissive scan when not in strict mode) and flags an error if the token includes invalid characters or formatting. It directly addresses the requirement that protocol elements must match the defined grammar.'}}, {'A1': {'code': ""for (uri = ll; apr_isspace(*uri); ++uri)\n    if (*uri != ' ')\n        RRL_ERROR(e, etoken, rrl_badwhitespace, uri);\n*ll = '\\0';"", 'explanation': 'This code advances past whitespace while verifying that only a single space is used, marking errors for excess or non-standard whitespace. It ensures proper separation of tokens in line with the ABNF grammar.'}}]","The function tokenize_request_line visibly addresses the specification by parsing and validating each component (method, URI, protocol) of an HTTP request line to ensure they conform to the HTTP ABNF grammar. By using designated scan functions and error reporting when encountering non-conforming input, the function explicitly prevents the generation or acceptance of protocol elements that deviate from the defined grammar. This direct implementation of token validation and error handling fully meets the intent of the RFC specification as provided.",success,
12359,tokenize_request_line,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': ""if (apr_isspace(*method)) {\n    RRL_ERROR(e, etoken, rrl_badwhitespace, method);\n    for ( ; apr_isspace(*method); ++method)\n        ;\n}\n\n...\n\nfor ( ; apr_isspace(*uri); ++uri)\n    if (*uri != ' ')\n        RRL_ERROR(e, etoken, rrl_badwhitespace, uri);\n\n...\n\nif (*ll && !apr_isspace(*ll)) {\n    RRL_ERROR(e, etoken, rrl_badprotocol, ll);\n}\nelse if (strict && *ll) {\n    RRL_ERROR(e, etoken, rrl_excesswhitespace, ll);\n}\nelse {\n    for ( ; apr_isspace(*ll); ++ll)\n        if (*ll != ' ') {\n            RRL_ERROR(e, etoken, rrl_badwhitespace, ll);\n            break;\n        }\n    if (*ll)\n        RRL_ERROR(e, etoken, rrl_trailingtext, ll);\n}"", 'explanation': 'The function implements defensive parsing by checking and skipping unexpected whitespace, validating token boundaries, and marking errors when input deviates from expected simple ABNF grammar. This directly addresses the RFC requirement to parse protocol elements defensively, assuming only marginal conformance with the ABNF.'}}, {'A1': {'code': 'if ((ll == method) || (*ll && !apr_isspace(*ll))) {\n    RRL_ERROR(e, etoken, rrl_badmethod, ll);\n    ll = strpbrk(ll, ""\\t\\n\\v\\f\\r "");\n}\n\n...\n\nif (!ll) {\n    RRL_ERROR(e, etoken, rrl_missinguri, NULL);\n    protocol = uri = """";\n    goto done;\n}', 'explanation': 'The function consistently marks and reports errors using RRL_ERROR when protocol elements (method, URI, protocol) are missing or malformed. This behavior fits the action of handling input errors defensively.'}}]","The function 'tokenize_request_line' attempts to implement the RFC’s defensive parsing requirement by individually scanning the HTTP request line components – method, URI, and protocol. It uses dedicated scanning routines (ap_scan_http_token, ap_scan_vchar_obstext) and performs checks (e.g., for leading/trailing whitespace, proper token boundaries), flagging errors where deviations occur. Thus, within its own logic it addresses the conditions and actions necessary to fairly defensively parse a received protocol element as specified in the RFC.",success,
12359,tokenize_request_line,A sender SHOULD generate RWS as a single SP.,6,Fully Matches,"[{'A1': {'code': ""if (strict && ll[0] && apr_isspace(ll[1])) {\n    RRL_ERROR(e, etoken, rrl_excesswhitespace, ll);\n}\n\nfor (uri = ll; apr_isspace(*uri); ++uri)\n    if (*uri != ' ')\n        RRL_ERROR(e, etoken, rrl_badwhitespace, uri);\n\n/* Similar logic is used when parsing the protocol, ensuring that non-SP whitespace or extra whitespace is flagged. */"", 'explanation': ""The RFC requires that required whitespace (RWS) should be exactly a single SP. In strict mode, the function verifies that after tokens there is exactly one space by checking that only one whitespace character (' ') is present and flags errors if additional or non‐SP whitespace is encountered. This enforcement directly implements the spec constraint.""}}]","The function 'tokenize_request_line' includes explicit logic to enforce that separating whitespace between tokens is exactly one SP. It checks for multiple whitespace characters in strict mode and flags any occurrence of non-SP whitespace. Thus, within its isolated implementation, it fully addresses the RFC requirement that a sender should generate RWS as a single SP.",success,
12754,add_http_certs,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function 'add_http_certs' focuses on parsing the Content-Type header from an HTTP response and processing certificates. It does not include any logic that checks or enforces that the sender must not generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. There is no explicit check tied to role-based message generation or any validation of protocol grammar according to the RFC constraints. Thus, it does not visibly address the specified HTTP RFC requirement within its own logic.",success,
12754,add_http_certs,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC specification requires that a sender must not generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. The function 'add_http_certs' only retrieves and parses certain HTTP headers (like 'Content-Type') and processes certificate chains. It does not contain any logic that validates or generates protocol elements based on ABNF grammar rules. Therefore, within the scope of the function body, there is no visible attempt to implement the labeled constraint (e.g., C1, A1) related to protocol element grammar conformity.",success,
12755,on_add_cert,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, on_add_cert, does not contain any logic that checks or enforces the role-based restrictions specified in the RFC. The RFC states that a sender must not generate protocol elements that are only allowed for other roles. However, the function primarily processes HTTP responses by adding certificates and logging the results. It does not include any validation or controls related to the sender's role or the generation of protocol elements as required by the specification. Therefore, no portion of the function fully implements any labeled condition (e.g., C1) or action (e.g., A1) from the spec constraints.",success,
12759,csr_req,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'location = apr_table_get(res->headers, ""location"");\nif (!location) {\n    md_log_perror(MD_LOG_MARK, MD_LOG_ERR, APR_EINVAL, d->p, \n                  ""cert created without giving its location header"");\n    return APR_EINVAL;\n}', 'explanation': ""This segment checks for the presence of the 'location' header, fulfilling the requirement to interpret a received protocol element in line with the specification. Missing the header leads to error logging and failure, demonstrating the recipient’s obligation to verify protocol element semantics.""}}, {'A1': {'code': 'if (APR_SUCCESS == (rv = md_cert_read_http(&cert, d->p, res))) {\n    md_log_perror(MD_LOG_MARK, MD_LOG_DEBUG, rv, d->p, ""cert parsed"");\n    apr_array_clear(ad->cred->chain);\n    APR_ARRAY_PUSH(ad->cred->chain, md_cert_t*) = cert;\n    get_up_link(d, res->headers);\n}\nelse if (APR_STATUS_IS_ENOENT(rv)) {\n    rv = APR_SUCCESS;\n    if (location) {\n        md_log_perror(MD_LOG_MARK, MD_LOG_DEBUG, rv, d->p, \n                      ""cert not in response, need to poll %s"", location);\n    }\n}', 'explanation': ""This part attempts to parse and recover a certificate from the HTTP response. If parsing fails with APR_STATUS_IS_ENOENT, the function treats the case as recoverable and prepares to poll further. It displays an error recovery approach consistent with the spec's allowance for recovering a usable protocol element, though without full configuration or experiential decision-making.""}}]","The function demonstrates visible attempts to implement some of the RFC-specified requirements by verifying the presence of critical protocol elements (e.g. the 'location' header) and attempting to recover certificate data from the HTTP response. Although it does address key aspects (like error logging and recovery), it does not fully encapsulate the broader semantic interpretation and configuration-based decisions mentioned in the specification. Thus, the function only partially matches the defined constraints.",success,
12759,csr_req,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function does not contain any explicit logic to enforce or check the RFC’s constraints regarding duplicate header fields or preserving the order of header fields. The RFC specifies that a sender MUST NOT generate multiple field lines with the same name unless the field allows a comma-separated list and that proxies must not alter their order. In the code, the function merely retrieves a single ""location"" header using apr_table_get without verifying if duplicates exist or preserving the order of headers. Therefore, there is no visible implementation within this function that addresses any of the labeled conditions (C1, etc.) or actions (A1, etc.) from the spec constraints.",success,
12759,csr_req,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided code function processes an HTTP response by extracting and handling the 'location' header, logging errors, saving order details, and reading a certificate. However, it does not contain any logic that ensures protocol elements conform to or do not deviate from the ABNF grammar as required by the spec. The function does not generate any HTTP protocol elements, nor does it validate that any generated elements match the grammar. Therefore, no part of the function addresses the spec constraint ""A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.""",success,
12759,csr_req,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function checks for the presence of a 'location' header, logs errors, and processes the response by saving certificate information and parsing a certificate from the HTTP response. However, the RFC specification states that a sender MUST NOT generate protocol elements that are only allowed to be generated by other roles. There is no code here that prevents or verifies the generation of such prohibited protocol elements. In other words, the function does not address the condition of avoiding the generation of role-specific syntax elements, and thus it does not match any labeled constraints (e.g., C1, A1) related to this requirement.",success,
12760,md_acme_drive_setup_cred_chain,"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT",71,Fully Matches,"[{'A1': {'code': 'rv = md_acme_POST(ad->acme, ad->order->finalize, on_init_csr_req, NULL, csr_req, NULL, d);', 'explanation': 'This code segment submits the CSR using a POST method (via md_acme_POST), thereby aligning with the RFC requirement to use POST for state‐changing requests rather than PUT.'}}]","The function generates a certificate signing request and finalizes the order by submitting the request using a POST operation. By directly invoking md_acme_POST and ensuring that the request does not use PUT, the code visibly addresses the RFC specification requiring POST for state‐changing operations. All relevant logic within the function adheres to this constraint.",success,
12780,inspect_problem,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC spec requires that a sender must not generate protocol elements that do not conform to the ABNF-defined grammar. This code function, however, does not implement any logic to verify or enforce the conformance of generated protocol elements to the specified ABNF rules. Instead, it checks for a specific content-type in a response and processes error information accordingly. There is no mechanism within the function to validate or restrict protocol element generation against the ABNF grammar. Therefore, the function does not address the constraint outlined in the RFC.",success,
12780,inspect_problem,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'ctype = apr_table_get(req->resp_hdrs, ""content-type"");\nctype = md_util_parse_ct(res->req->pool, ctype);\nif (ctype && !strcmp(ctype, ""application/problem+json"")) {\n    /* RFC 7807 */\n    rv = md_json_read_http(&problem, req->p, res);\n    if (rv == APR_SUCCESS && problem) {\n        const char *ptype, *pdetail;\n        req->resp_json = problem;\n        ptype = md_json_gets(problem, MD_KEY_TYPE, NULL);\n        pdetail = md_json_gets(problem, MD_KEY_DETAIL, NULL);\n        req->rv = problem_status_get(ptype);\n        md_result_problem_set(req->result, req->rv, ptype, pdetail,\n                              md_json_getj(problem, MD_KEY_SUBPROBLEMS, NULL));\n\n        if (APR_STATUS_IS_EAGAIN(req->rv)) {\n            md_log_perror(MD_LOG_MARK, MD_LOG_DEBUG, req->rv, req->p,\n                          ""acme reports %s: %s"", ptype, pdetail);\n        }\n        else {\n            md_log_perror(MD_LOG_MARK, MD_LOG_WARNING, req->rv, req->p,\n                          ""acme problem %s: %s"", ptype, pdetail);\n        }\n        return req->rv;\n    }\n}', 'explanation': 'This segment checks if the received Content-Type equals ""application/problem+json"" and processes the JSON body according to RFC 7807 semantics. It attempts to interpret the received protocol element as required by the specification.'}}]","The function partially implements the RFC requirement by parsing a protocol element when its content-type is ""application/problem+json"" and extracting problem details as defined by RFC 7807. However, it does not fully address the specification's broader requirement of verifying or adapting based on potential implementation errors from the sender (for example, using experience or configuration to determine if the sender has implemented the semantics incorrectly). Thus, while it shows visible handling for one aspect of the spec, it does not comprehensively implement all semantic interpretation rules outlined in the provided RFC specification.",success,
12780,inspect_problem,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function inspect_problem focuses on parsing and processing a problem response (specifically, parsing 'application/problem+json' content and logging based on the HTTP status code). It does not implement any logic that restricts the generation of protocol elements based on sender roles, as required by the provided RFC specification (i.e. that a sender must not generate protocol elements reserved for other roles). Therefore, within its own code, it does not visibly address the labeled constraint requiring the sender to avoid generating disallowed protocol elements.",success,
12785,acmev2_GET_as_POST_init,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function does not implement any logic related to the RFC specification that states a sender must not generate protocol elements reserved for other roles. The function simply ignores the baton parameter and returns the result of a call to md_acme_req_body_init with no additional checks or logic addressing role-specific message generation or syntax validation. Therefore, no labeled conditions (e.g., C1) or actions (e.g., A1) are visibly implemented within this function.",success,
12785,acmev2_GET_as_POST_init,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function only wraps a call to md_acme_req_body_init and does not contain any logic that directly ensures or verifies that protocol elements are generated in accordance with ABNF grammar rules. There is no implementation within this function that validates or enforces the RFC requirement (i.e., that a sender must not generate protocol elements that do not match the defined grammar). As such, this function does not visibly implement any condition or action (e.g., C1 or A1) related to the specified HTTP RFC requirement.",success,
12787,md_acme_POST,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function simply creates an ACME POST request by asserting the URL, setting callback pointers, logging the action, and sending the request. It does not include any logic that verifies or enforces the requirement that a sender must not generate protocol elements or syntax alternatives that are reserved for other roles. There is no validation against the HTTP grammar or specific role-based restrictions within the function. Thus, within its own code context, it does not implement any of the labeled spec constraints.",success,
12787,md_acme_POST,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC specification requires that a sender must not generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. In the function md_acme_POST, there is no visible logic that validates or enforces the grammar of the protocol elements. The function creates a request object, sets some callbacks, and ultimately calls md_acme_req_send to send the request. There is no explicit checking or generation of protocol elements to ensure they conform to an ABNF-defined grammar. Therefore, no part of the function can be identified as directly addressing any labeled condition (e.g., C1) or action (e.g., A1) from the specification constraints.",success,
12800,md_acme_create,"A sender SHOULD NOT generate information in product-version that is not a version identifier (i.e., successive versions of the same product name ought to differ only in the product-version portion of the product identifier).",275,Partially Matches,"[{'C1': {'code': 'acme->user_agent = apr_psprintf(p, ""%s mod_md/%s"", base_product, MOD_MD_VERSION);', 'explanation': 'This line builds a User-Agent string consisting of a base product identifier and a version identifier (mod_md/MOD_MD_VERSION). It limits additional information to what is necessary for identification, in line with the RFC requirement to avoid non-version advertising in the product-version portion.'}}]","The function constructs the User-Agent header value using only a product name and a version identifier, which partially addresses the RFC specification that mandates only essential product version information be generated. However, it does not include any additional logic to validate or enforce that no extraneous (non-version) data is included, nor does it handle changes between successive versions beyond formatting a static string. Therefore, while the function does visibly attempt to implement part of the RFC constraint (labeled C1), it only partially meets the overall specification.",success,
12800,md_acme_create,A sender SHOULD limit generated product identifiers to what is necessary to identify the product; a sender MUST NOT generate advertising or other nonessential information within the product identifier.,274,Fully Matches,"[{'C1': {'code': 'acme->user_agent = apr_psprintf(p, ""%s mod_md/%s"", base_product, MOD_MD_VERSION);', 'explanation': 'This line generates the User-Agent string with only the necessary product identifier (base_product) and its version (mod_md/MOD_MD_VERSION) without any extra advertising or nonessential information, which fulfills the requirement to limit product identifiers to what is necessary.'}}, {'A1': {'code': 'acme->user_agent = apr_psprintf(p, ""%s mod_md/%s"", base_product, MOD_MD_VERSION);', 'explanation': ""By constructing the User-Agent string in this concise format, the code avoids the inclusion of any advertising or other nonessential details, adhering to the spec's mandate.""}}]","The function creates the User-Agent string using a formatted print function that concatenates only the minimal product name and version information. This directly meets the RFC requirement by limiting the generated product identifier to just what is necessary without additional promotional or extraneous text. Therefore, within the function's own logic, the RFC spec constraints are fully addressed.",success,
12800,md_acme_create,A recipient that processes such a URI reference MUST reject it as invalid.,226,Does Not Match,[],"The provided function does perform some URI validation (e.g., using md_util_abs_uri_check and apr_uri_parse), but it does not explicitly implement the RFC constraint that a recipient processing an 'https' URI with an empty host identifier MUST reject it as invalid. There is no direct check within the function to ensure that the hostname is non-empty before proceeding, which means the function does not visibly address the specific requirement of rejecting such URIs.",success,
12800,md_acme_create,A recipient that processes such a URI reference MUST reject it as invalid.,224,Does Not Match,[],"The provided function performs some URI validation by calling md_util_abs_uri_check and apr_uri_parse; however, there is no visible logic within this function that explicitly checks if the host identifier (hostname) is empty. According to the RFC specification, a URI with an empty host identifier MUST be rejected as invalid. This function does not contain any explicit condition (e.g., checking if uri_parsed.hostname is NULL or an empty string) to enforce this requirement. As a result, the function does not visibly address the RFC’s constraint regarding empty host identifiers solely within its own logic.",success,
12801,update_directory,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (res->status == 503) {\n    md_result_printf(result, APR_EAGAIN,\n        ""The ACME server at <%s> reports that Service is Unavailable (503). This ""\n        ""may happen during maintenance for short periods of time."", acme->url); \n    md_result_log(result, MD_LOG_INFO);\n    rv = result->status;\n    goto leave;\n}\nelse if (res->status < 200 || res->status >= 300) {\n    md_result_printf(result, APR_EAGAIN,\n        ""The ACME server at <%s> responded with HTTP status %d. This ""\n        ""is unusual. Please verify that the URL is correct and that you can indeed ""\n        ""make request from the server to it by other means, e.g. invoking curl/wget."", \n        acme->url, res->status);\n    rv = result->status;\n    goto leave;\n}', 'explanation': 'The function checks the HTTP response status and handles error conditions, which is part of interpreting the protocol elements as mandated by the RFC.'}}, {'A1': {'code': 'rv = md_json_read_http(&json, req->pool, res);\nif (APR_SUCCESS != rv) {\n    md_log_perror(MD_LOG_MARK, MD_LOG_ERR, rv, req->pool, ""reading JSON body"");\n    goto leave;\n}\n\n/* Further interpretation of the JSON body follows with extraction of keys such as\n   ""newAccount"", ""newOrder"", ""newNonce"", etc. */', 'explanation': 'The function attempts to interpret the JSON response body by parsing it and extracting specific keys. This aligns with the RFC requirement for a recipient to interpret the protocol element as defined (including certain extensions), although it does not cover all extension possibilities.'}}]","The provided function inspects the HTTP response by checking status codes and then reading and processing a JSON body. In doing so, it implements portions of the RFC requirement that the recipient must interpret protocol elements by applying defined semantics. However, while it handles some expected fields and error conditions, it does not fully cover every possible extension or alternative handling mechanism described in the specification context. Therefore, the function partially matches the intended RFC implementation within its own logic.",success,
12895,header_cb,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Partially Matches,"[{'C1': {'code': ""++i;\\nwhile (i < len && b[i] == ' ') {\\n    ++i;\\n}"", 'explanation': 'This code snippet skips over a whitespace character (BWS) after the colon, which aligns with the RFC requirement to remove optional (bad) whitespace before interpreting the header value.'}}, {'A1': {'code': ""len = (clen && b[clen-1] == '\\n')? clen-1 : clen;\\nlen = (len && b[len-1] == '\\r')? len-1 : len;"", 'explanation': 'This segment removes trailing newline and carriage return characters, effectively cleaning up header line end markers, which can be seen as part of trimming extraneous whitespace (BWS).'}}]","The function processes incoming header data by first trimming trailing CR/LF characters and then scanning for the colon that separates the header name from its value. After finding the colon, it increments the pointer and explicitly skips over a single space character. These actions demonstrate that the function partially implements the RFC requirement to remove optional whitespace (BWS) before further processing. However, it only handles BWS in very specific scenarios (trailing characters and a single leading space) and does not fully encompass all possible cases of BWS removal as defined by the specification. Thus, while the function visibly addresses certain aspects of the BWS removal rule, it does so only partially.",success,
12895,header_cb,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,"[{'C1': {'code': ""len = (clen && b[clen-1] == '\\n')? clen-1 : clen;\nlen = (len && b[len-1] == '\\r')? len-1 : len;\n...\nwhile (i < len && b[i] == ' ') {\n    ++i;\n}"", 'explanation': ""The function removes trailing newline (\\n) and carriage return (\\r) characters and skips over spaces immediately following the colon. This shows an attempt to trim out what could be termed 'bad whitespace' in the header line. However, it does not comprehensively handle all instances or varieties of extra or misplaced whitespace as per the RFC requirement.""}}]","The code function demonstrates some logic aligned with the RFC specification by trimming trailing CR/LF and skipping spaces after the colon, thereby partially implementing the requirement that a recipient must remove bad whitespace before interpreting header elements. Nonetheless, it only addresses a subset of possible whitespace issues (specifically trailing and post-colon spaces), and does not fully cover all scenarios described in the specification, leading to a 'Partially Matches' judgment.",success,
12895,header_cb,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Partially Matches,[],"The RFC requires that any extraneous whitespace be excluded from the field value before evaluation—this means removing both leading and trailing whitespace. In the function, the code strips off the trailing newline and carriage return characters (via the lines that adjust 'len') and skips over leading spaces following the colon delimiter (in the while loop). However, it does not remove any other trailing whitespace that might appear before the CRLF. Thus, while the function does attempt part of the whitespace exclusion (removing newlines and leading spaces), it does not fully trim all surrounding whitespace as required by the RFC. This partial implementation means the function only partially meets the relevant spec constraints.",success,
12895,header_cb,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Partially Matches,"[{'C1': {'code': ""len = (clen && b[clen-1] == '\\n')? clen-1 : clen;\nlen = (len && b[len-1] == '\\r')? len-1 : len;"", 'explanation': ""This code snippet checks if the end of the header line has a newline ('\\n') and, if so, removes it; it then checks if the resulting last character is a carriage return ('\\r') and removes that as well. This implements the RFC provision that a header field terminated by CRLF can also be recognized as a line terminated with a single LF (ignoring any preceding CR).""}}]","The function partially implements the HTTP RFC section regarding the recognition of line terminators. By stripping a trailing '\n' and a preceding '\r', it addresses the condition where a single LF is used as a terminator and any accompanying CR is ignored, as described. However, the function does not handle other aspects of the spec such as validating encoding or detecting and replacing bare CR characters within the header content, hence its overall implementation of the RFC constraints is only partial.",success,
12896,curlify_headers,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': ""if (strchr(key, '\\r') || strchr(key, '\\n')\n    || strchr(value, '\\r') || strchr(value, '\\n')) {\n    ctx->rv = APR_EINVAL;\n    return 0;\n}"", 'explanation': 'This code snippet defensively checks for carriage return and newline characters in the header key and value. By rejecting inputs containing these CRLF characters, it helps prevent header injection and malformed header elements, which is in line with the RFC requirement for defensive parsing. However, it does not address other aspects such as buffer size limitations.'}}]","The function implements one defensive measure by verifying that neither the key nor the value contains CR or LF characters, thus partially addressing the RFC's recommendation to parse protocol elements defensively. While this check is in line with the guidance, the function does not perform additional validations such as checking if the element fits within a reasonable buffer size, hence it only partially matches the overall specification.",success,
12896,curlify_headers,"Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message.",3,Partially Matches,"[{'C1': {'code': ""if (strchr(key, '\\r') || strchr(key, '\\n') || strchr(value, '\\r') || strchr(value, '\\n')) {\n    ctx->rv = APR_EINVAL;\n    return 0;\n}"", 'explanation': 'This segment checks for CR and LF in both the header key and value and rejects the header if found, which partially implements the spec requirement to reject dangerous characters.'}}]","The spec requires that field values containing CR, LF, or NUL characters must be rejected (or have those characters replaced) before further processing. The code function checks for CR and LF characters in the header key and value and rejects the header when they are found. However, it does not check for NUL characters, thus only partially matching the complete requirement stated by the RFC. As only the logic within this function qualifies, the handling of NUL is missing, leading to a 'Partially Matches' outcome.",success,
12896,curlify_headers,A recipient of such a bare CR MUST consider that element to be invalid or replace each bare CR with SP before processing the element or forwarding the message.,173,Fully Matches,"[{'C1': {'code': ""if (strchr(key, '\\r') || strchr(key, '\\n') || strchr(value, '\\r') || strchr(value, '\\n')) {\n    ctx->rv = APR_EINVAL;\n    return 0;\n}"", 'explanation': 'This code checks for the presence of CR (and LF) in both the header key and value. According to the RFC, a bare CR must be considered invalid (or replaced with SP). By detecting these characters and invalidating the element, the function directly satisfies the specification requirement.'}}]","The function addresses the HTTP RFC requirement by verifying if any header key or value contains a carriage return. In doing so, it invalidates the header element by returning an error. Although the RFC allows either replacing bare CR with SP or considering the element invalid, this implementation uses invalidation, which complies with the specification. Therefore, the function fully implements the relevant condition (labeled C1) within its own code.",success,
12896,curlify_headers,"A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the ""message/http"" media type.",301,Partially Matches,"[{'C1': {'code': ""if (strchr(key, '\\r') || strchr(key, '\\n') || strchr(value, '\\r') || strchr(value, '\\n')) {\n    ctx->rv = APR_EINVAL;\n    return 0;\n}"", 'explanation': 'This code snippet checks for carriage return and newline characters in both the header key and value which effectively prevents any line folding. It addresses the requirement to not include folded lines by rejecting headers containing these characters.'}}]","The function enforces that header keys and values do not include CR or LF characters, thus avoiding any potential for obs-fold (line folding) and satisfying the sender's obligation not to generate messages with line folding. However, the RFC provides an exception for the ""message/http"" media type which is not handled in this function. Since there is no logic to allow line folding for message packaging within ""message/http"", the implementation is only a partial match of the full specification.",success,
12896,curlify_headers,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Fully Matches,"[{'C1': {'code': ""if (strchr(key, '\\r') || strchr(key, '\\n')\n        || strchr(value, '\\r') || strchr(value, '\\n')) {\n        ctx->rv = APR_EINVAL;\n        return 0;\n    }"", 'explanation': ""This code checks the header key and value for any CR ('\\r') or LF ('\\n') characters. By rejecting any header containing these characters, it ensures that no bare CR is generated in the protocol elements, directly addressing the RFC requirement.""}}]",The function 'curlify_headers' inspects the header key and value for any carriage return or line feed characters and returns an error if found. This directly implements the specification that a sender must not generate any bare CR outside of the content. The logic in the function satisfies the RFC constraint (labeled C1) as it prevents generation of malformed protocol elements.,success,
12900,internals_setup,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,61,Fully Matches,"[{'A1': {'code': 'else if (!apr_strnatcasecmp(""HEAD"", req->method)) {\n        curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);\n    }', 'explanation': 'This code branch for the HEAD method sets the CURLOPT_NOBODY option, ensuring that no response body is transferred. This directly implements the RFC requirement that the server must not send content in the response to a HEAD request.'}}]","The function inspects the request method and, when it identifies a HEAD request, it configures the curl handle with the CURLOPT_NOBODY option. This ensures that no response body is processed, which directly fulfills the spec constraint that although HEAD is similar to GET, it must not return any content. Hence, the implementation within this function fully addresses the critical part of the RFC specification for HEAD requests.",success,
12917,md_timeperiod_print,"When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.",245,Does Not Match,[],"The RFC specification requires that timestamps be generated using the IMF-fixdate format. However, the function uses apr_rfc822_date to format the dates, which produces dates in the RFC822 format rather than the IMF-fixdate format. Since there is no logic within this function to convert or generate dates in the IMF-fixdate format, the function does not visibly implement the required behavior as specified.",success,
12999,md_http_challenge_pr,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Does Not Match,[],"The RFC specification states that a sender must not include a Content-Length header if the message contains a Transfer-Encoding header. In the provided function, when a valid challenge is found, the code unconditionally sets the Content-Length header without checking if a Transfer-Encoding header is present. There is no logic within the function that verifies or prevents the presence of a Transfer-Encoding header before setting Content-Length. Therefore, the function does not address any conditions or actions from the spec constraints regarding this behavior.",success,
12999,md_http_challenge_pr,A server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6).,46,Does Not Match,[],"The RFC requirement prohibits sending a Content-Length header in any 2xx response to a CONNECT request. In the provided function, the logic is dedicated solely to handling ACME challenge resources and explicitly processes only GET requests. The function sets a Content-Length header in a 2xx response (HTTP_OK) without checking if the request is a CONNECT request. There is no conditional logic in the function to exclude CONNECT requests from sending a Content-Length header. Therefore, the function does not attempt to address the RFC constraint regarding CONNECT requests.",success,
12999,md_http_challenge_pr,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'A1': {'code': 'r->status = HTTP_OK;\napr_table_setn(r->headers_out, ""Content-Length"", apr_ltoa(r->pool, (long)len));', 'explanation': 'When a GET request for a challenge resource is detected, the function explicitly sets the HTTP status to 200 (OK) and writes a Content-Length header with the exact length of the response data. This reflects the RFC requirement to send a Content-Length header when the content size is known and Transfer-Encoding is not present.'}}]","The function demonstrates an attempt to implement part of the RFC by sending a Content-Length header when the content size is known, as shown in the explicit setting of the header. However, the RFC also requires that this behavior occur only in the absence of Transfer-Encoding and excludes responses with status codes like 1xx or 204, as well as handling CONNECT request responses. Since the function does not check for the presence of a Transfer-Encoding header nor excludes the excluded status cases (beyond setting status to HTTP_OK in this valid context), it only partially matches the complete constraints outlined by the spec.",success,
12999,md_http_challenge_pr,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The provided function is focused on handling ACME HTTP challenge requests and sending back a response with a computed Content-Length header based on the challenge data. However, the RFC specification requires that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect. This means the implementation should include logic to verify the correctness of the Content-Length header before forwarding the message. The function does not implement any such validation or error checking logic for the Content-Length header; it simply calculates the length of the challenge data and sets the header accordingly. Therefore, within the code of this function, none of the labeled conditions (e.g., C1) or actions (e.g., A1) that pertain to ensuring the correctness of the Content-Length header are met.",success,
12999,md_http_challenge_pr,An origin server that receives a request method that is unrecognized or not implemented SHOULD respond with the 501 (Not Implemented) status code.,59,Fully Matches,"[{'A1': {'code': 'if (r->method_number != M_GET) {\n    return HTTP_NOT_IMPLEMENTED;\n}', 'explanation': 'This segment directly checks whether the HTTP method is different from GET and, if so, returns HTTP_NOT_IMPLEMENTED (501). This behavior aligns with the RFC requirement that an origin server responding to an unrecognized or not implemented method SHOULD respond with a 501 status code.'}}]","Within the function, when the request is handled for the challenge resource, it specifically checks the request method. If the method is not GET, it immediately returns a 501 status code, thus visibly addressing the RFC specification that any unrecognized or unimplemented method should trigger a 501 response. This confirms that the function, by itself, implements the required behavior as defined in the spec.",success,
12999,md_http_challenge_pr,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Does Not Match,[],"The RFC requirement states that a server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content). In the provided function, the Content-Length header is set only when a successful challenge response is generated (HTTP_OK), and there is no logic present to check or avoid the header in cases where the status code might be 1xx or 204. Thus, the function does not visibly address this specified RFC constraint within its own code.",success,
13000,md_require_https_maybe,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,160,Fully Matches,"[{'C1': {'code': 'if (!ap_ssl_conn_is_ssl(r->connection)) {\n    if (md->require_https > MD_REQUIRE_OFF) {\n        ...\n    }\n}', 'explanation': 'The code checks whether the connection is not HTTPS and whether HTTPS is required (md->require_https > MD_REQUIRE_OFF), which is the precondition for generating a redirect.'}}, {'A1': {'code': 'if (APR_SUCCESS == apr_uri_parse(r->pool, s, &uri)) {\n    uri.scheme = (char*)""https"";\n    uri.port = 443;\n    uri.port_str = (char*)""443"";\n    uri.query = r->parsed_uri.query;\n    uri.fragment = r->parsed_uri.fragment;\n    s = apr_uri_unparse(r->pool, &uri, APR_URI_UNP_OMITUSERINFO);\n    if (s && *s) {\n        apr_table_setn(r->headers_out, ""Location"", s);\n        return status;\n    }\n}', 'explanation': ""When a redirect is required and the URL is successfully parsed, the function constructs a new HTTPS URL and sets the 'Location' header with that URL, which fulfills the RFC requirement.""}}]","The function inspects whether the current request is over HTTPS. If the connection is not secure and HTTPS is required (C1), it constructs a new URL with the 'https' scheme and sets the 'Location' header (A1) accordingly. This directly implements the RFC specification that the server SHOULD generate a Location header field containing a permanent URI reference for redirection.",success,
13000,md_require_https_maybe,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 's = apr_uri_unparse(r->pool, &uri, APR_URI_UNP_OMITUSERINFO);\nif (s && *s) {\n    apr_table_setn(r->headers_out, ""Location"", s);\n    return status;\n}', 'explanation': 'This code segment constructs a new URI with the ""https"" scheme and then explicitly sets the Location header in the response, which is the expected behavior as per the RFC specification.'}}]","The function checks if a request is not using HTTPS and if the domain requires HTTPS via the configuration. In that case, it constructs the redirect URL with the https scheme, properly sets the port, and then sets the Location header using apr_table_setn. This directly implements the RFC action of generating a Location header field containing a URI reference for the different (https) URI, thereby fully matching the specified constraint.",success,
13000,md_require_https_maybe,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'A1': {'code': 's = apr_uri_unparse(r->pool, &uri, APR_URI_UNP_OMITUSERINFO);\nif (s && *s) {\n    apr_table_setn(r->headers_out, ""Location"", s);\n    return status;\n}', 'explanation': 'This segment constructs the redirect URI by switching the scheme to HTTPS and then sets the Location header field in the response. This directly implements the RFC requirement to include a Location header with a URI reference for the different URI.'}}]","The function checks whether the current connection is not HTTPS and HTTPS is required (via the md->require_https flag). In that case, it constructs a new URI with the https scheme and port 443, then uses apr_table_setn to set the Location header field. This behavior fully addresses the RFC specification that the server SHOULD generate a Location header field in the response, thus meeting the spec constraint.",success,
13000,md_require_https_maybe,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,155,Fully Matches,"[{'A1': {'code': 's = ap_construct_url(r->pool, r->uri, r);\nif (APR_SUCCESS == apr_uri_parse(r->pool, s, &uri)) {\n    uri.scheme = (char*)""https"";\n    uri.port = 443;\n    uri.port_str = (char*)""443"";\n    uri.query = r->parsed_uri.query;\n    uri.fragment = r->parsed_uri.fragment;\n    s = apr_uri_unparse(r->pool, &uri, APR_URI_UNP_OMITUSERINFO);\n    if (s && *s) {\n        apr_table_setn(r->headers_out, ""Location"", s);\n        return status;\n    }\n}', 'explanation': ""This code segment constructs the new URL using the 'https' scheme along with the appropriate port and query/fragment parts, then sets the 'Location' header field in the response. This directly implements the RFC requirement to include a preferred URI in the Location header for permanent redirection.""}}]","The function inspects the request to determine if HTTPS is required, and if so, it constructs a new URL with the HTTPS scheme and sets the 'Location' header field to that URL. This behavior visibly implements the HTTP RFC specification that mandates a Location header with a preferred URI reference, fully matching the stated action constraint.",success,
13910,md_pkey_read_http,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (data_len > 1024*1024) { /* certs usually are <2k each */\n    rv = APR_EINVAL;\n    goto leave;\n}', 'explanation': 'The function checks that the HTTP response body length does not exceed a set limit (1MB), which is a defensive measure to ensure the element fits within a reasonable buffer size.'}}, {'A1': {'code': 'ERR_clear_error();\npkey->pkey = PEM_read_bio_PrivateKey(bf, NULL, NULL, &ctx);\nif (pkey->pkey == NULL) {\n    unsigned long err = ERR_get_error();\n    rv = APR_EINVAL;\n    md_log_perror(MD_LOG_MARK, MD_LOG_WARNING, rv, pool,\n                  ""error loading pkey from http response: %s"",\n                  ERR_error_string(err, NULL));\n    goto leave;\n}', 'explanation': 'The function uses defensive error handling when parsing the protocol element. It clears previous errors, attempts the PEM parsing, and logs a warning when parsing fails, thereby addressing the need for defensive action when the element does not conform as expected.'}}]","The RFC specifies that a recipient should parse a received protocol element defensively, not assuming strict conformance to its ABNF grammar and expecting only a reasonable buffer size. The function implements a defensive approach by first checking the body length against a set limit (1MB) and then using established parsing functions with rigorous error checking and logging. However, it only partially fulfills the broader intent of the RFC because while it does guard against excessively large input and handles parse errors, it does not cover all potential aspects (such as more nuanced handling of slightly nonconforming ABNF structures) within its own logic. Thus, the code only partially matches the defensive parsing requirements outlined in the specification.",success,
13947,md_cert_read_http,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided code function implements certificate parsing by verifying the HTTP response’s Content-Type and body content before attempting to decode a certificate. However, the RFC specification states: 'A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.' This requirement relates to the generation of protocol elements by a sender. The target function is concerned only with reading and parsing a certificate from a response and does not generate any protocol elements. As such, none of the internal logic in function_body directly implements the RFC’s sender behavior. Therefore, the function does not visibly address any labeled condition or action pertaining to the requirement.",success,
13947,md_cert_read_http,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'ct = apr_table_get(res->headers, ""Content-Type"");\nct = md_util_parse_ct(res->req->pool, ct);\nif (!res->body || !ct || strcmp(""application/pkix-cert"", ct)) {\n    rv = APR_ENOENT;\n    goto out;\n}', 'explanation': 'This segment verifies that the HTTP response contains a body and that the Content-Type header exactly matches ""application/pkix-cert"". In doing so, it partially implements the requirement to interpret the protocol element according to the defined semantics, ensuring that only certificate responses are processed.'}}, {'A1': {'code': 'if (APR_SUCCESS == (rv = apr_brigade_length(res->body, 1, &data_len))) {\n    if (data_len > 1024*1024) {\n        return APR_EINVAL;\n    }\n    if (APR_SUCCESS == (rv = apr_brigade_pflatten(res->body, &der, &der_len, res->req->pool))) {\n        const unsigned char *bf = (const unsigned char*)der;\n        X509 *x509;\n        if (NULL == (x509 = d2i_X509(NULL, &bf, (long)der_len))) {\n            rv = APR_EINVAL;\n            goto out;\n        } else {\n            cert = md_cert_make(p, x509);\n            rv = APR_SUCCESS;\n        }\n    }\n}', 'explanation': 'This block processes the response body by ensuring the data length is within acceptable limits, flattens the body to binary DER data, and then attempts to decode and create an X509 certificate. It implements the act of interpreting the certificate content as defined by its semantics, although without accommodating error recovery mechanisms suggested by the spec.'}}]","The function inspects and processes an HTTP certificate response by checking critical elements such as Content-Type and body length, then decodes the body if it is in DER format. These steps indicate that the function is addressing specific parts of the RFC requirement (C1 and A1) to interpret the protocol element correctly. However, it does not incorporate error recovery or extension handling in cases where the sender might be mis-implementing the semantics—behavior that is implied in the complete specification context. Thus, the function partially matches the RFC constraints as it handles the basic interpretation but not the full spectrum of recovery or extended semantic analysis.",success,
13947,md_cert_read_http,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (!res->body || !ct || strcmp(""application/pkix-cert"", ct)) {\n    rv = APR_ENOENT;\n    goto out;\n}', 'explanation': 'This code snippet defensively checks for the presence of a body and validates the Content-Type header, ensuring it meets a specific expected value. This is in the spirit of defensive parsing as required by the spec.'}}, {'A1': {'code': 'if (APR_SUCCESS == (rv = apr_brigade_length(res->body, 1, &data_len))) {\n    if (data_len > 1024*1024) { /* certs usually are <2k each */\n        return APR_EINVAL;\n    }\n    ...\n}', 'explanation': ""This snippet ensures that the received data does not exceed a set maximum size (1MB), providing a safeguard against overly large protocol elements. While the limit is arbitrarily set, it represents an effort to enforce a 'reasonable buffer size' as mentioned in the spec.""}}]","The function demonstrates defensive parsing by validating the existence of the HTTP body and ensuring that the Content-Type header matches the expected 'application/pkix-cert'. Additionally, it checks that the body size does not exceed a predefined maximum. However, the function only partially addresses the full spirit of the RFC specification since it handles only a subset of potential protocol malformations and fixes the buffer size to a hard-coded maximum rather than adapting to variable 'reasonable' sizes. As such, while some conditions (C1 and A1) are met, the implementation does not comprehensively cover all aspects of the spec, leading to a 'Partially Matches' outcome.",success,
13947,md_cert_read_http,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function md_cert_read_http processes an HTTP response by validating that the response body exists and that the Content-Type header is exactly 'application/pkix-cert', then extracts and parses a certificate from the body. However, the RFC specification requires that a sender must NOT generate protocol elements or syntax alternatives that are only allowed for other roles. This function does not contain any logic that attempts to generate protocol elements or enforce that requirement—it only reads and validates existing protocol data. As such, within its code, there is no implementation addressing the spec's constraints regarding generation of protocol elements, and therefore it does not visibly implement the specified HTTP RFC requirement.",success,
13948,md_cert_chain_read_http,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided RFC specification requires that a sender must not generate protocol elements that deviate from the grammar defined by the ABNF rules. This code function, however, is responsible for reading and parsing certificate chains from an HTTP response, not generating protocol elements. There is no logic in this function that verifies or enforces conformance to any ABNF grammar in the process of generating protocol elements. The function handles different content types and logs errors if the response content is unexpected, but it does not deal with the generation of HTTP elements as described in the RFC. Thus, no labeled spec constraints (C1, A1, etc.) are addressed within this function.",success,
13948,md_cert_chain_read_http,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function md_cert_chain_read_http is focused on reading and parsing certificate chains from an HTTP response based on its content-type. It does not generate any protocol elements, nor does it implement any logic to ensure that no forbidden protocol elements (i.e., those meant for other roles) are generated by the sender. Since the RFC specification requires that a sender must not generate protocol elements that are only allowed to be generated by other roles, and this function does not address or implement any controls related to that requirement (it solely processes received data), no labeled condition (e.g., C1) or action (e.g., A1) from the spec constraints is visibly implemented within this function.",success,
13985,on_order_upd,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function does not include any logic that ensures a sender avoids generating protocol elements or syntax alternatives restricted to other roles as required by the spec. It simply processes an order update by checking for a location header and updating the order from JSON. There is no role-based validation or protocol element generation control evident in the code; therefore, it does not address any of the labeled constraints (e.g., C1, A1) outlined in the specification.",success,
13985,on_order_upd,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC specification requires that a sender must not generate protocol elements that do not match the defined grammar (i.e., the ABNF rules). In the provided function_body, there is no logic that validates, rejects, or otherwise ensures that any generated protocol element (such as the 'location' header copied into the order URL) conforms to the ABNF grammar. The function simply extracts the value and assigns it without any validation or constraint enforcement. Therefore, none of the spec conditions (e.g., C1 corresponding to ensuring ABNF compliance) or actions (e.g., A1 related to not generating non-conforming protocol elements) are implemented within this function.",success,
13985,on_order_upd,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'const char *location = apr_table_get(hdrs, ""location"");\nif (!ctx->order) {\n    if (location) {\n        ctx->order = md_acme_order_create(ctx->p);\n        ctx->order->url = apr_pstrdup(ctx->p, location);\n        md_log_perror(MD_LOG_MARK, MD_LOG_TRACE1, rv, ctx->p, ""new order at %s"", location);\n    } else {\n        rv = APR_EINVAL;\n        md_log_perror(MD_LOG_MARK, MD_LOG_WARNING, rv, ctx->p, ""new order, no location header"");\n        goto out;\n    }\n}', 'explanation': ""This code extracts the 'location' header (a protocol element) and uses it to create or update an order. It effectively interprets a received header according to its semantics as required by the specification. However, while it handles the presence or absence of the header, it does not cover any further semantic extensions or error recovery mechanisms indicated by the spec.""}}, {'A1': {'code': 'if (!location) {\n    rv = APR_EINVAL;\n    md_log_perror(MD_LOG_MARK, MD_LOG_WARNING, rv, ctx->p, ""new order, no location header"");\n    goto out;\n}', 'explanation': 'When the required protocol element (location header) is missing, the function rejects the order update by setting an error value, which is an action in line with handling invalid constructs as per the specification.'}}]","The function partially implements the specification by checking and interpreting the 'location' header to create or update an order, in line with the requirement that a recipient interpret a received protocol element according to its semantics. However, it does not fully address all aspects of the RFC such as processing any extensions or advanced error recovery strategies. Since only a subset of the requirements is handled within this function, we conclude that it only partially matches the spec constraints.",success,
13986,md_acme_order_register,"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT",71,Fully Matches,"[{'A1': {'code': 'rv = md_acme_POST(acme, acme->api.v2.new_order, on_init_order_register, on_order_upd, NULL, NULL, &ctx);', 'explanation': 'This line explicitly calls the POST method implementation (md_acme_POST) for a new order, directly aligning with the spec’s requirement to use POST for a state-changing request that selects a proper URI on behalf of the client.'}}]","The function 'md_acme_order_register' directly invokes md_acme_POST to issue a POST request to register a new order associated with a chosen URI. This conforms to the RFC specification that recommends using POST rather than PUT for handling state-changing requests, where the intended URI is selected by the service. The implementation within this function meets the corresponding constraint by explicitly using the POST method.",success,
14026,md_http_cert_status,An origin server that receives a request method that is unrecognized or not implemented SHOULD respond with the 501 (Not Implemented) status code.,59,Fully Matches,"[{'C1': {'code': 'if (r->method_number != M_GET) {\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                  ""md(%s): status supports only GET"", md->name);\n    return HTTP_NOT_IMPLEMENTED;\n}', 'explanation': 'This code segment checks if the incoming request method is not GET, and if so, logs a message and returns HTTP_NOT_IMPLEMENTED (501). This behavior directly meets the RFC requirement that states an origin server should respond with a 501 status code when an unrecognized or unimplemented method is received.'}}]","The function explicitly implements the RFC requirement by verifying the request method; if the method is not GET (which is the only one it supports), it returns a 501 response code. This addresses the specified constraint within the function itself, fulfilling the RFC specification.",success,
14026,md_http_cert_status,"If the purpose of such a resource is to perform an unsafe action, then the resource owner MUST disable or disallow that action when it is accessed using a safe request method.",267,Partially Matches,"[{'A1': {'code': 'if (r->method_number != M_GET) {\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                  ""md(%s): status supports only GET"", md->name);\n    return HTTP_NOT_IMPLEMENTED;\n}', 'explanation': 'This segment ensures that only the safe GET method is allowed. By explicitly rejecting non-GET methods, it prevents the execution of potential unsafe actions, which aligns with the RFC requirement for disabling unsafe actions when a safe method (like GET) is used.'}}]","The RFC specification requires that if a resource performs an unsafe action, then that action must be disabled when accessed via a safe request method. In this code function, the only visible measure addressing this is the check that limits the resource to GET requests only, thereby disallowing potentially unsafe methods. However, the full spirit of the RFC—especially handling actions selected via query parameters (if they imply unsafe operations)—is not explicitly managed in this function. As a result, the function only partially meets the constraints outlined in the specification.",success,
14026,md_http_cert_status,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'apr_table_set(r->headers_out, ""Content-Type"", ""application/json"");', 'explanation': ""The function sets the 'Content-Type' header in the response right after generating content. This directly implements the RFC requirement that a sender generating a message with content SHOULD include a Content-Type header, assuming the representation is known.""}}]","The function clearly includes a line that sets the 'Content-Type' header to 'application/json' before sending the response data. This demonstrates that the function itself, without relying on external dependencies, implements the RFC specification's action to generate a Content-Type header when content is present.",success,
14052,md_ocsp_status_hook,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function md_ocsp_status_hook exclusively handles the reporting of OCSP stapling status and does not interact with any request context or modify request semantics. The RFC specification requires that any Content-Location context received in a request must not be used to alter the semantics of the request. There is no code in this function that examines or processes Content-Location or any similar context, and hence no logic relevant to conditions such as C1 (pertaining to not altering request semantics based on context information) or corresponding actions. Therefore, the function does not visibly address the specified constraint within its own implementation.",success,
14053,md_status_handler,An origin server that receives a request method that is unrecognized or not implemented SHOULD respond with the 501 (Not Implemented) status code.,59,Fully Matches,"[{'A1': {'code': 'if (r->method_number != M_GET) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, ""md-status supports only GET"");\n        return HTTP_NOT_IMPLEMENTED;\n    }', 'explanation': 'This code checks whether the incoming request method is GET. If not, it logs the fact and returns HTTP_NOT_IMPLEMENTED (501), thereby directly implementing the RFC requirement that unrecognized or unimplemented methods should result in a 501 status code.'}}]","The function 'md_status_handler' first verifies that it is responsible for handling the request. It then explicitly checks if the request method is GET and, if not, responds with HTTP_NOT_IMPLEMENTED. This behavior is in line with the RFC specification that mandates responding with a 501 status code when the method is unrecognized or not implemented. All logic addressing this constraint is contained within the function body, hence it fully matches the spec constraint.",success,
14053,md_status_handler,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function does not implement any logic that verifies or enforces that the generated protocol elements (in this case, the JSON output and HTTP headers) strictly adhere to the grammatical rules defined by the ABNF. The specification requires the sender to ensure generated protocol elements conform to these rules, yet this function merely delegates JSON output creation (using md_json_writeb) without any evidence of ABNF conformance checking. There is no direct implementation of any constraint labeled (e.g., C1, A1) within this function's code.",success,
14053,md_status_handler,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC requires that the sender must not generate protocol elements or syntax alternatives reserved for other roles. In the provided function, there is no logic that checks or enforces role-specific constraints or that prevents generating protocol elements reserved for other participants. The function primarily handles GET requests for the md-status handler and produces JSON output without verifying role-specific generation rules. Therefore, none of the spec constraints (e.g., C1, A1) are visibly implemented in this function.",success,
14053,md_status_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'if (jstatus) {\n    apr_table_set(r->headers_out, ""Content-Type"", ""application/json"");\n    bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    md_json_writeb(jstatus, MD_JSON_FMT_INDENT, bb);\n    ap_pass_brigade(r->output_filters, bb);\n    apr_brigade_cleanup(bb);\n\n    return DONE;\n}', 'explanation': 'This block clearly sets a Content-Type header on the outgoing message when content (the JSON representation) is generated. According to the HTTP RFC, a sender that generates a message containing content SHOULD generate a Content-Type header unless the media type is unknown. Here, since the media type of the representation is known (application/json), the function complies with the specification.'}}]","The function 'md_status_handler' generates and sends JSON content as a response and explicitly sets the 'Content-Type' header to 'application/json'. This directly satisfies the spec constraint that a sender should include a Content-Type header in messages with content, provided the intended media type is known. The implementation within this function makes a clear and direct attempt to fulfill this RFC guideline independently of caller or dependency logic.",success,
14074,on_init_acct_new,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function assembles a JSON payload for an ACME account creation request but does not include any explicit logic to validate or enforce that the protocol elements match the ABNF grammar as required by the specification. It relies on helper functions (such as md_json_create, md_json_setsa, etc.) for JSON construction, but there is no visible code within this function that checks or guarantees conformance to the grammar defined by the ABNF rules. As such, the function does not directly implement the constraint that a sender must not generate invalid protocol elements.",success,
14074,on_init_acct_new,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function builds a JSON payload for an account creation request by populating fields such as contacts, termsOfServiceAgreed, and externalAccountBinding, but it does not include any checks or logic to ensure that protocol elements are only generated by participants in the appropriate role. In other words, there is no visible logic within the function that verifies the sender's role against the allowed protocol elements as required by the RFC specification. Therefore, the function does not appear to address the RFC constraint regarding preventing generation of protocol elements reserved for other roles.",success,
14075,md_acme_acct_register,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Does Not Match,[],"The specified RFC requires that a sender MUST NOT generate an 'http' URI with an empty host identifier. In the provided function, although there are calls to md_util_abs_uri_check for validating both the agreement and contact URIs, the actual logic for checking the empty host identifier is not implemented directly within this function. It relies on an external function (md_util_abs_uri_check) to perform the check. According to the instructions, only the logic directly in the function body counts, so there is no visible implementation here that fully meets the requirement.",success,
14075,md_acme_acct_register,A recipient that processes such a URI reference MUST reject it as invalid.,226,Does Not Match,[],"The RFC spec requires that a recipient processing an ""https"" URI with an empty host identifier MUST reject it as invalid. In the provided function_body, the only evidence of URI validity checks is through calls to md_util_abs_uri_check() for both the agreement URI and contact URIs. However, these checks are delegated to an external function (a dependency), and the target function itself does not contain any in‐line logic to verify the host component of the URI. According to the requirements, only logic within the target function qualifies as implementing the spec constraint. As a result, the function does not fully implement the condition that a URI with an empty host should be rejected, and hence it does not match the specified constraint.",success,
14075,md_acme_acct_register,"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT",71,Fully Matches,"[{'C1': {'code': 'rv = acct_make(&acme->acct,  p, acme->url, md->contacts);', 'explanation': 'This call creates the account object (and thereby determines its URI) based on the provided input, addressing the selection of a proper URI on behalf of the client.'}}, {'A1': {'code': 'rv = md_acme_POST_new_account(acme,  on_init_acct_new, acct_upd, NULL, NULL, &ctx);', 'explanation': 'The function registers a new account by explicitly invoking a POST request (via md_acme_POST_new_account), which complies with the RFC’s recommendation to use POST rather than PUT for state-changing requests.'}}]","The function clearly implements the HTTP RFC requirement by ensuring that a state-changing request (i.e., account registration) is handled via a POST method. It constructs the new account URI using acct_make (thereby selecting a proper URI for the resource) and then carries out the registration with a POST call, fulfilling both the condition (selecting the proper URI) and the action (using POST method rather than PUT) as specified.",success,
14075,md_acme_acct_register,A recipient that processes such a URI reference MUST reject it as invalid.,224,Partially Matches,"[{'C1': {'code': 'if (APR_SUCCESS != (rv = md_util_abs_uri_check(acme->p, ctx.agreement, &err))) {\n    md_log_perror(MD_LOG_MARK, MD_LOG_ERR, 0, p, ""invalid agreement uri (%s): %s"", err, ctx.agreement);\n    goto out;\n}\n\nfor (i = 0; i < md->contacts->nelts; ++i) {\n    uri = APR_ARRAY_IDX(md->contacts, i, const char *);\n    if (APR_SUCCESS != (rv = md_util_abs_uri_check(acme->p, uri, &err))) {\n        md_log_perror(MD_LOG_MARK, MD_LOG_ERR, 0, p, ""invalid contact uri (%s): %s"", err, uri);\n        goto out;\n    }\n}', 'explanation': 'The function validates the agreement and contact URIs by invoking md_util_abs_uri_check, which is expected to enforce the requirement that a URI with an empty host (among other invalid forms) be rejected per the RFC. While the specific check against an empty host component is delegated to md_util_abs_uri_check rather than being directly implemented in this function, the function still visibly attempts to enforce the necessary URI validation rule.'}}]","The provided function processes URIs for agreement and contacts by passing them to an external validation function. This external function is presumed to implement the RFC mandate to reject URI references with an empty host identifier. However, because the check is not explicitly implemented within the function_body and is instead delegated, the function only partially meets the requirement as visible in its own logic.",success,
14079,md_acme_agree,"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT",71,Fully Matches,"[{'A1': {'code': 'return md_acme_POST(acme, acme->acct->url, on_init_agree_tos, acct_upd, NULL, NULL, &ctx);', 'explanation': 'The function makes a clear choice to use a POST method through the call to md_acme_POST when handling a state-changing request, which aligns with the RFC requirement to implement such actions using POST rather than PUT.'}}]","The provided function adheres to the RFC specification by ensuring that a state-changing request (in this case, an agreement update) is executed via a POST request. The core logic to perform the POST is visible in the function through the call to md_acme_POST, which therefore fully meets the relevant spec constraint.",success,
14085,md_acme_authz_update,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function (md_acme_authz_update) focuses on parsing a JSON response from an ACME server and updating internal state accordingly. It does not include any logic that enforces or checks that a sender does not generate protocol elements or syntax alternatives reserved for other roles, as required by the RFC. There is no code validating sender role or restricting protocol element generation based on role, so the function does not visibly address the labeled condition or action from the RFC specification.",success,
14085,md_acme_authz_update,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (APR_SUCCESS == (rv = md_acme_get_json(&json, acme, authz->url, p))\n    && (s = md_json_gets(json, MD_KEY_STATUS, NULL))) {\n    \n    authz->domain = md_json_gets(json, MD_KEY_IDENTIFIER, MD_KEY_VALUE, NULL); \n    authz->resource = json;\n    if (!strcmp(s, ""pending"")) {\n        authz->state = MD_ACME_AUTHZ_S_PENDING;\n        err = ""challenge \'pending\'"";\n        log_level = MD_LOG_DEBUG;\n    }\n    else if (!strcmp(s, ""valid"")) {\n        authz->state = MD_ACME_AUTHZ_S_VALID;\n        err = ""challenge \'valid\'"";\n        log_level = MD_LOG_DEBUG;\n    }\n    else if (!strcmp(s, ""invalid"")) {\n        ctx.p = p;\n        ctx.authz = authz;\n        authz->state = MD_ACME_AUTHZ_S_INVALID;\n        md_json_itera(copy_challenge_error, &ctx, json, MD_KEY_CHALLENGES, NULL);\n        err = ""challenge \'invalid\'"";\n    }\n}', 'explanation': ""This segment interprets the received JSON protocol element by extracting the 'status' field and mapping recognized values ('pending', 'valid', 'invalid') to specific internal states. This mirrors the RFC requirement for a recipient to interpret the protocol element according to its defined semantics.""}}, {'A1': {'code': 'if (json && authz->state == MD_ACME_AUTHZ_S_UNKNOWN) {\n    err = ""unable to understand response"";\n    rv = APR_EINVAL;\n}', 'explanation': 'This block acts as a fallback error handler by detecting when the protocol element does not match expected semantics. It attempts to recover or, failing that, signals an error, which aligns with the RFC stipulation to attempt recovery from an invalid construct.'}}]","The function implements some aspects of the RFC by explicitly parsing the received JSON to extract the 'status' field and mapping recognized values to internal states, thereby interpreting the protocol element as required. It also contains fallback logic to handle unexpected or unrecognized input. However, it does not address all possible extensions or more comprehensive error recovery strategies as the RFC might imply. As a result, while some key aspects are implemented in this function, it only partially satisfies the full intent of the specification.",success,
14085,md_acme_authz_update,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC requires that a sender must not generate protocol elements that do not conform to the ABNF grammar. In the function_body provided, there is no code segment that constructs (or checks) any outgoing protocol elements, nor is there any evidence of generating structured HTTP elements in accordance with an ABNF grammar. The function merely parses a JSON response and updates state accordingly, without directly addressing the protocol element generation stipulated by the RFC. Therefore, this function does not visibly implement the specified RFC constraint.",success,
14090,cha_http_01_setup,"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT",71,Partially Matches,"[{'A1': {'code': 'rv = md_acme_POST(acme, cha->uri, on_init_authz_resp, authz_http_set, NULL, NULL, &ctx);', 'explanation': 'This code segment makes an HTTP POST request (through md_acme_POST) to notify the ACME server of the challenge update. It demonstrates the intent to use POST for a state‐changing operation as specified by the RFC, rather than using PUT. However, the function does not contain any explicit logic for selecting a proper URI if a redirection is needed, so only part of the RFC’s requirement is directly implemented here.'}}]","The provided function contains logic that, upon detecting a change or a new challenge in its key authorization setup, notifies the ACME server using an HTTP POST request via md_acme_POST. This aligns with the RFC requirement that state-changing requests use POST instead of PUT. Nonetheless, the function does not implement any additional logic for dynamically selecting a proper URI or handling redirection (such as issuing a 3xx response), meaning that while it visibly addresses the use of POST for the state-changing request, it does not fully implement all aspects of the RFC specification. Therefore, the match is considered partial.",success,
14092,cha_tls_alpn_01_setup,"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT",71,Fully Matches,"[{'A1': {'code': 'rv = md_acme_POST(acme, cha->uri, on_init_authz_resp, authz_http_set, NULL, NULL, &ctx);', 'explanation': 'The RFC specifies that after receiving a state-changing request a service that selects a proper URI should use POST rather than PUT. This function directly implements that behavior by invoking md_acme_POST to notify the ACME server, ensuring that the state change occurs via a POST request.'}}]","The function, when setting up the TLS-ALPN challenge, performs a POST operation (via md_acme_POST) to notify the ACME server about the challenge set-up. This directly satisfies the RFC requirement that the service handling a state-changing request use the POST method rather than PUT. No part of the function attempts to use the PUT method, and the logic using POST is clearly visible within the function body.",success,
14093,cha_dns_01_setup,"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT",71,Fully Matches,"[{'A1': {'code': 'rv = md_acme_POST(acme, cha->uri, on_init_authz_resp, authz_http_set, NULL, NULL, &ctx);', 'explanation': 'This code explicitly uses the HTTP POST method (via md_acme_POST) to notify the ACME server after setting up the state-changing DNS-01 challenge, which matches the RFC specification that such operations should be implemented using POST rather than PUT.'}}]","The function calls md_acme_POST to inform the ACME server after the challenge setup, directly addressing the requirement that a state-changing request selecting a proper URI be implemented using the POST method. This implementation in the function_body fully addresses the specified RFC requirement.",success,
14394,next_todo,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function does not include any logic to ensure that protocol elements or syntax alternatives are generated only by the correct role. It focuses on scheduling and executing an OCSP request—such as creating jobs, building and sending HTTP POST requests, and assigning callbacks—but it does not evaluate or constrain the sender's role as required by the spec. Specifically, there is no check or enforcement of the rule that a sender MUST NOT generate protocol elements reserved for other roles (the primary condition in the RFC specification). Consequently, none of the labeled conditions (e.g., C1) or actions (e.g., A1) in the spec constraints are addressed directly within this function.",success,
14394,next_todo,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The spec requirement states that the sender must not generate protocol elements that violate the grammar defined by the ABNF rules. In the function_body provided, while it creates an HTTP POST request and sets headers (such as 'Expect'), it does not implement any logic that verifies or enforces that the generated protocol elements conform to an ABNF grammar. There is no direct validation or filtering of the generated elements against the ABNF rules within this function. Consequently, the function does not visibly address the spec constraints (e.g., ensuring grammar compliance), and thus, it does not meet the requirement specified.",success,
14394,next_todo,"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT",71,Fully Matches,"[{'A1': {'code': 'rv = md_http_POSTd_create(&req, http, ostat->responder_url, headers, ""application/ocsp-request"", &ostat->req_der);', 'explanation': 'This code segment explicitly creates an HTTP request using the POST method, which aligns with the RFC stipulation that a state‐changing request for selecting a URI on behalf of the client SHOULD be implemented using POST rather than PUT.'}}]","The function_body directly addresses the critical requirement of the spec by constructing an HTTP POST request to the server (using md_http_POSTd_create) with the appropriate headers and content type. This clearly demonstrates that the function attempts to implement the RFC’s guideline, fulfilling the constraint in question within the body of the function.",success,
14460,uri_check,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Fully Matches,"[{'C1': {'code': 'else if (!strncmp(""http"", uri_parsed->scheme, 4)) {\n            if (!uri_parsed->hostname) {\n                err = ""missing hostname"";\n            }', 'explanation': 'This segment checks that when the scheme is http, a hostname is provided. If not, it sets an error, thereby enforcing the RFC requirement that an http URI must not have an empty host identifier.'}}]","The function 'uri_check' parses the URI and, in the case of an 'http' scheme, explicitly checks for a missing hostname. By setting 'err' to 'missing hostname' if the hostname is absent, the function visibly enforces the specification that a sender must not generate an 'http' URI with an empty host identifier. This demonstrates that the function fully implements the necessary condition as required by the RFC.",success,
14460,uri_check,A recipient that processes such a URI reference MUST reject it as invalid.,224,Fully Matches,"[{'C1': {'code': 'else if (!uri_parsed->hostname) {\n                err = ""missing hostname"";\n            }', 'explanation': ""This code segment checks if the HTTP URI has an empty hostname. According to the spec, a recipient must reject any URI reference with an empty host identifier. Setting 'err' when 'uri_parsed->hostname' is NULL implements this requirement.""}}]","The function explicitly verifies that for an ""http"" scheme URI, the hostname must exist. By checking 'if (!uri_parsed->hostname)' and then setting an error, the function meets the RFC condition that a recipient must reject a URI with an empty host identifier. Therefore, the function fully addresses the specified constraint.",success,
14469,skip_ws,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': ""while (ctx->i < ctx->slen \n       && (((c = ctx->s[ctx->i]) == ' ') || (c == '\\t'))) {\n    ++ctx->i;\n}"", 'explanation': 'The loop explicitly checks for space and horizontal tab characters and skips them by incrementing the index in the context structure. This directly implements the RFC requirement to exclude leading whitespace from field values.'}}]","The function skip_ws entirely focuses on ignoring whitespace by advancing the internal pointer past any spaces or tabs encountered. Since the RFC requires that implementations remove such whitespace before field evaluation, and the code implements this by looping through and skipping the relevant characters, the function fully matches the constraint identified (C1). No additional logic is required within this function to meet the specification.",success,
14469,skip_ws,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': ""while (ctx->i < ctx->slen && (((c = ctx->s[ctx->i]) == ' ') || (c == '\\t')))"", 'explanation': ""This loop explicitly checks for spaces (' ') and horizontal tabs ('\\t') and advances the pointer over them. In doing so, it parses for and effectively removes the bad whitespace before further processing, which meets the RFC requirement.""}}]","The function skip_ws scans through the input string, advancing over characters that are either a space or a horizontal tab. Since the HTTP RFC specifies that a recipient must parse for such bad whitespace and remove it before interpreting the protocol element, the logic shown in the while loop directly embodies this requirement. All of the logic required to address the spec constraint is contained within this function, and no additional elements outside of it are needed to satisfy the requirement.",success,
14469,skip_ws,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': ""while (ctx->i < ctx->slen && (((c = ctx->s[ctx->i]) == ' ') || (c == '\\t'))){\n        ++ctx->i;\n    }"", 'explanation': ""The RFC requires that any bad whitespace (BWS) be removed before interpretation. This condition (C1) is handled by the loop that iterates over the data, skipping over both space (' ') and tab ('\\t') characters, thereby effectively removing the BWS.""}}]","The function 'skip_ws' iterates through the input, advancing the index for every whitespace character it finds (spaces or tabs). This directly aligns with the RFC specification that permits removal of BWS prior to message processing. All logic required to remove BWS is self-contained within this function, fulfilling the condition as specified.",success,
14480,find_url,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC requirement states that a sender must not generate protocol elements that do not match the grammar defined by the ABNF rules. In this function, the code only parses the 'link' header by calling external routines (read_link and skip_param) to extract a URL based on certain criteria. The function does not itself generate any protocol elements, nor does it perform explicit validation against an ABNF grammar. Since any grammar enforcement appears to be delegated to external functions (and thus is not part of the logic within 'find_url'), this function does not visibly address the specified requirement on its own.",success,
14480,find_url,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function, find_url, is designed to extract a URL from a 'link' header by parsing and matching a relation. It does not contain any logic that enforces restrictions on generating protocol elements or syntax alternatives based on sender roles, as described in the spec. The code focuses only on extracting data (i.e., checking if the 'link' header contains a particular 'rel' parameter) and does not address constraints such as ensuring the sender does not generate protocol elements reserved for other roles. Therefore, it does not implement any of the labeled conditions or actions associated with the spec.",success,
14482,md_util_parse_ct,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'md_util_parse_ct' only extracts the media type from a given content-type header (by scanning until a space or semicolon is encountered) and allocates a corresponding buffer for it. It does not include any logic to verify or enforce that a sender does not generate protocol elements or syntax alternatives reserved for a different role, as specified by the RFC constraint. No part of the code addresses the condition or action related to ensuring role-specific protocol element generation. Thus, within the function itself, none of the spec constraints (e.g., C1, A1) are implemented.",success,
14482,md_util_parse_ct,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function only extracts a substring from a content-type header and does not perform any form of validation or enforcement of grammar rules as defined by the ABNF. It does not check whether the output conforms to the required grammar, and it does not perform any logical steps to ensure that protocol elements being generated match the specification. Therefore, it does not visibly address the specified RFC condition.",success,
14547,ts_renew,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function is concerned primarily with certificate renewal operations and communicating with a local tailscale service via HTTP GET requests. It creates HTTP contexts, constructs URLs, and handles responses, but there is no visible logic in the function that enforces or validates that the protocol elements being generated conform to any ABNF-defined grammar. Thus, it does not appear to address the specified RFC requirement that a sender MUST NOT generate protocol elements that do not match the corresponding ABNF rules.",success,
14547,ts_renew,A sender SHOULD limit generated product identifiers to what is necessary to identify the product; a sender MUST NOT generate advertising or other nonessential information within the product identifier.,274,Partially Matches,"[{'C1': {'code': 'md_http_create(&http, d->p, apr_psprintf(d->p, ""Apache mod_md/%s"", MOD_MD_VERSION), NULL);', 'explanation': ""The code creates an HTTP context using a User-Agent string that consists solely of 'Apache mod_md/<version>', which is minimal and does not include any nonessential or advertising details. This addresses the RFC requirement to limit generated product identifiers to only necessary information.""}}]","The RFC specifies that a sender should limit product identifiers to what is necessary to identify the product and must not include advertising or nonessential information. In the function, the only related implementation is the instantiation of an HTTP context with a minimal User-Agent string ('Apache mod_md/<version>'). This shows that the function is attempting to conform to the RFC by generating a minimal identifier. However, aside from this, the function largely deals with certificate renewal and does not address any other aspects of the RFC specification related to user agent product identifiers (e.g., handling multiple product identifiers or comments). Thus, while one key aspect (the minimal product identifier) is implemented, the function does not cover the entirety of the RFC constraints.",success,
14547,ts_renew,"A sender SHOULD NOT generate information in product-version that is not a version identifier (i.e., successive versions of the same product name ought to differ only in the product-version portion of the product identifier).",275,Fully Matches,"[{'C1': {'code': 'rv = md_http_create(&http, d->p,\n                        apr_psprintf(d->p, ""Apache mod_md/%s"", MOD_MD_VERSION),\n                        NULL);', 'explanation': ""This line sets the User-Agent string to 'Apache mod_md/<version>' where only the version is variable. It does not include any extraneous advertising or non-version information, thereby complying with the RFC requirement that product-version contain only a version identifier.""}}]","The function creates an HTTP context using a User-Agent string formatted as 'Apache mod_md/<version>', fulfilling the RFC specification that a sender SHOULD NOT generate extraneous information in the product-version. The code directly adheres to the constraint by using only a product name with its version identifier, and no additional nonessential information is appended.",success,
14639,md_config_post_config,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, md_config_post_config, deals only with configuring certain server options (such as the HSTS header and base directory) and does not include any logic related to generating or restricting protocol elements based on sender roles as required by the specification. No part of the code attempts to validate that protocol elements are generated solely by the appropriate role, nor does it enforce any role-based constraints, thus it does not address the spec requirement.",success,
14639,md_config_post_config,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC specification requires that a sender must not generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. This function only formats a header using a fixed string pattern without any validation against ABNF grammar rules. There is no logic in the function that verifies or enforces that the produced header string adheres strictly to the HTTP grammar. Therefore, the code function does not visibly address any labeled conditions (such as C1) or actions (such as A1) related to conforming to the RFC specification.",success,
14663,req_set_body,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'C1': {'code': 'if (content_type) {\n    apr_table_set(req->headers, ""Content-Type"", content_type); \n}\nelse {\n    apr_table_unset(req->headers, ""Content-Type""); \n}', 'explanation': ""This segment sets the 'Content-Type' header using apr_table_set, which replaces any existing value. By doing so, it prevents the generation of multiple header lines for Content-Type, thereby partially conforming to the spec requirement that a sender MUST NOT generate duplicate header fields unless allowed.""}}]","The function addresses one aspect of the RFC by ensuring that the 'Content-Type' field is set in a way that disallows duplicate entries, effectively meeting the constraint for that header. However, it does not address other aspects of the RFC such as the significance of header field ordering or handling multiple field values that might be combined into comma-separated lists. Thus, while it partially matches the spec, it does not fully implement all conditions and actions specified.",success,
14663,req_set_body,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'if (content_type) {\n    apr_table_set(req->headers, ""Content-Type"", content_type);\n} else {\n    apr_table_unset(req->headers, ""Content-Type"");\n}', 'explanation': ""The function checks if a non-null content_type is provided and then sets the 'Content-Type' header accordingly. If content_type is NULL (i.e. the media type is unknown), it unsets the 'Content-Type' header. This logic directly implements the RFC requirement that a message containing content SHOULD generate a Content-Type header unless the media type is unknown.""}}]","By directly inspecting the content_type parameter and conditionally setting or unsetting the 'Content-Type' header, the function addresses the RFC's specification. The implementation satisfies the condition that a Content-Type header should be generated when the representation's media type is known, thereby fully matching the provided constraint.",success,
14674,md_http_POST_create,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function only creates a POST request and sets its body without any validation or conditional logic to ensure that the generated protocol elements strictly adhere to the sender’s allowed role. There is no code in the function that checks or restricts protocol elements based on roles, as required by the RFC specification.",success,
14674,md_http_POST_create,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function does not feature any logic that verifies whether generated protocol elements match the ABNF grammar or prevents the generation of protocol elements that do not meet this rule. It simply delegates request creation and body setup to helper functions (req_create and req_set_body) without performing any checks or validations regarding the RFC specifications. Since only the code within md_http_POST_create is considered (and not its dependencies), no condition (e.g., C1) or action (e.g., A1) is visibly addressed by the function.",success,
14675,md_http_POSTd_create,"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT",71,Fully Matches,"[{'A1': {'code': 'rv = req_create(&req, http, ""POST"", url, headers);', 'explanation': 'This code directly sets the HTTP method to ""POST"" when creating the request, which fulfills the RFC requirement to use POST instead of PUT for a service selecting a proper URI in response to a state-changing request.'}}]","The function md_http_POSTd_create is solely responsible for creating an HTTP request with the POST method. The key line 'rv = req_create(&req, http, ""POST"", url, headers);' demonstrates that it adheres to the specification requiring the use of POST rather than PUT when handling state-changing requests. No other logic or condition handling is necessary within this function to meet the stated RFC requirement, so the implementation is considered a full match.",success,
14677,md_http_HEAD_perform,"Except when responding to a HEAD request, the server SHOULD send a representation containing an explanation of the error situation, and whether it is a temporary or permanent condition.",161,Does Not Match,[],"The provided function, md_http_HEAD_perform, is specific to performing HEAD requests. The RFC requirement states that except when responding to a HEAD request, the server should send a representation with an explanation of the error. Since this function handles HEAD requests, it is not responsible for producing a representation. Furthermore, there is no visible logic within this function that generates or manages error representations for non-HEAD requests. All error handling or explanation generation is absent from the function's implementation, meaning that the HTTP RFC constraint (specifically addressing non-HEAD responses) is not addressed by this function alone.",success,
14678,md_http_POST_perform,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function md_http_POST_perform simply wraps calls to md_http_POST_create and md_http_perform, and conditionally sets a response callback via md_http_set_on_response_cb. It does not implement any logic to verify or enforce that the sender does not generate protocol elements or syntax alternatives that are restricted to other roles, as required by the RFC specification. All role or grammar constraints are deferred to other components or dependencies, and no direct handling is visible within this function.",success,
14766,md_json_set_time,"When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.",245,Fully Matches,"[{'C1': {'code': 'apr_rfc822_date(ts, value);', 'explanation': 'This call converts the time value to a date string in a format that conforms to the IMF‑fixdate requirement (i.e. a fixed HTTP-date format) as required by the RFC.'}}]","The function md_json_set_time generates a timestamp string by calling apr_rfc822_date, which is intended to produce an HTTP-date in the IMF‑fixdate format. This directly addresses the requirement that timestamps be generated in that specific format, and thus the function visibly implements the RFC constraint by itself.",success,
14804,md_json_read_http,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function md_json_read_http is focused on reading a JSON object from an HTTP response by checking the Content-Type header, and then processing the response body if it indicates JSON data. It does not contain any logic that addresses the RFC requirement stating that a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed from other roles. The code exclusively reads and parses incoming data rather than generating protocol elements based on its role. As such, there is no visible implementation of any condition (e.g., C1) or action (e.g., A1) associated with that spec constraint within the function_body itself.",success,
14804,md_json_read_http,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC requirement states that a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. This function, however, only deals with reading an HTTP response body as JSON if the content-type header ends with '/json' or '+json'. It does not generate any protocol elements nor does it perform any validation against an ABNF grammar for outgoing messages. Therefore, no part of the function directly attempts to implement the specified RFC constraint.",success,
14809,md_json_set_timeperiod,"When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.",245,Does Not Match,[],"The RFC specification mandates that the sender must generate timestamps in the IMF-fixdate format. However, the function uses apr_rfc822_date to produce timestamp strings. This function appears to generate dates in the RFC822 format, not the IMF-fixdate format required by the RFC. There is no logic within this function that ensures the timestamps comply with the IMF-fixdate format. Hence, the function does not visibly implement the specified constraint.",success,
14835,util_ldap_handler,A server MAY send a Content-Length header field in a response to a HEAD request (Section 9.3.2); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a response if the same request had used the GET method.,43,Does Not Match,[],"The provided function does not contain any logic that manipulates or checks the Content-Length header field in accordance with the RFC requirements. Although it checks for header-only responses (a characteristic of HEAD requests), it does not enforce or compute a Content-Length value to ensure it equals the octet count that would be sent in a GET response. Therefore, no labeled conditions or actions from the spec constraints (regarding Content-Length handling) are implemented directly in this function.",success,
14835,util_ldap_handler,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,44,Does Not Match,[],"This function does not address any of the specified RFC constraints regarding the handling of the Content-Length header. The RFC requires specific behavior for when and how to include Content-Length in responses (e.g., for 304 Not Modified or HEAD responses). The function solely processes GET requests for an 'ldap-status' handler, sets the Content-Type header, and writes HTML output without any logic for sending or validating a Content-Length header. Therefore, none of the labeled conditions (such as C1) or actions (such as A1) from the RFC specification are implemented within this function.",success,
14835,util_ldap_handler,The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request method had been GET,62,Fully Matches,"[{'C1': {'code': 'ap_set_content_type_ex(r, ""text/html; charset=ISO-8859-1"", 1);\n\nif (r->header_only)\n    return OK;', 'explanation': 'The function sets header fields (e.g., Content-Type) before checking if the request is only for headers (r->header_only). In Apache HTTP implementation, HEAD requests are handled via setting this flag while the method remains as GET. Thus, when r->header_only is true (i.e., a HEAD request), the function returns OK immediately after sending the headers and does not send the body, satisfying the RFC requirement.'}}]","The provided function first ensures that GET requests (and by extension, HEAD requests which are handled as GET with a header_only flag) receive the same headers by calling ap_set_content_type_ex. It then checks if the request is header-only and exits before sending any body content. This logic visibly implements the HTTP RFC requirement that a HEAD request should return the same header fields as a GET request while omitting the content, all within the function_body without relying on external dependencies.",success,
14835,util_ldap_handler,"If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type.",35,Does Not Match,[],"The RFC specifies that if a Content-Type header is not present, the recipient may assume 'application/octet-stream' or inspect the data. In contrast, this function unconditionally calls ap_set_content_type_ex() to set the Content-Type header to 'text/html; charset=ISO-8859-1'. There is no logic to check whether a Content-Type header is missing and no alternative behavior if it is; moreover, the charset does not match the RFC context (ISO-8859-4). Thus, the function does not visibly implement the conditions or actions required by the RFC.",success,
14835,util_ldap_handler,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided util_ldap_handler function does not implement any logic related to processing or ignoring the request's Content-Location header, nor does it show any mechanism to ensure that the origin server does not use transitory request context to alter request semantics as required by the RFC. The function simply handles GET requests for an LDAP status page, sets the content type, and outputs HTML data, with no conditions or actions addressing the specified context handling. Therefore, there is no visible implementation of the spec constraint.",success,
14835,util_ldap_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'ap_set_content_type_ex(r, ""text/html; charset=ISO-8859-1"", 1);', 'explanation': 'This invocation sets the Content-Type header field for the HTTP response, which is the action required by the RFC spec when sending a message that contains content. The code ensures that when content is present (i.e., not a header-only request), the Content-Type header is provided.'}}]","The function explicitly sets the Content-Type header using the ap_set_content_type_ex call, thereby addressing the RFC requirement that a message with content should include a Content-Type header field. Although the charset used (ISO-8859-1) differs from the spec context example (ISO-8859-4), the mechanism employed correctly implements the intended behavior defined in the specification. No additional dependency logic is involved; the function itself fully meets the constraint regarding the generation of the Content-Type header.",success,
14835,util_ldap_handler,"However, a server MAY omit header fields for which a value is determined only while generating the content.",269,Fully Matches,"[{'A1': {'code': 'if (r->header_only)\n    return OK;', 'explanation': ""This segment ensures that if the request is a HEAD request (indicated by the header_only flag), no body content is sent, which complies with the spec's requirement that a HEAD response MUST NOT include content.""}}]","The function explicitly checks for the header_only flag and returns before sending any body content, satisfying the key requirement from the RFC specification that a HEAD request should not produce a message body. Additionally, the function sets up the response header (Content-Type), which aligns with the guideline that the same headers may be sent for HEAD as for GET. All the necessary behavior is implemented directly within the function without relying on external dependencies.",success,
14845,uldap_cache_compare,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'ldap_cache_lock(st, r);\n…\n curl = util_ald_cache_fetch(st->util_ldap_cache, &curnode);\n…\n util_ald_cache_insert(curl->compare_cache, &the_compare_node);', 'explanation': 'The function implements a caching mechanism by fetching, updating, and inserting cache entries for LDAP comparison results. This reflects the specification’s part that allows a client or server to employ a cache.'}}]","The function makes visible use of a caching mechanism (as seen from the calls to ldap_cache_lock, util_ald_cache_fetch, and util_ald_cache_insert), which addresses the aspect of the spec that permits the employment of a cache. However, the RFC specification also requires that a cache not be used when acting as a tunnel. There is no logic in the function to verify if the client or server is acting as a tunnel or to disable cache usage in that scenario. Consequently, while caching is implemented, not all requirements (specifically the tunnel check) are met, so the overall outcome is 'Partially Matches'.",success,
14847,uldap_cache_check_subgroups,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The RFC specification allows clients or servers to employ a cache only when not acting as a tunnel. Although the code function makes extensive use of a caching mechanism (e.g., through ldap_cache_lock, ldap_cache_unlock, and fetching/inserting cache entries), there is no explicit logic to detect or prevent cache usage when operating as a tunnel. Therefore, the function does not implement the part of the RFC that prohibits using a cache while acting as a tunnel, and as such, it does not visibly address the complete spec constraints.",success,
14848,uldap_cache_checkuserid,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'ldap_cache_lock(st, r);\n...\ncurnode.url = url;\ncurl = (util_url_node_t *)util_ald_cache_fetch(st->util_ldap_cache, &curnode);\nif (curl == NULL) {\n    curl = util_ald_create_caches(st, url);\n}\nldap_cache_unlock(st, r);\n\n... (later, similar cache read and write operations with util_ald_cache_fetch, util_ald_cache_remove, and util_ald_cache_insert)', 'explanation': 'The function implements cache usage by fetching a cache node for the URL, checking for cached search results, and updating or removing cache entries. This logic addresses the RFC part that permits a client or server to employ a cache.'}}]","The RFC specifies that any client or server MAY employ a cache, while also noting that a cache cannot be used when acting as a tunnel. The function explicitly implements caching logic for LDAP user searches (e.g., fetching, validating, and updating cache entries), thus meeting the part of the spec that allows the use of a cache. However, the function does not contain any logic that checks whether it is acting as a tunnel and thereby prevents cache usage in that scenario. Therefore, only part of the specification is addressed by this function.",success,
14849,uldap_cache_getuserdn,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'ldap_cache_lock(st, r);\n...\ncurl = (util_url_node_t *)util_ald_cache_fetch(st->util_ldap_cache, &curnode);\nif (curl == NULL) {\n    curl = util_ald_create_caches(st, url);\n}\nldap_cache_unlock(st, r);', 'explanation': 'This segment shows the function retrieving and/or creating a cache entry for a given URL. This is an implementation of the spec part that states any client or server MAY employ a cache.'}}]","The function implements a caching mechanism by checking for, retrieving, or creating cached LDAP search results, which addresses the part of the RFC spec that indicates a client or server may employ a cache (C1). However, it does not include any logic to detect or disable caching when the process is acting as a tunnel, as required by the spec statement that a cache cannot be used while acting as a tunnel. Thus, only a portion of the spec is implemented, resulting in a 'Partially Matches' judgment.",success,
14998,log_request_query,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function, log_request_query, simply checks if query arguments exist and returns a concatenated string with an escaped query component using ap_escape_logitem. There is no logic present that validates or enforces that the generated protocol elements conform to the ABNF grammar as required by the spec. No part of the function addresses the condition that a sender must not generate protocol elements that do not match the defined grammar.",success,
14998,log_request_query,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function only formats a query string for logging by checking if r->args exists and concatenating an escaped version with a question mark. It does not include any logic that checks or enforces the RFC requirement that a sender must not generate protocol elements or syntax alternatives from roles they do not have. Thus, the function does not address any of the spec constraints (e.g., C1, A1) related to generating protocol elements according to HTTP role rules.",success,
15004,log_trailer_in,A recipient MUST NOT merge a received trailer field into the header section unless its corresponding header field definition explicitly permits and instructs how the trailer field value can be safely merged.,207,Does Not Match,[],"The function log_trailer_in only retrieves a value from the trailers table and escapes it for logging purposes. It does not implement any logic to decide whether a trailer field should be merged into the header section as per the RFC specification (i.e., no checks or operations ensure that merging is only performed if the header field explicitly permits it). Therefore, none of the conditions or actions (e.g., C1, A1) in the spec constraints are addressed in this function's code.",success,
15004,log_trailer_in,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The function 'log_trailer_in' simply retrieves a value from the 'trailers_in' table and logs it using 'ap_escape_logitem'. There is no logic within this function that verifies whether merging trailer fields into header sections is allowed or safe as per the RFC specification. Specifically, it does not address the requirement to only merge trailer fields if their definitions explicitly permit merging, nor does it perform any checks for understanding the header field definitions. Thus, none of the spec constraints (e.g., C1 or A1) are implemented in this function.",success,
15005,find_multiple_headers,"A recipient MAY combine multiple field lines within a field section that have the same field name into one field line, without changing the semantics of the message, by appending each subsequent field line value to the initial field line value in order, separated by a comma ("","") and optional whitespace (OWS, defined in Section 5.6.3).",231,Fully Matches,"[{'C1': {'code': 'do {\n    if (!ap_cstr_casecmp(t_elt->key, key)) {\n        if (!result_list) {\n            result_list = rp = apr_palloc(pool, sizeof(*rp));\n        }\n        else {\n            rp = rp->next = apr_palloc(pool, sizeof(*rp));\n            len += 2; /* "", "" */\n        }\n\n        rp->next = NULL;\n        rp->value = t_elt->val;\n        rp->len = strlen(rp->value);\n\n        len += rp->len;\n    }\n    ++t_elt;\n} while (t_elt < t_end);', 'explanation': 'The function iterates through all header entries in the table and, when a header matches the provided key (using a case-insensitive comparison), it appends each matching header value into a linked list, preserving the order in which they appear. This implements combining multiple field lines with the same field name.'}}, {'A1': {'code': ""if (rp != result_list) {\n    *cp++ = ',';\n    *cp++ = ' ';\n}\nmemcpy(cp, rp->value, rp->len);"", 'explanation': 'When concatenating multiple header values, the function explicitly inserts a comma followed by a single space ("", "") between values, which aligns with the RFC requirement to separate combined field line values with a comma SP.'}}]","The 'find_multiple_headers' function addresses the RFC specification by combining multiple header lines that match a given key. It preserves the order (as required) and concatenates the header values using the precise separator of "", "" as mandated. Thus, the function fully implements the relevant RFC constraints within its own logic.",success,
15007,log_trailer_out,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The function 'log_trailer_out' simply retrieves a value from the trailers_out table and escapes it for logging. There is no logic within the function that checks whether the recipient understands the header field definition or whether the trailer field value can be safely merged, as required by the spec. In other words, it does not implement any condition such as verifying if merging trailers is permitted (C1) or performing any action related to safe merging (A1). Dependencies aside, the function does not address any of the specified RFC constraints.",success,
15009,log_env_var,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function, log_env_var, simply retrieves and escapes an environment variable from the subprocess environment of the request record. There is no logic in this function that addresses the HTTP RFC specification or its constraints regarding the use of context information (such as Content-Location) to alter request semantics. Therefore, it does not implement any of the specified constraints (e.g., C1, A1) from the RFC.",success,
15010,log_cookie,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Partially Matches,"[{'C1': {'code': 'name += strspn(name, "" \\t"");\nwhile (last >= name && apr_isspace(*last)) {\n    *last = \'\\0\';\n    --last;\n}', 'explanation': 'This code segment trims leading and trailing whitespace from the cookie name, which addresses part of the BWS removal as required by the spec.'}}, {'A1': {'code': 'value += strspn(value, "" \\t"");\nwhile (last >= value && apr_isspace(*last)) {\n   *last = \'\\0\';\n   --last;\n}', 'explanation': 'This code segment removes leading and trailing white space from the cookie value, handling one aspect of the RFC requirement to remove bad whitespace.'}}]","The RFC specification states that any content defined as BWS (bad whitespace) may be removed before further processing. The function log_cookie implements logic to trim whitespace around cookie names and values using leading-space skipping (strspn) and a while loop to remove trailing whitespace. This directly addresses the BWS removal requirement found in the spec context. However, the function only partially implements the full set of provisions in the RFC—for instance, it does not support quoted strings or handle commas as separators—which leads to a 'Partially Matches' judgment for the code function when evaluated solely on its internal logic.",success,
15010,log_cookie,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': 'name += strspn(name, "" \\t"");\nwhile (last >= name && apr_isspace(*last)) {\n    *last = \'\\0\';\n    --last;\n}\n...\nvalue += strspn(value, "" \\t"");\nwhile (last >= value && apr_isspace(*last)) {\n    *last = \'\\0\';\n    --last;\n}', 'explanation': 'The function explicitly removes bad whitespace from both the cookie name and value. It advances the pointer past leading spaces using strspn and then iteratively trims trailing whitespace using a while loop, thereby complying with the RFC requirement to parse and remove such whitespace before interpretation.'}}]","The provided function extracts and processes cookie header entries by explicitly trimming leading and trailing whitespace from both the cookie name and its value. This directly addresses the RFC mandate to remove any bad whitespace before interpreting the protocol element. All whitespace-cleaning logic is implemented within this function, so the requirement is fully met.",success,
15010,log_cookie,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': 'name += strspn(name, "" \\t"");\nwhile (last >= name && apr_isspace(*last)) {\n    *last = \'\\0\';\n    --last;\n}\n\nvalue += strspn(value, "" \\t"");\nwhile (last >= value && apr_isspace(*last)) {\n    *last = \'\\0\';\n    --last;\n}', 'explanation': 'The code explicitly removes leading whitespace using strspn and removes trailing whitespace using a while loop for both the cookie name and cookie value. This directly implements the RFC requirement to exclude any leading or trailing whitespace from field values prior to evaluation.'}}]","The function retrieves the cookie header, tokenizes it, and then applies whitespace removal on both the cookie name and value before performing a case-insensitive comparison. This trimming logic addresses the RFC mandate to remove extraneous whitespace from HTTP field values, indicating that within its scope, the function correctly implements the specified requirement.",success,
15029,config_log_transaction,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function is focused on logging configuration and processing, such as handling conditional logging decisions and writing logs. It does not include any logic that verifies or restricts the generation of protocol elements based on the ABNF grammar as required by the RFC specification. Therefore, none of the labeled conditions (like C1) or actions (like A1) that pertain to the sender ensuring adherence to the ABNF-defined grammar are addressed within this function.",success,
15034,add_custom_log,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Does Not Match,[],"The provided function is concerned with configuring a custom log (parsing configuration strings such as 'env=' and 'expr=') rather than defensively parsing a received protocol element as mandated by the HTTP RFC specification. Although the function performs some basic checks (e.g., verifying that the environment clause is not empty), these measures are geared toward configuration validation rather than the defensive parsing requirements described in the spec (which include handling elements that might not conform to an expected ABNF grammar or fit within a reasonable buffer size). As such, no part of the function's logic addresses the labeled spec constraints, and the code cannot be considered to implement the required defensive parsing behavior on received protocol elements by itself.",success,
15087,log_headers,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided log_headers function is solely focused on appending a delimiter and then escaping the key and value before logging, but it does not incorporate any logic that enforces or verifies the RFC requirement stating that a sender MUST NOT generate protocol elements that are reserved for other roles. There is no check to confirm whether the header elements belong to the correct sender role, nor any decision-making based on role-specific permissions. Thus, none of the spec constraints (e.g., C1 or any corresponding actions like A1) are implemented in the function.",success,
15087,log_headers,"A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the ""message/http"" media type.",301,Does Not Match,[],"The provided function 'log_headers' only escapes and logs header key-value pairs; it does not implement any checks or logic to detect or prevent line folding (obs-fold) as required by the RFC specification. There is no code within the function addressing the constraints (like C1 or A1) regarding the prohibition of line folding unless the message is of 'message/http' media type. Therefore, the function does not visibly address any of the labeled spec constraints.",success,
15201,set_hc_condition,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (strlen(name) > (PROXY_WORKER_MAX_SCHEME_SIZE - 1)) {\n    return apr_psprintf(cmd->temp_pool, ""Expression name limited to %d characters"",\n                           (PROXY_WORKER_MAX_SCHEME_SIZE - 1));\n}', 'explanation': 'This check prevents overly long names, thereby ensuring that input does not exceed a reasonable buffer size – a defensive measure aligned with the RFC’s suggestion to not assume inputs will perfectly conform.'}}, {'A1': {'code': 'if (!*name) {\n    return apr_pstrcat(cmd->temp_pool, ""Missing expression name for "", cmd->cmd->name, NULL);\n}\n...\nexpr = ap_getword_conf2(cmd->temp_pool, &arg);\nif (!*expr) {\n    return apr_pstrcat(cmd->temp_pool, ""Missing expression for "", cmd->cmd->name, NULL);\n}\n...\nexpr = ap_getword_conf(cmd->temp_pool, &arg);\nif (*expr) {\n    return ""error: extra parameter(s)"";\n}', 'explanation': 'These segments check for required tokens (presence of a name and expression) and also validate that there are no extra parameters. This defensive behavior is in the spirit of not blindly trusting the input.'}}]","The RFC advises that protocol elements be parsed defensively and with minimal assumptions about their conformance to a strict grammar or size limitations. In this function, the input is handled defensively by checking that mandatory fields (name and expression) are present, by enforcing a maximum length on the name to protect against oversized inputs, and by ensuring there are no extra unexpected parameters. While these measures demonstrate a defensive approach, the implementation focuses on specific input tokens rather than covering all aspects of general HTTP protocol element parsing. As a result, the function only partially implements the full intent of the RFC’s recommendations.",success,
15204,create_request_rec,A recipient MUST NOT merge a received trailer field into the header section unless its corresponding header field definition explicitly permits and instructs how the trailer field value can be safely merged.,207,Does Not Match,[],"The provided function initializes separate tables for headers and trailers (r->headers_in, r->trailers_in, r->headers_out, r->trailers_out) but does not implement any logic relating to merging trailer fields into header sections. The RFC spec requires that trailer fields MUST NOT be merged unless explicitly permitted and safely handled; however, this function does not contain any merging code or checks to enforce or prevent such merging. Therefore, no part of the function directly addresses the given spec constraint.",success,
15204,create_request_rec,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The provided function initializes various request record fields, including allocating tables for headers and trailers. However, it does not contain any logic that addresses the specific RFC requirement regarding trailer field merging: there is no check or mechanism to ensure that a trailer field is merged into a header only if its definition is understood and permits safe merging. The function merely creates the data structures (trailers_in and trailers_out) without any processing or validation steps related to the RFC constraint.",success,
15204,create_request_rec,"Because of the potential for trailer fields to be discarded in transit, a server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive.",12,Does Not Match,[],"The provided function, create_request_rec, is responsible for initializing a request_rec structure and creating internal tables for headers and trailers. However, it does not include any logic that checks for the presence of the ""trailers"" keyword in the TE header or that ensures a server refrains from generating trailer fields that are necessary for the user agent as per the RFC specification. There is no conditional logic, decision-making, or any implementation that aligns with the specific requirement that a server should not generate crucial trailer fields. Therefore, no part of the function directly addresses the spec constraints (C1, A1, etc.) related to trailer fields as required by the HTTP RFC.",success,
15204,create_request_rec,A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.,30,Does Not Match,[],"The provided function create_request_rec merely initializes a request_rec structure and sets basic properties such as the request method, protocol, and header_only flag. Although it checks for an OPTIONS request (and a GET request starting with 'H' in a heuristic manner) to set r->header_only=1, this is not equivalent to implementing the specification requirement about protocol switching. In the RFC specification, the key constraint is that a server must not switch protocols unless the received message semantics can be honored by the new protocol, and that an OPTIONS request can always be honored. The function does not contain any logic which validates message semantics nor implements a protocol switch (like sending a 101 Switching Protocols and following up with a response in the new protocol). Therefore, there is no visible code to handle the protocol switching behavior as prescribed by the spec, and as such, the function does not address the relevant spec constraints.",success,
15206,create_hcheck_req,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'req = apr_psprintf(p,\n                       ""OPTIONS * %s\\r\\n""\n                       ""Host: %s:%d\\r\\n""\n                       ""\\r\\n"", protocol,\n                       hc->s->hostname_ex, (int)hc->s->port);\n\n// and later for HEAD/GET:\nreq = apr_psprintf(p,\n                       ""%s %s%s%s %s\\r\\n""\n                       ""Host: %s:%d\\r\\n""\n                       ""\\r\\n"",\n                       method,\n                       (wctx->path ? wctx->path : """"),\n                       (wctx->path && *hc->s->hcuri ? ""/"" : """" ),\n                       (*hc->s->hcuri ? hc->s->hcuri : """"),\n                       protocol,\n                       hc->s->hostname_ex, (int)hc->s->port);', 'explanation': 'The function constructs HTTP request strings using fixed formatting that closely follows the expected ABNF grammar for a request-line and a host header. It takes care to use CRLF as terminators. This indicates an attempt to generate protocol elements as defined in the RFC, thereby addressing the requirement that a sender must only generate elements matching the ABNF grammar.'}}]","The function 'create_hcheck_req' builds HTTP request strings based on different methods (OPTIONS, HEAD, and GET) using hardcoded format patterns that mimic the ABNF grammar provided by the HTTP RFC. This effort appears to ensure that the generated protocol elements are valid. However, while the fixed string formatting helps maintain conformance for these specific cases, the function does not perform any further dynamic validation or handle all possible cases, nor does it explicitly verify that no prohibited elements (or elements destined only for other roles) are generated. Consequently, although the function partially meets the constraint by constructing seemingly valid HTTP request segments, it does not fully cover every requirement implied by the spec context.",success,
15206,create_hcheck_req,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function creates HTTP request strings based on a method and protocol version but does not include any logic to enforce that a sender must not generate protocol elements or syntax alternatives reserved for roles it does not possess (as described in the spec). There is no check or verification relating to the generation of prohibited protocol elements based on the sender's role, nor any logic ensuring conformance to the role-specific grammar defined by the ABNF rules. As such, the function does not visibly address any of the specified conditions (e.g., C1) or actions (e.g., A1) within its own implementation.",success,
15206,create_hcheck_req,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Does Not Match,[],"The RFC requirement states that a sender MUST NOT generate an 'http' URI with an empty host identifier. However, within function_body, the code directly uses hc->s->hostname_ex to construct the Host header without any validation check to ensure that the hostname is non-empty. There is no logic that verifies the host identifier is non-empty before generating the request, so the function does not visibly address this specific spec constraint.",success,
15206,create_hcheck_req,All general-purpose servers MUST support the methods GET and HEAD,58,Fully Matches,"[{'C1': {'code': 'case HEAD:\ncase HEAD11:\n    method = ""HEAD"";\n    /* fallthru */\ncase GET:\ncase GET11:\n    if (!method) { /* did we fall thru? If not, we are GET */\n        method = ""GET"";\n    }\n    req = apr_psprintf(p,\n                       ""%s %s%s%s %s\\r\\n""\n                       ""Host: %s:%d\\r\\n""\n                       ""\\r\\n"",\n                       method,\n                       (wctx->path ? wctx->path : """"),\n                       (wctx->path && *hc->s->hcuri ? ""/"" : """" ),\n                       (*hc->s->hcuri ? hc->s->hcuri : """"),\n                       protocol,\n                       hc->s->hostname_ex, (int)hc->s->port);', 'explanation': 'This segment directly creates the HTTP request for both GET and HEAD methods, ensuring that the server supports these required operations as per the RFC.'}}]","The provided function constructs an HTTP request for health checks and explicitly handles GET and HEAD methods, which are mandated by the RFC for all general-purpose servers. By including specific switch cases for GET/HEAD (and their HTTP/1.1 variants), the function visibly addresses the requirement that the server must support these two methods. Therefore, the code function fully meets the relevant specified conditions.",success,
15207,hc_get_hcworker,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'port = (worker->s->port ? worker->s->port : ap_proxy_port_of_scheme(worker->s->scheme));', 'explanation': 'The code explicitly checks if a port is provided (worker->s->port) and, if not, retrieves the default port using ap_proxy_port_of_scheme. This directly implements the RFC requirement that if a port is not provided, the recipient may interpret that as meaning the default port for the given scheme.'}}]","The function includes a specific check for the presence of a port number and, when absent, retrieves and uses the default port corresponding to the protocol, which is exactly as specified in the RFC. The logic is contained entirely within the function, satisfying the constraint purely by its own implementation.",success,
15215,hc_read_headers,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': ""while (apr_isspace(*value))\n    ++value;            /* Skip to start of value   */\nfor (end = &value[strlen(value)-1]; end > value && apr_isspace(*end); --end)\n    *end = '\\0';"", 'explanation': 'This code segment ensures that any leading whitespace (using a while loop) and trailing whitespace (using a reverse for loop) are excluded from the field value before it is used. This directly addresses the RFC specification to remove such whitespace prior to evaluation.'}}, {'A1': {'code': ""while (apr_isspace(*value))\n    ++value;\nfor (end = &value[strlen(value)-1]; end > value && apr_isspace(*end); --end)\n    *end = '\\0';"", 'explanation': 'This implementation of explicitly trimming the header field value aligns with the action requirement of excluding whitespace before evaluating the field value.'}}]","The function processes header lines by first splitting the header name from its value and then eliminating any leading and trailing whitespace from the field value. This behavior directly implements the RFC requirement that when allowed whitespace appears, it must be excluded before the field value is processed. The trimming logic is contained entirely within the function and thus fully meets the constraint.",success,
15215,hc_read_headers,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,"[{'A1': {'code': ""while (apr_isspace(*value))\n    ++value;            /* Skip to start of value   */\nfor (end = &value[strlen(value)-1]; end > value && apr_isspace(*end); --end)\n    *end = '\\0';"", 'explanation': 'This code trims leading and trailing whitespace from header field values, which is a partial measure toward the RFC requirement of removing bad whitespace. However, the RFC emphasizes removing such whitespace from the protocol element (e.g. the status line), and this function does not explicitly normalize whitespace in that part.'}}]","The RFC requires that a recipient must parse for and remove bad whitespace before interpreting the protocol element. The provided function does implement whitespace removal for header values by trimming spaces around them, which satisfies part of the requirement. However, it does not explicitly handle the removal of extraneous or bad whitespace from the protocol element (the HTTP status line) before processing it. As the function only partially addresses the spec (focusing on header fields rather than the protocol element), the overall judgment is that it 'Partially Matches' the given RFC specification.",success,
15215,hc_read_headers,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Partially Matches,"[{'A1': {'code': ""while (apr_isspace(*value))\n    ++value;            /* Skip to start of value   */\nfor (end = &value[strlen(value)-1]; end > value && apr_isspace(*end); --end)\n    *end = '\\0';"", 'explanation': 'This segment of code trims any leading and trailing whitespace from the header value, which is an implementation of the recipient’s requirement to remove bad whitespace (BWS) as specified by the RFC. However, the function only performs this whitespace removal on header values and does not address every possible location where BWS might occur in an HTTP message.'}}]","The RFC states that recipients must remove BWS (bad whitespace) from protocol elements before interpretation. Within this function, the only explicit handling of whitespace is found in the header processing loop, where the code skips over leading whitespace and trims trailing whitespace from header values. This indicates an attempt to enforce the removal of unnecessary whitespace (BWS) for header values, fulfilling that part of the specification. Since the implementation does not fully cover all aspects of BWS removal as potentially required by the RFC (e.g., it does not account for optional whitespace in other protocol elements), the overall match is judged as partially matching the RFC intent.",success,
15215,hc_read_headers,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'len = ap_getline(buffer, sizeof(buffer), r, 1);\nif (len <= 0) {\n    return !OK;\n}\n\nif (apr_date_checkmask(buffer, ""HTTP/#.# ###*"")) {\n    int major;\n    /* ... subsequent parsing ... */\n    if ((major != 1) || (len >= sizeof(buffer)-1)) {\n        return !OK;\n    }\n    /* ... */\n} else {\n    return !OK;\n}', 'explanation': ""This segment defensively reads an input line into a fixed-size buffer, checks if data was read, and then uses a mask check (apr_date_checkmask) to verify that the status line conforms to a minimal ABNF-like pattern. It also ensures that the data doesn't exceed the buffer limits. This demonstrates an attempt to process the protocol element defensively.""}}, {'A1': {'code': ""while ((len = ap_getline(buffer, sizeof(buffer), r, 1)) > 0) {\n    char *value, *end;\n    if (!(value = strchr(buffer, ':'))) {\n        return !OK;\n    }\n    *value = '\\0';\n    ++value;\n    while (apr_isspace(*value))\n        ++value;\n    for (end = &value[strlen(value)-1]; end > value && apr_isspace(*end); --end)\n        *end = '\\0';\n    apr_table_add(r->headers_out, buffer, value);\n}"", 'explanation': 'This loop parses each subsequent header line by ensuring the presence of a colon, trimming whitespace, and storing header key-value pairs. It shows an effort to defend against malformed header lines, aligning with the expectation of marginal conformance in the RFC.'}}]","The function implements basic defensive parsing by reading data using a fixed-size buffer, checking for valid length, and applying minimal pattern matching to the status line and headers. However, while it does address some aspects of defensive parsing (e.g., pattern checks and boundary safeguards), it does not comprehensively handle all potential variations or length issues as suggested in the RFC specification. Thus, it partially meets the conditions and actions described in the spec constraints.",success,
15215,hc_read_headers,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,"[{'A1': {'code': '    /* Set the Content-Type for the request if set */\n    if ((ct = apr_table_get(r->headers_out, ""Content-Type"")) != NULL)\n        ap_set_content_type(r, ct);', 'explanation': ""This segment checks if a Content-Type header was received and, if so, sets the request's content type accordingly. This partially addresses the RFC requirement by using the provided header, but it does not itself generate a Content-Type header if one is absent.""}}]","The RFC specifies that a sender with content SHOULD generate a Content-Type header, unless the media type is unknown. In this function, if a Content-Type header is present in the parsed response, it is applied to the request record. However, the function does not create or add a Content-Type header when missing, meaning that it only partially implements the RFC's requirement by merely passing along an existing header rather than generating one when needed.",success,
15215,hc_read_headers,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that within a given message, a sender must not generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. This function (hc_read_headers) is solely focused on reading and parsing HTTP response headers and does not involve generating protocol elements at all. It validates the status line format using a date check mask and parses header fields, but no logic is present that implements or enforces the specific sender role constraint mentioned in the RFC. Therefore, the function does not attempt to implement the specified RFC requirement.",success,
15267,ajp_marshal_into_msgb,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function is responsible for serializing an HTTP request into an AJP message by appending various fields (such as method, headers, SSL properties, etc.) to the message buffer. However, the RFC specification requires that within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. In this function, there is no explicit logic or check that verifies the sender’s role or restricts the generation of protocol elements based on role responsibilities. Thus, none of the spec’s role‐based constraints (e.g., the condition to avoid generating elements not permitted for the sender’s role) are visibly implemented in this function. As a result, the function does not visibly address the required spec constraints.",success,
15267,ajp_marshal_into_msgb,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function constructs an AJP message by appending various protocol elements (e.g., method, protocol, headers, attributes) without performing any explicit validation to ensure the generated elements conform to the ABNF grammar required by the RFC. Although it uses helper functions (like ajp_msg_append_string and ajp_msg_append_uint8) to build the message, there is no in-function logic to check against the ABNF rules. Therefore, within the code of this function alone, it does not implement the requirement that a sender MUST NOT generate protocol elements that do not match the specified grammar.",success,
15267,ajp_marshal_into_msgb,"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",225,Does Not Match,[],"The RFC specifies that a sender MUST NOT generate an ""https"" URI with an empty host identifier. However, in the provided function, there is no logic that checks the host component of the URI (or any equivalent) to ensure that it is not empty before generating the URI. The function uses values such as r->useragent_ip, remote_host (obtained via ap_get_useragent_host), and ap_get_server_name(r) but it does not validate that for an https request the host identifier is non-empty. Therefore, the code function does not visibly address the required spec constraint.",success,
15269,ajp_unmarshal_response,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'if (!apr_table_get(r->subprocess_env, AP_TRUST_CGILIKE_CL_ENVVAR))\n    apr_table_unset(r->headers_out, ""Content-Length"");\napr_table_unset(r->headers_out, ""Transfer-Encoding"");', 'explanation': ""This code segment ensures that if the environment does not trust a CGI-like Content-Length (thus potentially having a Content-Length header), it explicitly removes the 'Content-Length' header. Additionally, it unconditionally removes the 'Transfer-Encoding' header from the outgoing headers. As a result, the message never simultaneously contains both 'Transfer-Encoding' and 'Content-Length', thereby satisfying the RFC requirement that a sender MUST NOT send a Content-Length header field when a Transfer-Encoding header field is present.""}}]","The function implements the RFC specification by making sure that neither content-length nor transfer-encoding headers conflict. It conditionally removes the Content-Length header (depending on an environment variable) and always removes the Transfer-Encoding header, ensuring that no outgoing message contains a Transfer-Encoding header along with a Content-Length header. Therefore, the implementation fully matches the spec constraint within the function body.",success,
15269,ajp_unmarshal_response,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided code function (ajp_unmarshal_response) is focused on unmarshalling an AJP response and processing header fields, status codes, and related values. While it does perform translation of protocol strings (e.g., using ap_xlate_proto_from_ascii) and maps header values for further processing, it does not contain any explicit logic to verify or enforce that the protocol elements it generates strictly adhere to the ABNF grammar defined by the HTTP RFC. In other words, it does not implement a check or validation that ensures protocol elements conform to the specified grammar, and therefore, it does not meet the requirement that a sender MUST NOT generate protocol elements that do not match the grammar. There is no segment of the function that fulfills this requirement by itself.",success,
15269,ajp_unmarshal_response,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function (ajp_unmarshal_response) is primarily concerned with unmarshalling an AJP response, extracting the status, status line, and headers, and then processing these headers (including content translation and reverse mapping for certain header fields). There is no logic within the function that checks whether the sender is generating protocol elements or syntax alternatives that are reserved for other roles, as required by the RFC specification. Specifically, the function does not implement any verification against the ABNF grammar for role-specific protocol elements nor does it verify that the sender is not mistakenly generating elements belonging to another role. Therefore, it does not address the spec constraint regarding role-based generation of protocol elements.",success,
15269,ajp_unmarshal_response,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'rc = ajp_msg_get_uint16(msg, &status);\nif (rc != APR_SUCCESS) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00983)\n            ""ajp_unmarshal_response: Null status"");\n    return rc;\n}\n\n... (similar checks for string and header values)', 'explanation': 'The function uses defensive parsing techniques by checking the return values (rc) for each parsed protocol element. Whenever an operation (like ajp_msg_get_uint16 or ajp_msg_get_string) fails, it logs an error and returns immediately. This behavior reflects a defensive approach in the spirit of the RFC, which advocates for only marginal expectations about conformance.'}}, {'A1': {'code': 'ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00986)\n       ""ajp_unmarshal_response: \\n       Null header value"");\n\n... (other logging statements for error conditions)', 'explanation': 'The function takes action by logging errors whenever a protocol element (such as status, header name, or header value) does not parse as expected. This logging and immediate error handling is a clear action toward mitigating issues with nonconforming inputs.'}}]","The ajp_unmarshal_response function implements defensive parsing by checking the success of each parsing operation and logging errors when an element does not meet expectations. This aligns with the RFC's guidance to expect only marginal conformance to the ABNF grammar and to handle unexpected input defensively. However, the function does not explicitly verify buffer sizes or perform detailed grammar validation, likely because such responsibilities are delegated to underlying helper functions. Therefore, while key defensive measures are present, the function only partially matches the full set of RFC requirements on defensive parsing.",success,
15269,ajp_unmarshal_response,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,[],"The function ajp_unmarshal_response attempts to interpret an AJP response message by parsing the status, status line, and header fields, and it even performs specific processing (e.g. for Set‐Cookie and Location headers) and basic error recovery (such as resetting the headers table when retrieving the header count fails). These activities indicate an effort to map incoming protocol elements to HTTP response semantics. However, the implementation does not fully cover the overall requirement of interpreting protocol elements per the RFC—specifically, it lacks robust mechanisms to decide when the sender is incorrectly implementing the semantics (e.g. based on configuration or experience) and does not implement comprehensive error recovery for numerous potential invalid constructs. As such, only part of the spec constraint (for example, aspects resembling a condition like C1 or an action like A1) is addressed in the isolated function, but not in a complete manner as required by the RFC.",success,
15269,ajp_unmarshal_response,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,[],"The RFC specification requires that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect. In the provided code, there is an attempt to avoid relying on the Content-Length header by unsetting it (and the Transfer-Encoding header) in the response header table when a specific trust flag is not set (see: if (!apr_table_get(r->subprocess_env, AP_TRUST_CGILIKE_CL_ENVVAR)) apr_table_unset(r->headers_out, ""Content-Length"")). This action is related to preventing potentially incorrect Content-Length values from propagating. However, the code does not perform any validation of the actual Content-Length header value against the ABNF, nor does it check for duplicate values (e.g., ""42, 42"") as specified in the RFC. As a result, while the function does address avoiding forwarding an incorrect Content-Length header by removing it under most conditions, it does not fully implement the RFC's requirement to validate the header's correctness. Thus, only part of the condition is addressed within this function.",success,
15270,ajp_send_header,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function ajp_send_header does not implement any logic to ensure that the protocol elements it generates conform to the ABNF grammar as required by the RFC. The function merely delegates tasks to helper functions (ajp_msg_create, ajp_marshal_into_msgb, and ajp_ilink_send) without any visible checks or validations against the grammar. Since validation or conformance to the ABNF grammar is not handled within the function body itself (and dependency code is not counted), the function does not address the constraint specified in the RFC.",success,
15272,ajp_parse_type,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function ajp_parse_type only reads a byte from the message, logs it, and returns it. It does not implement any logic to ensure that protocol elements are generated only by designated roles or enforce restrictions on generating syntax alternatives as described by the RFC specification. There are no conditional checks or validations in the function body that evaluate the role of the sender or the conformity of protocol elements to the approved grammar. Thus, it does not address any of the spec constraints (e.g., C1, A1) in its isolated implementation.",success,
15273,ajp_parse_header,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'rc = ajp_msg_get_uint8(msg, &result);\nif (rc != APR_SUCCESS) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00994)\n           ""ajp_parse_headers: ajp_msg_get_byte failed"");\n    return rc;\n}\nif (result != CMD_AJP13_SEND_HEADERS) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00995)\n           ""ajp_parse_headers: wrong type %s (0x%02x) expecting %s (0x%02x)"",\n           ajp_type_str(result), result,\n           ajp_type_str(CMD_AJP13_SEND_HEADERS), CMD_AJP13_SEND_HEADERS);\n    return AJP_EBAD_HEADER;\n}', 'explanation': 'This segment verifies that the received protocol element (header) conforms to the expected type, addressing the spec’s requirement to interpret the received protocol element as defined by its semantics. However, while it correctly validates the type, it does not attempt to recover a usable protocol element when an invalid construct is received, which is permitted by the spec.'}}]","The function ajp_parse_header checks and validates the command type of the received message, which partially meets the RFC requirement that a recipient must interpret a protocol element according to its defined semantics. However, it lacks additional handling such as recovering from an invalid construct, which is allowed by the RFC, so the implementation only partially addresses the specification.",success,
15273,ajp_parse_header,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'rc = ajp_msg_get_uint8(msg, &result);\nif (rc != APR_SUCCESS) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00994) ""ajp_parse_headers: ajp_msg_get_byte failed"");\n    return rc;\n}', 'explanation': 'This segment shows that the function defensively attempts to read a byte from the message, checking for errors rather than assuming the data conforms to an expected format.'}}, {'A1': {'code': 'if (result != CMD_AJP13_SEND_HEADERS) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00995) ""ajp_parse_headers: wrong type %s (0x%02x) expecting %s (0x%02x)"",\n           ajp_type_str(result), result,\n           ajp_type_str(CMD_AJP13_SEND_HEADERS), CMD_AJP13_SEND_HEADERS);\n    return AJP_EBAD_HEADER;\n}', 'explanation': 'This block verifies that the received protocol element has the expected type, which is a defensive measure ensuring that the header conforms minimally to expectations.'}}]","The function performs defensive checks by verifying that it correctly reads a byte from the protocol element and that the value matches the expected header type. These checks align with the RFC's recommendation to parse protocol elements defensively. However, while it handles basic error conditions (e.g., failing to read or encountering an unexpected type), it does not appear to cover further defensive measures such as verifying that additional elements conform to an ABNF grammar or enforcing buffer size considerations. Therefore, the function only partially meets the overall defensive parsing expectation outlined in the RFC specification.",success,
15274,ajp_parse_data,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'rc = ajp_msg_get_uint8(msg, &result);\nif (rc != APR_SUCCESS) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00996) ""ajp_parse_data: ajp_msg_get_byte failed"");\n    return rc;\n}\nif (result != CMD_AJP13_SEND_BODY_CHUNK) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00997) ""ajp_parse_data: wrong type %s (0x%02x) expecting %s (0x%02x)"",\n           ajp_type_str(result), result,\n           ajp_type_str(CMD_AJP13_SEND_BODY_CHUNK), CMD_AJP13_SEND_BODY_CHUNK);\n    return AJP_EBAD_HEADER;\n}', 'explanation': ""This segment checks and validates the protocol element type, ensuring that the received message's type conforms to the expected CMD_AJP13_SEND_BODY_CHUNK as the RFC requires a recipient to interpret the protocol element based on its defined semantics.""}}, {'C2': {'code': 'rc = ajp_msg_get_uint16(msg, len);\nif (rc != APR_SUCCESS) {\n    return rc;\n}\nexpected_len = msg->len - (AJP_HEADER_LEN + AJP_HEADER_SZ_LEN + 1 + 1);\nif (*len != expected_len) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00998) ""ajp_parse_data: Wrong chunk length. Length of chunk is %i, expected length is %i."", *len, expected_len);\n    return AJP_EBAD_HEADER;\n}', 'explanation': 'This code segment calculates the expected length of the data chunk based on header sizes and verifies that the parsed length matches this value. If not, it logs the error and returns early, ensuring that only messages with correctly formed lengths are processed.'}}]","The function attempts to verify and interpret incoming AJP messages by checking the type and length against expected values, in line with the RFC's requirement that a recipient interprets received protocol elements based on defined semantics. However, while the function validates structural aspects strictly (by rejecting improperly formed messages), it does not implement more elaborate error recovery or configuration-based exceptions as mentioned in the RFC context. Therefore, it only partially matches the complete spirit of the specification as it only covers some of the conditions (C1, C2) visible in the code.",success,
15274,ajp_parse_data,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'rc = ajp_msg_get_uint8(msg, &result);\nif (rc != APR_SUCCESS) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00996) ""ajp_parse_data: ajp_msg_get_byte failed"");\n    return rc;\n}\nif (result != CMD_AJP13_SEND_BODY_CHUNK) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00997) ""ajp_parse_data: wrong type %s (0x%02x) expecting %s (0x%02x)"",\n           ajp_type_str(result), result,\n           ajp_type_str(CMD_AJP13_SEND_BODY_CHUNK), CMD_AJP13_SEND_BODY_CHUNK);\n    return AJP_EBAD_HEADER;\n}', 'explanation': 'This segment of code defensively verifies the command type of the received protocol element. It checks whether the message type matches the expected value, returning an error if it does not, which is in line with the spirit of defensive parsing prescribed in the spec.'}}, {'A1': {'code': 'rc = ajp_msg_get_uint16(msg, len);\n...\nexpected_len = msg->len - (AJP_HEADER_LEN + AJP_HEADER_SZ_LEN + 1 + 1);\nif (*len != expected_len) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00998) ""ajp_parse_data: Wrong chunk length. Length of chunk is %i, expected length is %i."", *len, expected_len);\n    return AJP_EBAD_HEADER;\n}', 'explanation': 'This part of the function defensively validates the size of the incoming data chunk by computing the expected length based on the full message length and header information, then comparing it to the received length. Such a check helps ensure that the protocol element conforms to minimal structural expectations.'}}]","The function implements certain defensive parsing measures by verifying the command type and ensuring that the data chunk length matches an expected value computed from the overall message length. This approach aligns with part of the RFC specification that mandates defensive parsing with only marginal expectations on conformity. However, the function does not include broader checks such as ensuring that the buffer is within a 'reasonable' size or fully validating the entire ABNF grammar. As a result, the function partially meets the specified defensive parsing constraints.",success,
15275,ajp_parse_reuse,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'rc = ajp_msg_get_uint8(msg, &result);\nif (rc != APR_SUCCESS) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00999) ""ajp_parse_reuse: ajp_msg_get_byte failed"");\n    return rc;\n}\nif (result != CMD_AJP13_END_RESPONSE) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01000) ""ajp_parse_reuse: wrong type %s (0x%02x) expecting %s (0x%02x)"",\n                   ajp_type_str(result), result,\n                   ajp_type_str(CMD_AJP13_END_RESPONSE), CMD_AJP13_END_RESPONSE);\n    return AJP_EBAD_HEADER;\n}', 'explanation': 'The function implements defensive parsing by verifying that the message contains a valid header: it checks the return value from ajp_msg_get_uint8 and confirms that the retrieved byte equals the expected constant. This behavior aligns with the defensive parsing requirement in the spec, although it covers only a minimal subset of the overall defensive parsing strategy suggested by the RFC.'}}]","The RFC specification emphasizes defensive parsing with marginal assumptions about protocol element conformity and reasonable buffer sizes. The function ajp_parse_reuse demonstrates defensive parsing by checking the return status of the function call and enforcing an expected byte value, thereby mitigating some risks associated with unexpected or malformed data. However, it does not implement other potential defensive measures such as explicit checks for buffer size or comprehensive ABNF grammar validation; these aspects may be handled elsewhere in the codebase. Thus, the function only partially meets the spec constraints in isolation.",success,
15275,ajp_parse_reuse,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'rc = ajp_msg_get_uint8(msg, &result);\nif (rc != APR_SUCCESS) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00999)\n           ""ajp_parse_reuse: ajp_msg_get_byte failed"");\n    return rc;\n}\nif (result != CMD_AJP13_END_RESPONSE) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01000)\n           ""ajp_parse_reuse: wrong type %s (0x%02x) expecting %s (0x%02x)"",\n           ajp_type_str(result), result,\n           ajp_type_str(CMD_AJP13_END_RESPONSE), CMD_AJP13_END_RESPONSE);\n    return AJP_EBAD_HEADER;\n}', 'explanation': 'This segment reads a protocol element from the message and verifies its type against the expected CMD_AJP13_END_RESPONSE. It represents an attempt to interpret the received protocol element as required by the spec.'}}, {'A1': {'code': 'ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01000)\n       ""ajp_parse_reuse: wrong type %s (0x%02x) expecting %s (0x%02x)"",\n       ajp_type_str(result), result,\n       ajp_type_str(CMD_AJP13_END_RESPONSE), CMD_AJP13_END_RESPONSE);\nreturn AJP_EBAD_HEADER;', 'explanation': 'This code logs an error and returns an error code when the protocol element is not of the expected type, thereby addressing error handling as stipulated by the spec when the semantics are not met.'}}]","The function attempts to interpret a received protocol element by reading its type and verifying it matches the expected value. If the element does not meet the expected semantics, it logs an error and returns an error code. This approach partially addresses the spec's mandate to interpret received protocol elements and handle deviations. However, it does not cover extended interpretation mechanisms or recovery approaches that the spec allows, meaning it only partially meets the full requirements.",success,
15289,copy_headers_in,A sender MUST NOT send a connection option corresponding to a field that is intended for all recipients of the content.,252,Partially Matches,"[{'C1': {'code': 'case \'c\':\ncase \'C\':\n    if (ap_cstr_casecmp(""Connection"", key) == 0) {\n        return 0;\n    }', 'explanation': 'This segment explicitly checks if the header key is ""Connection"" and, if so, ignores it. This prevents a connection-specific header from being forwarded, which addresses part of the RFC requirement.'}}, {'C1': {'code': 'case \'u\':\ncase \'U\':\n    if (ap_cstr_casecmp(""Upgrade"", key) == 0) {\n        return 0;\n    }', 'explanation': 'This segment filters out the ""Upgrade"" header, another connection-specific header that should not be forwarded as per the RFC, further aligning with the requirement.'}}]","The RFC demands that a sender must not send a connection option corresponding to a field intended for all recipients of the content. In this function, several connection-specific headers (e.g., 'Connection' and 'Upgrade') are explicitly excluded by returning early. This shows that the function is attempting to implement the spec by not propagating these headers. However, the implementation handles only a subset of potential connection-specific headers (for example it omits a check for 'Cache-Control', which the spec cites as an example of a header that should not be used as a connection option). Therefore, while the function does address key aspects of the RFC requirement, it does so only partially.",success,
15290,copy_headers_out,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,"[{'C1': {'code': 'if (ap_cstr_casecmp(""Content-Type"", key) == 0) {\n    ap_set_content_type(ctx->r, value);\n    done = 1;\n    break;\n}', 'explanation': ""The function checks if the header is 'Content-Type' and then calls ap_set_content_type using the provided value. This code segment addresses the RFC instruction to send a Content-Type header when content is present. However, it only reacts if the header is already provided and does not generate a header when missing, which is a nuance of the specification.""}}]","The provided function inspects header keys and, when finding 'Content-Type', sets the request content type accordingly. This action partially implements the RFC requirement to generate a Content-Type header when content is present. However, since the RFC advises that a header SHOULD be generated unless the media type is unknown, the function’s behavior is limited to copying an already existing header and does not cover cases where the header might be missing or when the media type is unknown. Thus, only part of the specification is visibly addressed within this function.",success,
15293,setup_request,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC specification requires that a sender must not generate protocol elements that do not match the ABNF-defined grammar. In the function_body, while the request is assembled (e.g., by copying headers and setting elements such as the Host and Accept-Encoding), there is no explicit logic to validate or enforce that the generated protocol elements conform to the ABNF rules. The function relies on lower-level routines (such as serf_bucket_request_create) to ultimately produce the request, but from the visible code in this function itself, there is no implementation designed to ensure that only grammar-compliant elements are generated. Thus, no explicit condition or action addressing the specified requirement (e.g., ensuring ABNF conformance) is implemented within this function.",success,
15293,setup_request,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function assembles the HTTP request by setting the method, URI, and headers (including Host and Accept-Encoding) and optionally applies SSL encryption. However, there is no explicit logic within the function that checks or enforces the RFC condition stating that 'a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles.' In other words, while the function creates request elements, it does not validate or filter out protocol elements that might be reserved for other roles, and thus it does not visibly address the spec constraint by itself.",success,
15293,setup_request,"Note that the coding named ""identity"" is reserved for its special role in Accept-Encoding and thus SHOULD NOT be included.",38,Partially Matches,"[{'C1': {'code': 'serf_bucket_headers_setn(hdrs_bkt, ""Accept-Encoding"", ""gzip"");', 'explanation': ""The code explicitly sets the 'Accept-Encoding' header to 'gzip', thereby ensuring that the 'identity' coding is not included. This corresponds with the spec requirement that the reserved 'identity' value should not be part of the encoding list.""}}]","The provided function sets the 'Accept-Encoding' header to 'gzip' and does not include 'identity', which is in line with one of the key aspects of the specification. However, the spec mandates that if one or more encodings have been applied to a representation, the sender must generate a 'Content-Encoding' header that lists them in order. The function does not handle generating a 'Content-Encoding' header and only deals with the 'Accept-Encoding' header. Since only one of the spec's constraints is visibly handled in the function, the overall implementation is considered to partially match the specified RFC.",success,
15297,add_pass,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'if (!conf->url.port) {\n        conf->url.port = apr_uri_port_of_scheme(conf->url.scheme);\n    }', 'explanation': 'This code segment checks if the port field is absent and, if so, assigns it the default port based on the URL scheme. This behavior directly implements the RFC specification that if a port is not provided, the recipient may interpret it as received on the default port.'}}]",The function_body handles the case where no port is provided by explicitly setting the port to the default value corresponding to the URL scheme. This behavior fully addresses the given RFC requirement as specified in the provided spec.,success,
15304,argstr_to_table,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function simply tokenizes an input string based on '&' delimiters, splits key-value pairs at '=', unescapes the URL components, and populates an apr_table_t. There is no logic in the function that checks or prevents the generation of protocol elements or syntax alternatives that are only allowed to be generated by specific roles, which is the requirement specified in the RFC. Therefore, none of the spec constraints (e.g., C1 or A1) are addressed by this function's implementation.",success,
15310,static_list_servers,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 's->port = port ? port : 80;', 'explanation': 'This code checks if a port was provided; if not, it sets the port to 80, which is the default for HTTP. This directly implements the condition that if no port is provided, it should be interpreted as the default port for the received protocol.'}}]","The function processes a comma-separated list of hosts, parses each for an optional port, and explicitly applies a default port of 80 when none is provided. This meets the RFC specification requirement described in C1, ensuring that if a port is not given, the default HTTP port (80) is used. Since this logic is contained within the function itself, it fully addresses the specified constraint.",success,
15319,proxy_wstunnel_canon,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'if (ap_cstr_casecmpn(url, ""ws:"", 3) == 0) {\n    url += 3;\n    scheme = ""ws:"";\n    def_port = apr_uri_port_of_scheme(""http"");\n}\nelse if (ap_cstr_casecmpn(url, ""wss:"", 4) == 0) {\n    url += 4;\n    scheme = ""wss:"";\n    def_port = apr_uri_port_of_scheme(""https"");\n}\n...\nport = def_port;\n...\nif (port != def_port)\n    apr_snprintf(sport, sizeof(sport), "":%d"", port);\nelse\n    sport[0] = \'\\0\';', 'explanation': ""The function determines the default port based on the URL scheme (either HTTP or HTTPS for ws and wss, respectively). It initializes 'port' with the default value and later checks if an explicit port has been provided. If not, it uses the default port, thereby addressing the RFC requirement that states a missing port should be interpreted as the default.""}}]","The provided function implements the RFC requirement by checking the URL scheme and assigning a default port when no explicit port is provided. This logic guarantees that if a port is not supplied in the URL, the default port for the protocol will be used, which matches the specified HTTP RFC behavior.",success,
15319,proxy_wstunnel_canon,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",175,Partially Matches,"[{'C1': {'code': 'err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);\nif (err) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02439) ""error parsing URL %s: %s"", url, err);\n    return HTTP_BAD_REQUEST;\n}', 'explanation': ""This segment checks the syntactic validity of the URL by attempting to parse it. When parsing fails (i.e., the received sequence of characters doesn't match the expected grammar), the function responds with a 400 Bad Request by returning HTTP_BAD_REQUEST, in line with part of the RFC robustness requirement.""}}, {'A1': {'code': 'path = ap_proxy_canonenc_ex(r->pool, url, strlen(url), enc_path, flags, r->proxyreq);\nif (!path) {\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'This code attempts to canonically encode the path. If the encoding fails (implying nonconformance to expected URL formatting), the function returns HTTP_BAD_REQUEST, thereby taking action to reject malformed inputs.'}}]","The function implements partial handling of the RFC specification related to rejecting malformed HTTP requests. It verifies parts of the URL and, upon detecting parsing or encoding failures, returns a 400 (Bad Request) response. However, it does not explicitly address other aspects of the RFC spec such as handling or consuming extraneous whitespace between the start-line and header fields, and in some cases it returns HTTP_FORBIDDEN instead of HTTP_BAD_REQUEST. Thus, only some of the conditions and actions mandated by the spec are visibly implemented in this function.",success,
15319,proxy_wstunnel_canon,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,[],"The function does attempt to validate and canonicalize the request-target by checking for raw control characters or spaces (e.g. via ap_scan_vchar_obstext) and returns an error response (HTTP_BAD_REQUEST for URL parsing errors and HTTP_FORBIDDEN if control characters or spaces are found). This shows an intention to reject an invalid request-line without attempting to auto‐correct it, which is partly in line with the RFC description. However, the RFC specifies that recipients SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded. The function never implements a 301 redirect and, in one branch, returns an HTTP_FORBIDDEN error instead of 400. Also, additional aspects such as the proper checking of the Host header are not handled here. Since only part of the constraint is met by the function’s internal logic, it is classified as a partial match.",success,
15320,proxy_wstunnel_request,"A sender of Upgrade MUST also send an ""Upgrade"" connection option in the Connection header field (Section 7.6.1) to inform intermediaries not to forward this field.",31,Partially Matches,"[{'C1': {'code': 'buf = apr_pstrcat(p, ""Upgrade: "", upgrade, CRLF\n                         ""Connection: Upgrade"" CRLF\n                         CRLF, NULL);', 'explanation': ""This code explicitly constructs the HTTP header by including both the 'Upgrade' header and the required 'Connection: Upgrade' header. This directly implements the RFC requirement that a sender of an Upgrade must also send the 'Upgrade' option in the Connection header field.""}}]","The function constructs an HTTP request for a WebSocket tunnel and, in doing so, explicitly sends both the 'Upgrade' and the 'Connection: Upgrade' headers. This fulfills the specific spec constraint regarding the inclusion of the 'Upgrade' connection option. However, the RFC context includes additional rules—such as handling HTTP/1.0 requests, processing the Expect header with '100-continue', etc.—which are not addressed within this function. Therefore, while the function visibly implements the key header requirement (labeled here as C1), it does not address all aspects of the extended spec context, leading to a 'Partially Matches' judgment.",success,
15321,proxy_wstunnel_handler,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function 'proxy_wstunnel_handler' does not contain any code that addresses the RFC's requirements regarding the prevention of multiple field lines with the same name or preserving their order when forwarding messages. While the function does handle the 'Upgrade' header by retrieving it and verifying it matches expected values, it does not manipulate, validate, or preserve the order of HTTP header fields per the specified constraints. No logic in the function explicitly checks for duplicate header fields or recombines them as a comma-separated list, thus it does not visibly implement the labeled conditions (e.g., C1) or actions (e.g., A1) from the spec constraints.",success,
15321,proxy_wstunnel_handler,The server MUST send an Upgrade header field in a 426 response to indicate the required protocol(s) (Section 7.8).,167,Fully Matches,"[{'C1': {'code': 'upgrade = apr_table_get(r->headers_in, ""Upgrade"");\nif (!upgrade || !ap_proxy_worker_can_upgrade(p, worker, upgrade, ""WebSocket"")) {\n    const char *worker_upgrade = *worker->s->upgrade ? worker->s->upgrade : ""WebSocket"";\n    apr_table_setn(r->err_headers_out, ""Connection"", ""Upgrade"");\n    apr_table_setn(r->err_headers_out, ""Upgrade"", worker_upgrade);\n    return HTTP_UPGRADE_REQUIRED;\n}', 'explanation': ""This segment checks for the Upgrade header in the incoming request and, if missing or not matching the expected protocol, sets the 'Connection: Upgrade' and 'Upgrade' headers in the error response before returning HTTP_UPGRADE_REQUIRED (426). This directly implements the RFC requirement that a 426 response must include an Upgrade header field indicating the required protocol.""}}]","The function clearly implements the RFC requirement by verifying the presence of a valid Upgrade header and, when the condition is not met, it constructs a 426 response that includes the necessary Upgrade header. Thus, the logic within the function directly satisfies the spec constraint.",success,
15321,proxy_wstunnel_handler,A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field.,27,Fully Matches,"[{'C1': {'code': 'upgrade = apr_table_get(r->headers_in, ""Upgrade"");\nif (!upgrade || !ap_proxy_worker_can_upgrade(p, worker, upgrade, ""WebSocket"")) {\n    const char *worker_upgrade = *worker->s->upgrade ? worker->s->upgrade : ""WebSocket"";\n    apr_table_setn(r->err_headers_out, ""Connection"", ""Upgrade"");\n    apr_table_setn(r->err_headers_out, ""Upgrade"", worker_upgrade);\n    return HTTP_UPGRADE_REQUIRED;\n}', 'explanation': ""This segment checks whether the client’s request includes an 'Upgrade' header that matches the expected protocol (WebSocket). If the header is missing or invalid, it prevents switching protocols and responds with HTTP_UPGRADE_REQUIRED, directly enforcing that the server must not switch to a protocol not requested by the client.""}}, {'A1': {'code': 'apr_table_setn(r->err_headers_out, ""Connection"", ""Upgrade"");\napr_table_setn(r->err_headers_out, ""Upgrade"", worker_upgrade);', 'explanation': 'This segment ensures that, when rejecting the upgrade, the server includes the appropriate Upgrade header field in its response. This complies with the RFC requirement to indicate acceptable protocols in error responses.'}}]","The function explicitly checks for an 'Upgrade' header and validates that it contains the expected protocol ('WebSocket'). In the absence or mismatch of this header, it returns a 426 (Upgrade Required) response and sets the necessary response headers. This implementation directly addresses the RFC specification that a server MUST NOT switch protocols unless they were indicated by the client in the Upgrade header.",success,
15321,proxy_wstunnel_handler,"A server that sends a 426 (Upgrade Required) response MUST send an Upgrade header field to indicate the acceptable protocols, in order of descending preference.",28,Fully Matches,"[{'C1': {'code': 'upgrade = apr_table_get(r->headers_in, ""Upgrade"");\nif (!upgrade || !ap_proxy_worker_can_upgrade(p, worker, upgrade, ""WebSocket"")) {\n    const char *worker_upgrade = *worker->s->upgrade ? worker->s->upgrade : ""WebSocket"";\n    apr_table_setn(r->err_headers_out, ""Connection"", ""Upgrade"");\n    apr_table_setn(r->err_headers_out, ""Upgrade"", worker_upgrade);\n    return HTTP_UPGRADE_REQUIRED;\n}', 'explanation': ""This segment checks for the presence and validity of the Upgrade header. If the header is missing or incorrect, it explicitly sets the 'Connection' and 'Upgrade' headers and returns a 426 (Upgrade Required) HTTP response. Providing the protocol (in this case, 'WebSocket') meets the requirement to indicate acceptable protocols, which, when singular, trivially satisfies the descending order requirement.""}}]","The function 'proxy_wstunnel_handler' directly implements the RFC requirement for a 426 response by checking for the Upgrade header and, if needed, setting the appropriate 'Connection' and 'Upgrade' headers before returning HTTP_UPGRADE_REQUIRED. This logic is self-contained within the function, thus it fully addresses the condition (C1) specified in the spec even though it deals with a single protocol value.",success,
15321,proxy_wstunnel_handler,"A server MAY send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.",29,Partially Matches,"[{'C1': {'code': 'if (!upgrade || !ap_proxy_worker_can_upgrade(p, worker, upgrade, ""WebSocket"")) {\n    const char *worker_upgrade = *worker->s->upgrade ? worker->s->upgrade : ""WebSocket"";\n    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02900)\n                  ""require upgrade for URL %s (Upgrade header is %s, expecting %s)"", \n                  url, upgrade ? upgrade : ""missing"", worker_upgrade);\n    apr_table_setn(r->err_headers_out, ""Connection"", ""Upgrade"");\n    apr_table_setn(r->err_headers_out, ""Upgrade"", worker_upgrade);\n    return HTTP_UPGRADE_REQUIRED;\n}', 'explanation': ""This block checks for an appropriate 'Upgrade' header and, if it is missing or incorrect, prepares a 426 (Upgrade Required) response by explicitly setting the 'Connection' and 'Upgrade' headers. This directly implements the RFC requirement that a 426 response MUST include an Upgrade header field.""}}]","The function inspects the incoming request for an Upgrade header and, when the header is missing or does not meet expectations, it sets the required headers and returns a 426 status. This fulfills the part of the spec dictating that a 426 (Upgrade Required) response MUST contain an Upgrade header field. However, the spec also mentions that in other responses a server MAY advertise upgrade support by sending an Upgrade header, and this function does not address that scenario. Therefore, the function partially matches the RFC specification.",success,
15332,proxy_fdpass_handler,"As a result, a server MUST NOT assume that two requests on the same connection are from the same user agent unless the connection is secured and specific to that agent.",221,Does Not Match,[],"The function 'proxy_fdpass_handler' is focused on passing file descriptors and handling socket operations, such as obtaining a socket referenced by a URL with the 'fd://' scheme, flushing via a flush provider, sending the socket to the client, and replacing the connection socket with a dummy to avoid unintended closure. It does not include any logic that addresses the specification constraint regarding not assuming that two requests on the same connection are from the same user agent unless the connection is secured and specific to that agent. There are no checks, conditions, or actions in this function related to verifying connection security or binding the connection to a specific user agent. Therefore, this function does not visibly implement any of the labeled conditions (such as C1) or actions (such as A1) required by the HTTP RFC specification provided.",success,
15335,ajp_handle_cping_cpong,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'rv = ajp_msg_get_uint8(msg, &result);\nif (rv != APR_SUCCESS) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01013)\n           ""ajp_handle_cping_cpong: invalid CPONG message"");\n    goto cleanup;\n}\nif (result != CMD_AJP13_CPONG) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01014)\n           ""ajp_handle_cping_cpong: awaited CPONG, received %d "",\n           result);\n    rv = APR_EGENERAL;\n    goto cleanup;\n}', 'explanation': 'This segment retrieves the protocol element (the CPONG response) and checks that its command byte matches the expected CPONG value, thereby interpreting it as defined by the RFC. However, the function does not attempt further recovery strategies if an invalid construct is encountered.'}}]","The function ajp_handle_cping_cpong sends a CPING, waits for a CPONG response, and then extracts and validates the command byte in the received message. This demonstrates an attempt to interpret a received protocol element as required by the RFC. Nonetheless, aside from the basic validation and error logging, it does not include additional error recovery or extended interpretation mechanisms described in the RFC specification. Thus, the code partially matches the spec constraints.",success,
15335,ajp_handle_cping_cpong,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function largely handles sending a CPING message and waiting for a CPONG reply by invoking helper functions (e.g., ajp_msg_serialize_cping) and performing simple error checking on the received byte. However, none of the logic within this function directly ensures that the generated protocol elements conform to the ABNF grammar as required by the RFC specification. In other words, while the function does construct and send a message via helper calls, it does not itself validate or enforce the grammar constraints mandated by the spec. Consequently, the function does not visibly address the labeled spec constraint that a sender MUST NOT generate protocol elements that do not match the ABNF grammar.",success,
15335,ajp_handle_cping_cpong,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function implements a CPING/CPONG exchange by serializing a CPING message, sending it out, and then verifying that the reply is a CPONG. However, it does not include any explicit logic within its body to check or enforce the RFC’s requirement that a sender must not generate protocol elements or syntax that are restricted to other roles. The function simply delegates serialization and validation to helper functions (e.g., ajp_msg_serialize_cping), and does not perform any role-based verification or grammar enforcement itself. Therefore, in isolation, this function does not visibly address the spec constraint regarding role-specific message generation.",success,
15337,proxy_fcgi_canon,"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",225,Does Not Match,[],"The RFC requires that a sender must not generate an ""https"" URI with an empty host identifier. However, the provided function (proxy_fcgi_canon) exclusively handles URIs with the ""fcgi:"" scheme and does not contain any logic that specifically verifies that the host portion is non-empty for an ""https"" URI. There is no direct check within this function for an empty host identifier in the context of https URIs, and any potential validations on the host are delegated to functions like ap_proxy_canon_netloc without specific handling for https. Therefore, the function does not visibly implement the required condition from the RFC.",success,
15337,proxy_fcgi_canon,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'port = def_port = ap_proxy_port_of_scheme(""fcgi"");\n...\nif (port != def_port)\n    apr_snprintf(sport, sizeof(sport), "":%d"", port);\nelse\n    sport[0] = \'\\0\';', 'explanation': 'The code retrieves the default port for the ""fcgi"" protocol and then checks if the parsed port differs from this default. If not, it leaves the port string empty, effectively interpreting the absence of an explicit port as the default port, which directly implements the RFC requirement.'}}]","The function 'proxy_fcgi_canon' correctly handles the scenario where no explicit port is given by setting the port to a default value based on the protocol. It then conditionally formats the host string based on whether the provided port matches the default. This logic directly addresses the specification that states a missing port may be interpreted as the default port, thereby fully matching the constraint.",success,
15337,proxy_fcgi_canon,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'A1': {'code': 'err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);\nif (err) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01059)\n                  ""error parsing URL %s: %s"", url, err);\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'The function checks for errors during URL parsing and returns a 400 (Bad Request) error if the netloc fails to canonicalize, which addresses part of the RFC requirement to reject invalid request-lines.'}}, {'C1': {'code': 'if (path == url && *ap_scan_vchar_obstext(path)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10414)\n                  ""To be forwarded path contains control characters or spaces"");\n    return HTTP_FORBIDDEN;\n}', 'explanation': 'The function inspects the request-target for disallowed characters (control characters or spaces). It then returns an error response (HTTP_FORBIDDEN) rather than performing a redirect or solely issuing a 400 error, which only partially meets the RFC condition.'}}]","The RFC specifies that recipients of an invalid request-line should respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with a properly encoded request-target. This function checks the URL for parsing errors and invalid characters (e.g., control characters or spaces), returning HTTP_BAD_REQUEST and HTTP_FORBIDDEN respectively. While it does enforce an error response on invalid input, it does not implement a 301 redirect, and in one case returns a 403 status code (Forbidden) instead of a 400 error. Therefore, the function only partially meets the RFC constraints as implemented solely within this function.",success,
15342,send_begin_request,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function constructs and sends a FastCGI begin request message without any internal checks or logic to ensure that it does not generate protocol elements or syntax alternatives that are exclusively reserved for participants in other roles. While the code sets the role to AP_FCGI_RESPONDER and fills in the necessary header and request body fields, it does not perform any role validation or any explicit enforcement of the RFC requirement that a sender must not generate elements meant for other roles. Thus, in isolation, this function does not visibly address the specified HTTP RFC constraints.",success,
15344,handle_headers,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'handle_headers' solely implements a state machine for parsing header termination sequences based on CR and LF characters. It does not contain any logic that checks or enforces the RFC requirement stating that a sender must not generate protocol elements or syntax alternatives reserved for other roles. There is no code that verifies the role-based generation of protocol elements. Therefore, no part of this function addresses the specified RFC constraint.",success,
15344,handle_headers,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Partially Matches,"[{'C1': {'code': ""else if (*itr == '\\n') {\n            switch (*state) {\n                 case HDR_STATE_GOT_LF:\n                     *state = HDR_STATE_DONE_WITH_HEADERS;\n                     break;\n\n                 case HDR_STATE_GOT_CR:\n                     *state = HDR_STATE_GOT_CRLF;\n                     break;\n\n                 case HDR_STATE_GOT_CRLFCR:\n                     *state = HDR_STATE_DONE_WITH_HEADERS;\n                     break;\n\n                 default:\n                     *state = HDR_STATE_GOT_LF;\n                     break;\n            }\n        }"", 'explanation': 'This segment of code attempts to recognize a single LF as a valid line terminator (and in some cases follows a CR) in accordance with the spec which permits a sole LF in place of CRLF. It demonstrates partial handling of the RFC requirement to accept single LF without strictly enforcing a CR before it.'}}]","The function implements a state machine that distinguishes between CR, LF, and CRLF sequences to determine the end of header fields. This is in line with part of the RFC specification that permits recognizing a single LF as a valid line terminator. However, the function does not fully implement all aspects of the spec such as ensuring bare CR characters are either flagged as invalid or replaced with a space, nor does it deal with encoding issues mentioned in the context. As a result, while the code addresses one key aspect (recognizing LF-based termination), it only partially matches the overall constraints of the RFC.",success,
15345,dispatch,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'if (!apr_table_get(r->subprocess_env, AP_TRUST_CGILIKE_CL_ENVVAR))\n    apr_table_unset(r->headers_out, ""Content-Length"");\napr_table_unset(r->headers_out, ""Transfer-Encoding"");', 'explanation': 'This snippet explicitly removes the Content-Length header (if not explicitly trusted) and always removes the Transfer-Encoding header. By doing so, the function ensures that the response will never include a Content-Length header alongside a Transfer-Encoding header, which fully satisfies the RFC requirement that a sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.'}}]","The function processes the FastCGI response headers and, once the headers are handled, it unsets both the Content-Length and Transfer-Encoding headers. This guarantees that if any Transfer-Encoding header had ever been present, no Content-Length header would be sent with it. The logic is self-contained within the function itself, and thus the RFC constraint is fully implemented in this function.",success,
15345,dispatch,A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content).,193,Partially Matches,"[{'C1': {'code': 'apr_table_unset(r->headers_out, ""Transfer-Encoding"");', 'explanation': 'The RFC requires that a Transfer-Encoding header MUST NOT be sent in responses with status code 1xx or 204. In the code, during header processing for the FastCGI response, the Transfer-Encoding header is unconditionally removed by calling apr_table_unset(r->headers_out, ""Transfer-Encoding""). This ensures that the header is not passed along. However, the removal is not conditional on checking for 1xx or 204 responses (or testing for allowed cases such as HEAD or 304) so the logic is applied uniformly rather than selectively as the RFC permits in some cases.'}}]","The function makes an effort to comply with the RFC requirement by unsetting the Transfer-Encoding header from the output headers. The code segment 'apr_table_unset(r->headers_out, ""Transfer-Encoding"");' ensures that the header is not sent in the response. However, because the code does not conditionally check for the response status codes (or methods) under which Transfer-Encoding is allowed or disallowed, it only partially matches the full intent of the specification. Dependencies or additional logic outside this function might handle further nuances, but within the context of this function alone, only a blanket removal is implemented.",success,
15345,dispatch,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'rv = get_data_full(conn, (char *) farray, AP_FCGI_HEADER_LEN);\n...\nap_fcgi_header_fields_from_array(&version, &type, &rid, &clen, &plen, farray);\nif (version != AP_FCGI_VERSION_1) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, ""Got bogus version %d"", (int)version);\n    rv = APR_EINVAL;\n    break;\n}\nif (rid != request_id) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, ""Got bogus rid %d, expected %d"", rid, request_id);\n    rv = APR_EINVAL;\n    break;\n}', 'explanation': 'The function reads the protocol header into a fixed‐size buffer and then validates critical fields (version and request id) to ensure that the incoming data meets minimal expected formats. This exemplifies a defensive parsing approach by verifying that the received protocol element at least conforms to expected header values.'}}]","The RFC specification advises that a recipient should be defensive when parsing protocol elements, making only marginal assumptions about conformity and size. The function does show defensive parsing by using fixed buffer sizes, chunked reading, and by checking header fields (such as version and request id) to catch mismatches. However, it does not fully implement all aspects of the spec (for example, it does not perform an exhaustive check against an ABNF grammar nor does it dynamically handle all unreasonable lengths beyond using the predetermined buffer). In this sense, while parts of the defensive approach are clearly implemented within the function, the full intent of the RFC is only partially addressed.",success,
15345,dispatch,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,44,Partially Matches,"[{'A1': {'code': 'if (!apr_table_get(r->subprocess_env, AP_TRUST_CGILIKE_CL_ENVVAR))\n    apr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'This segment removes the Content-Length header from the outgoing headers when an environment flag is not set. This action is related to the RFC requirement that a Content-Length header should not be sent unless its value exactly matches the actual content length. However, the function does not compute or verify the actual length (for example, in a 304 response) against what would have been sent in a 200 response, so it only partially addresses the constraint.'}}, {'C1': {'code': ""if (status == HTTP_NOT_MODIFIED || status == HTTP_PRECONDITION_FAILED) {\n    /* Special 'status' cases handled:\n     * 1) HTTP 304 response MUST NOT contain a message-body, ignore it.\n     * 2) HTTP 412 response.\n     * ...\n     */\n    ignore_body = 1;\n}"", 'explanation': 'This code checks for a 304 (Not Modified) response and accordingly sets a flag to ignore the body. This demonstrates an awareness of the special handling required by RFC for 304 responses; nevertheless, it does not enforce that any present Content-Length header properly reflects the expected body length. Thus, it again only partially addresses the RFC constraint.'}}]","The function contains logic that is related to the RFC on Content-Length header usage. It unsets the Content-Length header under certain conditions and marks responses with HTTP_NOT_MODIFIED to ignore the body, which aligns with the overall intent of the RFC conditions. However, the function does not implement the verification that the Content-Length (if present) exactly equals the number of octets that would have been sent in a 200 response, as required by the RFC. Therefore, while there are measures that partially address the RFC's conditions, the full logic mandated by the specification is not completely implemented within this function.",success,
15345,dispatch,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Does Not Match,[],"The specification requires that the server must not send a Content-Length header in responses with status codes 1xx (Informational) or 204 (No Content). In the code function, while there is a line that unsets the ""Content-Length"" header (using apr_table_unset(r->headers_out, ""Content-Length"")), this action is done unconditionally based on the absence of an environment variable (AP_TRUST_CGILIKE_CL_ENVVAR) during FastCGI header handling. There is no logic that checks the response status code (e.g., 1xx or 204) before removing the header. Therefore, the function does not visibly implement the specific RFC requirement for these status codes within its own code body.",success,
15346,fcgi_do_request,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (rv != APR_SUCCESS) {\n    ...\n    conn->close = 1;\n    return HTTP_SERVICE_UNAVAILABLE;\n}\n\n... (similar usage in send_environment failure and after dispatch error logging)', 'explanation': ""The RFC permits a client, server, or proxy to close the transport connection at any time. In the function, when sending the begin request or the environment fails—or when an error is detected during dispatch—the code sets 'conn->close = 1', explicitly signaling that the connection should be closed. This directly addresses the RFC's allowance to close the connection when necessary.""}}, {'A1': {'code': 'if (r->connection->aborted) {\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, rv, r,\n                  ""The client aborted the connection."");\n    conn->close = 1;\n    return OK;\n}', 'explanation': ""The function monitors for a closure signal from the client by checking if 'r->connection->aborted'. Upon detecting this, it logs the event and sets 'conn->close = 1'. This implements the recommended behavior to gracefully handle a closure signal, as suggested by the RFC context.""}}]","The RFC specification allows the transport connection to be closed at any time by a client, server, or proxy. The provided function includes logic to set the connection's close flag ('conn->close = 1') when errors occur (during request initiation or environment transmission) or when a client abort is detected. While these checks ensure that the function reacts by closing the connection under error conditions and client aborts, it does not cover all potential graceful close scenarios (such as sustained monitoring of idle connections). Thus, the function partially implements the RFC specification by addressing some, but not all, aspects of the connection closure requirements within its own logic.",success,
15346,fcgi_do_request,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function fcgi_do_request does not include any logic that directly enforces the RFC requirement preventing a sender from generating protocol elements or syntax alternatives reserved for other roles. The function primarily orchestrates sending a FastCGI begin request, passing environment parameters, and dispatching the request, but it does not contain any condition checks or constraints that ensure that only the protocol elements associated with the sender's role are generated. Instead, it delegates work to helper functions (such as send_begin_request, send_environment, dispatch), whose implementation details are not part of this function. Therefore, based solely on the visible code in fcgi_do_request, it does not address any of the labeled constraints (like C1 or A1) from the spec.",success,
15347,proxy_fcgi_handler,A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 requests (or later minor revisions); such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response.,196,Partially Matches,[],"The specification requires that a client must not send a request containing a Transfer‐Encoding header unless it is certain that the server supports HTTP/1.1. In this function, there is some handling of the Transfer-Encoding header – for instance, if a Transfer-Encoding header is present (captured in 'old_te'), the code later sometimes removes it when a Content-Length header is determined (e.g. in the block that checks if the input brigade ends with EOS). However, the function does not perform any explicit check to determine whether the backend server supports HTTP/1.1 before deciding to allow a request to be sent with a Transfer-Encoding header. In one branch (the “streaming is possible using T-E: chunked” branch), the header may be preserved without verifying server HTTP version. Because the function only partially addresses the RFC’s requirement by conditionally unsetting Transfer-Encoding without verifying protocol support, the implementation is only a partial match to the RFC constraint.",success,
15347,proxy_fcgi_handler,"A sender MUST NOT apply the chunked transfer coding more than once to a message body (i.e., chunking an already chunked message is not allowed).",188,Partially Matches,"[{'C1': {'code': 'const char *old_te = apr_table_get(r->headers_in, ""Transfer-Encoding"");\n...\nif (old_te) {\n    apr_table_unset(r->headers_in, ""Content-Length"");\n}\n...\nif (APR_BRIGADE_EMPTY(input_brigade)\n        && APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(input_brigade))) {\n    if (old_cl || old_te || input_bytes) {\n        apr_table_setn(r->headers_in, ""Content-Length"",\n                        apr_off_t_toa(p, input_bytes));\n        if (old_te) {\n            apr_table_unset(r->headers_in, ""Transfer-Encoding"");\n        }\n    }\n}', 'explanation': ""The function checks whether a Transfer-Encoding header already exists and then unsets it before setting the Content-Length header. This is an attempt to avoid applying chunked transfer coding more than once, addressing the RFC requirement in part within this function's scope.""}}]","The code function partially addresses the RFC specification by detecting any existing Transfer-Encoding header (thereby implying that chunked encoding might have already been applied) and unsetting it to prevent a duplicate application of chunked transfer coding. However, the function does not fully implement all aspects of the RFC within its own logic, as some related processing (such as actually setting the appropriate Transfer-Encoding in a controlled fashion) appears to be delegated to other functions (for example, fcgi_do_request) or handled elsewhere in the system. Thus, it only partially matches the requirement.",success,
15347,proxy_fcgi_handler,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'const char *old_te = apr_table_get(r->headers_in, ""Transfer-Encoding"");\nif (old_te) {\n    apr_table_unset(r->headers_in, ""Content-Length"");\n}\n...\nif (!APR_BRIGADE_EMPTY(input_brigade)\n        && APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(input_brigade))) {\n    if (old_cl || old_te || input_bytes) {\n        apr_table_setn(r->headers_in, ""Content-Length"",\n                       apr_off_t_toa(p, input_bytes));\n        if (old_te) {\n            apr_table_unset(r->headers_in, ""Transfer-Encoding"");\n        }\n    }\n}', 'explanation': ""The code checks for the presence of a 'Transfer-Encoding' header and, if found, explicitly unsets the 'Content-Length' header. Later, when setting the Content-Length based on the prefetched input, it again removes the Transfer-Encoding header if it was originally present. This ensures the outgoing message does not include both headers simultaneously, thereby satisfying the RFC constraint.""}}]","Within its body, the function directly inspects the request headers and takes explicit actions to ensure that if 'Transfer-Encoding' is present, 'Content-Length' is removed before the message is sent. This direct handling fully meets the RFC specification requiring that a sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.",success,
15347,proxy_fcgi_handler,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'C1': {'code': 'const char *old_te = apr_table_get(r->headers_in, ""Transfer-Encoding"");\nif (old_te) {\n    apr_table_unset(r->headers_in, ""Content-Length"");\n}\n...\nif (!APR_BRIGADE_EMPTY(input_brigade)\n        && APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(input_brigade))) {\n    if (old_cl || old_te || input_bytes) {\n        apr_table_setn(r->headers_in, ""Content-Length"",\n                       apr_off_t_toa(p, input_bytes));\n        if (old_te) {\n            apr_table_unset(r->headers_in, ""Transfer-Encoding"");\n        }\n    }\n}', 'explanation': 'The function unsets an incoming Content-Length header if a Transfer-Encoding header is present and later resets the Content-Length header based on the actual read size of the body. This logic partially addresses the RFC requirement to not forward a message with an incorrect Content-Length value, by ensuring that when possible the header is replaced with a computed, presumably correct, value. However, not all edge cases (such as handling of duplicate values as per the exception in the specification) are explicitly managed.'}}]","The function includes logic that detects conditions which might lead to an incorrect Content-Length (for example, when Transfer-Encoding is present) and then replaces the header with one computed from the actual body size. This shows an attempt to avoid forwarding an incorrect Content-Length header value. However, the implementation does not fully cover all aspects of the RFC specification—especially regarding the handling of cases like repeated identical Content-Length values—so it only partially matches the required constraint.",success,
15353,proxy_ajp_canon,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function focuses on canonicalizing an AJP URL by validating its scheme, splitting the URL into components, and ensuring that the path and query string do not contain illegal characters. However, it does not contain any explicit logic that addresses the spec requirement: 'a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles.' There is no check or restriction in this function that verifies the role of the sender or restricts the generation of protocol elements based on participant roles. Therefore, from the function_body alone, there is no visible implementation of the condition or action defined in the spec constraint, and the function does not attempt to implement this particular aspect of the RFC.",success,
15353,proxy_ajp_canon,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (path == url && *ap_scan_vchar_obstext(path)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10418)\n                  ""To be forwarded path contains control ""\n                  ""characters or spaces"");\n    return HTTP_FORBIDDEN;\n}\nif (search && *ap_scan_vchar_obstext(search)) {\n     ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10406)\n                   ""To be forwarded query string contains control ""\n                   ""characters or spaces"");\n     return HTTP_FORBIDDEN;\n}', 'explanation': 'These code segments demonstrate defensive parsing by checking both the URL path and query string for control characters or spaces, thereby attempting to ensure that the protocol element conforms to a minimal set of expectations as suggested in the RFC.'}}, {'A1': {'code': 'err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);\nif (err) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00867) ""error parsing URL %s: %s"",\n                  url, err);\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'This segment validates the URL’s network location part calling an external canonicalization routine and returns a bad request error if the parsing fails, which supports defensive behavior.'}}]","The function attempts to implement the RFC’s guidance that a recipient should parse protocol elements defensively. It checks for the presence of control characters in key URL components and validates the network location portion by invoking a dedicated parsing routine, returning errors when expectations are not met. However, while these actions contribute to defensive parsing, aspects such as comprehensive ABNF compliance or managing dynamic buffer sizing are not fully implemented within this function itself. Consequently, the function only partially meets the overall specification.",success,
15353,proxy_ajp_canon,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'port = def_port = ap_proxy_port_of_scheme(""ajp"");\n...\nif (port != def_port)\n     apr_snprintf(sport, sizeof(sport), "":%d"", port);\nelse\n     sport[0] = \'\\0\';', 'explanation': ""This segment explicitly retrieves the default port for the 'ajp' scheme and then checks whether the provided port differs from the default. If no port is provided (i.e., port equals def_port), it omits the port in the constructed URL. This implements the RFC specification where, if a port is not provided, the recipient may use the default port.""}}]","The function retrieves the default port using ap_proxy_port_of_scheme and later compares the extracted port with the default. By omitting the port from the final URL when it equals the default, the function visibly implements the RFC requirement that a missing port be interpreted as the default port for the protocol. Thus, the function fully addresses the labeled condition from the RFC.",success,
15353,proxy_ajp_canon,"Specifications for newly defined fields SHOULD limit their values to visible US-ASCII octets (VCHAR), SP, and HTAB",2,Partially Matches,"[{'C1': {'code': 'if (path == url && *ap_scan_vchar_obstext(path)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10418)\n                  ""To be forwarded path contains control ""\n                  ""characters or spaces"");\n    return HTTP_FORBIDDEN;\n}', 'explanation': 'This segment checks the path for control characters (or spaces) and rejects the request if any are found. It partially implements the RFC requirement by enforcing that field values do not include disallowed characters; however, it does not perform trimming of leading or trailing whitespace as described in the spec context, nor does it explicitly allow SP or HTAB if that is the intention.'}}, {'C2': {'code': 'if (search && *ap_scan_vchar_obstext(search)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10406)\n                  ""To be forwarded query string contains control ""\n                  ""characters or spaces"");\n    return HTTP_FORBIDDEN;\n}', 'explanation': 'This segment verifies that the query string (if present) does not contain any control characters (or spaces) and rejects it if such characters are found. Like the check on the path, it partially addresses the RFC constraint by validating allowed characters but lacks additional handling (e.g., whitespace trimming) as required by the spec.'}}]","The function inspects the URL's path and query string by invoking a scan (ap_scan_vchar_obstext) to detect control characters or spaces and returns an error if any are found. This approach attempts to enforce the constraint that field values contain only a limited set of characters. However, it does not implement the complete spec behavior—specifically, it does not trim leading/trailing whitespace when allowed and rejects spaces outright, even though SP is permitted per the RFC specification for newly defined fields. Therefore, while parts of the RFC are addressed within the function, it only partially meets the overall constraints.",success,
15353,proxy_ajp_canon,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'C1': {'code': 'if (err) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00867) ""error parsing URL %s: %s"",\n                  url, err);\n    return HTTP_BAD_REQUEST;\n}\n\n...\n\nif (path == url && *ap_scan_vchar_obstext(path)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10418)\n                  ""To be forwarded path contains control characters or spaces"");\n    return HTTP_FORBIDDEN;\n}\n\nif (search && *ap_scan_vchar_obstext(search)) {\n     ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10406)\n                   ""To be forwarded query string contains control characters or spaces"");\n     return HTTP_FORBIDDEN;\n}', 'explanation': 'The function validates the request-target by checking for control characters or whitespace and returns an error (HTTP_BAD_REQUEST or HTTP_FORBIDDEN) if issues are found. This addresses the spec’s requirement that invalid request-lines be rejected. However, it does not offer a 301 redirect with a properly encoded target, as the RFC also permits.'}}, {'A1': {'code': 'path = ap_proxy_canonenc_ex(r->pool, url, strlen(url), enc_path, flags, r->proxyreq);\nif (!path) {\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'The function attempts to canonicalize and encode the request-target when necessary, which is related to ensuring proper encoding as required by the spec. This shows an effort to produce a correctly encoded target, though it does not implement the full redirection behavior (301) mandated by the RFC.'}}]","The function performs syntactic checks on the URL by breaking it into components and verifying that the request-target does not contain disallowed characters such as spaces or control characters. It returns an error (HTTP_BAD_REQUEST or HTTP_FORBIDDEN) if these rules are violated and attempts canonicalization of the target. This partly aligns with the RFC, which insists on responding with a 400 error or a 301 redirect with proper encoding. The lack of any redirect (301) implementation means the function only partially meets the specification.",success,
15355,get_content_length,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (clp && !ap_parse_strict_length(&len, clp)) {\n    len = -1; /* parse error */\n}', 'explanation': 'This segment shows that the function attempts to interpret the Content-Length header strictly, setting the length to -1 if the header does not conform, which is an effort to adhere to the specified interpretation of a protocol element.'}}]","The RFC requires that a recipient must interpret a protocol element according to its defined semantics and possibly recover from invalid constructs. The function visible here extracts and strictly parses the Content-Length header, which partially fulfills the RFC requirement by validating a received header field. However, it does not handle other aspects such as interpreting extensions or more complex error recovery, hence it only partially matches the overall RFC mandate.",success,
15355,get_content_length,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,[],"The spec requires a defensive parsing of a received protocol element with minimal expectations regarding its ABNF grammar conformance and length. The function does make an attempt at defensive parsing by retrieving the Content-Length header and using a strict parser (ap_parse_strict_length) to validate its contents, returning -1 if the parsing fails. This defensive error handling shows an attempt to check the element's validity. However, the function does not address other aspects of the spec—for example, it does not perform any checks to ensure that the header value fits within a “reasonable buffer size” or perform a comprehensive ABNF validation itself. Since only part of the specification is implemented within this function, it is considered a partial match.",success,
15356,ap_proxy_ajp_request,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC specification requires that a sender must not generate protocol elements that deviate from the ABNF grammar rules. In the provided function, although protocol messages (headers and data chunks) are sent using functions such as ajp_send_header, ajp_send_data_msg, and ajp_parse_type, there is no explicit logic within this function that validates or constructs these messages strictly according to the ABNF grammar. The function delegates message construction and parsing to helper functions without performing direct checks against the ABNF rules. Thus, in isolation, this function does not visibly address the constraint.",success,
15356,ap_proxy_ajp_request,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'A1': {'code': 'if (status != APR_SUCCESS) {\n    conn->close = 1;\n    ...\n}\n\n... \n\nif (apr_table_get(r->subprocess_env, ""proxy-nokeepalive"")) {\n    conn->close = 1;\n}', 'explanation': ""Throughout the function, in various error and exceptional conditions (e.g., failure to send headers, failure in data flattening, client connection abort), the code explicitly sets 'conn->close = 1'. This indicates that the connection is to be closed, which is in keeping with the RFC’s allowance that a client, server, or proxy may close the connection at any time.""}}]","The RFC specification states that a client, server, or proxy MAY close the transport connection at any time. In the function, there are multiple points where 'conn->close' is set to 1 in response to errors (and at the end if the 'proxy-nokeepalive' flag is set). These code segments show that the function acknowledges the need to close the connection when certain conditions arise, thereby partially addressing the RFC. However, while the function does implement closing the connection on error conditions, it does not fully implement the graceful close mechanism described in the broader RFC context (such as proactively monitoring for a closure signal for timeouts and performing a graceful shutdown under normal operation) solely within this function. Therefore, the function only partially matches the specification.",success,
15356,ap_proxy_ajp_request,"If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.",202,Partially Matches,"[{'C1': {'code': 'if (status == AJP_EOVERFLOW)\n    return HTTP_BAD_REQUEST;\n...\nelse if (content_length > 0) {\n    ap_log_rerror(... ""read zero bytes, expecting"" ...);\n    conn->close = 1;\n    return HTTP_BAD_REQUEST;\n}\n...\nif (r->connection->aborted) {\n    if (!headers_sent) {\n        r->status = HTTP_BAD_REQUEST;\n    }\n    client_failed = 1;\n}', 'explanation': ""These segments check for unrecoverable errors in the request (e.g. when the client sends an invalid or incomplete body) and return HTTP_BAD_REQUEST while also setting 'conn->close = 1' to close the connection, which reflects part of the specified RFC behavior.""}}, {'A1': {'code': 'conn->close = 1;', 'explanation': 'Throughout the function, on detection of various errors in the request, the connection is marked to be closed, meeting the requirement to close the connection after an unrecoverable error in the request.'}}]","The function attempts to implement the RFC requirement concerning unrecoverable errors in a request message by checking for error conditions such as invalid Content-Length, AJP_EOVERFLOW, or a client abort. In these cases, it returns HTTP_BAD_REQUEST and sets a flag to close the connection. However, not all error cases (or all aspects of the RFC) are handled exclusively by this function; some paths return other error codes and depend on further external logic. Therefore, the implementation is only a partial match to the RFC requirement.",success,
15356,ap_proxy_ajp_request,"If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value).",201,Partially Matches,"[{'C5': {'code': 'tenc = apr_table_get(r->headers_in, ""Transfer-Encoding"");\n\nif (tenc) {\n    if (ap_cstr_casecmp(tenc, ""chunked"") == 0) {\n        /* The AJP protocol does not want body data yet */\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00870)\n                      ""request is chunked"");\n    } else {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10396)\n                      ""%s Transfer-Encoding is not supported"",\n                      tenc);\n        conn->close = 1;\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n} else {\n    /* Get client provided Content-Length header */\n    content_length = get_content_length(r);\n    if (content_length < 0) {\n        status = APR_EINVAL;\n    } else {\n        status = ap_get_brigade(r->input_filters, input_brigade,\n                                AP_MODE_READBYTES, APR_BLOCK_READ,\n                                maxsize - AJP_HEADER_SZ);\n    }\n    ...\n    else if (content_length > 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00877)\n                      ""read zero bytes, expecting""\n                      "" %"" APR_OFF_T_FMT "" bytes"",\n                      content_length);\n        conn->close = 1;\n        apr_brigade_destroy(input_brigade);\n        return HTTP_BAD_REQUEST;\n    }\n}', 'explanation': 'This section checks for the presence of Transfer-Encoding. If absent, it retrieves and validates the Content-Length, treating negative values (invalid header) as an error by eventually returning HTTP_BAD_REQUEST. However, it does not implement the detailed comma‑separated list parsing required by the RFC exception.'}}]","The function contains logic to handle cases when there is no Transfer-Encoding header by reading and validating the Content-Length header (e.g., checking for negative values and erroring out when expected body data is not received). This matches part of the RFC spec condition (labeled here as C5) that requires the message framing to be treated as an unrecoverable error if Content-Length is invalid. However, the RFC also specifies an exception if the header can be parsed as a comma-separated list with identical valid values, and this function does not address that exception. Therefore, while some aspects of the spec are handled, the implementation is only partial in relation to the complete spec constraint.",success,
15356,ap_proxy_ajp_request,"A server or client that receives an HTTP/1.0 message containing a Transfer-Encoding header field MUST treat the message as if the framing is faulty, even if a Content-Length is present, and close the connection after processing the message.",199,Partially Matches,"[{'C1': {'code': 'tenc = apr_table_get(r->headers_in, ""Transfer-Encoding"");\nif (tenc) {\n    if (ap_cstr_casecmp(tenc, ""chunked"") == 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00870)\n                      ""request is chunked"");\n    }\n    else {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10396)\n                      ""%s Transfer-Encoding is not supported"",\n                      tenc);\n        conn->close = 1;\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n}', 'explanation': 'The code checks for the Transfer-Encoding header. In the case where the encoding is not ""chunked"", it logs an error and closes the connection by setting conn->close to 1, which partly implements the RFC requirement. However, when the encoding is ""chunked"" (which is particularly relevant for HTTP/1.0 messages where Transfer-Encoding is not expected), the function only logs the scenario without explicitly enforcing connection closure as mandated by the spec.'}}]","The RFC specification requires that an HTTP/1.0 message containing a Transfer-Encoding header be treated as having faulty framing and that the connection be closed after processing, irrespective of a provided Content-Length. While this function does detect the presence of a Transfer-Encoding header—and in the case of an unsupported encoding it aborts the connection—it does not clearly distinguish HTTP/1.0 messages nor does it enforce connection closure for messages declaring a ""chunked"" encoding. Thus, the function only partially meets the RFC requirement within its own logic.",success,
15356,ap_proxy_ajp_request,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'tenc = apr_table_get(r->headers_in, ""Transfer-Encoding"");\n    if (tenc) {\n        if (ap_cstr_casecmp(tenc, ""chunked"") == 0) {\n            /* The AJP protocol does not want body data yet */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00870)\n                          ""request is chunked"");\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10396)\n                          ""%s Transfer-Encoding is not supported"",\n                          tenc);\n            conn->close = 1;\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n    }\n    else {\n        /* Get client provided Content-Length header */\n        content_length = get_content_length(r);\n        if (content_length < 0) {\n            status = APR_EINVAL;\n        }\n        else {\n            status = ap_get_brigade(r->input_filters, input_brigade,\n                                    AP_MODE_READBYTES, APR_BLOCK_READ,\n                                    maxsize - AJP_HEADER_SZ);\n        }\n        ...\n    }', 'explanation': ""The function first checks if a Transfer-Encoding header exists. If it does, and specifically if it indicates 'chunked', the code handles it without obtaining or sending a Content-Length header. In the absence of Transfer-Encoding, it retrieves Content-Length. This approach ensures that when Transfer-Encoding is present, no Content-Length header is processed/sent, which complies with the RFC requirement.""}}]","The specified RFC requires that a sender must not include a Content-Length header in messages that contain a Transfer-Encoding header. Within this function, the code inspects the incoming headers for Transfer-Encoding and, if found, avoids reading and processing a Content-Length header. This internal logic fully implements the constraint within the function itself, satisfying the specification.",success,
15356,ap_proxy_ajp_request,The server generating a 401 response MUST send a WWW-Authenticate header field (Section 11.6.1) containing at least one challenge applicable to the target resource.,162,Partially Matches,"[{'C1': {'code': 'else if ((r->status == 401) && conf->error_override) {\n    const char *buf;\n    const char *wa = ""WWW-Authenticate"";\n    if ((buf = apr_table_get(r->headers_out, wa))) {\n        apr_table_set(r->err_headers_out, wa, buf);\n    } else {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00885)\n                      ""ap_proxy_ajp_request: origin server sent 401 without WWW-Authenticate header"");\n    }\n}', 'explanation': 'This code checks if the response status is 401 and if error override is enabled. It then attempts to retrieve the WWW-Authenticate header from the outbound headers and copies it to the error headers, thus addressing the need to include a challenge header in a 401 response. However, if the header is missing, it only logs an error rather than generating the header, so the implementation is partial.'}}]","The function partially implements the RFC requirement. It contains logic to check for a 401 status and to forward an existing WWW-Authenticate header, which is part of the mandated behavior. Nevertheless, if the header is not present, the function does not create one—it merely logs that the header is missing. This means the function only partially addresses the RFC's requirement that a 401 response MUST include a valid WWW-Authenticate header.",success,
15356,ap_proxy_ajp_request,"A sender MUST NOT apply the chunked transfer coding more than once to a message body (i.e., chunking an already chunked message is not allowed).",188,Partially Matches,"[{'C1': {'code': 'tenc = apr_table_get(r->headers_in, ""Transfer-Encoding"");\n    if (tenc) {\n        if (ap_cstr_casecmp(tenc, ""chunked"") == 0) {\n            /* The AJP protocol does not want body data yet */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00870) ""request is chunked"");\n        } else {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10396) ""%s Transfer-Encoding is not supported"", tenc);\n            conn->close = 1;\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n    } else {\n        // process content length and read body\n    }', 'explanation': 'This segment checks if the incoming request already uses \'chunked\' Transfer-Encoding. When the header is present and equals ""chunked"", the code logs that the request is chunked and does not proceed to re-read or re-chunk the request body, thereby avoiding a double application of chunked encoding.'}}]","The provided function inspects the 'Transfer-Encoding' header and, if it finds that the request is already chunked, it avoids attempting to reapply chunked transfer coding. This addresses the specific requirement from the RFC that a sender must not apply the chunked transfer coding more than once. However, the function does not address other parts of the spec context (such as applying chunked encoding as the final coding when other transfer codings are applied), so only part of the specification is handled within this function itself.",success,
15361,ajp_ilink_receive,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'hlen = msg->header_len;\n\nstatus = ilink_read(sock, msg->buf, hlen);\n\nif (status != APR_SUCCESS) {\n    ap_log_error(APLOG_MARK, APLOG_ERR, status, NULL, APLOGNO(01030)\n                 ""ajp_ilink_receive() can\'t receive header"");\n    return (APR_STATUS_IS_TIMEUP(status) ? APR_TIMEUP : AJP_ENO_HEADER);\n}\n\nstatus = ajp_msg_check_header(msg, &blen);\n\nif (status != APR_SUCCESS) {\n    ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL, APLOGNO(01031)\n                 ""ajp_ilink_receive() received bad header"");\n    return AJP_EBAD_HEADER;\n}\n\nstatus = ilink_read(sock, msg->buf + hlen, blen);\n\nif (status != APR_SUCCESS) {\n    ap_log_error(APLOG_MARK, APLOG_ERR, status, NULL, APLOGNO(01032)\n                 ""ajp_ilink_receive() error while receiving message body ""\n                 ""of length %"" APR_SIZE_T_FMT,\n                 hlen);\n    return AJP_EBAD_MESSAGE;\n}', 'explanation': ""This segment demonstrates defensive parsing by reading a fixed header length, validating it via ajp_msg_check_header, and handling errors appropriately through error logging and early returns. It addresses the need for defensive processing as suggested by the spec, though it does not cover all aspects such as dynamically ensuring a buffer's size is 'reasonable' as the spec context describes.""}}]","The function ajp_ilink_receive performs defensive parsing of the received protocol element by reading the header, validating it via a helper (ajp_msg_check_header), and then reading the message body. It includes appropriate error checking and logging when issues are encountered with the header or body. However, it assumes a fixed header length (msg->header_len) and does not dynamically verify that the entire element fits within a 'reasonable' buffer size, nor does it perform thorough schema/grammar validation against an ABNF form. Therefore, while it partially meets the defensive processing requirement (C1), it does not fully implement all aspects of the spec as required.",success,
15382,alias_match_servlet,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Fully Matches,"[{'C1': {'code': ""if (map[map_pos - 1] == '/') {\n    /* Collapse ///// sequences to / */\n    if (uri[uri_pos] == '/') {\n        do {\n            uri_pos++;\n        } while (uri[uri_pos] == '/');\n        continue;\n    }\n    ..."", 'explanation': ""This segment collapses multiple consecutive slashes, ensuring that variations such as '///' are normalized to a single '/'. This addresses the requirement that two HTTP URIs equivalent after normalization identify the same resource.""}}, {'A1': {'code': ""if (uri[uri_pos] == '.') {\n    /* Remove /./ segments */\n    if (uri[uri_pos + 1] == '/' || uri[uri_pos + 1] == ';' || uri[uri_pos + 1] == '\\0') {\n        uri_pos++;\n        if (uri[uri_pos] == '/') {\n            uri_pos++;\n        }\n        continue;\n    }\n\n    /* Remove /xx/../ segments */\n    if (uri[uri_pos + 1] == '.' && (uri[uri_pos + 2] == '/' || uri[uri_pos + 2] == ';' || uri[uri_pos + 2] == '\\0')) {\n        ...\n    }\n}"", 'explanation': 'This code handles both /./ and /../ segments: the /./ segments are simply removed, and the /../ segments cause the previous segment to be removed from the normalized path. This normalization is central to ensuring URI equivalence post-normalization.'}}]","The alias_match_servlet function implements normalization logic that is in direct agreement with the HTTP RFC specification. It removes redundant path parameters (like ';foo=bar'), collapses duplicate slashes, and eliminates /./ and /../ sequences. By doing this solely within the function, it ensures that two URIs which are equivalent after these normalization processes can be treated as identifying the same resource. Therefore, the function fully implements the relevant spec constraints.",success,
15391,proxy_needsdomain,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Fully Matches,"[{'C1': {'code': 'if (!r->parsed_uri.hostname)\n    return DECLINED;', 'explanation': ""This condition checks that the hostname is present. If the hostname is missing (empty), the function returns early (DECLINED) and does not generate a new HTTP URI, fulfilling the spec requirement that a sender MUST NOT generate an 'http' URI with an empty host identifier.""}}]","The function explicitly verifies the presence of the hostname in the parsed URI. The check 'if (!r->parsed_uri.hostname)' prevents the generation of a new URI when the host identifier is empty, which directly implements the specified RFC requirement. No additional logic from dependencies is used, and the check is fully contained in the function, thereby satisfying the constraint.",success,
15391,proxy_needsdomain,"If the server has a preferred choice, the server SHOULD generate a Location header field containing a preferred choice's URI reference",153,Fully Matches,"[{'C1': {'code': 'if (strchr(r->parsed_uri.hostname, \'.\') != NULL /* has domain, or IPv4 literal */\n || strchr(r->parsed_uri.hostname, \':\') != NULL /* IPv6 literal */\n || ap_cstr_casecmp(r->parsed_uri.hostname, ""localhost"") == 0)\n    return DECLINED;', 'explanation': 'This check ensures that only requests with a hostname missing a full domain are processed. In effect, it identifies the condition under which the server has a preferred (or missing) choice that needs correction.'}}, {'A1': {'code': 'r->parsed_uri.hostname = apr_pstrcat(r->pool, r->parsed_uri.hostname, domain, NULL);\nnuri = apr_uri_unparse(r->pool, &r->parsed_uri, APR_URI_UNP_REVEALPASSWORD);\napr_table_setn(r->headers_out, ""Location"", nuri);', 'explanation': ""This segment shows that the function reconstructs the request URI with the appended domain and then explicitly generates a Location header that contains the preferred choice's URI reference, fulfilling the RFC requirement.""}}]","The provided function inspects incoming GET requests for a missing domain in the hostname. When the hostname lacks a dot (or is not an IP literal/""localhost""), it appends the provided domain, reassembles the full URI, and sets the Location header accordingly. This directly implements the RFC specification stating that if the server has a preferred choice, it SHOULD generate a Location header field containing the preferred URI reference. Thus, the function’s internal logic fully addresses both the necessary condition (C1) and corresponding action (A1) of the spec.",success,
15391,proxy_needsdomain,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,155,Fully Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Location"", nuri);\nreturn HTTP_MOVED_PERMANENTLY;', 'explanation': 'This code segment constructs a new URI (with the updated hostname) and sets it in the Location header, then returns a 301 (Moved Permanently) response. This directly fulfills the RFC requirement that the server SHOULD generate a Location header field in the response containing a preferred URI for the new resource.'}}]","The function first verifies that the request is of the correct type (a GET via a proxy with a hostname) and then appends the missing domain to create a new URI. It then uses apr_table_setn to set the Location header and returns HTTP_MOVED_PERMANENTLY (301), which is exactly what the RFC specifies. All necessary logic for generating and returning the correct Location header is present within the function, hence it fully meets the spec for the Location header implementation.",success,
15391,proxy_needsdomain,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Location"", nuri);', 'explanation': ""This line sets the Location header in the response with the reassembled URI, directly fulfilling the spec's requirement to generate a Location header field containing a URI reference for the different URI.""}}]","The provided function modifies the request’s hostname by appending a domain, reassembles the URI, and then explicitly sets the Location header in the response. This directly addresses the RFC specification that states the server SHOULD generate a Location header containing a URI reference for the different URI. Although additional aspects of the redirect (such as the specific status code or response content) are handled outside this scope, the code within the function fully implements the action of generating the Location header as required.",success,
15391,proxy_needsdomain,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,160,Partially Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Location"", nuri);', 'explanation': 'This line sets the Location header in the response with the newly constructed URI, addressing the RFC requirement to include a preferred URI reference in a permanent redirect response.'}}]","The code function constructs a new URI by appending the missing domain and explicitly sets the Location header in the response, which corresponds to the RFC's requirement. However, it returns HTTP_MOVED_PERMANENTLY (typically corresponding to the 301 status code) instead of a 308 Permanent Redirect. This discrepancy, along with the fact that other parts of the RFC (for example, outlining the conditions under which a user-agent may use the Location header) are not fully handled in this function, means that the function only partially matches the specified HTTP RFC.",success,
15391,proxy_needsdomain,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Location"", nuri);', 'explanation': ""The function reconstructs the URI (by appending the domain to the hostname) and then explicitly sets the 'Location' header in the response using apr_table_setn. This directly addresses the spec requirement to generate a Location header field containing a URI reference for the different URI.""}}]","The provided function recalculates the destination URI and sets it as the value of the 'Location' header, which fulfills the core requirement of the RFC specification. Although the spec context mentions a 302 status code, the essential mandate to include a Location header with a URI reference is met by the function's logic, specifically with the call to apr_table_setn.",success,
15391,proxy_needsdomain,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Location"", nuri);\n...\nreturn HTTP_MOVED_PERMANENTLY;', 'explanation': ""The function sets the 'Location' header with the reassembled URI (nuri) and returns a 301 (Moved Permanently) response, which aligns with the RFC action of redirecting with a properly encoded request-target.""}}]","The provided function issues a 301 redirect when a missing domain is detected by appending it to the hostname. This partially addresses the RFC specification which states that an invalid request-line should be responded to with either a 400 error or a 301 redirect with the corrected request-target. However, the function does not validate or inspect for disallowed whitespace in the request-target as required by the spec, nor does it provide a mechanism to return a 400 error when necessary. Thus, only the redirect action (A1) is implemented, resulting in a partial match.",success,
15392,proxy_handler,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided proxy_handler function implements generic proxy routing and request handling logic (e.g., setting proxyreq, handling Max-Forwards, TRACE/OPTIONS processing, and selecting scheme handlers) but does not include any explicit logic to enforce the specific constraint from the RFC specification regarding sender roles. In other words, it does not check that the sender is avoiding generating protocol elements or syntax alternatives that are exclusively allowed for other roles, nor does it validate the generated elements against an ABNF grammar as required. Therefore, none of the labeled conditions or actions (e.g., C1 or A1) from the spec constraints are visibly implemented within this function.",success,
15392,proxy_handler,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if ((str = apr_table_get(r->headers_in, ""Max-Forwards""))) {\n    char *end;\n    maxfwd = apr_strtoi64(str, &end, 10);\n    if (maxfwd < 0 || maxfwd == APR_INT64_MAX || *end) {\n        ap_log_rerror(... ""Max-Forwards value \'%s\' could not be parsed"", str);\n        return ap_proxyerror(r, HTTP_BAD_REQUEST, \n                      ""Max-Forwards request header could not be parsed"");\n    }\n    ...\n    apr_table_setn(r->headers_in, ""Max-Forwards"",\n                   apr_psprintf(r->pool, ""%"" APR_INT64_T_FMT, maxfwd));\n}', 'explanation': ""This segment validates and then resets the 'Max-Forwards' header. By parsing its value and setting it only if valid, the code attempts to enforce that only protocol elements adhering to expected grammatical rules (here, a valid integer) are used. However, it only covers a subset of protocol elements rather than all elements that need to conform to the ABNF grammar.""}}, {'A1': {'code': 'rc = ap_proxy_canon_url(r); \nif (rc != OK) {\n    r->filename = old_filename;\n    r->proxyreq = 0;\n}', 'explanation': 'This excerpt shows an attempt to canonicalize the URL using a helper function, which helps ensure that the URL conforms to the expected format before further processing.'}}]","The RFC requires that a sender must not generate protocol elements that deviate from the ABNF-defined grammar. In this function, there are visible efforts to validate and normalize certain HTTP elements—specifically, the 'Max-Forwards' header is rigorously parsed and re-set only when valid, and the URL is canonicalized. These measures partially address the RFC requirement by ensuring that certain elements conform to expected formats. However, the function does not comprehensively enforce grammatical conformity across all generated protocol elements, so it only partially matches the specification.",success,
15392,proxy_handler,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'if (!r->filename) {\n    return DECLINED;\n}\n\nif (!r->proxyreq && r->handler && strncmp(r->handler, ""proxy:"", 6) == 0) {\n    char *old_filename = r->filename;\n\n    r->proxyreq = PROXYREQ_REVERSE;\n    r->filename = apr_pstrcat(r->pool, r->handler, r->filename, NULL);\n\n    /* Still need to canonicalize r->filename */\n    rc = ap_proxy_canon_url(r);\n    if (rc != OK) {\n        r->filename = old_filename;\n        r->proxyreq = 0;\n    }\n}\nelse if (r->proxyreq && strncmp(r->filename, ""proxy:"", 6) == 0) {\n    rc = OK;\n}\nif (rc != OK) {\n    return rc;\n}', 'explanation': 'This segment tries to ensure that the URI is valid by forcing a canonicalization of the URL when the proxy handler is explicitly invoked. It reflects the RFC’s guidance that a recipient MAY attempt to recover a usable protocol element (here via canonicalization), although the recovery attempt here is limited by reverting back if the canonicalization fails.'}}, {'A1': {'code': 'if ((str = apr_table_get(r->headers_in, ""Max-Forwards""))) {\n    char *end;\n    maxfwd = apr_strtoi64(str, &end, 10);\n    if (maxfwd < 0 || maxfwd == APR_INT64_MAX || *end) {\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10188) \n                      ""Max-Forwards value \'%s\' could not be parsed"", str);\n        return ap_proxyerror(r, HTTP_BAD_REQUEST, \n                      ""Max-Forwards request header could not be parsed"");\n    }\n    else if (maxfwd == 0) {\n        switch (r->method_number) {\n        case M_TRACE:\n            r->proxyreq = PROXYREQ_NONE;\n            access_status = ap_send_http_trace(r);\n            ap_die(access_status, r);\n            return OK;\n        case M_OPTIONS:\n            r->proxyreq = PROXYREQ_NONE;\n            access_status = ap_send_http_options(r);\n            ap_die(access_status, r);\n            return OK;\n        default:\n            return ap_proxyerror(r, HTTP_BAD_REQUEST,\n                                 ""Max-Forwards has reached zero - proxy loop?"");\n        }\n    }\n    maxfwd = (maxfwd > 0) ? maxfwd - 1 : 0;\n}\nelse {\n    /* set configured max-forwards */\n    maxfwd = conf->maxfwd;\n}\nif (maxfwd >= 0) {\n    apr_table_setn(r->headers_in, ""Max-Forwards"",\n                   apr_psprintf(r->pool, ""%"" APR_INT64_T_FMT, maxfwd));\n}', 'explanation': 'This code handles the semantics of the Max-Forwards header—parsing its integer value, handling cases of an invalid or zero value and then decrementing it when appropriate. These operations demonstrate an interpretation of the protocol element according to its defined semantics, which is in line with the HTTP RFC’s recommendations.'}}]","The function implements parts of the HTTP RFC by validating and processing incoming protocol elements such as the URL and the Max-Forwards header. It includes a canonicalization step to recover from an invalid construct (C1) and interprets the Max-Forwards header in multiple ways (A1), including handling specific methods when its value is zero. However, while these segments reveal attempts to interpret and recover protocol elements per the specification, the overall recovery framework is not comprehensive within this function alone. Thus, the code partially matches the spec constraints.",success,
15392,proxy_handler,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if ((str = apr_table_get(r->headers_in, ""Max-Forwards""))) {\n    char *end;\n    maxfwd = apr_strtoi64(str, &end, 10);\n    if (maxfwd < 0 || maxfwd == APR_INT64_MAX || *end) {\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10188) \n                      ""Max-Forwards value \'%s\' could not be parsed"", str);\n        return ap_proxyerror(r, HTTP_BAD_REQUEST, \n                      ""Max-Forwards request header could not be parsed"");\n    }\n    else if (maxfwd == 0) {\n        switch (r->method_number) {\n        case M_TRACE: {\n            int access_status;\n            r->proxyreq = PROXYREQ_NONE;\n            access_status = ap_send_http_trace(r);\n            ap_die(access_status, r);\n            return OK;\n        }\n        case M_OPTIONS: {\n            int access_status;\n            r->proxyreq = PROXYREQ_NONE;\n            access_status = ap_send_http_options(r);\n            ap_die(access_status, r);\n            return OK;\n        }\n        default: {\n            return ap_proxyerror(r, HTTP_BAD_REQUEST,\n                                 ""Max-Forwards has reached zero - proxy loop?"");\n        }\n        }\n    }\n    maxfwd = (maxfwd > 0) ? maxfwd - 1 : 0;\n}\nelse {\n    maxfwd = conf->maxfwd;\n}\nif (maxfwd >= 0) {\n    apr_table_setn(r->headers_in, ""Max-Forwards"",\n                   apr_psprintf(r->pool, ""%"" APR_INT64_T_FMT, maxfwd));\n}', 'explanation': 'This segment demonstrates interpreting a received header (Max-Forwards) per its semantic definition. It parses, validates, and adapts the header value in accordance with protocol rules.'}}]","The proxy_handler function exhibits logic for interpreting HTTP protocol elements such as the URL scheme, domain, and especially the Max-Forwards header. It validates and sanitizes incoming protocol elements and handles errors by logging and returning appropriate HTTP responses. This is in line with the requirement that a recipient must interpret protocol elements based on defined semantics. However, while the function addresses some aspects of proper interpretation and error handling, it does not fully implement all recovery and configuration‐based checks implied by the RFC (for example, adjusting behavior based on detected misimplementations). Therefore, the implementation can be considered to only partially match the specified HTTP RFC.",success,
15392,proxy_handler,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': '    p = strchr(uri, \':\');\n    if (p == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01141)\n                      ""proxy_handler no URL in %s"", r->filename);\n        return HTTP_BAD_REQUEST;\n    }', 'explanation': ""This segment checks that the URI contains a colon (':') which is necessary to separate the scheme from the rest of the URL. It defends against a malformed protocol element by returning a bad request if the expected structure is not met.""}}, {'A1': {'code': '    if ((str = apr_table_get(r->headers_in, ""Max-Forwards""))) {\n        char *end;\n        maxfwd = apr_strtoi64(str, &end, 10);\n        if (maxfwd < 0 || maxfwd == APR_INT64_MAX || *end) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10188) \n                          ""Max-Forwards value \'%s\' could not be parsed"", str);\n            return ap_proxyerror(r, HTTP_BAD_REQUEST, \n                          ""Max-Forwards request header could not be parsed"");\n        }\n        /* ... */\n    }', 'explanation': ""This code defensively parses the 'Max-Forwards' header by converting it to an integer, verifying that the conversion succeeds without leftover characters, and ensuring that the value is within a valid range. It thus helps safeguard against malformed header input.""}}]","The function implements defensive parsing for key protocol elements by checking that the URL contains the expected components and that header values such as 'Max-Forwards' are correctly formatted. However, while it performs important defensive checks (e.g., verifying a colon in the URI and validating numeric conversion of headers), it does not fully encompass all potential edge cases mentioned in the RFC specification (such as comprehensive ABNF validation or explicit buffer size checks). As a result, the implementation addresses some, but not all, expected conditions and actions from the spec.",success,
15392,proxy_handler,A recipient MAY ignore a Max-Forwards header field received with any other request methods.,22,Partially Matches,"[{'C1': {'code': 'if ((str = apr_table_get(r->headers_in, ""Max-Forwards""))) {\n    char *end;\n    maxfwd = apr_strtoi64(str, &end, 10);\n    if (maxfwd < 0 || maxfwd == APR_INT64_MAX || *end) {\n        ...\n    }\n    else if (maxfwd == 0) {\n        switch (r->method_number) {\n        case M_TRACE: {\n            ...\n            return OK;\n        }\n        case M_OPTIONS: {\n            ...\n            return OK;\n        }\n        default: {\n            return ap_proxyerror(r, HTTP_BAD_REQUEST,\n                                 ""Max-Forwards has reached zero - proxy loop?"");\n        }\n        }\n    }\n    maxfwd = (maxfwd > 0) ? maxfwd - 1 : 0;\n}', 'explanation': 'This segment retrieves the Max-Forwards header, parses it, and for TRACE/OPTIONS handles a value of zero by immediately responding (or returning an error for other methods). It attempts to enforce that when Max-Forwards is 0, TRACE and OPTIONS are finalized rather than forwarded.'}}, {'A1': {'code': 'if (maxfwd >= 0) {\n    apr_table_setn(r->headers_in, ""Max-Forwards"",\n                   apr_psprintf(r->pool, ""%"" APR_INT64_T_FMT, maxfwd));\n}', 'explanation': 'When a positive Max-Forwards value is present, the code decrements the value and updates the header before further processing, consistent with the requirement for handling TRACE and OPTIONS requests.'}}]","The function includes logic to check the Max-Forwards header by retrieving and parsing its value. For TRACE and OPTIONS requests it performs the required check—if the header value equals zero it does not forward the request, and if the value is greater than zero it decrements it before forwarding. However, the HTTP RFC also specifies that a recipient MAY ignore the Max-Forwards header for requests using methods other than TRACE or OPTIONS; in this implementation, the header is processed (and decremented) regardless of the request method. Because the function only partially adheres to the spec by correctly handling TRACE/OPTIONS but not by ignoring the header for other methods, it is considered to partially match the specification.",success,
15400,add_proxy,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'if (q != NULL) {\n    if (sscanf(q + 1, ""%u"", &port) != 1 || port > 65535) {\n        ...\n    }\n    *q = \'\\0\';\n} else\n    port = -1;\n...\nif (port == -1) {\n    port = apr_uri_port_of_scheme(scheme);\n}', 'explanation': ""The code checks whether a port is specified by looking for a ':' in the URL. If not found (i.e., port remains -1), it calls apr_uri_port_of_scheme(scheme) to assign the default port based on the provided scheme, which fully implements the RFC requirement.""}}]","The function 'add_proxy' contains logic that directly addresses the RFC specification by checking if a port is provided and, if not, determining the default port for the given protocol. This behavior corresponds exactly to the spec's requirement that a missing port be interpreted as the default port for the received protocol, hence it fully matches the constraint labeled C1.",success,
15403,ap_proxy_de_socketfy,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'if (!ap_cstr_casecmpn(url, ""unix:"", 5) && ((ptr = ap_strchr_c(url + 5, \'|\')) != NULL)) {\n    ...\n    if (c[1] == \'\\0\') {\n        return apr_pstrcat(p, ret, ""//localhost"", NULL);\n    } else {\n        return ret;\n    }\n}', 'explanation': 'This code segment inspects the URL for a Unix domain socket (UDS) syntax and, in the case where the scheme part is incomplete (i.e., nothing follows the \':\' character), it recovers the URL by appending ""//localhost"". This aligns with the RFC specification that a recipient MAY attempt to recover a usable protocol element from an invalid construct.'}}]","The function contains logic that attempts to recover a malformed URL by checking if it starts with ""unix:"" and contains a UDS path separated by '|'. In the special case where the scheme lacks sufficient characters after the colon, it appends ""//localhost"" to create a complete URL. This behavior reflects the RFC specification's allowance for a recipient to recover from certain invalid constructs. However, since the code only addresses this specific URL pattern and does not cover the full spectrum of potential invalid constructs, the implementation only partially matches the overall RFC constraints.",success,
15414,set_proxy_error_override,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,[],"The provided function demonstrates some elements of defensive parsing – for example, it checks if the input begins with a digit before converting it to an integer (using apr_isdigit) and it validates that the numeric code falls within a valid HTTP error range (using ap_is_HTTP_ERROR). These measures can be seen as a minimal defensive strategy. However, the RFC specifies that a recipient SHOULD parse a received protocol element defensively with only marginal assumptions about its conformance to an ABNF grammar and its buffer size. The function does not explicitly implement checks for buffer length or a more comprehensive validation of the input’s conformity to an ABNF grammar. Therefore, while there is evidence of defensive programming in handling the input—addressing some aspects of the RFC—it does not fully implement all the defensive parsing measures described in the specification.",success,
15477,ap_proxy_c2hex,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, ap_proxy_c2hex, only converts an integer character to its percent-encoded hexadecimal representation. It does not include any logic to verify or enforce that the protocol elements being generated are only those allowed for the specific role of the sender as mandated by the RFC specification. The function does not check the sender's role or validate the usage of protocol elements; it simply performs a transformation, and hence does not address the constraints regarding role-based protocol element generation (e.g., the sender not generating elements reserved for other roles). Therefore, it does not implement any of the labeled conditions or actions from the spec constraints.",success,
15480,ap_proxy_canon_netloc,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'url = strchr(host, \'/\');\nif (url == NULL) {\n    url = """";\n}\nelse {\n    *(url++) = \'\\0\';    /* skip separating \'/\' */\n}', 'explanation': 'The RFC states that a recipient MAY attempt to recover a usable protocol element from an invalid construct. In this function, if separating \'/\' is not found after the host part, the function sets the url to an empty string rather than failing completely. This shows an attempt to continue processing (i.e., to recover) from a potentially malformed construct. However, similar recovery is not applied in other instances (for example, if the URL does not start with ""//"", the function returns an error), meaning that only part of the RFC’s flexibility is implemented.'}}]","The function shows a limited attempt to follow the RFC's allowance for recovery from invalid constructs by handling one case of missing elements (defaulting the url to an empty string when no separating '/' is found). However, for other cases of potential invalidity (such as a URL not beginning with ""//"" or bad %-escapes) the function opts to return error messages rather than recovering. This partial approach means that while some recovery logic exists within the function_body, it does not fully implement the RFC’s flexible error-handling requirements in all cases.",success,
15480,ap_proxy_canon_netloc,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (url[0] != \'/\' || url[1] != \'/\') {\n    return ""Malformed URL"";\n}\n\n...\n\nrv = apr_parse_addr_port(&addr, &scope_id, &tmp_port, host, p);\nif (rv != APR_SUCCESS || addr == NULL || scope_id != NULL) {\n    return ""Invalid host/port"";\n}', 'explanation': ""This segment shows defensive parsing of the network location element by checking that the URL begins with '//' and by verifying the host/port portion using apr_parse_addr_port. It returns an error string when the structure does not meet minimal expectations, which reflects part of the RFC requirement that the recipient parse the input defensively.""}}, {'A1': {'code': 'user = ap_proxy_canonenc(p, user, strlen(user), enc_user, 1, 0);\nif (user == NULL) {\n    return ""Bad %-escape in URL (username)"";\n}\n\n...\n\npassword = ap_proxy_canonenc(p, strp + 1, strlen(strp + 1), enc_user, 1, 0);\nif (password == NULL) {\n    return ""Bad %-escape in URL (password)"";\n}', 'explanation': 'This code attempts to perform canonicalization of the user and password fields by handling %-escapes and returning an error if the escapes are invalid, in line with a defensive parsing approach.'}}]","The function implements defensive parsing by checking whether the input URL conforms to minimal expected structures (e.g., beginning with '//', proper separation of host, port, user, and password), and by validating %-escape sequences. However, it only partially implements the overall RFC advice. It does not perform a complete ABNF parsing or buffer length validation as might be expected for fully robust handling under all circumstances. Thus, while key defensive steps are visible (as addressed in constraints C1 and A1), the implementation does not cover every nuance suggested by the spec context, leading to a partial match.",success,
15481,proxyerror_core,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function does not implement any logic that checks or enforces conformance to the ABNF grammar requirements as mandated by the RFC specification. It merely logs an error, sets error notes, and constructs a status line with a fixed pattern without verifying that the resulting protocol element fully matches the defined grammar. Therefore, none of the spec constraints (for example, the rule against generating protocol elements that do not conform to the grammar) are visibly addressed within this function's body.",success,
15481,proxyerror_core,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'proxyerror_core' handles error logging and prepares an error response by setting specific error notes and a status line. However, it does not contain any logic that checks or enforces the RFC's requirement regarding role-based protocol element generation. Specifically, it does not verify or restrict the creation of protocol elements based on the sender's role, as mandated by the spec. Therefore, none of the labeled conditions (e.g., C1) or actions (e.g., A1) are addressed within this function.",success,
15493,ap_proxy_pre_http_request,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The function ap_proxy_pre_http_request merely adds two input filters ('HTTP_IN' and 'HTTP1_BODY_IN') and returns OK. There is no logic within the function that verifies or enforces that generated protocol elements conform to the ABNF rules. Thus, it does not visibly address the spec constraint requiring that a sender must not generate protocol elements that do not match the defined grammar (i.e., it does not implement any checks or formatting that ensure conformance). No part of the function's body implements any of the labeled conditions or actions from the specification.",success,
15493,ap_proxy_pre_http_request,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function does not contain any logic that verifies or restricts the generation of protocol elements based on the sender's role as required by the RFC. It simply adds input filters (HTTP_IN and HTTP1_BODY_IN) and returns OK without checking or enforcing any role-specific constraints. Therefore, no part of the function directly addresses the spec condition regarding not generating protocol elements reserved for other roles.",success,
15495,ap_proxy_cookie_reverse_map,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Partially Matches,"[{'C1': {'code': 'while (apr_isspace(*token)) {\n    ++token;\n}', 'explanation': 'This code segment iterates over each token and explicitly skips any leading whitespace. In doing so, it removes BWS (bad whitespace) as required by the RFC, addressing the condition that a recipient must parse for and remove such whitespace before interpreting protocol elements.'}}]","The RFC specification states that any content defined as BWS may be removed before interpretation. The provided function, when parsing cookie parameters, includes a loop that skips leading spaces from each token, thereby removing the bad whitespace. This logic within the function addresses at least one part of the requirements by directly removing unwanted whitespace. However, since the overall RFC specification might include additional conditions and actions beyond just BWS removal (and the code does not address those), the implementation only partially matches the full specification constraints.",success,
15495,ap_proxy_cookie_reverse_map,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,"[{'C1': {'code': 'while (apr_isspace(*token)) {\n    ++token;\n}', 'explanation': ""This loop strips the leading whitespace from each token before processing it, which is in line with the requirement to remove 'bad whitespace' before interpreting protocol elements. However, this is a localized operation and does not comprehensively normalize or remove all extraneous whitespace throughout the entire protocol element, meaning it only partially addresses the RFC specification on whitespace handling.""}}]","The function primarily focuses on reversing cookie mappings by parsing a semicolon-delimited string and checking for 'path=' and 'domain=' tokens. It does remove leading whitespace from each token using a loop (thus addressing a part of the RFC requirement), but it does not implement a complete whitespace normalization throughout the entire element as the RFC dictates. As a result, the function only partially matches the specified constraint regarding parsing and removal of bad whitespace.",success,
15495,ap_proxy_cookie_reverse_map,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Partially Matches,"[{'C1': {'code': 'while (apr_isspace(*token)) {\n    ++token;\n}', 'explanation': 'This segment attempts to exclude leading whitespace from each token before further evaluation, which partially satisfies the requirement to remove extraneous whitespace as specified. However, it does not remove trailing whitespace, so the implementation is only partial.'}}]","The RFC requires that any leading or trailing whitespace be removed before field values are evaluated. The code function includes a loop to skip leading spaces (as seen in the provided snippet), which addresses part of the constraint (C1). However, it does not exhibit any logic to remove trailing whitespace from the field values. Since only part of the whitespace exclusion requirement is handled within this function, the overall implementation is considered a partial match.",success,
15495,ap_proxy_cookie_reverse_map,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Fully Matches,"[{'C1': {'code': 'if (r->proxyreq != PROXYREQ_REVERSE) {\n        return str;\n    }', 'explanation': 'This check ensures that the function only modifies cookie elements (i.e. generates new protocol elements) when the role is reverse proxy. When the role is not reverse proxy, the original string is returned unchanged, thereby preventing the generation of protocol elements that are only allowed by other roles, in line with the RFC specification.'}}]","The function implements a role-based check by determining if the current request is a reverse proxy (using 'r->proxyreq != PROXYREQ_REVERSE'). This prevents the function from modifying the cookie details when the sender does not have the appropriate role. As such, the function visibly addresses the RFC requirement that a sender must not generate protocol elements or syntax alternatives that are only allowed for participants in other roles.",success,
15497,ap_proxy_get_balancer,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Partially Matches,"[{'C1': {'code': ""if ((c = strchr(c + 3, '/'))){\n    *c = '\\0';\n}\nap_str_tolower(uri);"", 'explanation': ""The code removes the path component from the URI and converts the entire URI to lower-case. This basic normalization aligns with the specification's requirement that HTTP URIs that are equivalent after normalization should identify the same resource. However, the normalization is basic and does not cover all potential normalization techniques, which is why the overall implementation only partially matches the spec.""}}]","The function implements a rudimentary normalization process by stripping the path from the URI and converting it to lower-case, which is a partial implementation of the HTTP normalization requirement. While it addresses the core idea of normalization (i.e. that equivalent URIs should resolve to the same resource), it does not fully implement a comprehensive normalization mechanism as might be expected from the full specification. Therefore, in isolation, the function's logic only partially meets the specified RFC constraint.",success,
15497,ap_proxy_get_balancer,A recipient that processes such a URI reference MUST reject it as invalid.,224,Partially Matches,"[{'C1': {'code': ""c = strchr(uri, ':');\nif (c == NULL || c[1] != '/' || c[2] != '/' || c[3] == '\\0') {\n    return NULL;\n}"", 'explanation': ""This segment checks that the URI contains a colon followed by '//' and that a character exists after it, effectively ensuring there is a non-empty host identifier. This addresses the RFC requirement that an 'http' URI with an empty host identifier must be rejected.""}}]","The function implements a basic validation of the URI by ensuring that after the scheme the '://' is present and that there is at least one character following it, which prevents an empty host identifier. This check is directly in line with the spec's requirement to reject URI references with an empty host. However, the function does not cover additional validations that might be required by the RFC, so while it does attempt to implement one key constraint, it does so only partially relative to all the possible conditions laid out in the RFC.",success,
15498,ap_proxy_update_balancer,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (!url) {\n    return NULL;\n}\nif (apr_uri_parse(p, url, &puri) != APR_SUCCESS) {\n    return apr_psprintf(p, ""unable to parse: %s"", url);\n}', 'explanation': 'The function performs defensive parsing by verifying the URL is non-null and by attempting to parse it with apr_uri_parse. This aligns with the expectation to not assume complete conformance to the ABNF and to handle parsing failures gracefully.'}}, {'A1': {'code': 'if (puri.path && PROXY_STRNCPY(balancer->s->vpath, puri.path) != APR_SUCCESS) {\n    return apr_psprintf(p, ""balancer %s front-end virtual-path (%s) too long"",\n                        balancer->s->name, puri.path);\n}\nif (puri.hostname && PROXY_STRNCPY(balancer->s->vhost, puri.hostname) != APR_SUCCESS) {\n    return apr_psprintf(p, ""balancer %s front-end vhost name (%s) too long"",\n                        balancer->s->name, puri.hostname);\n}', 'explanation': 'The function attempts to address the need for a reasonable buffer size by calling PROXY_STRNCPY on the protocol elements (path and hostname) and returns an error message if they are too long. This reflects a defensive approach, though it delegates length checking to the PROXY_STRNCPY utility.'}}]","The function provides a basic defensive parsing approach as suggested by the RFC specification. It checks for a null URL and uses apr_uri_parse to validate the URL's conformance, in addition to trying to enforce buffer size constraints when copying values into the virtual host and path fields. However, some key responsibilities, such as thoroughly validating against the ABNF or managing buffer sizes independently, are offloaded to external functions. As a result, while some conditions (C1) and actions (A1) are partially addressed within this function, it does not implement the entire spirit of the spec on its own.",success,
15517,ap_proxy_worker_can_upgrade,"Although protocol names are registered with a preferred case, recipients SHOULD use case-insensitive comparison when matching each protocol-name to supported protocols.",257,Partially Matches,"[{'C1': {'code': 'ap_cstr_casecmp(worker_upgrade, upgrade) == 0\n|| ap_find_token(p, worker_upgrade, upgrade)\n...\nreturn (dflt && ap_cstr_casecmp(dflt, upgrade) == 0);', 'explanation': ""The RFC specifies that protocol name matching should be case-insensitive. This function uses ap_cstr_casecmp to compare the worker's upgrade value (and a default) with the provided upgrade string, and additionally delegates token matching to ap_find_token. These segments directly implement case-insensitive comparisons, thereby addressing the RFC requirement regarding protocol-name comparisons.""}}]","The function visibly implements protocol name matching in a case-insensitive manner, fulfilling the core requirement from the specification (labeled C1). However, it does not cover other aspects mentioned in the specification context—such as ordering based on client preference or listing protocols in layer-ascending order—that might also be expected in a complete upgrade process. Therefore, while the case-insensitive comparison is adequately handled, the function only partially implements the full set of spec constraints.",success,
15520,ap_proxy_get_worker_ex,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Partially Matches,"[{'C1': {'code': ""c = ap_strchr_c(c+3, '/');\nif (c) {\n    char *pathstart;\n    pathstart = url_copy + (c - url);\n    *pathstart = '\\0';\n    ap_str_tolower(url_copy);\n    min_match = strlen(url_copy);\n    *pathstart = '/';\n} else {\n    ap_str_tolower(url_copy);\n    min_match = strlen(url_copy);\n}"", 'explanation': 'This block of code extracts the scheme and hostname portion of the URL and forces it to lowercase. By doing so, it performs a form of normalization on the URI, which is one of the aspects stated in the RFC specification (i.e. that two HTTP URIs equivalent after normalization identify the same resource). However, it only handles a limited aspect of normalization (i.e. lowercasing) rather than a complete normalization process as might be described in the full RFC.'}}]","The function makes an attempt to implement URI normalization by converting the scheme and host segment of the URL to lowercase prior to performing matching (thereby treating URIs that differ only in case as equivalent). This shows that the function partly addresses the RFC specification that equivalent URIs after normalization correspond to the same resource. However, since the normalization performed is limited and not comprehensive (e.g., other normalization aspects such as percent-decoding or default port elimination are not addressed here), the code only partially matches the spec constraints.",success,
15522,ap_proxy_define_worker_ex,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'rv = apr_uri_parse(p, ptr, &uri);\nif (rv != APR_SUCCESS) {\n    return apr_pstrcat(p, ""Unable to parse URL: "", url, NULL);\n}\nif (!uri.scheme) {\n    return apr_pstrcat(p, ""URL must be absolute!: "", url, NULL);\n}\nif (!uri.hostname) {\n    if (sockpath) {\n        uri.hostname = ""localhost"";\n    }\n    else {\n        return apr_pstrcat(p, ""URL must be absolute!: "", url, NULL);\n    }\n}', 'explanation': 'The code performs defensive parsing of the incoming URL by calling apr_uri_parse and then checking for essential components (scheme and hostname). It returns error messages if these components are missing, thereby attempting to handle protocol elements that may not conform to expected formats.'}}, {'A1': {'code': 'if (PROXY_STRNCPY(wshared->name, ptr) != APR_SUCCESS) {\n    ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(02808)\n    ""Alert! worker name (%s) too long; truncated to: %s"", ptr, wshared->name);\n}\n\nif (PROXY_STRNCPY(wshared->scheme, uri.scheme) != APR_SUCCESS) {\n    ap_log_error(APLOG_MARK, APLOG_ERR, 0, ap_server_conf, APLOGNO(010117)\n    ""Alert! worker scheme (%s) too long; truncated to: %s"", uri.scheme, wshared->scheme);\n}\n\nif (PROXY_STRNCPY(wshared->hostname_ex, uri.hostname) != APR_SUCCESS) {\n    return apr_psprintf(p, ""worker hostname (%s) too long"", uri.hostname);\n}\n\nif (PROXY_STRNCPY(wshared->hostname, uri.hostname) != APR_SUCCESS) {\n    ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf, APLOGNO(010118)\n    ""worker hostname (%s) too long; truncated for legacy modules that do not use ""\n    ""proxy_worker_shared->hostname_ex: %s"", uri.hostname, wshared->hostname);\n}', 'explanation': 'The code uses safe string copy routines (PROXY_STRNCPY) and checks their results to ensure that the data being parsed does not overflow the expected buffer sizes. This helps to enforce a reasonable limit on the protocol element’s length in line with defensive parsing requirements.'}}]","The function implements several defensive measures while parsing URL input. It first attempts to parse the URL and then verifies that essential components such as the scheme and hostname are present, returning an error if they are not. Additionally, it employs safe string copy routines to prevent overruns and logs or errors out if the data exceeds preset lengths. However, while these measures partially reflect the RFC’s emphasis on defensive parsing with marginal assumptions regarding conformance and buffer sizes, the function does not fully encompass all possible defensive strategies (e.g., handling every nuance of an ABNF grammar variation) that the broader RFC discussion might suggest. Consequently, the implementation in this function only partially meets the specified constraints.",success,
15522,ap_proxy_define_worker_ex,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Fully Matches,"[{'C1': {'code': 'if (!uri.hostname) {\n    if (sockpath) {\n        /* allow for unix:/path|http: */\n        uri.hostname = ""localhost"";\n    } else {\n        return apr_pstrcat(p, ""URL must be absolute!: "", url, NULL);\n    }\n}', 'explanation': ""This segment checks whether the parsed URI's hostname is empty. For non-unix-socket URLs, it returns an error, thereby ensuring that no HTTP URI is generated with an empty host identifier, as required by the RFC.""}}]","The function parses the input URL and explicitly verifies that the hostname is present. When the hostname is missing (and the URL isn't using a unix socket where a default 'localhost' is provided), it returns an error message. This directly implements the RFC constraint that an HTTP URI must not have an empty host identifier.",success,
15522,ap_proxy_define_worker_ex,A recipient that processes such a URI reference MUST reject it as invalid.,226,Fully Matches,"[{'C1': {'code': 'if (!uri.hostname) {\n    if (sockpath) {\n        /* allow for unix:/path|http: */\n        uri.hostname = ""localhost"";\n    }\n    else {\n        return apr_pstrcat(p, ""URL must be absolute!: "", url, NULL);\n    }\n}', 'explanation': 'This segment verifies that the URI contains a hostname. If the hostname is missing (and not in the special case of a Unix domain socket), the function returns an error message, thereby rejecting the URI as invalid as required by the RFC.'}}]","The function explicitly checks that the parsed URI includes a scheme and a hostname. In the case where the hostname is absent (except when using a Unix domain socket where a default of 'localhost' is assigned), it immediately rejects the URI by returning an error message. This directly implements the RFC requirement that a recipient must reject a URI reference with an empty host identifier. Therefore, in isolation, the code function fully implements the specified constraint.",success,
15522,ap_proxy_define_worker_ex,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Fully Matches,"[{'C1': {'code': '/* Normalize the url (worker name) */\nrv = apr_uri_parse(p, ptr, &uri);\nif (rv != APR_SUCCESS) {\n    return apr_pstrcat(p, ""Unable to parse URL: "", url, NULL);\n}\nif (!uri.scheme) {\n    return apr_pstrcat(p, ""URL must be absolute!: "", url, NULL);\n}\nif (!uri.hostname) {\n    if (sockpath) {\n        /* allow for unix:/path|http: */\n        uri.hostname = ""localhost"";\n    }\n    else {\n        return apr_pstrcat(p, ""URL must be absolute!: "", url, NULL);\n    }\n}\nelse {\n    ap_str_tolower(uri.hostname);\n}\nap_str_tolower(uri.scheme);\nport_of_scheme = ap_proxy_port_of_scheme(uri.scheme);\nif (uri.port && uri.port == port_of_scheme) {\n    uri.port = 0;\n}\nptr = apr_uri_unparse(p, &uri, APR_URI_UNP_REVEALPASSWORD);', 'explanation': 'This segment parses the given URL, verifies it is absolute, converts the scheme and hostname to lower case, and removes the default port by setting it to zero. This normalization process aligns directly with the RFC specification stating that equivalent HTTP URIs after normalization should identify the same resource.'}}]","The function explicitly implements a URL normalization mechanism by invoking apr_uri_parse and then applying several normalization steps: ensuring the URL is absolute, lowercasing the scheme and hostname, handling missing hostname (by setting it to 'localhost' in the case of unix socket paths), and eliminating the default port. These operations address the RFC requirement that HTTP URIs equivalent after normalization identify the same resource. Hence, the function fully meets the specified HTTP RFC requirement as implemented in the code body.",success,
15522,ap_proxy_define_worker_ex,A recipient that processes such a URI reference MUST reject it as invalid.,224,Fully Matches,"[{'C1': {'code': 'if (!uri.hostname) {\n    if (sockpath) {\n        /* allow for unix:/path|http: */\n        uri.hostname = ""localhost"";\n    } else {\n        return apr_pstrcat(p, ""URL must be absolute!: "", url, NULL);\n    }\n}', 'explanation': ""This code checks if the hostname in the parsed URI is empty. In cases where there is no hostname (and no Unix domain socket override provided by 'sockpath'), it immediately rejects the URL by returning an error message. This behavior directly implements the requirement of rejecting a URI with an empty host identifier as per the RFC specification.""}}]","The function inspects the parsed URI and if the hostname is missing, it rejects the URI by returning an error message. This directly addresses the spec's mandate that a recipient must reject a URI with an empty host identifier, thereby fully meeting the corresponding constraint.",success,
15528,fixup_uds_filename,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (!strncmp(r->filename, ""proxy:"", 6) &&\n        !ap_cstr_casecmpn(uds_url, ""unix:"", 5) &&\n        (origin_url = ap_strchr(uds_url + 5, \'|\')))', 'explanation': ""This segment defensively checks that the filename begins with 'proxy:' and that the subordinate part begins with 'unix:' and contains the expected '|' delimiter. It attempts to ensure the protocol element conforms at least marginally to an expected format.""}}, {'A1': {'code': 'if (!uds_path || !(end = ap_strchr(origin_url, \':\'))) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10292)\n            ""Invalid proxy UDS filename (%s)"", r->filename);\n    apr_table_unset(r->notes, ""uds_path"");\n    return HTTP_BAD_REQUEST;\n}', 'explanation': ""This part logs an error and returns an HTTP_BAD_REQUEST if critical parts of the protocol element (e.g. uds_path or delimiter ':') are missing, thereby enforcing defensive parsing of the element.""}}]","The function attempts to implement defensive parsing of a UDS filename input by checking for specific prefixes ('proxy:' and 'unix:'), validating the presence of expected delimiters, and safely handling cases where the format does not meet expectations by rejecting the request. However, while it performs sanity checks and error logging on format deviations, it does not comprehensively cover all aspects implied by the spec—such as ensuring a buffer size limitation—in isolation. Thus, the function partially matches the RFC’s guidance on defensive parsing.",success,
15528,fixup_uds_filename,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'if (!strncmp(r->filename, ""proxy:"", 6) &&\n        !ap_cstr_casecmpn(uds_url, ""unix:"", 5) &&\n        (origin_url = ap_strchr(uds_url + 5, \'|\')))', 'explanation': 'This segment checks that the filename begins with the expected ""proxy:"" prefix and a ""unix:"" subsequence, and then attempts to locate the protocol element separator (\'|\'). This corresponds to the spec allowing recovery of a usable protocol element from an otherwise invalid construct.'}}, {'A1': {'code': 'if (!end[1]) {\n    r->filename = apr_pstrcat(r->pool, ""proxy:"", origin_url, ""//localhost"", NULL);\n} else if (end[1] == \'/\' && end[2] == \'/\' && !end[3]) {\n    r->filename = apr_pstrcat(r->pool, ""proxy:"", origin_url, ""localhost"", NULL);\n}', 'explanation': 'This block ensures that if the hostname is missing from the UDS URL, a default value of ""localhost"" is inserted. This action helps to interpret the received protocol element according to its defined semantics, as per the specification.'}}]","The function fixup_uds_filename attempts to recover a usable protocol element from a potentially malformed proxy UDS filename. It does so by checking for the required prefixes and delimiters (C1) and by inserting a default hostname when necessary (A1). However, while these segments indicate an attempt to implement the recovery and interpretation of an invalid construct as allowed by the specification, the function does not address all potential conditions or actions implied by the full spec context. Thus, the function only partially matches the overall spec requirements.",success,
15528,fixup_uds_filename,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Does Not Match,[],"The provided function (fixup_uds_filename) focuses on processing and reformatting filenames for Unix Domain Socket proxy connections. It checks for specific formatting issues (e.g., ensuring the filename starts with ""proxy:"" and that a proper UDS URL is constructed) and returns HTTP_BAD_REQUEST if the UDS filename is malformed. However, it does not address the RFC specification regarding an invalid request-line. Specifically, the RFC requires that recipients of an invalid request-line—such as one containing disallowed whitespace in the request-target—should either return a 400 (Bad Request) error or issue a 301 (Moved Permanently) redirect with the properly encoded request-target. This function does not check for whitespace in the request-target, nor does it attempt to encode or redirect a malformed request-line. Instead, the logic is solely for correcting UDS filenames and not for validating or transforming HTTP request-lines as specified. Therefore, no labeled condition (e.g., C1) or action (e.g., A1) related to the RFC constraints is met within this function.",success,
15532,ap_proxy_canon_url,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,[],"The RFC requires that an invalid request‐line (for example, one containing disallowed whitespace) should result in either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request‐target properly encoded. In this function, the only visible check is a simple validation that the URL (extracted from r->filename) contains a colon (':') – if it is missing or misplaced, the function immediately returns HTTP_BAD_REQUEST (400). This addresses one scenario for an invalid request‐line by returning a 400 error. However, the function does not inspect or correct for disallowed whitespace in the request‐target, nor does it offer the alternative 301 redirect. Consequently, while the function attempts to handle certain invalid URL conditions by returning a 400, it does not fully implement the RFC requirement. None of the spec’s labeled constraints (e.g., conditions C1 or actions A1) are fully met solely within this function, so met_constrains remains empty.",success,
15546,ap_proxy_determine_connection,A recipient that processes such a URI reference MUST reject it as invalid.,224,Fully Matches,"[{'C1': {'code': 'if (!uri->hostname) {\n    return ap_proxyerror(r, HTTP_BAD_REQUEST,\n                         apr_pstrcat(p,""URI has no hostname: "", *url, NULL));\n}', 'explanation': ""This code segment checks whether the 'hostname' component of the parsed URI is empty and, if so, rejects the request as invalid by returning an error. This directly implements the specification requirement that a recipient MUST reject an 'http' URI with an empty host identifier.""}}]","The function parses the URI and explicitly checks for the absence of a hostname. When the hostname is missing, it returns an error, thereby fulfilling the RFC specification that a recipient processing such a URI reference must reject it as invalid. All other functionalities in the function are for connection management and do not affect this specific requirement.",success,
15546,ap_proxy_determine_connection,A recipient that processes such a URI reference MUST reject it as invalid.,226,Fully Matches,"[{'C1': {'code': 'if (!uri->hostname) {\n        return ap_proxyerror(r, HTTP_BAD_REQUEST,\n                             apr_pstrcat(p,""URI has no hostname: "", *url, NULL));\n    }', 'explanation': ""This segment checks if the URI's hostname is empty. According to the HTTP RFC specification, a URI with an empty host identifier (especially for an HTTPS URI) must be rejected as invalid. The function directly implements this requirement by parsing the URI and rejecting it immediately if uri->hostname is NULL.""}}]","The code function inspects the URI after parsing and explicitly rejects any URI with an empty hostname, which fully addresses the spec constraint that a recipient must reject an HTTPS URI with an empty host identifier. No dependency is involved in fulfilling this condition; it is implemented directly within the function.",success,
15546,ap_proxy_determine_connection,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'if (!uri->port) {\n    uri->port = ap_proxy_port_of_scheme(uri->scheme);\n}', 'explanation': 'This code checks if the URI does not include a port and, if so, assigns it the default port based on the scheme. This directly implements the RFC requirement where a missing port should be interpreted as the default port for the received protocol.'}}]","The function includes explicit logic that checks for a missing port in the URI and assigns a default port based on the protocol scheme. This behavior directly addresses the RFC specification which allows interpreting a missing port as the default port. Since this is the only spec constraint in question and it is fully implemented within the function, the outcome is 'Fully Matches'.",success,
15546,ap_proxy_determine_connection,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Fully Matches,"[{'C1': {'code': 'if (!uri->hostname) {\n        return ap_proxyerror(r, HTTP_BAD_REQUEST,\n                             apr_pstrcat(p,""URI has no hostname: "", *url, NULL));\n    }', 'explanation': ""This code directly checks if the URI's hostname is missing (empty) and rejects it by returning an error. This fulfills the RFC requirement that an 'http' URI with an empty host identifier MUST be rejected.""}}]","The function parses the URI and immediately tests whether the hostname is present. If not, it returns an error, effectively enforcing the RFC mandate that an 'http' URI with an empty host identifier must not be processed. This logic is contained entirely within the function body, satisfying the relevant spec constraint.",success,
15546,ap_proxy_determine_connection,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'C1': {'code': 'if (APR_SUCCESS != apr_uri_parse(p, *url, uri)) {\n    return ap_proxyerror(r, HTTP_BAD_REQUEST,\n                         apr_pstrcat(p,""URI cannot be parsed: "", *url, NULL));\n}\n\nif (!uri->hostname) {\n    return ap_proxyerror(r, HTTP_BAD_REQUEST,\n                         apr_pstrcat(p,""URI has no hostname: "", *url, NULL));\n}', 'explanation': 'The function checks if the URI is invalid (cannot be parsed or missing hostname) and returns a 400 (Bad Request) error. This addresses part of the RFC requirement to respond with a 400 error when an invalid request-line is received.'}}]","The RFC requires that recipients of an invalid request-line respond with either a 400 error or a 301 redirect with the request-target properly encoded. In this function, invalid URIs are detected and a 400 error is returned, which partially complies with the spec. However, the function does not attempt to perform a 301 redirect or to encode the request-target, nor does it explicitly check for disallowed whitespace in the request-target. Therefore, the function only partially matches the specified requirement.",success,
15548,send_http_connect,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Fully Matches,"[{'C1': {'code': 'nbytes = apr_snprintf(buffer, sizeof(buffer), ""CONNECT %s:%d HTTP/1.0"" CRLF, forward->target_host, forward->target_port);\nif (forward->proxy_auth != NULL) {\n    nbytes += apr_snprintf(buffer + nbytes, sizeof(buffer) - nbytes, ""Proxy-Authorization: %s"" CRLF, forward->proxy_auth);\n}\nnbytes += apr_snprintf(buffer + nbytes, sizeof(buffer) - nbytes, ""Proxy-agent: %s"" CRLF CRLF, ap_get_server_banner());', 'explanation': 'The spec requires that the sender must not generate protocol elements or syntax alternatives reserved for other roles. This code constructs a CONNECT request using only the headers and syntax that are permitted to be generated by a sender, and no additional or role‐inappropriate elements are added.'}}]","The function constructs an HTTP CONNECT request in compliance with the specified RFC requirement by only generating protocol elements that are allowed for a sender. It does not include any elements that would be reserved for other roles, thereby fully addressing the constraint stated in the spec. All logic pertaining to the construction of the message is implemented within this function, meeting the requirement.",success,
15548,send_http_connect,A sender MUST NOT send whitespace between the start-line and the first header field.,295,Fully Matches,"[{'C1': {'code': 'nbytes = apr_snprintf(buffer, sizeof(buffer), ""CONNECT %s:%d HTTP/1.0"" CRLF, forward->target_host, forward->target_port);', 'explanation': 'This line constructs the start-line and appends a CRLF immediately, without any extraneous whitespace, ensuring the start-line is not followed by whitespace-only lines before the first header field.'}}, {'A1': {'code': 'nbytes += apr_snprintf(buffer + nbytes, sizeof(buffer) - nbytes, ""Proxy-Authorization: %s"" CRLF, forward->proxy_auth);\nnbytes += apr_snprintf(buffer + nbytes, sizeof(buffer) - nbytes, ""Proxy-agent: %s"" CRLF CRLF, ap_get_server_banner());', 'explanation': 'These lines concatenate subsequent header fields immediately after the start-line (and its CRLF), without inserting any additional whitespace-only lines. This ensures the request complies with the requirement to not send whitespace between the start-line and the first header field.'}}]","The function constructs the HTTP CONNECT request by first sending the start-line terminated correctly with a CRLF and then immediately appending valid header fields without any extraneous whitespace lines in between. Thus, the function visibly implements the RFC specification that a sender MUST NOT send whitespace between the start-line and the first header field.",success,
15568,ap_proxy_clear_connection,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'apr_table_unset(headers, ""Proxy-Connection"");\napr_table_do(find_conn_headers, &x, headers, ""Connection"", NULL);\napr_table_unset(headers, ""Connection"");\n\nif (x.array) {\n    int i;\n    for (i = 0; i < x.array->nelts; i++) {\n        const char *name = APR_ARRAY_IDX(x.array, i, const char *);\n        ...\n        apr_table_unset(headers, name);\n    }\n}', 'explanation': ""This code removes the 'Proxy-Connection' header and the 'Connection' header, and further unsets each header listed in the Connection header. By clearing these protocol elements, it helps ensure that headers which are only permitted to be generated by participants in specific roles are not present in the message.""}}]","The provided function implements a cleanup mechanism that removes connection-related headers from a message before it is sent. This behavior addresses the RFC requirement that a sender must not include protocol elements that are reserved for other roles. However, the function only handles header removal and related logging, and does not cover the full scope of possible protocol elements or syntax alternatives mentioned in the specification. Therefore, it only partially matches the constraint as implemented solely within this function.",success,
15568,ap_proxy_clear_connection,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'apr_table_do(find_conn_headers, &x, headers, ""Connection"", NULL);\n...\nif (x.error) {\n    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02806) ""Error parsing Connection header: %s"", x.error);\n    return -1;\n}\n...\nif (x.array) {\n    for (i = 0; i < x.array->nelts; i++) {\n        const char *name = APR_ARRAY_IDX(x.array, i, const char *);\n        ...\n        apr_table_unset(headers, name);\n    }\n}', 'explanation': ""The function inspects the 'Connection' header (and also removes the 'Proxy-Connection' header) by invoking a helper (find_conn_headers) which is expected to validate header content against the allowed grammar. On detecting an error (x.error), it logs the issue and aborts processing, thereby preventing non-conforming headers from being used. This addresses, albeit partially and only with respect to connection-specific headers, the requirement that a sender must not generate protocol elements that violate the defined ABNF grammar.""}}]","While the RFC mandates that a sender must not generate protocol elements that do not match the defined ABNF rules, this function only deals with sanitizing and clearing certain connection-related headers. It calls a helper to validate the 'Connection' header and actively removes potentially problematic fields. However, its scope is limited to connection header processing, and it does not encompass all protocol element validations defined by the RFC. Therefore, the implementation in this function only partially matches the overall constraint.",success,
15569,ap_proxy_create_hdrbrgd,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'if ((*old_te_val = (char *)apr_table_get(r->headers_in, ""Transfer-Encoding""))) {\n    apr_table_unset(r->headers_in, ""Transfer-Encoding"");\n}\nif ((*old_cl_val = (char *)apr_table_get(r->headers_in, ""Content-Length""))) {\n    apr_table_unset(r->headers_in, ""Content-Length"");\n}', 'explanation': 'This code segment retrieves the existing Transfer-Encoding and Content-Length headers and then unsets both from the headers table. As a result, if a Transfer-Encoding header is present, the Content-Length header is removed, thereby ensuring that no message is sent with a Content-Length header when a Transfer-Encoding header exists, which fulfills the HTTP RFC requirement.'}}]","The function explicitly clears both the Transfer-Encoding and Content-Length headers from the request headers before forwarding them. By doing so, it ensures compliance with the RFC constraint that prohibits sending a Content-Length header in messages that include a Transfer-Encoding header. This logic is implemented directly within the function body and thus fully matches the specified constraint.",success,
15569,ap_proxy_create_hdrbrgd,A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 requests (or later minor revisions); such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response.,196,Partially Matches,"[{'A1': {'code': 'if ((*old_te_val = (char *)apr_table_get(r->headers_in, ""Transfer-Encoding""))) {\n    apr_table_unset(r->headers_in, ""Transfer-Encoding"");\n}', 'explanation': 'The function explicitly retrieves any Transfer-Encoding header from the incoming request and then unsets (removes) it before forwarding. This action is in line with the RFC requirement that a client MUST NOT send a request containing Transfer-Encoding unless it is sure that the server supports HTTP/1.1. By unconditionally clearing the header, the function avoids sending Transfer-Encoding regardless of whether the server is known to handle HTTP/1.1, thereby partially addressing the spec.'}}]","The RFC specifies that a request should not contain the Transfer-Encoding header unless the client is certain the server supports HTTP/1.1. This function takes a precautionary measure by removing any Transfer-Encoding header from the forwarded request. However, instead of conditionally allowing the header when the target server is known to support HTTP/1.1, the function always removes it (even if the request line is constructed as HTTP/1.1, unless forced to use HTTP/1.0). Thus, while the function does implement the safe removal of the Transfer-Encoding header (fulfilling one aspect of the RFC), it does not incorporate logic to conditionally include it when appropriate. Therefore, the implementation within this function only partially matches the RFC constraint.",success,
15569,ap_proxy_create_hdrbrgd,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (force10 || apr_table_get(r->subprocess_env, ""proxy-nokeepalive"")) {\n    if (origin) {\n        origin->keepalive = AP_CONN_CLOSE;\n    }\n    p_conn->close = 1;\n}', 'explanation': ""This segment checks for conditions (e.g., forcing HTTP/1.0 or a 'proxy-nokeepalive' flag) and then marks the connection to be closed. This is in line with the RFC’s allowance for a proxy to close the transport connection at any time. However, only connection closing is addressed, and the function does not manage additional aspects of graceful closure as recommended in the context, so it only partially meets the overall RFC guidance.""}}]","The RFC specifies that a client, server, or proxy MAY close the transport connection at any time, and implementations should handle graceful closures. In this function, there is logic that sets the connection’s close flags if certain conditions (such as force-proxy-request-1.0 or proxy-nokeepalive flags) are met. This directly addresses the possibility of closing the connection, matching one of the spec’s conditions (labeled here as C1). However, since the function does not implement the full spectrum of graceful closure behavior outlined in the spec context (such as monitoring for idle connections and proper resource reclamation), the implementation only partially matches the RFC requirements within the confines of this function.",success,
15569,ap_proxy_create_hdrbrgd,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'if ((*old_cl_val = (char *)apr_table_get(r->headers_in, ""Content-Length""))) {\n    apr_table_unset(r->headers_in, ""Content-Length"");\n}', 'explanation': 'This segment removes the Content-Length header from the forwarded headers. By unsetting the header (and storing its original value, if needed), the function avoids sending a potentially incorrect Content-Length value. However, it does not validate whether the header is incorrect or handle the special case exception (identical comma‐separated duplicate values), so it only partially implements the RFC requirement.'}}]","The RFC mandates that a sender MUST NOT forward a message with a Content-Length header if it is known to be incorrect. This function proactively strips the Content-Length header (and Transfer-Encoding) from the incoming headers before forwarding, thereby reducing the risk of forwarding an incorrect header. However, the function does not inspect or verify the correctness of the Content-Length value, nor does it implement the exception for comma‐separated duplicate values. Therefore, while the function addresses the removal of the header (action A1), it only partially meets the complete set of requirements described in the RFC.",success,
15569,ap_proxy_create_hdrbrgd,A server that receives an Upgrade header field in an HTTP/1.0 request MUST ignore that Upgrade field.,32,Fully Matches,"[{'C1': {'code': 'apr_table_unset(r->headers_in, ""Upgrade"");', 'explanation': ""This code unconditionally removes the 'Upgrade' header from the incoming header table. This ensures that when handling an HTTP/1.0 request (or any request), the Upgrade header is ignored, which complies with the RFC requirement that a server receiving an Upgrade header in an HTTP/1.0 request must ignore it.""}}]","The function explicitly clears the 'Upgrade' header from the headers that are forwarded to the backend. Although it removes the header in all cases rather than only for HTTP/1.0 requests, this approach satisfies the RFC specification that requires an HTTP/1.0 server to ignore the Upgrade header. Therefore, the function fully matches the specified constraint as implemented within the function_body.",success,
15569,ap_proxy_create_hdrbrgd,A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection.,25,Fully Matches,"[{'A1': {'code': 'apr_table_unset(r->headers_in, ""Upgrade"");', 'explanation': ""This line explicitly removes the 'Upgrade' header from the request headers, which is equivalent to ignoring any received Upgrade header as allowed by the RFC. By stripping the Upgrade header, the server signals that it is continuing with the current protocol, thus fulfilling the spec requirement.""}}]","The function includes logic to remove the 'Upgrade' header (using apr_table_unset), thereby ignoring any protocol change request supplied via this header. This directly implements the RFC behavior that a server may ignore a received Upgrade header if it wishes to continue using the current protocol on that connection. All relevant handling for this specific spec constraint is visible within the function_body.",success,
15569,ap_proxy_create_hdrbrgd,"However, comments in Via are optional, and a recipient MAY remove them prior to forwarding the message.",24,Fully Matches,"[{'C1': {'code': 'if (conf->viaopt == via_block) {\n    apr_table_unset(r->headers_in, ""Via"");\n} else if (conf->viaopt != via_off) {\n    const char *server_name = ap_get_server_name(r);\n    if (server_name == r->hostname)\n        server_name = r->server->server_hostname;\n    apr_table_mergen(r->headers_in, ""Via"",\n                     (conf->viaopt == via_full)\n                     ? apr_psprintf(r->pool, ""%d.%d %s%s (%s)"",\n                                    HTTP_VERSION_MAJOR(r->proto_num),\n                                    HTTP_VERSION_MINOR(r->proto_num),\n                                    server_name, server_portstr,\n                                    AP_SERVER_BASEVERSION)\n                     : apr_psprintf(r->pool, ""%d.%d %s%s"",\n                                    HTTP_VERSION_MAJOR(r->proto_num),\n                                    HTTP_VERSION_MINOR(r->proto_num),\n                                    server_name, server_portstr)\n                     );\n}', 'explanation': 'This code block implements the RFC requirement regarding the optional nature of Via header comments. It either removes the Via header altogether (if viaopt is set to block) or adds it—with an optional comment if via_full is configured—thus allowing a recipient to not forward the comment, in line with the spec stating that comments in Via are optional.'}}]","The function 'ap_proxy_create_hdrbrgd' explicitly handles the Via header in accordance with the RFC specification. It gives the option to remove the header entirely or add it with or without a comment, depending on the configuration (using conf->viaopt). This visible logic directly addresses the spec requirement that comments in Via are optional and may be removed prior to forwarding, thereby fully matching the constraint.",success,
15569,ap_proxy_create_hdrbrgd,"Likewise, a sender MUST NOT forward a message with a Content-Length header field value that does not match the ABNF above, with one exception: a recipient of a Content-Length header field value consisting of the same decimal value repeated as a comma-separated list (e.g, ""Content-Length: 42, 42"") MAY either reject the message as invalid or replace that invalid field value with a single instance of the decimal value, since this likely indicates that a duplicate was generated or combined by an upstream message processor.",49,Does Not Match,[],"The provided function does not contain any logic to validate the Content-Length header field value in accordance with the RFC specification. While it does remove the Content-Length header (and Transfer-Encoding) from the forwarded request, it does not perform any checks to ensure that the value matches the proper ABNF, nor does it address the special case for a comma‐separated list of the same decimal value (e.g., '42, 42'). All relevant RFC constraints (e.g., ensuring correctness of the Content-Length value) are not implemented within this function, and thus it does not meet the specified conditions.",success,
15587,proxy_tunnel_transfer,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Does Not Match,[],"The provided function focuses on transferring data between two connections and handling read/write shutdown events rather than actively managing or sustaining persistent connections as the RFC specifies. It checks for conditions such as incomplete reads, EOF, and failure scenarios, and decides whether to tear down the connection (or set the half-close flags) based on those situations. However, it does not include any logic that explicitly supports or sustains persistent connections, or that leverages underlying transport flow-control mechanisms to defer closing connections when overloaded. All connection lifecycle decisions (like returning DONE or marking a side as shutdown) occur based on immediate conditions without an attempt to maintain the connection persistently in the sense required by the spec. Therefore, no part of the function implements the specific persistent connection requirements described in the RFC.",success,
15588,ap_proxy_tunnel_run,"Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.",315,Fully Matches,"[{'C1': {'code': 'do {\n    ...\n    rv = apr_pollset_poll(pollset, timeout, &nresults, &results);\n    ...\n    for (i = 0; i < nresults; i++) {\n        ...\n        if ((tc->pfd->reqevents & APR_POLLIN) && ((pfd->rtnevents & (APR_POLLIN | APR_POLLHUP)) || !(pfd->rtnevents & APR_POLLOUT))) {\n            rc = proxy_tunnel_transfer(tunnel, tc);\n            if (rc != OK) {\n                status = rc;\n                goto done;\n            }\n        }\n        ...\n    }\n} while (!client->down_out || !origin->down_out);', 'explanation': 'The function continuously polls the connection sockets (using apr_pollset_poll and a loop that only exits when both directions are marked as closed) to detect events such as POLLHUP, which indicates that a side has been closed. This fulfills the requirement of constantly monitoring the connection for closure signals.'}}, {'A1': {'code': 'if ((tc->pfd->reqevents & APR_POLLOUT) && ((pfd->rtnevents & APR_POLLOUT) || !(tc->pfd->reqevents & APR_POLLIN) || !(pfd->rtnevents & (APR_POLLIN | APR_POLLHUP)))) {\n    ...\n    del_pollset(pollset, out->pfd, APR_POLLOUT);\n    if (in->down_in) {\n        apr_socket_shutdown(out->pfd->desc.s, 1);\n        out->down_out = 1;\n    }\n    ...\n}', 'explanation': 'Upon detecting that the other side is no longer readable (down_in is set), the code responds by shutting down the write direction (using apr_socket_shutdown) to gracefully terminate the connection, thus reclaiming system resources. This action meets the requirement to respond appropriately to a closure signal.'}}]","The provided function implements a tunneling mechanism that continuously monitors both the client and origin sockets for events that indicate closure (such as POLLHUP) by actively polling. When a closure condition is detected, it takes immediate actions (like shutting down the write side of the socket) to promptly close the connection. This behavior directly corresponds to the RFC's recommendation to monitor and promptly close idle or closed connections in order to reclaim resources. The logic is contained entirely within the code of the function, meeting the specification requirements as stated.",success,
15592,proxy_balancer_canon,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function performs URL canonicalization by stripping a ""balancer:"" prefix, parsing the network location, and constructing a proxy URL. However, none of its internal logic checks or enforces the specific HTTP RFC requirement that a sender must not generate protocol elements or syntax alternatives reserved for other roles. Although it performs syntactic checks (via the call to ap_proxy_canon_netloc), this is a generic URL validation and does not address the role-based restrictions detailed in the spec. Therefore, no part of the code directly implements any of the labeled conditions (such as C1) or actions (such as A1) associated with the spec constraints.",success,
15592,proxy_balancer_canon,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'A1': {'code': 'if (err) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01157)\n                  ""error parsing URL %s: %s"",\n                  url, err);\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'When URL parsing fails (which likely includes invalid request-line cases), the function responds with a 400 (Bad Request) error. This matches one of the RFC’s allowed response types for handling an invalid request-line.'}}]","The function only partially addresses the RFC requirements. It does implement returning a 400 error (A1) when URL parsing encounters an error, thereby fulfilling one of the required responses. However, it does not implement the alternative behavior of issuing a 301 (Moved Permanently) redirect with a properly encoded request-target. Hence, only part of the specification is directly handled in this function.",success,
15594,get_path_param,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function 'get_path_param' is designed to locate and extract a parameter value from a URL string using simple substring matching and tokenization. It does not check or enforce that the parameter or any generated protocol element conforms to the ABNF grammar as required by the specified RFC. There is no visible logic within the function addressing any condition (e.g., C1) that prohibits generating protocol elements not matching the defined ABNF grammar, nor any action (e.g., A1) implementing conformance checks. Therefore, the code function does not meet the spec constraints.",success,
15595,get_cookie_param,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,"[{'C1': {'code': 'while(*start_cookie && isspace(*start_cookie))\n    ++start_cookie;', 'explanation': 'The function explicitly skips over whitespace characters immediately after identifying the cookie name. This shows an attempt to remove bad whitespace as required by the RFC before interpreting the protocol element. However, the approach is limited to trimming whitespace after the cookie name and does not comprehensively address all potential cases of bad whitespace removal mandated by the RFC.'}}]","The function _get_cookie_param attempts a partial implementation of the RFC requirement to remove bad whitespace by trimming leading whitespace after the cookie name. Specifically, it uses a loop to move past any whitespace characters before checking for the '=' sign and extracting the cookie value. This addresses part of the condition (C1) described in the specification. However, because it only removes whitespace in a narrow context (just after the cookie name) and does not address other areas where bad whitespace might occur according to the RFC (such as within other protocol elements or across the entire header), the implementation is considered only a partial match to the spec.",success,
15595,get_cookie_param,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': 'while(*start_cookie && isspace(*start_cookie))\n                    ++start_cookie;', 'explanation': ""This loop explicitly skips over any whitespace (BWS) present after the cookie name, ensuring that any 'bad whitespace' is removed before further processing, thus fulfilling the RFC requirement.""}}]","The RFC specifies that any 'bad whitespace' (BWS) may be removed and must be stripped by the recipient prior to interpreting protocol elements. In this function, after identifying the cookie parameter name, the code advances the pointer over any whitespace using a while loop with isspace. This directly implements the removal of BWS as mandated by the spec, and therefore the function fully matches the given constraint within its own logic.",success,
15595,get_cookie_param,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Partially Matches,"[{'A1': {'code': 'while(*start_cookie && isspace(*start_cookie))\n    ++start_cookie;', 'explanation': ""This loop skips over any whitespace immediately after the cookie name before checking for the '=' sign. This shows an attempt at excluding whitespace prior to evaluating the cookie value, which corresponds to the spec requirement. However, the function does not further trim any trailing whitespace from the extracted value, and its treatment is specific to cookie parsing rather than full field value trimming.""}}]","The RFC specifies that implementations must exclude whitespace from the field value before evaluating it. The function addresses this through a while loop that increments the pointer while isspace() is true, thereby removing whitespace that immediately follows the cookie name before the '=' character is evaluated. Although this indicates an effort to implement the requirement, it only partially meets the broader specification (for example it does not remove trailing whitespace and is applied in a limited context), and so overall it only partially matches the spec as implemented in this function.",success,
15600,force_recovery,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'if (!((*worker)->s->status & PROXY_WORKER_IN_ERROR)) {\n    ok = 1;\n    break;\n}\nelse {\n    /* Try if we can recover */\n    ap_proxy_retry_worker_fn(""BALANCER"", *worker, s);\n    if (!((*worker)->s->status & PROXY_WORKER_IN_ERROR)) {\n        ok = 1;\n        break;\n    }\n}', 'explanation': 'This segment checks whether a worker is already not in an error state or can be recovered via a retry function, aligning with the RFC notion that a recipient may recover a usable protocol element from an invalid construct.'}}, {'A1': {'code': 'if (!ok && balancer->s->forcerecovery) {\n    /* If all workers are in error state force the recovery. */\n    worker = (proxy_worker **)balancer->workers->elts;\n    for (i = 0; i < balancer->workers->nelts; i++, worker++) {\n        ++(*worker)->s->retries;\n        (*worker)->s->status &= ~PROXY_WORKER_IN_ERROR;\n        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01165)\n                     ""%s: Forcing recovery for worker (%s:%d)"",\n                     balancer->s->name, (*worker)->s->hostname_ex,\n                     (int)(*worker)->s->port);\n    }\n}', 'explanation': 'This segment forces a recovery on all workers if none can be recovered normally, embodying a recovery action from an invalid construct as loosely permitted by the RFC.'}}]","The function 'force_recovery' includes logic to check the status of workers and attempts to recover from error conditions by invoking a retry mechanism and, if necessary, forcing recovery. This behavior is in line with the RFC statement that a recipient may attempt to recover a valid element from an invalid construct. However, because the function only addresses these recovery actions and does not fully implement all potential error-handling nuances defined by the HTTP RFC (e.g., distinguishing recovery strategies based on broader context), it only partially meets the spec constraints.",success,
15609,push2table,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function simply parses a URL-encoded query string and stores key/value pairs in a table (optionally checking against an allowed list). There is no logic found in the function that evaluates or enforces that the sender does not generate protocol elements or syntax alternatives reserved for other roles, as mandated by the RFC. Thus, the function does not implement the spec constraint regarding role-based protocol element generation.",success,
15612,balancer_display_page,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'if (usexml) {\n    ap_set_content_type_ex(r, ""text/xml"", 1);\n    ...\n} else {\n    ap_set_content_type_ex(r, ""text/html; charset=ISO-8859-1"", 1);\n    ...\n}', 'explanation': 'The function explicitly sets the Content-Type header using ap_set_content_type_ex in both branches (XML and HTML). This directly implements the RFC requirement that a sender generating a message with content SHOULD include a Content-Type header, thereby fulfilling the spec.'}}]","The analyzed function includes direct calls to set the Content-Type header regardless of the output format, ensuring that whenever content is generated, a Content-Type header is provided. This implementation within the function satisfies the RFC specification regarding the presence of the Content-Type header, and thus the function fully matches the constraint.",success,
15613,safe_referer,A recipient that processes such a URI reference MUST reject it as invalid.,226,Partially Matches,"[{'C1': {'code': 'if (apr_uri_parse(r->pool, ref, &uri) || !uri.hostname)\n        return 0;', 'explanation': 'This code segment checks that the URI has a non-empty hostname, fulfilling the RFC requirement that a recipient MUST reject an HTTPS URI with an empty host identifier.'}}]","The function verifies that the URI parsing succeeds and that the hostname is present, which addresses the RFC constraint regarding rejecting URIs with empty host identifiers. However, it does not address other aspects of HTTPS URI processing outlined in the spec (e.g., scheme validation, port defaults), so it only partially implements the full specification.",success,
15613,safe_referer,A recipient that processes such a URI reference MUST reject it as invalid.,224,Partially Matches,"[{'C1': {'code': 'if (apr_uri_parse(r->pool, ref, &uri) || !uri.hostname)\n        return 0;', 'explanation': ""This segment checks for an empty host by verifying '!uri.hostname' after parsing the URI. Since the specification states that URIs with empty host identifiers MUST be rejected, this code directly implements that part of the spec.""}}]","The function attempts to implement the RFC requirement by rejecting URI references that have an empty host identifier, evident in the check for (!uri.hostname). However, it does not directly address other parts of the specification such as verifying the default port or other authority details. Therefore, the function only partially matches the spec constraints.",success,
15613,safe_referer,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (apr_uri_parse(r->pool, ref, &uri) || !uri.hostname)\n    return 0;', 'explanation': 'The code defensively attempts to parse the input referer using apr_uri_parse and checks that a hostname was provided. This addresses the defensive parsing aspect of the spec that the element may only marginally conform to its grammar. However, it does not explicitly verify that the parsed element fits within a reasonable buffer size, so it only partially meets the overall requirements.'}}]","The safe_referer function demonstrates a defensive parsing strategy by calling apr_uri_parse and checking for a valid hostname, which aligns with the spec's recommendation to parse cautiously. Nevertheless, it does not include logic for verifying buffer lengths or handling explicitly oversized inputs, leaving part of the spec unaddressed within the function's own code.",success,
15614,balancer_handler,"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT",71,Fully Matches,"[{'C1': {'code': 'r->allowed = 0\n    | (AP_METHOD_BIT << M_GET)\n    | (AP_METHOD_BIT << M_POST);\nif ((r->method_number != M_GET) && (r->method_number != M_POST)) {\n    return DECLINED;\n}', 'explanation': ""The function explicitly restricts allowed methods to GET and POST and declines requests that are not one of these methods (e.g., PUT). This aligns with the spec's provision that state-changing requests meant for URI selection must be handled using POST rather than PUT.""}}, {'A1': {'code': ""if (r->method_number == M_POST) {\n    apr_bucket_brigade *ib;\n    apr_size_t len = 1024;\n    char *buf = apr_pcalloc(r->pool, len+1);\n\n    ib = apr_brigade_create(r->connection->pool, r->connection->bucket_alloc);\n    rv = ap_get_brigade(r->input_filters, ib, AP_MODE_READBYTES,\n                            APR_BLOCK_READ, len);\n    if (rv != APR_SUCCESS) {\n        return ap_map_http_request_error(rv, HTTP_BAD_REQUEST);\n    }\n    apr_brigade_flatten(ib, buf, &len);\n    buf[len] = '\\0';\n    push2table(buf, params, NULL, r->pool);\n}"", 'explanation': 'This block shows that the function processes POST requests by reading the enclosed representation, which confirms that the intended state-changing operation is performed using POST, as required by the spec.'}}]","The code function exclusively permits GET and POST methods by explicitly checking the HTTP method and declines any request that is not GET or POST (thus excluding PUT). Furthermore, it processes the POST request body to handle state-changing operations. These implementations directly address the RFC specification that a service selecting a URI based on a state-changing request should use POST rather than PUT.",success,
15621,scgi_canon,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'port = def_port = SCGI_DEF_PORT;\n...\nif (port != def_port) {\n    apr_snprintf(sport, sizeof(sport), "":%u"", port);\n} else {\n    sport[0] = \'\\0\';\n}', 'explanation': 'The code sets the default port (SCGI_DEF_PORT) and subsequently checks if the parsed port differs from this default. If a port is not provided (i.e. remains as the default), it omits appending an explicit port in the resulting URL, thereby adhering to the RFC specification.'}}]","The function correctly implements the RFC requirement by initializing a default port value and then using it when no alternative port is specified. This logic, contained entirely within the function, directly addresses the specified condition from the RFC.",success,
15621,scgi_canon,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Fully Matches,"[{'C1': {'code': 'if (err) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00857)\n                  ""error parsing URL %s: %s"", url, err);\n    return HTTP_BAD_REQUEST;\n}\n\n...\n\npath = ap_proxy_canonenc_ex(r->pool, url, strlen(url), enc_path, flags, r->proxyreq);\nif (!path) {\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'The RFC states that a recipient of an invalid request‐line should respond with either a 400 error or a 301 redirect with a properly encoded request-target. This code verifies the URL and its parts. When parsing the netloc fails (or the canonical encoding of the path fails), it responds by returning a 400 (Bad Request) error, which conforms to the acceptable behavior.'}}, {'A1': {'code': 'path = ap_proxy_canonenc_ex(r->pool, url, strlen(url), enc_path, flags, r->proxyreq);\nif (!path) {\n    return HTTP_BAD_REQUEST;\n}\n\nr->filename = apr_pstrcat(r->pool, ""proxy:"" SCHEME ""://"", host, sport, ""/"", path, NULL);', 'explanation': 'By canonicalizing the request-target (using ap_proxy_canonenc_ex) and constructing a properly encoded filename only when encoding succeeds, the function ensures that a mis-encoded or otherwise malformed request-target leads to an error (HTTP 400). This matches the RFC requirement of either returning an error or a redirection when the request-line is invalid.'}}]","The function focuses on processing and canonicalizing the SCGI URL. In doing so, it checks for errors during the URL parsing and path encoding stages. If any errors occur (for example, if disallowed characters like whitespace result in an invalid request-target), the function returns a 400 Bad Request error. This behavior meets the RFC requirement since clients must be given either a 400 response or a 301 redirect in such cases. Therefore, within the scope of its own logic, the function fully implements the specified requirement.",success,
15625,pass_response,"Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response (Section 15.4.5 of [HTTP]) to a GET request, neither of which includes a message body, to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET.",192,Does Not Match,[],"The function unconditionally removes the Transfer-Encoding header via the call to apr_table_unset(r->headers_out, ""Transfer-Encoding"") without checking the response type or status code. According to the RFC spec, Transfer-Encoding MAY be present in responses to HEAD requests or a 304 response to a GET in order to indicate that a transfer coding would have been applied if a message body were included. Since this function does not implement any conditional handling for such cases and simply strips out the header regardless, it does not visibly address the RFC requirements.",success,
15625,pass_response,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'if (!apr_table_get(r->subprocess_env, AP_TRUST_CGILIKE_CL_ENVVAR))\n    apr_table_unset(r->headers_out, ""Content-Length"");\napr_table_unset(r->headers_out, ""Transfer-Encoding"");', 'explanation': ""The code explicitly unsets the 'Transfer-Encoding' header and conditionally removes the 'Content-Length' header. By removing 'Transfer-Encoding' unconditionally, it prevents any scenario where both headers could be present, thereby complying with the RFC specification that a message containing a 'Transfer-Encoding' header should not include a 'Content-Length' header.""}}]","The function ensures compliance with the RFC requirement by always removing the 'Transfer-Encoding' header and, in certain cases, also removing the 'Content-Length' header. This built‐in logic avoids sending a message that contains both headers, thus meeting the specified condition in the HTTP RFC.",success,
15625,pass_response,A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 requests (or later minor revisions); such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response.,196,Partially Matches,"[{'A1': {'code': 'apr_table_unset(r->headers_out, ""Transfer-Encoding"");', 'explanation': ""This line removes any Transfer-Encoding header from the outgoing response. In doing so, the code attempts to satisfy the specification that a server MUST NOT send a response containing Transfer-Encoding unless special conditions are met. However, it does so unconditionally without checking if the request indicated HTTP/1.1, so it only partially implements the spec's requirement.""}}]","Although the RFC specifies conditions regarding when Transfer-Encoding may be present in a response (i.e. only when the request indicates HTTP/1.1), the code function unconditionally clears the Transfer-Encoding header. This approach addresses part of the spec by ensuring that a Transfer-Encoding header is not included in the response, but it does not conditionally check the HTTP version of the corresponding request. Moreover, the client-side condition about not sending a request with Transfer-Encoding under uncertain circumstances is not handled in this function at all. Therefore, only part of the spec constraint is visibly implemented within the function_body.",success,
15625,pass_response,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'if (!apr_table_get(r->subprocess_env, AP_TRUST_CGILIKE_CL_ENVVAR))\n    apr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'This code removes the Content-Length header when the environment does not indicate that the header can be trusted. In doing so, it attempts to prevent forwarding a Content-Length that might be incorrect, which is in line with the RFC requirement.'}}]","The RFC requires that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect. In this function, the header is removed via apr_table_unset() based on the absence of a trusted environment variable. This removal is intended to avoid forwarding a problematic Content-Length header. However, the function does not explicitly validate the correctness of the Content-Length value; instead, it relies on a configuration flag. Therefore, while the function makes a visible attempt to satisfy the RFC by not forwarding potentially incorrect Content-Length headers, it does not fully check or verify correctness within its own logic. Consequently, the function only partially matches the RFC constraint.",success,
15626,scgi_request_status,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function scgi_request_status does not include any logic that addresses the RFC constraint regarding the handling of multiple header field lines, their order, or combining values into comma-separated lists. The code focuses on internal redirects and file subrequests without any verification or adjustment of header field ordering or the prevention of generating duplicate header names. Therefore, no part of the function implements the conditions (C1, etc.) or actions (A1, etc.) specified in the HTTP RFC.",success,
15626,scgi_request_status,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'apr_table_unset(r->headers_in, ""Content-Length"");', 'explanation': ""In the scgi_internal_redirect case, the code unconditionally removes the 'Content-Length' header. This directly prevents forwarding any Content-Length value, which partially meets the spec requirement to not forward a message with an incorrect Content-Length field. However, the code does not verify whether the Content-Length is known to be incorrect nor does it handle the case of comma-separated repeated values as described in the specification.""}}]","The RFC requires that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect (and possibly handle repeated values). The function implements a measure in the internal redirect branch by unsetting the 'Content-Length' header, thereby preventing its forwarding. However, it does not include any logic to check if the header value is actually known to be incorrect, nor does it handle the allowed exceptions for repeated decimal values. Additionally, in the 'scgi_sendfile' case, the function explicitly decides not to touch the Content-Length header due to potential race conditions. Thus, only some aspects of the spec are addressed in this function.",success,
15643,proxy_ftp_canon,"A sender MUST NOT generate the userinfo subcomponent (and its ""@"" delimiter) when an ""http"" or ""https"" URI reference is generated within a message as a target URI or field value.",229,Does Not Match,[],"The RFC specification requires that a sender MUST NOT generate the userinfo subcomponent (and its '@' delimiter) when an http or https URI is generated. This function, however, is dedicated to handling FTP URLs (as evidenced by its check for ""ftp:"" and the construction of a URL starting with ""proxy:ftp://""). It also includes logic that incorporates user and password information into the constructed URL when present. Since the function does not process http/https URLs and does not attempt to omit the userinfo component when required by the RFC for those schemes, no part of the function addresses the specified constraint.",success,
15643,proxy_ftp_canon,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'A1': {'code': 'if (err)\n    return HTTP_BAD_REQUEST;\nif (user != NULL && !ftp_check_string(user))\n    return HTTP_BAD_REQUEST;\nif (password != NULL && !ftp_check_string(password))\n    return HTTP_BAD_REQUEST;\n...\nif (path == NULL)\n    return HTTP_BAD_REQUEST;\nif (!ftp_check_string(path))\n    return HTTP_BAD_REQUEST;', 'explanation': 'The function verifies various parts of the FTP URL and returns a HTTP_BAD_REQUEST error when it detects an invalid component (e.g., an error from canonicalizing the network location, or invalid user/password/path strings). This addresses the spec recommendation to respond with a 400 (Bad Request) in the presence of a malformed request-line. However, since the spec also permits a 301 redirect with a properly encoded request-target and the function does not implement any redirect logic, only part of the behavior is covered.'}}]","The provided function performs canonicalization of FTP URLs and, upon detecting invalid input (such as errors in parsing, or failing validation via ftp_check_string), immediately returns a HTTP_BAD_REQUEST, which aligns with one path described by the RFC (responding with a 400 error). However, the RFC also allows a 301 (Moved Permanently) redirect with a properly encoded request-target if the request-line is invalid. The function contains no logic to issue a 301 redirect, nor does it make any attempt to correct or re-encode a malformed request-line for redirection. Therefore, in isolation, the function partially meets the spec constraints by handling the 400 error response but not the alternative 301 redirect action.",success,
15645,proxy_send_dir_filter,"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",225,Does Not Match,[],"The provided function_body does not contain any logic that checks whether the generated 'https' URI has an empty host identifier. Although the function constructs the URL (using functions like ap_construct_url and apr_uri_unparse), there is no conditional statement or verification to ensure that the host component is non-empty. Therefore, the function does not implement the required constraint from the RFC (labeled C1: 'A sender MUST NOT generate an ""https"" URI with an empty host identifier').",success,
15645,proxy_send_dir_filter,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC specifies that a sender MUST NOT generate protocol elements that do not match the grammar defined by the ABNF rules. In reviewing the function_body, although it makes use of escaping functions (such as ap_escape_html and ap_escape_uri) and constructs URLs and HTML output, there is no explicit logic within this function that validates or ensures that the generated protocol elements conform to the ABNF grammar. All the measures (e.g., escaping, concatenation) are aimed at correctly formatting an HTML directory listing rather than verifying strict protocol grammar compliance. Therefore, the function does not visibly implement the specific RFC requirement within its own logic.",success,
15645,proxy_send_dir_filter,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, proxy_send_dir_filter, is primarily concerned with constructing and sending an HTML directory listing—formatting links, escaping URIs and HTML, and processing directory data. It does not contain any explicit logic or checks that prevent the generation of protocol elements that are reserved for participants in other roles (per the spec requirement that a sender MUST NOT generate such elements). Although there is some conditional behavior (for example, checking if the request is a reverse proxy), this merely chooses between URL construction methods and does not enforce role-based restrictions on protocol element generation. Thus, within the function_body itself, there is no implementation addressing the specific HTTP RFC constraint.",success,
15650,ftp_unauthorized,"Upon receipt of a request for a protected resource that omits credentials, contains invalid credentials (e.g., a bad password) or partial credentials (e.g., when the authentication scheme requires more than one round trip), an origin server SHOULD send a 401 (Unauthorized) response that contains a WWW-Authenticate header field with at least one (possibly new) challenge applicable to the requested resource.",91,Fully Matches,"[{'C1': {'code': 'apr_table_setn(r->err_headers_out, ""WWW-Authenticate"", apr_pstrcat(r->pool, ""Basic realm=\\"""", apr_uri_unparse(r->pool, &r->parsed_uri, APR_URI_UNP_OMITPASSWORD | APR_URI_UNP_OMITPATHINFO), ""\\"""", NULL));', 'explanation': 'This code sets the WWW-Authenticate header with a challenge, thereby addressing the requirement to provide a challenge when credentials are missing, invalid, or partial.'}}, {'A1': {'code': 'return HTTP_UNAUTHORIZED;', 'explanation': ""Returning HTTP_UNAUTHORIZED (401) directly meets the specification's directive to send a 401 response under these circumstances.""}}]","The function ftp_unauthorized directly implements key parts of the RFC requirement for handling unauthorized access. It sets the WWW-Authenticate header with a challenge and returns a 401 status code, thereby fully addressing the conditions and actions specified in the RFC. All logic fulfilling these requirements is contained within this function.",success,
15650,ftp_unauthorized,A server MAY generate a WWW-Authenticate header field in other response messages to indicate that supplying credentials (or different credentials) might affect the response.,93,Fully Matches,"[{'C1': {'code': 'apr_table_setn(r->err_headers_out, ""WWW-Authenticate"",\n               apr_pstrcat(r->pool, ""Basic realm=\\"""",\n                           apr_uri_unparse(r->pool, &r->parsed_uri,\n                                           APR_URI_UNP_OMITPASSWORD | APR_URI_UNP_OMITPATHINFO),\n                           ""\\"""", NULL));', 'explanation': 'This segment sets the WWW-Authenticate header with a Basic realm challenge as required when returning a 401 Unauthorized response.'}}, {'A1': {'code': 'return HTTP_UNAUTHORIZED;', 'explanation': 'Returning HTTP_UNAUTHORIZED (401) ensures that the response mandates the inclusion of the WWW-Authenticate header, fulfilling the required action of challenging the client.'}}]","The function directly implements the spec by setting a WWW-Authenticate header with a basic authentication challenge, and by returning a 401 Unauthorized response, it fully meets the RFC requirement that a 401 response must include at least one authentication challenge. All relevant logic is contained within the function, independent of external dependencies.",success,
15650,ftp_unauthorized,A server generating a 401 (Unauthorized) response MUST send a WWW-Authenticate header field containing at least one challenge.,92,Fully Matches,"[{'C1': {'code': 'apr_table_setn(r->err_headers_out, ""WWW-Authenticate"",\n               apr_pstrcat(r->pool, ""Basic realm=\\"""",\n                           apr_uri_unparse(r->pool, &r->parsed_uri, APR_URI_UNP_OMITPASSWORD | APR_URI_UNP_OMITPATHINFO),\n                           ""\\"""", NULL));', 'explanation': 'This code explicitly sets the WWW-Authenticate header in the 401 response, providing a Basic realm challenge as required by the RFC specification.'}}]","The function directly addresses the RFC requirement by including a WWW-Authenticate header with at least one challenge when returning a 401 (Unauthorized) response. The relevant code segment creates a Basic authentication challenge, thereby fully satisfying the specified condition.",success,
15650,ftp_unauthorized,"A sender SHOULD NOT generate a quoted-pair in a comment except where necessary to quote parentheses [""("" and "")""] and backslash octets occurring within that comment.",243,Does Not Match,[],"The RFC specification requires that a sender should not generate a quoted-pair in a comment except where necessary for quoting parentheses and backslash octets. In the provided function, there is no logic related to processing or avoiding quoted-pairs in a comment. The function only constructs a header (WWW-Authenticate) with a Basic realm value and uses string concatenation without handling any escaping of characters. Therefore, the function does not visibly address the constraint regarding quoted-pairs in comments as specified in the RFC.",success,
15650,ftp_unauthorized,The server generating a 401 response MUST send a WWW-Authenticate header field (Section 11.6.1) containing at least one challenge applicable to the target resource.,162,Fully Matches,"[{'C1': {'code': 'apr_table_setn(r->err_headers_out, ""WWW-Authenticate"",\n               apr_pstrcat(r->pool, ""Basic realm=\\"""",\n                           apr_uri_unparse(r->pool, &r->parsed_uri, APR_URI_UNP_OMITPASSWORD | APR_URI_UNP_OMITPATHINFO),\n                           ""\\"""", NULL));', 'explanation': ""This line directly implements the RFC requirement by setting the WWW-Authenticate header with a valid challenge (using Basic authentication). The function also returns a 401 (HTTP_UNAUTHORIZED), fulfilling the RFC's mandate to include the challenge with a 401 response.""}}]","The function ftp_unauthorized is self-contained and directly addresses the RFC requirement by setting the WWW-Authenticate header with the appropriate challenge and returning a 401 status. This ensures that the response includes at least one challenge applicable to the target resource, fully matching the spec constraints.",success,
15650,ftp_unauthorized,"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",225,Does Not Match,[],"The RFC specification requires that a sender MUST NOT generate an 'https' URI with an empty host identifier. In the provided function, there is no logic to verify or enforce that the host identifier is non-empty when forming an https URI. The function primarily handles logging for failed authentication and setting a basic authentication challenge header, without any checks related to the HTTPS host identifier. Therefore, none of the spec constraints (e.g., C1, if considered as the constraint regarding non-empty host identifiers) or any specific actions (e.g., A1) are visibly implemented within this function.",success,
15653,proxy_ftp_handler,"When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.",245,Fully Matches,"[{'C1': {'code': 'apr_rfc822_date(dates, r->request_time);\napr_table_setn(r->headers_out, ""Date"", dates);\n\n#if defined(USE_MDTM) && (defined(HAVE_TIMEGM) || defined(HAVE_GMTOFF))\n    if (mtime != 0L) {\n        char datestr[APR_RFC822_DATE_LEN];\n        apr_rfc822_date(datestr, mtime);\n        apr_table_set(r->headers_out, ""Last-Modified"", datestr);\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                      ""Last-Modified set to %s"", datestr);\n    }\n#endif', 'explanation': ""The code sets the HTTP header fields 'Date' and, when available, 'Last-Modified' using 'apr_rfc822_date'. This function generates a timestamp in the RFC 822 (and by current practice the IMF-fixdate) format, thereby fulfilling the RFC requirement that timestamp fields be generated in the IMF-fixdate format.""}}]","The proxy FTP handler function includes logic that generates timestamp header fields ('Date' and 'Last-Modified') using 'apr_rfc822_date'. Since this function outputs dates in the standard HTTP-date (IMF-fixdate) format, the code function directly and visibly implements the RFC specification regarding timestamp formatting.",success,
15653,proxy_ftp_handler,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'if (connectport == 0) {\n    connectport = apr_uri_port_of_scheme(""ftp"");\n}', 'explanation': 'This code checks if the port was not provided (i.e. connectport is 0) and then assigns it the default FTP port using apr_uri_port_of_scheme(""ftp""), which is precisely what the RFC specifies.'}}]","The function contains explicit logic to check whether a port was provided in the URL. If not, it defaults the port to the scheme's default (in this case FTP) by invoking apr_uri_port_of_scheme. This directly implements the RFC requirement that if a port is missing, the recipient may interpret that as meaning it was received on the default port.",success,
15653,proxy_ftp_handler,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function (proxy_ftp_handler) handles FTP proxying and building the HTTP response by setting individual headers (e.g., 'Date', 'Server', 'Content-Type', etc.) using APR table functions. However, there is no visible logic in the function that checks for, prevents, or reorders multiple header field lines with the same name in compliance with the RFC constraint. The function does not implement any logic that explicitly addresses conditions such as forbidding multiple identical header fields or managing their comma-separated combination as required by the specification. Therefore, within the function_body there is no evidence of an attempt to implement the specified HTTP RFC constraint.",success,
15653,proxy_ftp_handler,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function does not show any explicit logic that addresses the RFC requirement that a sender in a given message MUST NOT generate protocol elements or syntax alternatives that are only allowed for participants in other roles. The function mainly deals with FTP proxy operations (such as handling FTP commands, establishing control and data connections, and translating FTP replies to HTTP responses) and does not include any checks or restrictions that ensure only protocol elements appropriate for the sender role are generated. Therefore, within this function's self-contained logic, no part of the RFC constraint is implemented.",success,
15653,proxy_ftp_handler,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Does Not Match,[],"The provided function is designed for FTP proxy handling and does not generate or handle ""http"" URIs at all. The RFC requirement that a sender MUST NOT generate an ""http"" URI with an empty host identifier is not addressed in this function. There is no logic in the function that checks for an empty host identifier in an ""http"" URI, because the function explicitly declines non-FTP URLs. Therefore, no part of the function implements the spec constraint.",success,
15653,proxy_ftp_handler,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (type_suffix != NULL && strncmp(type_suffix, ""type="", 5) == 0\n        && apr_isalpha(type_suffix[5])) {\n        /* ""type=d"" forces a dir listing.\n         * The other types (i|a|e) are directly used for the ftp TYPE command\n         */\n        if ( ! (dirlisting = (apr_tolower(type_suffix[5]) == \'d\')))\n            xfer_type = apr_toupper(type_suffix[5]);\n\n        /* Check valid types, rather than ignoring invalid types silently: */\n        if (strchr(""AEI"", xfer_type) == NULL)\n            return ap_proxyerror(r, HTTP_BAD_REQUEST, apr_pstrcat(r->pool,\n                                    ""ftp proxy supports only types \'a\', \'i\', or \'e\': \\"""",\n                                    type_suffix, ""\\"" is invalid."", NULL));\n    } else {\n        /* make binary transfers the default */\n        xfer_type = \'I\';\n    }', 'explanation': 'The code validates the FTP transfer type by ensuring it is one of the allowed values (A, E, I) before sending any FTP command, thereby attempting to only generate protocol elements conforming to the expected grammatical form.'}}, {'A1': {'code': 'buf = apr_pstrcat(p, ""USER "", user, CRLF, NULL);\nrc = proxy_ftp_command(buf, r, origin, bb, &ftpmessage);', 'explanation': ""Commands such as 'USER' are constructed by concatenating fixed strings with parameters and a CRLF to adhere to FTP command grammar. This string‐construction pattern is used throughout the function to build protocol elements.""}}]","The function constructs FTP commands and manages the FTP session by concatenating command strings with parameters and appending CRLF, and it applies escaping (via ftp_escape_globbingchars) and explicit checks (for example, verifying the transfer type). These pieces of code demonstrate an effort to generate commands that follow the expected protocol syntax. However, the validation does not cover a comprehensive check against a formal ABNF grammar and may rely on minimal escaping and parameter checks. Thus, while some key aspects are addressed within the function itself, the implementation only partially meets the requirement of generating protocol elements that strictly conform to the defined grammar.",success,
15653,proxy_ftp_handler,"Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",308,Does Not Match,[],"The RFC requires that future registrations of transfer codings should not define parameters named ""q"" (case-insensitively), which is a directive specific to HTTP transfer codings. The provided ftp proxy handler function does not contain any logic that examines or restricts parameters (such as ""q"") in transfer codings. In fact, the function is entirely focused on FTP commands and connection handling, and it does not address any of the HTTP transfer coding registration constraints. Therefore, no part of the function implements the specified requirement.",success,
15653,proxy_ftp_handler,An origin server that receives a request method that is unrecognized or not implemented SHOULD respond with the 501 (Not Implemented) status code.,59,Fully Matches,"[{'C1': {'code': 'if (r->method_number != M_GET)\n    return HTTP_NOT_IMPLEMENTED;', 'explanation': 'This code segment checks if the request method is not GET and, if so, returns the HTTP status code 501 (Not Implemented) as prescribed by the RFC. It directly implements the requirement that requests with an unrecognized or unimplemented method should be responded to with 501.'}}]","The provided function includes a clear check for the request method using 'if (r->method_number != M_GET) return HTTP_NOT_IMPLEMENTED;', which ensures that any request method other than GET is immediately rejected with a 501 status code. This directly fulfills the part of the RFC that requires an origin server to return a 501 (Not Implemented) response if the request method is unrecognized or not implemented. As this check is fully contained within the function, the implementation is considered to fully match the specified RFC constraint.",success,
15653,proxy_ftp_handler,"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.",52,Fully Matches,"[{'A1': {'code': '#if defined(USE_MDTM) && (defined(HAVE_TIMEGM) || defined(HAVE_GMTOFF))\n    if (mtime != 0L) {\n        char datestr[APR_RFC822_DATE_LEN];\n        apr_rfc822_date(datestr, mtime);\n        apr_table_set(r->headers_out, ""Last-Modified"", datestr);\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                      ""Last-Modified set to %s"", datestr);\n    }\n#endif /* USE_MDTM */', 'explanation': ""This segment obtains the last modification date from the FTP MDTM command (if supported), formats it as an HTTP-date, and explicitly sets the 'Last-Modified' header in the response, which directly meets the RFC requirement that an origin server SHOULD send a Last-Modified header when determinable.""}}]","The function proxy_ftp_handler includes logic to determine the last modification time of a resource using the FTP MDTM command. When a valid modification time is retrieved (mtime != 0L), it formats the timestamp and sets it as the 'Last-Modified' HTTP header. Although the implementation depends on compile-time flags (USE_MDTM with HAVE_TIMEGM or HAVE_GMTOFF), within its context the function satisfies the spec's requirement of sending a Last-Modified header when the modification date can be reasonably determined. This fully addresses the relevant constraint (labeled here as A1) from the RFC specification.",success,
15653,proxy_ftp_handler,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'A1': {'code': 'if (xfer_type != \'A\' && size != NULL) {\n    apr_table_setn(r->headers_out, ""Content-Length"", size);\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                  ""Content-Length set to %s"", size);\n}', 'explanation': 'This code block sets the Content-Length header when a file’s size is known (obtained via the FTP SIZE command) and the transfer type is non-ASCII (i.e., typically binary). It demonstrates an attempt to implement the RFC requirement to include a Content-Length header in appropriate responses.'}}]","The function attempts to implement the RFC requirement by querying the remote FTP server for the size of the file and, if the size is returned and the transfer is not in ASCII mode, setting the Content-Length header accordingly. However, the code does not check for the absence of Transfer-Encoding nor does it consider cases that would prohibit sending a Content-Length header (such as for 1xx, 204, or CONNECT responses), which are part of the specification context. Therefore, while it addresses part of the spec constraint (sending Content-Length when the size is known), it only partially meets the overall requirements.",success,
15653,proxy_ftp_handler,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Does Not Match,[],"The HTTP RFC specifies that a server MUST NOT send a Content-Length header in responses with status codes 1xx (Informational) or 204 (No Content). In the function, the status is explicitly set to '200 OK' (HTTP_OK) and there is no conditional logic to check for and avoid sending a Content-Length header in cases where the response might be 1xx or 204. The only place where the Content-Length header is set is within a branch that does not guard against these specific status codes, which indicates that the function does not address the RFC requirement by itself.",success,
15653,proxy_ftp_handler,A sender that generates a Date header field SHOULD generate its field value as the best available approximation of the date and time of message generation.,15,Fully Matches,"[{'A1': {'code': 'apr_rfc822_date(dates, r->request_time);\napr_table_setn(r->headers_out, ""Date"", dates);', 'explanation': ""The function generates a Date header field by calling apr_rfc822_date with r->request_time and subsequently setting the 'Date' header in r->headers_out. This implements the RFC directive to generate the best available approximation of the date and time of message generation.""}}]","The RFC specifies that a sender SHOULD generate a Date header field with the best approximation of the message generation time. Within this function, the code explicitly obtains a formatted date based on r->request_time and sets it as the Date header. Thus, the function directly addresses the RFC requirement without reliance on external dependencies.",success,
15653,proxy_ftp_handler,"An origin server with a clock (as defined in Section 5.6.7) MUST generate a Date header field in all 2xx (Successful), 3xx (Redirection), and 4xx (Client Error) responses, and MAY generate a Date header field in 1xx (Informational) and 5xx (Server Error) responses.",16,Fully Matches,"[{'C1': {'code': 'apr_rfc822_date(dates, r->request_time);\napr_table_setn(r->headers_out, ""Date"", dates);', 'explanation': 'The function generates a Date header for the HTTP_OK (2xx) response by calling apr_rfc822_date() with r->request_time and setting the result into r->headers_out. This satisfies the RFC requirement that an origin server with a clock MUST generate a Date header field in all 2xx responses.'}}]","The function_body includes explicit logic to generate a Date header field when returning a successful (HTTP 200 OK) response. It uses the request time as the basis for the header value, which is in line with the RFC requirement. No other dependencies are needed for this implementation, so the code within the function fully addresses the spec constraint.",success,
15653,proxy_ftp_handler,An origin server MAY generate a Server header field in its responses.,89,Fully Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Server"", ap_get_server_banner());', 'explanation': ""This line sets the 'Server' header field in the HTTP response, which addresses the RFC specification where an origin server MAY generate a Server header field by providing information about its software.""}}]","The function includes explicit logic to set the Server header by calling ap_get_server_banner() and storing its value in r->headers_out. This directly implements the RFC requirement for optionally generating a Server header field in responses. Therefore, the function fully matches the specification by visibly addressing the constraint.",success,
15653,proxy_ftp_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,"[{'A1': {'code': 'if (dirlisting) {\n    ap_set_content_type_ex(r, apr_pstrcat(p, ""text/html;charset="",\n                                       fdconf->ftp_directory_charset ?\n                                       fdconf->ftp_directory_charset :\n                                       ""ISO-8859-1"",  NULL), 1);\n} else {\n    if (r->content_type) {\n        apr_table_setn(r->headers_out, ""Content-Type"", r->content_type);\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                      ""Content-Type set to %s"", r->content_type);\n    }\n}', 'explanation': 'The function explicitly sets a Content-Type header for directory listings and, when r->content_type is already provided, propagates it to the outgoing headers. This shows an attempt to implement the RFC requirement to include a Content-Type header when content is generated. However, in non-directory cases where r->content_type is not preset, no default Content-Type is generated.'}}]","The RFC specifies that a sender SHOULD include a Content-Type header when generating a message with content (unless the media type is unknown). In function_body, the Content-Type header is generated if a directory listing is being returned (using a text/html media type) or if r->content_type is already set. Because for non-directory file retrieval the function does not autonomously determine a default Content-Type when r->content_type is absent, it only partially meets the condition solely within its own logic.",success,
15653,proxy_ftp_handler,The server MAY send a Retry-After header field (Section 10.2.3) to suggest an appropriate amount of time for the client to wait before retrying the request.,169,Fully Matches,"[{'A1': {'code': 'if (rc == 120) {\n    /* RFC2616 states: 14.37 Retry-After\n     *\n     * The Retry-After response-header field can be used with a 503 (Service\n     * Unavailable) response to indicate how long the service is expected\n     * to be unavailable to the requesting client. [...] The value of\n     * this field can be either an HTTP-date or an integer number of\n     * seconds (in decimal) after the time of the response. Retry-After\n     * = ""Retry-After"" "":"" ( HTTP-date | delta-seconds )\n     */\n    char *secs_str = ftpmessage;\n    time_t secs;\n\n    /* Look for a number, preceded by whitespace */\n    while (*secs_str)\n        if ((secs_str==ftpmessage || apr_isspace(secs_str[-1])) &&\n            apr_isdigit(secs_str[0]))\n            break;\n    if (*secs_str != \'\\0\') {\n        secs = atol(secs_str);\n        apr_table_addn(r->headers_out, ""Retry-After"",\n                       apr_psprintf(p, ""%lu"", (unsigned long)(60 * secs)));\n    }\n    return ftp_proxyerror(r, backend, HTTP_SERVICE_UNAVAILABLE, ftpmessage);\n}', 'explanation': ""This code snippet checks if the FTP server returned a 120 reply (indicating a temporary delay) and extracts a delay value from the message. It then sets the 'Retry-After' header with the computed value, which aligns with the RFC specification regarding the Retry-After header field.""}}]",The function explicitly implements the behavior described in the RFC by checking if the FTP server responds with a 120 code and then setting the 'Retry-After' header accordingly to guide the client on how long to wait before retrying. This logic directly addresses the specification requirement within the function_body.,success,
15653,proxy_ftp_handler,"If the condition is temporary, the server SHOULD generate a Retry-After header field to indicate that it is temporary and after what time the client MAY try again.",165,Fully Matches,"[{'A1': {'code': 'if (rc == 120) {\n    char *secs_str = ftpmessage;\n    time_t secs;\n\n    /* Look for a number, preceded by whitespace */\n    while (*secs_str)\n        if ((secs_str==ftpmessage || apr_isspace(secs_str[-1])) &&\n            apr_isdigit(secs_str[0]))\n            break;\n    if (*secs_str != \'\\0\') {\n        secs = atol(secs_str);\n        apr_table_addn(r->headers_out, ""Retry-After"",\n                       apr_psprintf(p, ""%lu"", (unsigned long)(60 * secs)));\n    }\n    return ftp_proxyerror(r, backend, HTTP_SERVICE_UNAVAILABLE, ftpmessage);\n}', 'explanation': ""This code block checks for the temporary condition (FTP response code 120) and, upon detecting it, calculates a retry delay and adds the 'Retry-After' header field. This directly implements the RFC requirement that, if the condition is temporary, the server should generate a Retry-After header indicating when the client may try again.""}}]",The function explicitly addresses the requirement by detecting a temporary FTP response (rc == 120) and then generating and adding a Retry-After header with the calculated delay. This behavior fully implements the corresponding spec constraint within the function itself.,success,
15657,proxy_http_canon,"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response and close the connection.",175,Partially Matches,"[{'A1': {'code': 'if (err) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01083)\n                      ""error parsing URL %s: %s"", base_url, err);\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'This segment checks for a syntactic error in the URL by calling ap_proxy_canon_netloc. If an error is detected, it logs the error and returns HTTP_BAD_REQUEST, which aligns with the action in the RFC that the server should respond with a 400 error when the message does not match the expected grammar.'}}, {'A2': {'code': 'if (!path) {\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'After canonicalising the URL, if the resulting path is NULL (indicating a failure to properly process the URL components according to expected grammar), the function also returns HTTP_BAD_REQUEST.'}}]","The function demonstrates some level of robustness by validating the URL's syntax and returning HTTP_BAD_REQUEST when errors are detected, which partially corresponds to the specification's requirement to respond with a 400 status upon encountering octets that do not match the HTTP-message grammar. However, the specification also addresses issues such as handling whitespace-preceded lines between the start-line and headers and ensuring correct processing of HTTP messages. This function is focused solely on canonicalising URLs and does not address all aspects of the HTTP-message grammar or the related robustness exceptions. Therefore, the function only partially matches the overall specification.",success,
15657,proxy_http_canon,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'port = def_port = (is_ssl) ? DEFAULT_HTTPS_PORT : DEFAULT_HTTP_PORT;\n...\nif (port != def_port)\n    apr_snprintf(sport, sizeof(sport), "":%d"", port);\nelse\n    sport[0] = \'\\0\';', 'explanation': ""The function initializes 'port' with a default value based on whether the URL uses SSL (HTTPS) or not (HTTP). Later, when constructing the proxy URL, it compares the parsed port with the default port and only appends an explicit port (via 'sport') if they differ. This demonstrates that if a port is not provided in the URL, the recipient will assume the default port, matching the RFC specification.""}}]","The function sets the default port according to the scheme used (HTTP or HTTPS) and only includes an explicit port in the constructed URL if the parsed port differs from the default. This behavior directly implements the RFC instruction that, if no port is provided, it may be interpreted as using the default port. All relevant logic is contained within the function itself.",success,
15657,proxy_http_canon,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'C1': {'code': 'if (err) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01083)\n                  ""error parsing URL %s: %s"", base_url, err);\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'The function checks for syntactic errors in the URL and returns a 400 (Bad Request) error when parsing fails, which is in line with one possible action specified by the RFC for an invalid request-line.'}}, {'A1': {'code': 'if (path == url && *ap_scan_vchar_obstext(path)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10415)\n                  ""To be forwarded path contains control characters or spaces"");\n    return HTTP_FORBIDDEN;\n}\nif (search && *ap_scan_vchar_obstext(search)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10408)\n                  ""To be forwarded query string contains control characters or spaces"");\n    return HTTP_FORBIDDEN;\n}', 'explanation': 'The function validates that the path and search parts do not contain control characters or spaces. Although the RFC requires a 400 (Bad Request) error or a 301 redirect when the request-target is malformed, returning HTTP_FORBIDDEN indicates an effort to reject incorrectly formatted targets. This is a partial alignment with the RFC since a 301 redirect is not implemented.'}}]","The function attempts to validate and canonicalize the URL by checking for errors in both the network location and the request-target for disallowed whitespace/control characters, responding with error codes when issues are detected. However, while the RFC specifies that the recipient should respond with a 400 error or perform a 301 redirect with proper encoding, this function only implements returning HTTP_BAD_REQUEST (in some cases) and HTTP_FORBIDDEN (in cases of unencoded characters) without ever issuing a 301 redirect. Hence, it only partially matches the specified RFC behavior.",success,
15657,proxy_http_canon,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Fully Matches,"[{'C1': {'code': 'scheme = get_url_scheme((const char **)&url, &is_ssl);\n...\nerr = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);\n...\nif (!apr_table_get(r->notes, ""proxy-nocanon"")) {\n    path = ap_proxy_canonenc_ex(r->pool, url, strlen(url), enc_path, flags, r->proxyreq);\n    if (!path) {\n        return HTTP_BAD_REQUEST;\n    }\n    search = r->args;\n}\n...\nif (ap_strchr_c(host, \':\')) {\n    host = apr_pstrcat(r->pool, ""["", host, ""]"", NULL);\n}\n\nr->filename = apr_pstrcat(r->pool, ""proxy:"", scheme, ""://"", host, sport, ""/"", path, (search) ? ""?"" : """", search, NULL);', 'explanation': 'The function decomposes the input URL and reassembles it into a canonical form. It extracts the scheme, host, port, and path, applies encoding if necessary, and formats IPv6 addresses, all of which together implement the normalization requirement (C1) from the specification.'}}, {'A1': {'code': 'if (path == url && *ap_scan_vchar_obstext(path)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10415)\n                  ""To be forwarded path contains control characters or spaces"");\n    return HTTP_FORBIDDEN;\n}\nif (search && *ap_scan_vchar_obstext(search)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10408)\n                  ""To be forwarded query string contains control characters or spaces"");\n    return HTTP_FORBIDDEN;\n}', 'explanation': 'By validating the path and query string to ensure that control characters or spaces do not exist, the function further enforces a proper normalization and sanitization of the URL components in line with action A1 as per the RFC requirements.'}}]","The function 'proxy_http_canon' performs URL canonicalization in a way that addresses the normalization requirement stated in the HTTP specification. It extracts and processes the various components of the URL (scheme, host, port, path, and query), applies conditional encoding, and validates the resulting segments. These steps ensure that two HTTP URIs equivalent after normalization will be represented identically, thereby preventing distinct resources from being identified by different but normalized URIs. All of this logic is contained within the function, fulfilling the spec constraints directly without relying on external dependencies.",success,
15657,proxy_http_canon,"Specifications for newly defined fields SHOULD limit their values to visible US-ASCII octets (VCHAR), SP, and HTAB",2,Partially Matches,[],"The RFC specification requires that field values be limited to visible US‐ASCII octets (VCHAR), SP, and HTAB and that any leading or trailing whitespace be removed prior to further evaluation. In the provided function, there is logic that checks the URL path and query string for disallowed characters by calling ap_scan_vchar_obstext (for example, in the segments:

    if (path == url && *ap_scan_vchar_obstext(path)) { ... }
    if (search && *ap_scan_vchar_obstext(search)) { ... }

These checks attempt to reject inputs containing control characters or spaces. However, the function does not show any explicit logic for trimming leading or trailing whitespace nor does it fully validate against all disallowed characters such as CR, LF, or NUL as specified in the full context of the RFC. Since only part of the constraint (i.e. checking for illegal control characters in certain conditions) is handled in the function_body and not the entire set of restrictions outlined by the RFC, the implementation is considered a partial match.",success,
15660,add_te_chunked,"Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",308,Does Not Match,[],"The provided code function only adds a 'Transfer-Encoding: chunked' header into the HTTP header brigade and does not contain any logic related to checking or preventing the use of a parameter named 'q'. The spec's constraint about future registrations of transfer codings not defining parameters called 'q' (case-insensitively) is not addressed by any part of this function. Thus, there is no part of the function that implements any of the labeled conditions or actions related to the specification.",success,
15660,add_te_chunked,"It MUST conform to the field-name syntax defined in Section 5.1, and it SHOULD be restricted to just letters, digits, and hyphen ('-') characters, with the first character being a letter.",293,Partially Matches,"[{'C1': {'code': 'const char te_hdr[] = ""Transfer-Encoding: chunked"" CRLF;', 'explanation': ""The function hardcodes a header field 'Transfer-Encoding' which starts with a letter and contains only allowed characters (letters and hyphen), addressing the RFC's requirement for field-name syntax.""}}]","The RFC specification requires that the field name conforms to the syntax defined in Section 5.1, which includes restrictions on allowed characters and the first character. This function directly implements a header by hardcoding 'Transfer-Encoding: chunked' and thus meets that aspect (labeled C1) by itself. However, the specification context also mentions registration of a status (e.g., 'permanent', 'provisional', etc.), but the function does not address any such status. Therefore, while it correctly implements the header field-name requirement, it does not cover other aspects of the overall RFC spec, resulting in a partial match.",success,
15660,add_te_chunked,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Partially Matches,"[{'A1': {'code': 'const char te_hdr[] = ""Transfer-Encoding: chunked"" CRLF;\n\nbuf = apr_pmemdup(p, te_hdr, sizeof(te_hdr)-1);\nap_xlate_proto_to_ascii(buf, sizeof(te_hdr)-1);\n\ne = apr_bucket_pool_create(buf, sizeof(te_hdr)-1, p, bucket_alloc);\nAPR_BRIGADE_INSERT_TAIL(header_brigade, e);', 'explanation': ""This code explicitly creates and appends a 'Transfer-Encoding: chunked' header to the outbound HTTP header brigade, which is in line with the RFC recommendation that a server should generate encoding-delimited messages whenever possible. However, the function only handles setting this header and does not implement additional aspects (such as validating Content-Length or error handling) described in the RFC spec.""}}]","The provided function solely focuses on adding the 'Transfer-Encoding: chunked' header to the response, thereby addressing the specific part of the RFC that suggests generating encoding-delimited messages. Since it does not cover the entire range of conditions and actions related to message framing and error conditions mentioned in the RFC, the implementation is only a partial match.",success,
15661,add_cl,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Does Not Match,[],"The provided function strictly concatenates and inserts a Content-Length header into the header brigade. It does not perform any operations related to distinguishing between a successfully completed message and an incomplete one, nor does it implement any framing logic or error handling as prescribed by the RFC specification. In other words, none of the spec constraints (e.g., checking for proper content-length parsing or enforcing length-delimited message generation) are addressed in this function by itself.",success,
15666,terminate_headers,"A sender SHOULD send a Connection header field (Section 7.6.1 of [HTTP]) containing the ""close"" connection option when it intends to close a connection.",212,Fully Matches,"[{'A1': {'code': 'else {\n    ap_h1_append_header(req->header_brigade, req->p, ""Connection"", ""close"");\n}', 'explanation': 'When the connection is not reusable, the code adds the header \'Connection: close\', directly implementing the RFC\'s requirement that a sender SHOULD send a Connection header with the ""close"" option when it intends to close the connection.'}}]","The function 'terminate_headers' checks whether the backend connection will be reused. If not (and provided the request is HTTP/1.1), it appends the 'Connection: close' header. This behavior fully implements the RFC directive to include the 'close' connection option when the sender intends to close the connection.",success,
15666,terminate_headers,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'C1': {'code': 'if (!req->force10) {\n    ...\n    else if (ap_proxy_connection_reusable(req->backend)) {\n        ap_h1_append_header(req->header_brigade, req->p, ""Connection"", ""Keep-Alive"");\n    } else {\n        ap_h1_append_header(req->header_brigade, req->p, ""Connection"", ""close"");\n    }\n}', 'explanation': ""The RFC mandates that HTTP/1.1 implementations SHOULD support persistent connections. This code segment checks that the request is not forced to HTTP/1.0 and then, if the backend connection is reusable, it explicitly sets the header 'Connection: Keep-Alive' (otherwise signaling connection closure). This logic visibly addresses the need to support persistent connections as described in the specification.""}}, {'A1': {'code': 'ap_h1_append_header(req->header_brigade, req->p, ""Connection"", ""Keep-Alive"");', 'explanation': ""When the connection is determined to be reusable, the function adds the appropriate header 'Keep-Alive', which is a direct action implementing the persistent connection support required by the RFC.""}}]","The function 'terminate_headers' incorporates logic that differentiates between HTTP/1.1 and HTTP/1.0 (with the check '!req->force10'). It further determines if the backend connection is reusable via a condition call (ap_proxy_connection_reusable) and then adds the 'Keep-Alive' header accordingly. This code also handles the upgrade case and the non-reusable connection case, thereby directly implementing the requirements of supporting persistent connections as specified in the RFC. All the persistent connection related logic is contained within the function itself, satisfying the spec constraints.",success,
15666,terminate_headers,"A sender of Upgrade MUST also send an ""Upgrade"" connection option in the Connection header field (Section 7.6.1) to inform intermediaries not to forward this field.",31,Partially Matches,"[{'C1': {'code': 'if (req->upgrade) {\n    ap_h1_append_header(req->header_brigade, req->p, ""Connection"", ""Upgrade"");', 'explanation': ""This code segment checks if an upgrade is requested and appends the 'Connection: Upgrade' header as required by the RFC.""}}, {'A1': {'code': 'if (req->upgrade) {\n    ...\n    ap_h1_append_header(req->header_brigade, req->p, ""Upgrade"", req->upgrade);\n}', 'explanation': ""This code segment sets the 'Upgrade' header field, thereby completing the requirement that the Upgrade connection option is properly communicated.""}}]","The function 'terminate_headers' addresses the key requirement of the RFC by adding both 'Connection: Upgrade' and the corresponding 'Upgrade' header when an upgrade is indicated (provided that req->force10 is false). However, additional aspects of the RFC—such as handling HTTP/1.0 requests, responding to 100-continue expectations, and fully managing the upgrade process in other contexts—are not implemented within this function. Consequently, the function only partially matches the full set of constraints detailed in the RFC specification.",success,
15667,ap_proxy_http_prefetch,"A sender MUST NOT apply the chunked transfer coding more than once to a message body (i.e., chunking an already chunked message is not allowed).",188,Partially Matches,"[{'C1': {'code': 'if (req->old_te_val && ap_cstr_casecmp(req->old_te_val, ""chunked"") != 0) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01093)\n                  ""%s Transfer-Encoding is not supported"",\n                  req->old_te_val);\n    return HTTP_INTERNAL_SERVER_ERROR;\n}', 'explanation': ""This check ensures that if a Transfer-Encoding header is present, it must be 'chunked'. It rejects any encoding other than 'chunked', partially enforcing the constraint that non‐chunked codings should not be mixed.""}}, {'A1': {'code': 'case RB_STREAM_CHUNKED:\n    add_te_chunked(req->p, bucket_alloc, header_brigade);\n    break;', 'explanation': ""This action applies the chunked transfer coding when streaming the request body. However, the code does not verify whether 'chunked' has already been applied, so it does not fully protect against applying the coding more than once.""}}]","The function does include logic aimed at enforcing the RFC's requirements with respect to Transfer-Encoding. It ensures that if a Transfer-Encoding is provided it is only 'chunked' (C1) and, when streaming is used, it adds a chunked encoding (A1). However, there is no visible check to determine if chunking has already been applied, which leaves open the possibility that a message might be chunked twice. Thus, while some parts of the spec are addressed, the implementation is only partial relative to the complete RFC constraint.",success,
15667,ap_proxy_http_prefetch,A server MAY reject a request that contains both Content-Length and Transfer-Encoding or process such a request in accordance with the Transfer-Encoding alone.,198,Fully Matches,"[{'C1': {'code': 'if (req->old_cl_val && req->old_te_val) {\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01094)\n                  ""client %s (%s) requested Transfer-Encoding ""\n                  ""chunked body with Content-Length (C-L ignored)"",\n                  c->client_ip, c->remote_host ? c->remote_host: """");\n    req->old_cl_val = NULL;\n    p_conn->close = 1;\n}', 'explanation': 'This segment checks if both Content-Length and Transfer-Encoding are present. It then ignores the Content-Length header (by setting it to NULL) and forces the backend connection to be closed, which aligns with the RFC specification about processing the request using Transfer-Encoding alone and ensuring connection closure to mitigate potential attacks.'}}, {'A1': {'code': 'p_conn->close = 1;', 'explanation': 'By setting the connection to close after processing the request, the code fulfills the RFC requirement that the server must close the connection when both headers are present to avoid security vulnerabilities.'}}]","The function inspects the request for the presence of both Content-Length and Transfer-Encoding headers. When both are detected, it logs a message, nullifies the Content-Length header, and marks the connection for closure. This behavior directly reflects the RFC's allowance to process the request using the Transfer-Encoding alone and the mandate to close the connection after such processing. Hence, the code in function_body fully meets the relevant spec constraints.",success,
15667,ap_proxy_http_prefetch,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'if (req->old_cl_val && req->old_te_val) {\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01094)\n                  ""client %s (%s) requested Transfer-Encoding ""\n                  ""chunked body with Content-Length (C-L ignored)"",\n                  c->client_ip, c->remote_host ? c->remote_host: """");\n    req->old_cl_val = NULL;\n    p_conn->close = 1;\n}', 'explanation': 'This code segment checks if both a Content-Length header (req->old_cl_val) and a Transfer-Encoding header (req->old_te_val) are present. If so, it logs a debug message, clears the Content-Length header by setting req->old_cl_val to NULL, and marks the connection to be closed. This prevents the sending of the Content-Length header when the Transfer-Encoding header is present, meeting the RFC requirement.'}}]","The function explicitly checks for the concurrent presence of both Transfer-Encoding and Content-Length header fields. Upon detecting both, it clears the Content-Length header, ensuring that it is not sent. This behavior directly implements the RFC specification that a sender MUST NOT send a Content-Length header field in any message containing a Transfer-Encoding header field.",success,
15667,ap_proxy_http_prefetch,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'C1': {'code': 'else if (req->old_cl_val && r->input_filters == r->proto_input_filters) {\n    /* Streaming is possible by preserving the existing C-L */\n    if (!ap_parse_strict_length(&req->cl_val, req->old_cl_val)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01085)\n                      ""could not parse request Content-Length (%s)"",\n                      req->old_cl_val);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    req->rb_method = RB_STREAM_CL;\n}', 'explanation': ""This code verifies the Content-Length header's validity by attempting a strict parse via ap_parse_strict_length. If the parsing fails (i.e. the header is known to be incorrect), it logs an error and returns an error code, thereby preventing the forwarding of a message with an incorrect Content-Length field. This partially meets the RFC requirement, although it does not handle the exception for comma-separated duplicate values.""}}, {'A1': {'code': 'if (req->old_te_val && req->old_cl_val) {\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01094)\n                  ""client %s (%s) requested Transfer-Encoding ""\n                  ""chunked body with Content-Length (C-L ignored)"",\n                  c->client_ip, c->remote_host ? c->remote_host: """");\n    req->old_cl_val = NULL;\n    p_conn->close = 1;\n}', 'explanation': 'When both Transfer-Encoding and Content-Length headers are present, the code logs this condition and nullifies the Content-Length value while opting to close the connection. This helps mitigate inconsistencies between the header values but does not fully implement handling of all abnormal cases defined in the RFC (especially the allowed exception for duplicate, identical values).'}}]","The function includes logic to validate and act upon the Content-Length header. It attempts to reject requests when the Content-Length is deemed invalid (via a strict parse) and also addresses the presence of both Transfer-Encoding and Content-Length by nullifying the latter and closing the connection. However, it does not implement the specific exception allowing duplicate identical Content-Length values. Hence, while some aspects of the spec are addressed, the implementation is only partially complete relative to the detailed RFC requirement.",success,
15669,date_canon,"When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.",245,Fully Matches,"[{'C1': {'code': 'apr_time_t time = apr_date_parse_http(date);\nif (!time) {\n    return date;\n}', 'explanation': 'This segment attempts to parse an incoming HTTP-date string (which can be in various allowed formats) into a normalized time value, ensuring that the input is a valid HTTP-date.'}}, {'A1': {'code': 'ndate = apr_palloc(p, APR_RFC822_DATE_LEN);\nrv = apr_rfc822_date(ndate, time);\nif (rv != APR_SUCCESS) {\n    return date;\n}\nreturn ndate;', 'explanation': 'This segment allocates memory for a new date string and then generates a timestamp using apr_rfc822_date, which produces a canonical date format. In the context of HTTP, the output produced by apr_rfc822_date is equivalent to the IMF-fixdate required by the specification.'}}]","The function 'date_canon' first validates the input date using apr_date_parse_http to ensure that it is a valid HTTP-date (fulfilling condition C1). If valid, it then converts this date to a canonical format using apr_rfc822_date (fulfilling action A1), which produces a properly formatted timestamp equivalent to IMF-fixdate. This directly addresses the specification requirement that timestamps be generated in the IMF-fixdate format.",success,
15670,make_fake_req,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The function make_fake_req merely creates a fake request and allocates separate tables for headers and trailers (headers_in, trailers_in, headers_out, trailers_out) without implementing any logic to merge trailer fields into header sections or performing any validations regarding trailer field definitions. There is no visible code that attempts to adhere to the RFC requirement which mandates that a recipient must not merge a trailer field into the header section unless it understands the field and merging is explicitly allowed. Therefore, the function does not attempt to implement the specified constraint.",success,
15670,make_fake_req,"Because of the potential for trailer fields to be discarded in transit, a server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive.",12,Does Not Match,[],"The RFC requires that a server SHOULD NOT generate trailer fields it believes are necessary for the user agent to receive – a behavior that requires conditional logic to decide whether to generate such fields based on the TE header’s ‘trailers’ value. In the function make_fake_req, the code only allocates and initializes tables for both headers and trailers (rp->trailers_in and rp->trailers_out) without any examination or conditional handling of trailer fields. Specifically, there is no logic within this function that checks for the presence of the TE header or prevents the server from generating critical trailer fields. Therefore, the function does not visibly implement any of the labeled conditions or actions from the RFC specification.",success,
15672,ap_proxy_read_headers,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function ap_proxy_read_headers primarily handles reading header lines from a backend response and processing them. It includes logic to parse header lines, handle invalid headers, and log warnings when header formatting issues are encountered. However, none of its internal logic addresses the requirement from the RFC specification that 'a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles.' The function does not contain any logic that verifies or restricts protocol element generation based on sender roles, and thus it does not visibly implement any of the labeled constraints (e.g., C1, A1) provided in the spec.",success,
15672,ap_proxy_read_headers,A recipient MAY employ such workarounds while remaining conformant to this protocol if the workarounds are limited to the implementations at fault.,216,Fully Matches,"[{'C1': {'code': 'if (!(value = strchr(buffer, \':\'))) {     \n    if (!apr_date_checkmask(buffer, ""HTTP/#.# ###*"")) {\n        if (psc->badopt == bad_error) {\n            r->headers_out = NULL;\n            return APR_EINVAL;\n        }\n        else if (psc->badopt == bad_body) {\n            if (saw_headers) {\n                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01098)\n                              ""Starting body due to bogus non-header \\n                             ""in headers returned by %s (%s)"",\n                              r->uri, r->method);\n                *pread_len = len;\n                return APR_SUCCESS;\n            }\n            else {\n                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01099)\n                              ""No HTTP headers returned by %s (%s)"",\n                              r->uri, r->method);\n                return APR_SUCCESS;\n            }\n        }\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01100)\n                  ""Ignoring bogus HTTP header returned by %s (%s)"",\n                  r->uri, r->method);\n    continue;\n}', 'explanation': 'This segment checks for headers that do not include a colon and applies workarounds only when the header does not match a specific HTTP status line mask. The subsequent decisions (error, treating the remainder as body, or ignoring) ensure that any workaround is applied only to responses from faulty implementations, which directly corresponds to the RFC requirement that ""workarounds are limited to the implementations at fault.""'}}]","The provided function reads backend HTTP headers and specifically handles malformed header lines by checking for the expected colon separator and validating against an HTTP header mask. When an anomaly is detected, it conditionally applies different workarounds based on the configured policy (bad_error, bad_body, or bad_ignore). This internal logic directly implements the RFC's allowance for recipients to apply limited workarounds exclusively for faulty implementations, thereby fully matching the specified condition.",success,
15672,ap_proxy_read_headers,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (!(value = strchr(buffer, \':\'))) {     /* Find the colon separator */\n    /* We may encounter invalid headers, usually from buggy\n     * MS IIS servers, so we need to determine just how to handle\n     * them. ... */\n    if (!apr_date_checkmask(buffer, ""HTTP/#.# ###*"")) {\n        if (psc->badopt == bad_error) {\n            r->headers_out = NULL;\n            return APR_EINVAL;\n        }\n        else if (psc->badopt == bad_body) {\n            if (saw_headers) {\n                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, ""Starting body due to bogus non-header ..."");\n                *pread_len = len;\n                return APR_SUCCESS;\n            }\n            else {\n                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, ""No HTTP headers returned ..."");\n                return APR_SUCCESS;\n            }\n        }\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, ""Ignoring bogus HTTP header ..."");\n    continue;\n}', 'explanation': 'This code segment defensively handles protocol elements that do not adhere to the expected ABNF grammar (lacking the colon separator). It checks for an expected delimiter and applies fallback behaviors based on configuration, aligning with the requirement of marginal expectations on conformance.'}}, {'A1': {'code': 'rc = ap_proxygetline(tmp_bb, buffer, size, rr,\n                     AP_GETLINE_FOLD | AP_GETLINE_NOSPC_EOL, &len);\n\nif (rc != APR_SUCCESS) {\n    if (APR_STATUS_IS_ENOSPC(rc)) {\n        int trunc = (len > 128 ? 128 : len) / 2;\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, rc, r, APLOGNO(10124)\n                ""header size is over the limit allowed by ""\n                ""ResponseFieldSize (%d bytes). ""\n                ""Bad response header: \'%.*s[...]%s\'"",\n                size, trunc, buffer, buffer + len - trunc);\n    }\n    else {\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, rc, r, APLOGNO(10404) \n                      ""Error reading headers from backend"");\n    }\n    r->headers_out = NULL;\n    return rc;\n}', 'explanation': 'This segment checks the result of reading a header line and specifically tests for buffer size overruns (APR_STATUS_IS_ENOSPC). It logs a warning and handles the exceptional case, addressing the concern that protocol elements may not always fit within a reasonable buffer size.'}}]","The function ap_proxy_read_headers implements defensive parsing as specified in the HTTP RFC. It accepts header lines with only marginal expectations for strict ABNF conformance and handles cases where headers exceed a predefined buffer size. By checking for the presence of essential delimiters and managing potential buffer overruns, the function fulfills the core aspects of the spec constraints within its own logic.",success,
15672,ap_proxy_read_headers,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (!(value = strchr(buffer, \':\'))) {     /* Find the colon separator */\n    ...\n    if (!apr_date_checkmask(buffer, ""HTTP/#.# ###*"")) {\n        if (psc->badopt == bad_error) {\n            r->headers_out = NULL;\n            return APR_EINVAL;\n        }\n        else if (psc->badopt == bad_body) {\n            if (saw_headers) {\n                *pread_len = len;\n                return APR_SUCCESS;\n            }\n            else {\n                return APR_SUCCESS;\n            }\n        }\n    }\n    ap_log_rerror(..., ""Ignoring bogus HTTP header returned by %s (%s)"", r->uri, r->method);\n    continue;\n}', 'explanation': 'This segment checks the header for the expected colon separator and then interprets the header field according to defined semantics. When the format is off, it uses a mask check and configuration to determine whether the header is bogus, reflecting the RFC mandate to interpret the received protocol element based on its semantics.'}}, {'A1': {'code': 'while (1) {\n    rc = ap_proxygetline(...);\n    if (rc != APR_SUCCESS) {\n        if (APR_STATUS_IS_ENOSPC(rc)) {\n            ap_log_rerror(..., ""header size is over the limit allowed by ResponseFieldSize (%d bytes)..."", size, ...);\n        }\n        else {\n            ap_log_rerror(..., ""Error reading headers from backend"");\n        }\n        r->headers_out = NULL;\n        return rc;\n    }\n    if (len <= 0) {\n        break;\n    }\n    ...\n    process_proxy_header(r, dconf, buffer, value);\n    saw_headers = 1;\n}', 'explanation': 'This loop reads header lines until an empty line is encountered, and attempts to recover from errors (such as overly long lines or invalid headers) by logging warnings and returning accumulated headers when possible. This approach demonstrates an effort to salvage a usable protocol element even when some constructs violate the expected format.'}}]","The function ap_proxy_read_headers implements parts of the RFC requirement by reading the header lines, parsing them according to expected semantics (looking for a colon separator) and applying specific recovery strategies when encountering invalid header formats. It examines invalid cases such as missing colons and chooses among erroring out, treating the remainder as a body, or ignoring the header based on configuration. While it clearly addresses the interpretation of protocol elements (C1) and recovery from invalid constructs (A1) within its scope, it does not cover all potential aspects of the RFC specification. Therefore, the function partially matches the RFC constraints as implemented directly in this function.",success,
15672,ap_proxy_read_headers,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'if (!(value = strchr(buffer, \':\'))) { ... if (!apr_date_checkmask(buffer, ""HTTP/#.# ###*"")) { if (psc->badopt == bad_error) { r->headers_out = NULL; return APR_EINVAL; } else if (psc->badopt == bad_body) { if (saw_headers) { *pread_len = len; return APR_SUCCESS; } else { return APR_SUCCESS; } } } ap_log_rerror(...); continue; }', 'explanation': 'This segment checks if the header line is missing the colon separator—a sign of an invalid header construct—and then selects a recovery strategy based on configuration. This reflects the RFC-specified approach of attempting to recover from an invalid construct.'}}, {'A1': {'code': ""for (end = &value[strlen(value)-1]; end > value && apr_isspace(*end); --end) *end = '\\0';"", 'explanation': 'This snippet strips trailing whitespace from the header value, ensuring the header is in a usable form as specified by the RFC when interpreting protocol elements.'}}]","The function attempts to implement some aspects of the RFC by handling invalid header constructs. In particular, it detects when a header line is malformed (missing the colon) and then, based on configuration (psc->badopt), either returns an error, treats the remaining data as the body, or ignores the invalid header—demonstrating an attempt to recover a usable protocol element. Additionally, it cleans up header values by stripping extraneous whitespace. However, not all aspects of the RFC or the surrounding context (as provided in the specification) are handled solely within this function, leading to a partial match.",success,
15672,ap_proxy_read_headers,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'A1': {'code': ""        /* XXX: RFC2068 defines only SP and HT as whitespace, this test is\n         * wrong... and so are many others probably.\n         */\n        while (apr_isspace(*value))\n            ++value;            /* Skip to start of value   */\n\n        /* should strip trailing whitespace as well */\n        for (end = &value[strlen(value)-1]; end > value && apr_isspace(*end); --end)\n            *end = '\\0';"", 'explanation': ""This code explicitly removes both leading and trailing whitespace from the header value (immediately after the ':' separator), thereby ensuring that field values are evaluated without extraneous whitespace, in accordance with the RFC specification.""}}]","The function contains logic that directly addresses the requirement of excluding leading and trailing whitespace from an HTTP header field value (specifically after the colon). By iterating over whitespace characters both at the beginning and end of the extracted value, it meets the specified RFC constraint, and thus, the implementation fully matches the requirement.",success,
15672,ap_proxy_read_headers,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': ""while (apr_isspace(*value))\n    ++value;            /* Skip to start of value   */\n\nfor (end = &value[strlen(value)-1]; end > value && apr_isspace(*end); --end)\n    *end = '\\0';"", 'explanation': 'These code segments remove leading and trailing whitespace from the header value after the colon. This directly implements the RFC requirement that a recipient remove bad whitespace before interpreting the protocol element.'}}]","The function parses header lines and, upon identifying a colon separator, explicitly skips leading whitespace and trims trailing whitespace from the header value. This behavior directly addresses the spec constraint that a recipient must remove any extraneous (bad) whitespace before processing the header contents, thereby fully matching the condition specified.",success,
15672,ap_proxy_read_headers,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The provided code function reads headers from a backend and populates a headers table (r->headers_out) and a trailers table (r->trailers_out), but it does not contain any logic that explicitly addresses the RFC requirement: ""A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged."" There is no visible check or mechanism in the function that determines whether a trailer field’s definition permits merging into the header section. Instead, all header lines are processed via process_proxy_header without any special handling or verification for trailer fields. Therefore, in isolation, this function does not implement any of the labeled conditions or actions from the spec.",success,
15674,ap_proxygetline,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function ap_proxygetline only handles reading a line from the input (bucket brigade) and cleaning up afterwards. There is no logic in the function that addresses the RFC requirement stating that a sender MUST NOT generate protocol elements or syntax alternatives reserved for other roles. The function does not implement any checks or restrictions related to sender roles or protocol element generation, and therefore does not visibly address the spec constraints (e.g., C1, A1).",success,
15674,ap_proxygetline,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function only handles reading a line from a bucket brigade and cleaning it up. There is no logic within the function_body that verifies whether the generated protocol elements adhere to the ABNF grammar required by the HTTP RFC specification. It does not check, filter, or enforce that the data being sent conforms to the specified grammar (C1, A1, etc.), and thus does not address the key condition that a sender must not generate protocol elements that do not match the ABNF rules.",success,
15675,add_trailers,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Does Not Match,[],"The provided function simply checks if a value exists and then adds the key/value pair to a table. It does not perform any validation or checks to confirm if the trailer field is permitted to be merged into the header section based on an understanding of the header field definition, as required by the spec. There is no logic implementing any condition (such as checking permission or safety of merging trailer fields), so no spec constraint is addressed inside this function.",success,
15677,ap_proxy_http_process_response,"* A server that responds with a final status code before reading the entire request content SHOULD indicate whether it intends to close the connection (e.g., see Section 9.6 of [HTTP/1.1]) or continue reading the request content.",273,Partially Matches,"[{'A1': {'code': 'if (do_100_continue && (!interim_response || proxy_status == HTTP_CONTINUE)) {\n    int do_send_body = (proxy_status == HTTP_CONTINUE || (!toclose && major > 0 && minor > 0));\n    /* ... logging and timeout restoration ... */\n    if (do_send_body) {\n        status = send_continue_body(req);\n        if (status != OK) {\n            return status;\n        }\n    }\n    else {\n        /* When not sending further body, connection handling decisions are deferred\n         * (e.g. leaving r->expecting_100 unchanged and expecting the later ap_set_keepalive()\n         * to close the connection if needed).\n         */\n    }\n    do_100_continue = 0;\n}', 'explanation': ""This segment distinguishes between a 100-Continue interim response and a final response. It decides whether or not to proceed with reading the request body based on the final status code and header evaluation (e.g. checking 'toclose'). This indicates an attempt to signal whether the connection will be closed before the entire request content is read, which is part of the RFC requirement.""}}, {'A2': {'code': 'if (upgrade && ap_proxy_worker_can_upgrade(p, worker, upgrade,\n                                           (*req->proto == \'w\') ? ""WebSocket"" : NULL)) {\n    apr_table_setn(r->headers_out, ""Connection"", ""Upgrade"");\n    apr_table_setn(r->headers_out, ""Upgrade"", apr_pstrdup(p, upgrade));\n}\n\nif ((major < 1) || (minor < 1)) {\n    backend->close = 1;\n    origin->keepalive = AP_CONN_CLOSE;\n}\n', 'explanation': ""This part of the code inspects protocol version and upgrade headers to decide if the connection should be closed. By setting flags like 'backend->close' and 'origin->keepalive = AP_CONN_CLOSE', the code attempts to indicate the intended connection behavior, consistent with the RFC's recommendation.""}}]","The function implements logic to handle HTTP responses that include a 100-Continue expectation. In its do_100_continue branch, the function checks interim responses versus final responses and makes decisions about whether to send the request body or not. It examines headers (including connection-related headers) and adjusts connection flags (such as 'backend->close' or 'origin->keepalive') to indicate if the connection will be closed. Although these implementations address parts of the RFC specification regarding the indication of connection closure when a final response is sent before reading the entire request, some aspects (such as a detailed mechanism for reading or discarding the remaining content) rely on other functions. Therefore, while the function alone visibly addresses parts of the spec constraints, it only partially matches the overall RFC requirement.",success,
15677,ap_proxy_http_process_response,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (apr_date_checkmask(buffer, ""HTTP/#.# ###*"")) {\n    major = buffer[5] - \'0\';\n    minor = buffer[7] - \'0\';\n    …\n    /* validate status line length and proper HTTP/1 message */\n}\nelse {\n    /* handle HTTP/0.9 response */\n    backasswards = 1;\n    r->status = proxy_status = 200;\n    r->status_line = ""200 OK"";\n    backend->close = 1;\n}', 'explanation': 'This code segment checks that the incoming status line conforms to the expected HTTP syntax. In doing so, it helps ensure that the proxy only accepts valid protocol elements. This mechanism partially enforces the requirement that a sender (here the proxy) must not produce elements that are out of role by validating and then reusing the backend data.'}}, {'A1': {'code': 'for (i=0; hop_by_hop_hdrs[i]; ++i) {\n    apr_table_unset(r->headers_out, hop_by_hop_hdrs[i]);\n}\n…\nif (te && apr_table_get(r->headers_out, ""Content-Length"")) {\n    apr_table_unset(r->headers_out, ""Content-Length"");\n    backend->close = 1;\n}', 'explanation': 'This code removes hop-by-hop headers and resolves conflicts between Transfer-Encoding and Content-Length headers. By stripping headers that are not allowed to be generated in the response from a proxy (or that belong only to a specific role), the function partly adheres to the rule against generating protocol elements reserved for other roles.'}}]","The function 'ap_proxy_http_process_response' processes responses from a backend server and forwards them to the client while performing several checks and modifications to the headers and status line. It validates the HTTP response syntax, strips hop‐by‐hop headers, and ensures that conflicting header situations (such as having both Transfer-Encoding and Content-Length) are handled by unsetting the inappropriate header. These measures indicate an attempt to avoid generating or propagating protocol elements that are not in its role. However, the function does not explicitly enforce all aspects of the requirement—specifically, it does not perform a comprehensive check to ensure that it never generates elements meant solely for another role. As a result, the implementation addresses some of the spec’s constraints directly within its code, but only partially meets the complete requirement as stated in the RFC.",success,
15677,ap_proxy_http_process_response,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (apr_date_checkmask(buffer, ""HTTP/#.# ###*"")) {\n    major = buffer[5] - \'0\';\n    minor = buffer[7] - \'0\';\n\n    if ((major != 1) || (len >= response_field_size - 1)) {\n        return ap_proxyerror(r, HTTP_BAD_GATEWAY,\n                    apr_pstrcat(p, ""Corrupt status line returned by remote server: "", buffer, NULL));\n    }\n    ...\n}', 'explanation': ""The function inspects the incoming status line using a pattern check (apr_date_checkmask) to ensure it matches the expected 'HTTP/#.# ###*' format. It then performs additional validation (e.g., checking that the first digit is 1 and that the line length does not exceed the buffer capacity). This shows an attempt to ensure that no malformed protocol elements (i.e. those not matching the ABNF grammar) are processed or forwarded.""}}]","The RFC requires that a sender must not generate protocol elements violating the defined ABNF grammar. Within this function, there is a clear check on the status line using a format mask and length validations, which prevents improper protocol elements from being used. However, the function handles many aspects of response processing and some of the deeper semantics related to protocol element generation are deferred to other helper functions (such as ap_proxy_read_headers or ap_proxyerror). Thus, while the function does include logic to validate parts of the protocol against the ABNF rules, it only partially addresses the complete RFC mandate within its own code.",success,
15677,ap_proxy_http_process_response,"A server that sends a ""close"" connection option MUST initiate closure of the connection (see below) after it sends the response containing the ""close"" connection option.",321,Fully Matches,"[{'C1': {'code': 'toclose = ap_proxy_clear_connection_fn(r, r->headers_out);\nif (toclose) {\n    backend->close = 1;\n    if (toclose < 0) {\n         return ap_proxyerror(r, HTTP_BAD_GATEWAY, ""Malformed connection header"");\n    }\n}', 'explanation': ""The code checks the response headers (via ap_proxy_clear_connection_fn) for any hop-by-hop directives. When a 'close' option is detected (indicated by a non-zero 'toclose'), it immediately sets backend->close to 1. This directly implements the condition that when a 'close' connection option is sent, the server initiates closure.""}}, {'A1': {'code': 'r->connection->keepalive = AP_CONN_CLOSE;\nbackend->close = 1;\n...\nproxy_run_detach_backend(r, backend);\nap_proxy_release_connection(backend->worker->s->scheme, backend, r->server);\nreq->backend = NULL;', 'explanation': ""After sending the response (or during handling of a tunneling upgrade), the code sets the client connection to close (via r->connection->keepalive = AP_CONN_CLOSE) and ensures that the backend connection is not reused by marking it closed and releasing it. This satisfies the action requirement that the connection must be closed after sending the response containing the 'close' option.""}}]","The function explicitly checks for a 'close' connection option in the received HTTP response and then sets flags (backend->close, r->connection->keepalive) which trigger the closure of the connection after the response is sent. Additionally, it detaches from the backend and releases the connection to prevent any further processing. As these measures directly address the RFC specification requirement, the function fully matches the constraint.",success,
15677,ap_proxy_http_process_response,"A client, server, or proxy MAY close the transport connection at any time.",316,Fully Matches,"[{'C1': {'code': 'if ((major < 1) || (minor < 1)) {\n    backend->close = 1;\n    origin->keepalive = AP_CONN_CLOSE;\n} \n... \nif (rc <= 0) {\n    ...\n    backend->close = 1;\n    return ap_proxyerror(r, HTTP_BAD_GATEWAY, ""Error reading from remote server"");\n}\n...\nif (apr_pass_brigade(r->output_filters, bb) != APR_SUCCESS || c->aborted) {\n    if (req->backend) {\n         req->backend->close = 1;\n    }\n    finish = TRUE;\n}\n...\nif (c->aborted || backend_broke) {\n    return DONE;\n}', 'explanation': 'The function explicitly sets backend->close and adjusts the client keepalive (origin->keepalive) when error conditions or protocol mismatches are detected. It also monitors for aborted client connections. This behavior directly implements the RFC requirement that a client, server, or proxy MAY close the transport connection at any time.'}}, {'A1': {'code': 'if (do_100_continue && worker->s->ping_timeout_set) {\n    apr_socket_timeout_get(backend->sock, &old_timeout);\n    if (worker->s->ping_timeout != old_timeout) {\n        apr_status_t rc;\n        rc = apr_socket_timeout_set(backend->sock, worker->s->ping_timeout);\n        if (rc != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(01101)\n                          ""could not set 100-Continue timeout"");\n        }\n    }\n}\n...\n/* Cancel keepalive if necessary and force connection close in various cases */\nif ((major < 1) || (minor < 1)) {\n    backend->close = 1;\n    origin->keepalive = AP_CONN_CLOSE;\n}', 'explanation': 'This segment not only monitors for conditions such as timeouts and improper protocol versions, but also adjusts the socket timeout and ensures that when required, the connection is closed. This aligns with the RFC’s permission to close the connection at any time, as well as the guidance to gracefully shut down if needed.'}}]","The function 'ap_proxy_http_process_response' includes multiple checks where it determines that the connection should be closed – for example, when errors occur reading the response, when protocol constraints (like HTTP/1.0) disallow persistent connections, or when the client connection is aborted. By setting flags such as backend->close and origin->keepalive = AP_CONN_CLOSE, and by checking conditions like c->aborted, the code visibly implements the RFC specification that allows the client, server, or proxy to close the transport connection at any time. All handling is done within the function itself, fulfilling the necessary spec constraints.",success,
15677,ap_proxy_http_process_response,"A server MUST read the entire request message body or close the connection after sending its response; otherwise, the remaining data on a persistent connection would be misinterpreted as the next request.",312,Fully Matches,"[{'C1': {'code': 'do {\n    ...\n    rv = ap_get_brigade(backend->r->input_filters, bb, AP_MODE_READBYTES, mode, req->sconf->io_buffer_size);\n    ...\n    if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(pass_bb))) {\n        finish = TRUE;\n        ...\n        proxy_run_detach_backend(r, backend);\n        ap_proxy_release_connection(backend->worker->s->scheme, backend, r->server);\n        req->backend = NULL;\n    }\n    ...\n} while (!finish);', 'explanation': 'This loop reads the complete response body from the backend using apr_get_brigade until an EOS (end-of-stream) bucket is encountered. By exhausting the response data before releasing the connection (or, in error cases, marking it to close), it ensures that any residual data does not interfere with subsequent requests on a persistent connection.'}}, {'A1': {'code': 'if (rv != APR_SUCCESS || APR_BRIGADE_EMPTY(bb)) {\n    ...\n    backend->close = 1;\n    ...\n}\n\n... \nif (!r->header_only && !AP_STATUS_IS_HEADER_ONLY(proxy_status)) {\n    /* read body loop as above */\n}\n\nif (!c->keepalives) {\n    ...\n}\n\nif (ap_proxy_should_override(dconf, proxy_status)) {\n    if (!r->header_only) {\n        ap_discard_request_body(backend->r);\n    }\n    ...\n    return proxy_status;\n}', 'explanation': 'In various parts of the function, if an error occurs or if specific header conditions are met (such as during error override), the function marks the connection to be closed (using backend->close = 1) or explicitly discards any outstanding request body. This directly implements the action required to avoid misinterpreting leftover message body data on persistent connections.'}}]","The function is responsible for processing the HTTP response from a backend server in a proxy scenario. It explicitly reads the complete response body in a loop (using apr_get_brigade) until an end-of-stream is detected, and in error or special conditions, it either discards the remaining body or forces the associated connection to be closed. This behavior satisfies the RFC requirement that a server must either fully read the message body or close the connection to prevent any leftover data from being misinterpreted as the next request on a persistent connection.",success,
15677,ap_proxy_http_process_response,HTTP implementations SHOULD support persistent connections.,311,Fully Matches,"[{'C1': {'code': 'if ((major < 1) || (minor < 1)) {\n    backend->close = 1;\n    origin->keepalive = AP_CONN_CLOSE;\n} else {\n    origin->keepalives++;\n}', 'explanation': 'This code checks the HTTP version from the status line. For HTTP/1.1 (or higher), it allows persistent connections by incrementing the keepalive count. For HTTP/1.0 or earlier, it disables keepalive by setting the connection to close. This directly implements the RFC requirement that HTTP implementations SHOULD support persistent connections.'}}]","The function 'ap_proxy_http_process_response' includes explicit logic to handle persistent connections based on the HTTP version. By assessing the major and minor version numbers, it ensures that persistent connections are maintained for HTTP/1.1 responses and closed for earlier versions. This logic directly addresses the spec constraint regarding persistent connections, hence the function fully matches the provided spec constraint.",success,
15677,ap_proxy_http_process_response,"A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.",310,Partially Matches,"[{'C1': {'code': 'if (len <= 0) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(01102)\n                  ""error reading status line from remote server %s:%d"", backend->hostname, backend->port);\n    if (APR_STATUS_IS_TIMEUP(rc)) {\n        apr_table_setn(r->notes, ""proxy_timedout"", ""1"");\n        return ap_proxyerror(r, HTTP_SERVICE_UNAVAILABLE, ""Timeout on 100-Continue"");\n    }\n    return ap_proxyerror(r, HTTP_BAD_GATEWAY, ""Error reading from remote server"");\n}', 'explanation': 'This segment checks for an incomplete or faulty response (e.g. empty status line) and sends an error response before closing the connection. It partially implements the RFC provision for sending an error response when an incomplete message is received.'}}, {'A1': {'code': '/* In the body reading loop, on error conditions: */\nif (rv != APR_SUCCESS || APR_BRIGADE_EMPTY(bb)) {\n    int error_status = HTTP_BAD_GATEWAY;\n    /* ... log appropriate error message ... */\n    apr_brigade_cleanup(bb);\n    ap_proxy_fill_error_brigade(r, error_status, bb, 1);\n    ap_pass_brigade(r->output_filters, bb);\n    backend_broke = 1;\n    backend->close = 1;\n    break;\n}', 'explanation': ""This section shows that when a network or read error occurs during processing of the response body, an error brigade is filled and sent as a response. This is in line with the RFC's allowance to send an error response prior to closing the connection.""}}]","The function 'ap_proxy_http_process_response' contains logic that detects incomplete or erroneous responses from the remote/backend server. In cases where the response is incomplete—whether due to a timeout or a read error—it sends an error response (using ap_proxyerror or filling an error brigade) before closing the connection. This behavior aligns with the RFC’s statement that a server MAY send an error response when an incomplete message is received. However, the function does not cover all aspects of the RFC (for example, the full handling of incomplete messages and their caching implications) and only addresses part of the requirement within its own logic. Therefore, while it visibly implements key parts of the spec regarding issuing error responses, it only partially matches the overall requirements.",success,
15677,ap_proxy_http_process_response,"Regardless, the server MUST close the connection after responding to such a request to avoid the potential attacks.",302,Fully Matches,"[{'A1': {'code': 'if (te && apr_table_get(r->headers_out, ""Content-Length"")) {\n    apr_table_unset(r->headers_out, ""Content-Length"");\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01107)\n                  ""server %s:%d returned Transfer-Encoding and Content-Length"",\n                  backend->hostname, backend->port);\n    backend->close = 1;\n}', 'explanation': ""This segment checks if both Transfer-Encoding and Content-Length headers are present. By unsetting the Content-Length header and setting 'backend->close = 1', the function ensures that the connection is closed after responding, which fully meets the RFC requirement to close the connection to avoid potential attacks.""}}]","The provided function directly implements the RFC specification by detecting the simultaneous presence of Transfer-Encoding and Content-Length headers. It then unsets the Content-Length header and forces the connection to close, thereby adhering to the requirement that the server MUST close the connection after responding. This implementation is contained entirely within the function_body, fulfilling the necessary spec constraint.",success,
15677,ap_proxy_http_process_response,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,61,Fully Matches,"[{'C1': {'code': 'if (!r->header_only && !AP_STATUS_IS_HEADER_ONLY(proxy_status)) {\n    // code to read and send response body\n    ...\n} else {\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, ""header only"");\n    proxy_run_detach_backend(r, backend);\n    ap_proxy_release_connection(backend->worker->s->scheme, backend, r->server);\n    req->backend = NULL;\n    e = apr_bucket_eos_create(c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, e);\n    ap_pass_brigade(r->output_filters, bb);\n    apr_brigade_cleanup(bb);\n}', 'explanation': 'This code explicitly checks if the request is header-only (i.e. a HEAD request). In the HEAD branch (when r->header_only is true), it avoids reading or sending a response body and only sends an End Of Stream (EOS) bucket, which fulfills the requirement that HEAD responses include headers only and not the message body.'}}, {'A1': {'code': '/* Discard body, if one is expected (not HEAD request) */\nif (!r->header_only) {\n    ...\n    ap_discard_request_body(backend->r);\n}', 'explanation': 'Within the error override branch, the function explicitly checks if the request is not header-only before attempting to process a message body. This is another instance ensuring that for HEAD requests, no content body is sent.'}}]","The function distinguishes between full GET-like requests and HEAD requests by using the r->header_only flag (and AP_STATUS_IS_HEADER_ONLY check). When a HEAD request is detected, it bypasses the logic that reads and sends the response body and instead sends only the headers (via an EOS bucket), in strict accordance with the HTTP RFC requirement that a HEAD response MUST NOT send content. Thus, the function fully meets the relevant condition and action as specified in the RFC.",success,
15677,ap_proxy_http_process_response,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'if (te && apr_table_get(r->headers_out, ""Content-Length"")) {\n    /* 2616 section 4.4, point 3: ""if both Transfer-Encoding\n     * and Content-Length are received, the latter MUST be\n     * ignored""; To help mitigate HTTP Splitting, unset Content-Length\n     * and shut down the backend server connection */\n    apr_table_unset(r->headers_out, ""Content-Length"");\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01107)\n                  ""server %s:%d returned Transfer-Encoding and Content-Length"",\n                  backend->hostname, backend->port);\n    backend->close = 1;\n}', 'explanation': 'This code segment unsets the Content-Length header when a Transfer-Encoding header is also present. By not forwarding the Content-Length header in such cases, it partly implements the RFC requirement to avoid forwarding a message with a potentially incorrect Content-Length value. However, it does not perform explicit validation of the Content-Length value (for instance, against the ABNF or checking for duplicate comma-separated values), so only part of the specification is addressed.'}}]","The RFC requires that a sender must not forward a message with a Content-Length header field value that is known to be incorrect. In this function, there is a specific check that, if both 'Transfer-Encoding' and 'Content-Length' are present, the 'Content-Length' header is removed, which avoids forwarding a conflicting or potentially incorrect Content-Length value. However, apart from this conditional removal, no additional validation or handling (such as verifying the header against the ABNF or correctly managing duplicate values) is performed within the function. Therefore, the function only partially matches the RFC's intended constraint when considered in isolation.",success,
15677,ap_proxy_http_process_response,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,[],"The RFC requires that a sender generating a message containing content SHOULD generate a Content‐Type header field (unless the media type is unknown). In this function, the code checks for an existing Content‐Type header in the response (using 'if ((buf = apr_table_get(r->headers_out, ""Content-Type"")))') and then sets it on the request via 'ap_set_content_type'. This shows an attempt to preserve a known Content-Type. However, the function does not generate a default Content-Type header when none is present, which would be expected from a complete implementation of the RFC guidance. Thus, the function only partially meets the specification requirement.",success,
15677,ap_proxy_http_process_response,"A sender of Upgrade MUST also send an ""Upgrade"" connection option in the Connection header field (Section 7.6.1) to inform intermediaries not to forward this field.",31,Fully Matches,"[{'C1': {'code': 'if (upgrade && ap_proxy_worker_can_upgrade(p, worker, upgrade,\n                                                   (*req->proto == \'w\')\n                                                   ? ""WebSocket"" : NULL)) {\n    apr_table_setn(r->headers_out, ""Connection"", ""Upgrade"");\n    apr_table_setn(r->headers_out, ""Upgrade"", apr_pstrdup(p, upgrade));\n}', 'explanation': ""This segment explicitly sets the 'Connection' header to 'Upgrade' when the upgrade header is present and validated. It directly implements the RFC requirement that a sender of Upgrade must also send an 'Upgrade' connection option in the Connection header field.""}}]","The function contains logic that directly addresses the requirement specified in the RFC. Specifically, when handling an upgrade response, it verifies the Upgrade header and then ensures that the Connection header is set to 'Upgrade' before forwarding the response. This meets the constraint as implemented entirely within the function, without relying on external dependencies.",success,
15677,ap_proxy_http_process_response,"A server MAY send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.",29,Partially Matches,"[{'A1': {'code': 'if (upgrade && ap_proxy_worker_can_upgrade(p, worker, upgrade,\n                                                   (*req->proto == \'w\')\n                                                   ? ""WebSocket"" : NULL)) {\n    apr_table_setn(r->headers_out, ""Connection"", ""Upgrade"");\n    apr_table_setn(r->headers_out, ""Upgrade"", apr_pstrdup(p, upgrade));\n}', 'explanation': ""This code segment checks for an 'Upgrade' header in the response and, if present and allowed by the worker configuration, explicitly sets the 'Connection' and 'Upgrade' headers in the outgoing response. In doing so, it implements the action of advertising protocol upgrade support as permitted by the RFC.""}}, {'C1': {'code': 'if (proxy_status == HTTP_SWITCHING_PROTOCOLS) {\n    if (!upgrade || !req->upgrade || (strcasecmp(req->upgrade, upgrade) != 0)) {\n        return ap_proxyerror(r, HTTP_BAD_GATEWAY,\n                             apr_pstrcat(p, ""Unexpected Upgrade: "",\n                                         upgrade ? upgrade : ""n/a"",\n                                         "" (expecting "",\n                                         req->upgrade ? req->upgrade : ""n/a"", "")"", NULL));\n    }\n    backend->close = 1;\n}', 'explanation': ""This snippet handles the case where a 101 Switching Protocols response is received. It verifies that an 'Upgrade' header is present and that it matches the expected upgrade protocol, thus partially addressing the RFC’s requirement regarding the use of an Upgrade header field.""}}]","The RFC specifies that a server MAY include an Upgrade header in responses to advertise support for upgrading protocols. The function shows visible logic for handling the Upgrade header: when the response status indicates a protocol switch (HTTP_SWITCHING_PROTOCOLS), it validates the header and, for other responses, it forwards the Upgrade header if it qualifies. However, it does not explicitly generate or enforce the presence of an Upgrade header for a 426 (Upgrade Required) response as mandated by the RFC context. Therefore, only part of the RFC’s conditions is directly implemented in this function.",success,
15677,ap_proxy_http_process_response,A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field.,27,Fully Matches,"[{'C1': {'code': 'if (proxy_status == HTTP_SWITCHING_PROTOCOLS) {\n    if (!upgrade || !req->upgrade || (strcasecmp(req->upgrade, upgrade) != 0)) {\n        return ap_proxyerror(r, HTTP_BAD_GATEWAY,\n                             apr_pstrcat(p, ""Unexpected Upgrade: "",\n                                         upgrade ? upgrade : ""n/a"",\n                                         "" (expecting "",\n                                         req->upgrade ? req->upgrade : ""n/a"", "")"",\n                                         NULL));\n    }\n    backend->close = 1;\n}', 'explanation': 'This code segment enforces that when the server is switching protocols (HTTP_SWITCHING_PROTOCOLS), it only does so if the Upgrade header in the response matches the one specified by the client (req->upgrade). The use of strcasecmp ensures a case-insensitive comparison as required by the RFC. This directly implements the requirement that the server MUST NOT switch to a protocol that was not indicated by the client.'}}]","The function explicitly checks for the HTTP_SWITCHING_PROTOCOLS status and then verifies that the Upgrade header in the response matches the protocol requested by the client using a case-insensitive comparison. This effectively enforces the RFC specification that a server must not switch to a protocol not advertised by the client in the Upgrade header. Therefore, the code in this function fully meets the constraint labeled C1.",success,
15677,ap_proxy_http_process_response,"A server that sends a 101 (Switching Protocols) response MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched; if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order.",26,Partially Matches,"[{'C1': {'code': 'if (proxy_status == HTTP_SWITCHING_PROTOCOLS) {\n    if (!upgrade || !req->upgrade || (strcasecmp(req->upgrade, upgrade) != 0)) {\n        return ap_proxyerror(r, HTTP_BAD_GATEWAY,\n                             apr_pstrcat(p, ""Unexpected Upgrade: "",\n                                         upgrade ? upgrade : ""n/a"",\n                                         "" (expecting "",\n                                         req->upgrade ? req->upgrade : ""n/a"", "")"",\n                                         NULL));\n    }\n    backend->close = 1;\n}', 'explanation': 'This code segment checks that when a 101 Switching Protocols response is received, an Upgrade header is present and that it matches the expected protocol in a case-insensitive manner. This addresses the requirement for a server to send an Upgrade header field in a 101 response.'}}]","The function attempts to enforce the requirement that a 101 (Switching Protocols) response must include an Upgrade header field by checking if such a header exists and by performing a case-insensitive comparison with the expected value. However, the code does not address the requirement to list multiple protocol layers in layer-ascending order or validate that the protocol was indicated by the client. Therefore, while it partially meets the spec (specifically, the part regarding the presence and case-insensitive comparison of the Upgrade header), it does not comprehensively implement all aspects of the RFC constraint.",success,
15677,ap_proxy_http_process_response,A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection.,25,Fully Matches,"[{'C1': {'code': 'for (i=0; hop_by_hop_hdrs[i]; ++i) {\n    apr_table_unset(r->headers_out, hop_by_hop_hdrs[i]);\n}', 'explanation': ""This loop removes all hop‐by‐hop headers (including 'Upgrade') from the response unless explicitly re‐added later. It implements the RFC allowance that a server may ignore the Upgrade header when it continues with the current protocol.""}}, {'A1': {'code': 'if (upgrade && ap_proxy_worker_can_upgrade(p, worker, upgrade, (*req->proto == \'w\') ? ""WebSocket"" : NULL)) {\n    apr_table_setn(r->headers_out, ""Connection"", ""Upgrade"");\n    apr_table_setn(r->headers_out, ""Upgrade"", apr_pstrdup(p, upgrade));\n}', 'explanation': 'This conditional re-adds the Upgrade header to the response only when the backend’s requested upgrade matches the proxy’s configuration (i.e. a deliberate protocol change). When the criteria are not met, the header remains removed, effectively causing the server to ignore the Upgrade header as allowed by the RFC.'}}]","The function processes the response from the backend by first removing hop-by-hop headers—including the Upgrade header—and then conditionally re-adding the Upgrade header only if the response status is HTTP_SWITCHING_PROTOCOLS and the expected upgrade protocol matches. In doing so, it ensures that when no protocol change is negotiated, the Upgrade header is ignored, which is in full adherence with the RFC specification.",success,
15677,ap_proxy_http_process_response,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'te = apr_table_get(r->headers_out, ""Transfer-Encoding"");\n            if (te && apr_table_get(r->headers_out, ""Content-Length"")) {\n                apr_table_unset(r->headers_out, ""Content-Length"");\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01107)\n                              ""server %s:%d returned Transfer-Encoding and Content-Length"",\n                              backend->hostname, backend->port);\n                backend->close = 1;\n            }', 'explanation': 'This code snippet explicitly checks whether a Transfer-Encoding header is present and, if so, unsets the Content-Length header. This adheres to the RFC specification that a sender MUST NOT send a Content-Length header when a Transfer-Encoding header exists.'}}]","The function visibly implements the required behavior by detecting a Transfer-Encoding header in the response and unsetting the Content-Length header to prevent sending both headers together, which fully addresses the specified RFC constraint.",success,
15677,ap_proxy_http_process_response,A server MAY reject a request that contains both Content-Length and Transfer-Encoding or process such a request in accordance with the Transfer-Encoding alone.,198,Fully Matches,"[{'C1': {'code': 'te = apr_table_get(r->headers_out, ""Transfer-Encoding"");\nif (te && apr_table_get(r->headers_out, ""Content-Length"")) {\n    apr_table_unset(r->headers_out, ""Content-Length"");\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01107)\n                  ""server %s:%d returned Transfer-Encoding and Content-Length"",\n                  backend->hostname, backend->port);\n    backend->close = 1;\n}', 'explanation': 'This code segment checks if both Transfer-Encoding and Content-Length headers are present in the response. When both are found, it unsets the Content-Length header (thereby giving precedence to Transfer-Encoding) and sets the backend connection to close, which conforms to the RFC requirement.'}}, {'A1': {'code': 'backend->close = 1;', 'explanation': 'By enforcing the closure of the backend connection after detecting conflicting headers, the code meets the action requirement to close the connection to prevent potential vulnerabilities as outlined in the RFC.'}}]","The function 'ap_proxy_http_process_response' directly implements the RFC specification by checking for the presence of both Transfer-Encoding and Content-Length headers. Upon detecting both, it removes the Content-Length header and ensures that the backend connection is marked for closure. This behavior matches the RFC's mandate that Transfer-Encoding should override Content-Length and that the connection should be closed to avoid potential security issues.",success,
15677,ap_proxy_http_process_response,"* A server that sends a 100 (Continue) response MUST ultimately send a final status code, once it receives and processes the request content, unless the connection is closed prematurely.",82,Fully Matches,"[{'C1': {'code': 'if (do_100_continue && (!interim_response || proxy_status == HTTP_CONTINUE)) {\n    /* ... */\n    int do_send_body = (proxy_status == HTTP_CONTINUE || (!toclose && major > 0 && minor > 0));\n    /* Reset timeout if adjusted */\n    if (worker->s->ping_timeout_set) {\n        apr_socket_timeout_set(backend->sock, old_timeout);\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(10153)\n                  ""HTTP: %s100 continue sent by %pI (%s): %ssending body (response: HTTP/%i.%i %s)"",\n                  proxy_status != HTTP_CONTINUE ? ""no "" : """",\n                  backend->addr,\n                  backend->hostname ? backend->hostname : """",\n                  do_send_body ? """" : ""not "",\n                  major, minor, proxy_status_line);\n\n    if (do_send_body) {\n        status = send_continue_body(req);\n        if (status != OK) {\n            return status;\n        }\n    }\n    /* Once only! */\n    do_100_continue = 0;\n}', 'explanation': 'This code block detects when a 100 Continue response is received (or when the interim response state is active) and then calls send_continue_body(req) to process the request body. It then resets the do_100_continue flag, ensuring that after the interim 100 Continue phase the backend response processing eventually leads to a final status code being handled. This directly addresses the RFC requirement that a server sending a 100 Continue MUST eventually send a final status code.'}}]","The function 'ap_proxy_http_process_response' explicitly checks for the 100 Continue condition using the do_100_continue flag and handles interim responses. It ensures that if a 100 Continue or other interim response is processed, the request body is either sent or discarded appropriately and the final status response from the backend is subsequently processed and returned. The included code segment clearly shows that after handling the 100 Continue, the connection is not left hanging and the final status code is eventually sent, which is in accordance with the HTTP RFC specification.",success,
15677,ap_proxy_http_process_response,A server generating a 401 (Unauthorized) response MUST send a WWW-Authenticate header field containing at least one challenge.,92,Partially Matches,"[{'C1': {'code': 'if (ap_proxy_should_override(dconf, proxy_status)) {\n    if (proxy_status == HTTP_UNAUTHORIZED) {\n        const char *buf;\n        const char *wa = ""WWW-Authenticate"";\n        if ((buf = apr_table_get(r->headers_out, wa))) {\n            apr_table_set(r->err_headers_out, wa, buf);\n        } else {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01109) ""origin server sent 401 without WWW-Authenticate header"");\n        }\n    }\n    ...\n}', 'explanation': 'The function checks for a 401 Unauthorized response and then looks for the WWW-Authenticate header in the backend response. If found, it includes it in the error headers; if not found, it only logs a debug message. This shows an attempt to address the requirement, but the function does not add or enforce the header if missing.'}}]","The RFC requirement mandates that a server must include a WWW-Authenticate header with at least one authentication challenge in a 401 response. Within the function, when a 401 response is received, there is logic that checks for the presence of the 'WWW-Authenticate' header and transfers it to the error headers. However, if the header is missing, the function only logs a message rather than providing a default challenge. Thus, the code only partially meets the constraint on its own.",success,
15677,ap_proxy_http_process_response,The server MUST generate an Upgrade header field in the response that indicates which protocol(s) will be in effect after this response.,140,Fully Matches,"[{'A1': {'code': 'if (proxy_status == HTTP_SWITCHING_PROTOCOLS) {\n    if (!upgrade || !req->upgrade || (strcasecmp(req->upgrade, upgrade) != 0)) {\n        return ap_proxyerror(r, HTTP_BAD_GATEWAY,\n                             apr_pstrcat(p, ""Unexpected Upgrade: "",\n                                         upgrade ? upgrade : ""n/a"",\n                                         "" (expecting "",\n                                         req->upgrade ? req->upgrade : ""n/a"",\n                                         "")"", NULL));\n    }\n    backend->close = 1;\n}\n\n...\n\nif (upgrade && ap_proxy_worker_can_upgrade(p, worker, upgrade, (*req->proto == \'w\') ? ""WebSocket"" : NULL)) {\n    apr_table_setn(r->headers_out, ""Connection"", ""Upgrade"");\n    apr_table_setn(r->headers_out, ""Upgrade"", apr_pstrdup(p, upgrade));\n}', 'explanation': ""These code segments explicitly check if the server is processing a Switching Protocols response and then set the 'Upgrade' header in the response (along with the necessary 'Connection: Upgrade' header), which directly implements the RFC requirement that the Upgrade header field be generated to indicate the protocol in effect after the response.""}}]","The function 'ap_proxy_http_process_response' contains clear logic for handling HTTP 101 Switching Protocols responses. It verifies that the incoming Upgrade header matches the expected protocol and, if valid, sets the Upgrade header in the outgoing response along with the appropriate Connection header. This meets the RFC specification requirement that the server MUST generate an Upgrade header indicating the protocol(s) to be used, thereby fully addressing the spec constraint within this function.",success,
15678,proxy_http_handler,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'A1': {'code': 'if ((r->proxyreq == PROXYREQ_REVERSE) && (!c->keepalives)\n        && (apr_table_get(r->subprocess_env, ""proxy-initial-not-pooled""))) {\n        backend->close = 1;\n    }\n    ...\n    if (req->backend) {\n        if (status != OK)\n            req->backend->close = 1;\n        ap_proxy_release_connection(scheme, req->backend, r->server);\n    }', 'explanation': 'The function flags the connection for closure (by setting backend->close) under specific conditions such as when the connection should not be reused (e.g., reverse proxy requests without keep-alives) or when an error status is detected. This behavior reflects the RFC statement that a client, server, or proxy may close the transport connection at any time.'}}]","The RFC permits any involved party to close the transport connection at any time, and the provided function includes logic to mark the backend connection for closure under certain conditions, such as non-pooling for reverse proxy requests and error handling. However, the function does not fully implement the recommended graceful shutdown procedures or monitor for a closure signal continuously, so while it addresses part of the RFC requirement by allowing the connection to be closed, the implementation is only partial.",success,
15681,uwsgi_canon,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'apr_port_t port = UWSGI_DEFAULT_PORT;\n...\nif (port != UWSGI_DEFAULT_PORT)\n    apr_snprintf(sport, sizeof(sport), "":%u"", port);\nelse\n    sport[0] = \'\\0\';', 'explanation': ""The function initializes the port with UWSGI_DEFAULT_PORT and later checks if the port differs from the default. If no port is provided (i.e. it remains the default), the code omits it from the constructed URL, which aligns with the RFC's guidance that a missing port may be interpreted as the default port.""}}]","The provided function directly implements the RFC requirement by initializing the port with a default value and conditionally appending the port in the URL only when it differs from that default. This behavior clearly satisfies the specification stating that if a port is not provided, the default port is assumed.",success,
15681,uwsgi_canon,Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.,180,Partially Matches,"[{'C1': {'code': 'err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);\nif (err) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10097)\n                  ""error parsing URL %s: %s"", url, err);\n    return HTTP_BAD_REQUEST;\n}', 'explanation': 'This segment checks if the URL is malformed (i.e. if parsing fails) and returns a 400 Bad Request. This addresses part of the RFC requirement to reject invalid request-lines.'}}, {'A1': {'code': 'if (path == url && *ap_scan_vchar_obstext(path)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10417)\n                  ""To be forwarded path contains control characters or spaces"");\n    return HTTP_FORBIDDEN;\n}', 'explanation': 'This code checks for the presence of control characters or spaces in the request-target. Although the RFC suggests a 400 error or a 301 redirect with proper encoding, this function returns HTTP_FORBIDDEN for unencoded whitespace/control characters, thus partially addressing the requirement.'}}]","The function validates the URL by checking for parsing errors and for disallowed characters in the request-target. It ensures that malformed URLs do not proceed by returning HTTP_BAD_REQUEST or HTTP_FORBIDDEN. However, it does not implement the alternate behavior of issuing a 301 (Moved Permanently) redirect with a properly encoded request-target as specified by the RFC. Therefore, only part of the specification (the error response via a 400 status) is addressed directly in this function.",success,
15683,uwsgi_send_headers,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'uwsgi_send_headers' assembles a header packet from environment variables and then sends it over a connection. However, it does not contain any logic that checks or enforces the specific HTTP RFC requirement that a sender must not generate protocol elements or syntax alternatives that are reserved for other roles. No part of the function examines the sender's role or validates that only the allowed headers (or protocol elements) for that role are generated, which is the main constraint specified in the RFC. As such, the function does not visibly address any labeled conditions (e.g., C1) or actions (e.g., A1) related to this RFC requirement within its own logic.",success,
15683,uwsgi_send_headers,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided code function, uwsgi_send_headers, constructs a header packet by iterating over environment variables and encoding key-value pairs without performing any validation to ensure that the generated protocol elements match the grammar defined by the ABNF rules. There is no logic within the function that checks if the headers conform to the specified RFC requirements (i.e., the sender must not generate protocol elements that do not match the grammar). As such, this function does not address the listed spec constraint.",success,
15686,uwsgi_response,"A server MUST send the space that separates the status-code from the reason-phrase even when the reason-phrase is absent (i.e., the status-line would end with the space).",300,Fully Matches,"[{'C1': {'code': ""keepchar = buffer[status_end];\nbuffer[status_end] = '\\0';\n...\nif (keepchar != '\\0') {\n    buffer[status_end] = keepchar;\n}\nelse {\n    /* 2616 requires the space in Status-Line; the origin\n     * server may have sent one but ap_rgetline will\n     * have stripped it. */\n    buffer[status_end] = ' ';\n    buffer[status_end + 1] = '\\0';\n}"", 'explanation': 'This code checks whether the character following the status code is missing (i.e., the space was stripped). If it is missing, it explicitly sets a space at that position to comply with the RFC requirement that a space must separate the status-code from the reason-phrase even when the reason-phrase is absent.'}}]","The function handles the specific RFC requirement by verifying the presence of the space after the status-code and, if absent, inserting one. This directly addresses the specified RFC constraint that requires a space be sent after the status code, fully within the function without reliance on external dependencies.",success,
15686,uwsgi_response,"Regardless, the server MUST close the connection after responding to such a request to avoid the potential attacks.",302,Fully Matches,"[{'A1': {'code': 'if (apr_table_get(r->headers_out, ""Transfer-Encoding"")) {\n    apr_table_unset(r->headers_out, ""Content-Length"");\n    backend->close = 1;\n}', 'explanation': 'This code segment directly implements the RFC requirement by checking for the ""Transfer-Encoding"" header and, if present, unsetting the ""Content-Length"" header and setting the connection\'s close flag. This ensures the connection will be closed after the response, fulfilling the action mandated by the spec.'}}]","The RFC specifies that the server must close the connection after responding to requests that could pose vulnerabilities (i.e., those with Transfer-Encoding or both Transfer-Encoding and Content-Length headers). The function implements this by checking for the presence of the ""Transfer-Encoding"" header and then setting a flag (backend->close = 1) to ensure the connection is closed. Thus, the function fully addresses the required action within its own logic.",success,
15686,uwsgi_response,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,"[{'A1': {'code': 'if ((buf = apr_table_get(r->headers_out, ""Content-Type""))) {\n        ap_set_content_type(r, apr_pstrdup(r->pool, buf));\n    }', 'explanation': 'This code snippet checks if a Content-Type header exists in the backend response headers and then sets it for the current response. It addresses the part of the RFC that requires a Content-Type header to be included when the media type is known.'}}]","The RFC specifies that a sender generating a message with content SHOULD include a Content-Type header if the intended media type is known. In the function, the Content-Type header is only set if it is found in the backend response, as shown in the provided snippet. However, if the header is missing (and the media type is known), the function does not generate or default to a Content-Type header. Therefore, while the function handles the case when a Content-Type header is present (satisfying part of the requirement), it does not implement a mechanism to generate the header if it is missing, resulting in a partial match of the specification.",success,
15686,uwsgi_response,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': ""while (apr_isspace(*value))\n    ++value;\nfor (end = &value[strlen(value) - 1]; end > value && apr_isspace(*end); --end)\n    *end = '\\0';"", 'explanation': 'This segment explicitly removes any leading and trailing whitespace from the header value before it is used. This implements the RFC requirement that even if the HTTP version allows whitespace, the parsing must exclude it prior to evaluating the field value.'}}]","The function_body, in the header parsing section, directly addresses the RFC mandate by trimming whitespace from header field values. The loops that remove leading whitespace (using apr_isspace) and trailing whitespace are the precise measures needed to ensure that any allowed whitespace is excluded before processing the field value. This means that the function, by itself, fully implements the whitespace exclusion requirement from the spec.",success,
15686,uwsgi_response,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': ""if (keepchar != '\\0') {\n    buffer[status_end] = keepchar;\n} else {\n    /* 2616 requires the space in Status-Line; the origin\n     * server may have sent one but ap_rgetline will\n     * have stripped it. */\n    buffer[status_end] = ' ';\n    buffer[status_end + 1] = '\\0';\n}"", 'explanation': 'This code segment attempts to recover a usable protocol element by restoring the missing space in the HTTP Status-Line, which is an effort to deal with an otherwise malformed status line as permitted by the RFC specification.'}}]","The provided function shows an attempt to implement the RFC's allowance for recovery from invalid constructs by, for example, inserting a missing space in a status line if it was stripped during input. However, in other cases—such as when a header line is too long or completely invalid—the function opts to return an error instead of attempting further recovery. As a result, while the function addresses the recovery aspect in at least one specific instance (labeled here as C1), it does not fully implement recovery for all potential invalid cases described in the spec, leading to a partial match.",success,
15686,uwsgi_response,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'len = ap_getline(buffer, sizeof(buffer), rp, 1);\nif (len <= 0) {\n    /* invalid or empty */\n    return HTTP_INTERNAL_SERVER_ERROR;\n}\nbackend->worker->s->read += len;\nif ((apr_size_t)len >= sizeof(buffer)) {\n    /* too long */\n    return HTTP_INTERNAL_SERVER_ERROR;\n}\n\nif (apr_date_checkmask(buffer, ""HTTP/#.# ###*"")) {\n    status_start = 9;\n}\nelse if (apr_date_checkmask(buffer, ""HTTP/# ###*"")) {\n    status_start = 7;\n}\nelse {\n    /* not HTTP */\n    return HTTP_BAD_GATEWAY;\n}\n\nwhile ((len = ap_getline(buffer, sizeof(buffer), rp, 1)) > 0) {\n    if ((apr_size_t)len >= sizeof(buffer)) {\n        /* too long */\n        len = -1;\n        break;\n    }\n    value = strchr(buffer, \':\');\n    if (!value) {\n        /* invalid header */\n        len = -1;\n        break;\n    }\n    *value++ = \'\\0\';\n    if (*ap_scan_http_token(buffer)) {\n        /* invalid name */\n        len = -1;\n        break;\n    }\n    ...', 'explanation': 'The code implements defensive parsing by checking if the received protocol line fits in the designated buffer, validating that the HTTP status line conforms to one of the expected formats, and ensuring that header lines contain a colon and valid tokens. These measures directly address the requirement to accept only marginally well-formed elements.'}}, {'A1': {'code': 'if (len < 0) {\n    /* Reset headers, but not to NULL because things below the chain expect\n     * this to be non NULL e.g. the ap_content_length_filter.\n     */\n    r->headers_out = apr_table_make(r->pool, 1);\n    return HTTP_BAD_GATEWAY;\n}\n\nif (apr_table_get(r->headers_out, ""Transfer-Encoding"")) {\n    apr_table_unset(r->headers_out, ""Content-Length"");\n    backend->close = 1;\n}', 'explanation': 'The function takes a defensive action by immediately returning an error status when it detects an invalid or overly long protocol element or header. Additionally, it carefully manages conflicting headers, ensuring that Transfer-Encoding overrides Content-Length, which reflects cautious processing as required by the spec.'}}]","The function 'uwsgi_response' directly implements defensive parsing as described in the RFC specification. It performs multiple checks to ensure that the input does not exceed a fixed buffer size, validates that the HTTP status line and header fields conform minimally to expected grammar (through checks like the colon presence and token validity), and responds appropriately to malformed input by returning error codes. These safeguards match the RFC's requirement for defensive parsing of received protocol elements.",success,
15686,uwsgi_response,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'len = ap_getline(buffer, sizeof(buffer), rp, 1);\nif (len <= 0) {\n    /* invalid or empty */\n    return HTTP_INTERNAL_SERVER_ERROR;\n}\n\nif (apr_date_checkmask(buffer, ""HTTP/#.# ###*"")) {\n    status_start = 9;\n}\nelse if (apr_date_checkmask(buffer, ""HTTP/# ###*"")) {\n    status_start = 7;\n}\nelse {\n    /* not HTTP */\n    return HTTP_BAD_GATEWAY;\n}\n\nkeepchar = buffer[status_end];\nbuffer[status_end] = \'\\0\';\nr->status = atoi(&buffer[status_start]);\n\nif (keepchar != \'\\0\') {\n    buffer[status_end] = keepchar;\n}\nelse {\n    /* 2616 requires the space in Status-Line; the origin\n     * server may have sent one but ap_rgetline will\n     * have stripped it. */\n    buffer[status_end] = \' \';\n    buffer[status_end + 1] = \'\\0\';\n}', 'explanation': 'This segment demonstrates that the function attempts to interpret the received HTTP response according to expected status line formats. It checks for patterns defined by the spec and extracts the HTTP status code accordingly, which aligns with the requirement to interpret a received protocol element per the RFC semantics.'}}, {'A1': {'code': ""while ((len = ap_getline(buffer, sizeof(buffer), rp, 1)) > 0) {\n    if ((apr_size_t)len >= sizeof(buffer)) {\n        /* too long */\n        len = -1;\n        break;\n    }\n    value = strchr(buffer, ':');\n    if (!value) {\n        /* invalid header */\n        len = -1;\n        break;\n    }\n    *value++ = '\\0';\n    if (*ap_scan_http_token(buffer)) {\n        /* invalid name */\n        len = -1;\n        break;\n    }\n    while (apr_isspace(*value))\n        ++value;\n    /* Trim trailing whitespace */\n    for (end = &value[strlen(value) - 1]; end > value && apr_isspace(*end); --end)\n        *end = '\\0';\n    if (*ap_scan_http_field_content(value)) {\n        /* invalid value */\n        len = -1;\n        break;\n    }\n    apr_table_add(r->headers_out, buffer, value);\n}\nif (len < 0) {\n    /* Reset headers, but not to NULL because things below the chain expect\n     * this to be non NULL e.g. the ap_content_length_filter.\n     */\n    r->headers_out = apr_table_make(r->pool, 1);\n    return HTTP_BAD_GATEWAY;\n}"", 'explanation': 'This portion of the code shows that the function not only parses header fields according to the expected syntax, but also applies error checks. When encountering an invalid header (e.g., header too long, missing colon, invalid tokens), it resets the headers and returns an error status, demonstrating an effort to either recover a usable protocol element or reject an element that deviates from the protocol specifications.'}}]","The function 'uwsgi_response' implements several key steps required by the HTTP RFC specification for interpreting a received protocol element. It verifies the status line format (C1) and applies rigorous checks when parsing the header lines, taking corrective actions (A1) when encountering irregularities, such as missing separators or malformed headers. Although it does provide mechanisms to recover from certain invalid constructs (for example, reinserting a required space in the status line if stripped), the recovery mechanisms are basic and may not cover every possible error recovery strategy outlined in the RFC. As such, while the function addresses core aspects of the spec, not all nuanced recovery or extension behaviors are handled within this function alone. This leads to a judgment of 'Partially Matches' the RFC constraints as implemented in this function.",success,
15686,uwsgi_response,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function_body primarily focuses on parsing the HTTP response line and headers from a backend server, validating their syntax, and then passing them to the output filters. Although it checks for header validity (e.g., using ap_scan_http_token and ap_scan_http_field_content), there is no explicit logic that ensures the sender does not generate protocol elements or syntax alternatives that should only be generated by participants in other roles. In other words, the function does not implement any logic specifically aimed at preventing generation of elements reserved for other roles, which is the core of the RFC specification provided. Therefore, the code function does not visibly address the specified RFC constraint.",success,
15686,uwsgi_response,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'if (apr_table_get(r->headers_out, ""Transfer-Encoding"")) {\n    apr_table_unset(r->headers_out, ""Content-Length"");\n    backend->close = 1;\n}', 'explanation': 'This code checks if the Transfer-Encoding header is present and then removes the Content-Length header, directly implementing the RFC requirement that a sender MUST NOT send a Content-Length header in any message that contains a Transfer-Encoding header field.'}}]","The function clearly addresses the HTTP RFC specification by unconditionally checking for a Transfer-Encoding header in the response headers and, if found, unsetting the Content-Length header. This meets the labeled condition (C1) fully in the function body itself.",success,
15694,proxy_connect_handler,A server MUST NOT send a Transfer-Encoding header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6 of [HTTP]).,194,Fully Matches,"[{'C1': {'code': 'nbytes = apr_snprintf(buffer, sizeof(buffer),\n                              ""HTTP/1.0 200 Connection Established"" CRLF);\nap_xlate_proto_to_ascii(buffer, nbytes);\nap_fwrite(c->output_filters, bb, buffer, nbytes);\nnbytes = apr_snprintf(buffer, sizeof(buffer),\n                              ""Proxy-agent: %s"" CRLF CRLF,\n                              ap_get_server_banner());\nap_xlate_proto_to_ascii(buffer, nbytes);\nap_fwrite(c->output_filters, bb, buffer, nbytes);', 'explanation': ""For a CONNECT request (when proxyport is false), the code sends a '200 Connection Established' response along with a 'Proxy-agent' header but does not send a Transfer-Encoding header. This absence fulfills the RFC requirement that a 2xx response to a CONNECT request MUST NOT include a Transfer-Encoding header.""}}]","The function specifically handles CONNECT requests by first verifying the method and then sending a minimal response that does not include any Transfer-Encoding header. The code branch for constructing the response explicitly only writes the status line and a Proxy-agent header, thereby ensuring compliance with the RFC constraint. Since there is no logic in the function that adds or manipulates a Transfer-Encoding header, this function fully complies with the given requirement.",success,
15694,proxy_connect_handler,"A server MUST reject a CONNECT request that targets an empty or invalid port number, typically by responding with a 400 (Bad Request) status code.",74,Partially Matches,[],"The RFC requires that a CONNECT request targeting an empty or invalid port number must be rejected, typically with a 400 (Bad Request) response. In this function, there is an attempt to check the port by parsing the URI (using apr_uri_parse_hostinfo) and then invoking allowed_port(c_conf, uri.port). However, this check does not explicitly detect an empty port, nor does it return a 400 error code if the port is missing or invalid; instead, it returns HTTP_FORBIDDEN. Additionally, the only instance where a 400 response is returned is when the URI cannot be parsed at all, which is distinct from the case of an empty or invalid port. Therefore, because the function only partially addresses the spec—the port validation logic is present but does not adhere to the RFC’s mandate regarding error code and explicit handling of an empty or invalid port—the function is considered to only partially match the specification.",success,
15694,proxy_connect_handler,A server MUST NOT send any Transfer-Encoding or Content-Length header fields in a 2xx (Successful) response to CONNECT.,76,Fully Matches,"[{'C1': {'code': 'ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, ""Returning 200 OK"");\nnbytes = apr_snprintf(buffer, sizeof(buffer), ""HTTP/1.0 200 Connection Established"" CRLF);\nap_xlate_proto_to_ascii(buffer, nbytes);\nap_fwrite(c->output_filters, bb, buffer, nbytes);\nnbytes = apr_snprintf(buffer, sizeof(buffer), ""Proxy-agent: %s"" CRLF CRLF, ap_get_server_banner());\nap_xlate_proto_to_ascii(buffer, nbytes);\nap_fwrite(c->output_filters, bb, buffer, nbytes);\nap_fflush(c->output_filters, bb);', 'explanation': ""The code sends a 200 Connection Established response and only includes the 'Proxy-agent' header, thereby avoiding the inclusion of Transfer-Encoding and Content-Length headers as required by the RFC for a 2xx CONNECT response.""}}]","By inspecting the function_body, the CONNECT handler for non-proxy connections explicitly constructs a 200 OK response without adding any Transfer-Encoding or Content-Length header fields. This behavior directly conforms to the RFC specification, thereby fully matching the constraint.",success,
15694,proxy_connect_handler,A server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request (Section 9.3.6).,46,Fully Matches,"[{'C1': {'code': 'nbytes = apr_snprintf(buffer, sizeof(buffer), ""HTTP/1.0 200 Connection Established"" CRLF);\nap_xlate_proto_to_ascii(buffer, nbytes);\nap_fwrite(c->output_filters, bb, buffer, nbytes);\nnbytes = apr_snprintf(buffer, sizeof(buffer), ""Proxy-agent: %s"" CRLF CRLF, ap_get_server_banner());\nap_xlate_proto_to_ascii(buffer, nbytes);\nap_fwrite(c->output_filters, bb, buffer, nbytes);\nap_fflush(c->output_filters, bb);', 'explanation': 'This code segment sends a 200 OK response for a CONNECT request and deliberately does not include a Content-Length header, conforming to the RFC requirement.'}}]",The provided function explicitly handles CONNECT requests by producing a 200 Connection Established response without inserting a Content-Length header field. This directly addresses the specified RFC requirement that a server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request.,success,
15701,ajp_msg_end,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Fully Matches,"[{'C1': {'code': 'if (msg->server_side) {\n    msg->buf[0] = 0x41;\n    msg->buf[1] = 0x42;\n} else {\n    msg->buf[0] = 0x12;\n    msg->buf[1] = 0x34;\n}', 'explanation': ""This segment checks the sender's role via 'msg->server_side' and sets the header bytes accordingly. It ensures that the function only emits protocol elements (header bytes) that are permitted for its role, thereby preventing a sender from generating elements reserved for other roles as mandated by the spec.""}}, {'A1': {'code': 'msg->buf[2] = (apr_byte_t)((len >> 8) & 0xFF);\nmsg->buf[3] = (apr_byte_t)(len & 0xFF);', 'explanation': 'This code correctly appends the message length into the header after the role‐specific bytes, which is part of constructing a proper protocol message as expected from the sender’s role handling.'}}]","The function 'ajp_msg_end' inspects the role of the sender (via the 'msg->server_side' flag) and emits header bytes accordingly, fulfilling the requirement that a sender must not produce elements not permitted for its role. The separation of header construction into a branch based on role (server or non-server) clearly implements condition C1 and action A1 from the spec constraints. All role‐based logic is handled within the function, meeting the RFC requirement in scope.",success,
15706,ajp_msg_append_string_ex,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The code function ajp_msg_append_string_ex is responsible for appending a string to a message buffer and optionally converting it from EBCDIC, but it does not contain any logic that checks or enforces that only protocol elements permitted for the sender’s role are generated. There is no verification against role-specific constraints or any mechanism to prevent generating syntax alternatives that are reserved for other roles. As a result, this function does not address the RFC requirement that a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles.",success,
15741,argstr_to_table,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'argstr_to_table' merely parses a query string into key-value pairs, performs URL unescaping, and populates a table. It does not contain any logic related to checking or enforcing role-based restrictions on protocol element generation, as required by the RFC specification. There is no evidence in the function that it validates which protocol elements should or should not be generated based on the sender's role, or that it prevents generation of elements reserved for other roles. Therefore, none of the spec constraints (e.g., C1 or A1) are addressed within this function.",success,
15763,exipc_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'r->content_type = ""text/html"";', 'explanation': 'This line directly sets the Content-Type header for the response, ensuring that when the handler generates a message with content (i.e., when r->header_only is false), a Content-Type header is present in the message as required by the RFC.'}}]","The RFC specifies that a sender generating a message with content should include a Content-Type header unless the media type is unknown to the sender. The function implements this requirement by unconditionally setting r->content_type to ""text/html"" before outputting the content. Although the specification context mentions a charset (text/html; charset=ISO-8859-4), the RFC requirement is met by including a valid Content-Type header field, and thus the code function fully addresses the constraint within its scope.",success,
15763,exipc_handler,"If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type.",35,Does Not Match,[],"The RFC specification requires that if the Content-Type header is absent, the recipient should assume a default (application/octet-stream) or try to determine the media type. However, the function unconditionally sets r->content_type to ""text/html"" without checking if the header exists or applying the fallback logic described in the RFC. Therefore, no part of the code addresses the spec constraints regarding handling of the Content-Type header as specified.",success,
15780,x_post_config,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,44,Does Not Match,[],"The provided code function is only performing a logging operation and then returning OK. It does not contain any logic related to handling Content-Length header fields or evaluating conditions specified in the RFC specification (such as sending a Content-Length header only when it exactly equals the octet count of the corresponding GET or HEAD response). No part of the code within function_body implements any of the labeled constraints (like C1, A1, etc.) as required by the RFC specification.",success,
15787,x_handler,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,61,Fully Matches,"[{'A1': {'code': 'if (r->header_only) {\n    return OK;\n}', 'explanation': 'This code checks if the request is only for the headers (i.e. a HEAD request) and returns OK immediately without sending any body content. This implements the RFC requirement that a HEAD response must not include a message body.'}}]","The function explicitly checks the r->header_only flag and returns OK early in the processing, which prevents any content from being written to the response. This satisfies the specification that the HEAD method should behave like GET except that it must not send the response body.",success,
15787,x_handler,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The RFC requires that an origin server must not use the context information (from Content-Location) to alter the request semantics. In the provided x_handler function, there is no logic addressing or even referencing the Content-Location header or its associated context. The function simply handles generating HTML output without examining or using any request context that could affect request semantics. Therefore, it does not visibly implement the specified RFC constraint.",success,
15787,x_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'ap_set_content_type_ex(r, ""text/html"", 1);', 'explanation': ""The function explicitly sets the Content-Type header to 'text/html' before any content is generated. This directly implements the RFC specification requirement that a sender generating a message with content SHOULD include a Content-Type header field when the media type is known.""}}]","The code function checks that the current request is intended for this handler and then calls ap_set_content_type_ex() to set the Content-Type header. This is done before the content is output (and also on HEAD requests), ensuring that the outgoing message contains a Content-Type header. Thus, in isolation, the function visibly implements the relevant spec constraint.",success,
15820,note_basic_auth_failure,"For historical reasons, a sender MUST only generate the quoted-string syntax.",277,Fully Matches,"[{'C1': {'code': 'apr_pstrcat(r->pool, ""Basic realm=\\"""", ap_auth_name(r), ""\\"""", NULL)', 'explanation': 'The function constructs the authentication header by explicitly generating a quoted-string (with the double quotes surrounding the realm), which directly implements the requirement that the sender MUST only generate the quoted-string syntax.'}}]","The code in the function directly uses a quoted-string syntax for the realm parameter (as seen in the use of ""Basic realm=\"""" and appending the closing quote), thus fulfilling the RFC constraint that mandates only the quoted-string format to be generated. No extraneous logic is present, and the implementation is fully contained within the function without reliance on external dependencies.",success,
15820,note_basic_auth_failure,A server MAY generate a WWW-Authenticate header field in other response messages to indicate that supplying credentials (or different credentials) might affect the response.,93,Fully Matches,"[{'C1': {'code': 'apr_table_setn(r->err_headers_out,\n               (PROXYREQ_PROXY == r->proxyreq) ? ""Proxy-Authenticate"" : ""WWW-Authenticate"",\n               apr_pstrcat(r->pool, ""Basic realm=\\"""", ap_auth_name(r), ""\\"""", NULL));', 'explanation': ""This code explicitly sets either the 'WWW-Authenticate' header or the 'Proxy-Authenticate' header with a Basic authentication challenge. This directly aligns with the RFC requirement to generate a WWW-Authenticate header in responses to indicate that supplying credentials might affect the response.""}}]","The function 'note_basic_auth_failure' directly implements the necessary logic by setting the appropriate authentication header field. It uses the decision based on whether the request is from a proxy to set either 'Proxy-Authenticate' or 'WWW-Authenticate' header with a Basic realm challenge, thereby visibly addressing the RFC specification regarding the generation of a WWW-Authenticate header field.",success,
15822,get_basic_auth,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': ""/* Skip leading spaces. */\nwhile (*auth_line == ' ' || *auth_line == '\\t') {\n    auth_line++;\n}"", 'explanation': 'This loop explicitly removes leading whitespace (SP and HTAB) from the header value before further processing, thereby meeting the RFC requirement to exclude such whitespace prior to evaluating the field value.'}}]","The function retrieves the Authorization header, verifies the 'Basic' scheme, and then intentionally skips over any leading whitespace characters using a while loop. This directly addresses the specification that the implementation MUST exclude such whitespace prior to evaluating the field value, ensuring compliance with the HTTP RFC.",success,
15822,get_basic_auth,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': ""while (*auth_line == ' ' || *auth_line == '\\t') {\n    auth_line++;\n}"", 'explanation': 'This loop explicitly removes leading spaces and tabs from the authorization string before it is processed, thereby fulfilling the RFC requirement to parse and remove bad whitespace before interpreting the protocol element.'}}]","The function retrieves the authorization header and, after checking that the authentication scheme is Basic, it explicitly skips over any leading spaces or tabs. This directly addresses the RFC mandate that a recipient must remove bad whitespace prior to interpreting protocol elements. All of the whitespace-handling logic necessary to meet the specified constraint is contained within this function, so it fully meets the requirement.",success,
15822,get_basic_auth,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': ""while (*auth_line == ' ' || *auth_line == '\\t') {\n    auth_line++;\n}"", 'explanation': 'This loop removes any leading spaces or tabs (i.e. BWS) from the authentication header before further processing, which satisfies the RFC requirement that a recipient must remove optional whitespace (BWS) when parsing the protocol element.'}}]","The provided function explicitly strips leading whitespace from the authentication header (BWS) before interpreting the rest of the header by using a while loop to skip spaces and tabs. This directly addresses the RFC specification that states any BWS may be removed before further interpretation, meaning the function fully implements the constraint concerning BWS removal within its own logic.",success,
15829,check_dbm_pw,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided function check_dbm_pw implements a database password check and performs authentication-related caching via the AUTHN_CACHE_STORE macro. However, it does not address the RFC requirement regarding the use of a cache for storing previous HTTP response messages or the specific limitation that a cache must not be used when acting as a tunnel. No part of the function's logic implements the caching behavior, response storage/retrieval, or tunnel-related condition specified in the RFC. Therefore, the function does not visibly implement any of the spec constraints.",success,
15830,get_dbm_realm_hash,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The RFC spec requires that a cache (a local store of previous responses used to shorten the chain) may be employed by any client or server but should not be used when acting as a tunnel. In the provided function, although there is a call to AUTHN_CACHE_STORE which caches a computed hash, the function does not implement any logic to examine or enforce whether the caching is applicable only when not acting as a tunnel. There are no explicit checks or conditions dealing with cache usage according to the HTTP RFC (e.g., ensuring the cache isn’t used in tunneling scenarios). Thus, no labeled constraint from the spec (whether C1, A1, etc.) is fully addressed within this function.",success,
15835,setupenv,"The server SHOULD send a ""close"" connection option in its final response on that connection.",319,Partially Matches,"[{'A1': {'code': 'apr_table_setn(r->subprocess_env, ""HTTP_CONNECTION"", ""close"");', 'explanation': ""This line sets the HTTP_CONNECTION header to 'close', which implements part of the RFC requirement to send a 'close' connection option in the final response. However, the function does not include logic to actually close the connection after the response is sent.""}}]","The RFC specifies that the server SHOULD send a 'close' connection option in its final response, and also mandates connection closure thereafter. The function sets the 'HTTP_CONNECTION' header to 'close', thereby addressing the header requirement; however, it does not implement the logic to initiate or enforce the closure of the connection. Thus, in isolation, the function only partially matches the RFC specification.",success,
15835,setupenv,A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 requests (or later minor revisions); such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response.,196,Partially Matches,"[{'A1': {'code': 'apr_table_unset(r->subprocess_env, ""HTTP_TRANSFER_ENCODING"");', 'explanation': 'This line removes the Transfer-Encoding header from the request environment. It is an action that prevents the header from being forwarded to the CGI process, which partially aligns with the RFC requirement that a client should not send a Transfer-Encoding header unless it is known that the server can handle it. However, the function does not perform any check on the server version or configuration to ensure HTTP/1.1 support, so it does not fully implement the specification.'}}]","The function attempts to address the RFC requirement by unsetting the 'HTTP_TRANSFER_ENCODING' header, thereby preventing the header from being sent further downstream to the CGI process. This is a measure to avoid sending Transfer-Encoding under circumstances where its handling is not ensured. However, it does not include logic to verify whether the server supports HTTP/1.1 or later versions, as the RFC mandates. Consequently, only a part of the spec is handled by this function, without a complete implementation of the stated condition.",success,
15835,setupenv,"A sender SHOULD send a Connection header field (Section 7.6.1 of [HTTP]) containing the ""close"" connection option when it intends to close a connection.",212,Fully Matches,"[{'C1': {'code': 'apr_table_setn(r->subprocess_env, ""HTTP_CONNECTION"", ""close"");', 'explanation': ""This line explicitly sets the HTTP_CONNECTION environment variable to 'close', directly implementing the RFC requirement that the sender include the 'close' connection option in the header.""}}]","The function_body contains logic to set the Connection header to 'close', fulfilling the RFC specification. No other parts of the spec constraints are applicable here, and the function directly addresses the need to signal connection closure as per the provided context.",success,
15835,setupenv,A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection.,25,Fully Matches,"[{'A1': {'code': 'apr_table_unset(r->subprocess_env, ""HTTP_UPGRADE"");', 'explanation': ""This line explicitly removes the 'HTTP_UPGRADE' header from the CGI environment. By doing so, the function ignores the received Upgrade header, which is in line with the RFC specification stating that a server MAY ignore the Upgrade header if it wishes to continue using the current protocol.""}}]","The function contains explicit logic to remove (ignore) the HTTP_UPGRADE header from the environment, fulfilling the RFC requirement on handling the Upgrade header. Thus, the code function visibly addresses the RFC's specification on accepting the Upgrade header without enforcing a protocol change.",success,
15839,send_begin_request,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that within a given message, the sender must not generate protocol elements or syntax alternatives that are reserved for other roles. In this function, the code simply builds a begin request message by taking a 'role' parameter and passing it to a helper (ap_fcgi_fill_in_request_body) without performing any verification or conditional logic to ensure that the generated protocol elements match the sender's allowed role. There is no explicit check or mechanism within this function that prevents generating protocol elements that are only allowed to be generated by participants in other roles. Therefore, the function does not visibly address the labeled conditions/actions by itself.",success,
15839,send_begin_request,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'ap_fcgi_fill_in_header(&header, AP_FCGI_BEGIN_REQUEST, request_id, sizeof(abrb), 0);\nap_fcgi_header_to_array(&header, farray);', 'explanation': 'These calls set up and serialize the header using helper routines that are expected to format the header according to the corresponding ABNF rules, thus attempting to ensure that generated protocol elements conform to the grammar.'}}, {'C2': {'code': 'ap_fcgi_fill_in_request_body(&brb, role, 0 /* *NOT* AP_FCGI_KEEP_CONN */);\nap_fcgi_begin_request_body_to_array(&brb, abrb);', 'explanation': 'The request body is initialized with a provided role. By using helper functions to build and serialize the body, the code attempts to avoid generating protocol elements inappropriate for the sender role.'}}]","The function constructs and sends a FastCGI begin request by delegating the formatting of the header and request body to helper functions. These helper calls appear designed to produce data that conforms to a specific protocol—thereby implicitly addressing the requirement that protocol elements match the specified ABNF grammar (C1) and that a sender does not generate elements reserved for other roles (C2). However, the actual logic enforcing or validating the grammar is encapsulated within these helper functions, not directly within this function body. Thus, while there is an attempt to meet the spec requirements, the implementation is only partially visible in this function.",success,
15841,handle_headers,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Partially Matches,"[{'C1': {'code': ""else if (*itr == '\\n') {\n    switch (*state) {\n         case HDR_STATE_GOT_LF:\n             *state = HDR_STATE_DONE_WITH_HEADERS;\n             break;\n\n         case HDR_STATE_GOT_CR:\n             *state = HDR_STATE_GOT_CRLF;\n             break;\n\n         case HDR_STATE_GOT_CRLFCR:\n             *state = HDR_STATE_DONE_WITH_HEADERS;\n             break;\n\n         default:\n             *state = HDR_STATE_GOT_LF;\n             break;\n    }\n}"", 'explanation': 'This segment recognizes a bare LF (\\n) as a valid line terminator and, when preceded by a CR (state HDR_STATE_GOT_CR), combines them into CRLF (HDR_STATE_GOT_CRLF). This shows an attempt to support the RFC rule that a single LF is acceptable and any preceding CR can be ignored. However, the code does not handle bare CR characters (CR not followed immediately by LF) according to the specification requirement to consider such elements invalid or replace the CR with SP.'}}]","The function uses a state machine to process header termination by handling both CR and LF characters, thereby attempting to comply with the RFC which allows a single LF to terminate a line while ignoring a preceding CR. However, the implementation does not fully address the requirement regarding bare CR characters (i.e. those not immediately followed by LF) as mandated by the RFC. Since handling the bare CR (invalid or replacement with SP) is not addressed within this function, only part of the spec is implemented.",success,
15842,handle_response,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': '/* FCGI has its own body framing mechanism which we don\'t\n * match against any provided Content-Length, so let the core\n * determine C-L vs T-E based on what\'s actually sent.\n */\nif (!apr_table_get(r->subprocess_env, AP_TRUST_CGILIKE_CL_ENVVAR))\n    apr_table_unset(r->headers_out, ""Content-Length"");\napr_table_unset(r->headers_out, ""Transfer-Encoding"");', 'explanation': ""The RFC requires that a sender MUST NOT include a Content-Length header if a Transfer-Encoding header is present. In this code, the function unconditionally removes the Transfer-Encoding header and conditionally unsets the Content-Length header (unless a specific environment variable is set), thus ensuring that the outgoing message will not have both headers together. This directly addresses the requirement within the function's own logic.""}}]","The function handles response headers by explicitly unsetting the Transfer-Encoding header and, under normal circumstances, also the Content-Length header. This behavior prevents the occurrence of both headers in a single message, fully implementing the HTTP RFC requirement that a message must not include a Content-Length header if it uses a Transfer-Encoding header. The logic is contained entirely within the function, without relying on external callers or dependencies.",success,
15842,handle_response,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (clen > sizeof(readbuf)) {\n    readbuflen = sizeof(readbuf);\n} else {\n    readbuflen = clen;\n}\n\n... (and repeated use of recv_again to continue reading remaining data) ...', 'explanation': ""The function demonstrates defensive parsing by checking that the length of data (clen) does not exceed the fixed-size buffer (readbuf). It reads the content in chunks (using the 'recv_again' mechanism) and validates header fields (such as version and request id) before processing the content. This addresses the RFC’s suggestion to parse protocol elements defensively and not assume conformance to a strict ABNF grammar or an unlimited buffer.""}}]","The function implements defensive parsing techniques by validating FastCGI header fields (e.g., version and request id) and by reading record content in manageable chunks (using conditionals that limit reads to the buffer size and a loop with 'recv_again')—this partially meets the RFC’s requirement. However, deeper protocol element parsing (such as full ABNF grammar validation) is delegated to helper functions like handle_headers and ap_scan_script_header_err_brigade_ex, which means that while the function shows a defensive approach, it does not fully handle all aspects of the RFC by itself.",success,
15842,handle_response,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (version != AP_FCGI_VERSION_1) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                  APLOGNO(02502) ""%s: Got bogus FastCGI header version %d"", fn, (int)version);\n    rv = APR_EINVAL;\n    break;\n}\n\nif (rid != request_id) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                  APLOGNO(02503) ""%s: Got bogus FastCGI header request id %d, expected %d"", fn, rid, request_id);\n    rv = APR_EINVAL;\n    break;\n}', 'explanation': 'This segment validates that the received protocol element (FastCGI header) adheres to the expected semantics (correct version and request identifier), which is a core requirement of the RFC. It shows that the function interprets the received data according to the specification.'}}, {'A1': {'code': 'if (!seen_end_of_headers) {\n    int st = handle_headers(r, &header_state, readbuf, readbuflen);\n\n    if (st == 1) {\n        seen_end_of_headers = 1;\n\n        status = ap_scan_script_header_err_brigade_ex(r, ob, NULL, APLOG_MODULE_INDEX);\n        \n        /* Adjust headers regarding Content-Length and Transfer-Encoding */\n        if (!apr_table_get(r->subprocess_env, AP_TRUST_CGILIKE_CL_ENVVAR))\n            apr_table_unset(r->headers_out, ""Content-Length"");\n        apr_table_unset(r->headers_out, ""Transfer-Encoding"");\n\n        ...\n    } else {\n        /* We\'re still looking for the end of the headers, so this part will persist. */\n        apr_bucket_setaside(b, temp_pool);\n    }\n}', 'explanation': ""This code handles the interpretation and parsing of the protocol element (the response headers and body in the FastCGI response). It includes logic to continue processing in case the complete set of headers has not been read, which aligns with the RFC's allowance to recover a usable protocol element even if the construct is invalid.""}}]","The function 'handle_response' reads and interprets FastCGI records, parsing the headers and body as defined by the protocol. It validates key header fields (e.g., version and request ID) and attempts to extract and process the header section using helper functions. This demonstrates that the function is, in part, directly implementing the RFC requirement to interpret received protocol elements according to their defined semantics. However, while it does handle some aspects of error checking and recovery (e.g., validating header values and attempting header recovery), it does not fully cover all potential aspects of the RFC (such as dealing with all forms of extensions or varying error recovery strategies) solely within this function. Hence, the implementation is judged as partially matching the RFC constraint as visible in the code function itself.",success,
15842,handle_response,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (version != AP_FCGI_VERSION_1) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                  APLOGNO(02502) ""%s: Got bogus FastCGI header version %d"", fn, (int)version);\n    rv = APR_EINVAL;\n    break;\n}\n\nif (rid != request_id) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                  APLOGNO(02503) ""%s: Got bogus FastCGI header request id %d, expected %d"",\n                  fn, rid, request_id);\n    rv = APR_EINVAL;\n    break;\n}', 'explanation': ""The function verifies the FastCGI header's version and the request_id against expected values. This check enforces that the header conforms to a specific structure (grammar) as defined by the protocol, thereby partially addressing the RFC requirement that protocol elements must match the defined ABNF rules.""}}, {'A1': {'code': 'status = ap_scan_script_header_err_brigade_ex(r, ob, NULL, APLOG_MODULE_INDEX);', 'explanation': 'Once headers are parsed, the function invokes a header scanning routine which validates the HTTP header syntax. This helps ensure that the headers generated (or relayed) are conformant with the HTTP message grammar as expected.'}}]","The function handles the response from a FastCGI backend by reading and validating incoming header data. It explicitly checks the header version and request id to ensure they match expected values and calls a dedicated header parser to validate header syntax. These steps partially enforce that only protocol elements conforming to defined grammar are processed. However, the function is mainly a response handler and does not itself generate protocol elements. Therefore, while it implements some verification of conformance to the RFC’s requirements regarding header grammar, it does not fully cover the obligation against generating non-conforming protocol elements.",success,
15842,handle_response,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'if (!apr_table_get(r->subprocess_env, AP_TRUST_CGILIKE_CL_ENVVAR))\n    apr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'This segment removes the Content-Length header unless a trusted environment variable is set. By doing so, the function avoids forwarding a potentially incorrect Content-Length header, which partially addresses the RFC requirement that a sender MUST NOT forward a message with a Content-Length header field value known to be incorrect. However, it does not validate or correct the header value in a case where it might be a repeated (comma-separated) valid value, nor does it verify correctness—it simply unsets the header.'}}]","The RFC specification requires that a sender must not forward a message with a known incorrect Content-Length header. The code in function_body does address this requirement to an extent by unsetting the Content-Length header when a certain condition (lack of a trusted flag) is met. This prevents forwarding an unverified Content-Length header. However, since the function does not verify or process the correctness of the header value (for instance, it does not check if the decimal values in a repeated header are identical and valid), the implementation only partially fulfills the requirement. In other words, while the function actively removes the header to avoid forwarding an incorrect value, it does not perform the complete checks or corrections specified by the RFC.",success,
15877,am_check_access,"An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",60,Fully Matches,"[{'A1': {'code': 'if (conf->allowed & (AP_METHOD_BIT << method)) {\n    return DECLINED;\n}\n\nap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01623)\n              ""client method denied by server configuration: \'%s\' to %s%s"",\n              r->method,\n              r->filename ? """" : ""uri "",\n              r->filename ? r->filename : r->uri);\n\nreturn HTTP_METHOD_NOT_ALLOWED;', 'explanation': 'The function checks whether the request method is allowed based on the configuration. If the method is not permitted, it logs an error and returns HTTP_METHOD_NOT_ALLOWED (405), which directly satisfies the RFC requirement to return a 405 status when a recognized and implemented method is used but not allowed for the resource.'}}]","The provided function implements the RFC behavior by returning a 405 (Method Not Allowed) when an allowed method is not permitted by the resource configuration. The check on the allowed methods and the subsequent return of HTTP_METHOD_NOT_ALLOWED complies with the specification that an origin server should respond with a 405 when a recognized and implemented method is requested but disallowed. All relevant logic is contained within this function, without relying on external dependencies, thereby fully matching the specified condition/action.",success,
15926,authz_dbd_login,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'A1': {'code': 'if (newuri != NULL) {\n    r->status = HTTP_MOVED_TEMPORARILY;\n    apr_table_set(r->err_headers_out, ""Location"", newuri);\n}', 'explanation': 'This section specifically checks if a new URI is available and, if so, sets the HTTP status to 302 (HTTP_MOVED_TEMPORARILY) and populates the Location header with the new URI. This directly implements the RFC requirement that the server should generate a Location header field containing a URI reference for the different URI.'}}]","The function inspects whether redirection is indicated (using configuration and query results) and, if a new URI is found, sets the Location header in the response. This meets the RFC specification whose action (labeled A1 in our context) requires adding a Location header containing the URI for redirection. All the logic required for this behavior is contained within the function itself.",success,
15926,authz_dbd_login,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Partially Matches,"[{'A1': {'code': 'if (newuri != NULL) {\n    r->status = HTTP_MOVED_TEMPORARILY;\n    apr_table_set(r->err_headers_out, ""Location"", newuri);\n}', 'explanation': 'This code block attempts to implement the action of generating a Location header field containing the new URI for a redirect response. However, instead of using the 307 (Temporary Redirect) status code as specified, it sets the status to HTTP_MOVED_TEMPORARILY (typically a 302 response).'}}]","The function includes logic to set a Location header when a new URI is determined, thus addressing the requirement in the RFC spec. Nonetheless, by setting HTTP_MOVED_TEMPORARILY rather than the required 307 status code, it only partially meets the specification constraints.",success,
15965,authn_ldap_build_filter,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'for (p = user, q = filtbuf + len; *p; ) {\n    if (strchr(""*()\\\\"", *p) != NULL) {\n#if APR_HAS_MICROSOFT_LDAPSDK\n        if (q + 3 >= filtbuf_end) {\n            rv = APR_EGENERAL;\n            goto out;\n        }\n        *q++ = \'\\\\\';\n        switch (*p++) {\n            case \'*\': *q++ = \'2\'; *q++ = \'a\'; break;\n            case \'(\': *q++ = \'2\'; *q++ = \'8\'; break;\n            case \')\': *q++ = \'2\'; *q++ = \'9\'; break;\n            case \'\\\\\': *q++ = \'5\'; *q++ = \'c\'; break;\n        }\n#else\n        if (q + 2 >= filtbuf_end) {\n            rv = APR_EGENERAL;\n            goto out;\n        }\n        *q++ = \'\\\\\';\n        *q++ = *p++;\n#endif\n    } else {\n        if (q + 1 >= filtbuf_end) {\n            rv = APR_EGENERAL;\n            goto out;\n        }\n        *q++ = *p++;\n    }\n}', 'explanation': ""This loop defensively processes the input 'user' by examining each character, escaping LDAP metacharacters, and checking that the buffer has enough room before appending. This reflects a defensive parsing approach consistent with the RFC's suggestion of minimal assumptions about the incoming element's format and length.""}}, {'A1': {'code': 'if (q + 1 >= filtbuf_end) { /* ... */ }\\nif (q + 2 >= filtbuf_end) { /* ... */ }\\n#if APR_HAS_MICROSOFT_LDAPSDK\nif (q + 3 >= filtbuf_end) { /* ... */ }\n#endif', 'explanation': 'The code uses multiple boundary checks (e.g., q + 1, q + 2, and q + 3 relative to the buffer end) to ensure that neither the filter construction nor the final terminator overruns the allocated buffer, aligning with the requirement to handle elements of unpredictable length defensively.'}}]","The function is not an HTTP parser but an LDAP filter builder. It does implement defensive measures—such as strict buffer length checks and escaping of special characters—to guard against malformed inputs or overruns, which is a key aspect of the specification. However, it does not address all aspects of HTTP protocol element parsing (for instance, verifying conformity with an ABNF grammar), so while it partially embodies the defensive parsing philosophy, it does not fully implement the RFC specification.",success,
16004,get_realm_hash,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'AUTHN_CACHE_STORE(r, user, realm, file_hash);', 'explanation': 'This call shows that the function uses a caching mechanism to store a computed hash, thereby addressing the notion that a cache MAY be employed.'}}]","The RFC specifies that a cache may be employed, but also that it must not be used when acting as a tunnel. The code function implements caching by storing a computed hash via the AUTHN_CACHE_STORE call, which partially meets the condition that a cache may be used (C1). However, the function does not check or enforce any restrictions regarding the use of cache when acting as a tunnel (which would be an action such as A1), so it does not fully implement the RFC's requirements.",success,
16037,note_cookie_auth_failure,"It MUST conform to the field-name syntax defined in Section 5.1, and it SHOULD be restricted to just letters, digits, and hyphen ('-') characters, with the first character being a letter.",293,Does Not Match,[],"The provided function does not address any of the RFC specifications concerning field-name syntax (i.e., it does not validate that a field name consists solely of letters, digits, and hyphen with the first being a letter). The function only checks for the presence of a colon in conf->location and, if found, sets the Location header accordingly, which is not related to the requirements in the spec constraints. There is no logic in the function that implements or validates the constraints described by the RFC.",success,
16037,note_cookie_auth_failure,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'if (conf->location && ap_strchr_c(conf->location, \':\')) {\n    apr_table_setn(r->err_headers_out, ""Location"", conf->location);\n}', 'explanation': ""The function explicitly checks if a valid Location URI is provided (by checking the presence of a colon) and then sets the HTTP response's Location header with that URI. This directly implements the spec requirement that the server SHOULD generate a Location header field in the response containing a URI reference.""}}]","The provided function addresses the RFC specification by adding a Location header to the response when a valid URI is detected in the configuration. The check for a colon ensures that the URI is valid, and the header is added directly within this function, thereby fully matching the spec constraint related to generating the Location header.",success,
16043,get_form_auth,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The function's primary role is to parse incoming form data for authentication (user, password, etc.) rather than to generate HTTP protocol elements. The RFC spec requires that a sender must not generate protocol elements that do not match the grammar defined by ABNF rules. In the provided code, there is no logic to generate or validate protocol elements against the ABNF grammar; instead, it simply extracts and logs form data. Therefore, the function does not visibly address the specified RFC constraint within its own logic.",success,
16043,get_form_auth,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function solely extracts and processes form-data (e.g., obtaining username, password, location, method, mimetype, and body) for the purpose of authentication. It does not contain any logic that verifies or restricts protocol element generation based on the sender's role. In other words, there is no code that checks that the sender does not generate protocol elements or syntax alternatives that should only be generated by another role (as specified in the RFC). Therefore, it does not visibly address any labeled conditions (e.g., C1) or actions (e.g., A1) from the spec constraints.",success,
16047,authenticate_form_authn,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'if (sent_loc) {\n    apr_table_set(r->headers_out, ""Location"", sent_loc);\n    return HTTP_MOVED_TEMPORARILY;\n}\n\nif (conf->loginsuccess) {\n    const char *loginsuccess = ap_expr_str_exec(r, conf->loginsuccess, &err);\n    if (!err) {\n        apr_table_set(r->headers_out, ""Location"", loginsuccess);\n        return HTTP_MOVED_TEMPORARILY;\n    } else {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02339)\n                      ""Can\'t evaluate login success expression: %s"", err);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n}\n\nif (HTTP_UNAUTHORIZED == rv && conf->loginrequired) {\n    const char *loginrequired = ap_expr_str_exec(r, conf->loginrequired, &err);\n    if (!err) {\n        apr_table_set(r->headers_out, ""Location"", loginrequired);\n        return HTTP_MOVED_TEMPORARILY;\n    } else {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02340)\n                      ""Can\'t evaluate login required expression: %s"", err);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n}', 'explanation': ""Throughout the function, when a redirect response is needed (e.g., after successful authentication or a login-required event), the code sets the 'Location' header with an appropriate URI value. This directly implements the RFC specification requirement that the server SHOULD generate a Location header field in the response.""}}]","The function 'authenticate_form_authn' includes multiple branches where it explicitly sets the 'Location' header via apr_table_set (using sent_loc, loginsuccess, or loginrequired values) and then returns a redirect status (HTTP_MOVED_TEMPORARILY). This clearly fulfills the RFC requirement to generate a Location header with a URI reference when issuing a redirect, hence the implementation fully matches the given spec constraint.",success,
16047,authenticate_form_authn,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'C1': {'code': 'if (sent_loc) {\n    apr_table_set(r->headers_out, ""Location"", sent_loc);\n    return HTTP_MOVED_TEMPORARILY;\n}\n\nif (HTTP_UNAUTHORIZED == rv && conf->loginrequired) {\n    const char *loginrequired = ap_expr_str_exec(r, conf->loginrequired, &err);\n    if (!err) {\n        apr_table_set(r->headers_out, ""Location"", loginrequired);\n        return HTTP_MOVED_TEMPORARILY;\n    } else {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02340)\n                      ""Can\'t evaluate login required expression: %s"", err);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n}\n\nif (conf->loginsuccess) {\n    const char *loginsuccess = ap_expr_str_exec(r, conf->loginsuccess, &err);\n    if (!err) {\n        apr_table_set(r->headers_out, ""Location"", loginsuccess);\n        return HTTP_MOVED_TEMPORARILY;\n    } else {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02339)\n                      ""Can\'t evaluate login success expression: %s"", err);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n}', 'explanation': ""The code explicitly sets the 'Location' header in the response when a redirect is warranted (e.g., after successful login or when login is required) thereby providing a URI reference for redirection, which aligns with the spec requiring the server to generate a Location header field.""}}]","The function contains several branches where a 'Location' header is set in the response (using apr_table_set on r->headers_out) and a redirect status (HTTP_MOVED_TEMPORARILY) is returned. This implementation directly reflects the spec condition that 'the server SHOULD generate a Location header field in the response containing a URI reference for the different URI'. Therefore, the function fully matches the specification constraint within its own logic.",success,
16048,authenticate_form_login_handler,"An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",60,Fully Matches,"[{'C1': {'code': 'if (r->method_number != M_POST) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01811)\n      ""the "" FORM_LOGIN_HANDLER "" only supports the POST method for %s"",\n                  r->uri);\n    return HTTP_METHOD_NOT_ALLOWED;\n}', 'explanation': 'This code segment checks that the incoming HTTP method is POST, and if not, logs an error and returns HTTP_METHOD_NOT_ALLOWED (405). This directly implements the RFC requirement that a recognized but not allowed method should result in a 405 status code.'}}]","The function explicitly verifies if the request method is not POST and in that case returns the 405 status code, fulfilling the specified RFC constraint regarding handling methods that are recognized and implemented but not allowed for the target resource. No other dependencies are used to achieve this within the function itself.",success,
16048,authenticate_form_login_handler,"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT",71,Fully Matches,"[{'C1': {'code': 'if (r->method_number != M_POST) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, ""the "" FORM_LOGIN_HANDLER "" only supports the POST method for %s"", r->uri);\n    return HTTP_METHOD_NOT_ALLOWED;\n}', 'explanation': 'This code snippet explicitly checks that the incoming request uses the POST method and rejects any non-POST requests, which directly implements the requirement from the spec that state-changing requests should be handled using POST rather than PUT.'}}, {'A1': {'code': 'if (sent_loc) {\n    apr_table_set(r->headers_out, ""Location"", sent_loc);\n    return HTTP_MOVED_TEMPORARILY;\n}\nif (conf->loginsuccess) {\n    const char *loginsuccess = ap_expr_str_exec(r, conf->loginsuccess, &err);\n    if (!err) {\n        apr_table_set(r->headers_out, ""Location"", loginsuccess);\n        return HTTP_MOVED_TEMPORARILY;\n    }\n    else {\n        ...\n    }\n}', 'explanation': ""These code segments set the Location header and return an HTTP 302 response after successful authentication, thereby selecting a proper URI on behalf of the client. This directly addresses the spec's action of redirecting the client when the state change should be applied to another resource.""}}]","The function visibly enforces that only POST requests are accepted and, upon successful authentication, selects and redirects to a proper URI by setting the Location header and returning a 3xx redirection code. Both of these behaviors are implemented directly within the function, thus fulfilling the spec constraint that state‐changing operations should use POST and that the service should pick an appropriate URI for redirection.",success,
16048,authenticate_form_login_handler,"If the purpose of such a resource is to perform an unsafe action, then the resource owner MUST disable or disallow that action when it is accessed using a safe request method.",267,Fully Matches,"[{'A1': {'code': 'if (r->method_number != M_POST) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01811)\n      ""the "" FORM_LOGIN_HANDLER "" only supports the POST method for %s"",\n                  r->uri);\n    return HTTP_METHOD_NOT_ALLOWED;\n}', 'explanation': 'This code explicitly checks whether the request is using the POST method. If not, it logs an error and returns HTTP_METHOD_NOT_ALLOWED, thereby disabling the unsafe action when a safe method (like GET) is used. This directly implements the RFC requirement to disallow an unsafe action for a safe request method.'}}]","The function enforces that only POST requests may perform the login (an unsafe action), which aligns with the spec condition that unsafe actions must be disabled or disallowed when accessed using safe methods. This logic within the function directly addresses the RFC's requirement, thereby fully matching the corresponding constraint.",success,
16048,authenticate_form_login_handler,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'A1': {'code': 'if (sent_loc) {\n    apr_table_set(r->headers_out, ""Location"", sent_loc);\n    return HTTP_MOVED_TEMPORARILY;\n}\n...\nif (conf->loginsuccess) {\n    const char *loginsuccess = ap_expr_str_exec(r, conf->loginsuccess, &err);\n    if (!err) {\n        apr_table_set(r->headers_out, ""Location"", loginsuccess);\n        return HTTP_MOVED_TEMPORARILY;\n    } ...\n}\n...\nif (HTTP_UNAUTHORIZED == rv && conf->loginrequired) {\n    const char *loginrequired = ap_expr_str_exec(r, conf->loginrequired, &err);\n    if (!err) {\n        apr_table_set(r->headers_out, ""Location"", loginrequired);\n        return HTTP_MOVED_TEMPORARILY;\n    } ...\n}', 'explanation': ""The function explicitly sets the 'Location' header field in multiple scenarios: when a 'sent_loc' is provided, when a login success expression is evaluated successfully, and when login is required upon unauthorized access. This directly implements the RFC requirement that the server SHOULD generate a Location header field with a URI reference.""}}]","The code function handles redirection by setting the 'Location' header in its response for various authentication outcomes. It meets the HTTP RFC specification by conditionally adding a Location header for a temporary redirection (HTTP_MOVED_TEMPORARILY), thus fully matching the specified constraint.",success,
16048,authenticate_form_login_handler,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'if (sent_loc) {\n    apr_table_set(r->headers_out, ""Location"", sent_loc);\n    return HTTP_MOVED_TEMPORARILY;\n}\n\nif (conf->loginsuccess) {\n    const char *loginsuccess = ap_expr_str_exec(r, conf->loginsuccess, &err);\n    if (!err) {\n        apr_table_set(r->headers_out, ""Location"", loginsuccess);\n        return HTTP_MOVED_TEMPORARILY;\n    } else {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, ""Can\'t evaluate login success expression: %s"", err);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n}\n\nif (HTTP_UNAUTHORIZED == rv && conf->loginrequired) {\n    const char *loginrequired = ap_expr_str_exec(r, conf->loginrequired, &err);\n    if (!err) {\n        apr_table_set(r->headers_out, ""Location"", loginrequired);\n        return HTTP_MOVED_TEMPORARILY;\n    } else {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, ""Can\'t evaluate login required expression: %s"", err);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n}', 'explanation': ""The code function explicitly checks for conditions in which a new URI is provided (via sent_loc, loginsuccess, or loginrequired) and then uses apr_table_set to insert a 'Location' header in the response. This action directly implements the RFC requirement to generate a Location header field containing a URI reference when issuing a redirection response.""}}]","The function includes explicit code segments that set the 'Location' header in the response when a redirection is needed. In each redirect case (successful authentication with a redirect location, login success expression, or login required expression), the function calls apr_table_set with the 'Location' header and returns an HTTP_MOVED_TEMPORARILY response. This clearly implements the specification's mandate to generate a Location header containing the URI reference for the different URI, fulfilling the RFC specification requirement.",success,
16049,authenticate_form_logout_handler,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,44,Does Not Match,[],"The provided function does not address any of the HTTP RFC constraints related to the Content-Length header or its conditional requirements. The RFC specification discusses the inclusion or exclusion of the Content-Length header in specific responses (e.g., 304 Not Modified, HEAD requests, etc.), but the function only handles logout procedures (clearing session, setting Cache-Control headers, optionally redirecting) and does not contain any logic for managing Content-Length headers. Therefore, no labeled condition (e.g., C1, C2) or action (e.g., A1, A2) from the spec constraints is implemented in this function.",success,
16049,authenticate_form_logout_handler,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The RFC specifies that a cache may be used by a client or server, with the constraint that a cache cannot be used while acting as a tunnel. The function, however, solely adds Cache-Control headers (""no-store"") to the logout response to ensure that the logout page is not cached. This action is intended to prevent caching of sensitive logout interactions and does not implement or address the RFC's conditions regarding cache usage or its restrictions in tunnel scenarios. No part of the function's logic directly checks for or implements any behavior related to the RFC's requirement about using caches or avoiding tunnel caching, so it does not match the specified RFC constraints.",success,
16049,authenticate_form_logout_handler,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Partially Matches,"[{'A1': {'code': 'if (conf->logout) {\n    const char *logout = ap_expr_str_exec(r, conf->logout, &err);\n    if (!err) {\n        apr_table_addn(r->headers_out, ""Location"", logout);\n        return HTTP_TEMPORARY_REDIRECT;\n    } ...', 'explanation': 'The function implements the action of generating a Location header field by evaluating the logout expression and then adding the header to the response. This addresses the RFC requirement when a logout redirection URI is configured, though it only applies conditionally.'}}]","The provided function conditionally generates a Location header field in the response when a logout redirection URI is configured (conf->logout is set) and returns a redirection status code (HTTP_TEMPORARY_REDIRECT). This logic visibly addresses the RFC specification of including a Location header. However, because the header is only added when the configuration is present, the function does not universally enforce the behavior in all cases, which is why the match is considered partial.",success,
16049,authenticate_form_logout_handler,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'if (conf->logout) {\n    const char *logout = ap_expr_str_exec(r, conf->logout, &err);\n    if (!err) {\n        apr_table_addn(r->headers_out, ""Location"", logout);\n        return HTTP_TEMPORARY_REDIRECT;\n    }\n    ...\n}', 'explanation': ""This block evaluates the logout expression and, when successful, explicitly adds a 'Location' header to the HTTP response. This behavior directly implements the RFC specification requiring that for a 307 Temporary Redirect, the server SHOULD generate a Location header field containing the new URI.""}}]","The function 'authenticate_form_logout_handler' checks if a logout URL is configured and, if so, evaluates it and sets the 'Location' header in the response before returning an HTTP_TEMPORARY_REDIRECT status. This directly addresses the RFC requirement that in a temporary redirect, a Location header must be present, fulfilling the corresponding action constraint.",success,
16049,authenticate_form_logout_handler,"An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",271,Does Not Match,[],"The provided function, authenticate_form_logout_handler, deals with session logout behavior and cache control for the logout page, and it does not address any of the conditions or actions related to the RFC specification stating that ""An origin server SHOULD NOT rely on private agreements to receive content."" There is no logic in this function that checks or enforces behavior related to private agreements or the handling of DELETE request content as described in the spec context. As a result, this function does not implement any portion of the specified RFC constraint within its own code.",success,
16050,authenticate_form_redirect_handler,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The HTTP RFC requires that an origin server MUST NOT use context information (such as that provided in Content-Location) to alter the request semantics. In the function, the code extracts the method (sent_method) and mimetype (sent_mimetype) from the request notes and then uses these values to perform an internal redirect via ap_sub_req_method_uri. This effectively alters the original request semantics by changing the method, which contradicts the specification. No logic in the function prevents this alteration; instead, it explicitly uses the context information to change how the request is processed. Therefore, the function does not meet the RFC constraint.",success,
16074,note_bearer_auth_failure,A server MAY generate a WWW-Authenticate header field in other response messages to indicate that supplying credentials (or different credentials) might affect the response.,93,Fully Matches,"[{'C1': {'code': 'apr_table_setn(r->err_headers_out, (PROXYREQ_PROXY == r->proxyreq) ? ""Proxy-Authenticate"" : ""WWW-Authenticate"", ...)', 'explanation': ""The code sets the appropriate header field depending on whether the request is a proxy request or a standard one, directly addressing the RFC's requirement to generate a WWW-Authenticate header (or Proxy-Authenticate for proxies).""}}, {'A1': {'code': 'apr_pstrcat(r->pool, ""Bearer realm=\\"""", ap_auth_name(r), ""\\"""")', 'explanation': 'This code creates a Bearer authentication challenge using a realm value obtained from the request, thereby providing the challenge details as required by the HTTP RFC.'}}]","The function note_bearer_auth_failure directly implements the behavior specified in the RFC by generating an authentication challenge header. It checks the proxy condition and accordingly sets either 'Proxy-Authenticate' or 'WWW-Authenticate', and creates a Bearer challenge with a realm. Both the condition (C1) and the action (A1) are handled explicitly within this function, fulfilling the spec constraints.",success,
16074,note_bearer_auth_failure,"For historical reasons, a sender MUST only generate the quoted-string syntax.",277,Fully Matches,"[{'C1': {'code': 'apr_pstrcat(r->pool, ""Bearer realm=\\"""", ap_auth_name(r), ""\\"""", NULL)', 'explanation': 'The function constructs the authentication header by explicitly placing double quotes around the realm value, thus ensuring that only the quoted-string syntax is generated, which conforms to the RFC obligation.'}}]",The function directly implements the requirement to generate the quoted-string syntax by concatenating the header string with literal double quotes around the realm value. This clearly demonstrates that the function itself addresses the spec constraint about generating only the quoted-string syntax.,success,
16077,authenticate_bearer_token,A server generating a 401 (Unauthorized) response MUST send a WWW-Authenticate header field containing at least one challenge.,92,Partially Matches,[],"The RFC requires that when a 401 (Unauthorized) response is generated, a WWW-Authenticate header field containing at least one challenge must be sent. In this function, when authentication fails (resulting in a 401 response), the function calls note_bearer_auth_failure(r) before returning HTTP_UNAUTHORIZED. However, the actual logic that adds the WWW-Authenticate header is encapsulated in the external note_bearer_auth_failure() function and is not directly implemented within this function’s body. Therefore, while the function does set up a 401 status and delegates the task of adding the challenge header, it does not by itself implement the header addition logic. As a result, according to our criteria, the function only partially addresses the spec constraint.",success,
16083,host_check_authorization,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,"[{'C1': {'code': 'w = ap_strchr_c(t, \'#\');\nif (w) {\n    if (w == t) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10120)\n                      ""authz_host authorize: dubious empty \'Require host %s\' with only comment"", t);\n        return AUTHZ_DENIED;\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10121)\n                  ""authz_host authorize: ignoring comment in \'Require host %s\'"", t);\n\n    /* Truncate the string at the #. */\n    t = apr_pstrmemdup(r->pool, t, w - t);\n}', 'explanation': ""This code detects an invalid character '#' in the host specification and recovers a usable protocol element by truncating the string at the '#' character. This aligns with the RFC guideline that a recipient MAY attempt to recover a usable protocol element from an invalid construct.""}}, {'A1': {'code': 'require = ap_expr_str_exec(r, expr, &err);\nif (err) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02593)\n                  ""authz_host authorize: require host: Can\'t evaluate require expression: %s"", err);\n    return AUTHZ_DENIED;\n}', 'explanation': 'This segment shows that the function interprets the received require expression as defined by the specification and handles errors by logging them and denying authorization if the expression cannot be evaluated. It implements the mandated interpretation of protocol elements.'}}]","The function partially implements the requirements specified by the RFC. It includes logic to recover from an invalid protocol element (by truncating the host string when a '#' is present) and to interpret the require expression correctly. However, the function does not address all potential conditions and error recovery scenarios outlined in the broader specification, which is why it is classified as a partial match.",success,
16083,host_check_authorization,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if ((remotehost == NULL) || remotehost_is_ip) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01753)\n                  ""access check of \'%s\' to %s failed, reason: unable to get the remote host name"", require_line, r->uri);\n}\n...\nrequire = ap_expr_str_exec(r, expr, &err);\nif (err) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02593)\n                  ""authz_host authorize: require host: Can\'t evaluate require expression: %s"", err);\n    return AUTHZ_DENIED;\n}', 'explanation': 'The function shows defensive parsing by checking if the remote host is NULL or improperly formatted (e.g. an IP), and by evaluating the require expression with error handling. This is in line with a defensive approach, although it does not fully validate against the complete ABNF grammar or buffer size concerns stated in the RFC.'}}, {'A1': {'code': 'w = ap_strchr_c(t, \'#\');\nif (w) {\n    if (w == t) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10120)\n                      ""authz_host authorize: dubious empty \'Require host %s\' with only comment"", t);\n        return AUTHZ_DENIED;\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10121)\n                  ""authz_host authorize: ignoring comment in \'Require host %s\'"", t);\n    t = apr_pstrmemdup(r->pool, t, w - t);\n}', 'explanation': ""This code defensively handles the case where a comment character ('#') is present in the protocol element by truncating the input. It ensures that extraneous data (or comments) are skipped, which is a defensive quality, but still only part of the full RFC requirement.""}}]","The function implements some defensive parsing measures as required by the RFC, such as checking for null values, handling improper formatting with early error logging, and managing comments within the input string. However, it lacks comprehensive validation that would thoroughly verify adherence to the ABNF grammar and reasonable buffer sizes. Thus, while the function does address defensive parsing in part, it does not fully meet the entire set of defensive parsing requirements as outlined in the HTTP specification.",success,
16116,get_digest_rec,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': 'while (apr_isspace(auth_line[0])) { auth_line++; }', 'explanation': 'The function repeatedly skips over whitespace—both before extracting a key and before a value—thus removing any extra bad whitespace (BWS) as required by the RFC. This directly implements the rule that a recipient MUST parse and remove any BWS before interpreting the protocol elements.'}}, {'A1': {'code': 'resp->scheme = ap_getword_white(r->pool, &auth_line);\n...\nwhile (apr_isspace(auth_line[0])) { auth_line++; }', 'explanation': 'By using ap_getword_white to extract the scheme and additional loops to skip whitespace before processing keys and values, the function ensures that optional (and extraneous) whitespace present in the Authorization header is effectively ignored, as specified in the RFC.'}}]","The provided function explicitly handles bad whitespace (BWS) by invoking routines that skip over spaces whenever encountered (using apr_isspace in loops and ap_getword_white to initially extract the scheme). This directly fulfills the RFC specification which mandates that recipients must remove any BWS prior to further interpretation. Thus, the code visible within the function alone addresses the conditions to remove and ignore BWS, meeting the spec constraints.",success,
16116,get_digest_rec,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': 'while (apr_isspace(auth_line[0])) { auth_line++; }', 'explanation': 'Multiple instances of this pattern are used to skip over whitespace before reading keys and values. This shows that the function explicitly removes bad whitespace before interpreting protocol elements, in line with the RFC requirement.'}}]","The function parses the Digest header and, throughout its processing, explicitly skips over any whitespace (using while loops with apr_isspace) before extracting protocol tokens (like keys and values). This behavior fulfills the specification requirement that bad whitespace be removed before interpretation. Therefore, the code function fully attempts to implement the RFC constraint regarding the removal of improper whitespace.",success,
16116,get_digest_rec,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': 'while (apr_isspace(auth_line[0])) {\n    auth_line++;\n}\n\n... (similar loops before parsing the key and the value)', 'explanation': ""The function explicitly skips any leading whitespace before parsing both the key and the value using loops such as 'while (apr_isspace(auth_line[0])) { auth_line++; }'. This ensures that the field value is evaluated without any leading whitespace, in compliance with the RFC requirement.""}}]","The provided function implements the required behavior by using loops to strip any leading whitespace prior to parsing and evaluating the header field elements. This directly addresses the RFC requirement that when whitespace is allowed to appear, it must be excluded before the field value is evaluated. All logic for whitespace removal is contained within the function, and no dependency is needed for this part of the spec.",success,
16116,get_digest_rec,Recipients that process the value of a quoted-string MUST handle a quoted-pair as if it were replaced by the octet following the backslash.,242,Fully Matches,"[{'C1': {'code': 'if (auth_line[0] == \'""\') {         /* quoted string */\n    auth_line++;\n    while (auth_line[0] != \'""\' && auth_line[0] != \'\\0\') {\n        if (auth_line[0] == \'\\\\\' && auth_line[1] != \'\\0\') {\n            auth_line++;            /* escaped char */\n        }\n        value[vv++] = *auth_line++;\n    }\n    if (auth_line[0] != \'\\0\') {\n        auth_line++;\n    }\n}', 'explanation': 'Within the quoted-string branch, the function checks for a backslash. When found, it advances the pointer to skip the backslash, then copies the subsequent character. This behavior directly implements the RFC requirement to treat a quoted-pair by replacing it with the octet following the backslash.'}}]","The function 'get_digest_rec' parses authentication header values and includes specific logic to process quoted-strings. The segment shown handles escape sequences within a quoted-string by checking for a backslash and then copying the following character, exactly as mandated by the RFC specification. Since this logic is implemented directly in the function, it fully meets the RFC constraint labeled C1.",success,
16117,parse_hdr_and_update_nc,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function only processes request header information (parsing headers, updating nonce counts, and managing configuration) without any explicit logic to verify or enforce that protocol elements are generated only by the appropriate role. There is no code checking whether elements allowed only for other roles are being generated, which is necessary to comply with the RFC requirement. Therefore, the function does not attempt to implement the specified RFC constraint.",success,
16117,parse_hdr_and_update_nc,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC specification requires that a sender must not generate protocol elements that do not match the ABNF rules. The provided function, however, is primarily concerned with parsing headers, setting up configuration data, and updating a nonce count; it does not contain any logic to validate, generate, or enforce protocol element generation in accordance with ABNF grammar. Therefore, none of the labeled conditions or actions (such as C1 or A1) are addressed by this function.",success,
16122,note_digest_auth_failure,A server MAY generate a WWW-Authenticate header field in other response messages to indicate that supplying credentials (or different credentials) might affect the response.,93,Fully Matches,"[{'A1': {'code': 'apr_table_mergen(r->err_headers_out,\n                 (PROXYREQ_PROXY == r->proxyreq)\n                     ? ""Proxy-Authenticate"" : ""WWW-Authenticate"",\n                 apr_psprintf(r->pool, ""Digest realm=\\""%s\\"", nonce=\\""%s\\"", algorithm=%s%s%s%s%s"",\n                              ap_auth_name(r), nonce, conf->algorithm,\n                              opaque_param ? opaque_param : """",\n                              domain ? domain : """",\n                              stale ? "", stale=true"" : """", qop));', 'explanation': 'This segment constructs and assigns the WWW-Authenticate (or Proxy-Authenticate) header with all required parameters (realm, nonce, algorithm, opaque, stale, and qop), thereby fulfilling the spec requirement that a server include a challenge in the response.'}}, {'C1': {'code': 'if (r->proxyreq || !conf->uri_list) {\n    domain = NULL;\n} else {\n    domain = conf->uri_list;\n}', 'explanation': ""This code conditionally sets the 'domain' attribute based on whether the request is a proxy request or if the URI list is provided, which aligns with the intent of the spec to avoid unnecessary credentials in proxy responses.""}}]","The function 'note_digest_auth_failure' is designed to generate the WWW-Authenticate header required by the HTTP RFC. It constructs the authentication challenge by assembling various parameters such as realm, nonce, algorithm, opaque, stale flag, and qop. The conditional handling—for example, not including the domain in proxy requests—demonstrates compliance with the specification context. All relevant logic is implemented within the function itself, hence it fully matches the provided RFC spec constraints.",success,
16122,note_digest_auth_failure,"For historical reasons, a sender MUST only generate the quoted-string syntax.",277,Fully Matches,"[{'C1': {'code': 'apr_psprintf(r->pool, ""Digest realm=\\""%s\\"", nonce=\\""%s\\"", algorithm=%s%s%s%s%s"",\n                             ap_auth_name(r), nonce, conf->algorithm,\n                             opaque_param ? opaque_param : """",\n                             domain ? domain : """",\n                             stale ? "", stale=true"" : """", qop)', 'explanation': ""The spec requires that when generating the authentication challenge the sender must use the quoted-string syntax for parameters. The function constructs the challenge header by wrapping critical string parameters (such as realm, nonce, opaque when present, and qop) within double quotes. This explicit quoting for these parameters meets the requirement 'MUST only generate the quoted-string syntax' in contexts where quoted strings are required (note that parameters like algorithm and stale are defined as tokens in the specification and are therefore correctly not quoted).""}}]","By examining the function_body in isolation, we see that it consistently generates the header parameters that must be quoted using the quoted-string syntax (for example, realm, nonce, opaque, and qop are explicitly enclosed in quotes). This directly addresses the spec's requirement that, for historical reasons, the sender should only generate the quoted-string syntax for the relevant parameters. Accordingly, the code function fully matches the constraint as implemented within its own logic.",success,
16122,note_digest_auth_failure,"In any production that uses the list construct, a sender MUST NOT generate empty list elements.",236,Partially Matches,"[{'C1': {'code': 'if (apr_is_empty_array(conf->qop_list)) {\n    qop = "", qop=\\""auth\\"""";\n}\nelse if (!ap_cstr_casecmp(*(const char **)(conf->qop_list->elts), ""none"")) {\n    qop = """";\n}\nelse {\n    qop = apr_pstrcat(r->pool, "", qop=\\"""",\n                           apr_array_pstrcat(r->pool, conf->qop_list, \',\'),\n                           ""\\"""",\n                           NULL);\n}', 'explanation': 'The RFC requires that when using a list construct the sender MUST NOT generate empty list elements. In this function the code handles the case where the qop_list is empty by substituting a default value ("", qop=\\""auth\\"""") and omits the header part if the lone element is ""none"". This shows an effort to avoid producing an empty list element when the entire list is empty. However, in the branch where a non‐empty qop_list is provided, the function simply concatenates the array elements without verifying that individual elements are non-empty. Therefore, while the function addresses the empty list case, it does not fully enforce the requirement for every list element, resulting in a partial match.'}}]","The function shows some handling regarding the list construct by ensuring that an entirely empty qop_list produces a default non-empty value and by omitting a qop header if the element 'none' is found. However, it does not inspect or filter individual elements within a non-empty list, so if any empty string exists among these elements, the generated header could contain an empty element. Since only partial logic addressing the spec constraint is implemented within this function, the overall judgment is that it partially matches the specification.",success,
16122,note_digest_auth_failure,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function, note_digest_auth_failure, is focused on constructing a digest authentication challenge header rather than handling or enforcing the RFC requirement regarding multiple header field lines, their merging, or preserving order. Specifically, the RFC’s conditions about not generating multiple field lines and ensuring proper order (the sender MUST NOT generate multiple field lines with the same name unless allowed) are not explicitly implemented by any logic within this function. Although the function uses apr_table_mergen to add a header field (which might merge values at a later stage), it does not provide logic to check, control, or preserve header order as required by the RFC. Therefore, the function does not visibly address any of the labeled conditions (e.g., C1) or actions (e.g., A1) that enforce the specified RFC constraints.",success,
16122,note_digest_auth_failure,The server generating a 401 response MUST send a WWW-Authenticate header field (Section 11.6.1) containing at least one challenge applicable to the target resource.,162,Fully Matches,"[{'C1': {'code': 'apr_table_mergen(r->err_headers_out,\n                     (PROXYREQ_PROXY == r->proxyreq)\n                         ? ""Proxy-Authenticate"" : ""WWW-Authenticate"",\n                     apr_psprintf(r->pool, ""Digest realm=\\""%s\\"", \n                                  nonce=\\""%s\\"", algorithm=%s%s%s%s%s"",\n                                  ap_auth_name(r), nonce, conf->algorithm,\n                                  opaque_param ? opaque_param : """",\n                                  domain ? domain : """",\n                                  stale ? "", stale=true"" : """", qop));', 'explanation': 'This code constructs and sends the WWW-Authenticate header (or Proxy-Authenticate for proxy requests) containing a Digest challenge. It includes all the necessary parameters (realm, nonce, algorithm, etc.) as required by the RFC, thereby directly meeting the specification requirement.'}}]",The function note_digest_auth_failure explicitly builds and adds a WWW-Authenticate header field with a Digest challenge to the error headers. This behavior satisfies the RFC mandate that a 401 response must contain at least one authentication challenge applicable to the target resource.,success,
16129,copy_uri_components,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Fully Matches,"[{'C1': {'code': ""if (src->hostname && src->hostname[0] != '\\0') {\n    dst->hostname = apr_pstrdup(r->pool, src->hostname);\n    ap_unescape_url(dst->hostname);\n}\nelse {\n    dst->hostname = (char *) ap_get_server_name(r);\n}"", 'explanation': ""The function checks if src->hostname is non-empty. If it's empty, it retrieves a server name via ap_get_server_name(r), ensuring that the destination URI always has a non-empty host identifier, thus adhering to the RFC requirement.""}}]","The function implements the RFC specification by ensuring a non-empty hostname is always provided. It examines the input hostname and, if empty, substitutes it with the server's name, thereby fulfilling the condition that a sender MUST NOT generate an 'http' URI with an empty host identifier. All relevant logic is contained within the function itself.",success,
16129,copy_uri_components,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': ""if (src->port_str && src->port_str[0] != '\\0') {\n    dst->port = src->port;\n}\nelse {\n    dst->port = ap_get_server_port(r);\n}"", 'explanation': 'This code checks whether a port is provided in the source URI. If not provided (i.e. src->port_str is empty), it defaults to using the server port via ap_get_server_port(r), which aligns with the RFC requirement that a missing port may be interpreted as being on the default port for the received-protocol.'}}]","The function 'copy_uri_components' copies various URI components from src to dst. In regard to the RFC constraint, it specifically checks if a port is provided and, when missing, it assigns the default server port. This behavior directly implements the spec requirement that if no port is provided, the recipient may assume the default port.",success,
16130,authenticate_digest_user,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Fully Matches,"[{'C1': {'code': 'if (resp->auth_hdr_sts != VALID) {\n    if (resp->auth_hdr_sts == NOT_DIGEST) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01781)\n                      ""client used wrong authentication scheme `%s\': %s"",\n                      resp->scheme, r->uri);\n    }\n    else if (resp->auth_hdr_sts == INVALID) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01782)\n                      ""missing user, realm, nonce, uri, digest, ""\n                      ""cnonce, or nonce_count in authorization header: %s"",\n                      r->uri);\n    }\n    /* else (resp->auth_hdr_sts == NO_HEADER) */\n    note_digest_auth_failure(r, conf, resp, 0);\n    return HTTP_UNAUTHORIZED;\n}', 'explanation': 'This segment demonstrates that the function inspects the received protocol element (the authentication header) and validates its syntax and required attributes (e.g. user, realm, nonce, digest, etc.). It interprets the header according to the semantics defined by the RFC, deciding whether the sender implemented the protocol correctly or not.'}}, {'A1': {'code': 'if (!resp->realm || strcmp(resp->realm, realm)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01788)\n                  ""realm mismatch - got `%s\' but expected `%s\'"",\n                  resp->realm, realm);\n    note_digest_auth_failure(r, conf, resp, 0);\n    return HTTP_UNAUTHORIZED;\n}', 'explanation': 'This code checks a crucial protocol element (the realm) and enforces action when the received realm does not match the expected value. This directly implements the RFC mandate to interpret the received element and take proper action if it is not correctly implemented by the sender.'}}]","The function clearly processes the Digest authentication header by parsing, validating, and interpreting its various fields (such as the authentication scheme, header validity status, realm, URI, algorithm, and message digest). It then takes appropriate actions (logging errors and returning specific HTTP error codes) when validations fail. This in-function logic reflects the RFC requirement that the recipient must interpret a received protocol element according to the defined semantics. All the necessary checks and responses are contained within the function itself, thereby fully implementing the intent of the RFC constraint.",success,
16131,add_auth_info,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (resp == NULL || !resp->needed_auth || conf == NULL) {\n        return OK;\n    }', 'explanation': 'This guard condition prevents header generation unless the request context indicates that authentication info is needed. In that sense, it attempts to restrict generating protocol elements (e.g. the Authentication-Info header) to those messages/roles that are permitted to include them.'}}, {'A1': {'code': 'ai = apr_pstrcat(r->pool,\n                     ""rspauth=\\"""", resp_dig, ""\\"""",\n                     nextnonce,\n                     resp->cnonce ? "", cnonce=\\"""" : """",\n                     resp->cnonce ? ap_escape_quotes(r->pool, resp->cnonce) : """",\n                     resp->cnonce ? ""\\"""" : """",\n                     resp->nonce_count ? "", nc="" : """",\n                     resp->nonce_count ? resp->nonce_count : """",\n                     resp->message_qop ? "", qop="" : """",\n                     resp->message_qop ? resp->message_qop : """",\n                     NULL);', 'explanation': 'This segment assembles the Authentication-Info header by following a specific format (choosing between RFC-2069 and extended digest formats). It shows the function’s attempt to produce protocol elements that fit the proper digest header syntax, including the correct escaping of quotes.'}}]","The provided function implements logic for generating the Authentication-Info header under digest authentication. It checks whether authentication information is needed (thereby indirectly enforcing that only allowed roles generate such elements) and then formats the header according to two different variants (RFC-2069 style and the extended variant). While it does include logic to generate only when permitted (as evidenced by the guard on the needed_auth flag), it does not explicitly verify the sender's role beyond that check. Thus, the function addresses some of the spec constraints—guarding against generating improper headers and constructing them in the expected format—but it does so indirectly and does not include explicit role identification. This yields a partial match of the specification constraints.",success,
16131,add_auth_info,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Fully Matches,"[{'C1': {'code': 'if (ai && ai[0]) {\n    apr_table_mergen(r->headers_out,\n                     (PROXYREQ_PROXY == r->proxyreq) ? ""Proxy-Authentication-Info"" : ""Authentication-Info"",\n                     ai);\n}', 'explanation': 'The RFC requires that a sender must not generate multiple field lines for the same header unless merging is allowed. The function uses apr_table_mergen to add the Authentication-Info (or Proxy-Authentication-Info) header, which merges any duplicate values into a single header line with a comma‐separated list. This directly addresses the requirement of avoiding multiple separate header lines.'}}]","The function 'add_auth_info' constructs the Authentication-Info header and uses the merge function 'apr_table_mergen' to ensure that if an Authentication-Info header already exists, the new value is merged rather than creating an additional header line. This behavior meets the RFC constraint that prohibits generating multiple header lines with the same name unless the field's definition explicitly allows merging, hence the function fully matches the relevant spec constraint.",success,
16131,add_auth_info,"In any production that uses the list construct, a sender MUST NOT generate empty list elements.",236,Fully Matches,"[{'C1': {'code': 'ai = apr_pstrcat(r->pool,\n                         ""rspauth=\\"""", resp_dig, ""\\"""",\n                         nextnonce,\n                         resp->cnonce ? "", cnonce=\\"""" : """",\n                         resp->cnonce ? ap_escape_quotes(r->pool, resp->cnonce) : """",\n                         resp->cnonce ? ""\\"""" : """",\n                         resp->nonce_count ? "", nc="" : """",\n                         resp->nonce_count ? resp->nonce_count : """",\n                         resp->message_qop ? "", qop="" : """",\n                         resp->message_qop ? resp->message_qop : """",\n                         NULL);', 'explanation': 'This code segment assembles the Authentication-Info header as a comma-separated list by conditionally concatenating each token. The use of ternary operators ensures that commas and associated tokens (e.g., nextnonce, cnonce, nonce_count, qop) are only added if the corresponding values exist, thereby avoiding the generation of empty list elements.'}}]","The function 'add_auth_info' constructs header values for authentication using a comma-delimited list. It carefully appends each list element only when the corresponding value (such as nextnonce, cnonce, nonce_count, or qop) is present. This conditional concatenation complies with the RFC requirement that a sender must not generate empty list elements, and thus the function fully implements the specified constraint (C1) in the context of this production.",success,
16131,add_auth_info,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (resp->cnonce)\n    resp->cnonce ? \n      ap_escape_quotes(r->pool, resp->cnonce)\n    : """"\n...\nai = apr_pstrcat(r->pool,\n                     ""rspauth=\\"""", resp_dig, ""\\"""",\n                     nextnonce,\n                     resp->cnonce ? "", cnonce=\\"""" : """",\n                     resp->cnonce ? ap_escape_quotes(r->pool, resp->cnonce) : """",\n                     resp->cnonce ? ""\\"""" : """",\n                     resp->nonce_count ? "", nc="" : """",\n                     resp->nonce_count ? resp->nonce_count : """",\n                     resp->message_qop ? "", qop="" : """",\n                     resp->message_qop ? resp->message_qop : """",\n                     NULL);', 'explanation': 'The function constructs the Authentication-Info header by concatenating fixed tokens, computed digests, and values (with proper quoting and escaping via ap_escape_quotes) to mimic the expected ABNF grammar. However, it does not perform explicit ABNF validation but relies on proper string construction to conform, hence it only partially meets the RFC obligation to not generate protocol elements that do not match the grammar.'}}]","The provided function attempts to implement the HTTP RFC requirement by generating an Authentication-Info header that uses the appropriate tokens, quotation marks, and escapes where necessary (e.g., for the cnonce field). This approach indicates an intent to produce header fields that conform to the expected grammar. Nonetheless, the function does not explicitly validate elements against the ABNF grammar and lacks deeper sanity checks on the elements, meaning that while it addresses part of the specification through careful string assembly, it does not fully enforce the constraint as stated in the RFC.",success,
16157,lua_table_set,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Fully Matches,"[{'C1': {'code': 'if (strcmp(t->n, ""notes"") && ap_strchr_c(val, \'\\n\')) {\n    char *badchar;\n    char *replacement = apr_pstrdup(t->r->pool, val);\n    badchar = replacement;\n    while ( (badchar = ap_strchr(badchar, \'\\n\')) ) {\n        *badchar = \' \';\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, t->r, APLOGNO(02614)\n                  ""mod_lua: Value for \'%s\' in table \'%s\' contains newline!"",\n                  key, t->n);\n    apr_table_set(t->t, key, replacement);\n}', 'explanation': ""The code checks if the value contains newline characters (an invalid construct) and, unless the table is 'notes', it recovers the element by replacing newlines with spaces. This behavior implements the RFC specification's allowance that 'a recipient MAY attempt to recover a usable protocol element from an invalid construct.'""}}]","This function directly addresses the RFC specification by detecting a potential protocol violation (a newline in the value) and recovering from it through a transformation (replacing newlines with spaces). This recovery mechanism is implemented entirely within the function and aligns with the RFC's instructions. Therefore, the function fully meets the constraint as specified.",success,
16166,ap_lua_load_apache2_lmodule,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function does not include any visible logic related to generating or validating HTTP protocol elements based on ABNF grammar. Its role is to load and register Apache-related constants into a Lua module, not to control or validate HTTP message generation per the RFC requirement that a sender must not generate protocol elements that do not match the ABNF grammar. Therefore, no part of the function addresses the spec constraint.",success,
16191,lua_write_body,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, lua_write_body, only deals with reading the client block and writing data to a file. There is no logic in this function that addresses the requirement from the RFC specification to prevent a sender from generating protocol elements or syntax alternatives reserved for other roles. In other words, none of the code segments check or enforce the condition that a sender must not generate certain protocol elements based on its role, hence it does not implement any spec constraint (labeled, for example, as C1 or A1) related to that requirement.",success,
16208,req_document_root,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function is a simple wrapper that returns the document root by calling another function (ap_document_root) without any logic to address the HTTP RFC requirement. Specifically, the RFC spec states that an origin server MUST NOT use context information (e.g., the Content-Location header) to alter the request semantics. There is no logic in this function that handles, inspects, or intentionally ignores such context information, nor does it differentiate request semantics based on it. Therefore, the function does not appear to address any of the labeled constraints (e.g., C1, A1) related to this RFC.",success,
16219,req_filename_field,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided code function simply returns the filename from the request structure (r->filename) without any logic addressing the HTTP RFC specification regarding Content-Location. No part of the function implements or checks the constraint that the origin server MUST NOT use context information to alter the request semantics (e.g., C1 or any associated actions). Therefore, the function does not implement any of the labeled conditions or actions from the spec.",success,
16220,req_user_field,"A server SHOULD NOT use the From header field for access control or authentication, since its value is expected to be visible to anyone receiving or observing the request and is often recorded within logfiles and error reports without any expectation of privacy.",86,Does Not Match,[],"The provided function simply returns the 'user' field from the request_rec structure and does not contain any logic addressing the RFC requirement about the From header field. It neither implements access control, validation, or utilization of the From header field, nor does it avoid its use for authentication. Therefore, none of the spec constraints (such as C1 or A1) are addressed within this function's code.",success,
16251,lua_ap_unescape,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function, lua_ap_unescape, simply performs URL unescaping using known libraries and does not include any logic to check or enforce role-based generation of protocol elements as required by the RFC. It does not verify that a sender is not generating elements that are permitted only for other roles. Since no part of the code addresses the requirement 'Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles,' this function does not implement the specified constraint.",success,
16252,lua_ap_escape,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function lua_ap_escape only escapes a given URL string by calling ap_escape_urlencoded and pushing the result onto the Lua stack. There is no logic in this function that verifies whether the sender is allowed to generate certain protocol elements, nor does it perform any checks or validations against the role-specific protocol syntax as required by the RFC specification. Thus, none of the spec constraints (such as preventing the generation of protocol elements reserved for other roles) are handled within this function.",success,
16277,lua_ap_escape_logitem,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, lua_ap_escape_logitem, is solely focused on escaping a log string using the ap_escape_logitem function and returning the result to Lua. There is no logic within this function that addresses any conditions related to the RFC specification regarding role-based generation of protocol elements or enforcing that a sender must not generate protocol elements reserved for other roles. The function does not inspect or enforce any ABNF grammar, role, or message content constraints. Therefore, it does not visibly address any of the labeled conditions (such as C1 or any actions like A1) from the spec constraints.",success,
16300,lua_set_cookie,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'key = ap_escape_urlencoded(r->pool, key);\nvalue = ap_escape_urlencoded(r->pool, value);', 'explanation': 'By escaping the key and value, the function attempts to enforce that only safe characters are included in the header output. This is an effort to keep the generated protocol elements in line with allowed grammar, even though it does not fully validate against the entire ABNF specification.'}}, {'A1': {'code': 'rv = apr_rfc822_date(cdate, apr_time_from_sec(expires));\nif (rv == APR_SUCCESS) {\n    strexpires = apr_psprintf(r->pool, ""Expires=%s;"", cdate);\n}', 'explanation': 'The use of apr_rfc822_date to format the expiry date is an attempt to generate a correctly formatted date string, which is part of the header’s grammar. However, this only covers one attribute and not the full range of protocol syntax rules.'}}]","The function generates a Set-Cookie header by combining escaped key/value pairs and conditionally appending attributes such as Expires, Path, Domain, Secure, and HttpOnly. While it makes an effort (through URL encoding and date-formatting) to produce header components that conform to expected formats, it does not perform comprehensive validation of the entire header string against the ABNF grammar defined by the HTTP RFC. Thus, within its own code, it only partially implements the requirement that a sender must not generate protocol elements that do not match the grammar.",success,
16300,lua_set_cookie,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function does not implement any logic that checks or restricts the generation of protocol elements based on the sender's role, as required by the RFC condition. The RFC states that a sender MUST NOT generate elements that are only allowed for other roles, but this function only formats a Set-Cookie header using provided parameters without performing any role verification or enforcing any restrictions based on messaging roles. Consequently, the function does not visibly address the specified condition.",success,
16302,lua_websocket_greet,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Partially Matches,"[{'C1': {'code': 'apr_table_setn(r->headers_out, ""Transfer-Encoding"", ""chunked"");\n...\n r->clength = 0;', 'explanation': 'The function explicitly sets the Transfer-Encoding header to ""chunked"" and resets the internal content length to 0. This implies an intention not to emit a Content-Length header. However, the function does not directly remove or prevent inclusion of a Content-Length header (for instance, by unsetting it in r->headers_out). It relies on later internal processing by the server, which makes the implementation only a partial match to the RFC requirement.'}}]","The RFC specifies that a sender must not send a Content-Length header field in any message containing a Transfer-Encoding header field. In the provided function, while the Transfer-Encoding header is clearly set and the internal content length is set to 0, the function does not explicitly ensure that a Content-Length header is never sent. The avoidance of the Content-Length header thus depends on internal behaviors outside this function's direct control. As a result, the function only partially addresses the RFC requirement.",success,
16302,lua_websocket_greet,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'key = apr_table_get(r->headers_in, ""Sec-WebSocket-Key"");\nif (key != NULL) {\n    ...\n    key = apr_pstrcat(r->pool, key, ""258EAFA5-E914-47DA-95CA-C5AB0DC85B11"", NULL);\n    apr_sha1_init(&sha1);\n    apr_sha1_update(&sha1, key, strlen(key));\n    apr_sha1_final(digest, &sha1);\n    encoded_len = apr_base64_encode_len(APR_SHA1_DIGESTSIZE);\n    if (encoded_len) {\n        encoded = apr_palloc(r->pool, encoded_len);\n        encoded_len = apr_base64_encode(encoded, (char*) digest, APR_SHA1_DIGESTSIZE);\n        r->status = 101;\n        apr_table_setn(r->headers_out, ""Upgrade"", ""websocket"");\n        apr_table_setn(r->headers_out, ""Connection"", ""Upgrade"");\n        apr_table_setn(r->headers_out, ""Sec-WebSocket-Accept"", encoded);\n        /* Trick httpd into NOT using the chunked filter, IMPORTANT!!!111*/\n        apr_table_setn(r->headers_out, ""Transfer-Encoding"", ""chunked"");\n        ...\n    }\n}\n', 'explanation': 'The function retrieves the Sec-WebSocket-Key, appends the fixed GUID, computes the SHA1 digest, and Base64 encodes it to set the Sec-WebSocket-Accept header. This follows the expected algorithm to generate a proper upgrade response per the RFC. However, it does not explicitly validate that the provided key (or the generated header values) fully conforms to the ABNF grammar defined by the specification.'}}]","While the function implements the core logic for the WebSocket handshake—including generating protocol elements such as 'Sec-WebSocket-Accept' using the prescribed algorithm—it does not perform explicit validation to ensure that all the generated protocol elements completely match the ABNF rules from the HTTP specification. Therefore, the function partially addresses the constraint that a sender MUST NOT generate protocol elements that do not match the defined grammar.",success,
16302,lua_websocket_greet,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'C1': {'code': 'apr_table_setn(r->headers_out, ""Upgrade"", ""websocket"");\napr_table_setn(r->headers_out, ""Connection"", ""Upgrade"");\napr_table_setn(r->headers_out, ""Sec-WebSocket-Accept"", encoded);\napr_table_setn(r->headers_out, ""Transfer-Encoding"", ""chunked"");', 'explanation': 'The spec requires that a sender MUST NOT generate multiple field lines with the same name. In this function the headers are set using apr_table_setn, which sets (or replaces) the value of a header rather than appending additional values. This ensures that only one header is generated for each field and thus partially meets the constraint.'}}]","The function is designed to perform a WebSocket handshake upgrade by setting headers for the response. It sets each header exactly once via apr_table_setn, which prevents the generation of multiple header lines with the same name. However, the provided HTTP RFC also emphasizes maintaining the order of header fields if multiples were to exist and other nuances regarding header line recombination. This function does not address header ordering nor does it check or combine multiple header values explicitly; it simply overwrites any existing header using the Apache tables interface. Therefore, while it partially meets the specific constraint (C1) of not generating multiple field lines for the same header name, it does not fully implement all aspects of the spec as detailed in the RFC.",success,
16302,lua_websocket_greet,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Fully Matches,"[{'C1': {'code': 'apr_table_setn(r->headers_out, ""Upgrade"", ""websocket"");\napr_table_setn(r->headers_out, ""Connection"", ""Upgrade"");\napr_table_setn(r->headers_out, ""Sec-WebSocket-Accept"", encoded);', 'explanation': 'The function, acting in its server role, only generates response headers which are allowed in a server message. It does not generate any protocol elements that are reserved for participants in other roles.'}}, {'A1': {'code': 'key = apr_pstrcat(r->pool, key, ""258EAFA5-E914-47DA-95CA-C5AB0DC85B11"", NULL);\napr_sha1_init(&sha1);\napr_sha1_update(&sha1, key, strlen(key));\napr_sha1_final(digest, &sha1);\nencoded_len = apr_base64_encode_len(APR_SHA1_DIGESTSIZE);\nif (encoded_len) {\n    encoded = apr_palloc(r->pool, encoded_len);\n    encoded_len = apr_base64_encode(encoded, (char*) digest, APR_SHA1_DIGESTSIZE);\n}', 'explanation': ""This segment computes the Sec-WebSocket-Accept header value from the client's Sec-WebSocket-Key as required by the WebSocket handshake, ensuring the correct protocol response.""}}]","The function implements the WebSocket upgrade handshake response in a manner that reflects the server’s role. It computes the Sec-WebSocket-Accept header correctly and sets only those headers that are allowed for the server, thereby meeting the specification that a sender must not generate protocol elements intended for other roles. All relevant constraints are directly addressed in the function body.",success,
16302,lua_websocket_greet,The server MUST generate an Upgrade header field in the response that indicates which protocol(s) will be in effect after this response.,140,Fully Matches,"[{'C1': {'code': 'r->status = 101;', 'explanation': ""The function sets the HTTP status to 101 (Switching Protocols), indicating the server's readiness to switch protocols as required by the RFC.""}}, {'A1': {'code': 'apr_table_setn(r->headers_out, ""Upgrade"", ""websocket"");', 'explanation': ""The function generates the Upgrade header field with the value 'websocket', thereby specifying which protocol will be used after the upgrade, fully implementing the RFC requirement.""}}]","The function meets the RFC specification by setting the 101 status code and generating the Upgrade header field with the correct protocol ('websocket'). All necessary actions mandated by the spec are handled within this function, ensuring that the required headers are included in the response according to the spec constraints.",success,
16302,lua_websocket_greet,"A server that sends a 101 (Switching Protocols) response MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched; if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order.",26,Partially Matches,"[{'C1': {'code': 'apr_table_setn(r->headers_out, ""Upgrade"", ""websocket"");', 'explanation': 'This line ensures that the Upgrade header is sent, which is a requirement in the RFC for a 101 response.'}}, {'A1': {'code': 'r->status = 101;', 'explanation': 'The function sets the response status to 101 (Switching Protocols) as required by the RFC.'}}, {'A2': {'code': 'apr_table_setn(r->headers_out, ""Sec-WebSocket-Accept"", encoded);', 'explanation': 'This implements part of the WebSocket handshake by providing the computed Sec-WebSocket-Accept header.'}}]","The function implements key aspects of the HTTP 101 switching protocols response for a WebSocket handshake by setting the appropriate status code, Upgrade header (with the protocol name in lower case, which is acceptable due to case-insensitivity), and computing and providing the Sec-WebSocket-Accept header. However, it does not demonstrate handling for multiple protocol layers (i.e. listing protocols in layer‐ascending order) nor does it validate that the protocol being switched was among those specified in the client's Upgrade header. Since the RFC requires these conditions to be met in full, the function partially matches the specification.",success,
16302,lua_websocket_greet,"A server MAY send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.",29,Fully Matches,"[{'C1': {'code': 'apr_table_setn(r->headers_out, ""Upgrade"", ""websocket"");', 'explanation': 'The function explicitly sets the Upgrade header field, thus advertising support for upgrading the protocol as described by the RFC.'}}, {'A1': {'code': 'r->status = 101;\napr_table_setn(r->headers_out, ""Connection"", ""Upgrade"");', 'explanation': ""By setting the status to 101 (Switching Protocols) and including the Connection header with value 'Upgrade', the function implements the expected behavior for initiating an upgrade response.""}}, {'A2': {'code': 'key = apr_pstrcat(r->pool, key, ""258EAFA5-E914-47DA-95CA-C5AB0DC85B11"", NULL);\napr_sha1_update(&sha1, key, strlen(key));\napr_sha1_final(digest, &sha1);\nencoded_len = apr_base64_encode_len(APR_SHA1_DIGESTSIZE);\nif (encoded_len) {\n    encoded = apr_palloc(r->pool, encoded_len);\n    encoded_len = apr_base64_encode(encoded, (char*) digest, APR_SHA1_DIGESTSIZE);\n    apr_table_setn(r->headers_out, ""Sec-WebSocket-Accept"", encoded);\n}', 'explanation': 'The function calculates and sets the Sec-WebSocket-Accept header based on the provided key, which is required for the WebSocket upgrade handshake and is in line with the RFC requirements for upgrade responses.'}}]","The function implements the necessary logic for an HTTP protocol upgrade response by setting the appropriate headers. It sets the Upgrade header to indicate the supported protocol ('websocket') and the Connection header to 'Upgrade', as well as computing and including the Sec-WebSocket-Accept header. These elements address the spec’s requirement to advertise and properly handle protocol upgrades, thereby fully meeting the constraints as stated in the RFC.",success,
16305,lua_websocket_read,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'A1': {'code': 'if (opcode == 0x09) { /* ping */\n    char frame[2];\n    apr_bucket *b;\n\n    frame[0] = 0x8A;\n    frame[1] = 0;\n\n    /* Pong! */\n    b = apr_bucket_transient_create(frame, 2, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(brigade, b);\n\n    rv = ap_pass_brigade(c->output_filters, brigade);\n    apr_brigade_cleanup(brigade);\n\n    if (rv != APR_SUCCESS) {\n        return 0;\n    }\n\n    do_read = 1;\n}', 'explanation': 'This segment shows that when a ping (opcode 0x09) is received, the function generates a pong frame (with byte 0x8A) in response. This is an action that touches on handling protocol elements correctly. However, the code does not explicitly verify that the sender’s role permits such generation per the RFC requirement.'}}]","The function implements part of the RFC’s messaging behavior by properly reading websocket frame components (FIN bit, opcode, payload length, masking) and responding with a pong frame upon receiving a ping message. This addresses an action similar to A1 regarding generating allowed protocol responses. However, the RFC also requires that a sender must not generate protocol elements or syntax alternatives that are only allowed for other roles (a role-based restriction). The function does not include any explicit checks or logic to ensure that it is not generating elements reserved for other roles—it simply reacts to incoming frames. As such, while some protocol handling is present, the specific constraint regarding role-based generation is only partially addressed within this function.",success,
16305,lua_websocket_read,"At a minimum, a recipient MUST be able to parse and process protocol element lengths that are at least as long as the values that it generates for those same protocol elements in other messages.",218,Partially Matches,"[{'C1': {'code': 'if (payload == 126) {\n    rv = lua_websocket_readbytes(c, brigade, (char*) &payload_short, 2);\n    if (rv != APR_SUCCESS) {\n        return 0;\n    }\n    plen = ntohs(payload_short);\n}\nif (payload == 127) {\n    rv = lua_websocket_readbytes(c, brigade, (char*) &payload_long, 8);\n    if (rv != APR_SUCCESS) {\n        return 0;\n    }\n    plen = ap_ntoh64(&payload_long);\n}', 'explanation': ""The RFC specifies that a recipient must be able to parse and process protocol element lengths that are at least as long as the values it generates. In this function, extended payload lengths are read using extra bytes when the initial payload field is 126 or 127. This indicates an effort to process longer protocol element lengths. However, since the function also imposes an upper limit (HUGE_STRING_LEN*1024) on the payload it will process, it only partially meets the notion of handling lengths 'at least as long as those it generates' in full generality.""}}]","In isolation, the function implements logic to handle different payload length indicators by reading the additional bytes that are required for extended lengths, thereby visibly addressing the RFC condition regarding processing protocol element lengths. However, by enforcing a maximum payload size limit, the implementation does not fully cover the breadth of allowed values that might be produced. Thus, while it does address key aspects of the specification, it only partially matches the overall requirement from an RFC perspective.",success,
16305,lua_websocket_read,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'rv = lua_websocket_readbytes(c, brigade, &byte, 1);\nif (rv != APR_SUCCESS) {\n    return 0;\n}\n...\nrv = lua_websocket_readbytes(c, brigade, &byte, 1);\nif (rv != APR_SUCCESS) {\n    return 0;\n}\n...\n/* Several read attempts are all followed by a check for APR_SUCCESS */', 'explanation': ""This code demonstrates a defensive approach to parsing: each attempt to read a part of the protocol element checks the return value. If a read fails (i.e. does not conform to expectations or a read error occurs), the function immediately returns. This defensive checking of each individual byte/segment aligns with the specification's advice to parse received protocol elements defensively.""}}, {'A1': {'code': 'if (plen < (HUGE_STRING_LEN*1024) && plen > 0) {\n    apr_size_t remaining = plen;\n    char *buffer = apr_palloc(r->pool, plen+1);\n    buffer[plen] = 0;\n    rv = lua_websocket_readbytes(c, brigade, buffer, remaining);\n    ...\n}', 'explanation': 'Here the code limits the payload data to a size that is considered reasonable (i.e. less than HUGE_STRING_LEN*1024). This check ensures that the buffer size is controlled, matching the spec’s recommendation that protocol elements should fit within a reasonable buffer size.'}}]","The function demonstrates defensive parsing techniques by individually reading bytes of the WebSocket frame and verifying each read operation's success. It also constrains the payload size to a reasonable value before processing, which aligns with the HTTP RFC's guidance to parse protocol elements defensively with minimal assumptions on conformance and size. Thus, the code function fully addresses the specified constraints within its own logic.",success,
16305,lua_websocket_read,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': '/* Get opcode and FIN bit */\nrv = lua_websocket_readbytes(c, brigade, &byte, 1);\nif (rv == APR_SUCCESS) {\n    unsigned char ubyte, fin, opcode, mask, payload;\n    ubyte = (unsigned char)byte;\n    /* fin bit is the first bit */\n    fin = ubyte >> (CHAR_BIT - 1);\n    /* opcode is the last four bits */\n    opcode = ubyte & 0xf;\n\n    /* Get the payload length and mask bit */\n    rv = lua_websocket_readbytes(c, brigade, &byte, 1);\n    if (rv == APR_SUCCESS) {\n         ubyte = (unsigned char)byte;\n         /* Mask bit and payload length extraction */\n         mask = ubyte >> (CHAR_BIT - 1);\n         payload = ubyte & 0x7f;\n         ...\n    }\n}', 'explanation': 'The function explicitly reads and interprets the incoming protocol element by extracting the FIN bit, opcode, payload length (including extended lengths) and mask bit in accordance with the semantics defined by the specification. This shows that the function attempts to follow the core requirement that the recipient interprets the protocol element according to the spec.'}}]","The code function demonstrates an attempt to implement part of the RFC requirement by interpreting the received protocol element (e.g. parsing the header fields, handling extended payloads, applying masking, and even replying to pings as a form of response compliance). However, it does not include any explicit mechanism for checking or disregarding the protocol element based on prior determination (through experience or configuration) that the sender implemented the protocol incorrectly. Because only part of the RFC's requirements is directly addressed within this function (the direct interpretation of protocol fields), the overall match is only partial.",success,
16306,lua_websocket_write,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (raw != 1) {\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(03013) ""Websocket: Writing framed message to client"");\n    prelude = 0x81; /* text frame, FIN */\n    ap_rputc(prelude, r);\n    if (len < 126) {\n        ap_rputc(len, r);\n    } else if (len < 65535) {\n        apr_uint16_t slen = len;\n        ap_rputc(126, r);\n        slen = htons(slen);\n        ap_rwrite((char*) &slen, 2, r);\n    } else {\n        apr_uint64_t llen = len;\n        ap_rputc(127, r);\n        llen = ap_ntoh64(&llen);\n        ap_rwrite((char*) &llen, 8, r);\n    }\n}\n', 'explanation': 'This code segment attempts to generate a properly framed WebSocket message by adding a fixed header (0x81) and encoding the payload length. In the context of ensuring that the sender generates only its permitted protocol elements (those allowed by its role), this demonstrates an effort to adhere to the RFC by always creating a server-appropriate frame when not in raw mode.'}}]","The provided function implements logic to write a WebSocket message either in a framed or raw form. When not in raw mode, it adds a fixed frame header and handles payload length encoding, which is consistent with a server‐side implementation (servers must not include elements reserved for clients, such as masking keys). However, there is no explicit check for the sender’s role, and the option to send a raw message (when raw==1) bypasses the framing logic entirely. As a result, while part of the function addresses the requirement that a sender generate only the permitted protocol elements (by always using the unmasked header in framed mode), it does not fully enforce a role check or restrict raw messages, leading to a partial match of the specification.",success,
16307,lua_websocket_close,"A server that sends a ""close"" connection option MUST initiate closure of the connection (see below) after it sends the response containing the ""close"" connection option.",321,Fully Matches,"[{'A1': {'code': 'prelude[0] = 0x88; /* closing socket opcode */\nprelude[1] = 0; /* zero length frame */\nap_rwrite(prelude, 2, r);\napr_socket_close(sock);\nr->output_filters = NULL;\nr->connection->keepalive = AP_CONN_CLOSE;', 'explanation': ""This code sends a 'close' connection option by writing a close frame (opcode 0x88 with a zero length) and then immediately initiates the closure of the connection by closing the socket, clearing output filters, and setting the connection's keepalive flag to indicate closure as required by the RFC.""}}]","The function visibly implements the RFC requirement: after sending the response containing the 'close' connection option, it initiates connection closure. All necessary actions (sending the close frame and closing the connection) are directly performed in the function, and thus it fully meets the specified constraint.",success,
16307,lua_websocket_close,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification mandates that a sender must not generate protocol elements that are only allowed for other roles. There is no check within the lua_websocket_close function to verify if the sender is permitted to generate the close frame based on its role. The function merely writes a close frame (opcode 0x88 with zero length) and closes the socket without enforcing any role-based constraints, so it does not visibly address the required conditions and actions from the RFC specification.",success,
16308,lua_websocket_ping,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that within a message, a sender must not generate protocol elements or syntax alternatives that are reserved for other roles. In this function, there is no visible logic to check or enforce that the sender is permitted to generate the WebSocket PING frame, nor is there any validation to ensure that only allowed protocol elements are generated by the current role. Instead, the function directly constructs and sends a PING frame (using opcode 0x89) and then processes the response, without any role-based validation or restriction. Therefore, no labeled condition (such as C1) or action (such as A1) from the spec constraints is fully implemented within the code function itself.",success,
16331,report_lua_error,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'r->content_type = ""text/html"";', 'explanation': ""The function directly sets the Content-Type header field to 'text/html', which satisfies the RFC requirement that a sender generating a message with content should include a Content-Type header when the media type is known.""}}]","The function 'report_lua_error' explicitly assigns a Content-Type header by setting r->content_type to 'text/html'. This fulfills the RFC mandate that a message containing content should include a Content-Type header unless the media type is unknown. Although the specification context suggests a charset may be included (as in 'text/html; charset=ISO-8859-4'), the primary requirement is to provide a Content-Type header, which this function does. The implementation within this function visibly addresses the listed condition without relying on external dependencies.",success,
16338,lua_handler,"Except when responding to a HEAD request, the server SHOULD send a representation containing an explanation of the error situation, and whether it is a temporary or permanent condition.",161,Partially Matches,"[{'C1': {'code': 'if (!r->header_only) {\n    …\n    /* when error compiling VM */\n    if (!L) {\n        r->status = HTTP_INTERNAL_SERVER_ERROR;\n        ap_rputs(""Unable to compile VM, see logs"", r);\n        …\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    …\n}', 'explanation': 'The function checks whether the response is for a HEAD request (using r->header_only) and only sends a response body for non-HEAD requests, partially aligning with the requirement to not send an explanation representation when responding to a HEAD request.'}}]","The RFC requires that, except for HEAD requests, the server send a representation explaining the error and indicating if the condition is temporary or permanent. In the function, the check on r->header_only shows an awareness of not sending a body for HEAD requests. Additionally, when an error occurs (such as a failure to compile the Lua VM), the function sends a short message. However, the error representation is minimal – it does not provide a detailed explanation or indicate whether the error is temporary or permanent. Thus, while some error-handling logic addressing HEAD requests is present, the function only partially meets the full specification of the RFC.",success,
16339,lua_setup_filter_ctx,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,[],"The RFC requires that a message with an incorrect Content-Length header value must not be forwarded. In the provided function, there is a code segment (lines 49–53) that unconditionally removes the 'Content-Length' header (along with other headers) when the filter is not wired by mod_filter. Although this removal of the header might be seen as an attempt to avoid sending a possibly incorrect header, the function does not perform any validation or checking to decide if the Content-Length is actually incorrect. It does not verify if the header value is malformed or known to be incorrect, nor does it handle the exceptional case of repeated values as allowed by the RFC. Since the function only partially addresses the requirement by simply unsetting the header in a specific branch without actually assessing its correctness, it only partially matches the spec constraint.",success,
16343,lua_map_handler_fixups,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function does not implement any logic related to the specified RFC constraint regarding Content-Location and altering request semantics. It solely focuses on mapping a Lua handler based on a URI regex match and does not interact with any request metadata, such as Content-Location, or enforce that such context must not alter semantics. Therefore, no part of the function addresses the labeled spec conditions or actions.",success,
16456,set_language_priority,Multiple languages MAY be listed for content that is intended for multiple audiences.,260,Partially Matches,"[{'C1': {'code': 'if (!n->language_priority)\n        n->language_priority = apr_array_make(cmd->pool, 4, sizeof(char *));\n\nlangp = (const char **) apr_array_push(n->language_priority);\n*langp = lang;', 'explanation': 'This segment shows that the function supports accumulating multiple language values by initializing an array (if not already allocated) and then appending the provided language string. This supports the RFC requirement that multiple languages MAY be listed for content intended for multiple audiences.'}}]","The function implements logic to store language values by appending them into an array, which aligns with the RFC's notion that multiple languages may be listed. However, it does not address other aspects of the RFC such as the default behavior when no Content-Language is provided, thus it only partially fulfills the overall specification.",success,
16462,set_vlist_validator,"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.",57,Partially Matches,"[{'A1': {'code': 'ap_update_mtime(vlistr, vlistr->finfo.mtime);\n    r->vlist_validator = ap_make_etag(vlistr, 0);', 'explanation': ""This code segment updates the modification time and computes an ETag-like validator for the resource. It directly contributes toward the requirement of producing an ETag based on detectable changes in the representation, which corresponds with the RFC's recommendation to include an ETag.""}}]","The RFC specifies that an origin server should send an ETag when changes in the representation can be consistently detected. This function updates the modification time and creates an ETag-like value (vlist_validator) by calling ap_make_etag(), which is later used to set the ETag header. However, the actual transmission of the ETag header and any further logic for fully determining changes are handled elsewhere. Therefore, while the function contains logic that partially implements the RFC requirement by computing the validator, it does not by itself complete the full process mandated by the specification.",success,
16463,atoq,A sender of qvalue MUST NOT generate more than three digits after the decimal point.,279,Fully Matches,"[{'C1': {'code': ""if (*string == '.') {\n    int i = 0;\n\n    if (*++string >= '0' && *string <= '9') {\n        i += (*string - '0') * 100;\n\n        if (*++string >= '0' && *string <= '9') {\n            i += (*string - '0') * 10;\n\n            if (*++string > '0' && *string <= '9') {\n                i += (*string - '0');\n            }\n        }\n    }\n\n    return (float)i / 1000.0f;\n}"", 'explanation': 'This code block reads at most three digits after the decimal point and converts them into a normalized float between 0 and 1, enforcing the restriction of not generating more than three digits after the decimal point.'}}]","The provided function 'atoq' parses a string representing a qvalue and, when a decimal point is encountered, it explicitly processes only up to three digits following the decimal. This behavior directly implements the RFC specification which mandates that a sender of qvalue must not generate more than three digits after the decimal point. The code within the function itself enforces this constraint, fulfilling the requirement solely within its own logic.",success,
16464,get_entry,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': ""while (*accept_line == ';') {\n    /* Parameters ... */\n    char *parm;\n    ...\n    if (!*cp) {\n        continue;           /* No '='; just ignore it. */\n    }\n    ...\n}"", 'explanation': 'The function iterates over the input string, extracting tokens and parameters in a loop and using ap_get_token to parse elements. This indicates an attempt to defensively parse a protocol element that might not strictly conform to the expected ABNF grammar.'}}, {'A1': {'code': 'result->name = ap_get_token(p, &accept_line, 0);\nap_str_tolower(result->name);', 'explanation': 'The code retrieves the token and converts it to lowercase, ensuring case-insensitive matching as expected by the protocol. This is in line with actions enforcing robust token handling.'}}]","The function implements a basic, defensive approach to parsing an HTTP Accept header by iteratively consuming tokens and parameters while applying default values and case normalization. Although it handles many cases (such as checking for existence of '=' in parameters and handling quoted values), it does not implement explicit buffer size checking or robust error recovery that might be expected based on the RFC’s recommendation. Therefore, while key aspects of defensive parsing are present (matching conditions such as C1 and action A1), the implementation does not fully cover all the defensive concerns raised in the spec, resulting in a partial match.",success,
16464,get_entry,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'result->quality = 1.0f;\nresult->level = 0.0f;\n...\nresult->name = ap_get_token(p, &accept_line, 0);\nap_str_tolower(result->name);\n...\nif (!strcmp(result->name, ""text/html"") && (result->level == 0.0)) {\n    result->level = 2.0f;\n}\n', 'explanation': 'The RFC requires that a recipient interpret the received protocol element according to its semantics. The function initializes fields to defaults and then processes the MIME type, applying special default behavior (for example, defaulting text/html to level 2.0), which addresses part of that requirement.'}}, {'A1': {'code': ""while (*accept_line == ';') {\n    ...\n    parm = ap_get_token(p, &accept_line, 1);\n    for (cp = parm; (*cp && !apr_isspace(*cp) && *cp != '='); ++cp) {\n        *cp = apr_tolower(*cp);\n    }\n    if (!*cp) {\n        continue;           /* No '='; just ignore it. */\n    }\n    ...\n    if (*end) {\n        *end = '\\0';\n    }\n    ...\n}\n"", 'explanation': ""The RFC allows a recipient to attempt to recover a usable protocol element from an invalid construct. Here the function loops through parameters and, if a parameter lacks an '=', skips it; this is a recovery strategy for malformed input.""}}]","The function partially implements the RFC’s requirements by parsing the Accept header, applying default values, and incorporating mechanisms to recover from incomplete or improperly formatted parameters. However, while it addresses these aspects in isolation, it does not cover the entire spectrum of error detection, configuration-based handling, or security‐related error mechanisms implied by the full RFC context.",success,
16464,get_entry,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The code function is focused on parsing the 'Accept' header by tokenizing input, converting tokens to lowercase, and setting default values (such as quality and level). It does not contain any logic that pertains to the generation of protocol elements or syntax alternatives according to roles. In other words, it does not address the RFC requirement that a sender must not generate protocol elements that are only allowed for participants in other roles (the spec constraint). Thus, no part of the function implements the condition or action corresponding to the spec.",success,
16466,do_languages_line,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function 'do_languages_line' merely tokenizes the language line and normalizes it to lowercase. It does not contain any logic to enforce that protocol elements are only generated by permitted roles as required by the RFC specification. There is no code in this function that checks or restricts the generated protocol elements based on the sender's role, so it does not visibly address any of the specified conditions or actions.",success,
16466,do_languages_line,"In any production that uses the list construct, a sender MUST NOT generate empty list elements.",236,Does Not Match,[],"The provided function processes a list from the input string by extracting tokens using ap_get_token and then pushing them to an array, but it does not check or ensure that the tokens are non-empty. The spec requires that in any production that uses the list construct, a sender MUST NOT generate empty list elements. In the function_body, there is no verification (such as checking the length of the token returned by ap_get_token) to enforce this requirement. Therefore, the constraint regarding empty list elements is not implemented in this function.",success,
16466,do_languages_line,Multiple languages MAY be listed for content that is intended for multiple audiences.,260,Partially Matches,"[{'C1': {'code': ""while (**lang_line) {\n    char **new = (char **) apr_array_push(lang_recs);\n    *new = ap_get_token(p, lang_line, 0);\n    ap_str_tolower(*new);\n    if (**lang_line == ',' || **lang_line == ';') {\n        ++(*lang_line);\n    }\n}"", 'explanation': 'This loop tokenizes the language string into individual language tokens (by splitting on commas or semicolons) and converts them to lower-case, thereby allowing multiple languages to be listed as per the specification. However, it does not explicitly enforce a default for cases when no Content-Language is provided.'}}]","The function 'do_languages_line' implements the logic to parse a list of languages from a provided string, which partially addresses the requirement that multiple languages may be listed for content intended for multiple audiences. The tokenization and normalization to lower-case indicate an attempt to comply with the spec. However, the function does not implement the default behavior described in the specification context (i.e., treating unspecified Content-Language as all language audiences), and no additional actions (such as verifying or setting defaults) appear within the function. Thus, while the multiple language handling is present, the overall implementation is only partial.",success,
16468,parse_negotiate_header,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, parse_negotiate_header, focuses on parsing the 'Negotiate' header and adjusting flags in the negotiation_state structure based on token values (e.g., 'trans', 'vlist', etc.). However, it does not contain any explicit logic to ensure that the sender does not generate protocol elements or syntax alternatives that are only allowed for participants in other roles, as required by the RFC specification. The function does not check against the ABNF-defined grammar for such protocol elements nor does it enforce any restrictions based on the sender's role. Therefore, the function does not visibly address the labeled constraint from the RFC.",success,
16468,parse_negotiate_header,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'const char *negotiate = apr_table_get(r->headers_in, ""Negotiate"");\n...\nwhile ((tok = ap_get_list_item(neg->pool, &negotiate)) != NULL) {\n    if (strcmp(tok, ""trans"") == 0 ||\n        strcmp(tok, ""vlist"") == 0 ||\n        strcmp(tok, ""guess-small"") == 0 ||\n        apr_isdigit(tok[0]) ||\n        strcmp(tok, ""*"") == 0) {\n        neg->ua_supports_trans = 1;\n        neg->send_alternates = 1;\n        if (strcmp(tok, ""1.0"") == 0) {\n            neg->may_choose = 1;\n            neg->use_rvsa = 1;\n            neg->dont_fiddle_headers = 1;\n        } else if (tok[0] == \'*\') {\n            neg->may_choose = 1;\n            neg->dont_fiddle_headers = 1;\n        }\n    }\n}', 'explanation': ""This section retrieves the 'Negotiate' header and iterates through its tokens, interpreting their semantics according to the protocol specification. It adjusts the negotiation state based on known token values, fulfilling the requirement to interpret the protocol element per the RFC.""}}, {'A1': {'code': 'if (!negotiate)\n    return;\n\nif (strcmp(negotiate, ""trans"") == 0) {\n    const char *ua = apr_table_get(r->headers_in, ""User-Agent"");\n    if (ua && (strncmp(ua, ""Lynx"", 4) == 0))\n        return;\n}', 'explanation': ""This segment checks for a known problematic case (the 'trans' header from Lynx browsers) and effectively ignores the header when the sender is known to implement the semantics incorrectly. This is an example of recovering a usable protocol element from an invalid or misapplied construct.""}}]","The function 'parse_negotiate_header' performs direct interpretation of the 'Negotiate' header by extracting its value, tokenizing it, and then adjusting the state of the negotiation accordingly. It addresses part of the RFC requirement by ensuring that the received protocol element is interpreted according to its defined semantics (C1) and by implementing a recovery mechanism for a known misimplementation (A1). However, it does not cover all possible error handling or recovery strategies that the RFC leaves open, and some additional aspects may be handled elsewhere in the system. Thus, the function partially matches the specified constraints.",success,
16468,parse_negotiate_header,A recipient MAY employ such workarounds while remaining conformant to this protocol if the workarounds are limited to the implementations at fault.,216,Partially Matches,"[{'C1': {'code': 'if (strcmp(negotiate, ""trans"") == 0) {\n    const char *ua = apr_table_get(r->headers_in, ""User-Agent"");\n\n    if (ua && (strncmp(ua, ""Lynx"", 4) == 0))\n        return;\n}', 'explanation': ""This segment implements a workaround as allowed by the RFC. It specifically checks if the Negotiate header is set to 'trans' and if the User-Agent indicates a Lynx browser, then it avoids processing further. This is a targeted workaround for broken browser configurations, thus fulfilling the concept of employing limited workarounds for faulty implementations.""}}]","The RFC states that a recipient MAY employ workarounds limited to the faulty implementations. The provided function contains logic (specifically the Lynx check) that implements a workaround for browsers known to misbehave regarding the 'Negotiate' header. Although this is only one aspect of the overall specification and not all possible conditions or actions are handled within this function alone, it does address a specific labeled condition corresponding to the RFC's allowance for targeted workarounds, thereby partially matching the specification.",success,
16468,parse_negotiate_header,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function, parse_negotiate_header, is focused on parsing and interpreting the 'Negotiate' header from a client request rather than generating protocol elements. The RFC specification constraint requires that a sender must not generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. This function does not implement any logic that validates or generates such protocol elements based on ABNF rules, and it does not perform any grammar checking or protocol element generation. All of the logic in this function is related to setting negotiation state flags based on the header content, without addressing the specification constraints, and thus it does not visibly address the required RFC constraint.",success,
16469,maybe_add_default_accepts,A sender of qvalue MUST NOT generate more than three digits after the decimal point.,279,Partially Matches,"[{'C1': {'code': 'new_accept->quality = 1.0f;\n...\nnew_accept->quality = prefer_scripts ? 2.0f : 0.001f;', 'explanation': 'The RFC requirement states that a sender MUST NOT generate more than three digits after the decimal point. In this function, the quality values are hard-coded (1.0f, 2.0f, and 0.001f), and each of these constants uses at most three digits after the decimal. This indicates an attempt to adhere to the spec for generated values. However, the function does not include any explicit logic (such as rounding or validation) to enforce this limit on dynamically generated or user‐provided values. It simply uses fixed constants that happen to comply, hence the partial match.'}}]","The function sets the quality field using constants that comply with the three-digit precision rule (e.g. 1.0f, 2.0f, and 0.001f). Although these assignments do not generate more than three digits after the decimal point, the function lacks any additional enforcement (like rounding or validation) that would be required if the quality were derived dynamically or from user input. Therefore, while the code uses compliant constant values, it only partially addresses the RFC requirement by not implementing a general mechanism for enforcing the constraint in all cases.",success,
16469,maybe_add_default_accepts,"Note that the coding named ""identity"" is reserved for its special role in Accept-Encoding and thus SHOULD NOT be included.",38,Does Not Match,[],"The provided function does not contain any logic related to the HTTP RFC specification concerning Content-Encoding (specifically gzip) or the exclusion of the identity coding. Instead, its logic is focused solely on managing accept_rec records (i.e., for Accept header values) by adding default accept records and a CGI magic type based on certain flags. There is no code in this function that checks, orders, or validates content-coding headers as required by the specification context, so it does not address any of the labeled conditions (e.g., C1) or actions (e.g., A1) pertaining to the RFC.",success,
16470,get_header_line,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Does Not Match,[],"The RFC requires that the recipient parse for BWS (bad whitespace) and remove it before interpreting the protocol element. In the provided function, although there is some handling of whitespace (e.g., skipping leading whitespace to detect blank lines or continuation lines), the code does not explicitly identify or remove BWS per the RFC specification. The whitespace handling here is tied to line continuation and comment skipping rather than implementing a sanitization of BWS as described. Thus, no part of the function clearly and directly implements the intended BWS removal requirement.",success,
16473,lcase_header_name_return_body,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,"[{'C1': {'code': 'do {\n    ++cp;\n} while (apr_isspace(*cp));', 'explanation': 'This code segment advances the pointer beyond any whitespace immediately following the colon. It effectively removes the leading bad whitespace from the header body before further interpretation, which corresponds to the RFC requirement that a recipient parse for and remove bad whitespace. However, only the portion concerning removal of whitespace after the colon is handled here.'}}]","The function converts the header name to lowercase and then skips over any whitespace following the colon, thereby removing the leading bad whitespace from the header body before processing further. This meets part of the RFC specification stating that recipients MUST remove bad whitespace before interpreting protocol elements. Nonetheless, as the logic does not address potential whitespace issues elsewhere nor provide a comprehensive normalization per the full spec context, the implementation only partially matches the requirement.",success,
16473,lcase_header_name_return_body,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': 'do {\n    ++cp;\n} while (apr_isspace(*cp));', 'explanation': 'This loop explicitly advances the pointer past any whitespace characters (BWS) after the colon, effectively removing optional whitespace before interpreting the header body as required by the RFC.'}}]",The function processes the header by first normalizing the header name to lower-case and then locating the colon separator. It subsequently removes any whitespace (BWS) following the colon by looping until a non-whitespace character is encountered. This directly implements the behavior specified by the RFC requirement to remove bad whitespace before interpreting a protocol element.,success,
16473,lcase_header_name_return_body,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'A1': {'code': 'do {\n    ++cp;\n} while (apr_isspace(*cp));', 'explanation': 'This segment of the function explicitly skips over any whitespace characters following the colon, thereby ensuring that any allowed leading whitespace is excluded before the field value is processed, as required by the RFC specification.'}}]","The RFC requires that any whitespace allowed in an HTTP header message be excluded prior to evaluating the field value. In this function, after locating the colon that separates the header name from the header body, the code immediately advances past any whitespace using a loop with apr_isspace. This directly implements the behavior described in the specification, and thus the function fully fulfills the relevant constraint (labeled here as A1).",success,
16474,read_type_map,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'char buffer[MAX_STRING_LEN];\n...\nhstate = get_header_line(buffer, MAX_STRING_LEN, *map);', 'explanation': 'The function uses a fixed-size buffer (MAX_STRING_LEN) to read header lines, which reflects an expectation of a reasonable buffer size when parsing, in line with defensive parsing.'}}, {'A1': {'code': 'if (!ap_parse_strict_length(&clen, body1)) {\n    ap_log_rerror(... ""Parse error in type map, Content-Length: \'%s\' in %s is invalid."", body1, r->filename);\n    break;\n}', 'explanation': 'The function checks the Content-Length for proper formatting and logs a parse error if it does not conform, demonstrating a defensive approach to parsing a protocol element.'}}]","The function demonstrates elements of defensive parsing by imposing a fixed maximum buffer size and by checking/parsing individual header elements (such as Content-Length) with error logging for malformed values. However, it only partially implements the RFC's recommendation to defensively parse with marginal assumptions on ABNF conformance and element lengths, since many details about comprehensive ABNF validation or flexible buffer handling are not fully addressed within this function alone.",success,
16474,read_type_map,"An origin server that wishes to ""hide"" the current existence of a forbidden target resource MAY instead respond with a status code of 404 (Not Found).",163,Partially Matches,"[{'C1': {'code': 'if (APR_STATUS_IS_ENOTDIR(status) || APR_STATUS_IS_ENOENT(status)) {\n            return HTTP_NOT_FOUND;\n        }', 'explanation': 'This segment checks for specific file access errors (file not found or not a directory) and returns a 404 Not Found, which aligns with the RFC suggestion to hide the existence of a forbidden resource. However, it does not address other parts of the spec, such as handling authentication credentials.'}}]","The function partially implements the RFC. It visibly includes logic to return a 404 status code under conditions where the file is absent or not a directory, which matches the condition to hide the resource's existence. However, the complete RFC includes additional context regarding authentication credentials and further behavior that is not handled in this function alone. Therefore, only a portion of the labeled conditions/actions (here, C1 corresponding to the 404 response) is met by this function.",success,
16480,set_default_lang_quality,A sender of qvalue MUST NOT generate more than three digits after the decimal point.,279,Does Not Match,[],"The provided function does not implement any logic to enforce the HTTP RFC requirement that qvalues must not have more than three digits after the decimal point. In one branch, the function sets the quality factor to 0.0001f, which actually contains four digits after the decimal point, thereby violating the spec. There is no rounding or limiting mechanism present within the function_body to address this constraint.",success,
16492,set_neg_headers,A sender of qvalue MUST NOT generate more than three digits after the decimal point.,279,Fully Matches,"[{'C1': {'code': 'qstr = (char *) apr_palloc(r->pool, 6);\napr_snprintf(qstr, 6, ""%1.3f"", variant->source_quality);\n\n/* Strip trailing zeros (saves those valuable network bytes) */\nif (qstr[4] == \'0\') {\n    qstr[4] = \'\\0\';\n    if (qstr[3] == \'0\') {\n        qstr[3] = \'\\0\';\n        if (qstr[2] == \'0\') {\n            qstr[1] = \'\\0\';\n        }\n    }\n}', 'explanation': 'This code formats the \'qvalue\' using a format specifier that limits the number of digits after the decimal point to three (using ""%1.3f""). The subsequent trimming of trailing zeros further ensures that no more than three digits are output, directly addressing the RFC constraint.'}}]","The provided function implements the qvalue formatting requirement by using a precise format specifier which outputs three decimal places, and it further trims trailing zeroes to optimize the output. This directly satisfies the RFC specification that a sender of qvalue MUST NOT generate more than three digits after the decimal point.",success,
16492,set_neg_headers,Multiple languages MAY be listed for content that is intended for multiple audiences.,260,Fully Matches,"[{'C1': {'code': 'if (variant->content_languages && variant->content_languages->nelts) {\n    lang = apr_array_pstrcat(r->pool, variant->content_languages, \',\');\n} else {\n    lang = NULL;\n}\n...\nif (lang) {\n    *((const char **) apr_array_push(arr)) = "" {language "";\n    *((const char **) apr_array_push(arr)) = lang;\n    *((const char **) apr_array_push(arr)) = ""}"";\n}', 'explanation': 'The RFC requires that when content is provided in multiple languages it is possible to list them. This code segment checks for available Content-Language values, concatenates them (using commas), and injects them into the Alternates header. When no language is provided the header part is simply omitted, which is consistent with the default interpretation of ""all language audiences"".'}}]","The function explicitly handles the inclusion of multiple languages by checking if a variant has an array of content languages and then concatenating and inserting that information into the Alternates header. This behavior directly supports the RFC statement that multiple languages MAY be listed for content intended for multiple audiences. Since the default where no language is specified is implicitly handled (by not adding a specific language field), the code fully addresses the RFC requirements within the scope of this function.",success,
16493,make_variant_list,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'ap_escape_path_segment(r->pool, filename);\nap_escape_html(r->pool, filename);', 'explanation': 'The function uses escaping functions for path segments and HTML, which helps mitigate injection of invalid characters. This indirectly contributes to generating output that is less likely to violate the grammar as defined by the ABNF rules. However, it does not perform an explicit validation against the ABNF grammar, so the constraint is only partially addressed.'}}]","The provided function constructs an HTML-formatted list of available variants by manually concatenating string fragments and uses escaping routines (ap_escape_path_segment and ap_escape_html) to sanitize parts of the output. These escaping routines help ensure that the inserted values do not break the expected syntax, which partially addresses the RFC requirement that a sender must not generate protocol elements violating the ABNF grammar. However, the function does not explicitly validate the entire generated protocol element against the complete ABNF rules, nor does it enforce role-specific syntax limitations. Therefore, the implementation only partially meets the specified constraint.",success,
16493,make_variant_list,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, make_variant_list, is solely responsible for constructing and concatenating an HTML list of available variants. It does not perform any checks or validations to ensure that protocol elements or syntax alternatives are generated only by authorized roles, as required by the RFC specification. No logic exists within this function to restrict generation of protocol elements based on sender roles (e.g., no checks corresponding to any conditions like C1 or actions like A1). The function’s behavior is limited to formatting output, and hence it does not address the specified constraint.",success,
16496,do_negotiation,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The function 'do_negotiation' primarily handles content negotiation and variant selection logic. Although it contains logic regarding caching behavior (disabling caching for HTTP/1.0 clients via r->no_cache), it does not implement any logic related to the RFC requirement that states a cache cannot be used when acting as a tunnel. There is no code within this function that checks if the server or client is acting as a tunnel and hence prevents cache usage accordingly. Therefore, the function does not visibly address the specified RFC condition.",success,
16497,handle_map_file,Multiple languages MAY be listed for content that is intended for multiple audiences.,260,Fully Matches,"[{'C1': {'code': 'if (best->content_languages && best->content_languages->nelts) {\n    r->content_languages = apr_array_copy(r->pool, best->content_languages);\n}', 'explanation': 'This snippet checks whether multiple content languages have been negotiated and, if so, sets the Content-Language header accordingly. This directly addresses the spec requirement that multiple languages MAY be listed for content intended for multiple audiences.'}}]","The function explicitly examines the negotiated content languages and, if available, copies them to the response structure. This shows that the function alone attempts to implement the specification requirement regarding multiple languages. No other parts of the RFC (as given in the spec) are required, so the function fully meets the labeled constraint.",success,
16497,handle_map_file,The type/subtype MAY be followed by semicolon-delimited parameters (Section 5.6.6) in the form of name/value pairs.,259,Partially Matches,"[{'A1': {'code': 'if (best->mime_type && *best->mime_type) {\n    if (best->content_charset && *best->content_charset) {\n        ap_set_content_type_ex(r, apr_pstrcat(r->pool, best->mime_type, ""; charset="", best->content_charset, NULL), 1);\n    } else {\n        ap_set_content_type_ex(r, apr_pstrdup(r->pool, best->mime_type), 1);\n    }\n}', 'explanation': ""This code constructs the Content-Type header by appending a semicolon-delimited charset parameter (when available), which partially implements the RFC requirement that the type/subtype MAY be followed by semicolon-delimited parameters. It shows an attempt to include parameters in the output, although it only handles the 'charset' parameter and does not implement full parsing or case normalization for type/subtype tokens.""}}]","The function shows visible logic to append a parameter (i.e., charset) to the MIME type, addressing part of the RFC requirement on parameters following type/subtype values. However, it does not implement full handling of arbitrary semicolon-delimited name/value pairs or address case-insensitivity of tokens within the function itself. Therefore, the function only partially matches the RFC spec constraints.",success,
16497,handle_map_file,"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",225,Does Not Match,[],"The RFC spec requires that an 'https' URI must not be generated with an empty host identifier, but the function does not contain any explicit logic to validate or enforce the presence of a host identifier in an 'https' URI. The function primarily deals with file mapping and internal redirection and does not inspect or modify the authority component of a URI. Therefore, no part of the function addresses the specific constraint regarding empty host identifiers.",success,
16497,handle_map_file,An origin server without a clock MUST NOT generate a Last-Modified date for a response unless that date value was assigned to the resource by some other system (presumably one with a clock).,55,Does Not Match,[],"The provided function does not implement any logic related to the Last-Modified header conditions detailed in the RFC specification. Specifically, the function contains no code to check whether the server has a clock or to adjust or validate a Last-Modified date based on server time versus resource metadata. Although there is a commented-out section hinting at updating modification times and setting the Last-Modified header, it is not active code. Consequently, the function does not visibly address any of the labeled constraints (e.g., C1, A1) relating to Last-Modified dates as required by the spec.",success,
16497,handle_map_file,"An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",60,Fully Matches,"[{'A1': {'code': 'if (r->method_number != M_GET && r->method_number != M_POST) {\n    return HTTP_METHOD_NOT_ALLOWED;\n}', 'explanation': 'This code block clearly checks if the request method is not GET or POST, and if so returns HTTP_METHOD_NOT_ALLOWED (i.e. 405). This directly implements the RFC requirement to return a 405 response when a recognized and implemented method is not allowed for the target resource.'}}]","The function explicitly validates the request method in accordance with the RFC. By verifying that the method is either GET or POST and returning HTTP_METHOD_NOT_ALLOWED (405) for any other method, it visibly addresses the requirement that a server should respond with 405 when a recognized method is not permitted. This logic is contained entirely within the function, thereby fully matching the specified constraint.",success,
16497,handle_map_file,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'A1': {'code': 'ap_set_content_length(r, best->bytes);', 'explanation': 'This line sets the Content-Length header using the known size (best->bytes), addressing the RFC action to include a Content-Length when the content size is known.'}}]","The RFC advises that in the absence of Transfer-Encoding an origin server SHOULD send a Content-Length header when the content size is known. The function attempts to implement this by calling ap_set_content_length with best->bytes. However, the RFC also specifies conditions such as not including a Content-Length header in responses with status codes 1xx, 204, or in successful CONNECT responses. This function does not implement logic to check for these exceptional cases. Consequently, while the function addresses the primary action (A1) of sending a Content-Length header, it does not fully implement all aspects of the RFC specification, leading to a partial match.",success,
16497,handle_map_file,Content-Language MAY be applied to any media type --it is not limited to textual documents.,42,Fully Matches,"[{'A1': {'code': 'if (best->content_languages && best->content_languages->nelts) {\n    r->content_languages = apr_array_copy(r->pool, best->content_languages);\n}', 'explanation': 'This code snippet unconditionally applies the negotiated Content-Language values to the response regardless of the media type, which aligns with the RFC specification that Content-Language MAY be applied to any media type.'}}]","The function_body contains explicit logic to set the Content-Language header when a negotiated language is provided (see the A1 segment). This implementation directly addresses the RFC requirement by not limiting the application of Content-Language solely to textual documents. As a result, within the confines of this function, the relevant constraint is fully met.",success,
16497,handle_map_file,"Note that the coding named ""identity"" is reserved for its special role in Accept-Encoding and thus SHOULD NOT be included.",38,Partially Matches,"[{'A1': {'code': 'if (best->content_encoding && *best->content_encoding) {\n    r->content_encoding = apr_pstrdup(r->pool, best->content_encoding);\n}', 'explanation': ""This code sets the Content-Encoding header as negotiated. It aligns with the RFC action of applying a negotiated encoding; however, it does not verify whether the encoding equals the reserved value 'identity', which the RFC specifies should not be included.""}}]","The function attempts to implement aspects of the RFC by setting the Content-Encoding header when a negotiated encoding exists. However, it fails to check and exclude the reserved 'identity' coding as stipulated by the RFC specification. Thus, only part of the spec’s requirement is implemented within this function.",success,
16497,handle_map_file,"If one or more encodings have been applied to a representation, the sender that applied the encodings MUST generate a Content-Encoding header field that lists the content codings in the order in which they were applied.",37,Partially Matches,[],"The RFC requires that if one or more encodings have been applied to a representation, the sender MUST generate a Content-Encoding header field listing the content codings in the order they were applied, and it should not include the reserved ""identity"" coding. In the function, there is a block that checks if best->content_encoding is set and then assigns it to r->content_encoding, which indicates an attempt to set a Content-Encoding header. However, the code does not show any logic to handle multiple encodings (nor to enforce the order in which they were applied) or to omit the ""identity"" coding. Thus, while there is some effort to address the RFC requirement, it only partially meets the spec constraint directly within this function.",success,
16497,handle_map_file,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'if (best->mime_type && *best->mime_type) {\n    if (best->content_charset && *best->content_charset) {\n        ap_set_content_type_ex(r, apr_pstrcat(r->pool, best->mime_type, ""; charset="", best->content_charset, NULL), 1);\n    } else {\n        ap_set_content_type_ex(r, apr_pstrdup(r->pool, best->mime_type), 1);\n    }\n}', 'explanation': 'This code block checks whether a known MIME type exists (i.e., best->mime_type is non-null and non-empty) and then sets the Content-Type header by calling ap_set_content_type_ex. This satisfies the RFC requirement for a sender to generate a Content-Type header when the media type is known.'}}]","The function handle_map_file conducts a negotiation process for serving content and, when content is present, it checks if a MIME type is defined. If so, it generates the Content-Type header, including a charset if available. This directly fulfills the RFC specification that a message containing content should include a Content-Type header unless the media type is unknown. Therefore, based solely on the function_body, the implementation fully matches the required constraint.",success,
16497,handle_map_file,A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.,30,Does Not Match,[],"The provided function (handle_map_file) does not implement any logic to handle protocol switching or to ensure that the semantics of the received message can be honored by a new protocol, as required by the RFC specification. Even though there is a commented out code block hinting at handling OPTIONS requests (e.g., the commented 'if (r->method_number == M_OPTIONS) { return ap_send_http_options(r); }'), this section is not active. The function is focused on file negotiation and content delivery rather than protocol upgrade negotiation, and thus it does not visibly address the labeled conditions/actions related to protocol switching as outlined in the spec.",success,
16497,handle_map_file,"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT",71,Partially Matches,"[{'C1': {'code': 'if (r->method_number != M_GET && r->method_number != M_POST) {\n    return HTTP_METHOD_NOT_ALLOWED;\n}', 'explanation': 'This code segment ensures that only GET and POST requests are allowed and implicitly rejects PUT requests. Since the RFC specifies that a state‐changing request that selects a proper URI should be implemented using POST rather than PUT, rejecting methods other than POST (or GET for retrieval) partially meets the requirement.'}}]","The function performs content negotiation and eventually either serves content or internally redirects the request. A key part that aligns in spirit with the RFC is the check restricting HTTP methods to GET and POST, which disallows PUT, thereby implying that state-changing requests should use POST. However, the RFC also suggests that if PUT is received and the server wishes the state change to be applied to a different resource, an appropriate 3xx redirection response should be sent. The code instead uses an internal redirect without explicitly sending a 3xx response, and it also permits GET requests which are typically not state-changing. Therefore, while the function contains logic that addresses part of the spec (rejecting PUT), it does not fully implement all aspects of the RFC requirement, resulting in a partial match.",success,
16497,handle_map_file,"An origin server MUST NOT send a validator field (Section 8.8), such as an ETag or Last-Modified field, in a successful response to PUT unless the request's representation data was saved without any transformation applied to the content (i.e., the resource's new representation data is identical to the content received in the PUT request) and the validator field value reflects the new representation.",70,Does Not Match,[],"The provided function, handle_map_file, is focused on handling GET and POST requests for file negotiation and does not have any logic that handles PUT requests or the relevant validator headers (ETag, Last-Modified). Although there is a commented-out section mentioning etag and last modified fields, it is not active code and is not conditioned on checking whether the PUT request’s representation data was stored without transformation. Consequently, the function does not address the RFC requirement regarding validator fields in PUT responses, and no specific condition (C1) or action (A1) from the spec is implemented in this function.",success,
16499,fix_encoding,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function fix_encoding focuses on normalizing the content encoding based on the Accept-Encoding header by checking for a matching encoding (even with an 'x-' prefix) and adjusting the value accordingly. It does not implement any logic related to the RFC requirement that prohibits generating or appending multiple header field lines with the same name or preserving the order of such header fields. There is no code in the function that checks for duplicate header field lines or handles the concatenation of multiple values as required by the RFC. Therefore, no labeled conditions (e.g., C1) or actions (e.g., A1) from the spec constraints are fully implemented within this function.",success,
16499,fix_encoding,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Fully Matches,"[{'C1': {'code': ""if (enc[0] == 'x' && enc[1] == '-') {\n    enc += 2;\n}"", 'explanation': ""This segment checks for an invalid construct using the 'x-' prefix in the content encoding and recovers by skipping the prefix, which aligns with the RFC's allowance for recovery.""}}, {'A1': {'code': ""for (i = 0; i < accept_encodings->nelts; ++i) {\n    char *name = accept_recs[i].name;\n\n    if (!strcmp(name, enc)) {\n        r->content_encoding = name;\n        return OK;\n    }\n\n    if (name[0] == 'x' && name[1] == '-' && !strcmp(name+2, enc)) {\n        x_enc = name;\n    }\n}\n\nif (x_enc) {\n    r->content_encoding = x_enc;\n    return OK;\n}"", 'explanation': 'This loop iterates over the Accept-Encoding header values to match and update the content encoding accordingly. It demonstrates the action of using available protocol information to recover a usable encoding, thus implementing the recovery mechanism outlined in the RFC.'}}]","The function 'fix_encoding' explicitly attempts to recover from an invalid content encoding construct by detecting a deprecated 'x-' prefix and then seeking an accept-compatible encoding value from the client's Accept-Encoding header. This behavior implements the RFC's directive that a recipient MAY attempt to recover a usable protocol element from an invalid construct, and hence the function fully matches the intended constraints.",success,
16499,fix_encoding,A recipient MAY employ such workarounds while remaining conformant to this protocol if the workarounds are limited to the implementations at fault.,216,Partially Matches,"[{'C1': {'code': ""if (enc[0] == 'x' && enc[1] == '-') {\n    enc += 2;\n}"", 'explanation': ""This segment implements a workaround by stripping the 'x-' prefix from the content_encoding if present. It addresses the condition that a recipient may need to adjust legacy or buggy naming (i.e., with a vendor prefix) when comparing encodings.""}}, {'A1': {'code': ""for (i = 0; i < accept_encodings->nelts; ++i) {\n    char *name = accept_recs[i].name;\n\n    if (!strcmp(name, enc)) {\n        r->content_encoding = name;\n        return OK;\n    }\n\n    if (name[0] == 'x' && name[1] == '-' && !strcmp(name+2, enc)) {\n        x_enc = name;\n    }\n}\n\nif (x_enc) {\n    r->content_encoding = x_enc;\n    return OK;\n}"", 'explanation': ""This loop checks the Accept-Encoding header values to find a matching encoding, directly attempting the workaround for variant representations (with or without the 'x-' prefix). It embodies the implementation of an action that adjusts the protocol handling by selecting the appropriate encoding value when a match (or workaround match) is found.""}}]","The provided function 'fix_encoding' partially implements the RFC specification regarding workarounds. It contains logic to strip the 'x-' prefix from the encoding value and then compare it against the Accept-Encoding header values in order to select an appropriate encoding. This behavior reflects the RFC's notion that a recipient MAY employ workarounds limited to the faulty implementation. However, the function handles only the specific case of the 'x-' prefix workaround, and does not address the broader range of possible issues or conditions implied by full conformance to the HTTP messaging syntax and semantic requirements. Therefore, while some of the labeled constraints (C1 and A1) are met by this function, it does not fully cover all aspects detailed in the complete RFC specification.",success,
16507,escape_backref,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'escape_backref' is purely concerned with escaping characters in a given string based on provided flags and character sets. It does not contain any logic that relates to or enforces the HTTP RFC requirement that a sender must not generate protocol elements or syntax alternatives that are reserved for other roles. There is no code in the function that performs role validation, message context checking, or syntactic enforcement according to the ABNF grammar of HTTP. Therefore, the function does not visibly address any of the labeled conditions or actions specified in the RFC.",success,
16510,reduce_uri,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Partially Matches,"[{'C1': {'code': ""if (   strlen(r->filename) > l+3\n        && ap_cstr_casecmpn(r->filename, cp, l) == 0\n        && r->filename[l]   == ':'\n        && r->filename[l+1] == '/'\n        && r->filename[l+2] == '/' ) { ... }"", 'explanation': ""This block checks that the filename begins with the HTTP scheme and the expected '://' sequence, which is the first step in recognizing an absolute URI that may be normalized.""}}, {'A1': {'code': 'if (ap_matches_request_vhost(r, host, port)) {\n    ...\n    r->filename = apr_pstrdup(r->pool, url);\n    ...\n}', 'explanation': 'This segment performs the normalization by reducing the absolute URI to a local path if the host and port match those of the request, implementing the transformation action as specified.'}}]","The function inspects the HTTP URI by verifying its scheme and then extracts the host and port components. If these match the local request (using ap_matches_request_vhost), it rewrites the URI to a relative path. This logic implements a form of URI normalization as per the spec. However, since it only handles this particular normalization case (i.e. reducing an absolute URI to a local path when matching the local host and port) and does not address other normalization methods that might be covered by the full RFC, the implementation is only a partial match to the overall spec constraints.",success,
16510,reduce_uri,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'else if (*cp == \'/\') { /* default port */\n    *cp = \'\\0\';\n\n    port = ap_default_port(r);\n    url = r->filename + (cp - scratch);\n}\nelse {\n    port = ap_default_port(r);\n    url = ""/"";\n}', 'explanation': 'When no explicit port is provided in the URI, the function determines the port using ap_default_port. This directly implements the RFC requirement that a missing port may be interpreted as the default port for the protocol.'}}]","The function 'reduce_uri' inspects the URI to detect if a port is given. In the absence of an explicit port (when encountering a '/' immediately after the hostname or if no further path exists), it assigns the default port by calling ap_default_port. This behavior matches the provided RFC specification that if a port is not provided, the recipient may treat the request as having been received on the default port for the protocol.",success,
16511,fully_qualify_uri,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'else if (!is_absolute_uri(r->filename, NULL)) {\n    ...\n    r->filename = apr_psprintf(r->pool, ""%s://%s%s%s%s"",\n                               ap_http_scheme(r), thisserver, thisport,\n                               (*r->filename == \'/\') ? """" : ""/"",\n                               r->filename);\n}', 'explanation': 'This segment detects non‐absolute URIs and reconstructs them into an absolute URI, which is an effort towards generating protocol elements that are conformant. However, the code assumes that the formatted URI meets the ABNF grammar without explicitly validating it against the ABNF rules.'}}]","The function attempts to ensure that relative URIs are converted into fully qualified absolute URIs by prepending the appropriate scheme, server name, port, and a potential slash. This is in line with the intent of the RFC requirement that protocol elements are generated according to the proper grammar. However, the function does not perform any explicit validation to ensure that the resulting URI string fully complies with the ABNF-defined grammar. As a result, while it partially addresses the need to only generate well‐formed protocol elements, it does not completely enforce the RFC's specification.",success,
16511,fully_qualify_uri,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (r->method_number == M_CONNECT) {\n    return;\n}', 'explanation': 'This code segment ensures that if the request method is CONNECT—which is not meant to have its URI fully qualified—the function returns immediately. This aligns with the RFC requirement that a sender must not generate protocol elements inappropriate for the message role. However, no other explicit checks or generation restrictions are performed regarding protocol elements or syntax alternatives.'}}]","The function checks for the CONNECT method and avoids modifying the URI in that case, which partially satisfies the RFC’s requirement to prevent the generation of protocol elements by roles that should not generate them. The remainder of the function simply transforms a relative URI into an absolute one without further verification against ABNF grammar or role-based constraints. Therefore, while it includes logic addressing one aspect of the spec (C1), it does not fully implement all aspects implied by the RFC requirement.",success,
16511,fully_qualify_uri,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'thisport = ap_is_default_port(port, r) ? """" : apr_psprintf(r->pool, "":%u"", port);', 'explanation': 'This code checks if the port is the default port; if so, it produces an empty string (i.e., no explicit port), which aligns with the RFC stating that if a port is not provided, the recipient may interpret it as the default port.'}}]","The function fully_qualify_uri directly addresses the RFC requirement by checking whether the server port is the default. If it is, no port is appended to the URI, effectively implying the use of the default port. This implementation is entirely contained within the function itself and meets the specification's labeled constraint.",success,
16511,fully_qualify_uri,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Does Not Match,[],"The RFC specifies that a sender must not generate an 'http' URI with an empty host identifier. In the function, the host value is obtained via ap_get_server_name_for_url(r) and then used to construct the URI without any explicit check to ensure the host is non-empty. While the function does compose the URI, it does not show any logic to ensure that the host identifier is not empty; thus, it does not implement the specified constraint within its own logic.",success,
16511,fully_qualify_uri,"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",225,Does Not Match,[],"The RFC spec requires that a sender MUST NOT generate an ""https"" URI with an empty host identifier. The code in function_body constructs an absolute URI by concatenating the scheme, server name, port (if not default), and the requested filename. However, it does not perform any explicit check to ensure that the host identifier (obtained via ap_get_server_name_for_url(r)) is non-empty. There is no logic within the function to prevent generating a URI with an empty host. Therefore, based solely on the logic within function_body, the constraint is not met.",success,
16520,rewrite_mapfunc_escape,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Does Not Match,[],"The provided function only calls ap_escape_uri to escape the URI and does not implement any URI normalization logic as described in the specification. There is no evidence within the function that it performs any normalization or checks equivalent URIs, so it does not visibly address any of the labeled constraints.",success,
16521,rewrite_mapfunc_unescape,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Partially Matches,[],"The RFC specification requires that two HTTP URIs that are equivalent after normalization identify the same resource, implying that HTTP components may perform normalization. The provided function calls ap_unescape_url(key) to unescape the URL, which is a step towards normalization. However, normalization generally involves more than just unescaping (e.g., case normalization, percent-encoding normalization, etc.), and this function does not implement any additional normalization logic. Therefore, while it addresses part of the RFC’s normalization requirement (possibly corresponding to a condition like C1 if we use that label for URL unescaping), it does not fully implement the entire range of normalization steps implied by the specification. Since only logic internal to this function is considered and it only partially performs normalization, the overall judgment is that it partially matches the RFC requirements.",success,
16529,lookup_map_program,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': ""if (fpin == NULL || fpout == NULL || ap_strchr(key, '\\n')) {\n    return NULL;\n}"", 'explanation': 'This check prevents newline characters in the key, which helps avoid sending unexpected protocol elements (such as additional newlines) that should only be generated by other roles. This aligns partially with the RFC requirement that a sender must not generate syntax elements reserved for a different role.'}}]","The function includes a check (using ap_strchr on key for '\n') that prevents newline characters from being present in the input key, which is a safeguard against generating improper protocol elements. However, beyond this safeguard, the function does not explicitly verify or enforce role-based constraints or any further syntax conformity as outlined in the RFC specification. As such, while it partially addresses the requirement by ensuring certain protocol elements are not generated from unchecked input, it does not fully implement all aspects of the RFC requirement regarding sender roles.",success,
16529,lookup_map_program,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': ""if (fpin == NULL || fpout == NULL || ap_strchr(key, '\\n')) {\n    return NULL;\n}"", 'explanation': 'This check disallows newline characters within the key, which helps enforce that generated protocol elements conform to the expected grammar (i.e. they do not contain unexpected newline characters that could break the protocol’s ABNF). This is a partial implementation of the RFC requirement.'}}]","The RFC states that a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. In this function, there is logic (the check for newline characters in the key) that prevents one type of invalid input from being sent. However, the function only checks for newline characters and does not implement a full grammar validation as prescribed by the RFC. Thus, while it does show attention to preventing a form of protocol violation, it only partially meets the specification requirement.",success,
16529,lookup_map_program,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Does Not Match,[],"The provided function does not visibly address the RFC requirement that 'A sender MUST NOT generate a bare CR'. While it does check for newline characters (by returning NULL if the key contains '\n'), it does not inspect or filter out a carriage return ('\r'). There is no logic within the function to ensure that a CR is immediately followed by LF or to prevent a bare CR from being generated. Therefore, based solely on the implementation in this function, it does not meet the specified constraint.",success,
16530,lookup_map,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided function implements a caching mechanism for rewrite maps by retrieving and storing values in a cache; however, it does not contain any logic that checks or enforces the RFC requirement that a cache cannot be used when acting as a tunnel. There is no condition or branch in the function that determines whether the client or server is acting as a tunnel and disables caching accordingly. Therefore, while caching is implemented, the specific spec constraint from the RFC about tunneling is not addressed in this function.",success,
16531,lookup_header,"In any production that uses the list construct, a sender MUST NOT generate empty list elements.",236,Does Not Match,[],"The provided code function does not implement any logic to prevent the generation of empty list elements as required by the specification. While it does construct a comma-delimited list by concatenating header names, it does not validate that the elements inserted into the list are non-empty. There is no check within the function to ensure that empty strings are not being added to the list construct. Therefore, the function does not visibly address the spec constraint that a sender MUST NOT generate empty list elements.",success,
16538,add_cookie,"When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.",245,Partially Matches,"[{'A1': {'code': 'if (expires) {\n    apr_time_exp_t tms;\n    long exp_min;\n\n    exp_min = atol(expires);\n    if (exp_min) {\n        apr_time_exp_gmt(&tms, r->request_time + apr_time_from_sec((60 * exp_min)));\n        exp_time = apr_psprintf(r->pool, ""%s, %.2d-%s-%.4d %.2d:%.2d:%.2d GMT"",\n                               apr_day_snames[tms.tm_wday],\n                               tms.tm_mday,\n                               apr_month_snames[tms.tm_mon],\n                               tms.tm_year+1900,\n                               tms.tm_hour, tms.tm_min, tms.tm_sec);\n    }\n}', 'explanation': 'The function computes a GMT timestamp for the cookie\'s expires attribute and formats it into a date string. This logic attempts to address the requirement to generate HTTP-date timestamps in a GMT-based format. However, the formatting string uses \'-\' as the separator between day, month, and year (e.g., ""Wed, 09-Jun-2021 ..."") instead of the space-separated format required by the IMF-fixdate specification (e.g., ""Wed, 09 Jun 2021 ..."").'}}]","The RFC specification requires that HTTP-date timestamps be generated in the IMF-fixdate format. The code in the function 'add_cookie' does attempt to generate a GMT timestamp (which is part of the requirement) by computing an expiration time and formatting a string for the 'expires' attribute. However, the format string used in the function produces a date that does not fully conform to the IMF-fixdate standard because it uses dashes instead of spaces between the day, month, and year. Thus, while the function shows intent to implement the necessary behavior, it only partially matches the specification.",success,
16540,expand_tildepaths,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Partially Matches,"[{'C1': {'code': ""if (uri && *uri == '/' && uri[1] == '~') { ... }"", 'explanation': ""This check identifies URIs that begin with '/~', thus recognizing the need for normalization of tilde paths as suggested by the spec. It reflects an intention to treat such URIs specially.""}}, {'A1': {'code': 'user = apr_pstrmemdup(r->pool, user, p-user);\nif (apr_uid_homepath_get(&homedir, user, r->pool) == APR_SUCCESS) { ... }', 'explanation': 'This segment extracts the username from the URI and attempts to retrieve the corresponding home directory, effectively converting the tilde notation to an absolute path.'}}, {'A2': {'code': ""if (*p) {\n    user = homedir + strlen(homedir) - 1;\n    if (user >= homedir && *user == '/') {\n        *user = '\\0';\n    }\n    return apr_pstrcat(r->pool, homedir, p, NULL);\n} else {\n    return homedir;\n}"", 'explanation': 'This block completes the normalization by concatenating the expanded home directory with the remainder of the URI, returning a normalized path. It mirrors the idea that after normalization, equivalent URIs should resolve consistently.'}}]","The provided function implements a tilde-path expansion by detecting URIs that start with '/~', extracting the user portion, retrieving the corresponding home directory, and concatenating it with the rest of the URI. This is an attempt at normalization as mentioned in the RFC specification, ensuring that a URI with a tilde notation is expanded to a more canonical form. However, the function only handles this specific case and does not perform comprehensive normalization for all HTTP URIs. Therefore, while it addresses a component of the normalization requirement (i.e. tilde expansion), it only partially matches the overall spec which anticipates broader URI normalization.",success,
16564,init_child,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided function_body does not contain any logic that directly addresses the RFC specification concerning the use of a cache and its restriction during tunnel operation. The spec requires that any implementer may employ a cache (for storing previous response messages) but must not do so if acting as a tunnel. The examined code, which initializes a global mutex and attempts to initialize a lookup cache via init_cache(p), belongs to mod_rewrite's initialization routines and does not make any checks or implement any logic to decide whether caching should be enabled or disabled based on tunnel mode. Therefore, none of the spec constraints (labeled conditions or actions such as C1 or A1) are explicitly implemented in this function's code.",success,
16565,hook_uri2file,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,155,Partially Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Location"", r->filename);', 'explanation': 'In the block handling absolute (remote) URIs (when skip_absolute > 0), the code sets the Location header in the outgoing response. This demonstrates an attempt to implement the RFC requirement of generating a Location header with the new URI.'}}]","The provided function contains logic that sets a Location header (as shown by the call to apr_table_setn with ""Location"") when a rewrite leads to an external URI. However, the code does not explicitly enforce that the new URI be permanent (i.e. use a 301 status code) in all cases; if the status is not already a redirection, it defaults to HTTP_MOVED_TEMPORARILY (302). Thus, while the function visibly addresses the action of generating a Location header (A1), it only partially matches the RFC specification regarding the permanent redirection behavior required by the RFC.",success,
16565,hook_uri2file,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'A1': {'code': '...\nif (skip_absolute > 0) {\n    ...\n    apr_table_setn(r->headers_out, ""Location"", r->filename);\n    rewritelog(r, 1, NULL, ""redirect to %s [REDIRECT/%d]"", r->filename, n);\n    return n;\n}\n...', 'explanation': ""This code segment inspects the rewritten URL and, when it is an absolute URI (indicating a redirection), it sets the 'Location' header field in the response to the new URI. This directly addresses the RFC requirement that the server SHOULD generate a Location header with the different URI.""}}]","The function contains explicit logic for redirection: when the rewritten filename is recognized as an absolute URI, it escapes the URL as needed, determines the appropriate HTTP response status, and sets the 'Location' header using apr_table_setn. This directly implements the RFC specification to generate a Location header field containing the new URI, hence fully matching the constraint.",success,
16565,hook_uri2file,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'if (skip_absolute > 0) {\n    ...\n    apr_table_setn(r->headers_out, ""Location"", r->filename);\n    rewritelog(r, 1, NULL, ""redirect to %s [REDIRECT/%d]"", r->filename, n);\n    return n;\n}', 'explanation': ""This segment explicitly sets the 'Location' header in the response (using apr_table_setn on r->headers_out with the new URI) when a redirection is triggered. This directly implements the action specified in the RFC requirement that the server SHOULD generate a Location header field with the new URI.""}}]","The function contains logic that, upon determining that the rewritten filename represents an absolute URI (skip_absolute > 0), constructs the redirect URI (including handling query string encoding) and calls apr_table_setn to set the 'Location' header. This directly addresses the RFC requirement about generating a Location header field, meaning that the code function fully matches the specified action constraint.",success,
16565,hook_uri2file,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,160,Partially Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Location"", r->filename);', 'explanation': ""In the branch where the rewritten URI is determined to be a remote URL (i.e. when 'skip_absolute > 0'), the function sets the Location header in the response. This action addresses the requirement of generating a Location header field.""}}]","The RFC specification requires that the server generate a Location header field containing a preferred URI reference for the new permanent URI. In the provided function, when the rewriting process produces an absolute URI (as indicated by 'skip_absolute > 0'), a Location header is set (see 'apr_table_setn(r->headers_out, ""Location"", r->filename);'). This shows an attempt to implement the header generation requirement. However, the code defaults to using HTTP_MOVED_TEMPORARILY (or another non-308 status) rather than specifically handling a Permanent Redirect (308) scenario with a 'new permanent URI'. Therefore, while the function does generate a Location header in some cases, it does not completely fulfill the intent of the RFC to suggest the new permanent URI via a 308 status code. As a result, the implementation only partially matches the specification.",success,
16566,hook_fixup,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,155,Partially Matches,"[{'A1': {'code': '/* now prepare the redirect... */\n...\n/* now do the redirection */\napr_table_setn(r->headers_out, ""Location"", r->filename);\nrewritelog(r, 1, dconf->directory, ""redirect to %s [REDIRECT/%d]"", r->filename, n);', 'explanation': ""This segment generates a redirection by setting the 'Location' header with the rewritten URI, which complies with the RFC requirement to include a preferred URI reference in the response. However, the code may default to using a temporary redirect status (HTTP_MOVED_TEMPORARILY) rather than a permanent one (301), so while it addresses the header generation, it does not fully meet the expected permanent redirect behavior.""}}]","The function contains logic that sets the 'Location' header for redirection responses, thereby partially satisfying the RFC specification that requires the server to generate a Location header containing a preferred URI reference for the new permanent URI. However, the function chooses the redirect status code based on existing conditions and defaults to HTTP_MOVED_TEMPORARILY (302) instead of ensuring a 301 (permanent redirect) code. This lack of enforcement of a permanent redirect status means the implementation only partially matches the overall spec requirement.",success,
16566,hook_fixup,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Location"", r->filename);', 'explanation': ""This line sets the 'Location' header in the response with the rewritten URI, fulfilling the RFC requirement that a Location header field containing a URI reference for the different URI is generated.""}}]","Within the redirection branch (when the rewritten URI is external), the function constructs the new URI (including handling query strings and escaping) and then explicitly calls apr_table_setn to set the 'Location' header in the response. This directly addresses the HTTP RFC requirement described in the spec.",success,
16566,hook_fixup,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Location"", r->filename);', 'explanation': 'In the branch where the rewritten URL is external (i.e. when skip_absolute > 0 is true), the code sets the Location header field to r->filename. This explicitly implements the RFC specification action of generating a Location header field containing a URI reference.'}}]","The function contains logic that, when an external redirection is determined, sets the Location header (using apr_table_setn) with the rewritten URI before returning the appropriate redirect response code. This addresses the RFC requirement that the server SHOULD generate a Location header field in the response.",success,
16566,hook_fixup,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,160,Partially Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Location"", r->filename);', 'explanation': ""This code segment in the external redirect branch (when skip_absolute > 0) sets the Location header in the response using the preferred URI (r->filename), which addresses the RFC requirement to send a Location header. However, the code does not explicitly ensure a 308 (Permanent Redirect) status code and may use other redirect codes (such as HTTP_MOVED_TEMPORARILY), meaning it only partially fulfills the spec's permanent redirect requirement.""}}]","The function hook_fixup contains logic to perform URL rewriting and in one branch (when the rewritten URL is an absolute URI) it sets a Location header field via apr_table_setn(r->headers_out, ""Location"", r->filename). This addresses the action of generating a Location header as required by the spec. However, it does not specifically implement a 308 Permanent Redirect status code as described in the RFC specification context, instead defaulting to other redirect status codes. Hence, the implementation only partially matches the specification.",success,
16567,hook_mimetype,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,"[{'A1': {'code': 't = apr_table_get(r->notes, REWRITE_FORCED_MIMETYPE_NOTEVAR);\n    if (t && *t) {\n        rewritelog(r, 1, NULL, ""force filename %s to have MIME-type \'%s\'"", r->filename, t);\n        ap_set_content_type_ex(r, t, 1);\n    }', 'explanation': 'This segment sets the Content-Type header when a forced MIME type is available. It addresses the RFC requirement for generating a Content-Type header when content is present, but only in the case where the MIME type is forced via a note.'}}]","The RFC requires that a sender SHOULD generate a Content-Type header field when sending content, unless the intended media type is unknown. The provided function only sets the Content-Type header when a forced MIME type is explicitly provided in r->notes (via REWRITE_FORCED_MIMETYPE_NOTEVAR). This mechanism partially meets the requirement as it ensures the header is set in forced scenarios, but it does not cover all cases envisioned by the RFC (for instance, generating a default header when content is present without a forced MIME type). Therefore, the function only partially implements the RFC's requirement.",success,
16568,handler_redirect,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The provided function 'handler_redirect' does not address any of the specified RFC constraints regarding the handling of Content-Location context information. The RFC states that an origin server MUST NOT use such context information to alter request semantics, yet the code in this function only verifies if the request should be internally redirected based on a filename starting with 'redirect:' and performs the redirect without any handling or even mentioning of Content-Location headers. Therefore, no part within the target code function implements the constraints (e.g., C1, A1) in the specification.",success,
16581,imap_reply,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function does not contain any logic that validates or enforces the ABNF grammar required by the spec. Although it attempts to generate HTTP protocol elements by returning specific status codes and setting headers, it does not check whether the 'redirect' string or the generated protocol elements match the grammar defined by the corresponding ABNF rules. Therefore, the function does not visibly address the specified condition, and no labeled constraints (e.g., C1 or A1) are fully implemented based solely on the logic within this function.",success,
16581,imap_reply,A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content).,193,Does Not Match,[],"The provided function imap_reply only handles redirection and error responses by setting the Location header and returning specific HTTP status codes. It does not contain any logic related to checking or preventing the inclusion of a Transfer-Encoding header for responses with certain status codes (such as 1xx or 204) as specified by the RFC. Thus, none of the conditions or actions (e.g., C1, A1) related to the Transfer-Encoding header constraint from the spec are implemented within this function.",success,
16581,imap_reply,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Does Not Match,[],"The function does not explicitly handle the omission of the Content-Length header when returning a 1xx or 204 status code as required by the specification. Although it returns HTTP_NO_CONTENT when 'nocontent' is passed, it does not contain any logic to remove or avoid setting the Content-Length header. Thus, none of the specified conditions or actions regarding the Content-Length header are visibly implemented within this function.",success,
16581,imap_reply,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function does not attempt to address the specified HTTP RFC requirement. The RFC mandates that a sender must not generate protocol elements or syntax alternatives reserved for other roles. However, the function 'imap_reply' only examines the 'redirect' parameter to decide on the HTTP response code (error, no content, or temporary redirection) and does not contain any logic that validates or restricts protocol elements based on the sender's role. There is no code that checks whether any generated protocol element might be reserved for a different role, hence the function does not visibly implement the spec constraint.",success,
16581,imap_reply,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Partially Matches,"[{'A1': {'code': 'if (redirect && *redirect) {\n    /* must be a URL, so redirect to it */\n    apr_table_setn(r->headers_out, ""Location"", redirect);\n    return HTTP_MOVED_TEMPORARILY;\n}', 'explanation': 'This block sets the Location header when a non-empty redirect is provided, which addresses the RFC requirement of generating a Location header field. However, instead of using the 307 (Temporary Redirect) status code mentioned in the RFC context, it returns HTTP_MOVED_TEMPORARILY (typically 302), so it does not fully implement the precise expected temporary redirect behavior.'}}]","The function attempts to implement the RFC by generating a Location header when a redirect URL is provided. While this satisfies the core action required by the RFC, the use of HTTP_MOVED_TEMPORARILY (302) in place of the 307 (Temporary Redirect) status code means that the implementation only partially matches the specified RFC constraints.",success,
16581,imap_reply,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'A1': {'code': 'if (redirect && *redirect) {\n    /* must be a URL, so redirect to it */\n    apr_table_setn(r->headers_out, ""Location"", redirect);\n    return HTTP_MOVED_TEMPORARILY;\n}', 'explanation': ""This code block checks if a valid redirect URL is provided, sets the 'Location' header to that URL, and returns a 302 status code (HTTP_MOVED_TEMPORARILY), which directly implements the RFC requirement that the server SHOULD generate a Location header containing a URI reference for the temporary redirection.""}}]","The function directly addresses the key RFC specification by verifying a provided redirect URL and, if present, setting the Location header field with that URL and returning the appropriate 302 (Found) status code. This clearly fulfills the action requirement (labeled as A1) stated in the spec, hence the outcome is 'Fully Matches'.",success,
16582,menu_header,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,"[{'A1': {'code': 'ap_set_content_type_ex(r, ""text/html; charset=ISO-8859-1"", 1);', 'explanation': 'The function explicitly sets a Content-Type header using ap_set_content_type_ex, which aligns with the RFC’s recommendation that messages containing content SHOULD have a Content-Type header. However, it always sets the header (without conditionally checking if the media type is unknown) and uses a charset (ISO-8859-1) that differs from the RFC context example (ISO-8859-4), leading to only partial compliance.'}}]","The provided function 'menu_header' includes a call to set the Content-Type header, fulfilling the core requirement of the RFC that a message containing content should have a Content-Type header. However, because it does not check whether the intended media type is unknown (as per the 'unless' clause) and because the charset used differs from the one shown in the RFC context, the code only partially matches the RFC specification.",success,
16583,menu_blank,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Does Not Match,[],"The RFC specifies that a sender must not generate a bare CR (a CR not immediately followed by LF) in protocol elements. The function in question does not include any logic to check for or prevent bare CR characters. It simply outputs fixed strings (either ""\n"" or ""<br />\n"") without actively ensuring that a CR is not output or that it is paired with an LF. Therefore, the function does not visibly address the RFC constraint within its own code.",success,
16585,menu_default,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'ehref = ap_escape_uri(r->pool, href);\netext = ap_escape_html(r->pool, text);', 'explanation': ""These lines attempt to safeguard the output by escaping the 'href' and 'text' strings so that any characters that could cause the generated protocol elements (in this case, HTML fragments) to fall outside expected syntactic form are handled. This is an effort to ensure the output conforms to expected grammar, addressing the RFC's requirement that a sender must not generate protocol elements that do not match the ABNF grammar.""}}]","The function uses ap_escape_uri and ap_escape_html to sanitize input values and thereby reduce the risk of generating invalid protocol elements. This demonstrates an attempt to enforce components of the ABNF by properly escaping values. However, it does not explicitly validate the entire output against a complete ABNF grammar nor does it handle every potential conformance issue expected by the RFC, so it only partially meets the specified constraint.",success,
16585,menu_default,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specifies that within a given message, a sender MUST NOT include syntax or protocol elements that are not allowed for its role. The provided function only checks for specific href values (""error"" and ""nocontent"") and filters them out but does not implement any logic that verifies or enforces role-based generation of protocol elements. It does not check or enforce that elements are only generated by participants with the appropriate role in the message, so it does not visibly address the labeled condition (e.g., C1) or any similar action (e.g., A1) as required by the RFC specification.",success,
16586,menu_directive,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (!strcasecmp(href, ""error"") || !strcasecmp(href, ""nocontent"")) {\n    return;                 /* don\'t print such lines, as this isn\'t\n                               really an href */\n}', 'explanation': 'This check prevents the function from outputting hrefs with values ""error"" or ""nocontent"", thereby avoiding the generation of protocol elements that are not allowed for this sender role.'}}]","The provided function partially implements the specified RFC requirement by explicitly filtering out href values that are considered reserved for other roles. However, aside from this specific check, the function does not address other aspects of protocol element generation or enforce role-based constraints comprehensively. Only the logic to avoid generating certain elements is present, which is why the outcome is 'Partially Matches'.",success,
16586,menu_directive,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (!strcasecmp(href, ""error"") || !strcasecmp(href, ""nocontent"")) {\n    return;\n}\n\nehref = ap_escape_uri(r->pool, href);\netext = ap_escape_html(r->pool, text);', 'explanation': 'This segment prevents outputting certain href values and escapes both href and text via ap_escape_uri and ap_escape_html, which helps ensure that the generated protocol elements conform to their expected syntactic (ABNF) format. However, the function relies on these utility functions rather than directly validating against the ABNF grammar.'}}]","The function shows an attempt to prevent non-conforming output by filtering unwanted href values and escaping user-supplied data before generating the protocol output. This approach partially addresses the RFC requirement that a sender must not generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. Nonetheless, because it does not incorporate direct validation against the ABNF in its own logic and depends on external utility functions for escaping, the implementation only partially meets the specification.",success,
16594,translate_userdir,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'A1': {'code': 'if (prefix) {\n#ifdef HAVE_DRIVE_LETTERS\n    if (strchr(prefix + 2, \':\'))\n#else\n    if (strchr(prefix, \':\') && !is_absolute)\n#endif /* HAVE_DRIVE_LETTERS */\n    {\n        redirect = apr_pstrcat(r->pool, prefix, user, userdir, dname, NULL);\n        apr_table_setn(r->headers_out, ""Location"", redirect);\n        return HTTP_MOVED_TEMPORARILY;\n    }\n    ...\n}\n\nelse if (prefix && ap_strchr_c(prefix, \':\')) {\n    redirect = apr_pstrcat(r->pool, prefix, user, dname, NULL);\n    apr_table_setn(r->headers_out, ""Location"", redirect);\n    return HTTP_MOVED_TEMPORARILY;\n}', 'explanation': ""These code segments generate a redirect URI and explicitly set the 'Location' header field with it before returning an HTTP_MOVED_TEMPORARILY status. This directly implements the RFC requirement that the server SHOULD include a Location header for a temporary redirect.""}}]","The function 'translate_userdir' clearly includes logic to construct and set a Location header for redirections. When certain conditions (such as specific patterns in the userdir configuration) are met, it builds a URI reference, sets it in the 'Location' header, and returns a redirection status (HTTP_MOVED_TEMPORARILY). This behavior fulfills the RFC specification requiring that a Location header be generated with the appropriate URI, and thus the function fully matches the specified RFC requirement.",success,
16594,translate_userdir,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'redirect = apr_pstrcat(r->pool, prefix, user, userdir, dname, NULL);\napr_table_setn(r->headers_out, ""Location"", redirect);\nreturn HTTP_MOVED_TEMPORARILY;\n\n... \n\nelse if (prefix && ap_strchr_c(prefix, \':\')) {\n    redirect = apr_pstrcat(r->pool, prefix, user, dname, NULL);\n    apr_table_setn(r->headers_out, ""Location"", redirect);\n    return HTTP_MOVED_TEMPORARILY;\n}', 'explanation': ""In two distinct branches, the function constructs a redirect URI (using apr_pstrcat) and then sets the 'Location' header field in the response (using apr_table_setn) before returning a redirect status code. This visibly implements the specification requirement that the server SHOULD generate a Location header containing a URI reference for the different URI.""}}]","The function 'translate_userdir' directly implements the relevant HTTP RFC requirement by checking if the request URI matches a '~user' pattern and, when appropriate, constructing a redirect URI and setting it in the 'Location' header. This is done within the function itself (without relying on external dependencies) and aligns with the specified action requirement. Therefore, the function fully matches the provided spec constraint.",success,
16609,check_speling,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Partially Matches,"[{'A1': {'code': 'nuri = ap_escape_uri(r->pool, apr_pstrcat(r->pool, url, variant[0].name, r->path_info, NULL));\nif (r->parsed_uri.query)\n    nuri = apr_pstrcat(r->pool, nuri, ""?"", r->parsed_uri.query, NULL);\napr_table_setn(r->headers_out, ""Location"",\n                  ap_construct_url(r->pool, nuri, r));', 'explanation': 'When there is a unique, unambiguous candidate for a corrected URL, the function constructs the new URL and sets it in the Location header before returning a redirection response. This directly addresses the RFC requirement that the server SHOULD generate a Location header field containing a URI reference for the different (corrected) URI.'}}]","The function implements the specified RFC behavior in one branch: when a unique corrected resource is identified, it constructs a new URL and sets the 'Location' header field, fulfilling the RFC's requirement for redirection. However, in cases where there is ambiguity (multiple candidates), the function instead returns a Multiple Choices response with a list of candidate URLs and does not include a Location header. Because the RFC requirement is only fully met in the immediate redirection branch, the overall implementation is considered to partially match the specification.",success,
16609,check_speling,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,160,Partially Matches,"[{'A1': {'code': 'nuri = ap_escape_uri(r->pool, apr_pstrcat(r->pool, url,\n                                                     variant[0].name,\n                                                     r->path_info, NULL));\nif (r->parsed_uri.query)\n    nuri = apr_pstrcat(r->pool, nuri, ""?"", r->parsed_uri.query, NULL);\n\napr_table_setn(r->headers_out, ""Location"",\n                ap_construct_url(r->pool, nuri, r));', 'explanation': ""This segment constructs the new URI and sets the 'Location' header with it, thereby fulfilling the action of generating a preferred URI reference for redirection as specified.""}}]","The function attempts to implement the RFC requirement by constructing a corrected URL and setting it in the 'Location' header. This addresses the action of generating a preferred URI reference. However, the function returns HTTP_MOVED_PERMANENTLY (typically 301) instead of using the 308 status code described in the spec, and additional redirection handling is also present. Thus, while part of the specification is properly implemented (i.e. generating the Location header), not all aspects (such as the proper status code for a permanent redirect) are fully matched by this code function.",success,
16609,check_speling,"For request methods other than HEAD, the server SHOULD generate content in the 300 response containing a list of representation metadata and URI reference(s) from which the user or user agent can choose the one most preferred.",154,Fully Matches,"[{'A1': {'code': 'if (variant[0].quality != SP_VERYDIFFERENT\n    && (candidates->nelts == 1\n        || variant[0].quality != variant[1].quality)) {\n\n    nuri = ap_escape_uri(r->pool, apr_pstrcat(r->pool, url,\n                                             variant[0].name,\n                                             r->path_info, NULL));\n    if (r->parsed_uri.query)\n        nuri = apr_pstrcat(r->pool, nuri, ""?"", r->parsed_uri.query, NULL);\n\n    apr_table_setn(r->headers_out, ""Location"",\n                   ap_construct_url(r->pool, nuri, r));\n\n    ...\n\n    return HTTP_MOVED_PERMANENTLY;\n}', 'explanation': 'When a single, unambiguous candidate exists, the code constructs a fixed URL and sets it in the Location header, then returns a redirection response. This implements the action (A1) as per the RFC specification.'}}, {'C1': {'code': '...\n\nelse {\n    apr_pool_t *sub_pool;\n    ...\n    /* Generate the response text with list of candidates */\n    *(const char **)apr_array_push(t) = ""The document name you requested (<code>"";\n    *(const char **)apr_array_push(t) = ap_escape_html(sub_pool, r->uri);\n    ...\n    apr_table_setn(notes, ""variant-list"", apr_array_pstrcat(p, t, 0));\n\n    apr_table_mergen(r->subprocess_env, ""VARIANTS"",\n                      apr_array_pstrcat(p, v, \',\'));\n\n    ...\n\n    return HTTP_MULTIPLE_CHOICES;\n}', 'explanation': 'When multiple potential matches are found, the function builds an HTML listing of candidate URIs and associated metadata, assigns it to a header note and the VARIANTS field, and returns a 300 Multiple Choices response. This directly addresses condition (C1) from the RFC.'}}]","The function clearly distinguishes between a unique, preferred candidate and an ambiguous set of candidates. In the former case, it sets the Location header and returns an HTTP_MOVED_PERMANENTLY response, while in the latter it builds a candidate list and returns an HTTP_MULTIPLE_CHOICES response. Both behaviors match the RFC's specifications for non-HEAD requests, demonstrating that the function fully addresses the relevant conditions and actions within its scope.",success,
16609,check_speling,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,155,Fully Matches,"[{'A1': {'code': 'nuri = ap_escape_uri(r->pool, apr_pstrcat(r->pool, url, variant[0].name, r->path_info, NULL));\nif (r->parsed_uri.query)\n    nuri = apr_pstrcat(r->pool, nuri, ""?"", r->parsed_uri.query, NULL);\n\napr_table_setn(r->headers_out, ""Location"",\n                ap_construct_url(r->pool, nuri, r));\n\nreturn HTTP_MOVED_PERMANENTLY;', 'explanation': ""This code constructs the new preferred URI from the candidate file name, sets the 'Location' header in the response using ap_construct_url(), and returns the 301 status code. This directly implements the RFC requirement to generate a Location header with the new permanent URI.""}}]","The function 'check_speling' inspects the request and, when a unique and acceptable correction is found for a misspelling, constructs a new URI and sets the 'Location' header in the response. The presence of the 'apr_table_setn' call setting the 'Location' header along with returning HTTP_MOVED_PERMANENTLY demonstrates that the function fully addresses the RFC specification regarding redirection via a Location header.",success,
16609,check_speling,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'nuri = ap_escape_uri(r->pool, apr_pstrcat(r->pool, url, variant[0].name, r->path_info, NULL));\nif (r->parsed_uri.query)\n    nuri = apr_pstrcat(r->pool, nuri, ""?"", r->parsed_uri.query, NULL);\n\napr_table_setn(r->headers_out, ""Location"",\n                ap_construct_url(r->pool, nuri, r));', 'explanation': ""This code constructs the corrected URI for the misspelled request and sets the 'Location' header in the response. This directly implements the RFC requirement that the server SHOULD generate a Location header field with a URI reference.""}}]","The function 'check_speling' inspects a request for a potential misspelling, and when a likely candidate is found, it constructs a corrected URI and sets the 'Location' header accordingly. This fulfills the RFC specification requirement by generating a Location header field containing a URI reference to the target resource, and this logic is implemented entirely within the function itself.",success,
16618,fixup_dir,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'A1': {'code': 'if (r->uri[0] == \'\\0\' || r->uri[strlen(r->uri) - 1] != \'/\')\n{\n    ...\n    apr_table_setn(r->headers_out, ""Location"", ap_construct_url(r->pool, ifile, r));\n    return HTTP_MOVED_PERMANENTLY;\n}\n\n... \n\nif (ap_is_HTTP_REDIRECT(d->redirect_index)) {\n    apr_table_setn(r->headers_out, ""Location"", ap_construct_url(r->pool, rr->uri, r));\n    return d->redirect_index;\n}', 'explanation': ""The function implements the RFC requirement by checking if the request URI is not slash-terminated and then constructing a URI reference to which to redirect. It sets the 'Location' header field using apr_table_setn in the response. A similar approach is used for redirecting index requests. This logic fully addresses the action of generating a Location header as specified.""}}]","The provided function explicitly evaluates the request URI and, when it does not end with a '/', constructs a redirect URL and sets it in the Location header of the response. Additionally, during lookup for index files, if a redirect is indicated, it again sets the Location header. This behavior directly implements the RFC's guideline that the server SHOULD generate a Location header field in such redirection responses.",success,
16618,fixup_dir,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,160,Fully Matches,"[{'A1': {'code': 'if (r->uri[0] == \'\\0\' || r->uri[strlen(r->uri) - 1] != \'/\')\n{\n    ...\n    apr_table_setn(r->headers_out, ""Location"", ap_construct_url(r->pool, ifile, r));\n    return HTTP_MOVED_PERMANENTLY;\n}', 'explanation': ""This code block detects when the request URI is not terminated with a '/' and constructs a new URI (adding a trailing slash and appending query parameters if needed). It then explicitly sets the Location header using 'apr_table_setn' and returns a permanent redirect status code. This directly fulfills the RFC requirement that the server should respond with a Location header containing a preferred URI reference for the new permanent URI.""}}]","The function 'fixup_dir' visibly handles the RFC requirement by checking if the request URI lacks a trailing slash and, in that case, constructs a corrected URI. It then sets the 'Location' header appropriately and returns a permanent redirect response (HTTP_MOVED_PERMANENTLY). This logic is self-contained within the function and satisfies the specified RFC condition.",success,
16619,dir_fixups,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The RFC specification requires that an origin server MUST NOT use context information (such as that provided by Content-Location) to alter the request semantics. This function, however, is solely concerned with file type checks (serving directories via fixup_dir and using a fallback if the file does not exist) and does not contain any logic addressing or preventing alteration of request semantics using context information. Therefore, the code function does not visibly implement any of the spec constraints.",success,
16635,try_redirect,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that within a given message, a sender must not generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. In the provided function, there is no explicit logic checking or enforcing the sender's role or whether the generated redirect URI qualifies as a protocol element that the sender is not permitted to generate. The function simply evaluates a redirect expression based on configuration (dirconf->redirect_set and related fields) and constructs a redirect URI. There is no mechanism here to verify role-based restrictions as described in the RFC specification. Therefore, based solely on the code within function_body, the function does not visibly address the labeled constraint from the RFC.",success,
16637,translate_alias_redir,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function 'translate_alias_redir' does not incorporate any logic that addresses the HTTP RFC specification regarding multiple header field lines or the ordering of header fields. The RFC constraints (e.g., not generating multiple field lines with the same name unless allowed and preserving their received order) are not implemented in this function. The code simply sets a 'Location' header using apr_table_setn without any checks for duplicate or multiple header fields, and there is no logic to preserve header ordering. Therefore, the function does not meet any of the specified constraints within its own logic.",success,
16637,translate_alias_redir,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'if (ap_is_HTTP_REDIRECT(status)) {\n    ...\n    apr_table_setn(r->headers_out, ""Location"", ret);\n}', 'explanation': ""This segment checks if the status corresponds to an HTTP redirect and explicitly sets the 'Location' header field in the response with the new URI, thereby implementing the RFC requirement.""}}]","The function 'translate_alias_redir' inspects the requested URI and, if a redirection is applicable (as determined by try_redirect or try_alias_list), it checks that the status is a redirect (ap_is_HTTP_REDIRECT) and then sets the 'Location' header in the outgoing headers. This code directly addresses the specification that the server SHOULD generate a Location header field containing a URI reference for the different URI. Since the logic for generating the header is present and executed within this function, it fully matches the relevant spec action.",success,
16637,translate_alias_redir,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'A1': {'code': 'if (ap_is_HTTP_REDIRECT(status)) {\n    ...\n    /* append requested query only, if the config didn\'t supply its own. */\n    if (r->args && !ap_strchr(ret, \'?\')) {\n        ret = apr_pstrcat(r->pool, ret, ""?"", r->args, NULL);\n    }\n    apr_table_setn(r->headers_out, ""Location"", ret);\n}', 'explanation': 'When a redirection response is indicated by the status (via ap_is_HTTP_REDIRECT(status)), the function constructs and validates a target URI and then generates the Location header with that URI, which fulfills the spec requirement that the server should return a Location header field with a URI reference for the different URI.'}}]","The function directly implements the required behavior by checking if the response status indicates a redirect and then generating a Location header with the appropriate URI. This meets the specification requirement stated in the RFC, as the logic for constructing and setting the Location header is fully present within the function.",success,
16637,translate_alias_redir,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,155,Fully Matches,"[{'A1': {'code': 'if (ap_is_HTTP_REDIRECT(status)) {\n    ...\n    apr_table_setn(r->headers_out, ""Location"", ret);\n}', 'explanation': 'This segment checks if the status is a HTTP redirect (which includes 301) and then explicitly sets the Location header with the new URI, fulfilling the RFC requirement that a 301 response should include a Location header with a preferred URI reference.'}}]","The function translate_alias_redir verifies if a redirection is needed by checking the status with ap_is_HTTP_REDIRECT, modifies the target URI when needed (e.g., constructing an absolute URL), and then sets the Location header in the response. This directly addresses the RFC specification that the server SHOULD generate a Location header in a 301 (Moved Permanently) response, and therefore the code meets the required constraint.",success,
16637,translate_alias_redir,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,160,Partially Matches,"[{'C1': {'code': 'if (ap_is_HTTP_REDIRECT(status)) {\n    ...\n    apr_table_setn(r->headers_out, ""Location"", ret);', 'explanation': ""This code block checks if the returned status indicates an HTTP redirection and then sets the 'Location' header field, thereby attempting to provide a URI reference in the response as required by the RFC.""}}, {'A1': {'code': 'if (r->args && !ap_strchr(ret, \'?\')) {\n    ret = apr_pstrcat(r->pool, ret, ""?"", r->args, NULL);\n}', 'explanation': 'This snippet appends the query part from the original request to the generated redirect URI if the config has not already supplied a query component, ensuring that additional request details are preserved.'}}]","The function attempts to implement part of the RFC requirement by generating a Location header field when a redirection is needed. It ensures that a valid URI (potentially converted to an absolute URL) is set in the header and preserves the query string if absent. However, the function does not explicitly check for a 308 (Permanent Redirect) status code or exclusively enforce the permanent URI requirement, so while it addresses key aspects of the specification, it only partially meets the complete spec as written.",success,
16638,fixup_redir,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that within a given message a sender must not generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. The provided function fixup_redir primarily focuses on generating and validating redirection targets (ensuring they are valid absolute URLs or proper paths) and on setting the Location header. It does not contain any logic that checks whether the protocol elements being generated are exclusive to a different role than the sender’s. Although the function performs URL construction and validation in accordance with configured settings (such as allow_relative), there is no visible implementation within the function that enforces the RFC mandate regarding protocol element generation based on sender roles. Therefore, the function does not address the pertinent spec constraint.",success,
16638,fixup_redir,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,160,Fully Matches,"[{'A1': {'code': 'if (ap_is_HTTP_REDIRECT(status)) {\n    ...\n    apr_table_setn(r->headers_out, ""Location"", ret);\n}', 'explanation': 'This segment checks if the status indicates an HTTP redirection and then sets the Location header with the newly determined URI. This directly implements the RFC requirement that the server SHOULD generate a Location header containing the preferred URI reference.'}}, {'A2': {'code': 'if (r->args && !ap_strchr(ret, \'?\')) {\n    ret = apr_pstrcat(r->pool, ret, ""?"", r->args, NULL);\n}', 'explanation': 'This part of the code ensures that if the original request contained query parameters and the redirection target did not already include one, these are appended. This further refines the construction of the preferred URI reference.'}}]","The function fixup_redir implements the key aspects of the RFC specification by constructing an appropriate redirection URI and setting it in the Location header. It not only generates an absolute URI (using ap_construct_url when necessary) but also appends any query parameters that were present in the original request. This logic, contained solely within the function_body, satisfies the requirement that the server provide a Location header field with the preferred URI reference for permanent redirection.",success,
16638,fixup_redir,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'if (ap_is_HTTP_REDIRECT(status)) {\n    ...\n    apr_table_setn(r->headers_out, ""Location"", ret);\n}', 'explanation': ""This code block checks if the status indicates a redirection and then sets the 'Location' header field with the computed URI, which directly implements the RFC requirement that the server SHOULD generate a Location header containing a URI reference for the different URI.""}}]","The function fixup_redir directly addresses the RFC specification by determining when a redirection is to occur and constructing the URI appropriately -- including handling relative paths by converting them to absolute URLs if necessary -- and finally setting the 'Location' header in the response. This logic fulfills the spec constraint regarding the generation of the Location header field, and all necessary redirection handling is contained within this function itself.",success,
16638,fixup_redir,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'A1': {'code': 'if (ap_is_HTTP_REDIRECT(status)) {\n    ...\n    /* append requested query only, if the config didn\'t supply its own. */\n    if (r->args && !ap_strchr(ret, \'?\')) {\n        ret = apr_pstrcat(r->pool, ret, ""?"", r->args, NULL);\n    }\n    apr_table_setn(r->headers_out, ""Location"", ret);\n}', 'explanation': ""This segment checks for an HTTP redirect by evaluating the status and, once confirmed, constructs an absolute URI if necessary and appends any query string provided. It then sets the 'Location' header field in the response with the target URI, which directly addresses the RFC requirement for generating a Location header field.""}}]","The function fixup_redir inspects the redirection target returned by try_redirect or try_alias_list, performs necessary adjustments to ensure the target is a valid absolute URI (if needed), and finally populates the 'Location' header in the response. This behavior directly implements the specified action in the HTTP RFC, thereby ensuring that a correctly formatted Location header is provided in redirection cases. The logic within fixup_redir fully addresses the constraint.",success,
16638,fixup_redir,The server SHOULD generate a Location header field in the response containing a preferred URI reference for the new permanent URI.,155,Fully Matches,"[{'C1': {'code': 'if (ap_is_HTTP_REDIRECT(status)) {\n    ...\n    apr_table_setn(r->headers_out, ""Location"", ret);\n}', 'explanation': ""This code block checks if the status represents an HTTP redirection and then sets the 'Location' header field in the response with the computed URI, thereby directly implementing the RFC requirement that a Location header with the new permanent URI should be generated.""}}, {'A1': {'code': 'if (dirconf->allow_relative != ALIAS_FLAG_ON || ret[0] != \'/\') {\n    if (ret[0] == \'/\') {\n        char *orig_target = ret;\n        ret = ap_construct_url(r->pool, ret, r);\n        /* logs the conversion for transparency */\n    }\n    if (!ap_is_url(ret)) {\n         /* error logging and return */\n    }\n}\n\nif (r->args && !ap_strchr(ret, \'?\')) {\n    ret = apr_pstrcat(r->pool, ret, ""?"", r->args, NULL);\n}', 'explanation': 'This segment ensures that if the redirection target is a relative URI (or incomplete), it is converted to an absolute URI (via ap_construct_url) and that any query string not already included is appended. This directly supports the requirement to provide a preferred absolute URI reference in the Location header.'}}]","The function fixup_redir computes a redirection URI and conditionally sets the Location header accordingly when a 301 (Moved Permanently) redirection is indicated. It explicitly handles relative URIs by converting them to absolute URLs and appends any necessary query parameters, which meets the RFC specification's requirement that the server SHOULD generate a Location header field containing a preferred URI reference for the new permanent URI.",success,
16717,policy_type_out_filter,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'A1': {'code': 'if (fail) {\n    const char *types = NULL;\n    if (conf->type_matches) {\n        int i;\n        for (i = 0; i < conf->type_matches->nelts; i++) {\n            types = apr_pstrcat(f->r->pool, types ? "", "" : """",\n                    ((char **) conf->type_matches->elts)[i], NULL);\n        }\n    }\n    else {\n        types = POLICY_DEFAULT_TYPE;\n    }\n\n    handle_policy(\n            f->r,\n            result,\n            apr_psprintf(\n                    f->r->pool,\n                    ""Content-Type of \'%s\' should be RFC compliant and match one of: %s"",\n                    f->r->content_type, types), conf->type_url, bb, HTTP_BAD_GATEWAY);\n}', 'explanation': 'The function inspects the Content-Type header and, if it does not match the allowed types (as per configured policy), it triggers an error using handle_policy. This reflects an attempt to enforce that only protocol elements conformant to the RFC are generated by the sender. However, it does not explicitly check whether the generated elements are reserved for other roles.'}}]","The provided code function inspects the Content-Type header to determine if it complies with a set of allowed values, and when it does not, it calls handle_policy to reject the message. This behavior partially addresses the RFC requirement that a sender must not generate protocol elements (or syntax alternatives) that are not allowed for its role. However, the function does not make explicit checks regarding the sender's role versus allowed protocol elements, so while it enforces some RFC-related syntax constraints, it does not fully implement all aspects of the specification.",success,
16718,policy_length_out_filter,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Partially Matches,"[{'A1': {'code': 'if (!apr_table_get(r->headers_out, ""Content-Length"")) {\n    handle_policy(r, result, ""Content-Length should be present"", conf->length_url, bb, HTTP_BAD_GATEWAY);\n}', 'explanation': 'This segment checks that a Content-Length header is present for successful response messages (status 200-299 and not 204). By calling handle_policy with an error (HTTP_BAD_GATEWAY) when the header is missing, it attempts to enforce the RFC recommendation to generate length-delimited messages when possible. However, it does not check for Transfer-Encoding or cover other detailed conditions (e.g., handling invalid Content-Length values) present in the full spec context.'}}]","The function partially implements the RFC requirement by verifying that a Content-Length header is present for applicable responses and raising an error if it is missing. This aligns with the RFC's suggestion to use encoding or length-delimitation, but the function does not address several other conditions specified (such as considerations for Transfer-Encoding or multiple/invalid Content-Length values). Thus, while it addresses one aspect (A1) of the specification, it does not fully implement all the constraints.",success,
16718,policy_length_out_filter,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Does Not Match,[],"The RFC requires that a server MUST NOT send a Content-Length header for responses with status 1xx (Informational) or 204 (No Content). The function only performs a check when the response status is between 200 and 299, explicitly excluding 204, to ensure that a Content-Length header is present. It does not provide any logic to block or avoid sending a Content-Length header in responses with 1xx or 204 statuses. Therefore, within the function_body itself no spec constraint regarding forbidding the header in 1xx/204 responses is implemented.",success,
16718,policy_length_out_filter,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'C1': {'code': 'if (result != policy_ignore && r->status >= 200 && r->status < 300\n        && r->status != HTTP_NO_CONTENT) {', 'explanation': 'This check ensures that the policy applies only to responses with a status code in the 2xx range (excluding 204). It partly implements the RFC requirement not to include Content-Length for 1xx and 204 responses, although it does not check for CONNECT responses.'}}, {'A1': {'code': 'if (!apr_table_get(r->headers_out, ""Content-Length"")) {\n\n    handle_policy(r, result, ""Content-Length should be present"",\n            conf->length_url, bb, HTTP_BAD_GATEWAY);\n\n}', 'explanation': 'This segment enforces the action by verifying that if the Content-Length header is absent in eligible responses, an error is triggered. It addresses the required enforcement when the content size is known, assuming no Transfer-Encoding is present (although the function does not itself check for Transfer-Encoding).'}}]","The function attempts to enforce the RFC requirement by checking that responses with status codes from 200 to 299 (excluding 204) include a Content-Length header. This partially addresses the RFC constraints about when a Content-Length header should be present. However, it misses explicit checks for cases such as CONNECT requests or verifying the absence of Transfer-Encoding, which the RFC context also describes. Therefore, while some conditions and actions are implemented within this function, they do not fully cover all aspects of the RFC specification.",success,
16719,policy_keepalive_out_filter,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'if (result != policy_ignore && r->connection->keepalive != AP_CONN_CLOSE\n            && !r->expecting_100 && !ap_status_drops_connection(r->status)) {', 'explanation': 'This condition checks that the connection is not already marked to close and that the request state permits a persistent (keepalive) connection, thereby addressing the part of the RFC that mandates the server to sustain persistent connections when possible.'}}, {'A1': {'code': 'if (!(r->header_only\n                || AP_STATUS_IS_HEADER_ONLY(r->status)\n                || apr_table_get(r->headers_out, ""Content-Length"")\n                || ap_is_chunked(r->pool, apr_table_get(r->headers_out, ""Transfer-Encoding""))\n                || r->proto_num >= HTTP_VERSION(1, 1))) {\n\n            handle_policy(r, result, ""Keepalive should be possible (supply Content-Length or HTTP/1.1 Transfer-Encoding)"",\n                    conf->keepalive_url, bb, HTTP_BAD_GATEWAY);\n\n        }', 'explanation': 'This block ensures that if essential headers (like Content-Length or an appropriate Transfer-Encoding) are missing—conditions required for safely using persistent connections—the policy handling is invoked. This addresses part of the specification by enforcing necessary criteria for sustaining a keepalive connection.'}}]","The function contains checks to determine whether a connection can be kept alive by verifying conditions such as the connection’s status and the presence of essential headers. This meets part of the RFC requirement to sustain persistent connections. However, the RFC also calls for allowing underlying transport flow-control mechanisms to resolve temporary overloads instead of severing the connection, and this aspect is not addressed within the function. Thus, while the code does implement parts related to sustaining keepalive connections, it does not fully cover all aspects of the RFC specification.",success,
16719,policy_keepalive_out_filter,HTTP implementations SHOULD support persistent connections.,311,Partially Matches,"[{'C1': {'code': 'if (result != policy_ignore && r->connection->keepalive != AP_CONN_CLOSE && !r->expecting_100 && !ap_status_drops_connection(r->status)) { ... }', 'explanation': 'This check ensures the connection is eligible to remain persistent by verifying that it has not been set to close and other conditions that typically disable keepalive are not met. It reflects the spec’s requirement that persistent connections should be supported.'}}, {'A1': {'code': 'if (!(r->header_only || AP_STATUS_IS_HEADER_ONLY(r->status) || apr_table_get(r->headers_out, ""Content-Length"") || ap_is_chunked(r->pool, apr_table_get(r->headers_out, ""Transfer-Encoding"")) || r->proto_num >= HTTP_VERSION(1, 1))) { handle_policy(r, result, ""Keepalive should be possible (supply Content-Length or HTTP/1.1 Transfer-Encoding)"", conf->keepalive_url, bb, HTTP_BAD_GATEWAY); }', 'explanation': 'By validating that either the response is header only, has a Content-Length, or uses chunked transfer encoding (or that the protocol is HTTP/1.1 or higher, where persistent connections are the default), this segment enforces that conditions supporting persistent connections are satisfied.'}}]","The function contains logic to determine whether a response qualifies for a persistent connection. It checks that the connection is not explicitly closed and then verifies that the necessary criteria (such as proper headers or HTTP version) are met. While it does address key aspects of the spec regarding support for persistent connections, some other aspects may be handled elsewhere in the system. Thus, in isolation this function only partially implements the specification.",success,
16719,policy_keepalive_out_filter,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Partially Matches,"[{'A1': {'code': 'if (!(r->header_only\n                || AP_STATUS_IS_HEADER_ONLY(r->status)\n                || apr_table_get(r->headers_out, ""Content-Length"")\n                || ap_is_chunked(r->pool, apr_table_get(r->headers_out, ""Transfer-Encoding""))\n                || r->proto_num >= HTTP_VERSION(1, 1))) {\n\n            handle_policy(r, result, ""Keepalive should be possible (supply Content-Length or HTTP/1.1 Transfer-Encoding)"",\n                    conf->keepalive_url, bb, HTTP_BAD_GATEWAY);\n\n        }', 'explanation': ""This code segment enforces that a keepalive response must include an explicit Content-Length header or use a chunked (or HTTP/1.1 implicit) encoding. This is in line with the RFC's recommendation that servers should generate encoding or length-delimited messages whenever possible in order to reliably delineate message boundaries.""}}]","The function inspects the outgoing response to determine whether it provides the necessary framing information (via Content-Length or Transfer-Encoding) required for a reliable keepalive connection. By checking these conditions and invoking a policy handler when they are not met, the function partially implements the RFC's requirement. However, it does not cover all potential conditions (such as the detailed handling of invalid Content-Length header fields or close-delimited scenarios noted in the RFC), so the match is only partial.",success,
16721,policy_vary_out_filter,"In any production that uses the list construct, a sender MUST NOT generate empty list elements.",236,Does Not Match,[],"The provided function does not implement any logic to detect or prevent empty list elements in comma-delimited lists as required by the RFC specification. Although it constructs a Vary header by concatenating elements from the vary_matches collection, it does not check whether any of these elements are empty. All logic regarding list validation, if any, is not present within the body of this function. Therefore, the function does not address the condition that a sender MUST NOT generate empty list elements (e.g., C1).",success,
16722,policy_validation_out_filter,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (etag) {\n    int len = strlen(etag);\n    if (len > 1) {\n        if (etag[0] == \'""\' && etag[len - 1] == \'""\') {\n            fail = 0;\n        }\n        else if (etag[0] == \'W\' && etag[1] == \'/\' && etag[2] == \'""\' && etag[len - 1] == \'""\') {\n            fail = 0;\n        }\n    }\n    if (fail) {\n        etagfail = 1;\n    }\n}', 'explanation': 'This segment defensively parses the ETag header by verifying that it is properly delimited (either as a strong or weak ETag). This corresponds to a defensive check as expected in the RFC spec.'}}, {'C2': {'code': 'if (lastmodified) {\n    apr_time_t lastmod = apr_date_parse_http(lastmodified);\n    if (lastmod != APR_DATE_BAD) {\n        fail = 0;\n    }\n    if (fail) {\n        lmfail = 1;\n    }\n}', 'explanation': 'This segment applies defensive parsing to the Last-Modified header by using a date parser and validating the result, which is in line with the defensive parsing concept outlined by the spec.'}}, {'A1': {'code': 'if (fail) {\n    const char *error = NULL;\n    if (!etag && !lastmodified) {\n        error = apr_psprintf(f->r->pool, ""Etag and Last Modified missing"");\n    }\n    else {\n        error = apr_pstrcat(f->r->pool, \n                           (etagfail ? ""ETag syntax error (check quotes)"" : """"),\n                           (etagfail && lmfail ? "" / "" : """"),\n                           (lmfail ? ""Last-Modified could not be parsed"" : """"),\n                           NULL);\n    }\n\n    handle_policy(f->r, result, error, conf->validation_url, bb, HTTP_BAD_GATEWAY);\n}', 'explanation': 'Upon detecting failures in the parsing of protocol elements, this code constructs an appropriate error message and enforces a policy action, aligning with the need to act defensively when elements do not meet expectations.'}}]","The function implements defensive parsing for specific HTTP headers (ETag and Last-Modified) by checking their syntax and validity. If the headers do not conform, it triggers an error handling policy. This represents a partial implementation of the RFC's recommendation for defensive parsing, as it only addresses these two elements rather than adopting a broader defensive strategy for all protocol elements.",success,
16722,policy_validation_out_filter,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'C1': {'code': 'if (etag) {\n    int len = strlen(etag);\n    if (len > 1) {\n        if (etag[0] == \'""\' && etag[len - 1] == \'""\') {\n            fail = 0;\n        }\n        else if (etag[0] == \'W\' && etag[1] == \'/\' && etag[2] == \'""\' && etag[len - 1] == \'""\') {\n            fail = 0;\n        }\n    }\n    if (fail) {\n        etagfail = 1;\n    }\n}', 'explanation': 'This segment validates the syntax of the ETag header to ensure it is enclosed in quotes (or follows the weak validator format). It attempts to enforce the HTTP grammar rules for ETag though only for this header element.'}}, {'A1': {'code': 'if (lastmodified) {\n    apr_time_t lastmod = apr_date_parse_http(lastmodified);\n    if (lastmod != APR_DATE_BAD) {\n        fail = 0;\n    }\n    if (fail) {\n        lmfail = 1;\n    }\n}', 'explanation': 'This code segment uses the HTTP date parser to verify that the Last-Modified header conforms to the expected HTTP date format, which is in line with the syntax and semantic requirements.'}}]","The function partially implements the RFC requirement by validating certain header elements (ETag and Last-Modified) against the expected syntax as defined by HTTP grammar rules. However, it neither covers all possible protocol elements nor fully addresses the broader constraint of not generating protocol elements reserved for other roles. Thus, only some labeled conditions (here mapped to C1 and A1) are addressed within this function.",success,
16722,policy_validation_out_filter,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Fully Matches,"[{'C1': {'code': 'if (etag) {\n    int len = strlen(etag);\n    if (len > 1) {\n        if (etag[0] == \'""\' && etag[len - 1] == \'""\') {\n            fail = 0;\n        }\n        else if (etag[0] == \'W\' && etag[1] == \'/\' && etag[2] == \'""\' && etag[len - 1] == \'""\') {\n            fail = 0;\n        }\n    }\n    if (fail) {\n        etagfail = 1;\n    }\n}', 'explanation': 'Validates the ETag header by ensuring it is enclosed in quotes, accounting for both strong and weak validators, thereby enforcing conformity with the expected ABNF grammar.'}}, {'C2': {'code': 'if (lastmodified) {\n    apr_time_t lastmod = apr_date_parse_http(lastmodified);\n    if (lastmod != APR_DATE_BAD) {\n        fail = 0;\n    }\n    if (fail) {\n        lmfail = 1;\n    }\n}', 'explanation': 'Checks the Last-Modified header by parsing it with a standard HTTP date parser. A failure to parse indicates a deviation from the expected grammar.'}}, {'A1': {'code': 'if (fail) {\n    const char *error = NULL;\n    if (!etag && !lastmodified) {\n        error = apr_psprintf(f->r->pool, ""Etag and Last Modified missing"");\n    }\n    else {\n        error = apr_pstrcat(f->r->pool,\n            (etagfail ? ""ETag syntax error (check quotes)"" : """"),\n            (etagfail && lmfail ? "" / "" : """"),\n            (lmfail ? ""Last-Modified could not be parsed"" : """"),\n            NULL);\n    }\n\n    handle_policy(f->r, result, error, conf->validation_url, bb, HTTP_BAD_GATEWAY);\n}', 'explanation': 'When either header fails to meet the allowed format, an error message is generated and the handle_policy function is invoked to enforce the protocol policy, thus handling non-conformant elements.'}}]","The function directly validates protocol elements (specifically the 'ETag' and 'Last-Modified' headers) against expected ABNF rules. It checks for proper formatting—such as ensuring quotes surround ETag values and that Last-Modified values are correctly parsed—and triggers an error handling routine when these validations fail. As such, the function visibly enforces the spec requirement that a sender must not generate protocol elements that do not comply with the defined grammar, fulfilling both condition checks and corresponding actions within its own logic.",success,
16754,dialup_handler,"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.",57,Fully Matches,"[{'A1': {'code': 'ap_set_etag_fd(r, fd);', 'explanation': 'This call sets the ETag on the response based on the file descriptor, which directly addresses the RFC requirement to send an ETag for a selected representation.'}}]","The dialup_handler function contains an explicit call to ap_set_etag_fd(r, fd), ensuring that an ETag is generated and sent as part of the response. This behavior matches the RFC specification that an origin server SHOULD send an ETag when it can be reliably determined, thereby fulfilling the intended condition within the function's scope.",success,
16754,dialup_handler,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Does Not Match,[],"The provided function unconditionally sets the Content-Length header by calling ap_set_content_length(r, r->finfo.size) without checking for the presence of a Transfer-Encoding header field. According to the specification, if a Transfer-Encoding header field is present, the sender MUST NOT include the Content-Length header. Since there is no logic in the function to verify the absence of Transfer-Encoding before setting Content-Length, the function does not implement the required RFC constraint.",success,
16754,dialup_handler,"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.",52,Fully Matches,"[{'A1': {'code': 'ap_update_mtime(r, r->finfo.mtime);\n    ap_set_last_modified(r);', 'explanation': 'These calls update the resource’s modification time and explicitly set the Last-Modified header in the response. This directly addresses the RFC requirement that the origin server SHOULD send a Last-Modified header when a last modification date can be reasonably determined.'}}]","The function clearly implements the core action required by the HTTP RFC regarding the Last-Modified header by invoking ap_update_mtime and ap_set_last_modified. Even though there are other unrelated operations in the function, this portion alone ensures that the Last-Modified header is set as required by the spec. All logic relevant to the specification is contained within this function, fulfilling the corresponding labeled constraint.",success,
16754,dialup_handler,"The Accept-Ranges field MAY be sent in a trailer section, but is preferred to be sent as a header field because the information is particularly useful for restarting large information transfers that have failed in mid-content (before the trailer section is received).",133,Partially Matches,"[{'A1': {'code': 'ap_set_accept_ranges(r);', 'explanation': ""The function calls ap_set_accept_ranges(r) to set the Accept-Ranges header field, addressing the RFC's recommendation to send this information as a header rather than a trailer.""}}]","The RFC specifies that the Accept-Ranges field is preferably sent as a header field because it is useful for resuming large transfers. The function implements this preference by calling ap_set_accept_ranges(r), thereby satisfying one of the key aspects of the spec. However, it does not implement any logic regarding sending the field in a trailer section or advising the client to avoid range requests using the 'none' range unit. As the function only addresses part of the spec constraint, the outcome is partially matched.",success,
16754,dialup_handler,"In 200 responses to GET or HEAD, an origin server SHOULD send any available validator fields (Section 8.8) for the selected representation, with both a strong entity tag and a Last-Modified date being preferred.",141,Partially Matches,"[{'A1': {'code': 'ap_set_last_modified(r);', 'explanation': 'This line sets the Last-Modified header on the response, satisfying the validator field requirement for a strong Last-Modified date.'}}, {'A2': {'code': 'ap_set_etag_fd(r, fd);', 'explanation': 'This call assigns an ETag (entity tag) based on the file descriptor, implementing the preferred strong entity tag validator.'}}]","The RFC requires that for a 200 response to GET or HEAD, the server should send available validator fields, favoring both a strong entity tag and a Last-Modified date. In this function, the code checks for GET requests (ignoring HEAD) and proceeds to set both the Last-Modified header and the ETag by calling ap_set_last_modified(r) and ap_set_etag_fd(r, fd). Although the validator fields for GET responses are implemented, HEAD responses are not explicitly handled in this function, so only part of the spec's requirements are addressed here.",success,
16754,dialup_handler,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'C1': {'code': 'ap_set_content_length(r, r->finfo.size);', 'explanation': 'This call explicitly sets the Content-Length header using the known file size. It reflects the requirement that in the absence of Transfer-Encoding, the origin server SHOULD send a Content-Length header when the content length is known.'}}]","The function checks that the request is a GET and operates on a valid file before proceeding, then it sets the Content-Length header by calling ap_set_content_length with the file's size. This addresses the spec requirement to send a Content-Length header when the content size is known. However, the function does not include logic to check for conditions such as the presence of Transfer-Encoding or to avoid sending Content-Length for responses with status codes like 1xx, 204, or 2xx CONNECT responses. Because only part of the spec constraint is directly implemented in this function, the match is considered partial.",success,
16782,session_cookie_load,A sender MUST NOT send a connection option corresponding to a field that is intended for all recipients of the content.,252,Does Not Match,[],"The RFC specification requires that a connection option corresponding to a field meant for all recipients (e.g., Cache-Control) must not be sent. In the provided code function, the only related operation is the line that adds a 'Cache-Control' header to the outgoing headers (apr_table_addn(r->headers_out, ""Cache-Control"", ""no-cache, private"");). However, this action does not reflect logic that avoids using a connection option for a field intended for all recipients—instead, it simply sets a header for controlling caching. There is no specific mechanism in the function that enforces or checks the restriction described in the RFC. As a result, the function does not visibly address the specified condition and action outlined in the RFC.",success,
16782,session_cookie_load,"An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",268,Does Not Match,[],"The provided function, session_cookie_load, focuses on session cookie extraction and caching headers by adding a ""Cache-Control"" header, but it does not implement any logic addressing the RFC's requirement that an origin server SHOULD NOT rely on private agreements to receive content. There is no code that directly relates to or ensures that private agreements are not being trusted for content transfer. Hence, none of the spec constraints (such as C1, A1, etc.) defined in the input are met within this function.",success,
16786,set_cookie_name,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': 'while (apr_isspace(*last)) {\n    last++;\n}', 'explanation': ""This loop advances the pointer past any whitespace characters in 'last', thus removing leading bad whitespace before further interpretation. This behavior directly implements the RFC requirement that a recipient must parse for and remove bad whitespace.""}}]","The function tokenizes the input string to separate the cookie name from its attributes and then explicitly skips over any whitespace characters before storing the remaining string in conf->name_attrs. This approach directly addresses the RFC directive to remove bad whitespace before interpreting a protocol element, thus fully matching the constraint specified.",success,
16786,set_cookie_name,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Partially Matches,"[{'A1': {'code': 'while (apr_isspace(*last)) {\n    last++;\n}', 'explanation': 'This loop removes leading whitespace from the remaining part of the input after tokenizing the first cookie element. This is an attempt to implement removal of BWS as required by the RFC, though it only applies to a specific part of the input and does not cover every aspect of BWS removal.'}}]","The RFC states that any content defined as BWS may be removed before interpretation. In this function, after extracting the cookie name token, the while loop iterates over any leading whitespace (BWS) in the remaining string and skips it. This shows an attempt to address the BWS removal requirement. However, the implementation is limited to processing the whitespace after the token and does not comprehensively address all possible occurrences of BWS as described in the spec. Therefore, the function only partially matches the intended spec constraints.",success,
16786,set_cookie_name,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Partially Matches,"[{'A1': {'code': 'while (apr_isspace(*last)) {\n    last++;\n}', 'explanation': ""The code explicitly advances the pointer 'last' to skip over any leading whitespace before storing name_attrs. This demonstrates an attempt to remove whitespace as required by the HTTP RFC specification.""}}]","The RFC requires that whitespace be excluded from the field value prior to its evaluation. In this function, the first token (cookie name) is obtained using apr_strtok with space/tab as delimiters, which inherently excludes any surrounding whitespace, and the subsequent attribute string is advanced past any leading whitespace via a while loop checking apr_isspace(*last). However, the implementation does not address potential trailing whitespace and only partially cleans the input according to the complete requirement. Therefore, while the function demonstrates an effort to trim whitespace in one part of the field (i.e. leading whitespace on the attributes), it does not fully meet the broader condition of always excluding unwanted whitespace from the field value.",success,
16787,set_cookie_name2,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Partially Matches,"[{'A1': {'code': 'while (apr_isspace(*last)) {\n    last++;\n}', 'explanation': 'This loop explicitly skips over whitespace characters in the remainder of the string after tokenizing the cookie name, which is an attempt to remove BWS as suggested by the RFC. However, only a part of the RFC requirement (removing leading whitespace from the attribute section) is handled.'}}]","The RFC specifies that any content defined as BWS may be removed before interpreting the protocol element. In this function, the removal of leading whitespace via the while loop is the only visible implementation addressing the BWS aspect. The cookie tokenization and assignment operations do not fully cover all possible BWS scenarios described in the spec, so the function only partially matches the RFC constraints.",success,
16787,set_cookie_name2,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': 'char *cookie = apr_strtok(line, "" \\t"", &last);\n...\nwhile (apr_isspace(*last)) {\n    last++;\n}', 'explanation': 'The function first tokenizes the input (using whitespace delimiters) to separate the cookie name. Then, it explicitly removes any leading whitespace from the remaining string via a loop (while (apr_isspace(*last)) { last++; }), which meets the RFC requirement to parse and remove bad whitespace before further interpretation.'}}]","The RFC requires that a recipient must parse for bad whitespace and remove it before interpreting protocol elements. Within the function, the code tokenizes the input based on whitespace and then proceeds to skip over any white space characters that follow, directly addressing the requirement. This logic is contained entirely within the function_body, thereby fully matching the specified condition.",success,
16787,set_cookie_name2,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Partially Matches,"[{'A1': {'code': 'while (apr_isspace(*last)) {\n    last++;\n}', 'explanation': 'This loop explicitly skips leading whitespace before assigning the remaining string (name2_attrs), thus partially addressing the RFC requirement to exclude whitespace prior to evaluation.'}}]","The function first tokenizes the input to isolate a cookie name and then uses a loop to skip over any leading whitespace in the remaining portion of the argument before assigning it as attributes. This addresses the spec's requirement to remove whitespace from the field value, but only in part. It relies on tokenization for the first token and only removes leading whitespace from the attributes, meaning it does not comprehensively trim all whitespace (for example, any trailing whitespace is not removed). Thus, the function only partially matches the RFC requirement.",success,
16793,session_dbd_load,A sender MUST NOT send a connection option corresponding to a field that is intended for all recipients of the content.,252,Does Not Match,[],"The RFC requires that a sender must not send a connection option for a header field intended for all recipients (e.g., Cache-Control). In the function, the line 'apr_table_addn(r->headers_out, ""Cache-Control"", ""no-cache, private"");' unconditionally adds a Cache-Control header to the outgoing headers. This header is intended for all recipients, and by adding it, the function fails to honor the condition set by the RFC. There is no logic in the function that distinguishes connection options from general headers or prevents sending a connection option corresponding to a universally intended field. Therefore, the function does not implement the RFC requirement.",success,
16797,session_dbd_save,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function does not include any visible logic that enforces or checks the HTTP header field constraints as specified in the RFC. It primarily handles session management and cookie creation (via ap_cookie_write and ap_cookie_write2) and adds a Cache-Control header, without any explicit handling of multiple header field lines, their order, or prevention of duplicating header fields. Therefore, none of the labeled spec constraints (e.g., C1, A1) are implemented within this function.",success,
16804,set_cookie_name,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Partially Matches,"[{'C1': {'code': 'while (apr_isspace(*last)) {\n    last++;\n}', 'explanation': ""This loop skips over any whitespace characters at the beginning of the remainder of the input string. It directly implements the removal of 'bad whitespace' (BWS) as described in the RFC, addressing the requirement that a recipient must parse and remove such whitespace. However, only this part of the RFC is visibly handled in the function.""}}]","The function processes the input string by tokenizing it into a cookie name and attributes. It then explicitly removes leading whitespace from the attributes by advancing the pointer past any whitespace. This behavior partially satisfies the RFC specification regarding the removal of BWS. However, the function does not address all aspects of the RFC rule, nor does it handle other locations where BWS might occur, so the implementation only partially matches the spec.",success,
16804,set_cookie_name,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,"[{'C1': {'code': 'while (apr_isspace(*last)) {\n    last++;\n}', 'explanation': ""This loop advances the pointer past any whitespace characters before setting 'name_attrs', which aligns with the RFC requirement to remove bad whitespace. However, the function only strips whitespace for a specific portion and does not comprehensively normalize all parts of the input, indicating only a partial implementation of the spec.""}}]","The function does include logic to remove leading whitespace (using a loop that increments the pointer past any whitespace characters), which addresses the core requirement of parsing and removing 'bad whitespace' as specified in the RFC. However, its handling is limited to a particular context (i.e., before assigning cookie attributes) and does not fully cover all scenarios described in the RFC. Thus, only part of the spec constraint is implemented within this function.",success,
16804,set_cookie_name,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': 'while (apr_isspace(*last)) {\n    last++;\n}', 'explanation': 'The RFC requires that any allowed whitespace in a field be excluded prior to evaluating the field value. In this code, after tokenizing the input, the loop explicitly skips over leading whitespace (using apr_isspace) in the remainder of the string before it is assigned (as attributes). Additionally, the use of apr_strtok with spaces and tabs as delimiters ensures that the extracted token (cookie name) does not include unwanted whitespace. Together, these two steps fulfill the specified requirement.'}}]","The function first duplicates the input string, tokenizes it to extract the cookie name (thus inherently stripping leading whitespace for that token), and then uses a while loop to explicitly skip any leading whitespace in the remaining part of the string. This logic directly addresses the RFC specification that mandates the exclusion of whitespace before evaluating a field value, demonstrating that the function fully meets the requirement.",success,
16805,set_cookie_name2,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,"[{'C1': {'code': 'while (apr_isspace(*last)) {\n    last++;\n}', 'explanation': ""The loop explicitly skips over any whitespace characters at the beginning of the attributes (stored in 'last'), thereby removing bad whitespace before further processing. This directly addresses the requirement to remove such whitespace from the input.""}}]","The function extracts a token from the input and then advances the pointer past any whitespace by using a loop, which corresponds to the removal of bad whitespace outlined in the RFC spec. However, it only addresses the whitespace removal for one part of the message (the attributes portion) and does not encompass a complete implementation of all aspects of the RFC, so it only partially matches the complete set of spec constraints.",success,
16805,set_cookie_name2,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'A1': {'code': 'while (apr_isspace(*last)) {\n    last++;\n}', 'explanation': 'This loop removes all leading whitespace (i.e. bad whitespace) from the remaining part of the input string before assigning it to the configuration, which directly satisfies the RFC requirement to strip BWS.'}}]","The RFC specification mandates that any bad whitespace (BWS) is to be removed before interpreting the protocol element. In the provided function, after tokenizing the input using apr_strtok the code explicitly iterates over any whitespace (using apr_isspace) and advances the pointer before setting the remaining string as attributes. This behavior, implemented solely within the function (and not via external dependencies), directly addresses the RFC's requirement, thus fully matching the specified constraint labeled here as A1.",success,
16805,set_cookie_name2,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': 'while (apr_isspace(*last)) {\n        last++;\n    }', 'explanation': ""This loop explicitly skips over any leading whitespace in the remaining string (stored in 'last') before the field value (name2_attrs) is used, directly addressing the RFC requirement to exclude such whitespace prior to evaluation.""}}, {'A1': {'code': 'char *cookie = apr_strtok(line, "" \\t"", &last);\nconf->name2 = cookie;', 'explanation': 'Tokenizing the input using whitespace delimiters ensures that the extracted cookie name (name2) itself does not contain leading or trailing whitespace, which is in line with the field value constraints.'}}]","The function processes the input string by duplicating it and then tokenizing it based on whitespace. The tokenization (using apr_strtok) inherently removes any surrounding whitespace from the cookie name, while the explicit loop that increments the pointer past any whitespace characters ensures that leading whitespace is removed from the attributes portion. This behavior embodies the RFC requirement to exclude whitespace from the field value prior to evaluation. Since both the extraction and whitespace removal are handled within this function itself, the code fully meets the specified condition.",success,
16830,session_identity_decode,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function, session_identity_decode, focuses solely on decoding a URL-encoded session identity string into key-value pairs and updating session records accordingly. There is no logic within this function that addresses the RFC specification requiring that a sender must not generate protocol elements or syntax alternatives that are reserved for other roles. It does not check or enforce any role-based messaging restrictions, nor does it validate that the generated protocol elements conform to the sender's allowed role. As a result, no part of the function directly implements any of the specified constraints (e.g., C1, A1) in the RFC specification.",success,
16831,session_output_filter,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function, session_output_filter, does not implement any logic that enforces or checks the conditions described by the RFC specification regarding multiple header field lines (i.e., prohibiting generating multiple field lines with the same name or the proper handling/ordering of such). The function simply retrieves a header value using apr_table_get and then unsets it, without any evidence of combining multiple header field values into a comma-separated list or preserving their order, as required by the spec constraints (e.g., C1, A1). Therefore, no part of the function directly addresses the specified conditions.",success,
16833,session_fixups,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function does not contain any logic that ensures no duplicate header fields are generated or that the order of header fields is preserved as required by the RFC specification. The function merely loads a session, encodes it, sets an environment variable, and unsets the ""Session"" header. There is no implementation within this function to check for or prevent the creation of multiple field lines with the same header name or to combine them into a comma-separated list as specified.",success,
16845,reflector_handler,"An origin server that receives a request method that is recognized and implemented, but not allowed for the target resource, SHOULD respond with the 405 (Method Not Allowed) status code.",60,Fully Matches,"[{'C1': {'code': 'ap_allow_methods(r, 1, ""POST"", ""OPTIONS"", NULL);', 'explanation': 'This line explicitly declares which HTTP methods (POST and OPTIONS) are allowed for the reflector resource, thereby supporting the condition that the resource only implements a subset of methods.'}}, {'A1': {'code': 'else {\n    return HTTP_METHOD_NOT_ALLOWED;\n}', 'explanation': 'This block handles any method that is recognized and implemented by the server but not permitted for the target resource, returning the 405 status code (HTTP_METHOD_NOT_ALLOWED) as specified by the RFC.'}}]","The function first restricts allowed methods to POST and OPTIONS. For a request using one of these two methods, it processes the request accordingly; for all other methods—implying that the method is recognized and implemented but not allowed—it returns HTTP_METHOD_NOT_ALLOWED (405). This directly implements the RFC requirement that a recognized but not allowed method should prompt a 405 response.",success,
16845,reflector_handler,"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.",52,Fully Matches,"[{'A1': {'code': 'if (!apr_table_get(r->headers_out, ""Last-Modified"")) {\n    ap_update_mtime(r, apr_time_now());\n    ap_set_last_modified(r);\n}', 'explanation': 'This segment explicitly checks if the Last-Modified header is absent in the outgoing response and, if so, updates the modification time to the current time and sets the Last-Modified header. This directly implements the RFC requirement that an origin server SHOULD send a Last-Modified header for a representation.'}}]","The function includes logic that addresses the RFC specification regarding the Last-Modified header. In the case of a POST request, if the Last-Modified header is not already provided, the code calls 'ap_update_mtime' with the current time and then 'ap_set_last_modified' to send the header. This implementation meets the RFC's mandate by ensuring that a proper Last-Modified value is sent for the selected representation.",success,
16845,reflector_handler,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Partially Matches,"[{'C1': {'code': 'if ((content_length = apr_table_get(r->headers_in, ""Content-Length""))) {\n    apr_off_t clen;\n\n    if (!ap_parse_strict_length(&clen, content_length)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10243)\n                      ""reflector_handler: invalid content-length \'%s\'"", content_length);\n        return HTTP_BAD_REQUEST;\n    }\n\n    ap_set_content_length(r, clen);\n}', 'explanation': 'This segment checks if a Content-Length header is present, strictly parses its value, and returns a 400 (Bad Request) error if the header is invalid. This behavior aligns with the RFC requirement to treat messages with invalid Content-Length as framing errors.'}}]","The function partially addresses the RFC by handling the Content-Length header: it validates the header and returns an error when invalid, which meets part of the specification for proper message framing. However, aside from this check, the function does not explicitly implement mechanisms to generate encoded or length-delimited messages whenever possible. For example, it does not introduce chunked encoding or other length-delimited strategies when the Content-Length header is absent, meaning that only a portion of the RFC’s recommendations is addressed within this function.",success,
16845,reflector_handler,"If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value).",201,Partially Matches,"[{'C5': {'code': 'if ((content_length = apr_table_get(r->headers_in, ""Content-Length""))) {\n    apr_off_t clen;\n\n    if (!ap_parse_strict_length(&clen, content_length)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10243)\n                      ""reflector_handler: invalid content-length \'%s\'"",\n                      content_length);\n        return HTTP_BAD_REQUEST;\n    }\n\n    ap_set_content_length(r, clen);\n}', 'explanation': 'The function checks for a Content-Length header and validates it using ap_parse_strict_length. If the header is invalid, it logs an error and returns HTTP_BAD_REQUEST. This partially implements the RFC requirement regarding handling an invalid Content-Length when Transfer-Encoding is not present. However, it does not address the nuance of accepting comma‐separated lists of identical valid values.'}}]","The function implements a check for an invalid Content-Length header by validating it and returning an error if the value is not strictly parsable. This logic partially fulfills the condition specified in the RFC for messages received without Transfer-Encoding and with an invalid Content-Length header. However, it does not consider the presence of a comma-separated list of values (all identical) as an exception, nor does it check for the Transfer-Encoding header at all. Thus, while it does address part of the RFC (invalid Content-Length error handling), it does not fully implement the complete RFC requirement.",success,
16845,reflector_handler,"If the unrecoverable error is in a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.",202,Partially Matches,"[{'C1': {'code': 'if (!ap_parse_strict_length(&clen, content_length)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10243) ""reflector_handler: invalid content-length \'%s\'"", content_length);\n    return HTTP_BAD_REQUEST;\n}\n\n...\n\nstatus = apr_bucket_read(bucket, &data, &len, APR_BLOCK_READ);\nif (status != APR_SUCCESS) {\n    apr_brigade_destroy(bbin);\n    return ap_map_http_request_error(status, HTTP_BAD_REQUEST);\n}', 'explanation': ""The RFC specifies that if an unrecoverable error is found in a request, the server must respond with a 400 (Bad Request) status code and then close the connection. In the provided code function, when an invalid Content-Length is encountered or an error occurs during bucket reading, the function logs the error and returns HTTP_BAD_REQUEST. This handling fulfills the part of the requirement regarding the error response. However, there is no explicit logic to close the connection within the function itself (likely relying on the Apache framework's error handling), which is why the match is only partial.""}}]","The function addresses the RFC requirement by detecting unrecoverable errors (e.g., an invalid Content-Length header or failure during bucket reading) and responding with HTTP_BAD_REQUEST, which is consistent with the spec's mandate for error responses in a request. However, the code does not explicitly close the connection after sending the error response, a detail mandated by the spec. Thus, while error conditions are detected and handled with a 400 status code, the function only partially matches the complete requirements of the RFC as provided.",success,
16845,reflector_handler,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Fully Matches,"[{'C1': {'code': 'if ((content_length = apr_table_get(r->headers_in, ""Content-Length""))) {\n    apr_off_t clen;\n\n    if (!ap_parse_strict_length(&clen, content_length)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10243)\n                      ""reflector_handler: invalid content-length \'%s\'"",\n                      content_length);\n        return HTTP_BAD_REQUEST;\n    }\n\n    ap_set_content_length(r, clen);\n}', 'explanation': ""This segment retrieves the 'Content-Length' header and uses ap_parse_strict_length to validate it. If the value is incorrect, it logs the error and returns HTTP_BAD_REQUEST, thereby ensuring that a message with an incorrect Content-Length header is not forwarded, which fully satisfies the RFC requirement.""}}]","The function_body directly checks the Content-Length header and validates it strictly using ap_parse_strict_length. In the event of an invalid value, the function does not continue processing the message, instead returning HTTP_BAD_REQUEST. This behavior aligns with the RFC specification that mandates a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect. All relevant behavior is implemented within the function_body itself, and no reliance on external dependencies is involved.",success,
16845,reflector_handler,"The Accept-Ranges field MAY be sent in a trailer section, but is preferred to be sent as a header field because the information is particularly useful for restarting large information transfers that have failed in mid-content (before the trailer section is received).",133,Partially Matches,"[{'A1': {'code': 'ap_set_accept_ranges(r);', 'explanation': 'The call to ap_set_accept_ranges(r) attempts to set the Accept-Ranges header field, which satisfies the part of the RFC that prefers its inclusion as a header field.'}}]","The RFC specifies that the Accept-Ranges field should preferably be sent as a header field (and notes the relevance of the range unit ""none"" for advising clients not to perform range requests). In the function, the only visible implementation related to this is the call to ap_set_accept_ranges(r), which likely sets the Accept-Ranges header. However, the function does not explicitly implement any logic regarding the 'none' range unit or handling trailer sections, so it only partially matches the RFC specification.",success,
16845,reflector_handler,"If the purpose of such a resource is to perform an unsafe action, then the resource owner MUST disable or disallow that action when it is accessed using a safe request method.",267,Fully Matches,"[{'A1': {'code': 'ap_allow_methods(r, 1, ""POST"", ""OPTIONS"", NULL);\n...\nelse {\n    return HTTP_METHOD_NOT_ALLOWED;\n}', 'explanation': 'The function explicitly limits allowed HTTP methods to POST and OPTIONS. By doing so, it disallows safe methods (e.g., GET) from triggering the unsafe action, thereby meeting the RFC requirement that unsafe actions must be disabled when accessed via a safe request method.'}}]","The RFC requires that if a resource is designed to perform an unsafe action, then that action must not be performed when a safe method (such as GET) is used. In the provided function, the call to ap_allow_methods limits acceptable methods to POST and OPTIONS, and any other method (i.e., safe methods like GET) is explicitly rejected by returning HTTP_METHOD_NOT_ALLOWED. This logic, implemented entirely within the function, qualifies as a full match to the spec constraint.",success,
16845,reflector_handler,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'A1': {'code': 'if ((content_length = apr_table_get(r->headers_in, ""Content-Length""))) {\n    apr_off_t clen;\n\n    if (!ap_parse_strict_length(&clen, content_length)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10243)\n                      ""reflector_handler: invalid content-length \'%s\'"",\n                      content_length);\n        return HTTP_BAD_REQUEST;\n    }\n\n    ap_set_content_length(r, clen);\n}', 'explanation': ""This segment of the function checks for a 'Content-Length' header in the incoming request, validates it, and then sets it on the response. This directly attempts to implement the RFC guideline that an origin server SHOULD send a Content-Length header when the content size is known. However, it only does so if the header is already present and does not include further logic (e.g. verifying the absence of Transfer-Encoding or checking explicitly for disallowed status codes) as required by the RFC context.""}}]","The function partially implements the RFC by reflecting the Content-Length header when it is available in the incoming request. While it does attempt to send a Content-Length header when the content length is provided (thus meeting part of the RFC requirement), it does not address additional conditions—such as ensuring that the header is not sent when Transfer-Encoding is present or when the response status code is 1xx/204 or in the case of CONNECT requests—as specified in the full RFC. Therefore, the function only partially matches the overall specification.",success,
16845,reflector_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,"[{'A1': {'code': 'if ((content_type = apr_table_get(r->headers_in, ""Content-Type""))) {\n    \t\tap_set_content_type(r, content_type);\n\t}', 'explanation': 'This segment checks for the presence of a Content-Type header in the request and sets it on the response. It addresses the RFC’s requirement to include a Content-Type header when the media type is known. However, if the header is absent (i.e. the media type is unknown), the function does not attempt to generate a default Content-Type, and so it only partially meets the RFC spec.'}}]","The function attempts to implement the specified HTTP RFC by reflecting the Content-Type header from the input to the output when it is present (i.e., when the intended media type is known). This satisfies the action of generating a Content-Type header when applicable. However, it does not include any logic to generate or default a Content-Type when the header is missing, which only partially fulfills the specification.",success,
16845,reflector_handler,A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.,30,Partially Matches,"[{'A1': {'code': 'if (r->method_number == M_OPTIONS) {\n    return ap_send_http_options(r);\n}', 'explanation': 'This code branch directly handles OPTIONS requests by sending an HTTP options response, which aligns with the spec stating that an OPTIONS request can be honored by any protocol. No protocol switch is attempted.'}}]","The provided function explicitly handles OPTIONS requests by calling ap_send_http_options, thereby satisfying the part of the RFC that indicates an OPTIONS request can be honored by any protocol. However, the RFC also includes a requirement that a server must not switch protocols unless the received message semantics can be honored by the new protocol. Since the function does not implement or address any protocol-switching logic (i.e., it never sends a 101 Switching Protocols response or similar), the function only partially matches the overall RFC specification.",success,
16845,reflector_handler,"Likewise, a sender MUST NOT forward a message with a Content-Length header field value that does not match the ABNF above, with one exception: a recipient of a Content-Length header field value consisting of the same decimal value repeated as a comma-separated list (e.g, ""Content-Length: 42, 42"") MAY either reject the message as invalid or replace that invalid field value with a single instance of the decimal value, since this likely indicates that a duplicate was generated or combined by an upstream message processor.",49,Partially Matches,"[{'C1': {'code': 'if ((content_length = apr_table_get(r->headers_in, ""Content-Length""))) {\n    apr_off_t clen;\n\n    if (!ap_parse_strict_length(&clen, content_length)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10243)\n                      ""reflector_handler: invalid content-length \'%s\'"",\n                      content_length);\n        return HTTP_BAD_REQUEST;\n    }\n\n    ap_set_content_length(r, clen);\n}', 'explanation': 'The code checks for the Content-Length header and uses a strict parser (ap_parse_strict_length) to ensure that the value conforms to the expected ABNF. This satisfies part of the spec condition that a Content-Length header value must match the ABNF, and it aborts (rejects) the request if it does not.'}}]","The function partially implements the RFC specification regarding the Content-Length header. It verifies that the provided Content-Length adheres to a strict format and rejects the message if it does not. However, it does not address the specific exception outlined in the spec – namely when the Content-Length header is provided as a comma‐separated list of identical numbers (e.g., ""42, 42"") – where the recipient MAY either reject or normalize the value. Since this exception is not handled within the function itself, the implementation only partially matches the specification.",success,
16876,crypto_out_filter,"Likewise, a sender MUST NOT forward a message with a Content-Length header field value that does not match the ABNF above, with one exception: a recipient of a Content-Length header field value consisting of the same decimal value repeated as a comma-separated list (e.g, ""Content-Length: 42, 42"") MAY either reject the message as invalid or replace that invalid field value with a single instance of the decimal value, since this likely indicates that a duplicate was generated or combined by an upstream message processor.",49,Does Not Match,[],"The RFC requires that the sender must not forward a message with a Content-Length header field value that does not match specific ABNF rules, with an exception for comma-separated repeated values. However, in this function, the only logic related to Content-Length is the unconditional removal of the 'Content-Length' header when ctx->clength is false (i.e., '!ctx->clength'). There is no parsing, validation, or handling of duplicate comma-separated Content-Length values. Thus, the function does not implement the necessary checks and transformations as per the spec constraints.",success,
16876,crypto_out_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'C1': {'code': 'if (!ctx->clength) {\n    ctx->clength = 1;\n    apr_table_unset(f->r->headers_out, ""Content-Length"");\n}', 'explanation': ""This segment attempts to ensure that an outgoing message does not carry an incorrect Content-Length header. By unsetting the 'Content-Length' header when ctx->clength is false, the code avoids forwarding a header that might be known to be incorrect. However, it does not validate the header value against explicit ABNF rules or check for duplicated repeated values as described in the RFC context, so the implementation only partially meets the requirement.""}}]","The RFC specifies that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect. In this function_body, the check on ctx->clength and subsequent removal of the 'Content-Length' header is the only visible logic addressing this spec constraint. Since the function does not perform a comprehensive validation of the Content-Length header (for example, checking against the ABNF or handling the specific duplicate value case), it only partially implements the specification. The code addresses the core requirement by not forwarding an incorrect Content-Length but leaves room for improvements in fully meeting all aspects of the RFC.",success,
16877,crypto_in_filter,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function, crypto_in_filter, does not contain any visible logic that checks whether the generated protocol elements conform to any ABNF grammar. The RFC specification requires that a sender MUST NOT generate protocol elements that do not match the defined grammar (labeled here as C1). However, within the function_body, there is no code segment that validates or enforces any aspect of the protocol's ABNF rules. Instead, the function mainly handles data reading, buffering, and passing bucket elements along the filter chain. As such, the code does not address the specific requirement, and no labeled constraint (e.g., C1) is fully implemented in this function.",success,
16877,crypto_in_filter,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function (crypto_in_filter) does not implement any logic that checks or enforces the RFC requirement which states that within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. The function mainly handles reading data from input buckets, processing it through a crypto operation (do_crypto), and then writing the output. There is no code segment that validates the role or restricts the generation of certain protocol elements, nor does it verify that the generated elements conform to the grammar defined by ABNF rules. Therefore, within its own logic, it does not address any of the labeled conditions (such as C1) or actions (such as A1) from the spec constraints.",success,
16877,crypto_in_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'if (!ctx->clength) {\n    ctx->clength = 1;\n    apr_table_unset(f->r->headers_in, ""Content-Length"");\n}', 'explanation': 'This segment appears to implement the action of not forwarding a message with an incorrect Content-Length header by removing (unsetting) the Content-Length field when the context flag (ctx->clength) is not set. It addresses the RFC requirement by ensuring the header is cleared before the message is forwarded.'}}]","The RFC specifies that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect. In this function, the only visible measure addressing this is the removal of the Content-Length header if a condition (ctx->clength is not set) is met. However, aside from clearing the header, the function does not perform any in-depth validation of the Content-Length value or directly compare it with any computed value. Thus, while the code does attempt to address one aspect (action A1) of the requirement, it does not fully implement the comprehensive check required by the specification, leading to a partial match.",success,
16878,crypto_handler,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The provided function does not address any of the HTTP RFC requirements regarding the Content-Length header value. The RFC mandates that a sender must not forward a message if the Content-Length is known to be incorrect. In this function, while the Content-Length is set using ap_set_content_length (with the value based on a secret's length), there is no logic that validates or verifies whether the Content-Length header field value is correct in the context of the received message or its framing. The function only assigns a value without performing any checks or handling duplicates (as suggested by the spec context for comma-separated repeated values). No code segment in the function inspects, validates, or rejects an incorrect Content-Length, and therefore it does not implement any of the labeled constraints (such as C1 or A1) from the specification.",success,
16878,crypto_handler,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Does Not Match,[],"The provided function always sets the Content-Length header via the call to ap_set_content_length without checking for the presence of a Transfer-Encoding header. According to the RFC, a sender MUST NOT send a Content-Length header when a Transfer-Encoding header is present. Since this function does not include any logic to inspect or conditionally omit the Content-Length header when Transfer-Encoding exists, it does not implement the specified HTTP requirement.",success,
16878,crypto_handler,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'A1': {'code': 'ap_set_content_length(r, rec->k.secret.secretLen);', 'explanation': 'The function explicitly sets the Content-Length header when the content (in this case, the crypto key) is available. This action aligns with the RFC recommendation to send a Content-Length header field when the content size is known.'}}]","The function attempts to implement the RFC requirement by setting the Content-Length header when the content size is known (i.e., when a valid crypto key is retrieved). However, it does not check additional conditions (for example, verifying that no Transfer-Encoding header is present or ensuring that the response is not one of the cases such as 1xx or 204 where the header must not be sent). As such, while it fulfills part of the specification (sending the header when content length is known), it does not cover all the context-specific conditions outlined in the RFC.",success,
16878,crypto_handler,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Does Not Match,[],"The provided function sets the Content-Length header unconditionally when processing a valid crypto key (e.g., via the call to ap_set_content_length) without checking the response status code. The RFC requires that the server MUST NOT send a Content-Length header field in responses with a status code of 1xx or 204, but the function does not include any conditional logic to omit the Content-Length header in these cases. Therefore, the function does not attempt to implement the specified HTTP RFC constraint.",success,
16878,crypto_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,"[{'A1': {'code': 'ap_set_content_type_ex(r, ""application/octet-stream"", 1);', 'explanation': ""This call sets the Content-Type header for the response when content is generated (in the key_set branch), thereby attempting to meet the spec requirement that a message with content should include a Content-Type header field. However, it does not determine the intended media type and always uses 'application/octet-stream', which may not be appropriate if the media type is known.""}}]","The RFC specification requires that a sender generating a message with content SHOULD include a Content-Type header unless the media type is unknown. In this function, when a valid key is available (and content is produced via ap_rwrite), the Content-Type header is unconditionally set to 'application/octet-stream'. This meets the basic action of setting a Content-Type header, but it does not account for cases where the intended media type might be known and different (for example, the provided sr_context indicates 'text/html; charset=ISO-8859-4'). Consequently, while the function includes logic to set a Content-Type header when outputting content (fulfilling part of the spec), it does not fully implement conditional logic based on the knowledge of the intended media type. Therefore, only a partial match is achieved.",success,
16878,crypto_handler,"If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type.",35,Partially Matches,"[{'A1': {'code': 'ap_set_content_type_ex(r, ""application/octet-stream"", 1);', 'explanation': 'This call forcefully sets the Content-Type header to ""application/octet-stream"", which is one of the options specified in the RFC if no Content-Type header is present. However, the code does not check if a Content-Type header was provided before setting it, and thus does not implement the complete logic of conditionally assuming this default type.'}}]","The provided function force-sets the Content-Type header to ""application/octet-stream"" when a crypto-key is processed. This behavior loosely corresponds to the RFC clause that states a recipient may assume a media type of ""application/octet-stream"" if no Content-Type header is present. However, because the function does not check for or conditionally apply this default only in the absence of an existing Content-Type header, it only partially matches the specification.",success,
16943,have_lf_or_eos,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Partially Matches,"[{'C1': {'code': 'if (str[len-1] == APR_ASCII_LF)\n            return APR_SUCCESS;', 'explanation': 'This code inspects the final character of a non-empty bucket to verify if it is LF, which is a key aspect of the spec stating that a recipient MAY recognize a single LF as a line terminator. It directly addresses the scenario where only LF is used as a terminator.'}}]","The function iterates over buckets and returns success upon encountering either an EOS bucket or a bucket ending with LF. This demonstrates an attempt to acknowledge LF as a valid line terminator. However, the spec also requires that any preceding CR be ignored when LF is used and mandates proper handling of bare CRs. The function does not implement logic to ignore a preceding CR nor does it handle bare CRs as specified (i.e., considering the element invalid or replacing bare CR with SP). Since only part of the spec constraints is addressed within the function (i.e., recognizing LF as a terminator), the function only partially meets the specification.",success,
16945,reqtimeout_filter,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'C1': {'code': 'if (ccfg->cur_stage.timeout > 0) {\n    now = apr_time_now();\n    ccfg->timeout_at = now + apr_time_from_sec(ccfg->cur_stage.timeout);\n    ccfg->cur_stage.timeout = 0;\n    if (ccfg->cur_stage.max_timeout > 0) {\n        ccfg->max_timeout_at = now + apr_time_from_sec(ccfg->cur_stage.max_timeout);\n        ccfg->cur_stage.max_timeout = 0;\n    }\n}\n...\nrv = check_time_left(ccfg, &time_left, now);', 'explanation': 'This segment sets the timeout for the request. It implements monitoring of the open connection by determining how much time is left, thereby addressing the condition for timing-out an idle or slow connection as mentioned in the RFC context.'}}, {'A1': {'code': 'if (APR_STATUS_IS_TIMEUP(rv)) {\n    ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, f->c, APLOGNO(01382)\n                  ""Request %s read timeout"", ccfg->type);\n    apr_table_setn(f->c->notes, ""short-lingering-close"", ""1"");\n    f->c->keepalive = AP_CONN_CLOSE;\n}\nreturn rv;', 'explanation': 'This code block checks if the read operation timed out and then logs the timeout, sets a flag for a short lingering close, and marks the connection to be closed. This directly implements the action of closing the connection gracefully when a timeout condition is met, which is in line with the RFC requirement that a client, server, or proxy may close the transport connection at any time.'}}]","The function implements mechanisms to monitor the time left for a read operation and, upon a timeout (i.e. when the accrued idle time exceeds the allowed limits), it actively triggers a closure of the connection by setting the keepalive flag to AP_CONN_CLOSE. While this portion of the function directly addresses the RFC directive to allow closure of the connection (especially in handling timeouts gracefully), it only covers a specific scenario (timeout-induced closure) and does not encompass all aspects of connection management mentioned in the RFC. Hence, the implementation partially matches the provided spec constraints.",success,
16945,reqtimeout_filter,A client or server that wishes to time out SHOULD issue a graceful close on the connection.,314,Fully Matches,"[{'A1': {'code': 'if (APR_STATUS_IS_TIMEUP(rv)) {\n    ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, f->c, APLOGNO(01382)\n                  ""Request %s read timeout"", ccfg->type);\n    apr_table_setn(f->c->notes, ""short-lingering-close"", ""1"");\n    f->c->keepalive = AP_CONN_CLOSE;\n}', 'explanation': 'This code block detects a read timeout (indicating the intent to time out) and then sets flags to perform a graceful closure on the connection. By logging the timeout, setting a note for a short lingering close, and marking the connection to close (via f->c->keepalive = AP_CONN_CLOSE), the function directly implements the RFC recommendation that a client or server wishing to time out SHOULD issue a graceful close.'}}]","The reqtimeout_filter function directly manages request timeouts by monitoring read operations and adjusting connection timeout values. When the timeout condition is met (APR_STATUS_IS_TIMEUP), the function logs the timeout event and sets connection-marking parameters to ensure that the connection is gracefully closed. This behavior addresses the RFC specification that a client or server that wishes to time out should issue a graceful close on the connection. Hence, the function fully matches the relevant constraint as implemented within its own logic.",success,
16954,set_reqtimeouts,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'word = ap_getword_conf(cmd->temp_pool, &arg);\nval = strchr(word, \'=\');\nif (!val) {\n    return ""Invalid RequestReadTimeout parameter. Parameter must be in the form \'key=value\'"";\n}', 'explanation': ""This segment implements a basic defensive parser by ensuring that an expected 'key=value' pattern is present in each protocol element. It checks that a '=' exists and returns an error if not. While this partially meets the RFC requirement of defensively parsing a protocol element, it does not include further checks such as validating against a full ABNF grammar or enforcing any reasonable length limits.""}}]","The function attempts to parse the provided protocol element defensively by tokenizing the input and checking for the 'key=value' format, which is in line with the spirit of the RFC's recommendation. However, because it lacks additional validations like verifying the full ABNF grammar or checking buffer size limits, it only partially implements the full intent of the specification.",success,
16967,data_out_filter,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The function data_out_filter is primarily responsible for base64 encoding of the response body and adjusting headers such as Content-Length and Content-Type. It does not contain any logic that addresses the RFC specification concerning the prohibition of generating multiple header (or trailer) field lines with the same name, or ensuring that field line order is maintained when forwarding a message. No part of the function inspects or modifies HTTP header field ordering or conformance to the comma-separated list allowance as prescribed in the RFC, so it does not meet any of the labeled conditions or actions from the spec constraints.",success,
16967,data_out_filter,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC requires that a sender must not generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. In this function, although output is generated (for example, by using apr_brigade_printf to print a string in the format ""data:%s%s;base64,"" and by encoding data using apr_base64_encode_binary), there is no mechanism to verify that the output conforms to the ABNF grammar rules. The function does not validate or constrain the content type or any protocol element against the ABNF specification; it merely formats and passes through data. Therefore, no parts within the function_body address the constraint as defined, meaning the function does not visibly implement any requirement (labeled, for example, as C1 or A1) corresponding to the RFC specification.",success,
16967,data_out_filter,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Partially Matches,"[{'A1': {'code': 'apr_brigade_printf(ctx->bb, NULL, NULL, ""data:%s%s;base64,"", type ? type : """", charset ? charset : """");', 'explanation': ""This code prefixes the output with a 'data:' URI indicating Base64 encoding. This shows an attempt to generate an encoded message, which is one option required by the RFC.""}}, {'C1': {'code': 'content_length = apr_table_get(r->headers_out, ""Content-Length"");\nif (content_length) {\n    apr_off_t len, clen;\n    apr_brigade_length(ctx->bb, 1, &len);\n    if (ap_parse_strict_length(&clen, content_length) && clen < APR_INT32_MAX) {\n         ap_set_content_length(r, len + apr_base64_encode_len((int)clen) - 1);\n    } else {\n         apr_table_unset(r->headers_out, ""Content-Length"");\n    }\n}', 'explanation': 'This segment checks for a valid Content-Length header and, if found, calculates and sets a new Content-Length after Base64 encoding. This reflects an effort to produce a length-delimited message when possible, addressing part of the RFC requirement.'}}]","The function implements Base64 encoding of the response stream and attempts to adjust the Content-Length header accordingly. By doing so, it addresses the RFC's recommendation that a server should generate encoding or length-delimited messages whenever possible. However, it only partially meets the full set of message framing rules and error handling criteria described in the RFC specification context, as it does not handle other aspects like errors from invalid headers or connection closure issues.",success,
16967,data_out_filter,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC requires that a sender must not generate protocol elements that are reserved for other roles. The provided function focuses on processing and base64-encoding data for outgoing messages, including a check for subrequests (via ap_is_initial_req) and adjustments to the Content-Length header. However, there is no logic within the function that enforces or verifies role-based restrictions regarding protocol element generation. As such, the function does not address the specific requirement stated in the RFC specification.",success,
16967,data_out_filter,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,"[{'A1': {'code': 'ap_set_content_type_ex(r, ""text/plain"", 1);', 'explanation': 'This call sets the Content-Type header field on the request record. It is the only explicit action within the function that attempts to generate a Content-Type header field as required by the RFC spec.'}}]","The RFC requires that a sender generating a message with content should generate a Content-Type header field unless the media type is unknown. In this function, there is logic to retrieve the original content type (r->content_type) and incorporate it into a data URI prefix. However, the function ultimately forces the header to be set to 'text/plain' via the call to ap_set_content_type_ex(). This indicates an intent to provide a Content-Type header, but it ignores the original media type information and does not conditionally check if the media type is unknown before setting the header. Therefore, while the function does attempt to implement the RFC by generating a Content-Type header field, it does so in a limited and unconditional manner that only partially fulfills the specification.",success,
16967,data_out_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Fully Matches,"[{'C1': {'code': 'content_length = apr_table_get(r->headers_out, ""Content-Length"");\nif (content_length) {\n    apr_off_t len, clen;\n    apr_brigade_length(ctx->bb, 1, &len);\n    if (ap_parse_strict_length(&clen, content_length) && clen < APR_INT32_MAX) {\n        ap_set_content_length(r, len + apr_base64_encode_len((int)clen) - 1);\n    }\n    else {\n        apr_table_unset(r->headers_out, ""Content-Length"");\n    }\n}', 'explanation': ""This segment checks for the presence of a Content-Length header and validates it using a strict parser. If the header's value is considered invalid (parsing fails or exceeds a limit), it is removed, ensuring that an incorrect Content-Length is not forwarded.""}}]","The function implements the specified RFC requirement by checking for the Content-Length header value and validating it via a strict parsing routine (ap_parse_strict_length). If the header value is incorrect, the code explicitly removes the Content-Length header from the outgoing headers (using apr_table_unset). This approach prevents forwarding a message with an incorrect Content-Length value, thereby meeting the RFC specification.",success,
16969,bail_out_on_error,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC spec requires that a sender must not generate protocol elements or syntax alternatives reserved for other roles within a message. In the function_body provided, the code merely cleans the bucket brigade, creates an error bucket, appends an EOS bucket, and passes the brigade onward. There is no logic to verify or enforce that the protocol elements being generated conform only to those allowed for the sender's role. It does not check against or restrict protocol element generation based on the sender's role, which is the central requirement stated in the RFC spec. Therefore, no part of the function_body implements any labeled spec constraints.",success,
16969,bail_out_on_error,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function simply cleans up the bucket brigade, creates an error bucket and an EOS (end-of-stream) bucket, and passes the brigade onward. It does not contain any logic that verifies or enforces whether the generated protocol elements match the grammar as defined by the corresponding ABNF rules. In other words, there is no visible mechanism in this function for checking or ensuring that the output conforms to the spec constraint that a sender must only generate protocol elements that match the ABNF grammar. Hence, the function does not address the specified constraint.",success,
16970,keep_body_filter,"If a message is received without Transfer-Encoding and with an invalid Content-Length header field, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error, unless the field value can be successfully parsed as a comma-separated list (Section 5.6.1 of [HTTP]), all values in the list are valid, and all values in the list are the same (in which case, the message is processed with that single value used as the Content-Length field value).",201,Partially Matches,"[{'C5': {'code': 'if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01411)\n                  ""Invalid Content-Length \'%s\'"", lenp);\n    ap_remove_input_filter(f);\n    return bail_out_on_error(b, f, HTTP_REQUEST_ENTITY_TOO_LARGE);\n}', 'explanation': 'This code segment checks the Content-Length header by strictly parsing its value. If the value is not strictly valid (i.e. it does not conform to a well‐formed decimal number), it logs an error and bails out with an error response. This partially implements the RFC requirement that a received message without Transfer-Encoding and an invalid Content-Length header field must be treated as an unrecoverable error. However, the RFC also requires handling of a comma-separated list of identical valid values, and this logic is not present in the function.'}}]","The function attempts to enforce the RFC's requirement regarding an invalid Content-Length header by using a strict parse (ap_parse_strict_length) and bailing out on failure. This addresses part of the condition (invalid Content-Length header) as specified in the RFC, but it does not implement the additional logic required when a comma‐separated list of values is provided or check for the presence of Transfer-Encoding. Hence, the implementation in this function only partially matches the full specification.",success,
16970,keep_body_filter,"Since there is no predefined limit to the length of content, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows or precision loss due to integer conversion (Section 17.5).",261,Fully Matches,"[{'C1': {'code': 'if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01411)\n                  ""Invalid Content-Length \'%s\'"", lenp);\n\n    ap_remove_input_filter(f);\n    return bail_out_on_error(b, f, HTTP_REQUEST_ENTITY_TOO_LARGE);\n}', 'explanation': 'This segment verifies the Content-Length header value by calling ap_parse_strict_length, which (as noted in the comment) protects against overflows, non-digit characters, and improper values. This directly implements the requirement from the RFC to anticipate very large decimal numerals and prevent parsing errors due to integer conversion overflows or precision loss.'}}, {'A1': {'code': 'if (dconf->keep_body < ctx->remaining) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01412)\n              ""Requested content-length of %"" APR_OFF_T_FMT\n              "" is larger than the configured limit""\n              "" of %"" APR_OFF_T_FMT, ctx->remaining, dconf->keep_body);\n    ap_remove_input_filter(f);\n    return bail_out_on_error(b, f, HTTP_REQUEST_ENTITY_TOO_LARGE);\n}', 'explanation': 'This part ensures that if the parsed content-length exceeds the preset limit (dconf->keep_body), the function bails out with an error. This error handling aligns with the RFC’s requirement to safely handle message framing and large content lengths by preventing further processing that could lead to security or parsing issues.'}}]","The function inspects the Content-Length header value and uses a strict parsing function to ensure the number is within acceptable limits, thereby guarding against integer conversion overflows and precision loss. Furthermore, it performs a check against a configured maximum size, bailing out if the value is too large. These measures directly address the RFC requirement that recipients must be prepared to handle arbitrarily large decimal numerals and safely parse them.",success,
16970,keep_body_filter,"Since there is no predefined limit to the length of content, recipients MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows.",285,Fully Matches,"[{'C1': {'code': 'if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01411)\n                  ""Invalid Content-Length \'%s\'"", lenp);\n\n    ap_remove_input_filter(f);\n    return bail_out_on_error(b, f, HTTP_REQUEST_ENTITY_TOO_LARGE);\n}', 'explanation': 'This segment uses a strict parsing function (ap_parse_strict_length) to safely convert the Content-Length header from a decimal string to a numeric value, protecting against overflows and non-digit characters as required by the RFC.'}}, {'A1': {'code': 'if (dconf->keep_body < ctx->remaining) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01412)\n                  ""Requested content-length of %"" APR_OFF_T_FMT\n                  "" is larger than the configured limit""\n                  "" of %"" APR_OFF_T_FMT, ctx->remaining, dconf->keep_body);\n    ap_remove_input_filter(f);\n    return bail_out_on_error(b, f, HTTP_REQUEST_ENTITY_TOO_LARGE);\n}', 'explanation': 'This segment ensures that if the parsed Content-Length exceeds a predetermined limit (thereby handling potentially large numbers), the function logs an error and aborts processing, which is in line with the RFC requirement to prevent parsing errors due to large decimal numerals.'}}]","The function_body inspects the Content-Length header and employs a strict parsing function to convert the numeric string while preventing overflow and related parsing errors. It further verifies that the requested length does not exceed a configured limit, and if it does, it exits early with an error. Thus, the core requirements of the RFC concerning handling large decimal numerals and preventing integer conversion errors are visibly addressed within this function.",success,
16970,keep_body_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Fully Matches,"[{'C1': {'code': 'if (lenp) {\n    if (!ap_parse_strict_length(&ctx->remaining, lenp)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01411)\n                      ""Invalid Content-Length \'%s\'"", lenp);\n\n        ap_remove_input_filter(f);\n        return bail_out_on_error(b, f, HTTP_REQUEST_ENTITY_TOO_LARGE);\n    }\n    \n    if (dconf->keep_body < ctx->remaining) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01412)\n                  ""Requested content-length of %"" APR_OFF_T_FMT\n                  "" is larger than the configured limit""\n                  "" of %"" APR_OFF_T_FMT, ctx->remaining, dconf->keep_body);\n        ap_remove_input_filter(f);\n        return bail_out_on_error(b, f, HTTP_REQUEST_ENTITY_TOO_LARGE);\n    }\n}', 'explanation': 'The code retrieves the Content-Length header and uses ap_parse_strict_length to ensure that the value conforms to the expected numeric format. If parsing fails (indicating an incorrect or malformed Content-Length), it logs an error and aborts forwarding the message by calling bail_out_on_error, thereby fulfilling the requirement that a message with an incorrect Content-Length must not be forwarded.'}}, {'A1': {'code': 'if (APR_SUCCESS == rv && len > ctx->remaining) {\n    if (f->r->kept_body) {\n        apr_brigade_cleanup(f->r->kept_body);\n        f->r->kept_body = NULL;\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(01413)\n                  ""Requested content-length of %"" APR_OFF_T_FMT\n                  "" is larger than the configured limit""\n                  "" of %"" APR_OFF_T_FMT, len, ctx->keep_body);\n    return bail_out_on_error(b, f, HTTP_REQUEST_ENTITY_TOO_LARGE);\n}', 'explanation': 'After reading the data brigade, the code verifies that the actual byte count does not exceed the allowed limit. If it does, it again aborts the process. This defensive action ensures that the message is not forwarded with a mismatched framing.'}}]",The 'keep_body_filter' function implements the specified RFC constraint by ensuring that any Content-Length header value that is known to be incorrect (either due to failing strict numeric parsing or due to exceeding a configured limit) leads to the immediate termination of message handling. This is achieved by calling a bail-out function that prevents the message from being forwarded. The use of ap_parse_strict_length and subsequent error handling directly address the requirement that a sender MUST NOT forward a message with an incorrect Content-Length header field value.,success,
16971,kept_body_filter_init,"Any recipient along the request/response chain MAY decode the received transfer coding(s) or apply additional transfer coding(s) to the message body, assuming that corresponding changes are made to the Transfer-Encoding field value.",191,Fully Matches,"[{'C1': {'code': 'if (kept_body) {\n    apr_table_unset(r->headers_in, ""Transfer-Encoding"");\n    ...\n}', 'explanation': 'This segment removes the Transfer-Encoding header from the incoming headers, thereby ensuring that any changes in transfer coding are correctly reflected. This directly implements the requirement that corresponding changes be made to the Transfer-Encoding field as per the spec.'}}, {'A1': {'code': 'apr_brigade_length(kept_body, 1, &length);\napr_table_setn(r->headers_in, ""Content-Length"", apr_off_t_toa(r->pool, length));', 'explanation': 'This code computes the body length after processing (which may involve decoding or removal of transfer codings) and sets the Content-Length header accordingly. This fulfills the action of updating message metadata following any transfer coding changes.'}}]","The function checks if a processed (kept) message body exists and, if so, unsets the Transfer-Encoding header and sets the Content-Length header based on the computed message length. This precisely satisfies the HTTP RFC’s requirement that any transfer coding modifications must be accompanied by corresponding changes to the Transfer-Encoding field value.",success,
16971,kept_body_filter_init,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'if (kept_body) {\n    apr_table_unset(r->headers_in, ""Transfer-Encoding"");\n    ...\n}', 'explanation': 'This segment ensures that if there is a kept_body (i.e. content present), any existing Transfer-Encoding header is removed. This directly prevents a message from simultaneously having a Transfer-Encoding and a Content-Length header.'}}, {'A1': {'code': 'apr_brigade_length(kept_body, 1, &length);\napr_table_setn(r->headers_in, ""Content-Length"", apr_off_t_toa(r->pool, length));', 'explanation': 'After unsetting the Transfer-Encoding header, the function computes the length of the kept_body and sets the Content-Length header to this value. This implements the action of providing framing information only when Transfer-Encoding is not present.'}}]","The function explicitly checks for the presence of a kept body, and when found, it unsets the Transfer-Encoding header before computing and setting the Content-Length header. This logic directly implements the RFC requirement that a sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header. Thus, the function fully meets the specified constraints within its body.",success,
16971,kept_body_filter_init,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'A1': {'code': 'if (kept_body) {\n    apr_table_unset(r->headers_in, ""Transfer-Encoding"");\n    apr_brigade_length(kept_body, 1, &length);\n    apr_table_setn(r->headers_in, ""Content-Length"", apr_off_t_toa(r->pool, length));\n}', 'explanation': 'This segment removes the Transfer-Encoding header and sets a singular Content-Length header based on the calculated body length. In doing so, it attempts to prevent conflicting message framing headers (which could be interpreted as avoiding multiple field lines for related headers) as required by the RFC. However, it does not handle all aspects of the RFC—specifically, it does not verify or merge multiple header fields with the same name or manage the ordering of headers—so it only partially meets the overall constraint.'}}]","The RFC specifies that messages should not contain duplicate header lines unless allowed by the header's definition and that the ordering of such headers is significant. The function adjusts headers by unsetting Transfer-Encoding and setting a Content-Length header based on the kept body. This addresses the need to avoid conflicting framing information but does not fully cover scenarios involving multiple instances of the same header field or the preservation of header order. Thus, within its isolated context, the function only partially implements the specified RFC requirements.",success,
16971,kept_body_filter_init,"It MUST conform to the field-name syntax defined in Section 5.1, and it SHOULD be restricted to just letters, digits, and hyphen ('-') characters, with the first character being a letter.",293,Does Not Match,[],"The provided function does not contain any logic that verifies or enforces the field-name syntax requirements given in the RFC specification. Although it manipulates header fields by unsetting ""Transfer-Encoding"" and setting ""Content-Length"", these are hardcoded string literals that are assumed to be valid. The function does not validate that a requested field name (as described in the spec and sr_context) conforms to the syntax (i.e., starting with a letter and containing only letters, digits, and hyphens). Therefore, no part of the function visibly implements any of the labeled conditions (e.g., C1) or actions (e.g., A1) from the spec constraints.",success,
16971,kept_body_filter_init,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'A1': {'code': 'if (kept_body) {\n    apr_table_unset(r->headers_in, ""Transfer-Encoding"");\n    apr_brigade_length(kept_body, 1, &length);\n    apr_table_setn(r->headers_in, ""Content-Length"", apr_off_t_toa(r->pool, length));\n}', 'explanation': 'This code block clears any Transfer-Encoding header, computes the known content length from the kept body, and then sets the Content-Length header accordingly. This directly addresses the action of sending a Content-Length header when the content size is known and Transfer-Encoding is absent.'}}]","The RFC requires that in the absence of Transfer-Encoding, if the content size is known, a Content-Length header SHOULD be sent. This function addresses that by unsetting the Transfer-Encoding header and calculating then setting the Content-Length header. However, the RFC and its context also specify cases (such as for 1xx, 204 responses, or CONNECT requests) where the Content-Length header must not be sent. This function does not check those additional conditions, so while it does implement part of the specification, it does not fully cover all aspects as mandated by the RFC.",success,
16971,kept_body_filter_init,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_in, ""Content-Length"", apr_off_t_toa(r->pool, length));', 'explanation': 'The function recalculates the length of the kept_body and then unconditionally replaces the Content-Length header field with this computed value. This acts as a replacement of a potentially duplicate or invalid header value, which partially addresses the RFC’s requirement to not forward a message with an incorrect Content-Length header.'}}]","The RFC specifies that a sender MUST NOT forward a message with a Content-Length header field value known to be incorrect, and for duplicate comma-separated values, the sender may replace the invalid field with a single instance. The code function does recalculate the body length using apr_brigade_length and resets the Content-Length header, effectively replacing an existing value with a computed one. However, it does not perform explicit checks for duplicate values or stringent ABNF compliance. Thus, while the function contains logic that attempts to enforce part of the specification (i.e., correcting the Content-Length header), it does not fully implement all aspects of the precaution described in the RFC.",success,
16971,kept_body_filter_init,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Partially Matches,"[{'A1': {'code': 'if (kept_body) {\n    apr_table_unset(r->headers_in, ""Transfer-Encoding"");\n    ...\n}', 'explanation': 'The code unconditionally removes the Transfer-Encoding header when a kept body exists. This is an attempt to enforce the use of length-delimited framing as recommended by the RFC.'}}, {'A2': {'code': 'apr_brigade_length(kept_body, 1, &length);\napr_table_setn(r->headers_in, ""Content-Length"", apr_off_t_toa(r->pool, length));', 'explanation': 'The code calculates the body length from the kept_body brigade and sets the Content-Length header accordingly. This implements a length-delimited message which is preferred in the spec.'}}]","The function partially implements the RFC requirement that a server SHOULD generate encoding or length-delimited messages whenever possible. It explicitly removes the Transfer-Encoding header and sets a Content-Length header based on the calculated body length if a kept_body exists. However, the function does not cover other aspects of the spec (such as error handling for invalid Content-Length values or conditions when no kept_body exists), meaning it only partially meets the overall spec constraints within its own logic.",success,
16978,set_kept_body_size,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (APR_SUCCESS != apr_strtoff(&(conf->keep_body), arg, &end, 10) || conf->keep_body < 0 || *end) {\n        return ""KeptBodySize must be a valid size in bytes, or zero."";\n    }', 'explanation': 'This code segment attempts defensive parsing by converting the input string using apr_strtoff and then verifying that the conversion succeeded, that the number is non-negative, and that no unexpected extra characters remain in the input.'}}]","The RFC specification requires that a recipient should parse received protocol elements defensively, only assuming marginal conformance to its grammar and reasonable lengths. The provided function makes an effort to defensively parse a size value by converting the string and validating the result. However, it does this only for one particular numeric configuration value and does not address other broader aspects mentioned (like buffer size considerations in general HTTP elements). Therefore, while the function addresses part of the specification (defensive parsing of a numeric element), it only partially implements the overall spirit of the requirement.",success,
17065,check_gzip,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Partially Matches,"[{'A1': {'code': 'if (!ap_cstr_casecmp(encoding, ""gzip"") || !ap_cstr_casecmp(encoding, ""x-gzip"")) {\n    found = 1;\n    if (hdrs) {\n        apr_table_unset(hdrs, ""Content-Encoding"");\n    } else {\n        r->content_encoding = NULL;\n    }\n}', 'explanation': ""This code segment removes the 'Content-Encoding' header when its value is 'gzip' or 'x-gzip'. This removal action is in line with preventing the generation of protocol elements that the sender should not produce, which relates to the RFC requirement. However, the function does not explicitly check the sender's role or cover all protocol element grammar and role constraints, so the match is only partial.""}}]","The function attempts to enforce part of the RFC rule by stripping out disallowed 'Content-Encoding' values (gzip or x-gzip) so that the sender does not inadvertently generate protocol elements reserved for other roles. While this removal partially implements the requirement that a sender must not generate such protocol elements, the function does not perform a full role check or address all aspects (such as validating protocol grammar), resulting in a partial match with the specified constraints.",success,
17065,check_gzip,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (encoding && *encoding) {\n    /* check the usual/simple case first */\n    if (!ap_cstr_casecmp(encoding, ""gzip"")\n        || !ap_cstr_casecmp(encoding, ""x-gzip"")) {\n        found = 1;\n        if (hdrs) {\n            apr_table_unset(hdrs, ""Content-Encoding"");\n        }\n        else {\n            r->content_encoding = NULL;\n        }\n    }\n    else if (ap_strchr_c(encoding, \',\') != NULL) {\n        /* ... looping to check each token ... */\n        for(;;) {\n            char *token = ap_strrchr(new_encoding, \',\');\n            if (!token) {\n                if (!ap_cstr_casecmp(new_encoding, ""gzip"")\n                    || !ap_cstr_casecmp(new_encoding, ""x-gzip"")) {\n                    found = 1;\n                    if (hdrs) {\n                        apr_table_unset(hdrs, ""Content-Encoding"");\n                    }\n                    else {\n                        r->content_encoding = NULL;\n                    }\n                }\n                break;\n            }\n            /* ... trimming of tokens and further checks ... */\n            if (!ap_cstr_casecmp(ptr, ""gzip"")\n                || !ap_cstr_casecmp(ptr, ""x-gzip"")) {\n                *token = \'\\0\';\n                if (hdrs) {\n                    apr_table_setn(hdrs, ""Content-Encoding"", new_encoding);\n                }\n                else {\n                    r->content_encoding = new_encoding;\n                }\n                found = 1;\n            }\n            else if (!ptr[0] || !ap_cstr_casecmp(ptr, ""identity"")) {\n                *token = \'\\0\';\n                continue;\n            }\n            break;\n        }\n    }\n}', 'explanation': ""This segment checks the Content-Encoding header to verify if it matches the allowed tokens ('gzip' or 'x-gzip') and then removes or adjusts the header accordingly. By doing so, it attempts to ensure that generated protocol elements adhere to the permitted tokens, which is a partial implementation of the requirement to not generate protocol elements that do not match the ABNF grammar.""}}]","The RFC requires that a sender not generate protocol elements that deviate from the ABNF grammar. This function partially addresses that requirement by comparing the 'Content-Encoding' header against expected token values ('gzip' and 'x-gzip') and adjusting the header if a match is found or if multiple tokens are present. However, it only handles a subset of potential protocol element errors (specifically related to the gzip encoding) rather than fully validating the entire header against the complete ABNF grammar. Therefore, while the function implements some logic intended to enforce protocol correctness, it only partially meets the full specification.",success,
17065,check_gzip,"A recipient SHOULD consider ""x-gzip"" to be equivalent to ""gzip"".",41,Fully Matches,"[{'C1': {'code': 'if (!ap_cstr_casecmp(encoding, ""gzip"")\n            || !ap_cstr_casecmp(encoding, ""x-gzip"")) {\n            found = 1;\n            if (hdrs) {\n                apr_table_unset(hdrs, ""Content-Encoding"");\n            } else {\n                r->content_encoding = NULL;\n            }\n        }\n        \n        ...\n\n        else if (ap_strchr_c(encoding, \',\') != NULL) {\n            char *new_encoding = apr_pstrdup(r->pool, encoding);\n            char *ptr;\n            for(;;) {\n                char *token = ap_strrchr(new_encoding, \',\');\n                if (!token) {\n                    if (!ap_cstr_casecmp(new_encoding, ""gzip"")\n                        || !ap_cstr_casecmp(new_encoding, ""x-gzip"")) {\n                        found = 1;\n                        if (hdrs) {\n                            apr_table_unset(hdrs, ""Content-Encoding"");\n                        } else {\n                            r->content_encoding = NULL;\n                        }\n                    }\n                    break;\n                }\n                for (ptr = token + 1; apr_isspace(*ptr); ++ptr);\n                if (!ap_cstr_casecmp(ptr, ""gzip"")\n                    || !ap_cstr_casecmp(ptr, ""x-gzip"")) {\n                    *token = \'\\0\';\n                    if (hdrs) {\n                        apr_table_setn(hdrs, ""Content-Encoding"", new_encoding);\n                    } else {\n                        r->content_encoding = new_encoding;\n                    }\n                    found = 1;\n                } else if (!ptr[0] || !ap_cstr_casecmp(ptr, ""identity"")) {\n                    *token = \'\\0\';\n                    continue;\n                }\n                break;\n            }\n        }', 'explanation': 'This code explicitly checks for both ""gzip"" and ""x-gzip"" in the Content-Encoding header. It treats them equivalently by applying identical handling (either unsetting the header or setting it to NULL). This fulfills the RFC requirement that a recipient SHOULD consider ""x-gzip"" the same as ""gzip"".'}}]","The function 'check_gzip' inspects the Content-Encoding header and performs a case-insensitive comparison against both ""gzip"" and ""x-gzip"". In both simple and comma-separated header cases, the code identifies these encodings as equivalent. Therefore, the function independently implements the RFC requirement as specified.",success,
17076,deflate_set_inflate_limit,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (APR_SUCCESS != apr_strtoff(&dc->inflate_limit, arg, &errp, 10)) {\n    return ""DeflateInflateLimitRequestBody is not parsable."";\n}', 'explanation': ""This segment defensively attempts to parse the input ('arg') using apr_strtoff and returns an error if the conversion fails, addressing the need to not blindly trust the incoming protocol element.""}}, {'A1': {'code': 'if (*errp || dc->inflate_limit < 0) {\n    return ""DeflateInflateLimitRequestBody requires a non-negative integer."";\n}', 'explanation': 'This part further checks that no unexpected characters remain after parsing and that the resulting integer is non-negative, reinforcing defensive handling of input values.'}}]","The provided function demonstrates defensive parsing by converting the received string into an integer and validating its format and value. It returns explicit error messages when the conversion fails or when extra characters or negative values are detected. While this meets the defensive parsing aspect of the RFC specification, the function does not explicitly address arguments related to buffer size constraints. As a result, it only partially matches the overall requirements outlined in the context of the spec.",success,
17085,deflate_out_filter,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,61,Partially Matches,"[{'C1': {'code': 'if (r->header_only && r->bytes_sent) {\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}', 'explanation': 'This code branch checks if the request is a HEAD request (using r->header_only) and if some data has already been sent (r->bytes_sent), then it removes the compression filter and passes the brigade unchanged. This is an attempt to avoid sending body content in a HEAD response.'}}]","The specification mandates that the HEAD method should behave like GET but must not transmit content. In this function, there is a check for HEAD requests (using r->header_only) that stops further processing if some data has already been sent, which partially addresses the RFC requirement. However, because the check only triggers when r->bytes_sent is nonzero, the function does not fully guarantee that no body content is transmitted for HEAD requests under all circumstances. Thus, the implementation only partially meets the RFC's requirements as manifested solely in this function.",success,
17085,deflate_out_filter,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'C1': {'code': 'if (!encoding || !ap_cstr_casecmp(encoding, ""identity"")) {\n    apr_table_setn(r->headers_out, ""Content-Encoding"", ""gzip"");\n} else {\n    apr_table_mergen(r->headers_out, ""Content-Encoding"", ""gzip"");\n}', 'explanation': ""This code fragment ensures that if a Content-Encoding is already set and is not simply the 'identity' value, the new encoding (gzip) is merged into the header field. It combines values into a comma‐separated list rather than generating duplicate header lines, which is in line with the RFC requirement that a sender must not generate multiple header fields unless the field definition allows values to be combined.""}}]","The function is primarily used for output compression and in the process modifies certain response headers. In doing so it explicitly handles the Content-Encoding header. When no encoding or an 'identity' encoding is present, it sets the header directly; but if an encoding is already present, it merges the encoding value with 'gzip', so that multiple values are combined as a comma-separated list. This approach adheres to the RFC requirement (C1) regarding multiple header field values. However, the code does not explicitly address the ordered receipt of header lines (as mentioned in the spec context) nor does it deal with other headers that might be affected by these restrictions. Thus, the function partially matches the RFC constraints.",success,
17085,deflate_out_filter,An origin server SHOULD generate a Vary header field on a cacheable response when it wishes that response to be selectively reused for subsequent requests.,96,Fully Matches,"[{'A1': {'code': 'apr_table_mergen(r->headers_out, ""Vary"", ""Accept-Encoding"");', 'explanation': ""This line of code explicitly adds (merges) the 'Vary' header with the value 'Accept-Encoding' into the response headers. This ensures that caches are informed that the response may vary based on the 'Accept-Encoding' request header, which aligns with the RFC requirement for selectively reusing a cacheable response.""}}]","The provided function, which handles compression for HTTP responses, contains logic that adds a 'Vary: Accept-Encoding' header when appropriate (as seen in the apr_table_mergen call). This directly addresses the RFC mandate that an origin server SHOULD generate a Vary header on cacheable responses to indicate that they can be selectively reused based on request headers. Since this header modification is implemented directly within the function_body (and not deferred to dependencies), the function fully meets the relevant RFC constraint.",success,
17085,deflate_out_filter,"If a non-empty Accept-Encoding header field is present in a request and none of the available representations for the response have a content coding that is listed as acceptable, the origin server SHOULD send a response without any content coding unless the identity coding is indicated as unacceptable.",94,Partially Matches,"[{'C1': {'code': 'accepts = apr_table_get(r->headers_in, ""Accept-Encoding"");\nif (accepts == NULL) {\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}\n...\ntoken = ap_get_token(r->pool, &accepts, 0);\nwhile (token && token[0] && ap_cstr_casecmp(token, ""gzip"")) {\n    /* skip parameters */\n    while (*accepts == \';\') {\n        ++accepts;\n        ap_get_token(r->pool, &accepts, 1);\n    }\n    if (*accepts == \',\') {\n        ++accepts;\n    }\n    token = (*accepts) ? ap_get_token(r->pool, &accepts, 0) : NULL;\n}\nif (!token || token[0] == \'\\0\' || (q && strlen(q) >= 3 && strncmp(""q=0.000"", q, strlen(q)) == 0)) {\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                  ""Not compressing (no Accept-Encoding: gzip or q=0)"");\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}\n', 'explanation': ""The function examines the 'Accept-Encoding' header, and only proceeds with compression if 'gzip' is accepted with a non-zero qvalue. Otherwise, it removes the compression filter and sends the response uncompressed.""}}]","The function partially implements the HTTP RFC requirement by checking for a non-empty 'Accept-Encoding' header and ensuring that 'gzip' is acceptable. When it is not (i.e. when 'gzip' isn’t found or is assigned q=0), the function removes the compression filter and sends the response without any content coding. However, the function does not address the additional clause of the spec that states the origin server SHOULD send the response without any content coding only if the identity coding is not indicated as unacceptable. Since there is no specific check for the 'identity' coding being unacceptable, the implementation only partially meets the specification.",success,
17085,deflate_out_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Fully Matches,"[{'A1': {'code': 'apr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'The function removes the Content-Length header from the outgoing response before passing the brigade along. This ensures that an incorrect or mismatched Content-Length (if present) is never forwarded, thereby implementing the RFC requirement that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.'}}]","By unsetting the Content-Length header (and also the Content-MD5 header) prior to forwarding the response, the function ensures that no potentially incorrect Content-Length value is present in the message. This directly adheres to the spec's mandate, and as such, the function visibly addresses the constraint entirely within its own logic.",success,
17085,deflate_out_filter,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Partially Matches,"[{'A1': {'code': 'apr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'In the branch where compression is applied (i.e. for responses other than 1xx/204/304), the function explicitly unsets the Content-Length header. This shows an attempt to prevent sending a Content-Length header as required. However, for responses with a 204 status (and by extension, 1xx responses are not handled here), the filter bails out early without modifying the headers.'}}]","The RFC states that a server MUST NOT send a Content-Length header field in any response with a status code of 1xx or 204. In this function, when compression is performed the code unsets the Content-Length header, which addresses the requirement for the responses that are processed by this filter. However, for 204 responses (and similarly for 1xx responses, though not explicitly checked), the function avoids processing the content (by removing the filter and passing the brigade along) and does not explicitly remove the Content-Length header. Therefore, the function only partially addresses the RFC specification on its own.",success,
17085,deflate_out_filter,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,44,Partially Matches,"[{'A1': {'code': 'apr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'The function removes the Content-Length header unconditionally before sending the response. This prevents sending an incorrect Content-Length value (as required by the spec for 304 or HEAD responses) but does not compute and emit the correct value when it might be allowed. Thus it partially meets the RFC requirement of not sending a Content-Length header unless its value is correctly set.'}}]","The RFC says that a server may send a Content-Length header for 304 responses or for HEAD requests only when its value equals the number of octets that would be sent in a GET request. In this filter function, the Content-Length header is always removed (and never recalculated) as seen in the call to apr_table_unset on 'Content-Length'. Additionally, there is early exit logic for HEAD requests and 304 responses. Although this ensures that an incorrect Content-Length is not sent, the filter does not attempt to compute the correct value per the RFC. Therefore, only part of the requirement is addressed by this function, leading to a 'Partially Matches' judgment.",success,
17085,deflate_out_filter,A server MAY send a Content-Length header field in a response to a HEAD request (Section 9.3.2); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a response if the same request had used the GET method.,43,Fully Matches,"[{'C1': {'code': 'if (r->header_only && r->bytes_sent) {\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}', 'explanation': ""This check ensures that for HEAD responses where some bytes have already been sent, further compression (and consequently any Content-Length computation) is bypassed. This is consistent with the RFC’s requirement to avoid sending a Content-Length header that does not exactly match the GET method's response body size.""}}, {'A1': {'code': 'apr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'Unconditionally unsetting the Content-Length header ensures that the server does not send a Content-Length header in the response, which complies with the RFC mandate for HEAD responses unless the value exactly matches what would be sent in a GET response.'}}]","The function explicitly removes the Content-Length header from the response and bypasses further compression for HEAD requests with previously sent bytes, ensuring that the server does not send an incorrect Content-Length header. This direct handling inside the function meets the RFC specification concerning HEAD responses.",success,
17085,deflate_out_filter,"Note that the coding named ""identity"" is reserved for its special role in Accept-Encoding and thus SHOULD NOT be included.",38,Fully Matches,"[{'C1': {'code': 'if (encoding) {\n    const char *tmp = encoding;\n\n    token = ap_get_token(r->pool, &tmp, 0);\n    while (token && *token) {\n        /* stolen from mod_negotiation: */\n        if (strcmp(token, ""identity"") && strcmp(token, ""7bit"") &&\n            strcmp(token, ""8bit"") && strcmp(token, ""binary"")) {\n            ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                          ""Not compressing (content-encoding already set: %s)"", token);\n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n        if (*tmp) {\n            ++tmp;\n        }\n        token = (*tmp) ? ap_get_token(r->pool, &tmp, 0) : NULL;\n    }\n}', 'explanation': ""This segment checks existing Content-Encoding tokens and ensures that if any encoding other than the allowed ones (including the reserved 'identity') is already specified, compression is skipped. This satisfies the RFC requirement that the 'identity' coding is not included as a compressible alternative.""}}, {'A1': {'code': 'if (!encoding || !ap_cstr_casecmp(encoding, ""identity"")) {\n    apr_table_setn(r->headers_out, ""Content-Encoding"", ""gzip"");\n} else {\n    apr_table_mergen(r->headers_out, ""Content-Encoding"", ""gzip"");\n}', 'explanation': ""This segment sets the Content-Encoding header to 'gzip', either by replacing the current value when there is no encoding or when it is 'identity', or by merging it. This adheres to the specification requiring the sender to list the applied content codings for the compressed representation.""}}]","The function implements the core logic for applying gzip compression in accordance with the HTTP RFC. It first verifies that the output is eligible for compression, then checks whether any Content-Encoding is already set (while ensuring that reserved codings like 'identity' are treated appropriately). Afterward, it updates the Content-Encoding header to include 'gzip'. By handling both the detection of pre-existing encodings and the proper setting of the header, the function fully addresses the relevant RFC constraints within its body.",success,
17085,deflate_out_filter,"If one or more encodings have been applied to a representation, the sender that applied the encodings MUST generate a Content-Encoding header field that lists the content codings in the order in which they were applied.",37,Fully Matches,"[{'A1': {'code': 'if (!encoding || !ap_cstr_casecmp(encoding, ""identity"")) {\n    apr_table_setn(r->headers_out, ""Content-Encoding"", ""gzip"");\n}\nelse {\n    apr_table_mergen(r->headers_out, ""Content-Encoding"", ""gzip"");\n}', 'explanation': ""This segment directly addresses the RFC requirement by ensuring that when gzip encoding is applied, the Content-Encoding header is generated with 'gzip'. If no encoding or 'identity' is present, the header is set to 'gzip'; otherwise, 'gzip' is merged (appended) to existing encodings. This ordering meets the spec's mandate to list applied codings in the order of their application.""}}]","The function implements the necessary logic to satisfy the RFC requirement by properly generating the Content-Encoding header. It inspects any pre-existing encoding values and either replaces or merges them with 'gzip', effectively listing the content codings in the order they were applied. This logic is contained entirely within the function_body and fully meets the spec constraint.",success,
17087,deflate_in_filter,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Partially Matches,"[{'C1': {'code': 'if (ctx->header[0] != deflate_magic[0] ||\n    ctx->header[1] != deflate_magic[1]) {\n    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01387)\n                  ""Zlib: Invalid header"");\n    return APR_EGENERAL;\n}\n\nctx->zlib_flags = ctx->header[3];\nif ((ctx->zlib_flags & RESERVED)) {\n    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01388)\n                  ""Zlib: Invalid flags %02x"", ctx->zlib_flags);\n    return APR_EGENERAL;\n}', 'explanation': 'The function checks that the incoming deflate header matches expected magic bytes and that the zlib flags do not include reserved bits. This is an attempt to enforce that protocol elements (in this case, the compressed header) conform to the expected grammar as required by the spec.'}}]","The provided function implements portions of the required validation by ensuring that the compressed data header adheres to expected format (i.e. matching magic bytes and valid flag values). This verifies a subset of the grammar constraints described in the RFC. However, the spec’s mandate applies to a sender generating protocol elements, and this filter is primarily an input (decompression) function rather than a sender element generator. Therefore, while it does include logic to enforce correct protocol form, it only partially matches the full intent of the RFC requirement.",success,
17087,deflate_in_filter,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, deflate_in_filter, primarily implements decompression (inflate) logic for deflated HTTP request bodies. It handles reading input buckets, managing zlib state, and error reporting for decompression issues. However, it does not contain any logic that addresses the RFC requirement stating that a sender MUST NOT generate protocol elements or syntax alternatives reserved for a different role. There is no visible implementation within this function that checks or prevents the generation of such protocol elements. Therefore, the function does not implement the labeled condition or action described in the spec.",success,
17087,deflate_in_filter,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'do {\n    apr_brigade_cleanup(ctx->bb);\n    len = sizeof(ctx->header) - ctx->header_len;\n    rv = ap_get_brigade(f->next, ctx->bb, AP_MODE_READBYTES, block, len);\n    ...\n    rv = apr_brigade_flatten(ctx->bb, ctx->header + ctx->header_len, &len);\n    if (rv != APR_SUCCESS) { return rv; }\n    ctx->header_len += len;\n} while (ctx->header_len < sizeof(ctx->header));\n\nif (ctx->header[0] != deflate_magic[0] || ctx->header[1] != deflate_magic[1]) {\n    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01387) ""Zlib: Invalid header"");\n    return APR_EGENERAL;\n}', 'explanation': 'This segment shows that the function reads the protocol element incrementally and checks that the header conforms (via magic byte comparison). This defensive parsing approach aligns with the RFC suggestion of handling input with only marginal assumptions about conformance.'}}, {'A1': {'code': 'if (inflate_limit && ctx->inflate_total > inflate_limit) { \n    inflateEnd(&ctx->stream);\n    ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02647) ""Inflated content length of %"" APR_OFF_T_FMT "" is larger than the configured limit of %"" APR_OFF_T_FMT, ctx->inflate_total, inflate_limit);\n    return APR_ENOSPC;\n}\n\n...\n\nif (ctx->validation_buffer) {\n    ...\n    compCRC = getLong(buf);\n    if (ctx->crc != compCRC) {\n        inflateEnd(&ctx->stream);\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01394) ""Zlib: CRC error inflating data"");\n        return APR_EGENERAL;\n    }\n    compLen = getLong(buf + VALIDATION_SIZE / 2);\n    if ((ctx->stream.total_out & 0xFFFFFFFF) != compLen) {\n        inflateEnd(&ctx->stream);\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(01395) ""Zlib: Length %"" APR_UINT64_T_FMT "" of inflated data does not match expected value %ld"", (apr_uint64_t)ctx->stream.total_out, compLen);\n        return APR_EGENERAL;\n    }\n}', 'explanation': 'This code enforces limits on inflated content and validates the resulting data using a CRC and length check. These checks are defensive measures to ensure the decompressed data remains within reasonable bounds, as recommended by the RFC.'}}]","The function implements defensive parsing in line with the RFC’s requirement. It cautiously reads and validates protocol elements (by checking header magic numbers) and further ensures that buffer sizes and inflated content remain within configured limits. Additionally, it performs CRC and length validations to handle potential nonconformities in the input data. All these measures are implemented within the function itself, satisfying the spec constraints.",success,
17087,deflate_in_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'if (len && !ctx->header_len) {\n    apr_table_unset(r->headers_in, ""Content-Length"");\n    apr_table_unset(r->headers_in, ""Content-MD5"");\n}', 'explanation': 'This snippet unsets the Content-Length header early in the processing of a compressed request. By removing the header (and also the Content-MD5), it prevents an incorrect Content-Length value from being forwarded. This is in line with the RFC’s mandate that a sender must not forward a message with an incorrect Content-Length. However, the function does not perform any explicit validation of the header value (for example checking against the ABNF or handling the duplicate comma-separated case), so it only partially addresses the full requirements described in the spec.'}}]","The deflate_in_filter function makes an effort to prevent forwarding an incorrect Content-Length header by unsetting it before processing the incoming data. This behavior addresses part of the RFC specification (namely, the action to not forward a known incorrect header). However, the function does not fully implement all aspects of the spec, such as validating the header against the ABNF or handling specific exceptions (for instance, a duplicate comma‐separated Content-Length value). Consequently, while the function incorporates a relevant measure, it only partially matches the complete set of constraints outlined in the specification.",success,
17087,deflate_in_filter,A server MUST ignore a Content-Range header field received in a request with a method for which Content-Range support is not defined.,135,Fully Matches,"[{'C1': {'code': 'if (apr_table_get(r->headers_in, ""Content-Range"") != NULL) {\n                ap_remove_input_filter(f);\n                return ap_get_brigade(f->next, bb, mode, block, readbytes);\n            }', 'explanation': ""This segment directly checks for the presence of a 'Content-Range' header in the incoming request. If found, it removes the input filter and bypasses further processing, effectively ignoring the Content-Range header as mandated by the RFC.""}}]","The function 'deflate_in_filter' includes a clear check for the 'Content-Range' header in the request headers. When the header is detected, the corresponding input filter is removed and the request processing continues without attempting any special handling of the Content-Range header. This logic aligns with the RFC specification that a server must ignore a Content-Range header field when received with a method for which support is not defined.",success,
17088,inflate_out_filter,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The target function, inflate_out_filter, is focused on decompressing content, adjusting headers (such as unsetting Content-Length and Content-MD5), and validating the integrity of the decompressed stream. However, it does not contain any logic that directly addresses the RFC specification that requires a sender to refrain from generating protocol elements or syntax alternatives reserved for other roles. There is no explicit check or handling in this function to prevent the generation of protocol elements by a sender in a role it does not have. Thus, the function does not implement the specific RFC constraint by itself.",success,
17088,inflate_out_filter,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (ctx->header[0] != deflate_magic[0] ||\n    ctx->header[1] != deflate_magic[1]) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01405)\n                      ""inflate: bad header"");\n        return APR_EGENERAL;\n    }', 'explanation': 'This segment verifies the first two bytes of the header against the expected deflate magic numbers. This is a defensive check that ensures the received protocol element conforms to basic structural expectations.'}}, {'A1': {'code': 'if (len > APR_INT32_MAX) {\n    apr_bucket_split(e, APR_INT32_MAX);\n    apr_bucket_read(e, &data, &len, APR_BLOCK_READ);\n}', 'explanation': 'This code protects against oversized buckets by splitting them if the length exceeds a reasonable limit, showing a defensive approach to buffer size handling.'}}]","The function 'inflate_out_filter' implements several defensive parsing techniques such as checking the header signature and managing unusually large input lengths; these align with the RFC's recommendation that a recipient should parse protocol elements with minimal expectations and verify their conformance. However, while key defensive checks (labeled here as C1 and A1) are present, the function does not address every aspect of the specification (for example, handling of full ABNF grammar validation or a more complete verification of reasonable limits) solely within its code. Therefore, the implementation partially matches the spec constraints.",success,
17088,inflate_out_filter,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,44,Partially Matches,"[{'C1': {'code': 'if (r->status == HTTP_NOT_MODIFIED) {\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}', 'explanation': 'This conditional block checks for a 304 (Not Modified) response and then immediately removes the output filter, causing the response (and its headers) to be passed along without further processing. This ensures that any Content-Length header is not inadvertently maintained or added later in the processing chain.'}}, {'A1': {'code': 'apr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'By unsetting the Content-Length header before any output processing, the function prevents sending an incorrect or non‐validated Content-Length header in 304 responses, which aligns with the RFC requirement that no Content-Length should be sent unless it equals the actual content length of a 200 OK response.'}}]","The function contains visible logic aimed at handling responses with a 304 status. It explicitly unsets the Content-Length header and, upon detecting a 304 response, bypasses further content processing. This meets part of the RFC requirement by ensuring that a Content-Length header is not sent when it might not correctly reflect the content of a 200 (OK) response. However, it does not implement the additional logic required to conditionally include a valid Content-Length header (i.e. when its value precisely equals the number of octets that would have been sent with a 200 OK response). As such, the function only partially matches the full RFC specification regarding Content-Length header handling in 304 responses.",success,
17088,inflate_out_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'apr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'This code segment removes the Content-Length header, which prevents forwarding an incorrect Content-Length value. This action corresponds with the requirement that a sender must not forward a message with a known incorrect Content-Length header field value.'}}]","The function addresses part of the RFC requirement by unsetting the Content-Length header, thereby avoiding the forwarding of an incorrect value. However, it does not perform any explicit validation of the Content-Length header value nor does it handle cases like comma-separated duplicate values. Since only the removal action is implemented within this function (and no further checks or transformations related to the Content-Length field are visible), the implementation only partially matches the specified constraint.",success,
17088,inflate_out_filter,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Partially Matches,"[{'A1': {'code': 'apr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'In the main filtering branch (for compressible responses), the function unsets the Content-Length header, which is in line with the RFC requirement not to send it when content modifications (such as compression) occur.'}}, {'C1': {'code': 'if (!ap_is_initial_req(r) || (r->status == HTTP_NO_CONTENT) || ... ) {\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}', 'explanation': 'The function checks for a 204 (No Content) response and bypasses the compression logic by removing the filter. However, it does not explicitly unset the Content-Length header in this case. Moreover, there is no explicit handling for 1xx (Informational) responses within the function.'}}]","The RFC requires that a server MUST NOT send a Content-Length header in responses with a 1xx or 204 status. The function does remove the Content-Length header when it processes responses for compression (A1), but for 204 responses (and by extension 1xx, which are not explicitly checked), it exits early without unsetting the header. As the logic to remove the header is only applied in part of the processing flow, the implementation only partially matches the RFC constraint.",success,
17094,normalise,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Partially Matches,"[{'C1': {'code': 'if (flags & NORM_LC)\n    for (p = str; *p; ++p)\n        if (isupper(*p))\n            *p = tolower(*p);', 'explanation': 'This segment converts all uppercase characters to lowercase, which is one method of normalization applicable to HTTP URIs.'}}, {'A1': {'code': ""if (flags & NORM_MSSLASH)\n    for (p = ap_strchr(str, '\\\\'); p; p = ap_strchr(p+1, '\\\\'))\n        *p = '/';"", 'explanation': 'This segment replaces backslashes with forward slashes, supporting normalization of URI separators.'}}]","The provided function implements two normalization steps: converting to lowercase (addressing case normalization) and replacing backslashes with forward slashes (addressing separator normalization). These actions partially address the HTTP RFC specification that allows normalization of URIs. However, since the RFC refers to URI equivalence after any normalization method and the function does not handle other normalization aspects (such as percent-encoding, default ports, or path resolution), the implementation only partially matches the overall intent of the specification.",success,
17099,pinternalSubset,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function 'pinternalSubset' does not contain any logic that checks or enforces the requirement that a sender must not generate protocol elements that should only be generated by other roles. While it produces a DOCTYPE declaration based on configuration and external identifiers, it does not verify whether the sender is authorized to generate these elements according to the RFC. No code segments can be directly mapped to the requirement, so the function does not visibly address the labeled constraint.",success,
17104,metafix,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function 'metafix' parses meta tags from an HTML buffer and conditionally extracts header and content information, adding corresponding HTTP header entries. However, there is no visible logic that checks or enforces that the generated protocol elements (headers in this case) are only those allowed for the sender's role as specified in the RFC. In other words, the function does not implement any condition checks against the constraint that a sender must not generate protocol elements reserved for other roles. Therefore, it does not address the labeled spec requirement, and the outcome is 'Does Not Match'.",success,
17104,metafix,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'while (offs < len &&\n       !ap_regexec_len(seek_meta, buf + offs, len - offs, 2, pmatch, 0)) {\n    ...\n    offs += pmatch[0].rm_eo;\n}', 'explanation': ""This loop uses the provided buffer length (len) when scanning for protocol elements and employs a regex (ap_regexec_len) with an explicit length limit. This shows an attempt to parse defensively by not reading beyond the provided buffer. However, subsequent pointer arithmetic (e.g., inner loops like 'while (!apr_isalpha(*++p));') does not explicitly check boundaries, so only some of the defensive measures prescribed by the specification are present in this function.""}}]","The function attempts to implement defensive parsing by ensuring that the scanning does not exceed the buffer size and by employing a regex match that is limited to the remaining length of the buffer. This aligns partially with the RFC's expectation that a recipient should parse with marginal assumptions about element conformity and buffer sizes. However, further defensive checks (particularly during inner loop pointer arithmetic without explicit boundary checking) are not fully addressed within this function, leading to the conclusion that it only partially meets the specification.",success,
17104,metafix,"It MUST conform to the field-name syntax defined in Section 5.1, and it SHOULD be restricted to just letters, digits, and hyphen ('-') characters, with the first character being a letter.",293,Partially Matches,"[{'C1': {'code': ""while (!apr_isalpha(*++p));\nfor (q = p; apr_isalnum(*q) || (*q == '-'); ++q);"", 'explanation': 'These code segments extract the header field name by first skipping to an alphabetic character (ensuring the first character is a letter) and then consuming only alphanumeric characters or hyphens, which aligns with the RFC requirement for the field-name syntax.'}}]","The function attempts to implement the RFC's requirement for field-name syntax by checking that the header starts with a letter and only contains letters, digits, and hyphens. This addresses one of the requirements (C1) from the specification. However, the overall RFC also specifies that a registration request should include a valid status (e.g., 'permanent', 'provisional', 'deprecated', or 'obsoleted'), which this function does not handle. Therefore, only part of the spec constraints are visibly addressed within this function.",success,
17107,check_filter_init,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'apr_table_unset(f->r->headers_out, ""Content-Length"");', 'explanation': 'This line removes the Content-Length header from the outgoing headers. By doing so, it prevents the forwarding of a Content-Length header, which is in line with the RFC requirement that a sender MUST NOT forward a message with a Content-Length header value that is known to be incorrect.'}}]","The function unconditionally removes the Content-Length header, thereby addressing the action of not forwarding a potentially incorrect Content-Length value (corresponding to a labeled action, e.g., A1). However, it does not inspect or validate the correctness of the Content-Length header value (i.e., it lacks logic addressing any condition like C1 that checks for known incorrectness), nor does it handle the exception case mentioned in the RFC (e.g., duplicate comma-separated values). As such, while it attempts to comply with part of the RFC by removing the header, it does not fully implement all aspects of the specified constraint.",success,
17109,proxy_html_filter,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'if (!xml2enc_charset ||\n    (xml2enc_charset(f->r, &enc, &cenc) != APR_SUCCESS)) {\n    ...\n    ap_set_content_type_ex(f->r, ""text/html;charset=utf-8"", 1);\n} else {\n    if (ctxt->cfg->charset_out && xml2enc_filter) {\n        if (*ctxt->cfg->charset_out != \'*\')\n            cenc = ctxt->cfg->charset_out;\n        xml2enc_filter(f->r, cenc, ENCIO_OUTPUT);\n        ap_set_content_type(f->r,\n                            apr_pstrcat(f->r->pool,\n                                        ""text/html;charset="",\n                                        cenc, NULL));\n    } else\n        ap_set_content_type_ex(f->r, ""text/html;charset=utf-8"", 1);\n}', 'explanation': 'The code explicitly sets the Content-Type header field for the outgoing HTML content. It checks for character encoding support and, based on that, either uses a default utf-8 header or a charset specified in the configuration, thereby fulfilling the RFC requirement that a sender should generate a Content-Type header if the intended media type is known.'}}]","The function processes HTML content and ensures that before any content is emitted, a Content-Type header is set using ap_set_content_type_ex or ap_set_content_type. This directly addresses the RFC spec requirement that a sender generating a message containing content should include a Content-Type header field, as long as the media type is known. All logic pertaining to this is contained within the function, and no reliance is placed on external dependencies for generating this header.",success,
17127,parse_cmd,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (**args == \'""\') {\n    const char *start = *args + 1;\n    int escaping = 0;\n    ++*args; /* move past leading "" */\n    while (**args && (**args != \'""\' || escaping)) {\n        if (escaping) {\n            escaping = 0;\n        }\n        else if (**args == \'\\\\\') {\n            escaping = 1;\n        }\n        ++*args;\n    }\n    if (**args != \'""\') {\n        return ""Expected cmd= delimiter"";\n    }\n    parms = apr_pstrndup(p, start, *args - start);\n    ++*args; /* move past trailing "" */\n}', 'explanation': 'This segment implements defensive parsing by checking for a leading quote, handling escaped characters, and ensuring that a matching trailing quote exists. This corresponds to the basic idea of defensively parsing the protocol element.'}}, {'A1': {'code': 'if (**args != \'""\') {\n    return ""Expected cmd= delimiter"";\n}', 'explanation': 'This code checks for proper termination of the quoted argument and returns an error message if the expected delimiter is missing, which is a defensive measure.'}}]","The function shows an attempt at defensive parsing by verifying the presence of surrounding quotes and handling escapes, which partially addresses the spec’s guidelines for defensively parsing a protocol element. However, while it checks for proper structure (e.g., leading and trailing quotes with escape handling), it does not explicitly validate the length or ensure the element fits within a reasonable buffer size. Thus, only some of the necessary defensive parsing requirements are handled within this function.",success,
17127,parse_cmd,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, which parses and tokenizes command parameters, does not contain any logic that enforces the RFC requirement stated in the specification. Specifically, it does not check or prevent the generation of protocol elements or syntax alternatives that are disallowed based on the sender's role. There is no role-based validation or discrimination of command elements within the function, and thus it does not implement any of the spec constraints labeled (for example) C1 or actions labeled A1 that would ensure that a sender does not generate forbidden protocol elements.",success,
17127,parse_cmd,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Partially Matches,[],"The parsed RFC specification requires that a recipient MAY attempt to recover a usable protocol element when faced with an invalid construct. The function implements some aspects of this behavior by handling both quoted and unquoted input, and it even processes escape sequences inside quoted strings (for example, the loop beginning with 'while (**args && (**args != '""' || escaping)) { ... }'). However, if the quoted argument does not end with a proper closing quote, the function immediately returns an error (""Expected cmd= delimiter"") rather than attempting any recovery. In addition, while the function tokenizes the arguments (using apr_tokenize_to_argv) which can be seen as a recovery step in well‐formed cases, it does not incorporate any additional error recovery mechanisms as might be implied by the RFC context. Because only some behaviors (like handling escape sequences and separating quoted from unquoted input) address the RFC’s intent in part, and robust recovery is not fully pursued within this function, it only partially matches the specified constraints.",success,
17137,init_filter_instance,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'if (ctx->filter->preserves_content_length != 1) {\n    /* nasty, but needed to avoid confusing the browser\n     */\n    apr_table_unset(f->r->headers_out, ""Content-Length"");\n}', 'explanation': 'This code segment removes the Content-Length header from the outbound headers when the filter does not guarantee that it preserves the correct content length. This partially implements the RFC requirement to not forward a message with an incorrect Content-Length value, by proactively removing it when it may have become invalid.'}}]","The RFC mandates that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect. In this function, the only visible handling related to Content-Length is the conditional removal of the header when the filter does not preserve it. While this mechanism addresses the risk of forwarding an invalid Content-Length by removing it, the code does not check the actual correctness or validity of the header (e.g., verifying repeated values as permissible by the exception in the RFC). Since the function partially prevents the risk by removing the header instead of attempting to validate it, the implementation can be considered as partially matching the RFC constraint.",success,
17142,ef_output_filter,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function primarily focuses on initializing the filter instance, error handling, logging, and passing on data via the bucket brigade. It does not include any logic that addresses role-specific generation of protocol elements or syntax alternatives. In other words, the function does not enforce the requirement that a sender must not generate protocol elements reserved for other roles (as specified in the RFC). Therefore, none of the conditions (e.g., C1) or actions (e.g., A1) related to this constraint are visibly implemented within the function_body.",success,
17142,ef_output_filter,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function does not include explicit logic to ensure that protocol elements match the ABNF grammar as required by the spec constraint. While it handles error cases (for example, setting the status line to '500 Internal Server Error' and creating error buckets), it does not perform any verification or enforcement related to the grammar or conformance of generated protocol elements. Thus, no part of the function visibly implements the spec constraint that 'a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.'",success,
17150,ap_ssi_parse_string,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if ((out && out >= eout) || (length && outlen >= length)) {\n    break;\n}', 'explanation': ""The function checks buffer boundaries repeatedly (both for the output pointer 'out' against 'eout' and by tracking 'outlen') to prevent overruns. This is inline with a defensive approach when parsing a received protocol element.""}}, {'A1': {'code': 'if (!ep) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01331) ""Missing \'}\' on variable \\""%s\\"" in %s"", p, r->filename);\n    break;\n}', 'explanation': ""When encountering a malformed variable (missing the closing '}'), the function logs an error and terminates parsing. This represents an action toward defensive parsing in the face of potential protocol deviations.""}}]","The function implements several defensive parsing techniques by performing extensive boundary checks during memory copy operations and by validating critical syntax (e.g., ensuring that a variable expansion has a closing '}'). These measures address the RFC's requirement that a recipient should parse a received protocol element defensively with only marginal expectations of compliance. However, while it protects against overruns and improperly formatted input, it does not fully implement a comprehensive ABNF grammar validation or dynamically adjustable buffer lengths that the specification context implies. Thus, the function partially meets the specification within its own scope.",success,
17159,handle_echo,"Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",308,Does Not Match,[],"The provided function does not contain any logic related to enforcing the constraint that future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively). The function only processes parameters such as ""var"", ""decoding"", and ""encoding"", and there is no check for a parameter named ""q"". Therefore, based solely on the visible code in this function, no part of the relevant RFC specification is addressed.",success,
17168,handle_printenv,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The function 'handle_printenv' is focused on processing and printing environment variables and does not contain any logic addressing the HTTP RFC requirement that 'an origin server MUST NOT use such context information to alter the request semantics.' There is no code in this function that interprets, applies, or specifically avoids modifying request semantics based on any context (such as Content-Location), and as such it does not implement any labeled constraints from the specification.",success,
17173,find_directive,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'while (p < ep && !apr_isspace(*p)) { /* ... */ } ... while (p < ep && pos < intern->end_seq_len && *p == intern->end_seq[pos]) { ++p; ++pos; }', 'explanation': ""This code uses explicit pointer boundary checks (e.g. 'while (p < ep)') during parsing, which is a defensive measure ensuring that the received protocol element is only processed within its provided buffer limits. This aligns with the idea of not making strong assumptions about the conformance of the element to its ABNF grammar.""}}, {'A1': {'code': 'if (!intern->directive_len) {\n    intern->error = 1;\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, APLOGNO(01368) ""missing directive name in parsed document %s"", ctx->r->filename);\n}', 'explanation': 'The function actively checks for a missing directive name and raises an error with logging. This is an example of a defensive action to handle non-conforming elements.'}}]","The function 'find_directive' implements several defensive parsing techniques—such as enforcing buffer boundaries via pointer comparisons and checking for missing or malformed directive components—thereby partially addressing the RFC recommendation of defensive parsing. However, it does not perform an in-depth validation of the protocol element against its full ABNF grammar nor does it impose a specific reasonable maximum length, instead relying on the provided buffer length. Thus, while it demonstrates some of the intended defensive behaviors, it only partially meets the overall expected constraints of the RFC.",success,
17177,send_parsed_content,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function implements SSI parsing by processing buckets and directives but does not include any explicit logic enforcing the RFC requirement that a sender must not generate protocol elements or syntax alternatives reserved for other roles. No segments of the function verify sender roles or validate against an ABNF grammar to prevent generation of such elements. Therefore, in isolation, this function does not address the specified RFC constraint.",success,
17179,includes_filter,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function does not address the RFC requirements about preventing multiple field lines with the same header name or preserving their order. Its logic is focused on setting up SSI processing, configuring the environment, and unsetting specific headers (like Content-Length and Last-Modified) based on certain conditions. There is no visible logic within this function that implements the specification constraints regarding multiple header field lines as described in the RFC.",success,
17179,includes_filter,"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.",52,Fully Matches,"[{'C1': {'code': 'if (conf->lastmodified > 0) {\n    if (r->finfo.valid & APR_FINFO_MTIME && !apr_table_get(f->r->headers_out, ""Last-Modified"")) {\n        ap_update_mtime(r, r->finfo.mtime);\n        ap_set_last_modified(r);\n    }\n}\nelse if (((conf->xbithack == XBITHACK_FULL ||\n           (conf->xbithack == XBITHACK_UNSET && DEFAULT_XBITHACK == XBITHACK_FULL))\n         && (r->finfo.valid & APR_FINFO_GPROT)\n         && (r->finfo.protection & APR_GEXECUTE))) {\n    ap_update_mtime(r, r->finfo.mtime);\n    ap_set_last_modified(r);\n}\nelse {\n    apr_table_unset(f->r->headers_out, ""Last-Modified"");\n}', 'explanation': 'The code checks if a valid file modification time exists and if configuration permits setting the Last-Modified header. When conditions are met (either via the SSILastModified directive or through the XBitHack full mode), it updates and sends the Last-Modified header. If not, it unsets the header, aligning with the RFC’s guidance to send Last-Modified only when a reliable modification time is available.'}}]","The function visibly addresses the RFC requirement regarding the Last-Modified header. It includes logic to determine if the file's last modification time is valid and to set the header when enabled by configuration, or unset it otherwise. This concrete implementation within the function satisfies the condition specified in the RFC that an origin server SHOULD send Last-Modified for a representation with a reliably determined last modification date.",success,
17179,includes_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Fully Matches,"[{'A1': {'code': 'apr_table_unset(f->r->headers_out, ""Content-Length"");', 'explanation': ""This line unconditionally removes the 'Content-Length' header from the outgoing response. By doing so, the function ensures that no potentially incorrect Content-Length is forwarded, which directly implements the RFC requirement that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.""}}]","The function explicitly unsets the 'Content-Length' header prior to forwarding the response (see the call to apr_table_unset). This removal prevents the propagation of any incorrect Content-Length value. Since the RFC specification mandates that a sender avoid forwarding an incorrect Content-Length header, the code in this function fully addresses that requirement by eliminating the header, thereby ensuring compliance without needing additional validation logic within the function.",success,
17180,include_fixup,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,"[{'C1': {'code': 'if (!r->content_type || !*r->content_type) {\n            ap_set_content_type_ex(r, ""text/html"", 1);\n        }', 'explanation': ""This segment checks if the Content-Type header is missing and, when the handler is 'server-parsed', sets a default Content-Type to 'text/html'. This implements the requirement of generating a Content-Type header when content is present.""}}]","The code function attempts to enforce the RFC requirement by adding a Content-Type header when it is missing for 'server-parsed' content. However, it does so only in a specific case (when the handler is 'server-parsed') and does not cover all cases outlined by the RFC (for example, checking whether the media type is unknown). Consequently, while the function does address part of the specification (C1), it only partially implements the full guidance provided by the RFC.",success,
17180,include_fixup,"If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type.",35,Partially Matches,"[{'C1': {'code': 'if (!r->content_type || !*r->content_type) {\n    ap_set_content_type_ex(r, ""text/html"", 1);\n}', 'explanation': ""This code block checks if the Content-Type header is missing or empty and then sets a default value ('text/html'). It addresses the condition where no Content-Type is provided by assuming a default media type, which is one of the options allowed by the RFC.""}}]","The RFC states that if a Content-Type header is not present, the recipient may either assume a default media type (such as 'application/octet-stream') or inspect the data to determine its type. In the provided function, for 'server-parsed' requests, the code explicitly checks for a missing or empty Content-Type header and assigns 'text/html' as the default. This meets the requirement of setting a default when none is provided, consistent with the RFC's flexibility—provided the sender knows the intended media type. However, the code does not implement any mechanism to examine the data for determining its type, and it does not consider the alternative default of 'application/octet-stream'. Therefore, while the function does address one aspect of the RFC, it does so only partially.",success,
17203,sed_response_filter,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,61,Partially Matches,"[{'A1': {'code': 'if (ctx == NULL) {\n    if (APR_BUCKET_IS_EOS(APR_BRIGADE_FIRST(bb))) {\n        /* no need to run sed filter for Head requests */\n        ap_remove_output_filter(f);\n        return ap_pass_brigade(f->next, bb);\n    }\n    ...', 'explanation': 'This segment bypasses further sed processing when the bucket brigade is empty – a situation expected for HEAD requests – thereby avoiding the processing and generation of response content.'}}, {'A2': {'code': 'apr_table_unset(f->r->headers_out, ""Content-Length"");', 'explanation': 'Removal of the Content-Length header helps ensure that HEAD responses do not inappropriately include content size details, consistent with the RFC requirement not to send a response body.'}}]","The function includes logic that appears intended to avoid generating content when processing a HEAD request by checking for an EOS bucket and by unsetting the Content-Length header. These actions align with the RFC directive that a HEAD response must not send content. However, the determination for a HEAD request is implicit (assuming an EOS bucket indicates no content) rather than an explicit check of the request method, and additional header field consistencies required by the RFC are not managed solely within this function. As such, while some requirements are addressed here, the implementation is only partially compliant based on the logic present in the function_body.",success,
17203,sed_response_filter,A server MAY send a Content-Length header field in a response to a HEAD request (Section 9.3.2); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a response if the same request had used the GET method.,43,Partially Matches,"[{'A1': {'code': 'apr_table_unset(f->r->headers_out, ""Content-Length"");', 'explanation': 'This code unconditionally removes the Content-Length header from the response. It is an attempt to fulfill the RFC mandate that a server MUST NOT send Content-Length in a HEAD response (or similar) unless it exactly matches the GET response octet count. However, the function does not compute or validate the correct content length if it were a GET request, hence it only partially implements the specification by simply unsetting the header.'}}]","The function shows an attempt to implement the RFC by ensuring that the Content-Length header is not present in the response—this is visible in the call to apr_table_unset. However, the RFC requires the header to be sent only if its value equals the number of octets that would have been sent in a GET request. Since the function does not perform any computation or validation to determine the correct content length, it only partially matches the constraints. Only the removal of the header (an action we label A1) is implemented within this function.",success,
17203,sed_response_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Fully Matches,"[{'C1': {'code': 'apr_table_unset(f->r->headers_out, ""Content-Length"");', 'explanation': 'This line removes the Content-Length header from the outgoing response, ensuring that an incorrect or stale Content-Length value (which might have been rendered invalid by the sed processing) is not forwarded. This directly implements the spec requirement that a sender must not forward a message with a known incorrect Content-Length header value.'}}]","The function sed_response_filter addresses the critical aspect of the HTTP specification by unsetting the Content-Length header when the sed filter is applied. By doing so, it prevents potentially incorrect Content-Length header values from being passed to downstream recipients, thereby fully matching the requirement of the RFC that prohibits forwarding messages with a known incorrect Content-Length value.",success,
17203,sed_response_filter,"Likewise, a sender MUST NOT forward a message with a Content-Length header field value that does not match the ABNF above, with one exception: a recipient of a Content-Length header field value consisting of the same decimal value repeated as a comma-separated list (e.g, ""Content-Length: 42, 42"") MAY either reject the message as invalid or replace that invalid field value with a single instance of the decimal value, since this likely indicates that a duplicate was generated or combined by an upstream message processor.",49,Partially Matches,"[{'C1': {'code': 'apr_table_unset(f->r->headers_out, ""Content-Length"");', 'explanation': 'This line removes the Content-Length header from the outgoing response. By doing so, it prevents forwarding a potentially incorrect Content-Length value when the body content has been modified (for example, by applying sed expressions), which is in line with the RFC requirement that a sender MUST NOT forward a message with an invalid Content-Length. However, the function does not check for duplicate comma‐separated Content-Length values nor does it implement the exception described in the RFC.'}}]","The function partially addresses the RFC specification by unsetting the Content-Length header to avoid forwarding a header that may no longer be valid after content modification. This action satisfies, in part, the constraint that incorrect Content-Length header values must not be forwarded. However, it does not implement the exception for duplicate Content-Length values (such as '42, 42') where the value might be replaced or the message rejected. Therefore, only part of the spec constraint is handled within this function.",success,
17204,sed_request_filter,"Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",308,Does Not Match,[],"The RFC requirement specifies that future registrations of transfer codings should not define parameters called 'q' to avoid ambiguities. The provided function, sed_request_filter, is solely focused on processing input data using sed expressions and managing bucket brigades. There is no logic present in this function that inspects or validates HTTP header fields or parameters related to transfer codings, specifically no check or handling for a parameter named 'q'. Thus, the function does not address the RFC constraint.",success,
17210,filter_lookup,A server MAY ignore the Range header field.,126,Partially Matches,"[{'A1': {'code': 'if (proto_flags & AP_FILTER_PROTO_NO_BYTERANGE) {\n    apr_table_setn(r->headers_out, ""Accept-Ranges"", ""none"");\n}', 'explanation': ""This segment sets the 'Accept-Ranges' header to 'none' when the provider flag AP_FILTER_PROTO_NO_BYTERANGE is active, which is an attempt to implement the action that a server MAY ignore range requests. This partially implements the RFC provision regarding how range requests may be ignored.""}}]","The function does include logic to disable byte-range support by setting the 'Accept-Ranges' header to 'none', thus showing an intent to ignore the Range header in certain cases. However, it lacks comprehensive implementation (for example, it does not check if the request method is GET or ensure that range handling is skipped when the method is unrecognized), so only part of the RFC specification is addressed within this function.",success,
17220,filter_insert,A server MAY ignore the Range header field.,126,Partially Matches,[],"The RFC allows the server to ignore the Range header field. In the function, there is logic under the conditional (if (ranges && (filter->proto_flags & (AP_FILTER_PROTO_NO_BYTERANGE | AP_FILTER_PROTO_CHANGE_LENGTH)))) that retrieves the 'Range' header and then unsets it from r->headers_in. This shows an attempt to ignore the Range header based on certain filter flag conditions. However, the function does not check if the request method is GET nor does it address all the nuanced conditions of range handling described in the specification. The code only partially implements the behavior of ignoring the Range header as allowed by the RFC, rather than fully implementing all aspects of the spec constraint.",success,
17242,xlate_out_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Fully Matches,"[{'A1': {'code': 'if (!ctx->ran) {  \n    chk_filter_chain(f);\n    ctx->ran = 1;\n    if (!ctx->noop && !ctx->is_sb) {\n        /* We\'re not converting between two single-byte charsets, so unset\n         * Content-Length since it is unlikely to remain the same.\n         */\n        apr_table_unset(f->r->headers_out, ""Content-Length"");\n    }\n}', 'explanation': 'The RFC specifies that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect. When a translation is performed (i.e. ctx->noop is false and the conversion involves more than single-byte charsets), the function unsets the Content-Length header to avoid forwarding an incorrect value. This directly implements the requirement prescribed by the spec.'}}]","The function xlate_out_filter contains explicit logic to remove the Content-Length header when a translation modifies the body's framing, thereby preventing forwarding of a likely incorrect Content-Length value. This directly addresses the spec requirement that a sender must not forward a message with an incorrect Content-Length header field. All of the logic relevant to this spec constraint is self-contained within this function, so the implementation fully matches the specification.",success,
17248,substitute_filter,"Likewise, a sender MUST NOT forward a message with a Content-Length header field value that does not match the ABNF above, with one exception: a recipient of a Content-Length header field value consisting of the same decimal value repeated as a comma-separated list (e.g, ""Content-Length: 42, 42"") MAY either reject the message as invalid or replace that invalid field value with a single instance of the decimal value, since this likely indicates that a duplicate was generated or combined by an upstream message processor.",49,Does Not Match,[],"The RFC specification requires that a sender must not forward a message with a Content-Length header field value that is incorrect, and in the special case of a duplicate comma‐separated valid value, the message can either be rejected or the header value replaced with a single instance. The function code provided does not implement any parsing, validation, or duplicate handling logic for the Content-Length header. The only direct reference to Content-Length is the call to 'apr_table_unset(f->r->headers_out, ""Content-Length"")', which simply removes the header, rather than validating or replacing it per the spec. Therefore, the function does not visibly address any of the labeled constraints in the RFC specification.",success,
17248,substitute_filter,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Does Not Match,[],"The RFC requires that the server MUST NOT send the Content-Length header field only in responses with status codes 1xx or 204. In this function, the Content-Length header is unconditionally removed via the call to apr_table_unset(f->r->headers_out, ""Content-Length"") without any check for the response's status code. This lack of conditional handling means that although the code does remove the header, it does not correctly implement the RFC constraint which only applies the removal for specific status codes. Therefore, the function does not visibly address the RFC's requirement within its own logic.",success,
17248,substitute_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'C1': {'code': 'apr_table_unset(f->r->headers_out, ""Content-Length"");', 'explanation': 'The code unconditionally removes any Content-Length header from the response. This prevents an incorrect Content-Length value from being forwarded. However, it does not validate the header or handle the exception for comma‐separated repeated values as described in the spec.'}}]","The RFC requires that a sender must not forward a message with a known incorrect Content-Length value. In this function, the act of unsetting the Content-Length header addresses this by ensuring that no Content-Length is forwarded. Although this meets part of the specification by preventing the forwarding of possibly incorrect values, the function does not explicitly check if a Content-Length is incorrect or handle allowed exceptions (e.g., duplicate entries). Thus, within the function body, only a part of the requirement (C1) is visibly addressed.",success,
17254,sniff_encoding,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'sniff_encoding' is focused on detecting and setting the character encoding based on HTTP headers, XML BOM, and META tags. It does not include any logic that enforces the role-based constraint from the RFC—that is, it does not check whether the sender is generating protocol elements that are only permitted for other roles. No part of the function restricts or validates the generation of such protocol elements according to the specified RFC. Therefore, the function does not visibly address the labeled spec requirement.",success,
17254,sniff_encoding,The type/subtype MAY be followed by semicolon-delimited parameters (Section 5.6.6) in the form of name/value pairs.,259,Partially Matches,"[{'C1': {'code': 'if (ctype && (p = ap_strcasestr(ctype, ""charset="") , p != NULL)) {\n    p += 8 ;\n    if (ctx->encoding = apr_pstrndup(r->pool, p, strcspn(p, "" ;"") ), ctx->encoding) {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01431)\n                      ""Got charset %s from HTTP headers"", ctx->encoding) ;\n        ctx->xml2enc = xmlParseCharEncoding(ctx->encoding);\n    }\n}', 'explanation': ""The function performs a case-insensitive search (using ap_strcasestr) for the 'charset=' marker within the Content-Type header and then extracts the charset value using strcspn with delimiters (' ' and ';'). This addresses the specification’s requirement that parameters (here the charset) following the type/subtype are delimited by semicolons.""}}, {'A1': {'code': 'if (ctype && ctx->encoding) {\n    if (ap_regexec(seek_charset, ctype, 2, match, 0)) {\n        r->content_type = apr_pstrcat(r->pool, ctype, "";charset=utf-8"", NULL);\n    } else {\n        char* str = apr_palloc(r->pool, strlen(r->content_type) + 13\n                               - (match[0].rm_eo - match[0].rm_so) + 1);\n        memcpy(str, r->content_type, match[1].rm_so);\n        memcpy(str + match[1].rm_so, ""utf-8"", 5);\n        strcpy(str + match[1].rm_so + 5, r->content_type+match[1].rm_eo);\n        r->content_type = str;\n    }\n}', 'explanation': ""After determining the encoding, the function updates the Content-Type header to ensure a charset parameter is present and normalized (in this case, forcing 'utf-8'). This demonstrates an attempt to handle the semicolon-delimited parameter formatting prescribed in the RFC.""}}]","The function addresses part of the HTTP RFC requirement by performing case-insensitive parsing of the charset parameter from the Content-Type header and by updating the header to ensure that a charset parameter is present in a semicolon-delimited format. However, it focuses solely on the 'charset' parameter instead of fully processing all potential parameters attached to the type/subtype token. Therefore, it partially matches the specified constraints.",success,
17256,xml2enc_ffunc,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': '/* we might change the Content-Length, so let\'s force its re-calculation */\napr_table_unset(f->r->headers_out, ""Content-Length"");', 'explanation': 'This code unconditionally removes the Content-Length header from the outbound headers. In the context of the RFC—where messages with an incorrect Content-Length should not be forwarded—this removal forces a recalculation, thereby mitigating the risk of propagating an erroneous value. However, the function does not actually verify the correctness of the Content-Length before forwarding, so it addresses the concern in a blanket manner rather than selectively when the value is known to be incorrect.'}}]","The RFC requires that a sender MUST NOT forward a message with a Content-Length header field value known to be incorrect. In this function, there is visible logic to remove the Content-Length header (via apr_table_unset) to force it to be recalculated later on. This action is consistent with the intent of the RFC; however, the function does not perform any specific check to determine if the Content-Length is incorrect—it simply removes it regardless. Therefore, while the function does attempt to address the constraint by preventing an incorrect Content-Length from being forwarded, it does so in a non-discriminatory way and does not directly validate it. This leads to the conclusion that the code only partially matches the specified constraint.",success,
17256,xml2enc_ffunc,The type/subtype MAY be followed by semicolon-delimited parameters (Section 5.6.6) in the form of name/value pairs.,259,Fully Matches,"[{'C1': {'code': ""mtype = apr_pstrdup(f->r->pool, f->r->content_type);\nif ((p = ap_strchr(mtype, ';')) != NULL) *p = '\\0';\nap_str_tolower(mtype);"", 'explanation': 'This code segment extracts the media type from the Content-Type header by copying the string, then locates any semicolon (which indicates the start of parameters) and truncates the string there. It then converts the resulting type/subtype token to lowercase, satisfying the RFC requirement that the type/subtype is case-insensitive and may be followed by semicolon-delimited parameters.'}}]","The function visibly implements the specified RFC behavior by isolating the type/subtype from any parameters attached to the Content-Type header and by converting it to lowercase. These steps directly address the requirement that the type/subtype may be followed by parameters and that they are treated in a case-insensitive manner, thus the function fully meets the constraint within its own logic.",success,
17258,xml2enc_hooks,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, xml2enc_hooks, primarily registers output filters and compiles regular expressions to locate meta charset elements. It does not include any logic that pertains to ensuring that a sender does not generate protocol elements or syntax alternatives that are only allowed by other roles. There is no conditional logic or role-specific checks addressing the specification’s requirement. Hence, within the boundaries of the function itself, no part of the code attempts to implement the specified RFC constraint regarding protocol element generation based on sender roles.",success,
17258,xml2enc_hooks,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The spec requires that a sender must not generate protocol elements that do not follow the ABNF defined grammar. In the function_body, there is no logic that checks or enforces the generated protocol elements against an ABNF grammar. The function only registers filters and compiles regular expressions for meta tags and charset extraction, which does not directly implement or validate the RFC constraint. Therefore, this function does not visibly address any labeled condition or action from the specification.",success,
17305,get_content_encoding,"A recipient MAY combine multiple field lines within a field section that have the same field name into one field line, without changing the semantics of the message, by appending each subsequent field line value to the initial field line value in order, separated by a comma ("","") and optional whitespace (OWS, defined in Section 5.6.3).",231,Partially Matches,[],"The function attempts to implement the RFC’s guideline to combine multiple header field lines by appending values in order and using a comma as a separator. It gathers values from different sources (headers_out, err_headers_out, and r->content_encoding) and concatenates them using a comma. However, the RFC (and its context) specifies that for consistency a comma followed by a space (comma SP) should be used. Since the function uses just a comma without the additional space, it does not fully meet the specified requirement. Thus, while the basic idea of combining values in order is present, the precise formatting dictated by the RFC is not completely implemented in the function.",success,
17305,get_content_encoding,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Fully Matches,"[{'C1': {'code': 'encoding = apr_table_get(r->headers_out, ""Content-Encoding"");\nif (encoding) {\n    const char *err_enc;\n    err_enc = apr_table_get(r->err_headers_out, ""Content-Encoding"");\n    if (err_enc) {\n        encoding = apr_pstrcat(r->pool, encoding, "","", err_enc, NULL);\n    }\n} else {\n    encoding = apr_table_get(r->err_headers_out, ""Content-Encoding"");\n}\n\nif (r->content_encoding) {\n    encoding = encoding ? apr_pstrcat(r->pool, encoding, "","", r->content_encoding, NULL) : r->content_encoding;\n}', 'explanation': 'This segment retrieves multiple possible sources of the Content-Encoding header and recombines them into a single comma-separated string. This directly addresses the RFC requirement that, except for the well‐known exception, a sender must not produce multiple field lines with the same name unless the values can be recombined as a comma-separated list.'}}, {'A1': {'code': 'encoding = apr_pstrcat(r->pool, encoding, "","", err_enc, NULL);\n...\nencoding = encoding ? apr_pstrcat(r->pool, encoding, "","", r->content_encoding, NULL) : r->content_encoding;', 'explanation': 'By concatenating the header values in the order they are retrieved (from headers_out, then err_headers_out, then r->content_encoding), the code preserves the order of appearance, which meets the requirement that the order of multiple field lines is significant.'}}]","The function get_content_encoding explicitly checks for the existence of the 'Content-Encoding' header in different parts of the request structure and combines them into a single, comma-separated string. This behavior reflects the HTTP RFC's exception, which allows for the recombination of multiple header values provided that their order is maintained. As such, the function visibly implements the relevant spec constraints by ensuring that if multiple header lines are present, they are concatenated in the correct order, fully matching the specified conditions and actions.",success,
17306,compress_filter,The HEAD method is identical to GET except that the server MUST NOT send content in the response.,61,Partially Matches,"[{'C1': {'code': 'if (r->header_only && r->bytes_sent) {\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}', 'explanation': ""This code segment checks if the request is a HEAD request (by way of r->header_only) and, if some bytes have already been sent, removes the compression filter and passes on the brigade without further processing. In doing so, it attempts to avoid sending a response body, which is the core of the RFC requirement. However, it relies on the bytes_sent condition and the broader context in which HEAD requests are handled, meaning that the function itself only partially implements the RFC's mandate.""}}]","The RFC requires that a HEAD response not send any content, and this function includes a check (using r->header_only) that stops further compression by removing its output filter when appropriate. Although this reflects an intent to not process or add a response body for HEAD requests, the implementation is tied to the bytes_sent state and the surrounding Apache filter chain processing. Consequently, while the function visibly addresses the requirement in one key segment (labeled C1), it does not comprehensively enforce the RFC requirement on its own, leading to a classification of 'Partially Matches'.",success,
17306,compress_filter,"If a non-empty Accept-Encoding header field is present in a request and none of the available representations for the response have a content coding that is listed as acceptable, the origin server SHOULD send a response without any content coding unless the identity coding is indicated as unacceptable.",94,Partially Matches,"[{'C1': {'code': 'accepts = apr_table_get(r->headers_in, ""Accept-Encoding"");\nif (!accepts) {\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}\n\n/* Do we have Accept-Encoding: br? */\ntoken = ap_get_token(r->pool, &accepts, 0);\nwhile (token && token[0] && ap_cstr_casecmp(token, ""br"") != 0) {\n    while (*accepts == \';\') {\n        ++accepts;\n        ap_get_token(r->pool, &accepts, 1);\n    }\n\n    if (*accepts == \',\') {\n        ++accepts;\n    }\n    token = (*accepts) ? ap_get_token(r->pool, &accepts, 0) : NULL;\n}\n\n/* No acceptable token found or q=0 */\nif (!token || token[0] == \'\\0\' ||\n    (q && strlen(q) >= 3 && strncmp(""q=0.000"", q, strlen(q)) == 0)) {\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}', 'explanation': ""This code segment inspects the Accept-Encoding header (a non-empty header) and tokenizes it to check for the 'br' content coding. If the header does not include an acceptable 'br' token (or its qvalue is zero), the filter is removed and the response is sent without adding a new content coding. This mechanism attempts to comply with the RFC's requirement to send a response without any content coding when none of the available representations are acceptable.""}}]","The function contains logic that inspects the Accept-Encoding header and conditionally applies Brotli compression only when the 'br' token is present with a non-zero qvalue. This aligns with the RFC requirement of sending a response without applying a new content coding if no acceptable content coding is found. However, it does not explicitly check the exception clause regarding the 'identity' coding being unacceptable. Thus, while the function addresses a major part of the RFC specification (i.e. checking for an acceptable encoding and bypassing compression when not found), it only partially matches the complete set of constraints outlined in the specification.",success,
17306,compress_filter,"In order to avoid confusion with issues related to media types, servers that fail a request with a 415 status for reasons unrelated to content codings MUST NOT include the Accept-Encoding header field.",95,Does Not Match,[],"The RFC specification requires that when a server fails a request with a 415 status for reasons unrelated to content codings, it MUST NOT include the Accept-Encoding header field. The compress_filter function does not include any logic to fail a request with a 415 status code, nor does it decide whether or not to include the Accept-Encoding header field in a 415 response. Instead, it only checks the 'Accept-Encoding' header in the request to determine if compression (specifically Brotli compression indicated by ""br"") is acceptable and then processes the response accordingly. There is no code segment that addresses the requirement regarding 415 failures and the inclusion/exclusion of the Accept-Encoding header. Therefore, the function does not match the specified HTTP RFC constraint.",success,
17306,compress_filter,An origin server SHOULD generate a Vary header field on a cacheable response when it wishes that response to be selectively reused for subsequent requests.,96,Fully Matches,"[{'A1': {'code': 'apr_table_mergen(r->headers_out, ""Vary"", ""Accept-Encoding"");', 'explanation': ""This statement explicitly sets the Vary header to 'Accept-Encoding' in the response, ensuring that caches consider the Accept-Encoding header when reusing the response. This matches the spec's requirement that an origin server should generate a Vary header field on a cacheable response for selective reuse.""}}]","The function compress_filter directly implements the RFC requirement by generating the Vary header field. The code does this by calling apr_table_mergen to merge 'Accept-Encoding' into the Vary header. This action, visible within the function (and not delegated to any dependency), meets the specified condition described in the RFC.",success,
17306,compress_filter,"Note that the coding named ""identity"" is reserved for its special role in Accept-Encoding and thus SHOULD NOT be included.",38,Fully Matches,"[{'C1': {'code': 'if (!encoding || ap_cstr_casecmp(encoding, ""identity"") == 0) {\n    apr_table_setn(r->headers_out, ""Content-Encoding"", ""br"");\n} else {\n    apr_table_mergen(r->headers_out, ""Content-Encoding"", ""br"");\n}', 'explanation': ""This segment ensures that if no Content-Encoding is set or if the encoding is 'identity', the filter replaces it by setting the header to 'br'. In cases where another encoding (besides the reserved 'identity', '7bit', '8bit', or 'binary') has been applied, it bypasses Brotli compression, thus ensuring that the reserved 'identity' is not included in the header.""}}, {'A1': {'code': 'encoding = get_content_encoding(r);\n\nif (encoding) {\n    const char *tmp = encoding;\n\n    token = ap_get_token(r->pool, &tmp, 0);\n    while (token && *token) {\n        if (strcmp(token, ""identity"") != 0 &&\n            strcmp(token, ""7bit"") != 0 &&\n            strcmp(token, ""8bit"") != 0 &&\n            strcmp(token, ""binary"") != 0) {\n            /* The data is already encoded, do nothing. */\n            ap_remove_output_filter(f);\n            return ap_pass_brigade(f->next, bb);\n        }\n\n        if (*tmp) {\n            ++tmp;\n        }\n        token = (*tmp) ? ap_get_token(r->pool, &tmp, 0) : NULL;\n    }\n}', 'explanation': ""This part of the code parses the existing Content-Encoding header and checks for tokens that are not 'identity' (or the standard ones '7bit', '8bit', 'binary'). Finding any such token means that another encoding is already applied, and the filter will not perform Brotli compression. This logic supports the RFC requirement regarding the handling (and exclusion) of the reserved 'identity' coding.""}}]","The function inspects the current Content-Encoding header and parses its tokens to ensure that the special reserved 'identity' is not inadvertently included in the list, as mandated by the RFC. It conditionally replaces or augments the header with 'br' only when appropriate (i.e., when no other encoding is in place or when the encoding is simply 'identity'). Thus, the core RFC constraint and its associated actions are fully addressed within this function.",success,
17306,compress_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Fully Matches,"[{'A1': {'code': '...\n    apr_table_unset(r->headers_out, ""Content-Length"");\n...', 'explanation': 'The function unconditionally removes the Content-Length header from the output (via apr_table_unset), ensuring that no potentially incorrect Content-Length value is forwarded. This behavior satisfies the spec requirement that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.'}}]","The HTTP RFC requires that when a message’s Content-Length is known or may be incorrect, it must not be forwarded. In this compression filter, before processing the response further, the code removes the Content-Length header from the outgoing headers. By doing so, the function guarantees that an outdated or invalid Content-Length header is not transmitted, which directly aligns with the requirement specified. Since the function itself performs the necessary header removal, it fully meets the constraint as implemented in the function body.",success,
17306,compress_filter,A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 15.4.5); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a 200 (OK) response to the same request.,44,Fully Matches,"[{'C1': {'code': 'apr_table_unset(r->headers_out, ""Content-Length"");\n...\n/* For 304 responses, we only need to send out the headers. */\nif (r->status == HTTP_NOT_MODIFIED) {\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}', 'explanation': 'The RFC requires that a 304 response must not include a Content-Length header unless its value exactly equals the size of the body for a corresponding 200 response. This function unsets the Content-Length header unconditionally and, when a 304 status is detected, immediately stops further processing. By doing so, it ensures that no potentially invalid Content-Length header is sent, thus fully addressing the RFC requirement.'}}, {'A1': {'code': 'if (r->header_only && r->bytes_sent) {\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}', 'explanation': 'For HEAD requests, the RFC allows sending a Content-Length header only if it accurately reflects the content that would have been sent with a GET. This branch detects if some data has already been sent on a HEAD request and bypasses further compression. This prevents any attempt to modify or add an incorrect Content-Length header, thereby aligning with the RFC.'}}]","The function ensures compliance with the relevant RFC by unsetting the Content-Length header before processing responses that should not include it and handling 304 and HEAD responses with dedicated branches. This conservative behavior—that is, removing the header instead of attempting to compute and send one—satisfies the requirement that a Content-Length header must not be sent unless it exactly reflects the expected body size, thereby fully matching the spec constraints within the function itself.",success,
17306,compress_filter,A server MAY send a Content-Length header field in a response to a HEAD request (Section 9.3.2); a server MUST NOT send Content-Length in such a response unless its field value equals the decimal number of octets that would have been sent in the content of a response if the same request had used the GET method.,43,Fully Matches,"[{'C1': {'code': 'apr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': ""This line ensures that the 'Content-Length' header is removed from the response. In a HEAD response, the RFC mandates that the server MUST NOT send a Content-Length header unless it would exactly match the GET response body size. Removing it satisfies the requirement.""}}, {'A1': {'code': 'if (r->header_only && r->bytes_sent) {\n    ap_remove_output_filter(f);\n    return ap_pass_brigade(f->next, bb);\n}', 'explanation': 'This branch checks for a HEAD request (via r->header_only) and bypasses further compression (and header additions) once data has been partially sent. This avoids inadvertently sending a Content-Length header when it may not match a GET response’s content length.'}}]","The function explicitly unsets the Content-Length header and avoids further processing on HEAD responses once data transmission is detected. These actions directly address the RFC's requirement that a server MUST NOT send a Content-Length header in a HEAD response unless it exactly represents the number of octets that would have been sent for a GET request. All necessary logic is contained within this function, so it fully matches the specified constraints.",success,
17306,compress_filter,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Partially Matches,"[{'C1': {'code': 'if (r->main || r->status == HTTP_NO_CONTENT\n            || apr_table_get(r->subprocess_env, ""no-brotli"")\n            || apr_table_get(r->headers_out, ""Content-Range"")) {\n        ap_remove_output_filter(f);\n        return ap_pass_brigade(f->next, bb);\n    }', 'explanation': 'This check explicitly bypasses compression for 204 (No Content) responses, ensuring that further modifications, including removal of Content-Length later, are not applied for such responses.'}}, {'A1': {'code': 'apr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'The code unconditionally removes the Content-Length header from the response headers when the filter is applied, which addresses part of the RFC requirement to not send a Content-Length header under the specified conditions.'}}]","The function contains logic that removes the Content-Length header (via apr_table_unset) and explicitly checks for a 204 response (HTTP_NO_CONTENT) to bypass compression, thereby partially addressing the RFC specification that a server must not send a Content-Length header in a 204 response. However, it does not include a specific check for 1xx (Informational) responses. Although these responses might be handled differently elsewhere in the system, in the context of this function only the 204 case is directly addressed. Therefore, the implementation partially matches the given RFC constraints.",success,
17770,ctutil_buffer_to_array,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': 'while (apr_isspace(*ch) && ch < end) {\n    ch++;\n}', 'explanation': 'This loop removes leading whitespace from each line, satisfying the requirement to parse and remove BWS before interpretation.'}}, {'A1': {'code': 'while (tmpend > ch && isspace(*tmpend)) {\n    --tmpend;\n}', 'explanation': 'This loop removes trailing whitespace from each line, ensuring that any bad whitespace (BWS) is eliminated as required by the RFC.'}}]","The function 'ctutil_buffer_to_array' processes an input buffer by splitting it into lines at newline characters and, for each line, explicitly removes leading whitespace using a loop that advances the pointer while whitespace is encountered and trailing whitespace by decrementing the pointer from the end of the line. This behavior directly implements the RFC specification that any content defined as BWS may be removed before interpreting or forwarding the message. Thus, the code function itself visibly addresses the spec's conditions about BWS removal, fulfilling both the condition (C1) for parsing and the action (A1) for removal.",success,
17770,ctutil_buffer_to_array,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': 'while (apr_isspace(*ch) && ch < end) {\n    ch++;\n}\n...\nwhile (tmpend > ch && isspace(*tmpend)) {\n    --tmpend;\n}', 'explanation': 'The code explicitly trims bad whitespace by advancing the start pointer past any whitespace characters (leading whitespace) and by moving backwards from the end of the line to remove trailing whitespace. This directly implements the RFC requirement that a recipient must parse and remove such bad whitespace before interpreting the protocol element.'}}]","The function processes a buffer into an array of lines and removes unwanted whitespace from the beginning and end of each line. This trimming behavior is in accordance with the RFC specification that requires removal of bad whitespace before any interpretation. The logic for handling leading and trailing whitespace in the code directly addresses the spec's requirement, and therefore, the function fully matches the constraint.",success,
17813,ssl_io_input_getline,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Partially Matches,"[{'C1': {'code': 'if ((pos = memchr(buf, APR_ASCII_LF, *len))) {\n    break;\n}', 'explanation': 'This segment searches for a LF in the read data and breaks the loop when found, thereby implementing the allowance to recognize a single LF as a line terminator in compliance with the RFC.'}}]","The function attempts to implement part of the RFC by reading the input until a LF is found, which is in line with the provision that a recipient MAY recognize a single LF as a line terminator. However, the RFC also specifies requirements regarding the treatment of bare CR characters (such as considering the element invalid or replacing each bare CR with a SP) and parsing messages as a sequence of octets to prevent security vulnerabilities. The function does not include logic to detect or handle a bare CR, nor does it perform any special encoding or replacement for CR characters. Thus, while it addresses the LF recognition (condition C1), it does not fully meet all aspects of the RFC's constraints, leading to a Partial Matches outcome.",success,
17817,ssl_filter_io_shutdown,"Servers MAY close the connection after sending the closure alert, thus generating an incomplete close on the client side.",326,Fully Matches,"[{'C1': {'code': 'SSL_set_shutdown(ssl, shutdown_type);\nmodssl_smart_shutdown(ssl);', 'explanation': 'This segment initiates the shutdown by setting the shutdown mode (which involves sending a close_notify alert) and then performing the smart shutdown. It directly implements the requirement that the server must attempt to initiate an exchange of closure alerts before closing the connection.'}}, {'A1': {'code': 'default:\n    /* send close notify, but don\'t wait for clients close notify\n       (standard compliant and safe, so it\'s the DEFAULT!) */\n    shutdown_type = SSL_RECEIVED_SHUTDOWN;\n    type = ""standard"";\n    logno = APLOGNO(02001);\n    break;', 'explanation': 'In the default case, the function sends a close_notify alert and deliberately does not wait for the client’s close_notify response. This behavior aligns with the RFC allowance to close the connection after sending the alert, which may lead to an incomplete close on the client side.'}}]","The function implements the RFC by ensuring that a close_notify alert is sent as part of the shutdown process (C1). It covers both scenarios where the server waits for or does not wait for the client's response (A1), thus addressing the specification that servers must initiate an exchange of closure alerts, yet are allowed to close the connection after sending the alert. All the key aspects of the spec are visibly handled in this function.",success,
17894,stapling_cache_response,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'rv = mc->stapling_cache->store(mc->stapling_cache_context, s,\n                               cinf->idx, sizeof(cinf->idx),\n                               expiry, resp_der, stored_len, pool);', 'explanation': 'This segment implements caching of the OCSP response by storing it with an expiry value, fulfilling the aspect of the spec that allows a cache to be employed.'}}]","The specified RFC states that any client or server may employ a cache, but a cache cannot be used while acting as a tunnel. The code function clearly implements the caching mechanism by encoding, setting an expiry, and storing an OCSP response, thereby addressing the permitted use of caches. However, the code does not include any logic to check whether it is acting as a tunnel (and thus whether the cache should be disabled), meaning that part of the specification is not enforced within this function. Consequently, the function only partially meets the RFC requirements.",success,
17895,stapling_get_cached_response,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, stapling_get_cached_response, is focused on retrieving and parsing a cached OCSP response from a cache and does not generate any new protocol elements. The RFC specification requires that a sender must not generate protocol elements or syntax alternatives reserved for other roles. There is no visible logic within this function that addresses role verification or preventing the generation of forbidden protocol elements. Therefore, none of the spec constraints (e.g., C1, A1) are implemented within this function in isolation.",success,
17895,stapling_get_cached_response,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided function is focused on retrieving a cached OCSP response for stapling purposes and managing thread safety for that cache. It does not incorporate any logic that checks whether the entity is acting as a tunnel nor does it embody any mechanism that restricts cache usage when in tunnel mode, as stated in the RFC specification. Thus, from the function_body alone, there is no visible attempt to implement the caching constraints (e.g., using a cache only when not acting as a tunnel) required by the RFC.",success,
17895,stapling_get_cached_response,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (resp_derlen <= 1) {\n    /* should-not-occur; must have at least valid-when-stored flag +\n     * OCSPResponseStatus\n     */\n    ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01931)\n                 ""stapling_get_cached_response: response length invalid??"");\n    return;\n}\n...\nrsp = d2i_OCSP_RESPONSE(NULL, &p, resp_derlen);\nif (!rsp) {\n    ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(01932)\n                 ""stapling_get_cached_response: response parse error??"");\n    return;\n}', 'explanation': 'The code defensively checks the received data by ensuring the buffer is longer than a minimal length and validating the parse result. This shows an effort to cope with potentially malformed or nonconforming responses in line with the idea of defensive parsing.'}}, {'A1': {'code': 'unsigned char resp_der[MAX_STAPLING_DER];\nunsigned int resp_derlen = MAX_STAPLING_DER;\n\nrv = mc->stapling_cache->retrieve(mc->stapling_cache_context, s,\n                                  cinf->idx, sizeof(cinf->idx),\n                                  resp_der, &resp_derlen, pool);', 'explanation': 'The function sets a fixed maximum buffer size (MAX_STAPLING_DER) and attempts to retrieve the protocol element into it, reflecting the notion of preparing to handle responses of a reasonable length.'}}]","The function attempts to implement defensive parsing by preallocating a buffer of fixed maximum size, checking that the response meets a minimum length requirement, and validating the correctness of the parsed response using d2i_OCSP_RESPONSE. These elements indicate that the function is designed to operate with only marginal expectations about the conformance of the received element to its expected format. However, not every aspect of the RFC's recommendations (such as detailed ABNF validation or flexible adaptations to varying contexts) is handled solely in this function, resulting in a partial match.",success,
17895,stapling_get_cached_response,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function solely retrieves, validates (via a length check and DER decoding) and outputs a cached OCSP response. It does not contain any logic that ensures that the protocol elements being generated (if any) conform to the ABNF grammar as required by the RFC spec. In other words, there is no explicit code in this function that prevents the generation of protocol elements that do not match the grammar, and any validation of the response grammar is solely handled by the d2i_OCSP_RESPONSE function call, which is not a direct implementation of the HTTP spec’s ABNF grammar rules. Therefore, the function does not visibly address the specified constraints.",success,
17898,stapling_renew_response,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'if (!uri.port) {\n    uri.port = apr_uri_port_of_scheme(uri.scheme);\n}', 'explanation': ""The function checks if the 'uri.port' is not provided and assigns it the default port for the given scheme. This directly implements the spec requirement that if no port is specified, the default port for the protocol should be assumed.""}}]","The function explicitly handles the case where no port is provided in the OCSP URI by checking 'if (!uri.port)' and using 'apr_uri_port_of_scheme' to set the default port. This logic directly addresses the RFC specification requiring that a missing port be interpreted as the default port, thereby fully meeting the labeled constraint (C1).",success,
17898,stapling_renew_response,"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",225,Does Not Match,[],"The RFC constraint requires that a sender MUST NOT generate an ""https"" URI with an empty host identifier. In the function, there is no code that checks for an empty host identifier in an https URI. In fact, the function only accepts URIs with the ""http"" scheme (as seen in the check using strcmp), and it rejects any URI that is not ""http"". Therefore, there is no visible logic within this function that implements the specified constraint.",success,
17908,get_and_check_cached_response,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'stapling_get_cached_response(s, rsp, &ok, cinf, p);\n\nif (*rsp) {\n    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(01953) ""stapling_cb: retrieved cached response"");\n    rv = stapling_check_response(s, mctx, cinf, *rsp, NULL);\n    ...', 'explanation': 'This segment retrieves and validates a cached OCSP response, demonstrating that the function employs a cache as outlined in the spec (i.e. using previous response messages stored locally).'}}]","The spec states that clients or servers MAY use a cache for storing responses, and the function clearly attempts to retrieve a cached OCSP response (thus implementing a cache usage condition). However, the spec also mandates that a cache must not be used when acting as a tunnel. The function does not contain any logic to check or enforce that condition. As dependencies cannot be considered, the function only partially implements the spec constraints.",success,
17910,stapling_cb,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'if ((cinf = stapling_get_certinfo(s, idx, sizeof(idx), mctx, ssl)) == NULL) {\n    return SSL_TLSEXT_ERR_NOACK;\n}\n\nrv = get_and_check_cached_response(s, mctx, &rsp, &ok, cinf, conn->pool);\nif (rv != 0) {\n    return rv;\n}\n\nif (rsp == NULL) {\n    /* ... attempting to renew cached response ... */\n    rv = stapling_renew_response(s, mctx, ssl, cinf, &rsp, &ok, conn->pool);\n}\n\nif (rsp && ((ok == TRUE) || (mctx->stapling_return_errors == TRUE))) {\n    if (!stapling_set_response(ssl, rsp)) {\n        rv = SSL_TLSEXT_ERR_ALERT_FATAL;\n    } else {\n        rv = SSL_TLSEXT_ERR_OK;\n    }\n}\nelse {\n    rv = SSL_TLSEXT_ERR_NOACK;\n}\nOCSP_RESPONSE_free(rsp);', 'explanation': 'This segment demonstrates that the function attempts to employ a cache by retrieving cached OCSP responses and, if not found or stale, renewing the cached response, thereby addressing the condition that a cache may be employed.'}}]","The provided function implements a caching mechanism for OCSP responses by checking for an existing cached response and renewing it when necessary. This addresses part of the spec, particularly the allowance ('MAY employ a cache'). However, the function does not include any logic to check or enforce that 'a cache cannot be used while acting as a tunnel.' Since not all aspects (e.g., the tunnel condition) of the spec are handled within the function, the overall match is only partial.",success,
18017,determine_responder_uri,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'if (!u->port) {', 'explanation': 'This check verifies whether the parsed URI lacks an explicit port, thereby addressing the condition where no port is provided.'}}, {'A1': {'code': 'u->port = apr_uri_port_of_scheme(u->scheme);', 'explanation': 'When the port is absent, the code assigns the default port for the HTTP scheme, directly implementing the RFC requirement to interpret missing ports as the default port.'}}]","The function 'determine_responder_uri' correctly parses the responder URI and explicitly checks for a missing port. When no port is provided, it sets the port field to the default port of the scheme (HTTP in this case) using 'apr_uri_port_of_scheme'. This behavior meets the RFC specification that states a missing port may be interpreted as meaning the message was received on the default port. All relevant logic is contained within the function, independent of any external dependencies.",success,
18017,determine_responder_uri,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Fully Matches,"[{'C1': {'code': 'rv = apr_uri_parse(p, s, u);\n    if (rv || !u->hostname) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c, APLOGNO(01919)\n                      ""failed to parse OCSP responder URI \'%s\'"", s);\n        return NULL;\n    }', 'explanation': 'The code checks whether the parsed URI has an empty hostname (i.e., empty host identifier). If it does, it logs an error and returns NULL, thereby preventing generation of an HTTP URI with an empty host identifier as required by the spec.'}}]","The function 'determine_responder_uri' includes logic that parses the responder URI and then verifies that the resulting URI structure includes a non-empty hostname. This matches the spec constraint that the 'http' URI must not have an empty host identifier, fulfilling the requirement entirely within the function itself.",success,
18017,determine_responder_uri,"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",225,Partially Matches,"[{'C1': {'code': 'rv = apr_uri_parse(p, s, u);\nif (rv || !u->hostname) {\n    ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c, APLOGNO(01919)\n                  ""failed to parse OCSP responder URI \'%s\'"", s);\n    return NULL;\n}', 'explanation': ""This code parses the URI and checks that the hostname is present. This prevents the generation of a URI with an empty host identifier, which partly aligns with the spec constraint. However, the function only accepts 'http' URIs and explicitly rejects any non-http scheme, including 'https'. Thus, while it avoids empty hosts, it does not attempt to generate or properly handle 'https' URIs as specified.""}}]","The RFC requires that a sender must not generate an 'https' URI with an empty host identifier. The function does check for an empty hostname after parsing the URI, which indirectly ensures that an empty host won’t be used. However, it only handles 'http' URIs (rejecting others, including 'https'), meaning it does not implement logic for generating or validating 'https' URIs according to the RFC. This is why the implementation partially meets the specification.",success,
18017,determine_responder_uri,A recipient that processes such a URI reference MUST reject it as invalid.,224,Fully Matches,"[{'C1': {'code': 'rv = apr_uri_parse(p, s, u);\n    if (rv || !u->hostname) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c, APLOGNO(01919)\n                      ""failed to parse OCSP responder URI \'%s\'"", s);\n        return NULL;\n    }', 'explanation': 'This code segment explicitly checks if the parsed URI has an empty hostname (or if parsing fails) and, if so, rejects the URI by returning NULL. This directly implements the RFC requirement that a recipient processing an http URI with an empty host must reject it as invalid.'}}]","The function 'determine_responder_uri' verifies that the OCSP responder URI is valid by parsing it and ensuring that, for http URIs, the hostname is non-empty. If the hostname is missing, it logs an error and returns NULL, effectively rejecting the URI as invalid. This behavior fully meets the RFC specification requiring that a recipient must reject an http URI with an empty host identifier.",success,
18062,upgrade_connection,"A server that sends a 101 (Switching Protocols) response MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched; if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order.",26,Partially Matches,"[{'A1': {'code': 'rv = ap_fputs(conn->output_filters, bb, SWITCH_STATUS_LINE CRLF\n                  UPGRADE_HEADER CRLF CONNECTION_HEADER CRLF CRLF);', 'explanation': 'This code sends a 101 Switching Protocols response along with an Upgrade header field, which fulfills the requirement to include the Upgrade header field when switching protocols.'}}]","The function attempts to implement the RFC requirement by sending a 101 response and including an Upgrade header field, which addresses the primary condition (C1). However, it does not explicitly handle or verify that multiple protocol layers are listed in layer-ascending order (C2) nor does it validate that the protocol was indicated by the client. Therefore, only part of the spec constraints is visibly addressed within this function.",success,
18062,upgrade_connection,"A server MAY send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.",29,Fully Matches,"[{'C1': {'code': 'rv = ap_fputs(conn->output_filters, bb, SWITCH_STATUS_LINE CRLF\n                  UPGRADE_HEADER CRLF CONNECTION_HEADER CRLF CRLF);', 'explanation': 'This segment constructs a response that includes a status line along with the Upgrade header and Connection header. It visibly implements the requirement of sending an Upgrade header field (as per the RFC spec both for advertising upgrade capability and for use in upgrade-required responses).'}}, {'A1': {'code': 'SSL_set_accept_state(ssl);\n\nif ((SSL_do_handshake(ssl) != 1) || !SSL_is_init_finished(ssl)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02030)\n                  ""TLS upgrade handshake failed"");\n    ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, r->server);\n\n    return APR_ECONNABORTED;\n}', 'explanation': 'This segment initiates and verifies the TLS handshake, which is the subsequent action required after indicating upgrade support in the response. It ensures that the upgraded connection meets protocol requirements.'}}]","The function 'upgrade_connection' sends a response that includes the needed Upgrade header (via the concatenation of SWITCH_STATUS_LINE, UPGRADE_HEADER and CONNECTION_HEADER) and then proceeds with establishing a TLS connection by performing the handshake. These implementations directly address the RFC stipulation that a server may (or must, in the case of a 426 response) include an Upgrade header to advertise protocol upgrade support, thereby fully matching the spec constraints (here labeled as C1 and A1) within the visible scope of the function.",success,
18070,ssl_hook_ReadReq,A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field.,27,Partially Matches,"[{'C1': {'code': 'if (sc->enabled == SSL_ENABLED_OPTIONAL && !myConnConfig(r->connection)\n        && (upgrade = apr_table_get(r->headers_in, ""Upgrade"")) != NULL\n        && ap_find_token(r->pool, upgrade, ""TLS/1.0"")) {\n        if (upgrade_connection(r)) {\n            return AP_FILTER_ERROR;\n        }\n    }', 'explanation': 'This block of code checks the Upgrade header from the client for the token ""TLS/1.0"" and only attempts the protocol upgrade if it is present. This reflects the part of the RFC that requires a server not to switch protocols that were not indicated by the client.'}}]","The function inspects the client's Upgrade header and only triggers a TLS upgrade when the token ""TLS/1.0"" is found, which aligns with the requirement that the server must only switch to a protocol indicated by the client. However, later in the function a response header is set containing ""TLS/1.0, HTTP/1.1"" without verifying that ""HTTP/1.1"" was requested by the client. This inclusion of an additional protocol that the client may not have indicated means that the function only partially meets the RFC specification.",success,
18070,ssl_hook_ReadReq,The server MUST generate an Upgrade header field in the response that indicates which protocol(s) will be in effect after this response.,140,Fully Matches,"[{'A1': {'code': 'if (sc->enabled == SSL_ENABLED_OPTIONAL && !(sslconn && sslconn->ssl)\n        && !r->main) {\n    apr_table_setn(r->headers_out, ""Upgrade"", ""TLS/1.0, HTTP/1.1"");\n    apr_table_mergen(r->headers_out, ""Connection"", ""upgrade"");\n}', 'explanation': ""This segment directly sets the Upgrade header in the response with the protocols 'TLS/1.0, HTTP/1.1', which fulfills the RFC requirement that the server MUST include an Upgrade header indicating the protocol(s) in effect after switching.""}}]","The function explicitly checks for conditions under which an SSL/TLS upgrade should occur and, when appropriate, it adds the 'Upgrade' header (and the 'Connection: upgrade' header) to the outgoing response. This directly implements the RFC specification that requires the server to generate an Upgrade header in its response, thereby fully meeting the constraint.",success,
18070,ssl_hook_ReadReq,A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection.,25,Fully Matches,"[{'C1': {'code': 'if (sc->enabled == SSL_ENABLED_OPTIONAL && !myConnConfig(r->connection) && (upgrade = apr_table_get(r->headers_in, ""Upgrade"")) != NULL && ap_find_token(r->pool, upgrade, ""TLS/1.0"")) {\n    if (upgrade_connection(r)) {\n        return AP_FILTER_ERROR;\n    }\n}', 'explanation': ""This code segment checks for the presence of the Upgrade header and for a 'TLS/1.0' token. In accordance with the RFC, the decision to perform an upgrade (or not) is made based on configuration. If conditions aren’t satisfied, the header is effectively ignored, which complies with the RFC statement that a server MAY ignore the Upgrade header.""}}, {'A1': {'code': 'if (sc->enabled == SSL_ENABLED_OPTIONAL && !(sslconn && sslconn->ssl) && !r->main) {\n    apr_table_setn(r->headers_out, ""Upgrade"", ""TLS/1.0, HTTP/1.1"");\n    apr_table_mergen(r->headers_out, ""Connection"", ""upgrade"");\n}', 'explanation': 'This segment proactively sets the response Upgrade header and related Connection header when the server is configured for optional SSL and the connection is not already secure. This clearly shows that the Upgrade header is not being forced to change the protocol, thus aligning with the RFC’s language that the header may be ignored if the current protocol is to be continued.'}}]","The code in function_body inspects the incoming Upgrade header, and based on configuration (SSLEngine set to optional), it conditionally initiates a TLS upgrade or leaves the request to continue with the current protocol. Both the detection of an Upgrade header and the conditional sending back of an Upgrade header in the response demonstrate that the function follows the spec's guidance that a server may ignore the Upgrade header if it wishes to continue with the current protocol. All logic addressing the spec is contained within this function, and therefore it fully meets the requirements of the given RFC specification.",success,
18070,ssl_hook_ReadReq,"A server MAY send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.",29,Fully Matches,"[{'A1': {'code': 'if (sc->enabled == SSL_ENABLED_OPTIONAL && !(sslconn && sslconn->ssl)\n    && !r->main) {\n    apr_table_setn(r->headers_out, ""Upgrade"", ""TLS/1.0, HTTP/1.1"");\n    apr_table_mergen(r->headers_out, ""Connection"", ""upgrade"");\n}', 'explanation': ""This code block implements the action required by the RFC: advertising support for protocol upgrade. It checks that the server is configured with an optional SSLEngine, ensures the connection is not already upgraded (non-SSL) and that the request is an initial request (not a subrequest), then sets the 'Upgrade' header with the supported protocols in descending preference and the associated 'Connection' header, directly addressing the spec.""}}]","The function visibly implements the RFC's specification regarding the Upgrade header by including logic to set the appropriate Upgrade and Connection headers in the response. The code directly checks the necessary conditions and then advertises support for upgrading (e.g., 'TLS/1.0, HTTP/1.1') in the response, fully addressing the constraint stated in the RFC.",success,
18070,ssl_hook_ReadReq,"A sender of Upgrade MUST also send an ""Upgrade"" connection option in the Connection header field (Section 7.6.1) to inform intermediaries not to forward this field.",31,Partially Matches,"[{'A1': {'code': 'if (sc->enabled == SSL_ENABLED_OPTIONAL && !(sslconn && sslconn->ssl) && !r->main) {\n    apr_table_setn(r->headers_out, ""Upgrade"", ""TLS/1.0, HTTP/1.1"");\n    apr_table_mergen(r->headers_out, ""Connection"", ""upgrade"");\n}', 'explanation': ""This code segment ensures that when the request is not using an SSL connection and the engine is optional, the response contains an Upgrade header and adds 'upgrade' to the Connection header, addressing the requirement that an Upgrade sender also send the Upgrade option in the Connection header field.""}}]","The function does include logic to set the Upgrade response header and to merge the 'upgrade' token into the Connection header. This aligns with part of the RFC specification requirement. However, the RFC also covers additional conditional behaviors (e.g., handling HTTP/1.0 requests, processing both Upgrade and Expect headers, ensuring the client does not switch protocol mid-request) which are not directly implemented here. Thus, the function partially matches the given constraints.",success,
18075,ssl_hook_Access,"A sender of Upgrade MUST also send an ""Upgrade"" connection option in the Connection header field (Section 7.6.1) to inform intermediaries not to forward this field.",31,Partially Matches,"[{'C1': {'code': 'if ((sc->enabled == SSL_ENABLED_OPTIONAL) && !r->connection->master) {\n    apr_table_setn(r->err_headers_out, ""Upgrade"", ""TLS/1.0, HTTP/1.1"");\n    apr_table_setn(r->err_headers_out, ""Connection"", ""Upgrade"");\n    return HTTP_UPGRADE_REQUIRED;\n}', 'explanation': ""This code segment sets the 'Upgrade' header and the 'Connection' header to 'Upgrade' when an SSL connection is required but not present, thereby addressing the spec condition that a sender of Upgrade must include an 'Upgrade' option in the Connection header. However, other aspects of the spec (e.g., handling HTTP/1.0 requests or processing combined Upgrade/Expect headers) are not addressed in this function.""}}]","The function partially addresses the specified RFC requirement by ensuring that when SSL is optional yet required and not present, it returns an HTTP_UPGRADE_REQUIRED response along with both the 'Upgrade' and 'Connection: Upgrade' headers. This complies with the requirement that a sender of Upgrade must include the appropriate connection option. However, the function does not handle the additional constraints mentioned in the spec, such as ignoring Upgrade headers in HTTP/1.0 requests or managing protocol switch timing, so it only partially matches the overall specification.",success,
18075,ssl_hook_Access,"A server MAY send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.",29,Fully Matches,"[{'C1': {'code': 'if (dc->bSSLRequired && !ssl) {\n    if ((sc->enabled == SSL_ENABLED_OPTIONAL) && !r->connection->master) {\n        apr_table_setn(r->err_headers_out, ""Upgrade"", ""TLS/1.0, HTTP/1.1"");\n        apr_table_setn(r->err_headers_out, ""Connection"", ""Upgrade"");\n\n        return HTTP_UPGRADE_REQUIRED;\n    }\n    ...\n}', 'explanation': 'This branch checks when an SSL connection is required but not present and, in the case of an optional SSL configuration (and a normal connection, not a master), it sets the Upgrade header field as well as the Connection header to signal available protocols before returning a 426 (Upgrade Required) response. This directly implements the RFC requirement that a 426 response MUST include an Upgrade header field indicating acceptable protocols.'}}]","The provided function contains a specific code branch that, when SSL is required but not available, and the server’s configuration is set as optional, sets the 'Upgrade' and 'Connection' headers (with the values 'TLS/1.0, HTTP/1.1' and 'Upgrade', respectively) and returns HTTP_UPGRADE_REQUIRED (426). This matches the RFC specification which mandates that a 426 response include an Upgrade header field to indicate acceptable protocols. All pertinent logic addressing this requirement is visible within the function body itself, and therefore the function fully meets the relevant constraint.",success,
18075,ssl_hook_Access,"A server that sends a 426 (Upgrade Required) response MUST send an Upgrade header field to indicate the acceptable protocols, in order of descending preference.",28,Fully Matches,"[{'A1': {'code': 'if (dc->bSSLRequired && !ssl) {\n    if ((sc->enabled == SSL_ENABLED_OPTIONAL) && !r->connection->master) {\n        apr_table_setn(r->err_headers_out, ""Upgrade"", ""TLS/1.0, HTTP/1.1"");\n        apr_table_setn(r->err_headers_out, ""Connection"", ""Upgrade"");\n\n        return HTTP_UPGRADE_REQUIRED;\n    }', 'explanation': ""When SSL is required but missing in an optional SSL setup, the function explicitly sets the 'Upgrade' header (with protocols listed as 'TLS/1.0, HTTP/1.1' in descending order of preference) and sends a 426 Upgrade Required response. This directly implements the RFC requirement.""}}]","The function directly addresses the specified RFC by checking if an SSL connection is required and absent, then setting the appropriate Upgrade header and returning a 426 (Upgrade Required) response. This code segment fulfills the requirement that a 426 response must include an Upgrade header with acceptable protocols in order of descending preference.",success,
18075,ssl_hook_Access,"A server that sends a 101 (Switching Protocols) response MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched; if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order.",26,Partially Matches,"[{'A1': {'code': 'if (dc->bSSLRequired && !ssl) {\n    if ((sc->enabled == SSL_ENABLED_OPTIONAL) && !r->connection->master) {\n        apr_table_setn(r->err_headers_out, ""Upgrade"", ""TLS/1.0, HTTP/1.1"");\n        apr_table_setn(r->err_headers_out, ""Connection"", ""Upgrade"");\n\n        return HTTP_UPGRADE_REQUIRED;\n    }\n    ...\n}', 'explanation': ""Here the function explicitly sets an 'Upgrade' header (and a 'Connection' header of 'Upgrade') when SSL is required but not in use. This is an attempt to adhere to the RFC requirement that an upgrade response include an Upgrade header field. However, it only handles the case for an HTTP_UPGRADE_REQUIRED (426) response with hard-coded protocol values, rather than a negotiated 101 Switching Protocols response and/or dynamic ordering if multiple protocol layers are involved.""}}]","The RFC specifies that a server sending a Switching Protocols (101) response must include an Upgrade header listing the new protocol(s) in layer-ascending order. In this function, the relevant logic is triggered when an SSL connection is required but not present, leading to a 426 (Upgrade Required) response where the Upgrade header is set to 'TLS/1.0, HTTP/1.1'. While this shows an attempt to implement an upgrade header as required by the RFC, the implementation is partial. It uses a hard-coded header for a specific error case and does not cover the full set of conditions (including proper handling for 101 responses and dynamic ordering of protocols). Therefore, within the context of this function alone, the RFC requirement is only partially addressed.",success,
18075,ssl_hook_Access,The server MUST send an Upgrade header field in a 426 response to indicate the required protocol(s) (Section 7.8).,167,Fully Matches,"[{'C1': {'code': 'if (dc->bSSLRequired && !ssl) {\n    if ((sc->enabled == SSL_ENABLED_OPTIONAL) && !r->connection->master) {\n        apr_table_setn(r->err_headers_out, ""Upgrade"", ""TLS/1.0, HTTP/1.1"");\n        apr_table_setn(r->err_headers_out, ""Connection"", ""Upgrade"");\n        return HTTP_UPGRADE_REQUIRED;\n    }', 'explanation': ""This code branch checks if SSL is required but not present. In the case of an optional SSL configuration, it sets the 'Upgrade' header (and the 'Connection' header) and returns the HTTP_UPGRADE_REQUIRED (426) status code, thereby meeting the RFC requirement to send an Upgrade header in a 426 response.""}}]","The function explicitly handles the scenario where an SSL connection is required but absent by setting the necessary 'Upgrade' and 'Connection' headers and returning the 426 status code. This direct implementation within the function meets the RFC specification's requirement, and therefore the code fully matches the constraint.",success,
18075,ssl_hook_Access,The server MUST generate an Upgrade header field in the response that indicates which protocol(s) will be in effect after this response.,140,Partially Matches,"[{'C1': {'code': 'if (dc->bSSLRequired && !ssl) {\n    if ((sc->enabled == SSL_ENABLED_OPTIONAL) && !r->connection->master) {\n        apr_table_setn(r->err_headers_out, ""Upgrade"", ""TLS/1.0, HTTP/1.1"");\n        apr_table_setn(r->err_headers_out, ""Connection"", ""Upgrade"");\n\n        return HTTP_UPGRADE_REQUIRED;\n    }\n    ...\n}', 'explanation': ""This block checks for when an SSL connection is required but missing in an optional SSL configuration, and it explicitly sets the 'Upgrade' header (and 'Connection: Upgrade') in the output headers before returning a code (HTTP_UPGRADE_REQUIRED). This addresses the RFC requirement that the server generate an Upgrade header field indicating the protocols to be used after the response. However, this logic is applied only in a specific branch of the function and does not comprehensively handle every context where the RFC mandate might apply.""}}]","The function attempts to address the RFC specification by generating the Upgrade header in the response when an SSL connection is required but absent, which triggers an upgrade. While it does set the 'Upgrade' and 'Connection' headers as mandated, it only does so in a conditional branch (for an optionally SSL-enabled vhost) rather than as a general response to all upgrade scenarios. Therefore, the implementation partially matches the RFC specification within the context of this function.",success,
18076,ssl_hook_UserCheck,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The RFC specification requires that a sender must not generate multiple field lines with the same name (unless allowed by the field's definition) and that the order of these field lines is significant. The function 'ssl_hook_UserCheck' only retrieves and overwrites the 'Authorization' header using apr_table_get and apr_table_setn without any explicit logic addressing the prevention of multiple header fields or preserving their order as per the RFC. No part of the function implements logic to verify or manage duplicate header field lines, so it does not meet any of the specified constraints by itself.",success,
18088,ssl_callback_NewSessionCacheEntry,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'rc = ssl_scache_store(s, id, idlen, apr_time_from_sec(SSL_SESSION_get_time(session) + timeout), session, conn->pool);', 'explanation': 'This line stores the SSL session in an inter-process cache, showing that the function employs a cache as allowed by the RFC.'}}]","The RFC specifies that a cache may be used, but it must not be used when acting as a tunnel. The function implements caching by storing the SSL session with an expiration timeout, which fulfills the part of the spec that allows employing a cache. However, there is no logic in the function to determine if it is operating in tunnel mode and to disable or avoid caching in that scenario. Therefore, while the caching aspect (C1) is implemented, the restriction concerning tunnel use is not addressed, leading to a partial match.",success,
18102,serialize_request,A sender MUST NOT send whitespace between the start-line and the first header field.,295,Fully Matches,"[{'C1': {'code': 'BIO_printf(bio, ""%s%s%s HTTP/1.0\\r\\n""\n           ""Host: %s:%d\\r\\n""\n           ""Content-Type: application/ocsp-request\\r\\n""\n           ""Connection: close\\r\\n""\n           ""Content-Length: %d\\r\\n""\n           ""\\r\\n"",\n           uri->path ? uri->path : ""/"",\n           uri->query ? ""?"" : """", uri->query ? uri->query : """",\n           uri->hostname, uri->port, len);', 'explanation': 'This code constructs the HTTP request with the start-line followed immediately by the header fields, ensuring that no extra CRLF or whitespace is sent between the start-line and the first header field, which satisfies the specification.'}}]","The function assembles an HTTP request by printing the start-line (which includes 'POST', an optional full URL, and the request target) and then immediately printing the header fields. There is no insertion of any additional whitespace (CRLF) between the request-line and the first header field. This directly meets the RFC specification requirement that a sender MUST NOT send whitespace between the start-line and the first header field. All logic fulfilling this condition is contained within the function_body.",success,
18102,serialize_request,"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",225,Does Not Match,[],"The RFC requires that a sender MUST NOT generate an ""https"" URI with an empty host identifier. In the provided function_body, there is no logic that verifies if the host identifier (uri->hostname) is empty when generating the URI, nor is there any condition handling for generating an ""https"" URI. The function simply formats the request using the hostname and port without checking for emptiness. Therefore, the function does not visibly address the constraint specified by the RFC.",success,
18102,serialize_request,A sender MUST NOT send a connection option corresponding to a field that is intended for all recipients of the content.,252,Does Not Match,[],"The RFC specification requires that a sender MUST NOT send a connection option corresponding to a field intended for all recipients of the content. In this function, the HTTP request is constructed with a fixed set of headers, including a 'Connection: close' header. There is no logic in the function that checks for or omits connection options corresponding to fields that are meant for all recipients (for example, ensuring that headers like 'Cache-Control' are not mistakenly sent as connection options). Since the function does not incorporate any measures to enforce this RFC requirement within its own logic, it does not visibly address the specified constraint.",success,
18102,serialize_request,A sender MUST NOT generate BWS in messages.,239,Does Not Match,[],"The RFC requires that a sender MUST NOT generate BWS (bad whitespace) in messages. This function constructs an HTTP request message by printing fixed strings (e.g., ""POST "", "" HTTP/1.0\r\n"" etc.) and concatenating parts of the URI. There is no explicit logic in the function to detect, prevent, or remove BWS, nor is there any replacement of optional whitespace (OWS/RWS) with a single SP as outlined in the spec context. Thus, the function does not visibly address the requirement regarding BWS, and it cannot be considered an implementation of that part of the RFC on its own.",success,
18102,serialize_request,"A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the ""message/http"" media type.",301,Fully Matches,"[{'C1': {'code': 'BIO_printf(bio, ""%s%s%s HTTP/1.0\\r\\n""\n               ""Host: %s:%d\\r\\n""\n               ""Content-Type: application/ocsp-request\\r\\n""\n               ""Connection: close\\r\\n""\n               ""Content-Length: %d\\r\\n""\n               ""\\r\\n"",\n               uri->path ? uri->path : ""/"",\n               uri->query ? ""?"" : """", uri->query ? uri->query : """",\n               uri->hostname, uri->port, len);', 'explanation': 'The function constructs an HTTP request by printing each header separately using explicit CRLF (""\\r\\n"") sequences. It does not insert any continuation lines (i.e. no extra line folding) in any header field, thereby complying with the RFC requirement to avoid the obs-fold rule unless within a ""message/http"" media type.'}}]","The provided function serializes an OCSP request by constructing HTTP headers with explicit CRLF terminations and without introducing any folded header lines. Since it does not generate any header line that begins with a space or horizontal tab following a CRLF, it inherently fulfills the specification that prohibits line folding (obs-fold) outside of the ""message/http"" context. Dependencies and other callers do not contribute to this logic, and thus the function itself fully matches the constraint.",success,
18102,serialize_request,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Partially Matches,"[{'C1': {'code': 'BIO_printf(bio, ""%s%s%s HTTP/1.0\\r\\n""\n               ""Host: %s:%d\\r\\n""\n               ""Content-Type: application/ocsp-request\\r\\n""\n               ""Connection: close\\r\\n""\n               ""Content-Length: %d\\r\\n""\n               ""\\r\\n"",\n               uri->path ? uri->path : ""/"",\n               uri->query ? ""?"" : """", uri->query ? uri->query : """",\n               uri->hostname, uri->port, len);', 'explanation': 'The RFC mandates that a sender must not generate a bare CR and the line terminators for the start-line and fields should use CRLF. This code explicitly uses ""\\r\\n"" sequences when constructing the HTTP request, thereby ensuring compliance with the sender’s requirement.'}}]","The function builds and serializes an HTTP request using explicit CRLF line ending sequences, which directly addresses the sender-side requirement to avoid bare CR characters in protocol elements. However, the RFC also discusses recipient behavior (such as recognizing single LF and handling bare CR), but this logic is not implemented within the function since it is solely responsible for request creation. Thus, while the function meets the sender aspect of the specification (labeled here as C1), it does not address the recipient-side parsing concerns, resulting in a partial match of the overall RFC specification.",success,
18102,serialize_request,"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT",71,Fully Matches,"[{'C1': {'code': 'BIO_printf(bio, ""POST "");', 'explanation': ""The function explicitly writes the 'POST' method in the request line, fulfilling the requirement to use POST for state-changing requests as specified by the RFC.""}}, {'A1': {'code': 'if (proxy_uri) {\n    BIO_printf(bio, ""http://%s:%d"", uri->hostname, uri->port);\n}', 'explanation': ""This segment addresses the proper selection of a full URL when a proxy is used, ensuring that the correct URI is included in the request, which is consistent with the specification's intent.""}}]","The function constructs an HTTP request using the POST method and handles the case where a proxy is involved by selecting the full URL, which directly implements the conditions set by the RFC specification. The code clearly demonstrates the use of POST (rather than PUT) and correct URI selection based solely on its internal logic, hence it fully meets the provided constraints.",success,
18102,serialize_request,"Likewise, a sender MUST NOT forward a message with a Content-Length header field value that does not match the ABNF above, with one exception: a recipient of a Content-Length header field value consisting of the same decimal value repeated as a comma-separated list (e.g, ""Content-Length: 42, 42"") MAY either reject the message as invalid or replace that invalid field value with a single instance of the decimal value, since this likely indicates that a duplicate was generated or combined by an upstream message processor.",49,Does Not Match,[],"The provided function only serializes an OCSP request and unconditionally writes a single 'Content-Length' header using the computed length. It does not contain any logic to verify that the Content-Length header value conforms to the ABNF specified in the RFC, nor does it implement the exception regarding comma‐separated duplicate values. Thus, none of the spec constraints (e.g., ensuring correct formatting or handling duplicates as per the RFC) are addressed within this function.",success,
18102,serialize_request,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The function calculates the Content-Length by serializing the OCSP request and then unconditionally writes it into the HTTP header. There is no logic within the function to verify whether the computed Content-Length is correct or to reject/modify the header if it is known to be incorrect as required by the RFC specification. Thus, none of the spec constraints (e.g., checking or rejecting an incorrect Content-Length value) are addressed by this function.",success,
18102,serialize_request,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'BIO_printf(bio, ""%s%s%s HTTP/1.0\\r\\n""\n           ""Host: %s:%d\\r\\n""\n           ""Content-Type: application/ocsp-request\\r\\n""\n           ""Connection: close\\r\\n""\n           ""Content-Length: %d\\r\\n""\n           ""\\r\\n"",\n           uri->path ? uri->path : ""/"",\n           uri->query ? ""?"" : """", uri->query ? uri->query : """",\n           uri->hostname, uri->port, len);', 'explanation': ""The code function explicitly adds a 'Content-Type' header field (with the value 'application/ocsp-request') to the HTTP message, which fulfills the RFC requirement that a message containing content SHOULD include a Content-Type header when the media type is known.""}}]","The function 'serialize_request' constructs an HTTP POST request for an OCSP request, and it includes the 'Content-Type: application/ocsp-request' header in the request. This directly implements the RFC mandate that messages with content have a Content-Type header field when the intended media type is known.",success,
18102,serialize_request,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Does Not Match,[],"The RFC specifies that a sender MUST NOT generate an 'http' URI with an empty host identifier. In the function, while the hostname (uri->hostname) is used to build the URI (for both proxy and non-proxy cases), there is no check to ensure that it is not empty. Therefore, the function does not implement the constraint regarding ensuring a non-empty host identifier.",success,
18102,serialize_request,"If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type.",35,Does Not Match,[],"The RFC specifies a behavior to deal with cases where a Content-Type header is missing (i.e., to default to 'application/octet-stream' or to inspect the data), but this function does not contain any conditional logic to handle the absence of a Content-Type header. Instead, it unconditionally prints a 'Content-Type: application/ocsp-request' header into the HTTP request. There is no code segment that implements the fallback mechanism described by the RFC, so the function does not attempt to implement the specified HTTP RFC behavior within itself.",success,
18102,serialize_request,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Fully Matches,"[{'C1': {'code': 'BIO_printf(bio, ""POST "");\n...\nBIO_printf(bio, ""%s%s%s HTTP/1.0\\r\\n""\n           ""Host: %s:%d\\r\\n""\n           ""Content-Type: application/ocsp-request\\r\\n""\n           ""Connection: close\\r\\n""\n           ""Content-Length: %d\\r\\n""\n           ""\\r\\n"",\n           uri->path ? uri->path : ""/"",\n           uri->query ? ""?"" : """", uri->query ? uri->query : """",\n           uri->hostname, uri->port, len);', 'explanation': 'The function builds the request line and header fields that are permitted for a client (sender). It only generates protocol elements (e.g., POST, Host, Content-Type, Content-Length) that conform to the allowed syntax for a sender, avoiding any elements reserved for other roles.'}}, {'A1': {'code': 'if (proxy_uri) {\n    BIO_printf(bio, ""http://%s:%d"", uri->hostname, uri->port);\n}', 'explanation': 'When a proxy is involved, the function correctly inserts the full URL as required. This ensures that even when routing through a proxy, the sender does not generate any extraneous or disallowed syntax alternatives.'}}]","The function 'serialize_request' constructs an HTTP request message strictly using the components allowed for a sender. It only emits valid client request elements and handles the special case for proxy requests appropriately. Therefore, by itself, it visibly implements the RFC requirement that a sender must not generate protocol elements or syntax alternatives that are only allowed for other roles.",success,
18102,serialize_request,"A sender SHOULD send a Connection header field (Section 7.6.1 of [HTTP]) containing the ""close"" connection option when it intends to close a connection.",212,Fully Matches,"[{'A1': {'code': 'BIO_printf(bio, ""%s%s%s HTTP/1.0\\r\\nHost: %s:%d\\r\\nContent-Type: application/ocsp-request\\r\\nConnection: close\\r\\nContent-Length: %d\\r\\n\\r\\n"", uri->path ? uri->path : ""/"", uri->query ? ""?"" : """", uri->query ? uri->query : """", uri->hostname, uri->port, len);', 'explanation': ""This code segment explicitly writes the 'Connection: close' header as required by the RFC, thereby signaling that the sender intends to close the connection after the response.""}}]","The function 'serialize_request' directly implements the RFC requirement by including the 'Connection: close' header in the HTTP request it constructs. The header is inserted within the formatted string that composes the HTTP request, which wholly satisfies the specification without relying on external dependencies.",success,
18102,serialize_request,"Since the TE header field only applies to the immediate connection, a sender of TE MUST also send a ""TE"" connection option within the Connection header field (Section 7.6.1 of [HTTP]) in order to prevent the TE header field from being forwarded by intermediaries that do not support its semantics.",210,Does Not Match,[],"The provided function constructs an HTTP POST request but does not address the RFC requirement regarding the TE header field. Specifically, the RFC mandates that if a TE header is sent, the Connection header must also include the 'TE' option to avoid improper forwarding by intermediaries. In the code, the Connection header is hardcoded as 'Connection: close' with no mention of a TE option, and there is no logic handling the TE header or its related connection option. Therefore, the function does not meet the spec constraint.",success,
18102,serialize_request,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Does Not Match,[],"The provided function always includes a Content-Length header (e.g., the line 'Content-Length: %d\r\n') without checking if a Transfer-Encoding header is present. According to the RFC specification, a sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field. Since the function does not conditionally omit the Content-Length header (or check for a Transfer-Encoding header) when necessary, it does not address the spec constraint. Additionally, no logic within the function inspects or handles the Transfer-Encoding header; all logic is confined to adding Content-Length regardless. Thus, the function does not fully implement the required behavior of the RFC as specified.",success,
18102,serialize_request,A server MAY reject a request that contains both Content-Length and Transfer-Encoding or process such a request in accordance with the Transfer-Encoding alone.,198,Does Not Match,[],"The RFC requires logic to handle the scenario where both Content-Length and Transfer-Encoding headers are present (e.g., rejecting the request or processing according to Transfer-Encoding, and ensuring the connection is closed). This function only serializes an OCSP request by including a Content-Length header and a Connection: close header; it does not check for or process a Transfer-Encoding header. Therefore, none of the labeled conditions or actions related to handling both headers are implemented within this function.",success,
18102,serialize_request,A server MAY reject a request that contains a message body but not a Content-Length by responding with 411 (Length Required).,203,Fully Matches,"[{'A1': {'code': 'BIO_printf(bio, ""%s%s%s HTTP/1.0\\r\\n""\n           ""Host: %s:%d\\r\\n""\n           ""Content-Type: application/ocsp-request\\r\\n""\n           ""Connection: close\\r\\n""\n           ""Content-Length: %d\\r\\n""\n           ""\\r\\n"",\n           uri->path ? uri->path : ""/"",\n           uri->query ? ""?"" : """", uri->query ? uri->query : """",\n           uri->hostname, uri->port, len);', 'explanation': ""This code segment constructs the HTTP request by explicitly outputting a valid 'Content-Length' header using the calculated length of the serialized OCSP request. This meets the RFC requirement that a request containing a message body should include a valid Content-Length header to avoid potential 411 (Length Required) responses.""}}]","The function 'serialize_request' creates an HTTP POST request that always includes the 'Content-Length' header by printing it out along with other required request elements. This directly addresses the RFC requirement that a request containing a message body should have a valid Content-Length header, ensuring that the server will not need to respond with a 411 status code. Therefore, the code function fully implements the relevant spec action (A1) within its own logic.",success,
18104,get_line,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'get_line' reads and processes a line from an OCSP server response, performing checks such as ensuring the line ends with LF, truncating CR, and handling errors. However, it does not implement or enforce any logic related to the RFC requirement that a sender must not generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. There is no code that checks or controls the generation of protocol elements based on sender roles. As a result, none of the labeled conditions or actions in the specification are visibly addressed by this function.",success,
18104,get_line,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'rv = apr_brigade_split_line(bbout, bbin, APR_BLOCK_READ, 8192);\nif (rv) {\n    ap_log_cerror(..., ""failed reading line from OCSP server"");\n    return NULL;\n}', 'explanation': ""This segment defensively reads an input line up to a fixed maximum length (8192), thereby limiting buffer usage and guarding against excessively long inputs. It reflects the idea of expecting only a 'reasonable buffer size' as indicated by the spec.""}}, {'A1': {'code': 'if (line[len-1] != APR_ASCII_LF) {\n    ap_log_cerror(..., ""response header line too long from OCSP server"");\n    return NULL;\n}', 'explanation': 'The function checks that the line ends with a newline character (and optionally a carriage return before it), which is a minimal validation step for protocol conformance as per the idea of marginal expectations about grammar.'}}]","The function 'get_line' implements defensive parsing by imposing a maximum read length and verifying the proper termination of the read line. This addresses part of the RFC specification that mandates a cautious approach when handling protocol elements whose format or length may vary. However, it does not fully validate ABNF grammar conformity or other potential irregularities beyond these basic checks, hence it only partially meets the overall spec constraints.",success,
18104,get_line,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Fully Matches,"[{'C1': {'code': 'if (line[len-1] != APR_ASCII_LF) {\n    ap_log_cerror(APLOG_MARK, APLOG_ERR, rv, c, APLOGNO(01979)\n                  ""response header line too long from OCSP server"");\n    return NULL;\n}\n\nline[len-1] = \'\\0\';\nif (len > 1 && line[len-2] == APR_ASCII_CR) {\n    line[len-2] = \'\\0\';\n}', 'explanation': 'This segment checks that the line ends with a LF (APR_ASCII_LF) and then, if the preceding character is a CR (APR_ASCII_CR), it removes it. This implements the RFC requirement that a recipient may recognize a single LF as a line terminator and ignore any preceding CR.'}}]","The function 'get_line' is designed to read a line from an OCSP server response and it explicitly enforces that the line terminator must be LF. After confirming the LF terminator, it removes the LF and, if present, an immediately preceding CR. This matches the specified HTTP RFC requirement that although lines should end with CRLF, a single LF is acceptable with any preceding CR being ignored. All related logic is contained within this function, fulfilling the condition without relying on external dependency implementation.",success,
18105,read_response,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'line = get_line(tmpbb, bb, c, p);\nif (!line || strncmp(line, ""HTTP/"", 5)\n    || (line = ap_strchr(line, \' \')) == NULL\n    || (code = apr_atoi64(++line)) < 200 || code > 299) { ... }', 'explanation': 'This segment checks that the response starts with an HTTP version string and validates the status code. It shows that the function expects a minimal conformance to the HTTP response format, addressing the idea of marginal expectations.'}}, {'A1': {'code': 'while ((line = get_line(tmpbb, bb, c, p)) != NULL && line[0] && ++count < MAX_HEADERS) { ... }\nif (count == MAX_HEADERS) { ... return NULL; }', 'explanation': 'This loop defensively reads header lines, limiting the number of headers to MAX_HEADERS, which helps ensure the response fits within a reasonable buffer size.'}}, {'A2': {'code': 'while (!APR_BRIGADE_EMPTY(bb)) {\n    ...\n    count += len;\n    if (count > MAX_CONTENT) {\n        ap_log_cerror(... ""OCSP response size exceeds %u byte limit"", MAX_CONTENT);\n        return NULL;\n    }\n    ...\n}', 'explanation': 'This block sums the content length and aborts if the total exceeds a predefined maximum (MAX_CONTENT), thus enforcing an upper bound on the buffer size.'}}]","The function implements several defensive parsing measures: it checks that the response begins with an expected HTTP status line, limits the number of header lines to prevent abuse, and imposes a maximum body size. These measures correspond to the spirit of the specification (defensive parsing with only marginal expectations regarding the payload’s exact grammar and size). However, while these checks are in place, the parsing remains relatively rigid (e.g. strictly expecting 'HTTP/' at the start) and does not fully relax the expectations as the spec might imply. For that reason, the function’s implementation only partially matches the complete intent of the specification.",success,
18106,modssl_dispatch_ocsp_request,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function modssl_dispatch_ocsp_request does not include any logic that explicitly checks or prevents the generation of protocol elements or syntax alternatives that are reserved for other roles, as required by the RFC specification. It focuses on serializing the OCSP request, sending it, and handling the response, but there is no visible implementation within this function that addresses constraints such as ensuring that only appropriate elements for the sender role are generated. Any role-based validation appears to be handled in dependencies (e.g., serialize_request), which does not count towards the function's own implementation of the spec constraints.",success,
18106,modssl_dispatch_ocsp_request,"A client, server, or proxy MAY close the transport connection at any time.",316,Partially Matches,"[{'A1': {'code': 'apr_socket_close(sd);', 'explanation': 'The function explicitly closes the transport connection by calling apr_socket_close(sd) after processing the response. This reflects the RFC statement that a client, server, or proxy MAY close the transport connection at any time.'}}]","The provided function performs a connection closure via apr_socket_close(sd), which partially addresses the RFC requirement that allows for closing the connection at any time. However, the spec context also emphasizes that connections should be closed gracefully with monitoring for closure signals to ensure that resources are reclaimed in an orderly manner. The function does not contain logic to handle a graceful shutdown or monitor the connection for incoming closure signals. As such, while it does include a mechanism to close the connection, it does not fully implement the broader graceful closure behavior suggested by the spec.",success,
18124,parse_time_str,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': ""if (errno || *end != '\\0') {\n    return APR_EINVAL;\n}"", 'explanation': 'This code checks that the entire time_str is consumed by apr_strtoi64 and that no conversion error occurred, which is a defensive programming measure ensuring minimal expectations about input conformance. However, it does not address other defensive aspects like buffer size validation.'}}]","The RFC specifies that protocol elements should be parsed defensively, assuming only marginal conformance to an expected grammar and reasonable size. The function attempts defensive parsing for a time string by verifying that the entire string can be converted to an integer, thereby rejecting malformed inputs (C1). Nonetheless, it does not implement additional checks for input length or buffer limitations, which limits its overall coverage of the RFC's recommendations. Thus, the code function partially matches the spec.",success,
18318,modssl_smart_shutdown,Servers MUST attempt to initiate an exchange of closure alerts with the client before closing the connection.,325,Fully Matches,"[{'A1': {'code': 'for (i = 0; i < 4 /* max 2x pending + 2x data = 4 */; i++) {\n    rc = SSL_shutdown(ssl);\n    if (rc >= 0 && flush && (SSL_get_shutdown(ssl) & SSL_SENT_SHUTDOWN)) {\n        if (BIO_flush(SSL_get_wbio(ssl)) <= 0) {\n            rc = -1;\n            break;\n        }\n        flush = 0;\n    }\n    if (rc != 0)\n        break;\n}', 'explanation': 'The function implements the RFC requirement that the server must attempt to initiate an exchange of closure alerts by invoking SSL_shutdown repeatedly. This initiates sending the close_notify alert, and the subsequent flush ensures the alert is transmitted over the network.'}}]","The provided function modssl_smart_shutdown repeatedly calls SSL_shutdown and flushes the output to ensure that the closure alert (close_notify) is sent to the client before closing the connection. This directly addresses the RFC requirement to initiate an exchange of closure alerts, fulfilling the specified action within the function's own logic.",success,
18336,sct_parse,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (len < 1 + LOG_ID_SIZE + 8) {\n    /* no room for header */\n    ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,\n                 APLOGNO(02768) ""SCT size %"" APR_SIZE_T_FMT "" is too small"",\n                 len);\n    return APR_EINVAL;\n}\n\n... (similar length checks for extension and signature fields)', 'explanation': ""The function validates that the input buffer is large enough to contain the required header fields, extensions, and signature information before attempting to parse them. These defensive length checks ensure that only minimally well‐formed SCT data is processed, which aligns with the spec's requirement to treat incoming protocol elements with minimal assumptions regarding their conformance and size.""}}, {'A1': {'code': 'ap_log_error(APLOG_MARK, APLOG_ERR, 0, s,\n             APLOGNO(02769) ""SCT size %"" APR_SIZE_T_FMT "" has no space for extension len"", orig_len);\n\n... (other ap_log_error invocations on insufficient data)', 'explanation': 'The function logs errors and returns specific error codes (APR_EINVAL) when the input does not meet length requirements. This error handling is a direct action supporting defensive parsing by notifying of protocol element issues in line with the specification.'}}]","The function implements defensive parsing by explicitly checking that the provided buffer has sufficient length before accessing each expected field. It logs errors and aborts processing when the provided data does not meet the minimal length requirements. This approach directly corresponds with the RFC specification which advises that a recipient should parse a received protocol element defensively, expecting only marginal conformance to the standard ABNF grammar and a reasonable buffer size.",success,
18375,ssl_var_lookup,"Note that the coding named ""identity"" is reserved for its special role in Accept-Encoding and thus SHOULD NOT be included.",38,Does Not Match,[],"The provided function 'ssl_var_lookup' does not implement any logic related to the Content-Encoding specifications described in the RFC context. Specifically, it does not address the requirement that if one or more encodings have been applied to a representation, the Content-Encoding header must list the content codings in the applied order, nor does it implement any checks to avoid including the special coding 'identity'. The function primarily focuses on retrieving various HTTP and environment variables from request and connection records, and there is no visible code that handles the specified conditions (e.g., C1) or actions (e.g., A1) related to content encoding as described in the RFC specification.",success,
18376,ssl_io_filter_Upgrade,A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection.,25,Fully Matches,"[{'C1': {'code': 'upgrade = apr_table_get(r->headers_in, ""Upgrade"");\nif (upgrade == NULL || !ap_find_token(r->pool, upgrade, ""TLS/1.0"")) {\n    return ap_pass_brigade(f->next, bb);\n}', 'explanation': ""This segment checks whether the request has an 'Upgrade' header and whether it contains the token 'TLS/1.0'. By doing so, it implements the RFC requirement that a server may ignore the Upgrade header if the protocol is not applicable, thus continuing with the existing connection.""}}, {'A1': {'code': 'ap_fputs(f->next, upgradebb, SWITCH_STATUS_LINE CRLF\n         UPGRADE_HEADER CRLF CONNECTION_HEADER CRLF CRLF);', 'explanation': 'This code sends the interim 101 response indicating a protocol switch. Sending this response complies with the spec’s intended mechanism for transitioning protocols when an Upgrade header is appropriately received.'}}]","The function checks for the presence and validity of the 'Upgrade' header. If the header is missing or does not contain the required token, it simply passes the request along, effectively ignoring the upgrade request as allowed by the RFC. Conversely, if the header is valid, it sends an interim 101 response to initiate the protocol upgrade. This logic within the function fully implements the specified RFC requirement.",success,
18376,ssl_io_filter_Upgrade,A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field.,27,Fully Matches,"[{'C1': {'code': 'upgrade = apr_table_get(r->headers_in, ""Upgrade"");\nif (upgrade == NULL || !ap_find_token(r->pool, upgrade, ""TLS/1.0"")) {\n    return ap_pass_brigade(f->next, bb);\n}', 'explanation': ""This segment checks the client's 'Upgrade' header for the presence of 'TLS/1.0'. If the header is missing or does not include 'TLS/1.0', it bypasses the upgrade behavior, thereby ensuring the server does not switch protocols not indicated by the client.""}}, {'A1': {'code': 'ap_fputs(f->next, upgradebb, SWITCH_STATUS_LINE CRLF UPGRADE_HEADER CRLF CONNECTION_HEADER CRLF CRLF);', 'explanation': 'This code sends the interim 101 Switching Protocols response along with the required Upgrade header, fulfilling the action requirement for upgrading protocols as indicated by the client.'}}]","The function first verifies that the client has requested an upgrade to TLS/1.0 by checking the 'Upgrade' header. If this condition (C1) is met, it proceeds to send a 101 Switching Protocols response with the corresponding Upgrade header (A1). This implementation directly enforces the RFC requirement that the server must not switch to any protocol not indicated by the client, thus fully matching the specified constraints.",success,
18390,regfnGetServerVariable,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function builds strings by concatenating environment and header variables with colon and CRLF delimiters, but it does not include any logic to validate those strings against the precise ABNF grammar defined by HTTP. In other words, while it formats output in a way that superficially resembles HTTP header formatting, it does not check or enforce conformance to the RFC’s grammar requirements. Thus, none of the labeled conditions (C1, etc.) or actions (A1, etc.) are fully implemented within this function.",success,
18390,regfnGetServerVariable,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC requires that within a message, a sender must not produce protocol elements or syntax alternatives that are exclusive to other roles. In the provided function, while there is logic to retrieve and format various HTTP header values (e.g., for ALL_HTTP and ALL_RAW), there is no logic that checks the sender’s role or enforces restrictions on generating protocol elements that are reserved for other roles. The function simply formats the headers extracted from internal tables without any role validation or restrictions. Thus, no part of this function visibly implements any constraint like C1 or action like A1 from the specification.",success,
18390,regfnGetServerVariable,A sender MUST NOT generate a bare CR (a CR character not immediately followed by LF) within any protocol elements other than the content,172,Partially Matches,"[{'C1': {'code': ""In both loops for ALL_HTTP and ALL_RAW:\n\n    *(buf_data++) = '\\r';\n    *(buf_data++) = '\\n';\n\nThese segments show that the function, when outputting header lines, always writes a CR immediately followed by an LF."", 'explanation': ""The RFC indicates that a sender must not generate a bare CR. In the code, whenever a header line is constructed, the function appends '\\r' immediately followed by '\\n', thus avoiding the generation of a bare CR in its own output. However, the function does not inspect or sanitize the header values that are copied via strcpy, so if those values already contain a bare CR, they would pass through unmodified. This means the function only partially implements the specified constraint since it ensures its own inserted CR characters are properly paired with LF, but does not guarantee that no bare CR exists in the overall output.""}}]","The function explicitly formats its own output by appending CR followed by LF when writing header data (as seen in the loops handling ALL_HTTP and ALL_RAW), which addresses the requirement not to generate a bare CR. However, because it directly copies header values (using strcpy) without checking for or replacing any bare CR characters that might be present in those values, the overall implementation is only partial. The function’s own logic is compliant, but it does not cover cases where an input header may contain a bare CR, which means the RFC’s condition is not fully enforced within this function alone.",success,
18392,send_response_header,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function manipulates HTTP response header strings and status codes, but there is no visible logic that checks or restricts the generation of protocol elements based on the sender's role. The spec constraint mandates that the sender MUST NOT generate protocol elements (or syntax alternatives) that are reserved for other roles. However, none of the code segments in this function verify the sender’s role or enforce the prohibition against generating disallowed protocol elements. Instead, the function focuses on parsing and constructing headers, setting status codes, and handling termination sequences. As a result, no labeled condition (e.g., C1) or action (e.g., A1) from the spec constraints is implemented solely within this function.",success,
18392,send_response_header,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (!head || headlen == 0 || !*head) {\n    head = stat;\n    stat = NULL;\n    headlen = statlen;\n    statlen = 0;\n    head_present = 0; /* Don\'t eat the header */\n}\n\nif (!stat || statlen == 0 || !*stat) {\n    if (head && headlen && *head && ((stat = memchr(head, \'\\r\', headlen))\n                                  || (stat = memchr(head, \'\\n\', headlen))\n                                  || (stat = memchr(head, \'\\0\', headlen))\n                                  || (stat = head + headlen))) {\n        statlen = stat - head;\n        if (memchr(head, \':\', statlen)) {\n            stat = ""Status: 200 OK"";\n            statlen = strlen(stat);\n        }\n        else {\n            const char *flip = head;\n            head = stat;\n            stat = flip;\n            headlen -= statlen;\n            ate += statlen;\n            if (*head == \'\\r\' && headlen)\n                ++head, --headlen, ++ate;\n            if (*head == \'\\n\' && headlen)\n                ++head, --headlen, ++ate;\n        }\n    }\n}', 'explanation': 'This segment demonstrates a defensive approach to parsing the protocol element. It checks that the header exists, has a non-zero length, and contains expected characters before proceeding. Such checks align with the RFC requirement of not having strong expectations regarding the input conforming entirely to the defined grammar.'}}, {'A1': {'code': 'if (head[headlen - 1] && head[headlen]) {\n    /* Whoops... not NULL terminated */\n    head = apr_pstrndup(cid->r->pool, head, headlen);\n}\n\n/* ... later, ensuring proper header termination parsing via the scan function: */\nres = ap_scan_script_header_err_strs_ex(cid->r, NULL,\n                APLOG_MODULE_INDEX, &termch, &termarg, stat, head, NULL);', 'explanation': ""This code shows robust handling of header data that may not be properly NULL terminated and ensures that when passed to further parsing functions, the header is safely duplicated and terminated. This defensive strategy embodies the RFC's guidance of marginal assumptions about the data's correctness.""}}]","The function send_response_header implements a defensive parsing strategy for HTTP response headers by validating input pointers, lengths, content, and ensuring proper termination. It checks for cases where the header may be missing or malformatted and uses safe memory routines (e.g., memchr, apr_pstrndup) to mitigate potential issues. These measures closely align with the RFC specification, which advises that recipients should parse protocol elements defensively while making only marginal assumptions about conformance to the ABNF grammar.",success,
18392,send_response_header,"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct.",220,Fully Matches,"[{'C1': {'code': 'if (!head || headlen == 0 || !*head) {\n    head = stat;\n    stat = NULL;\n    headlen = statlen;\n    statlen = 0;\n    head_present = 0; /* Don\'t eat the header */\n}\n\nif (!stat || statlen == 0 || !*stat) {\n    if (head && headlen && *head && ((stat = memchr(head, \'\\r\', headlen))\n                                  || (stat = memchr(head, \'\\n\', headlen))\n                                  || (stat = memchr(head, \'\\0\', headlen))\n                                  || (stat = head + headlen))) {\n        statlen = stat - head;\n        if (memchr(head, \':\', statlen)) {\n            stat = ""Status: 200 OK"";\n            statlen = strlen(stat);\n        }\n        else {\n            const char *flip = head;\n            head = stat;\n            stat = flip;\n            headlen -= statlen;\n            ate += statlen;\n            if (*head == \'\\r\' && headlen)\n                ++head, --headlen, ++ate;\n            if (*head == \'\\n\' && headlen)\n                ++head, --headlen, ++ate;\n        }\n    }\n}', 'explanation': ""This segment explicitly attempts to recover a usable protocol element (i.e. the status line) when the incoming header field is missing or malformed. It chooses a default value ('Status: 200 OK') if a colon is detected in the header, consistent with the RFC instruction that a recipient MAY attempt recovery from an invalid construct.""}}, {'A1': {'code': 'if (cid->r->status == HTTP_INTERNAL_SERVER_ERROR) {\n    return -1;\n}\n\n...\n\nif (!termch)\n    return(ate + headlen);\n\nif (termch && (termarg == (stat ? 1 : 0))\n           && head_present && head + headlen > termch) {\n    return ate + termch - head;\n}\nreturn ate;', 'explanation': 'This part shows how the function safely finalizes header processing and determines how much of the header data was consumed. It handles errors and incomplete header termination gracefully, ensuring that even if the header is not perfectly formed, a usable response is still produced following error recovery strategies.'}}]","The function 'send_response_header' includes multiple recovery mechanisms that align with the HTTP specification's allowance for error recovery when a received protocol element is invalid. It checks for null or empty header strings, attempts to parse or default missing elements, and finally sets sensible defaults (e.g., HTTP_OK) if no valid status is extracted. This comprehensive in-function error handling demonstrates that the code correctly fulfills the intent of the RFC's error recovery requirements.",success,
18393,regfnWriteClient,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The HTTP RFC requirement mandates that a sender must not generate protocol elements that do not match the ABNF-defined grammar. While the function does call send_response_header to process header data, it does not contain any explicit logic within itself to validate or enforce ABNF grammar compliance. All parsing or validation appears to be offloaded to an external function and no in-function checks ensure that only valid protocol elements are generated. Consequently, no labeled conditions or actions (e.g., C1, A1) are visibly implemented within this function.",success,
18393,regfnWriteClient,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided code function is responsible for writing client data by processing headers (via a dependency function send_response_header) and sending the body through an APR bucket brigade. However, it does not contain any explicit logic to enforce the HTTP RFC requirement that states: 'Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles.' There is no logic within this function that verifies or restricts the generation of protocol elements based on the sender's role or that checks the grammar defined by ABNF rules. The header parsing and similar responsibilities are delegated to helper functions, and thus the function does not visibly address this particular spec constraint by itself.",success,
18394,regfnServerSupportFunction,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function handles various HSE request codes and dispatches actions based on those codes but does not implement any explicit checks or restrictions regarding role-based generation of protocol elements. The RFC specification requires that a sender must not generate protocol elements that are only allowed for other roles. There is no visible logic in the function that validates the sender’s role or ensures that certain protocol elements (e.g., specific headers or syntax alternatives) are only produced when permitted by its role. All actions (e.g., sending URL redirects, response headers, file transmissions) occur based solely on the HSE code and without verification against role responsibilities. Therefore, the function does not address the relevant RFC constraint on role-based protocol element generation.",success,
18394,regfnServerSupportFunction,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The RFC requirement is that a sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. In the function_body, although there is extensive handling of various HTTP-related request codes (HSE_REQ_SEND_URL_REDIRECT_RESP, HSE_REQ_SEND_RESPONSE_HEADER, etc.), there is no visible logic that validates or enforces the proper formatting of protocol elements against the ABNF grammar. The function sets header values, modifies response status lines, and redirects or transmits files, but it does not perform any checks or adjustments to ensure that the generated protocol elements strictly adhere to the ABNF defined in HTTP. Therefore, the function does not address this spec constraint within its own code.",success,
18394,regfnServerSupportFunction,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,159,Fully Matches,"[{'A1': {'code': 'apr_table_set (r->headers_out, ""Location"", buf_data);', 'explanation': ""In the HSE_REQ_SEND_URL_REDIRECT_RESP case, the function sets the 'Location' header field in the response using the provided buf_data. This directly implements the RFC specification that requires the server to generate a Location header with a URI reference for the different URI.""}}]","The function directly addresses the RFC specification by implementing logic to generate a Location header in its HTTP redirect response. The code snippet in the HSE_REQ_SEND_URL_REDIRECT_RESP case meets the requirement as stated in the RFC, and thus the function fully implements the specified behavior within its own logic.",success,
18394,regfnServerSupportFunction,The server SHOULD generate a Location header field in the response containing a URI reference for the different URI.,156,Fully Matches,"[{'A1': {'code': 'case HSE_REQ_SEND_URL_REDIRECT_RESP:\n    /* Set the status... */\n    apr_table_set(r->headers_out, ""Location"", buf_data);\n    cid->r->status = cid->ecb->dwHttpStatusCode = HTTP_MOVED_TEMPORARILY;\n    cid->r->status_line = ap_get_status_line(cid->r->status);', 'explanation': ""This code segment directly sets the 'Location' header with the URI provided in 'buf_data' when handling a redirect response (HSE_REQ_SEND_URL_REDIRECT_RESP). This behavior directly implements the RFC requirement for generating a Location header with a URI reference.""}}]","The function clearly implements the specified HTTP RFC requirement in the HSE_REQ_SEND_URL_REDIRECT_RESP case. It sets the 'Location' header in the outgoing response using the provided URI reference and adjusts the status accordingly, thereby fully covering the stated constraint within the function itself.",success,
18404,privileges_req,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'apr_table_unset(r->headers_in, ""Content-Length"");', 'explanation': 'This code removes the Content-Length header from the request headers, which is an attempt to prevent forwarding a message with a potentially incorrect Content-Length.'}}]","The RFC requires that a sender must not forward a message when the Content-Length header value is known to be incorrect. In this function, during the parent process branch after forking, the header is unconditionally unset (along with Content-Type). This indicates an effort to avoid forwarding a message with a problematic Content-Length header. However, the function does not actually validate whether the header value is incorrect or check the header against the ABNF, which means it does not fully implement all aspects of the RFC requirement. Therefore, while the function does address the header forwarding concern by removing the header, it only partially meets the detailed specification.",success,
18448,store_array,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,36,Fully Matches,"[{'C1': {'code': 'for (i = 0; i < arr->nelts; i++) {\n    ...\n    len = apr_snprintf(buffer ? (char *) buffer + *slider : NULL,\n                         buffer ? buffer_len - *slider : 0, ""%s"" CRLF, elts[i]);\n    *slider += len;\n}\nif (buffer) {\n    memcpy(buffer + *slider, CRLF, sizeof(CRLF) - 1);\n}\n*slider += sizeof(CRLF) - 1;', 'explanation': 'The RFC specifies that only CRLF should be used to represent line breaks between the body parts. This function appends CRLF to each element using the apr_snprintf call and then adds an additional CRLF at the end. Thus, it directly implements the requirement by ensuring that only CRLF is generated as line breaks.'}}]","The function 'store_array' explicitly formats each part of the message body by appending a CRLF sequence after each element and at the end of the array. This behavior directly addresses the RFC specification requirement regarding the use of CRLF for line breaks. All logic related to generating CRLF line breaks is contained within this function, fulfilling the spec condition as required.",success,
18448,store_array,"A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the ""message/http"" media type.",301,Does Not Match,[],"The RFC specification requires that the sender must not generate messages including line folding (i.e., the obs-fold pattern) unless for a specific media type. The provided function, however, lacks any checks or handling to prevent or address line folding. It simply outputs each string from the array with a CRLF appended, without validating if any of these strings may contain forbidden line folding. Therefore, no part of this function’s logic implements any of the spec constraints (e.g., C1 or related actions), and the function does not address the requirement from the RFC.",success,
18449,read_table,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Partially Matches,"[{'C1': {'code': 'while (apr_isspace(buffer[colon]) && (colon < *slider)) {\n    colon++;\n}', 'explanation': ""This loop scans over any whitespace that appears after the colon, effectively removing the so-called 'bad whitespace' (BWS) from the header value before it is stored. This behavior aligns with the RFC requirement that a recipient MUST parse and remove such BWS before interpreting the header. However, note that the code only handles BWS removal in this narrow context.""}}]","The provided function 'read_table' shows explicit logic (using apr_isspace in a loop) to remove extraneous whitespace after the colon separator in a header line, which corresponds to the RFC requirement regarding the removal of BWS. This directly addresses the part of the specification that mandates removing bad whitespace before interpreting the protocol element. Nonetheless, the function does not comprehensively implement all aspects of the RFC’s guidance on optional whitespace (for example, it does not deal with potential BWS in other areas of the header), hence it only partially matches the full set of spec constraints.",success,
18449,read_table,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,"[{'C1': {'code': 'while (apr_isspace(buffer[colon]) && (colon < *slider)) {\n    colon++;\n}', 'explanation': 'This loop skips over whitespace characters after the colon delimiter, effectively removing what can be considered bad whitespace before the header value is interpreted.'}}]","The code function attempts to address the RFC requirement by removing extra whitespace after the colon using a while loop that advances past space characters, which partially implements the requirement that a recipient must remove bad whitespace. However, it does not implement the entire normalization process specified (such as replacing sequences of OWS/RWS with a single SP), so it only partially matches the spec constraints.",success,
18449,read_table,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Partially Matches,[],"The RFC requires that any whitespace allowed in a message be excluded from the field value prior to evaluation – meaning that leading and trailing whitespace should be removed. In this function, when a header line is encountered, the code locates the colon and then uses a while‐loop (while (apr_isspace(buffer[colon]) && (colon < *slider))) to advance past any whitespace immediately after the colon. This shows an attempt to exclude leading whitespace from the field value. However, there is no explicit mechanism to trim any trailing whitespace that might exist before the '\r'. Since the implementation only removes the leading whitespace and not trailing whitespace, it only partially addresses the spec constraint. Note that only logic within this function is considered, and while it does handle a portion of the whitespace trimming (the leading part), it does not fully meet the requirement as stated in the RFC specification.",success,
18450,store_table,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, store_table, focuses on formatting and appending header key-value pairs into a buffer and appending a terminating CRLF. It does not include any logic to enforce that protocol elements are generated only by allowed sender roles, nor does it verify that the generated protocol elements conform to ABNF rules for allowed sender syntax. Since no part of the function checks that the generated header lines are not those restricted to other roles (as required by the RFC), it does not visibly address any labeled conditions (e.g., C1) or actions (e.g., A1) from the specification.",success,
18456,open_entity,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Fully Matches,"[{'C1': {'code': 'if (buffer_len >= sobj->buffer_len) {\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rc, r, APLOGNO(02353)\n            ""Key found in cache but too big, ignoring: %s"", key);\n    apr_pool_destroy(sobj->pool);\n    sobj->pool = NULL;\n    return DECLINED;\n}\n\n... \nif (buffer_len >= sobj->buffer_len) {\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, rc, r, APLOGNO(02358)\n            ""Key found in cache but too big, ignoring: %s"", key);\n    goto fail;\n}', 'explanation': 'This code checks that the retrieved cache data does not exceed the allocated buffer (sobj->buffer_len). By validating the length before processing further, the function defensively handles oversized protocol elements per the RFC recommendation.'}}, {'A1': {'code': 'if (APR_SUCCESS != read_table(h, r, h->resp_hdrs, sobj->buffer, buffer_len, &slider)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(02364)\n            ""Cache entry for key \'%s\' response headers unreadable, removing"", nkey);\n    goto fail;\n}\nif (APR_SUCCESS != read_table(h, r, h->req_hdrs, sobj->buffer, buffer_len, &slider)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r, APLOGNO(02365)\n            ""Cache entry for key \'%s\' request headers unreadable, removing"", nkey);\n    goto fail;\n}', 'explanation': 'This segment attempts to parse the header lines from the protocol element. By checking the return values from the parsing routines and handling errors defensively through cleanup and logging, it aligns with the requirement to parse with only marginal assumptions about conformity.'}}]","The function 'open_entity' demonstrates a defensive parsing strategy by verifying that received cache entries do not exceed preset buffer limits and by cautiously handling parsing errors for header values. These actions directly implement the RFC's guideline of defensively parsing protocol elements with minimal assumptions about their structure and size, thereby fully matching the specified constraint.",success,
18456,open_entity,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided function 'open_entity' is involved in retrieving, parsing, and handling cached data (including headers and bodies) rather than generating protocol elements or validating that such elements conform to the ABNF grammar. It does not contain any explicit logic that ensures protocol elements adhere to the grammar defined in the RFC. Although it processes header tables via calls to functions like read_table, this falls under data retrieval and parsing rather than generation or validation of protocol elements per the ABNF rules. Therefore, none of the labeled conditions (e.g., C1) or actions (e.g., A1) that involve preventing the generation of non-grammar conformant elements are implemented within this function.",success,
18456,open_entity,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, open_entity, focuses on retrieving cache entries, managing locks, and processing cached data (including header tables and bodies). There is no visible logic within this function that checks or enforces the rule that a sender must not generate protocol elements or syntax alternatives allowed only for other roles. In other words, the function does not contain code that directly validates that generated protocol elements adhere to the appropriate role's grammar as specified by the HTTP RFC. Therefore, within the boundaries of this function, the spec constraint (which can be labeled C1 or A1) is not addressed.",success,
18462,store_body,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided function implements logic to store and buffer the response body into a cache; however, it does not contain any code that checks or prevents cache usage while acting as a tunnel. The RFC specification explicitly notes that a cache cannot be used when acting as a tunnel, yet there is no corresponding condition or action (e.g., checking the connection type or tunnel flag) implemented in this function. Therefore, none of the spec constraints (such as a condition like C1 or action like A1 if they were meant to restrict tunnel mode caching) are visibly addressed in the function_body.",success,
18463,commit_entity,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The RFC requires that a cache not be used when acting as a tunnel. However, within function_body there is no logic to detect or prevent caching when acting as a tunnel. The function simply commits an entity to the cache by storing it via the provider, without any checks related to tunnel behavior. Since no labeled conditions (e.g., C1 for checking whether the cache is used during a tunnel connection) or corresponding actions (e.g., A1 to disable caching when acting as a tunnel) are implemented in this function, it does not visibly address the specified RFC constraint.",success,
18499,cache_quick_handler,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'if (!conf->quick) {\n    return DECLINED;\n}\n...\nrv = cache_select(cache, r);', 'explanation': 'This segment shows that the function enables caching if a quick caching mode is active and proceeds to try to select a cached copy for GET requests. This aligns with the RFC’s permission that a client or server may employ a cache.'}}, {'A1': {'code': 'switch (r->method_number) {\ncase M_PUT:\ncase M_POST:\ncase M_DELETE:\n{\n    ...\n    ap_add_output_filter_handle(\n            cache_invalidate_filter_handle, cache, r,\n            r->connection);\n    return DECLINED;\n}', 'explanation': 'For methods that modify the resource, the function sets up a filter to invalidate any cached copy. This is an action to manage cache storage and maintain consistency.'}}]","The function implements key parts of the caching mechanism: it checks whether caching is enabled, attempts to serve GET requests from the cache, and installs filters to invalidate cache entries when modifications occur. These aspects reflect the permission for client or server to use a cache. However, the RFC also specifies that a cache must not be used while acting as a tunnel; there is no visible logic in the function to detect or disable caching when functioning as a tunnel. As a result, while the function addresses significant caching behaviors mandated by the RFC, it omits handling of the tunnel condition, leading to a partial match.",success,
18502,cache_handler,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'if (!(providers = cache_get_providers(r, conf))) {\n    return DECLINED;\n}', 'explanation': 'This segment checks if a cache provider is available and only proceeds with caching logic if so, thus implementing the part of the spec that allows a client or server to employ a cache.'}}]","The function contains logic for caching by selecting cache providers, applying output filters, and handling different HTTP methods (GET, PUT, POST, DELETE) to manage cache actions. This aligns with the spec constraint that a cache may be employed. However, there is no explicit handling to ensure that a cache is not used while acting as a tunnel, as required by the RFC. Therefore, while the function implements some of the caching logic (fulfilling condition C1), it does not address the restriction regarding tunnels, resulting in a partial match with the RFC specification.",success,
18503,cache_out_filter,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided function_body handles output filtering by retrieving a cached response and restoring its Content-Type and status code. However, the HTTP RFC specification states that a cache may be employed by any client or server and that a cache must not be used while acting as a tunnel. There is no visible logic within this function that checks or enforces the rule regarding tunnel usage (i.e., that caching should be bypassed when the client or server is functioning as a tunnel). Thus, none of the spec’s labeled conditions or actions (such as C1, A1, etc.) are directly implemented within the code in isolation, leading to the conclusion that the function does not address the specified RFC requirement.",success,
18503,cache_out_filter,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'const char *ct = apr_table_get(cache->handle->resp_hdrs, ""Content-Type"");\nif (ct) {\n    ap_set_content_type(r, ct);\n}', 'explanation': 'This segment checks if a Content-Type header is available in the cached response headers and sets it on the request. This directly implements the RFC requirement that a sender generating a message with content should include a Content-Type header when the media type is known.'}}]","The function 'cache_out_filter' includes logic to retrieve the Content-Type from the cached response and set it on the current request, which aligns with the RFC guideline. The RFC states that if the media type of the content is known, the sender SHOULD generate a Content-Type header; this is exactly what is achieved in the code. No additional logic for handling unknown media types is required, as the absence of the header is acceptable per the spec. Dependencies are not considered since the logic is implemented within this function, fulfilling the requirement fully.",success,
18504,cache_save_store,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'rv = cache->provider->store_body(cache->handle, f->r, in, cache->out);\n...\nrv = cache->provider->commit_entity(cache->handle, f->r);', 'explanation': 'This code segment implements the mechanism to store response data in the cache via the cache provider. It shows that the function handles caching (i.e. saving body data and committing the entity), thereby addressing the basic permission in the RFC that clients or servers MAY employ a cache.'}}]","The function implements caching behavior by forwarding bucket brigades to the cache provider and managing cache commit and lock removal, which addresses the part of the spec that allows using a cache. However, the RFC also states that 'a cache cannot be used while acting as a tunnel,' and there is no visible logic in this function to detect or disable cache usage in such a scenario. Since only part of the spec is directly addressed within the function_body, the overall match is partial.",success,
18506,cache_save_filter,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'else if (!dconf->store_private && control.private) {\n    reason = ""Cache-Control: private present"";\n}', 'explanation': ""This segment shows that the function is checking cache eligibility based on HTTP headers (in this case, rejecting caching when a response contains 'Cache-Control: private'). This relates to the idea that a cache should not be engaged in contexts that restrict caching (analogous to not using a cache when acting as a tunnel). However, a key part of the spec – that a cache cannot be used while acting as a tunnel – is not explicitly detected or enforced anywhere in the function.""}}]","The function implements detailed caching logic by checking various HTTP headers and conditions (such as handling Cache-Control directives, and rejecting cache storage if certain conditions are met). This shows an attempt to implement aspects of the RFC that allow a cache to be optionally employed. However, there is no explicit logic checking for whether the client or server is acting as a tunnel, which is a critical part of the spec. Therefore, the function only partially matches the spec because it addresses many caching eligibility concerns but does not directly enforce the 'no cache while tunneling' requirement.",success,
18506,cache_save_filter,"Since the goal of a 304 response is to minimize information transfer when the recipient already has one or more cached representations, a sender SHOULD NOT generate representation metadata other than the above listed fields unless said metadata exists for the purpose of guiding cache updates (e.g., Last-Modified might be useful if the response does not have an ETag field).",158,Fully Matches,"[{'A1': {'code': 'if (r->status == HTTP_NOT_MODIFIED) {\n    for (eh = MOD_CACHE_ENTITY_HEADERS; *eh; ++eh) {\n        apr_table_unset(r->headers_out, *eh);\n    }\n}', 'explanation': 'This code segment checks if the response status is 304 Not Modified and, if so, explicitly unsets (removes) all entity headers that are not part of the essential metadata. This aligns with the RFC specification stating that a 304 response should not include extra representation metadata unless it serves to guide cache updates (e.g., retaining Last-Modified if no ETag exists).'}}]","Within the function, the logic for handling 304 responses is clearly present. When a 304 is detected, the code iterates over a set of entity header names (MOD_CACHE_ENTITY_HEADERS) and removes them from the outgoing headers. This prevents unnecessary or extraneous metadata from being sent and complies with the RFC requirement. As the function itself contains this handling without relying on external dependencies, it fully meets the specified constraint.",success,
18506,cache_save_filter,"If the last modification time is derived from implementation-specific metadata that evaluates to some time in the future, according to the origin server's clock, then the origin server MUST replace that value with the message origination date.",265,Fully Matches,"[{'C1': {'code': 'if (lastmod != APR_DATE_BAD && lastmod > date) {\n    /* if it\'s in the future, then replace by date */\n    lastmod = date;\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0,\n            r, APLOGNO(00771) ""cache: Last modified is in the future, ""\n            ""replacing with now"");\n}', 'explanation': ""This code checks whether the Last-Modified date is valid and in the future (i.e. greater than the message origination date 'date'). If true, it replaces the Last-Modified value with the current date, precisely as required by the RFC.""}}]","The RFC specifies that if the last modification time is in the future according to the origin server's clock, it must be replaced by the message origination date. The function_body implements this logic directly by comparing 'lastmod' with 'date' and assigning 'date' to 'lastmod' if 'lastmod' is later. Therefore, this function fully implements the specific RFC requirement within its own code.",success,
18506,cache_save_filter,"An origin server with a clock (as defined in Section 5.6.7) MUST NOT generate a Last-Modified date that is later than the server's time of message origination (Date, Section 6.6.1).",54,Fully Matches,"[{'C1': {'code': 'if (lastmod != APR_DATE_BAD && lastmod > date) {\n    /* if it\'s in the future, then replace by date */\n    lastmod = date;\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00771) ""cache: Last modified is in the future, replacing with now"");\n}', 'explanation': 'This code snippet checks whether the Last-Modified date (lastmod) is later than the message origination date (date). If so, it resets lastmod to date, ensuring that the Last-Modified date is not in the future as required by the HTTP RFC.'}}]","The function includes explicit logic to compare the parsed Last-Modified date with the message origination date. When the Last-Modified is found to be in the future (i.e., greater than the Date header), it is replaced with the current server time. This implementation directly addresses and fulfills the RFC requirement that an origin server must not generate a Last-Modified date later than its message origination time.",success,
18506,cache_save_filter,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'C1': {'code': 'cl = apr_table_get(r->err_headers_out, ""Content-Length"");\nif (cl == NULL) {\n    cl = apr_table_get(r->headers_out, ""Content-Length"");\n}\nif (cl && !ap_parse_strict_length(&size, cl)) {\n    reason = ""invalid content length"";\n}', 'explanation': 'This segment checks for a Content-Length header and validates its value using ap_parse_strict_length. If the value is deemed invalid, it sets the rejection reason, which indicates awareness of the spec requirement concerning incorrect Content-Length header values.'}}]","The function addresses the RFC’s requirement by inspecting the Content-Length header and marking the response as having an invalid length (C1). However, rather than halting or dropping the message when an incorrect Content-Length is detected, the function logs the issue, removes the caching filter, and then forwards the message (via ap_pass_brigade). This means that although the check is performed, the response with an invalid Content-Length is still forwarded to the next filter, which only partially meets the RFC requirement that a sender MUST NOT forward such a message.",success,
18506,cache_save_filter,A recipient with a clock that receives a response with an invalid Date header field value MAY replace that value with the time that response was received.,19,Fully Matches,"[{'A1': {'code': 'dates = apr_table_get(r->err_headers_out, ""Date"");\nif (dates == NULL) {\n    dates = apr_table_get(r->headers_out, ""Date"");\n}\nif (dates != NULL) {\n    info->date = apr_date_parse_http(dates);\n}\nelse {\n    info->date = APR_DATE_BAD;\n}\n...\nnow = apr_time_now();\nif (info->date == APR_DATE_BAD) {  /* No, or bad date */\n    /* no date header (or bad header)! */\n    info->date = now;\n}', 'explanation': 'The function checks for the Date header by attempting to parse it. If parsing fails (resulting in APR_DATE_BAD), it replaces the invalid or missing Date with the current time (now), thereby implementing the RFC guidance that a recipient MAY replace an invalid Date header value with the time the response was received.'}}]","Within the function, the logic that reads and processes the Date header directly addresses the RFC specification. The code verifies whether the Date header is present and valid; if it is missing or invalid, it explicitly sets the response's date to the current time. This behavior fully implements the requirement described in the spec. Dependencies or external callers are not involved in this specific handling, so the function itself fully meets the constraint labeled A1.",success,
18506,cache_save_filter,A recipient with a clock that receives a response message without a Date header field MUST record the time it was received and append a corresponding Date header field to the message's header section if it is cached or forwarded downstream.,18,Partially Matches,"[{'C1': {'code': 'dates = apr_table_get(r->err_headers_out, ""Date"");\nif (dates == NULL) {\n    dates = apr_table_get(r->headers_out, ""Date"");\n}', 'explanation': 'The code checks for the Date header in both error and normal headers, thus detecting when the response lacks a Date field.'}}, {'A1': {'code': 'if (dates != NULL) {\n    info->date = apr_date_parse_http(dates);\n} else {\n    info->date = APR_DATE_BAD;\n}\n\nnow = apr_time_now();\nif (info->date == APR_DATE_BAD) {  /* No, or bad date */\n    info->date = now;\n}', 'explanation': ""When no valid Date header is present, the function records the current time (using apr_time_now()) in the cache metadata. This implements the requirement to record the reception time. However, while the recorded time is stored in 'info->date' (and later passed to store_headers), there is no explicit code here that appends a Date header to the message's header section.""}}]","The RFC requirement is that a recipient with a clock must, upon receiving a response without a Date header, record the reception time and append a corresponding Date header when caching or forwarding the response. The function inspects whether a Date header exists and—if not—records the current time in the cache metadata (info->date). This satisfies the part of the requirement that records the time, but the function does not directly append a Date header to the response headers, implying that this step is likely handled by dependency functions (e.g. store_headers). Thus, within its own code, the function only partially meets the entire RFC specification.",success,
18510,cache_status,"However, an origin server MUST NOT use such context information to alter the request semantics.",263,Does Not Match,[],"The function_body is concerned with setting caching status headers and environment variables based on the cache status. It does not process or check any context information such as the Content-Location header, nor does it include any logic to ensure that such context is not used to alter the request semantics. Therefore, none of the labeled constraints (e.g., C1 or A1) from the specification are addressed by this function.",success,
18511,cache_insert_error_filter,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The given function is focused solely on error handling in cache revalidation scenarios (specifically for 5xx responses) and the use of stale responses when the stale_on_error option is enabled. It does not address the RFC requirement that a cache must not be used while acting as a tunnel. No logic within this function checks or distinguishes if the request is operating as a tunnel, and thus the essential part of the spec (“a cache cannot be used while acting as a tunnel”) is not implemented.",success,
18524,add_cache_enable,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The function 'add_cache_enable' performs configuration validation (such as ensuring that the provider does not start with '/' and that a URL is provided correctly) but does not implement any logic to ensure that generated protocol elements conform to an ABNF grammar. In other words, there is no check within the function that verifies if the output matches the HTTP RFC grammar constraints. Therefore, it does not address the specific requirement that a sender must not generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.",success,
18536,set_cache_key_base_url,A recipient that processes such a URI reference MUST reject it as invalid.,224,Does Not Match,[],"The RFC specifies that a URI reference with an empty host identifier must be rejected. However, the function only checks if all of scheme, hostname, and port are missing. This means that if only the hostname is empty (while having a valid scheme or port), the function does not enforce the rejection required by the RFC. As a result, the function does not visibly address the RFC’s mandate to reject an 'http' URI with an empty host identifier.",success,
18539,register_hooks,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'ap_hook_quick_handler(cache_quick_handler, NULL, NULL, APR_HOOK_FIRST);\nap_hook_handler(cache_handler, NULL, NULL, APR_HOOK_REALLY_FIRST);\ncache_filter_handle = ap_register_output_filter(""CACHE"", cache_filter, NULL, AP_FTYPE_RESOURCE);', 'explanation': 'These code segments register caching hooks and filters, thereby enabling the use of a cache as permitted by the RFC. The function clearly sets up various components (quick handler, handler, output filters) to implement caching behavior.'}}]","The provided function registers a set of hooks and filters related to caching operations, which aligns with the RFC statement that any client or server may employ a cache. However, it does not include any logic regarding the special case when acting as a tunnel—that is, it does not enforce the exception that a cache cannot be used while acting as a tunnel. Since only part of the specification is implemented within this function, the overall match is partial.",success,
18543,uri_meets_conditions,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'if (!(filter->port_str && !filter->port_str[0])) {\n    const unsigned fport = filter->port_str ? filter->port : apr_uri_port_of_scheme(filter->scheme);\n    const unsigned uport = (url->port_str && url->port_str[0]) ? url->port : apr_uri_port_of_scheme(url->scheme);\n    if (fport != uport) {\n        return 0;\n    }\n}', 'explanation': 'This segment directly handles the RFC requirement: when a port is not explicitly provided, the function defaults to using the default port (via apr_uri_port_of_scheme) for the given scheme. This meets the specification that if a port is not provided, it should be interpreted as received on the default port.'}}]","The function implements the specified RFC condition by checking the port values of both the filter URI and the tested URI. In the absence of an explicit port, it calls apr_uri_port_of_scheme to derive the default port for the scheme, thus satisfying the requirement that missing ports be interpreted as default ports. Other parts of the function perform matching on the scheme, hostname, and path, but with respect to the RFC condition about port handling, the code fully meets the expected behavior.",success,
18544,cache_use_early_url,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided function only examines if the request is a proxy request (r->proxyreq == PROXYREQ_PROXY) and if the quick configuration flag is set. There is no visible logic within this function that checks if the cache is being used in a tunnel (or prevents its usage in such a scenario) as required by the spec. The spec mandates that a cache cannot be used while acting as a tunnel, but the function lacks any explicit handling of a tunnel condition. Therefore, the function does not visibly address the labeled constraint from the specification.",success,
18546,cache_get_providers,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,[],"The RFC specification states that any client or server MAY employ a cache but that a cache cannot be used while acting as a tunnel. The function 'cache_get_providers' does implement logic to decide when to enable caching (for example, by checking per-directory and global cache disable flags), which aligns with the part of the spec that permits using a cache. However, there is no visible logic within this function to check or prevent caching when the system is acting as a tunnel. Since the critical requirement of disallowing cache use in tunnel mode is not addressed, the function only partially addresses the RFC spec.",success,
18550,ap_cache_check_no_cache,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'if (cache->control_in.no_cache) {\n    if (!conf->ignorecachecontrol) {\n        return 0;\n    }\n    else {\n        ap_log_rerror(..., ""Incoming request is asking for an uncached version of %s..."", r->unparsed_uri);\n    }\n}', 'explanation': ""This segment checks if the client's request includes a no-cache directive and, unless overridden by configuration, prohibits returning cached content. This addresses part of the RFC requirement related to cache revalidation on no-cache requests.""}}]","The function inspects the request's Cache-Control and Pragma headers (via ap_cache_control) to see if a no-cache directive is present. When found, and unless the configuration instructs to ignore it, the function returns 0, thereby not using the cached data. This behavior aligns with RFC2616 section 14.9.4 regarding not using a cached copy when a no-cache directive is present. However, the provided RFC specification also states that a cache cannot be used while acting as a tunnel. There is no logic in this function to determine whether the request is being processed as a tunnel. Consequently, while the code function does address the aspect of handling no-cache directives, it does not address the 'acting as a tunnel' part of the spec, leading to a partial match.",success,
18552,cache_check_freshness,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided function implements detailed logic for evaluating whether a cached response is fresh based on Cache-Control, Age, Expires, and other related headers (such as handling max-age, s-maxage, max-stale, min-fresh, etc.). However, the RFC specification states that 'any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.' This function does not contain any logic to determine if the system is acting as a tunnel or to disable the cache when tunneling conditions are met. Since none of the code segments address this specific aspect of the RFC constraint, in isolation the function does not satisfy the full set of conditions outlined by the RFC specification.",success,
18558,cache_strqtok,Recipients that process the value of a quoted-string MUST handle a quoted-pair as if it were replaced by the octet following the backslash.,242,Fully Matches,"[{'C1': {'code': ""if (*str == '\\\\' && *(str + 1)) { ++str; }"", 'explanation': 'Within the IN_QUOTES state, the code checks for a backslash. When found, it increments the pointer to skip the backslash so that the following octet is used, which effectively replaces the quoted-pair with the escaped character as required by the RFC.'}}]","The function processes quoted strings and within that context handles backslashes by skipping them and copying only the next character. This behavior directly implements the RFC requirement that a quoted-pair should be replaced by the octet following the backslash. Therefore, the code fully matches the single provided constraint.",success,
18558,cache_strqtok,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': 'while (*str && TEST_CHAR(*str, T_HTTP_TOKEN_STOP)) {\n    if (!ap_strchr_c(CACHE_TOKEN_SEPS, *str)) {\n        return APR_EINVAL;\n    }\n    ++str;\n}', 'explanation': 'This loop skips over leading token separator characters (which include whitespace such as SP and HTAB) before beginning to extract the field value, thus excluding leading whitespace as required by the spec.'}}, {'A1': {'code': ""for (; *str; ++str) {\n    if (*str == ',') {\n        ++str;\n        break;\n    }\n    if (*str != '\\t' && *str != ' ') {\n        rv = APR_EINVAL;\n        break;\n    }\n}"", 'explanation': 'This segment iterates over any remaining characters after the token extraction and effectively ensures that only allowed trailing whitespace (SP and HTAB) is present. This aligns with the requirement to exclude trailing whitespace.'}}]","The function cache_strqtok visibly implements the RFC requirement regarding whitespace handling by first skipping any leading whitespace or separator characters before evaluating the token and later by verifying that any remaining characters (trailing characters) are only allowed whitespace. Both these segments directly address the condition that a field parsing implementation MUST exclude whitespace prior to field value evaluation, thereby fully satisfying the constraint.",success,
18560,cache_control_remove,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'cache_control_remove' processes the 'Cache-Control' header by removing certain header entries based on tokens such as 'no-cache' and 'private'. However, it does not implement any logic that verifies or restricts protocol element generation based on sender roles as required by the RFC specification. There is no handling within the function to ensure that a sender does not generate protocol elements or syntax alternatives that are reserved for other roles, nor is there any validation against ABNF grammar rules for such elements. All the logic in this function is focused solely on header manipulation, not on enforcing sender-specific protocol constraints. Therefore, the function does not visibly address any of the designated constraints (e.g., C1 or A1) as defined in the spec.",success,
18560,cache_control_remove,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided code function cache_control_remove only handles removal of headers when encountering 'no-cache' or 'private' directives. It does not implement any logic that verifies or generates protocol elements in compliance with the ABNF grammar as required by the RFC specification. There is no code addressing the requirement that a sender must not generate protocol elements that do not match the defined grammar (C1) or any related action such as validating generated elements (A1). Thus, within this function, no spec constraint is fully or partially met.",success,
18561,ap_cache_cacheable_headers,A sender MUST NOT send a connection option corresponding to a field that is intended for all recipients of the content.,252,Fully Matches,"[{'C1': {'code': 'apr_table_unset(headers_out, ""Connection"");\napr_table_unset(headers_out, ""Keep-Alive"");\napr_table_unset(headers_out, ""Proxy-Authenticate"");\napr_table_unset(headers_out, ""Proxy-Authorization"");\napr_table_unset(headers_out, ""TE"");\napr_table_unset(headers_out, ""Trailers"");\napr_table_unset(headers_out, ""Transfer-Encoding"");\napr_table_unset(headers_out, ""Upgrade"");', 'explanation': ""The function creates a copy of the header table from the input and explicitly removes headers that are connection‐specific (such as 'Connection', 'Upgrade', etc.). This directly implements the RFC requirement that a sender MUST NOT send a connection option corresponding to a field intended for all recipients of the content.""}}]","The code function ap_cache_cacheable_headers first makes a copy of the incoming headers and then removes all hop-by-hop or connection-specific headers (e.g., 'Connection', 'Keep-Alive', 'Upgrade', etc.). By doing so, it ensures that fields not meant to be forwarded as part of the cacheable response (i.e., connection options) are omitted. This fully meets the spec constraint as stated in the RFC and discussed in the context by removing the connection option corresponding to fields intended for all recipients.",success,
18561,ap_cache_cacheable_headers,A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection.,25,Fully Matches,"[{'A1': {'code': 'apr_table_unset(headers_out, ""Upgrade"");', 'explanation': 'The code explicitly removes the ""Upgrade"" header from the table of headers. This action aligns with the RFC specification that allows a server to ignore the Upgrade header if it chooses to continue using the current protocol.'}}]","The function makes a copy of the headers and then unsets several hop-by-hop headers, including ""Upgrade"". By doing so, it demonstrates that the server is opting to ignore the Upgrade header, which is precisely what the RFC permits. Thus, within the context of the function itself (without considering dependencies), the relevant RFC requirement is fully addressed.",success,
18564,cache_merge_headers_out,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'C1': {'code': 'if (r->content_type\n        && !apr_table_get(headers_out, ""Content-Type"")) {\n    const char *ctype = ap_make_content_type(r, r->content_type);\n    if (ctype) {\n        apr_table_setn(headers_out, ""Content-Type"", ctype);\n    }\n}', 'explanation': ""This segment checks whether a 'Content-Type' header already exists before adding one. In doing so, it prevents the generation of a duplicate 'Content-Type' header, which addresses part of the RFC requirement to not generate multiple header lines with the same name.""}}, {'C1': {'code': 'if (r->content_encoding\n        && !apr_table_get(headers_out, ""Content-Encoding"")) {\n    apr_table_setn(headers_out, ""Content-Encoding"", r->content_encoding);\n}', 'explanation': ""Similarly, this section conditionally sets the 'Content-Encoding' header only if it is not already present, thus avoiding duplicate header entries for that field.""}}]","The function merges two header tables (r->headers_out and r->err_headers_out) and then conditionally adds the 'Content-Type' and 'Content-Encoding' headers only when they are not already present. This directly prevents the creation of duplicate header field lines for these two specific headers, which is part of the RFC’s requirement. However, the RFC specification also addresses the ordering of header field lines and the general rule for handling all fields, which this function does not comprehensively implement. Therefore, while the function shows visible logic that addresses a part of the constraints (specifically for Content-Type and Content-Encoding), it does not fully implement all aspects of the RFC.",success,
18564,cache_merge_headers_out,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'if (r->content_type && !apr_table_get(headers_out, ""Content-Type"")) { ... }', 'explanation': 'The code checks if a content type is present (r->content_type) and that the Content-Type header has not already been set, satisfying the condition that if content exists and the media type is known, the header should be added.'}}, {'A1': {'code': 'const char *ctype = ap_make_content_type(r, r->content_type);\nif (ctype) {\n    apr_table_setn(headers_out, ""Content-Type"", ctype);\n}', 'explanation': ""This segment implements the action: generating and setting the Content-Type header using the provided content type, directly aligning with the RFC's recommendation.""}}]","The function 'cache_merge_headers_out' inspects the request to determine if r->content_type is present and if the Content-Type header is missing. If so, it computes the appropriate content type via ap_make_content_type and sets the header. This behavior directly implements the specification requirement to include a Content-Type header when the enclosed representation's media type is known, thereby fully matching the RFC constraint.",success,
18629,create_entity,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The RFC specification states that a cache may be employed but must not be used while acting as a tunnel. The provided function_body is focused on constructing and initializing cache objects, performing size checks, and skipping caching for partial content responses. However, it contains no logic to verify or enforce that the cache is not used when the entity is acting as a tunnel. As such, none of the labeled conditions or actions, in particular the condition regarding tunnel usage, are implemented in the function itself.",success,
18630,open_entity,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided function 'open_entity' focuses on locating and reading cached data from disk. It includes logic for opening the cache files, verifying file formats, and reading stored cache metadata. However, there is no logic in the function that checks whether the client/server is acting as a tunnel (i.e., disabling cache usage in tunnel mode), nor does it appear to implement any mechanism that would stop the cache when acting as a tunnel. As a result, the function does not implement the specified RFC requirement that a cache may not be used while acting as a tunnel.",success,
18634,read_array,"Although the line terminator for the start-line and fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",171,Partially Matches,"[{'C1': {'code': ""if (p > 0 && w[p - 1] == '\\n') {\n            if (p > 1 && w[p - 2] == CR) {\n                w[p - 2] = '\\0';\n            }\n            else {\n                w[p - 1] = '\\0';\n            }\n        }"", 'explanation': 'This code segment explicitly checks if a string read from the file ends with a newline character and then further verifies if the character immediately preceding the newline is a carriage return. If so, it removes both (i.e. treats the sequence as CRLF), otherwise it removes just the LF. This behavior directly addresses the spec requirement that a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.'}}]","The function implements logic for processing line terminators in accordance with the HTTP RFC snippet provided — it trims an LF and, if present, a preceding CR, effectively normalizing CRLF and lone LF line endings. However, it does not include additional checks (for example, handling bare CR characters by replacing them with a space or marking them as errors) as mentioned in the broader spec context. Therefore, while it visibly addresses the key condition related to line termination (labeled here as C1), it only partially fulfills the full specification requirements.",success,
18634,read_array,"Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message.",3,Does Not Match,[],"The provided function only strips trailing newline (\n) and optional carriage return (\r) characters from the end of each line read; it does not address the RFC requirement to replace or reject field values containing any CR, LF, or NUL characters. There is no logic within the function that detects dangerous in-string occurrences of these characters or replaces them with SP as mandated by the spec.",success,
18635,store_array,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function, store_array, simply writes an array of strings (each followed by a CRLF) to a file. There is no logic in the function that checks for or restricts protocol elements based on the sender's role, nor any validation to ensure that only elements permitted for the message sender are generated. In other words, none of the labeled constraints (such as C1 or A1) that require the sender to avoid generating protocol elements reserved for other roles is implemented within this function's code. The function does not include any conditional logic or verification that matches the RFC condition regarding role-based element generation; thus, the function does not visibly address the spec constraints.",success,
18635,store_array,The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.,36,Fully Matches,"[{'C1': {'code': 'iov[1].iov_base = CRLF;\niov[1].iov_len = sizeof(CRLF) - 1;\n\n...\n\niov[0].iov_base = CRLF;\niov[0].iov_len = sizeof(CRLF) - 1;', 'explanation': 'The function consistently appends the CRLF constant as the line break for each message body part. This directly addresses the spec requirement that a sender MUST generate only CRLF to represent line breaks.'}}]","The function iterates through an array of body parts and, for each element, concatenates the string with a CRLF line break by explicitly using the CRLF constant. It also appends an extra CRLF at the end of the data. This clearly demonstrates that within its own logic, the function implements the RFC requirement to use only CRLF for line breaks, fulfilling the relevant spec constraint.",success,
18636,read_table,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Partially Matches,"[{'C1': {'code': ""p = strlen(w);\nif (p > 0 && w[p - 1] == '\\n') {\n    if (p > 1 && w[p - 2] == CR) {\n        w[p - 2] = '\\0';\n    } else {\n        w[p - 1] = '\\0';\n    }\n}"", 'explanation': 'This segment removes trailing newline (and CR if present) from each header line. This is in line with the spec requirement to remove any bad whitespace (BWS) before further parsing.'}}, {'A1': {'code': 'while (apr_isspace(*l)) {\n    ++l;\n}', 'explanation': 'After splitting the header at the colon, this loop skips over any leading whitespace in the header value, effectively removing BWS as required by the spec.'}}]","The function reads header lines from a file and processes them by trimming the terminal newline and, if present, a preceding carriage-return, and then by removing any leading whitespace from the header value. These actions partially address the RFC's stipulation that any bad or unnecessary whitespace (BWS) be removed before further interpretation. However, while these code segments remove certain extraneous whitespace elements, they do not necessarily cover all possible instances or locations of BWS in a header, hence the assessment as 'Partially Matches.'",success,
18636,read_table,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Partially Matches,"[{'A1': {'code': ""if (p > 0 && w[p - 1] == '\\n') {\n    if (p > 1 && w[p - 2] == CR) {\n        w[p - 2] = '\\0';\n    } else {\n        w[p - 1] = '\\0';\n    }\n}"", 'explanation': 'This segment strips the trailing newline (and CR, if present) from the header line, which is a form of cleaning up extraneous whitespace.'}}, {'A2': {'code': ""*l++ = '\\0';\nwhile (apr_isspace(*l)) {\n    ++l;\n}"", 'explanation': ""After splitting the header at the colon, this loop removes any leading whitespace from the header value. This is an attempt to remove 'bad whitespace' before interpreting the header element.""}}]","The RFC requires a recipient to remove bad whitespace before using protocol elements. In this function, there is visible logic to strip the terminal CR/LF and to remove leading whitespace from the header value after the colon. However, these measures only partially address the RFC's intent—namely, the function cleans up specific whitespace issues (trailing newlines and leading spaces after the colon), but it does not comprehensively parse and remove all instances of bad whitespace that might occur in various parts of a header. Therefore, while the function does implement some whitespace cleanup steps, it only partially matches the complete set of requirements as stated in the RFC.",success,
18636,read_table,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Partially Matches,"[{'C1': {'code': ""if (p > 0 && w[p - 1] == '\\n') {\n    if (p > 1 && w[p - 2] == CR) {\n        w[p - 2] = '\\0';\n    } else {\n        w[p - 1] = '\\0';\n    }\n}"", 'explanation': 'This block removes the terminal newline (or CRLF), which addresses part of the trailing whitespace removal as specified by the RFC.'}}, {'A1': {'code': ""*l++ = '\\0';\nwhile (apr_isspace(*l)) {\n    ++l;\n}"", 'explanation': 'After splitting the header into name and value, this code advances past any leading whitespace in the field value, thereby excluding it before further evaluation.'}}]","The function attempts to implement the RFC requirement by trimming unwanted whitespace from header fields. It explicitly removes trailing newline/CRLF characters and skips over leading whitespace in the header value. However, if there is additional trailing whitespace beyond the newline characters (i.e., spaces before the newline), the function does not explicitly trim it. Thus, while it addresses part of the requirement (as seen in C1 and A1), it does not fully guarantee that both leading and trailing whitespace are removed in all cases.",success,
18639,store_table,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function 'store_table' simply serializes a table of key-value pairs into a string format with the header syntax (key, colon, space, value, CRLF) and writes them to a file. There is no logic in the function that checks or enforces any role restrictions as specified by the RFC requirement that a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles. Thus, none of the labeled conditions (e.g., C1) or actions (e.g., A1) from the RFC spec constraints are implemented within the function itself.",success,
18639,store_table,"A sender MUST NOT generate a message that includes line folding (i.e., that has any field line value that contains a match to the obs-fold rule) unless the message is intended for packaging within the ""message/http"" media type.",301,Does Not Match,[],"The provided function, store_table, only writes the header fields to a file using a simple concatenation of key, literal "": "", value, and CRLF. There is no logic within the function that checks for, prevents, or handles obs-fold (line folding) as required by the RFC specification. Specifically, there is no code that verifies that any header field value does not contain sequences that would match the obs-fold rule, nor is there any alternative handling for the ""message/http"" media type scenario. As a result, the function does not visibly address any of the RFC constraints (e.g., C1 or any relevant action A1) solely by its own implementation.",success,
18642,store_body,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The provided function 'store_body' implements logic for reading response buckets and storing them to disk for caching. However, it does not include any logic that relates to the RFC specification which states that a cache cannot be used while a client or server is acting as a tunnel. There is no code in the function to check for a tunneling state or to disable caching in that scenario. As such, none of the spec constraints (e.g., the prohibition of using a cache when acting as a tunnel) are addressed in this function.",success,
18657,cache_create_entity,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The RFC specifies that while any client or server may employ a cache, a cache cannot be used while acting as a tunnel. In the provided function_body, the code is solely responsible for creating a cache entity by generating a cache key if necessary, selecting a cache provider, and attempting to create the cached entity. There is no logic in this function that checks or enforces the condition that a cache should not be used if the client/server is acting as a tunnel. Therefore, this function does not visibly address the spec constraint related to tunnel behavior, and no labeled constraints (e.g., C1, A1) from the spec are implemented in the function.",success,
18662,cache_select,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'A1': {'code': 'if (!ap_cache_check_no_cache(cache, r)) {\n        return DECLINED;\n    }\n\n    if (!cache->key) {\n        rv = cache_generate_key(r, r->pool, &cache->key);\n        if (rv != APR_SUCCESS) {\n            return DECLINED;\n        }\n    }\n    \n    /* go through the cache types till we get a match */\n    h = apr_palloc(r->pool, sizeof(cache_handle_t));\n\n    list = cache->providers;\n\n    while (list) { ... }', 'explanation': 'This segment implements using a cache by checking for caching directives (e.g. no-cache) and then generating a key and selecting a cached response. This logic aligns with the permission for a client or server to employ a cache as allowed by the RFC.'}}]","The function 'cache_select' includes internal logic for employing a cache by validating request headers, handling cache key generation, and verifying response freshness. This satisfies the part of the RFC that allows the use of a cache. However, the RFC also specifies that a cache cannot be used while acting as a tunnel, and there is no visible check or condition in this function that prevents caching when the connection is a tunnel. Since the function does not address the 'tunnel' exception within its own code, it only partially matches the specification.",success,
18662,cache_select,"Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method.",282,Partially Matches,"[{'C1': {'code': 'if (ap_condition_if_match(r, h->resp_hdrs) == AP_CONDITION_NOMATCH\n        || ap_condition_if_unmodified_since(r, h->resp_hdrs) == AP_CONDITION_NOMATCH\n        || ap_condition_if_none_match(r, h->resp_hdrs) == AP_CONDITION_NOMATCH\n        || ap_condition_if_modified_since(r, h->resp_hdrs) == AP_CONDITION_NOMATCH\n        || ap_condition_if_range(r, h->resp_hdrs) == AP_CONDITION_NOMATCH) {\n    mismatch = 1;\n}', 'explanation': 'This segment evaluates various conditional headers (If-Match, If-Unmodified-Since, etc.) before proceeding with using a cached entity. It directly attempts to implement the RFC mandate to evaluate received request preconditions prior to processing the request content.'}}, {'A1': {'code': 'if (!cache_check_freshness(h, cache, r)) {\n    /* Cache-Control: only-if-cached and revalidation required */\n    if (cache->control_in.only_if_cached) {\n        /* try again with next cache type */\n        list = list->next;\n        continue;\n    }\n\n    /* set aside the stale entry for accessing later */\n    cache->stale_headers = apr_table_copy(r->pool, r->headers_in);\n    cache->stale_handle = h;\n\n    /* if no existing conditionals, use conditionals of our own */\n    if (!mismatch) {\n        /* Remove existing conditionals that might conflict with ours */\n        apr_table_unset(r->headers_in, ""If-Match"");\n        apr_table_unset(r->headers_in, ""If-Modified-Since"");\n        apr_table_unset(r->headers_in, ""If-None-Match"");\n        apr_table_unset(r->headers_in, ""If-Range"");\n        apr_table_unset(r->headers_in, ""If-Unmodified-Since"");\n\n        etag = apr_table_get(h->resp_hdrs, ""ETag"");\n        lastmod = apr_table_get(h->resp_hdrs, ""Last-Modified"");\n\n        if (etag || lastmod) {\n            if (etag) {\n                apr_table_set(r->headers_in, ""If-None-Match"", etag);\n            }\n            if (lastmod) {\n                apr_table_set(r->headers_in, ""If-Modified-Since"", lastmod);\n            }\n            apr_table_unset(r->headers_in, ""Range"");\n        }\n    }\n\n    /* ready to revalidate, pretend we were never here */\n    return DECLINED;\n}', 'explanation': 'This block handles the case when a cached response is stale. It resets any conflicting conditional headers and adds its own based on the cached ETag and Last-Modified values so that revalidation can soon occur. This aligns with the action of preparing for conditional re-request processing before further handling.'}}]","The function shows visible logic for evaluating and acting upon HTTP conditional requests: it checks various conditional header fields (via ap_condition_if_* calls) and, when a cached response is deemed stale, it clears and sets conditional headers for revalidation. This reflects an attempt to implement the RFC directive to evaluate preconditions before processing request content. However, it does not fully cover all aspects of the RFC (for example, it does not check that precondition evaluation should be skipped if the non-conditional response would have resulted in a status other than 2xx or 412), and some of the broader context likely handled elsewhere. Thus, the implementation within this function partially meets the specification.",success,
18662,cache_select,A server MAY ignore the Range header field.,126,Partially Matches,"[{'A1': {'code': '/* Do not do Range requests with our own conditionals: If\n * we get 304 the Range does not matter and otherwise the\n * entity changed and we want to have the complete entity */\napr_table_unset(r->headers_in, ""Range"");', 'explanation': ""This code explicitly removes the Range header from the request when adding the server's own conditional headers. This is an implementation choice that shows the server is purposely ignoring the Range header as permitted by the RFC.""}}]","The provided function is focused on cache selection and revalidation. Within its logic, it checks various cache conditions and manipulates request headers, including a branch where it unsets the 'Range' header. This indicates an intentional decision to ignore the Range header in some cases, thus partially addressing the RFC instruction that a server MAY ignore the Range header field. However, the function does not implement comprehensive handling for range requests (for example, it does not check that range handling is only defined for GET or support byte-range requests), so from the perspective of this function alone, the RFC is only partially met.",success,
18663,cache_canonicalise_key,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': 'if (r->proxyreq && (r->proxyreq != PROXYREQ_REVERSE)) {\n    if (parsed_uri->port_str) {\n        port_str = apr_pcalloc(p, strlen(parsed_uri->port_str) + 2);\n        port_str[0] = \':\';\n        for (i = 0; parsed_uri->port_str[i]; i++) {\n            port_str[i + 1] = apr_tolower(parsed_uri->port_str[i]);\n        }\n    }\n    else if (apr_uri_port_of_scheme(scheme)) {\n        port_str = apr_psprintf(p, "":%u"", apr_uri_port_of_scheme(scheme));\n    }\n    else {\n        port_str = """";\n    }\n}\nelse {\n    if (conf->base_uri && conf->base_uri->port_str) {\n        port_str = apr_pstrcat(p, "":"", conf->base_uri->port_str, NULL);\n    }\n    else if (conf->base_uri && conf->base_uri->hostname) {\n        port_str = """";\n    }\n    else {\n        port_str = apr_psprintf(p, "":%u"", ap_get_server_port(r));\n    }\n}', 'explanation': 'This code segment implements the RFC specification for handling missing port information. When no port is provided in the URI, it defaults to using the default port for the scheme, either via apr_uri_port_of_scheme or by using the server port. This directly addresses the condition that a missing port may be interpreted as the message being received on the default port.'}}]","The function constructs a canonical key for caching by including scheme, hostname, port, path, and query parameters. The logic handling the port checks for an explicit port string and, if missing, assigns the default port for the protocol. This directly implements the RFC requirement that if a port is not provided, a recipient may interpret it as having been received on the default port for that protocol. Thus, the code fully matches the relevant RFC constraint.",success,
18663,cache_canonicalise_key,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Fully Matches,"[{'C1': {'code': 'if (!r->proxyreq || (r->proxyreq == PROXYREQ_REVERSE)) {\n        if (conf->base_uri && conf->base_uri->hostname) {\n            hostname = conf->base_uri->hostname;\n        }\n        else {\n            /* Use _default_ as the hostname if none present, as in mod_vhost */\n            hostname = ap_get_server_name(r);\n            if (!hostname) {\n                hostname = ""_default_"";\n            }\n        }\n    } else if (parsed_uri->hostname) {\n        hn = apr_pstrdup(p, parsed_uri->hostname);\n        ap_str_tolower(hn);\n        hostname = hn;\n    } else {\n        hostname = ""_default_"";\n    }', 'explanation': ""The code ensures that a hostname is always set by selecting it from the configuration, using the server name, or defaulting to '_default_' if no hostname is found. This directly prevents the generation of an HTTP URI with an empty host identifier, satisfying the RFC requirement.""}}]","The function 'cache_canonicalise_key' constructs a canonicalized cache key representing an HTTP URI. It explicitly ensures that the URI always includes a non-empty hostname by using either the configured base URI's hostname, the server's name (via ap_get_server_name), or a default value ('_default_') if none is available. This directly implements the RFC constraint that a sender MUST NOT generate an 'http' URI with an empty host identifier.",success,
18663,cache_canonicalise_key,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Partially Matches,"[{'C1': {'code': 'ap_str_tolower(hn);\n...\nif (r->proxyreq && parsed_uri->scheme) {\n    lcs = apr_pstrdup(p, parsed_uri->scheme);\n    ap_str_tolower(lcs);\n    ...\n}', 'explanation': 'The code normalizes parts of the HTTP URI by converting the hostname and scheme to lower case. This is one aspect of normalizing equivalent URIs according to the spec.'}}, {'A1': {'code': '*key = apr_pstrcat(p, scheme, ""://"", hostname, port_str, kpath, ""?"", kquery, NULL);', 'explanation': 'The function constructs a canonical key by concatenating the normalized components (scheme, hostname, port, path, and query). This demonstrates an attempt to ensure that equivalent URIs are mapped to the same resource.'}}]","The function attempts to implement normalization of HTTP URIs by lowercasing the hostname and scheme, optionally ignoring the query string, and removing specified session ID parameters before constructing a canonical key. However, while these measures address some aspects of the normalization requirement from the spec, the code does not cover all normalization cases (for example, percent-encoding normalization or path segment normalization). Therefore, it only partially matches the RFC specification as provided.",success,
18665,cache_invalidate,"Two HTTP URIs that are equivalent after normalization (using any method) can be assumed to identify the same resource, and any HTTP component MAY perform normalization.",227,Fully Matches,"[{'C1': {'code': 'location = apr_table_get(r->headers_out, ""Location"");\nif (location) {\n    if (apr_uri_parse(r->pool, location, &location_uri)\n            || cache_canonicalise_key(r, r->pool,\n                                      location_uri.path,\n                                      location_uri.query,\n                                      &location_uri, &location_key)\n            || !(r->parsed_uri.hostname\n                 && location_uri.hostname\n                 && !strcmp(r->parsed_uri.hostname, location_uri.hostname))) {\n        location_key = NULL;\n    }\n}\n\ncontent_location = apr_table_get(r->headers_out, ""Content-Location"");\nif (content_location) {\n    if (apr_uri_parse(r->pool, content_location, &content_location_uri)\n            || cache_canonicalise_key(r, r->pool,\n                                      content_location_uri.path,\n                                      content_location_uri.query,\n                                      &content_location_uri, &content_location_key)\n            || !(r->parsed_uri.hostname\n                 && content_location_uri.hostname\n                 && !strcmp(r->parsed_uri.hostname, content_location_uri.hostname))) {\n        content_location_key = NULL;\n    }\n}', 'explanation': ""This segment parses the 'Location' and 'Content-Location' headers, and canonicalizes them via 'cache_canonicalise_key'. This implements normalization of HTTP URIs, addressing the condition that two HTTP URIs equivalent after normalization should identify the same resource.""}}, {'A1': {'code': 'rv = list->provider->open_entity(h, r, cache->key);\nif (OK == rv) {\n    rv = list->provider->invalidate_entity(h, r);\n    status = OK;\n}\n\nif (location_key) {\n    rv = list->provider->open_entity(h, r, location_key);\n    if (OK == rv) {\n        rv = list->provider->invalidate_entity(h, r);\n        status = OK;\n    }\n}\n\nif (content_location_key) {\n    rv = list->provider->open_entity(h, r, content_location_key);\n    if (OK == rv) {\n        rv = list->provider->invalidate_entity(h, r);\n        status = OK;\n    }\n}', 'explanation': ""This code uses the normalized keys generated for the main request URI, the 'Location' URI, and the 'Content-Location' URI to access and invalidate cache entries. It enforces that equivalent URIs (after normalization) are treated uniformly in cache invalidation, as the HTTP RFC requires.""}}]","The function explicitly performs URI normalization by parsing and canonicalizing the 'Location' and 'Content-Location' headers. It then uses these normalized (canonicalized) keys to invalidate cached entities. This directly addresses the HTTP spec requirement that two equivalent HTTP URIs after normalization be considered the same resource. As the normalization logic and its subsequent use in invalidation are entirely contained within the function, the code fully matches the specified constraints.",success,
18736,cache_the_file,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'sconf = ap_get_module_config(cmd->server->module_config, &file_cache_module);\napr_hash_set(sconf->fileht, new_file->filename, strlen(new_file->filename), new_file);', 'explanation': 'The function implements a caching mechanism by storing the file information and its associated handle or memory-mapped data in a hash table, thereby embodying the notion of a local cache as described in the spec.'}}]","The provided function 'cache_the_file' clearly takes steps to cache a file by checking its validity (file existence, type, size), opening the file, optionally memory-mapping it, and finally storing the file object in a server configuration's hash table. This demonstrates that a cache (i.e. a local store of file data) is being employed, which aligns with the part of the RFC that indicates that any client or server may employ a cache. However, the spec also states that a cache cannot be used while acting as a tunnel, and the function does not include any logic or checks to prevent caching when acting as a tunnel. As such, while the caching functionality (C1) is implemented, the constraint regarding tunnel mode is not addressed within this function, leading to the conclusion of a partial match.",success,
18736,cache_the_file,"When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.",245,Fully Matches,"[{'A1': {'code': 'apr_rfc822_date(new_file->mtimestr, new_file->finfo.mtime);', 'explanation': ""This call formats the file's modification time into a string. The apr_rfc822_date function is used here to produce a timestamp in the format required by HTTP (i.e. the IMF-fixdate format), thus implementing the spec requirement.""}}]","The specification mandates that timestamps be generated in the IMF-fixdate format. Within the function, the sole logic related to timestamp generation is the call to apr_rfc822_date, which converts the file's modification time into a properly formatted date string. This implementation directly addresses the RFC requirement (via A1) within the function's own scope, without relying on external code or dependencies.",success,
18737,cachefilehandle,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Does Not Match,[],"The RFC specifies that a cache may be used by any client or server except when acting as a tunnel; however, the provided function simply attempts to cache a file by calling cache_the_file (or logs a warning if that functionality is not supported) without any conditional logic regarding whether the entity is operating as a tunnel. There is no code that checks or enforces the restriction described (e.g., ensuring that a cache is not used when acting as a tunnel), nor is there any logic managing cache behavior in accordance with the specific RFC guidance. As a result, within the target code function, no visible part addresses the labeled condition or action, and the function does not implement the requirements stated in the RFC.",success,
18740,file_cache_xlat,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,"[{'C1': {'code': 'if (!apr_hash_count(sconf->fileht)) {\n        return DECLINED;\n    }', 'explanation': 'This segment checks that a cache is configured by verifying that at least one cachefile directive exists. It implements the optional use of a cache in accordance with the RFC permission that a client or server MAY employ a cache.'}}, {'A1': {'code': 'match = (a_file *) apr_hash_get(sconf->fileht, r->filename, APR_HASH_KEY_STRING);\n    if (match == NULL)\n        return DECLINED;\n    \n    /* pass search results to handler */\n    ap_set_module_config(r->request_config, &file_cache_module, match);\n    \n    /* shortcircuit the get_path_info() stat() calls and stuff */\n    r->finfo = match->finfo;\n    return OK;', 'explanation': 'This part retrieves a cached file entry based on the request filename and, if found, uses its file information to bypass further processing. It directly uses the cache to shortcut typical file lookup operations.'}}]","The function implements part of the RFC's specification by allowing caching when a cache is available. It checks for the presence of a cache and retrieves cached content to optimize processing. However, it does not implement the constraint that a cache must not be used when acting as a tunnel. Since the RFC clearly states that 'a cache cannot be used while acting as a tunnel' but no such check is present, the function only partially matches the specification.",success,
18743,file_cache_handler,"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity tag's use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability, scalability, and reliability.",57,Fully Matches,"[{'A1': {'code': 'ap_set_etag(r);', 'explanation': 'The RFC requires that an origin server SHOULD send an ETag for selected representations. This function directly calls ap_set_etag(r) to set the ETag header, thereby addressing the requirement within its own scope.'}}]","The function explicitly calls ap_set_etag(r) before processing conditional requests, which directly meets the RFC specification that an origin server should send an ETag for change detection and effective caching. All relevant logic associated with the ETag requirement is contained within the function, so it fully implements the necessary aspect of the specification.",success,
18743,file_cache_handler,"An origin server MUST NOT send a validator field (Section 8.8), such as an ETag or Last-Modified field, in a successful response to PUT unless the request's representation data was saved without any transformation applied to the content (i.e., the resource's new representation data is identical to the content received in the PUT request) and the validator field value reflects the new representation.",70,Does Not Match,[],"The provided function, file_cache_handler, handles only GET requests and does not implement any logic related to handling PUT requests. As the RFC specification requires constraints regarding the inclusion or exclusion of validator fields (such as ETag or Last-Modified) in responses to PUT requests based on transformation conditions, none of that behavior is addressed in this function. All validator fields (e.g., setting Last-Modified and ETag) in this function are set for GET responses and do not consider the PUT-specific conditions described in the RFC.",success,
18743,file_cache_handler,"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([CACHING]) can substantially reduce unnecessary transfers and significantly improve service availability and scalability.",52,Fully Matches,"[{'C1': {'code': 'ap_update_mtime(r, match->finfo.mtime);\n\n{\n    apr_time_t mod_time;\n    char *datestr;\n\n    mod_time = ap_rationalize_mtime(r, r->mtime);\n    if (mod_time == match->finfo.mtime)\n        datestr = match->mtimestr;\n    else {\n        datestr = apr_palloc(r->pool, APR_RFC822_DATE_LEN);\n        apr_rfc822_date(datestr, mod_time);\n    }\n    apr_table_setn(r->headers_out, ""Last-Modified"", datestr);\n}', 'explanation': ""This code determines the resource's last modification time and sets the 'Last-Modified' HTTP header, directly addressing the RFC requirement that an origin server should send a Last-Modified header for representations where a modification date can be determined.""}}]","The function clearly calculates the last modification time using the file's information (from match->finfo.mtime) and sets the 'Last-Modified' header accordingly. This visible implementation within the function_body satisfies the RFC specification related to caching and conditional requests by ensuring that the Last-Modified value is sent, thus fully matching the intended requirement.",success,
18743,file_cache_handler,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Does Not Match,[],"The RFC specification requires that a Content-Length header must not be sent in any message containing a Transfer-Encoding header. In the function_body, the code always sets the Content-Length header (using apr_table_setn on ""Content-Length"") without checking for the presence of a Transfer-Encoding header. There is no conditional logic that omits the Content-Length header when Transfer-Encoding is present, meaning the function does not address this RFC constraint.",success,
18743,file_cache_handler,"Any client or server MAY employ a cache, though a cache cannot be used while acting as a tunnel.",222,Partially Matches,[],"The provided function implements a file‐cache mechanism for GET requests—it retrieves a matched cached file, sets response headers (Last-Modified, Content-Length, ETag), and uses appropriate file‐send handlers. This demonstrates an attempt to “employ a cache” as the RFC allows. However, the RFC also specifies that a cache cannot be used while acting as a tunnel, and there is no explicit logic in this function that checks for or prevents cache usage when acting as a tunnel. Since only part of the spec (the use of a cache) is visibly addressed within this function and the tunnel condition is not checked, the function only partially matches the spec constraints.",success,
18743,file_cache_handler,"When a sender generates a field that contains one or more timestamps defined as HTTP-date, the sender MUST generate those timestamps in the IMF-fixdate format.",245,Partially Matches,"[{'A1': {'code': 'mod_time = ap_rationalize_mtime(r, r->mtime);\nif (mod_time == match->finfo.mtime)\n    datestr = match->mtimestr;\nelse {\n    datestr = apr_palloc(r->pool, APR_RFC822_DATE_LEN);\n    apr_rfc822_date(datestr, mod_time);\n}\napr_table_setn(r->headers_out, ""Last-Modified"", datestr);', 'explanation': ""The specification requires that HTTP-date values be generated in the IMF-fixdate format. Here, the function sets the 'Last-Modified' header and, in one code branch, calls apr_rfc822_date to produce a date string—which typically follows the required HTTP-date (IMF-fixdate) format. However, if the file’s modification time matches a cached value (match->mtimestr), the function reuses that string without demonstrating locally that it conforms to the IMF-fixdate format. Thus, the function shows an attempt to meet the timestamp format requirement, but not comprehensively in all cases.""}}]","The function shows logic for generating an HTTP date for the 'Last-Modified' header. In one branch it explicitly converts the time using apr_rfc822_date, which is generally used to output dates in the HTTP-date (IMF-fixdate) format. However, it reuses a pre-formatted date string from match->mtimestr in another branch without verifying its format, and no other HTTP-date fields are addressed. Because only part of the spec constraint is visibly implemented within this function, the overall judgment is that it Partially Matches the specification.",success,
18743,file_cache_handler,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Partially Matches,"[{'A1': {'code': 'r->clength = match->finfo.size;\napr_table_setn(r->headers_out, ""Content-Length"", match->sizestr);', 'explanation': 'These lines explicitly set the Content-Length header, which implements the RFC recommendation to generate length-delimited messages. This helps ensure that the response message is properly framed by specifying its length.'}}]","The provided function sets the Content-Length header for GET responses using cached file information, which partially implements the RFC requirement that a server SHOULD generate encoding or length-delimited messages whenever possible. However, other aspects of the RFC (such as handling conditions involving invalid Content-Length headers, Transfer-Encoding, or distinguishing between a fully completed and a prematurely closed connection) are not addressed within this function. Therefore, the function only partially matches the specified constraints.",success,
18743,file_cache_handler,"An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.",268,Fully Matches,"[{'C1': {'code': 'if (r->method_number != M_GET) return DECLINED;\n\n/* This handler has no use for a request body (yet), but we still\n * need to read and discard it if the client sent one.\n */\nif ((errstatus = ap_discard_request_body(r)) != OK)\n    return errstatus;', 'explanation': 'The RFC states that an origin server SHOULD NOT rely on private agreements to receive content. This implies that the server should not process any request body content sent with a GET request unless explicitly supported. The code explicitly checks that the method is GET and then discards any request body, thereby ensuring it does not rely on any content that might have been sent based on a private agreement.'}}]","The function 'file_cache_handler' confirms that it only processes requests using the GET method and discards any message body that might accompany such requests. By doing so, the function avoids processing content provided in GET requests, which aligns with the RFC requirement that an origin server should not rely on private agreements to receive content. The key parts of the code that implement this logic are the method check and the call to ap_discard_request_body(). Therefore, the function fully addresses the specified constraint as implemented within it.",success,
18743,file_cache_handler,"In 200 responses to GET or HEAD, an origin server SHOULD send any available validator fields (Section 8.8) for the selected representation, with both a strong entity tag and a Last-Modified date being preferred.",141,Fully Matches,"[{'A1': {'code': 'apr_table_setn(r->headers_out, ""Last-Modified"", datestr);', 'explanation': ""This code sets the Last-Modified header based on the file's modification time, thereby providing one of the preferred validator fields.""}}, {'A2': {'code': 'ap_set_etag(r);', 'explanation': 'This call sets the entity tag (ETag) header, ensuring that a strong entity tag is provided as preferred by the RFC.'}}]","The function explicitly handles GET requests (which in Apache may also cover HEAD when header_only is set) and updates the response with both the Last-Modified header and the ETag header. By doing so, it addresses the key requirement from the RFC specification that a 200 response should ideally include available validator fields, namely a strong entity tag and a Last-Modified date. Therefore, within the bounds of its own logic (ignoring caller and dependency implementations), this function fully matches the specification constraints.",success,
18743,file_cache_handler,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The function does not implement any logic to verify that the Content-Length header field is correct. The RFC mandates that a sender MUST NOT forward a message with a Content-Length header field value known to be incorrect or that does not match the required ABNF. In the provided code, the Content-Length header is simply set from cached file metadata (match->sizestr and match->finfo.size) without any validation against the actual message framing or verification of the header's correctness. There is no check to ensure that the value conforms to the expected format or that it correctly represents the actual message body length. As a result, the function does not address the specified RFC requirements.",success,
18743,file_cache_handler,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Partially Matches,"[{'A1': {'code': 'r->clength = match->finfo.size;\napr_table_setn(r->headers_out, ""Content-Length"", match->sizestr);', 'explanation': 'This code explicitly sets the Content-Length header using the precomputed file size when the content size is known, thereby implementing the recommendation to include a Content-Length header when available.'}}]","The function implements the action of sending a Content-Length header when the content size is known (A1). However, it does not contain any logic to prevent sending a Content-Length header for responses that should not include it (e.g., responses with 1xx, 204, or 2xx CONNECT responses) as detailed in the specification context. Thus, while it addresses part of the spec by sending Content-Length when applicable, it fails to handle the conditions mandated by the spec regarding when not to send this header.",success,
18743,file_cache_handler,"Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would process the request content (if any) or perform the action associated with the request method.",282,Fully Matches,"[{'C1': {'code': 'if ((errstatus = ap_meets_conditions(r)) != OK)\n       return errstatus;', 'explanation': 'This code explicitly evaluates the request preconditions (by calling ap_meets_conditions) after normal request checks (such as verifying GET method, discarding the body, and updating headers) and just before processing the file content. This aligns with the RFC requirement of checking preconditions right before processing the request content.'}}]","The function file_cache_handler carries out the normal request checks and, crucially, invokes ap_meets_conditions to evaluate request preconditions before processing the resource. This in-function call directly implements the key aspect of the RFC specification regarding conditional evaluation. No other dependencies or external functions contribute to this decision within the function, so based solely on its visible logic, the function fully addresses the spec constraint.",success,
18749,process_echo_connection,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function primarily reads input from a client and echoes it back without any explicit logic to check or restrict protocol elements based on the sender's role. The RFC specification requires that a sender must not generate protocol elements or syntax alternatives that are only allowed for other roles. However, within this function, there is no code that verifies whether the generated protocol elements conform to the proper grammar or role-based restrictions. All processing is focused on reading and writing data, without any validation or enforcement of the role limits as required by the RFC. Therefore, the function does not visibly address any of the specified constraints.",success,
18749,process_echo_connection,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The provided code function (process_echo_connection) serves as an echo mechanism; it reads lines from the client and writes them back without checking if these protocol elements match any ABNF-defined grammar. There is no attempt within the function to validate or enforce the RFC requirement that a sender must not generate protocol elements that do not adhere to the grammar. Therefore, none of the spec constraints (e.g., C1, A1) are visibly addressed in this function's implementation.",success,
18749,process_echo_connection,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Partially Matches,"[{'C1': {'code': 'if (!csd) {\n    csd = ap_get_conn_socket(c);\n    apr_socket_timeout_set(csd, c->base_server->keep_alive_timeout);\n}\n\nfor ( ; ; ) {\n    apr_status_t rv;\n    if (((rv = ap_get_brigade(c->input_filters, bb, AP_MODE_GETLINE, APR_BLOCK_READ, 0)) != APR_SUCCESS)) {\n        apr_brigade_cleanup(bb);\n        ...\n        break;\n    }\n    ...\n    rv = ap_pass_brigade(c->output_filters, bb);\n    if (rv != APR_SUCCESS) {\n        ...\n        break;\n    }\n    apr_brigade_cleanup(bb);\n    ...\n}', 'explanation': 'The function loops indefinitely reading and writing data on the connection and sets a socket timeout using a keep_alive_timeout. This indicates an attempt to sustain persistent connections, as per the RFC requirement.'}}]","The code function attempts to implement persistent connection behavior by continuously processing requests on an open connection and by setting a socket timeout, which partially addresses the requirement of sustaining persistent connections. However, there is no explicit handling within the function for allowing the underlying transport's flow-control mechanisms to mitigate temporary overloads, nor is there logic to handle cases where the server stops reading mid-request as described in the spec context. Thus, while the persistent connection aspect is partially covered, the overall implementation does not fully meet the RFC's detailed recommendations.",success,
18752,main,"Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",308,Does Not Match,[],"The function_body code does not contain any logic pertaining to the RFC specification regarding transfer codings, specifically the prohibition of defining parameters called ""q"". There is no reference or handling of transfer codings or query parameters named ""q"" anywhere in the code. The function focuses solely on constructing and sending HTTP GET requests with varying lengths and does not address any of the labeled constraints from the specification.",success,
18752,main,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Does Not Match,[],"The RFC specification mandates that a sender MUST NOT include a Content-Length header in any message that also contains a Transfer-Encoding header. In the provided function_body, there is no logic that checks for the presence of a Transfer-Encoding header field or conditionally omits sending a Content-Length header field when such a header is present. Even though the function sends a Content-Length header in the TEST_LONG_REQUEST_BODY branch, it does so unconditionally without verifying or handling the presence of a Transfer-Encoding header. Thus, none of the code segments address the specific requirement defined in the RFC.",success,
18752,main,A sender MUST NOT send whitespace between the start-line and the first header field.,295,Does Not Match,[],"The provided function does not include any logic to ensure that no whitespace is sent between the HTTP start-line and the first header field as required by the RFC. It simply constructs and sends HTTP requests (including various test types) without any checks or handling for extraneous whitespace between the start-line and header fields. Therefore, none of the spec constraints (e.g., C1, A1) are visibly addressed within this function.",success,
18788,parse_host_port,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': '*pport = rv? 0 : (port? (uint16_t)port : def_port);', 'explanation': 'This line implements the behavior where if no port is explicitly specified (port remains 0), the function substitutes the provided default port (def_port) as per the RFC requirement.'}}]","The provided function 'parse_host_port' includes logic to check for a colon indicating an explicit port. If no port is provided (i.e., the parsed port remains 0), it returns the default port (def_port) via '*pport = (port? (uint16_t)port : def_port);'. This directly addresses the RFC specification that states 'if a port is not provided, a recipient MAY interpret that as meaning it was received on the default port'. Thus, the function fully implements the relevant condition (labeled C1) from the spec.",success,
18788,parse_host_port,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Fully Matches,"[{'C1': {'code': 'if (i == offset) {\n            log_debugf(""parse_uri"", ""empty host name in \'%.*s"", (int)len, s);\n            goto leave;\n        }', 'explanation': 'This segment checks whether no characters were consumed for the host (i.e., an empty host identifier) and triggers an error path (via goto leave), effectively ensuring that an empty host is not accepted. This directly addresses the RFC requirement that a sender must not generate an HTTP URI with an empty host identifier.'}}]","The function 'parse_host_port' explicitly checks for an empty host identifier by comparing the current index 'i' with the initial offset, and logs an error if they are equal. This error handling prevents further processing when the host is empty, thereby enforcing the RFC's mandate. Although the function is involved in parsing rather than generating URIs, its logic to reject empty host identifiers meets the specified constraint within its isolated implementation.",success,
18788,parse_host_port,A recipient that processes such a URI reference MUST reject it as invalid.,224,Fully Matches,"[{'C1': {'code': 'if (s[offset] == \'[\') {\n    ipv6 = 1;\n    for (i = offset++; i < len; ++i) {\n        if (s[i] == \']\')\n          break;\n    }\n    if (i >= len || i == offset)\n        goto leave;\n    host = strndup(s + offset, i - offset);\n    offset = i + 1;\n}\nelse {\n    for (i = offset; i < len; ++i) {\n        if (strchr(""/:?#"", s[i]))\n          break;\n    }\n    if (i == offset) {\n        log_debugf(""parse_uri"", ""empty host name in \'%.*s"", (int)len, s);\n        goto leave;\n    }\n    host = strndup(s + offset, i - offset);\n    offset = i;\n}', 'explanation': 'The code checks for an empty host identifier in both IPv6-qualified and normal host contexts. When the host part is empty (i.e., for non-bracket hosts, i == offset), it logs a debug message and goes to the leave label, resulting in a rejection (rv remains non-zero). This directly implements the condition from the spec that a URI reference with an empty host MUST be rejected.'}}, {'A1': {'code': '*phost = rv? NULL : host;\n*pport = rv? 0 : (port? (uint16_t)port : def_port);', 'explanation': 'By setting the host pointer to NULL (and accordingly returning an error indicated by the non-zero return value) when the host identifier is empty, the function rejects such invalid URI references, fulfilling the action requirement from the spec.'}}]","The provided function checks whether the host component of the URI is empty for both IPv6 and non-IPv6 cases. If the host is found to be empty, it logs the issue and aborts parsing by returning an error. Additionally, it provides a mechanism to return a default port if no port is explicitly provided. Together, these behaviors address the spec constraint that a recipient processing an 'http' URI with an empty host MUST reject it as invalid. All logic necessary to implement this constraint is contained within the function, making the implementation fully compliant with the specified condition and action.",success,
18788,parse_host_port,A recipient that processes such a URI reference MUST reject it as invalid.,226,Partially Matches,"[{'C1': {'code': 'if (i == offset) {\n    log_debugf(""parse_uri"", ""empty host name in \'%.*s"", (int)len, s);\n    goto leave;\n}', 'explanation': 'This code segment checks if the host identifier is empty (i.e., no characters were parsed) and, if so, rejects the URI by jumping to the cleanup/exit path. This directly addresses the RFC requirement that a recipient processing an HTTPS URI must reject it if the host identifier is empty.'}}]","The function primarily parses a host (with optional IPv6 formatting) and an optional port. It includes logic to detect an empty host identifier and rejects the URI when that occurs, which is in line with the provided RFC specification that mandates rejection of an HTTPS URI with an empty host. However, other aspects of the RFC (for example, default port handling or additional authority component validations) are not explicitly or fully addressed by this function alone. Therefore, it only partially matches the spec constraints.",success,
18789,parse_uri,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Partially Matches,"[{'C1': {'code': 'if (len > 5 && !memcmp(""ws://"", s, 5)) {\n        uri->scheme = ""ws"";\n        def_port = 80;\n        offset = 5;\n    }\n    else if (len > 6 && !memcmp(""wss://"", s, 6)) {\n        uri->scheme = ""wss"";\n        def_port = 443;\n        offset = 6;\n    }\n    ...\n    if (parse_host_port(&uri->host, &uri->port, &uri->ipv6, &n, s + offset, len - offset, def_port))\n        goto leave;\n    offset += n;\n\n    if (uri->port == def_port)\n      uri->authority = uri->host;\n    else if (uri->ipv6) {\n      snprintf(tmp, sizeof(tmp), ""[%s]:%u"", uri->host, uri->port);\n      uri->authority = strdup(tmp);\n    }\n    else {\n      snprintf(tmp, sizeof(tmp), ""%s:%u"", uri->host, uri->port);\n      uri->authority = strdup(tmp);\n    }', 'explanation': 'This segment sets a default port (80 for ""ws"" and 443 for ""wss"") when no explicit port is provided, fulfilling the spec requirement that a non-specified port may be interpreted as the default port for the received-protocol. It then uses this default value when generating the authority field.'}}]","The function parse_uri implements logic to set and interpret default ports based on the scheme, which is aligned with the RFC requirement that if a port is not provided, the default port may be assumed. However, beyond managing default port assignment for websocket schemes, the function does not handle other aspects of the full HTTP RFC or the broader context described (such as handling of intermediary information, comments, or pseudonyms for sensitive host data). Therefore, while the default port behavior is implemented, only part of the overall spec is covered by this function alone.",success,
18799,h2_session_on_header,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (namelen == 7 && !strncmp("":status"", (const char *)name, namelen)) {\n    stream->http_status = 0;\n    if (valuelen < 10) {\n        char tmp[10], *endp;\n        memcpy(tmp, value, valuelen);\n        tmp[valuelen] = 0;\n        stream->http_status = (int)strtol(tmp, &endp, 10);\n    }\n    if (stream->http_status < 100 || stream->http_status >= 600) {\n        log_errf(""on header recv"", ""stream=%d, invalid :status: %.*s"",\n                 frame->hd.stream_id, (int)valuelen, value);\n        return NGHTTP2_ERR_CALLBACK_FAILURE;\n    } else {\n        fprintf(stdout, ""[%d] :status: %d\\n"", stream->id, stream->http_status);\n    }\n}', 'explanation': ""This segment handles the interpretation of the ':status' header as per the RFC requirement to interpret a received protocol element according to its defined semantics. It converts the header's value to an integer and verifies that it falls within the valid HTTP status code range (100-599).""}}]","The function partially matches the RFC specification. It shows an attempt to interpret a critical header element (':status') by extracting its value, converting it to an integer, and validating the range of acceptable HTTP status codes. This reflects a direct implementation of the requirement to interpret protocol elements. However, the RFC implies a broader mandate (including support for extensions and error recovery strategies) that is not fully addressed in this isolated function. Therefore, while a key aspect is implemented, the function does not cover the full scope of the specification as described in the context.",success,
18799,h2_session_on_header,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (valuelen < 10) {\n    char tmp[10], *endp;\n    memcpy(tmp, value, valuelen);\n    tmp[valuelen] = 0;\n    stream->http_status = (int)strtol(tmp, &endp, 10);\n}', 'explanation': ""This segment shows an attempt at defensive parsing by checking that the length of the header value is less than the fixed buffer size (10), copying it safely into a temporary buffer, and null‐terminating it before conversion. This helps prevent buffer overflows and partially conforms to the expectation of parsing 'defensively' as described in the spec.""}}, {'A1': {'code': 'if (stream->http_status < 100 || stream->http_status >= 600) {\n    log_errf(""on header recv"", ""stream=%d, invalid :status: %.*s"",\n             frame->hd.stream_id, (int)valuelen, value);\n    return NGHTTP2_ERR_CALLBACK_FAILURE;\n}', 'explanation': 'This segment verifies that the converted HTTP status code falls within a reasonable range (100-599). It logs an error and returns a failure code if the value is outside the acceptable range, which is an actionable defensive measure.'}}]","The function implements a degree of defensive parsing for the :status header from an HTTP/2 frame, checking the length of the header value to avoid overflows and validating the parsed value against a sensible range. However, this defensive parsing is limited to this particular header element and does not comprehensively cover all aspects (such as full ABNF grammar parsing or handling varying buffer sizes) that might be expected under the RFC spec. Therefore, while some conditions (C1) and actions (A1) are addressed, it only partially meets the overall requirements of the RFC specification.",success,
18799,h2_session_on_header,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The function h2_session_on_header processes received header fields by logging them and, in the case of a "":status"" header, validating its numeric value against a range. However, none of the code within the function implements any logic to ensure that a sender does not generate protocol elements or syntax alternatives that are reserved for other roles, as mandated by the RFC specification. It does not include checks to confirm or enforce that the appropriate role is used when generating protocol elements, nor does it validate against the sender’s permitted elements. Thus, this function does not conform to the specific condition stated in the RFC regarding sender role-based generation of protocol elements.",success,
18804,h2_session_ev,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Does Not Match,[],"The function simply checks for poll events and either calls session I/O or logs an error and returns -1 for hangup and error events. It does not implement any logic to sustain persistent connections or to allow the underlying transport's flow-control mechanisms to resolve temporary overloads as required by the specification. In particular, there is no explicit handling for keeping idle connections alive or for delaying termination in favor of flow-control, so none of the labeled spec constraints are visibly addressed within this function.",success,
18815,main,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC specification requires that within a given message the sender must not generate protocol elements or syntax alternatives that are reserved for other roles. The function_body provided only constructs and sends HTTP/2 CONNECT messages with various header scenarios based on the command line parameters. It does not contain any logic that verifies or enforces that the protocol elements being generated are strictly those allowed for the sender’s role. There is no code to check for or filter out elements that are exclusively allowed for other roles. Therefore, the function does not visibly address the RFC constraint directly by itself.",success,
18815,main,"A sender MUST NOT generate an ""https"" URI with an empty host identifier.",225,Does Not Match,[],"The RFC requires that a sender MUST NOT generate an ""https"" URI with an empty host identifier. In the provided function_body, while the URI is parsed and logged, there is no explicit check or validation to ensure that when the scheme is ""https"", the host identifier is non-empty. The function simply assigns host from the parsed URI (or command-line argument) without verifying its presence when the scheme is https. Thus, the function does not visibly address or implement the spec constraint concerning an empty host identifier for https URIs.",success,
18815,main,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function constructs an array of header (or pseudo-header) fields based on the scenario and then submits them via a ws_stream_submit call. However, it does not implement any logic that checks or enforces the HTTP RFC requirement regarding duplicate header fields or the preservation of their order. There is no evidence in the function's code of any mechanism to avoid generating multiple field lines with the same name, nor is there any logic to handle the order of header fields. Thus, the function does not visibly address the required constraints (e.g., conditions like C1 or actions like A1) specified by the RFC.",success,
18815,main,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Does Not Match,[],"The RFC specification requires that the sender must not generate an ""http"" URI with an empty host identifier. In this function, while the URI is parsed and later used, there is no explicit check or logic to ensure that the host identifier is not empty. The code simply assigns host from argv via parse_host_port or falls back to the parsed URI's host with ""if (!host) { host = uri.host; ... }"" without verifying that uri.host is non-empty. Therefore, the function does not visibly address the constraint within its own logic.",success,
18815,main,A sender SHOULD limit generated product identifiers to what is necessary to identify the product; a sender MUST NOT generate advertising or other nonessential information within the product identifier.,274,Fully Matches,"[{'C1': {'code': 'MAKE_NV(""user-agent"", ""mod_h2/h2ws-test"")', 'explanation': 'The code hard-codes a minimal User-Agent value that clearly identifies the product without extra details. This meets the RFC requirement that a sender SHOULD limit generated product identifiers to what is necessary.'}}, {'A1': {'code': 'MAKE_NV(""user-agent"", ""mod_h2/h2ws-test"")', 'explanation': 'By using a fixed minimal string, the code ensures that no advertising or nonessential information is added to the product identifier, complying with the mandate that a sender MUST NOT generate such information.'}}]","Within the function, the User-Agent header is constructed as one of the nghttp2_nv array elements using the static string ""mod_h2/h2ws-test"". This value is a concise product identifier with no extra, nonessential or advertising details. Therefore, the function itself visibly addresses both constraints – limiting the product identifier to necessary details (C1) and excluding nonessential information (A1) – fully matching the RFC specification as interpreted by the provided conditions and actions.",success,
18815,main,"Note that the coding named ""identity"" is reserved for its special role in Accept-Encoding and thus SHOULD NOT be included.",38,Does Not Match,[],"The provided code function does not contain any logic that handles Content-Encoding as specified by the RFC. The RFC requires that if content codings (like gzip) are applied then a Content-Encoding header must be generated listing them (and ensure that the special ""identity"" coding is not included). This function only constructs HTTP/2 header arrays for various websocket scenarios and does not address any Content-Encoding headers, so it does not implement any of the spec constraints related to Content-Encoding.",success,
18823,START_TEST,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Fully Matches,"[{'C1': {'code': 'status = ap_pbase64decode_strict(g_pool, invalid_padding[_i], &decoded, &len);\nck_assert_int_eq(status, APR_EINVAL);', 'explanation': 'This code verifies that when a protocol element (in this case, a base64 encoded string with incorrect padding) is processed, it is recognized as invalid and the function returns an error. This behavior aligns with the RFC requirement that a recipient must interpret protocol elements per the specification and reject them if the sender is incorrectly implementing the semantics.'}}, {'A1': {'code': 'ck_assert(decoded == NULL);\nck_assert_uint_eq(len, (apr_size_t) -1);', 'explanation': 'These assertions ensure that no decoded output is produced and that the length remains unchanged when invalid input is provided, which matches the action of handling an invalid protocol element by not producing a usable result.'}}]","The function_body tests the strict base64 decoding behavior by intentionally using an invalid padding scenario. It checks that the decoding function detects the error (returning APR_EINVAL) and does not output any decoded data, directly implementing the RFC’s mandate to interpret received protocol elements according to specification and to reject them if they are invalid. All behaviors related to the labeled constraints (C1 and A1) are implemented within this function, so it fully matches the intended requirements.",success,
18823,START_TEST,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'status = ap_pbase64decode_strict(g_pool, invalid_padding[_i], &decoded, &len);\nck_assert_int_eq(status, APR_EINVAL);', 'explanation': 'This segment calls the strict decoder with an input known to have invalid padding and asserts that an error (APR_EINVAL) is returned. It demonstrates defensive parsing by ensuring that the parser does not accept malformed protocol elements.'}}, {'A1': {'code': 'ck_assert(decoded == NULL);\nck_assert_uint_eq(len, (apr_size_t) -1);', 'explanation': 'These assertions verify that no decoded output is produced and that the output length remains unchanged after encountering invalid input. This confirms that the function refrains from processing the protocol element further, aligning with a defensive approach.'}}]","The function_body implements a defensive parsing check for a specific error case – incorrect padding in a base64 encoded element. It explicitly tests for error status and that no output is generated, which aligns with the spec's guidance to defensively parse received protocol elements. However, it addresses only this specific aspect rather than all possible defensive considerations laid out in the full HTTP RFC guidance. Hence, it partially matches the spec constraints.",success,
18844,set_nonce_lifetime,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'lifetime = strtol(t, &endptr, 10);\nif (endptr < (t+strlen(t)) && !apr_isspace(*endptr)) {\n    return apr_pstrcat(cmd->pool, ""Invalid time in AuthDigestNonceLifetime: "", t, NULL);\n}', 'explanation': 'This segment implements a defensive parsing check by converting the input string to a number using strtol and then verifying that any non‐numeric trailing characters are only whitespace. This aligns with the requirement to parse the protocol element defensively with only marginal expectations regarding its conformance.'}}, {'A1': {'code': 'return apr_pstrcat(cmd->pool, ""Invalid time in AuthDigestNonceLifetime: "", t, NULL);', 'explanation': 'This part of the code returns an error message if the input does not fully match the expected numeric format, fulfilling the action of notifying when the protocol element is not valid.'}}]","The function shows an attempt to implement defensive parsing as required by the RFC: it uses strtol to parse the input and checks that any extra characters following the numeric part are acceptable (whitespace). However, it does not address all aspects mentioned in the RFC context (such as verifying that the protocol element fits within a 'reasonable buffer size'), so while it visibly implements some defensive measures (C1 and A1), it does not fully cover every nuance of the specification.",success,
18844,set_nonce_lifetime,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The provided function 'set_nonce_lifetime' solely handles parsing and validating a numerical value for a nonce lifetime. It parses the input string to a long integer, verifies proper termination, and then assigns the value, converting seconds to the appropriate time format. There is no visible logic in this function addressing the RFC specification constraint which prohibits generating protocol elements or syntax alternatives only allowed to participants in other roles. The function does not perform any checks, modifications, or decisions based on role-based protocol element generation. Hence, it does not meet any of the labeled conditions or actions from the RFC spec.",success,
18853,get_digest_rec,Any content known to be defined as BWS MAY be removed before interpreting it or forwarding the message downstream.,241,Fully Matches,"[{'C1': {'code': 'while (apr_isspace(auth_line[0])) {\n    auth_line++;\n}\n\n/* ... also similar whitespace skipping in key and value parsing */', 'explanation': 'The RFC specifies that any Bad Whitespace (BWS) encountered must be removed before interpreting protocol elements. This code repeatedly checks for whitespace (using apr_isspace) and advances the pointer (auth_line++) to effectively remove any such whitespace before further processing. This directly implements the requirement that BWS may be removed.'}}, {'A1': {'code': 'resp->scheme = ap_getword_white(r->pool, &auth_line);', 'explanation': ""The function uses 'ap_getword_white', which extracts a word from the input header while ignoring leading whitespace. This aligns with the RFC action where the protocol element is processed only after BWS is removed.""}}]","The function 'get_digest_rec' parses the authentication header and explicitly removes extraneous whitespace by using loops that skip over any whitespace characters. By doing so before it interprets keys and values from the header, the function implements the specified HTTP RFC regarding the removal of BWS. All relevant whitespace removal steps are performed within 'function_body', making it a self-contained implementation that fully matches the RFC's constraints.",success,
18853,get_digest_rec,Recipients that process the value of a quoted-string MUST handle a quoted-pair as if it were replaced by the octet following the backslash.,242,Fully Matches,"[{'C1': {'code': 'if (auth_line[0] == \'""\') {         /* quoted string */\n    auth_line++;\n    while (auth_line[0] != \'""\' && auth_line[0] != \'\\0\') {\n        if (auth_line[0] == \'\\\\\' && auth_line[1] != \'\\0\') {\n            auth_line++;            /* escaped char */\n        }\n        value[vv++] = *auth_line++;\n    }\n    if (auth_line[0] != \'\\0\') {\n        auth_line++;\n    }\n}', 'explanation': 'This segment of code processes a quoted-string. When it encounters a backslash within the quoted-string (i.e. a potential quoted-pair), it skips the backslash and takes the following character (thereby replacing the quoted-pair with the octet following the backslash) which is exactly what the RFC requires.'}}]","The function explicitly handles the quoted-pair scenario within a quoted-string by checking for a backslash followed by another character and then replacing the backslash sequence with the following character. This properly implements the behavior mandated by the RFC for processing quoted-pairs, and thus the function fully matches the specified constraint.",success,
18853,get_digest_rec,A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.,240,Fully Matches,"[{'C1': {'code': 'while (apr_isspace(auth_line[0])) { auth_line++; }', 'explanation': 'The function repeatedly uses loops (e.g., before parsing the scheme, keys, and values) to skip over any whitespace characters. This directly implements the RFC requirement that a recipient must parse for bad whitespace and remove it before interpreting the protocol element.'}}]","The provided function explicitly checks for and skips over whitespace in several key locations (for example, before and after reading header elements). These loops ensure that any extraneous or bad whitespace is effectively removed before further processing occurs. Since this logic is contained completely within the function itself (and not delegated to a dependency), the function fully meets the RFC specification regarding the handling of bad whitespace.",success,
18853,get_digest_rec,"When a specific version of HTTP allows such whitespace to appear in a message, a field parsing implementation MUST exclude such whitespace prior to evaluating the field value.",234,Fully Matches,"[{'C1': {'code': ""while (apr_isspace(auth_line[0])) {\n    auth_line++;\n}\n\n... // similar loops before reading key and value\n\nif (auth_line[0] == '=') {\n    auth_line++;\n    while (apr_isspace(auth_line[0])) {\n        auth_line++;\n    }\n    // then token or quoted string parsing follows"", 'explanation': 'The RFC requires that any leading or trailing whitespace be excluded before evaluating a field’s value. In the function, before both key and value extraction, there are explicit loops (using apr_isspace) that skip whitespace. This ensures that any whitespace permitted by the HTTP version is not considered part of the parsed field value.'}}]","The provided function implements the necessary trimming of whitespace by advancing the pointer past any whitespace characters before parsing the key and value parts. This behavior directly addresses the RFC specification requirement to exclude such whitespace before evaluating the field value. All relevant code to strip the whitespace is located within the function_body, making the function fully match the specified constraint.",success,
18859,note_digest_auth_failure,"For historical reasons, a sender MUST only generate the quoted-string syntax.",277,Partially Matches,"[{'C1': {'code': 'apr_psprintf(r->pool, ""Digest realm=\\""%s\\"", nonce=\\""%s\\"", algorithm=%s%s%s%s%s"", ap_auth_name(r), nonce, conf->algorithm, opaque_param ? opaque_param : """", domain ? domain : """", stale ? "", stale=true"" : """", qop)', 'explanation': ""The RFC requires that the sender MUST generate header values using quoted-string syntax. The code encloses values for 'realm', 'nonce', 'qop', and 'opaque' in quotes. However, the 'algorithm' parameter is output without quotes. This means while most parts of the spec are addressed, the implementation is not fully compliant because not all values are rendered as quoted-strings.""}}]","The function attempts to implement the RFC constraint by quoting several parameter values in the WWW-Authenticate header. Although it meets the quoted-string requirement for 'realm', 'nonce', 'qop', and 'opaque', the 'algorithm' field is not generated as a quoted-string. Since the spec mandates that only quoted-string syntax be used, this omission results in a partial match.",success,
18859,note_digest_auth_failure,A server MAY generate a WWW-Authenticate header field in other response messages to indicate that supplying credentials (or different credentials) might affect the response.,93,Fully Matches,"[{'C1': {'code': 'apr_table_mergen(r->err_headers_out,\n                 (PROXYREQ_PROXY == r->proxyreq)\n                         ? ""Proxy-Authenticate"" : ""WWW-Authenticate"",\n                 apr_psprintf(r->pool, ""Digest realm=\\""%s\\"", nonce=\\""%s\\"", algorithm=%s%s%s%s%s"",\n                                  ap_auth_name(r), nonce, conf->algorithm,\n                                  opaque_param ? opaque_param : """",\n                                  domain ? domain : """",\n                                  stale ? "", stale=true"" : """", qop));', 'explanation': 'This segment assembles and adds a WWW-Authenticate (or Proxy-Authenticate) header with the digest authentication parameters, directly addressing the spec requirement that the server may provide a challenge header to indicate that supplying (or changing) credentials might affect the response.'}}, {'A1': {'code': 'if (r->proxyreq || !conf->uri_list) {\n        domain = NULL;\n    } else {\n        domain = conf->uri_list;\n    }', 'explanation': ""This code chooses whether to include the domain attribute in the authentication challenge, ensuring that for non-proxy requests and when a URI list has been specified, the 'domain' attribute is sent. This aligns with the aim of reducing unnecessary client header size and informing the client of the applicable authentication realm.""}}]","The function 'note_digest_auth_failure' internally builds a Digest authentication challenge by generating values such as realm, nonce, opaque, stale flag, qop, and optionally the domain. It then adds this as a WWW-Authenticate (or Proxy-Authenticate) header field to the error headers. This behavior directly reflects the RFC specification that a server MAY include a WWW-Authenticate header in responses, thereby fully matching the provided constraints.",success,
18859,note_digest_auth_failure,The server generating a 401 response MUST send a WWW-Authenticate header field (Section 11.6.1) containing at least one challenge applicable to the target resource.,162,Fully Matches,"[{'C1': {'code': 'apr_table_mergen(r->err_headers_out,\n                     (PROXYREQ_PROXY == r->proxyreq)\n                         ? ""Proxy-Authenticate"" : ""WWW-Authenticate"",\n                     apr_psprintf(r->pool, ""Digest realm=\\""%s\\"", ""\n                                  ""nonce=\\""%s\\"", algorithm=%s%s%s%s%s"",\n                                  ap_auth_name(r), nonce, conf->algorithm,\n                                  opaque_param ? opaque_param : """",\n                                  domain ? domain : """",\n                                  stale ? "", stale=true"" : """", qop));', 'explanation': ""This code segment creates and sends an authentication challenge by setting the 'WWW-Authenticate' header (or 'Proxy-Authenticate' for proxy requests) with all necessary parameters (realm, nonce, algorithm, opaque, domain, stale, and qop) to prompt the client for credentials, thereby directly addressing the RFC requirement.""}}]","The 'note_digest_auth_failure' function visibly constructs a Digest authentication challenge and injects it into the error header output via a call to apr_table_mergen. By building the header string with all required parameters (realm, nonce, etc.) and sending it as the WWW-Authenticate header, the function ensures that a 401 response contains the appropriate challenge as mandated by the HTTP RFC. Thus, in isolation, this function meets the specified constraint.",success,
18859,note_digest_auth_failure,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Partially Matches,"[{'C1': {'code': 'apr_table_mergen(r->err_headers_out,\n                     (PROXYREQ_PROXY == r->proxyreq)\n                         ? ""Proxy-Authenticate"" : ""WWW-Authenticate"",\n                     apr_psprintf(r->pool, ""Digest realm=\\""%s\\"", \n                                  nonce=\\""%s\\"", algorithm=%s%s%s%s%s"",\n                                  ap_auth_name(r), nonce, conf->algorithm,\n                                  opaque_param ? opaque_param : """",\n                                  domain ? domain : """",\n                                  stale ? "", stale=true"" : """", qop));', 'explanation': 'This segment makes a single header entry by merging any existing header of the same name. It uses apr_table_mergen to combine multiple values as a comma-separated string, thereby addressing the condition that a sender MUST NOT generate multiple field lines with the same name unless allowed.'}}]","The function constructs the Digest authentication header and uses the table merge function (apr_table_mergen) to ensure that if a header already exists, its value is merged rather than new separate header lines being created. This directly addresses the RFC's requirement regarding the handling of multiple header fields with the same name. However, aside from merging functionality, the function does not provide additional logic to handle all nuances of field line ordering or specify conditions under which multiple values may be allowed. Therefore, the function partially matches the spec constraints.",success,
18863,check_nonce,"A recipient SHOULD parse a received protocol element defensively, with only marginal expectations that the element will conform to its ABNF grammar and fit within a reasonable buffer size.",217,Partially Matches,"[{'C1': {'code': 'if (strlen(resp->nonce) != NONCE_LEN\n        || resp->nonce[NONCE_TIME_LEN - 1] != \'=\') {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01775)\n                  ""invalid nonce \'%s\' received - length is not %d ""\n                  ""or time encoding is incorrect"",\n                  resp->nonce, NONCE_LEN);\n    note_digest_auth_failure(r, conf, resp, 1);\n    return HTTP_UNAUTHORIZED;\n}', 'explanation': ""This conditional block checks the nonce’s length and its expected formatting (by ensuring that the time encoding portion ends with '='), which is a defensive parsing measure in line with the RFC’s guidance to not assume perfect conformance to an ABNF grammar.""}}, {'A1': {'code': 'if (strcmp(hash, resp->nonce+NONCE_TIME_LEN)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01776)\n                  ""invalid nonce %s received - hash is not %s"",\n                  resp->nonce, hash);\n    note_digest_auth_failure(r, conf, resp, 1);\n    return HTTP_UNAUTHORIZED;\n}', 'explanation': 'This segment actively implements an action upon detecting a nonce that fails validation (hash mismatch): it logs an error, records the failure, and rejects the request, which is a key response action as specified.'}}]","The function shows an attempt to enforce defensive parsing by checking the length and format of the nonce, and by verifying its integrity using a generated hash. These checks are implemented to avoid assumptions about the nonce conforming completely to an expected grammar. However, the function only addresses the nonce element and does not cover all possible protocol element parsing, which is why the overall implementation is considered a partial match to the full RFC requirement.",success,
18863,check_nonce,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Partially Matches,"[{'C1': {'code': 'if (strlen(resp->nonce) != NONCE_LEN || resp->nonce[NONCE_TIME_LEN - 1] != \'=\') {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01775)\n                  ""invalid nonce \'%s\' received - length is not %d or time encoding is incorrect"",\n                  resp->nonce, NONCE_LEN);\n    note_digest_auth_failure(r, conf, resp, 1);\n    return HTTP_UNAUTHORIZED;\n}', 'explanation': ""This segment ensures that the nonce received conforms to the expected format (proper length and ending with '=' for a base64 encoding). In doing so, it is attempting to interpret the protocol element according to its defined semantics.""}}, {'A1': {'code': 'if (strcmp(hash, resp->nonce+NONCE_TIME_LEN)) {\n    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01776)\n                  ""invalid nonce %s received - hash is not %s"",\n                  resp->nonce, hash);\n    note_digest_auth_failure(r, conf, resp, 1);\n    return HTTP_UNAUTHORIZED;\n}', 'explanation': 'This segment verifies the integrity of the nonce by computing and then comparing a generated hash with the hash part of the received nonce. It rejects the request if the validation fails, thereby enforcing the semantic correctness of the protocol element.'}}]","The function check_nonce incorporates multiple internal checks that interpret a received nonce according to its expected semantics. It validates the format, decodes a time stamp, verifies a computed hash against that provided in the nonce, and further examines timing constraints (e.g., expiration and even detecting 'time travel'). These measures show that the function addresses key aspects of interpreting a protocol element as specified in the RFC. However, while several conditions and actions (such as those mapped to C1 and A1) are fully addressed, the function does not cover the full range of error recovery or alternative interpretations that might be specified elsewhere in the RFC. Therefore, in isolation, the function only partially matches the complete intent of the specification.",success,
18866,copy_uri_components,"A sender MUST NOT generate an ""http"" URI with an empty host identifier.",223,Fully Matches,"[{'C1': {'code': ""if (src->hostname && src->hostname[0] != '\\0') {\n    dst->hostname = apr_pstrdup(r->pool, src->hostname);\n    ap_unescape_url(dst->hostname);\n}\nelse {\n    dst->hostname = (char *) ap_get_server_name(r);\n}"", 'explanation': 'This code checks if the source hostname is non-empty; if it is empty, it falls back to using the server name from the request, ensuring that the generated HTTP URI always has a non-empty host identifier.'}}]","The provided function implements the RFC requirement by ensuring that the 'hostname' field is never left empty. It first attempts to use the source hostname if available; otherwise, it substitutes it with the value returned by ap_get_server_name, thereby fully meeting the condition that a sender MUST NOT generate an HTTP URI with an empty host identifier.",success,
18866,copy_uri_components,"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default port, if any, for the received-protocol.",254,Fully Matches,"[{'C1': {'code': ""if (src->port_str && src->port_str[0] != '\\0') {\n    dst->port = src->port;\n}\nelse {\n    dst->port = ap_get_server_port(r);\n}"", 'explanation': 'This code explicitly checks if a port string is provided. If it is absent or empty, it defaults to using the server port (via ap_get_server_port), which implements the RFC condition that if a port is not provided, the default port for the received-protocol is assumed.'}}]","The provided function_body includes logic to handle the situation where a port is not supplied by checking the src->port_str field. If the port string is empty, the function sets the destination port to the server's default port. This behavior matches the RFC specification that stipulates a recipient may interpret a missing port as received on the default port for the protocol.",success,
18867,authenticate_digest_user,"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics.",219,Fully Matches,"[{'C1': {'code': 'if (!(t = ap_auth_type(r)) || ap_cstr_casecmp(t, ""Digest"")) {\n    return DECLINED;\n}\n...\nif (!ap_auth_name(r)) {\n    ap_log_rerror(... ""need AuthName: %s"", r->uri);\n    return HTTP_INTERNAL_SERVER_ERROR;\n}\n...\nif (!resp->realm || strcmp(resp->realm, realm)) {\n    ap_log_rerror(... ""realm mismatch - got `%s\' but expected `%s\'"", resp->realm, realm);\n    note_digest_auth_failure(r, conf, resp, 0);\n    return HTTP_UNAUTHORIZED;\n}\n', 'explanation': 'This segment ensures that the function only processes Digest authentication and correctly interprets the protocol element by validating required fields such as the authentication type and realm. This corresponds to the RFC mandate that a recipient must interpret the received protocol element according to its defined semantics.'}}, {'A1': {'code': 'if (resp->auth_hdr_sts != VALID) {\n    if (resp->auth_hdr_sts == NOT_DIGEST) {\n        ap_log_rerror(... ""client used wrong authentication scheme `%s\': %s"", resp->scheme, r->uri);\n    }\n    else if (resp->auth_hdr_sts == INVALID) {\n        ap_log_rerror(... ""missing user, realm, nonce, uri, digest, cnonce, or nonce_count in authorization header: %s"", r->uri);\n    }\n    note_digest_auth_failure(r, conf, resp, 0);\n    return HTTP_UNAUTHORIZED;\n}\n...', 'explanation': 'This block handles the situation when the incoming authorization header does not meet the required semantics (i.e. missing or wrongly specified fields) by logging the error, attempting to recover with a failure note, and returning an error code. This is in line with the RFC requirement to attempt to recover a usable protocol element from an invalid construct.'}}]","The function implements the key aspects of the RFC by first verifying the use of Digest authentication and ensuring that essential protocol elements (such as AuthName, realm, nonce, digest, etc.) are present and valid. When discrepancies or errors are encountered it logs the failure and responds with the appropriate error status. This direct and self-contained logic within the function meets the specified conditions (C1) and actions (A1) as required by the RFC.",success,
18870,mod_auth_digest_setup,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The provided function only sets up memory pools and initializes a header table in a request structure. There is no logic in this function that addresses or enforces the rules specified by the HTTP RFC regarding handling multiple header fields, their ordering, or prohibiting appending duplicate header field names. As such, none of the labeled spec conditions or actions (e.g., C1, A1) are implemented within this function.",success,
18902,h2test_echo_handler,A recipient MUST NOT merge a received trailer field into the header section unless its corresponding header field definition explicitly permits and instructs how the trailer field value can be safely merged.,207,Fully Matches,"[{'C1': {'code': 'if (r->trailers_in && !apr_is_empty_table(r->trailers_in)) {\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                  ""echo_handler: seeing incoming trailers"");\n    apr_table_setn(r->trailers_out, ""h2test-trailers-in"", \n                   apr_itoa(r->pool, 1));\n}', 'explanation': 'The specification requires that a recipient must not merge a received trailer field into the header section unless explicitly permitted. In this code, if there are any incoming trailers (r->trailers_in), the function logs the event and adds an entry to r->trailers_out rather than merging the trailer into the header (i.e. r->headers_out). This separate handling of trailer fields satisfies the RFC requirement.'}}]","The function demonstrates proper handling of HTTP trailer fields by detecting them in r->trailers_in and then storing an indication of their presence in the separate trailers_out table. No merging into the header section occurs, which aligns with the mandate from the RFC. Therefore, the code function fully matches the specified RFC constraint.",success,
18902,h2test_echo_handler,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'r->clength = -1;\n r->chunked = 1;\n apr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'The function explicitly disables the Content-Length header by setting r->clength to -1, enabling chunked transfer encoding via r->chunked = 1, and unsetting the Content-Length header in the outgoing headers. This directly ensures that when Transfer-Encoding (chunked) is used, the Content-Length header is not sent, fully meeting the RFC requirement.'}}]","The provided code function correctly implements the RFC specification by ensuring that the Content-Length header is not present when chunked transfer encoding is used. The logic that sets r->chunked to 1, resets the Content-Length (r->clength = -1), and removes the header from r->headers_out addresses the requirement that a message with a Transfer-Encoding header must not include a Content-Length header field. Therefore, the function fully matches the specified constraint.",success,
18902,h2test_echo_handler,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Partially Matches,"[{'C1': {'code': 'if (r->trailers_in && !apr_is_empty_table(r->trailers_in)) {\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, ""echo_handler: seeing incoming trailers"");\n    apr_table_setn(r->trailers_out, ""h2test-trailers-in"", apr_itoa(r->pool, 1));\n}', 'explanation': ""This segment checks for the presence of incoming trailer fields and, instead of merging them into the header section, it sets them into the outgoing trailer table. In doing so, it avoids merging trailer fields into the header, which follows the specification's requirement not to merge trailers unless it is safe to do so. However, it does not perform any further validation to determine if the trailer field is explicitly permitted to be merged, which is why the implementation only partially matches the RFC.""}}]","The function demonstrates partial compliance with the RFC requirement by detecting trailer fields and ensuring that they are kept in the trailer section rather than being merged into the header section. It avoids unsafe merging by not transferring trailer fields into headers, but it does not explicitly check whether the header definition permits merging or defines how to safely merge trailer values. As such, while the function correctly avoids merging by default, it does not implement the full validation logic required by the RFC.",success,
18902,h2test_echo_handler,"Because of the potential for trailer fields to be discarded in transit, a server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive.",12,Does Not Match,[],"The RFC specification states that a server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive. In the function, there is logic that unconditionally sets a trailer header (""h2test-trailers-in"") in r->trailers_out when any incoming trailers are detected (see the block starting with 'if (r->trailers_in && !apr_is_empty_table(r->trailers_in)) { ... }'). There is no check to determine whether the trailer field is absolutely necessary for the client's processing or if its omission would be tolerable. Therefore, the function does not implement the specification constraint within its own logic, as it does not make an attempt to avoid generating trailer fields that might be essential for proper client operation.",success,
18902,h2test_echo_handler,"Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",308,Does Not Match,[],"The RFC specification requires that future registrations of transfer codings should not define parameters called 'q' (case-insensitively), to avoid ambiguities. The function h2test_echo_handler does not contain any logic addressing or checking for a 'q' parameter since it only processes parameters such as 'id', 'chunk_delay', and 'fail_after'. There is no code segment within this function that implements any constraint related to the parameter 'q'. Therefore, the function does not visibly address the specified RFC constraint.",success,
18902,h2test_echo_handler,"Likewise, a sender MUST NOT forward a message with a Content-Length header field value that does not match the ABNF above, with one exception: a recipient of a Content-Length header field value consisting of the same decimal value repeated as a comma-separated list (e.g, ""Content-Length: 42, 42"") MAY either reject the message as invalid or replace that invalid field value with a single instance of the decimal value, since this likely indicates that a duplicate was generated or combined by an upstream message processor.",49,Does Not Match,[],"The provided function does not contain any logic that validates or checks the Content-Length header field against an ABNF or duplicate values as specified. The code simply unsets the Content-Length header (r->clength is set to -1 and 'Content-Length' is removed from headers_out) without any reference to ensuring that the header matches the required format or handling the exception for duplicate values in a comma-separated list. Therefore, it does not visibly implement any of the labeled spec constraints.",success,
18902,h2test_echo_handler,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Fully Matches,"[{'A1': {'code': 'r->clength = -1;\n...\napr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'The function deliberately clears any outgoing Content-Length header and sets the request length to -1, thereby ensuring that no potentially incorrect Content-Length value is forwarded. This directly addresses the RFC requirement that a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.'}}]","The provided code function forces the use of chunked encoding by unsetting the Content-Length header and setting r->clength to -1. In doing so, it guarantees that any invalid or incorrect Content-Length header from the incoming message will not be forwarded. This in-function logic fully meets the spec requirement per the provided constraints without relying on external callers or dependencies.",success,
18902,h2test_echo_handler,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Does Not Match,[],"The RFC requires the server must NOT send a Content-Length header for responses with status 1xx or 204. In this function, the response status is explicitly set to 200 and the Content-Length header is unconditionally removed with apr_table_unset. There is no logic to detect or conditionally handle a response with a status of 1xx or 204, so the function does not attempt to implement the specific HTTP RFC requirement.",success,
18903,h2test_delay_handler,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'r->clength = -1;\nr->chunked = 1;\napr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'These lines ensure that when chunked transfer encoding is used (r->chunked = 1), the Content-Length header is removed (apr_table_unset on ""Content-Length"") and the content length is set to -1, thus preventing a Content-Length header from being sent in a message that uses Transfer-Encoding.'}}]","The RFC specifies that a sender must not include a Content-Length header if the message is using a Transfer-Encoding header. Within the function, after verifying the handler and method, the code sets r->chunked = 1 to enable chunked transfer encoding, resets the content length with r->clength = -1, and then explicitly unsets any Content-Length header via apr_table_unset. This directly satisfies the RFC specification within the function_body itself.",success,
18903,h2test_delay_handler,"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT",71,Does Not Match,[],"The provided function does not implement any logic that selects a proper URI on behalf of the client after receiving a state-changing request. The RFC specifies that the service should use the POST method (rather than PUT) when performing this operation, and additional rules such as responding with 3xx redirection when the desired state change should be applied to a different resource. In the function_body, the only related check is that it accepts only GET and POST methods (declining other methods, including PUT), but there is no further logic that selects a URI, redirects the request, or otherwise implements the detailed behavior described in the RFC. Thus, no labeled constraints (e.g., C1, A1) from the spec constraints are fully implemented in this function.",success,
18903,h2test_delay_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'A1': {'code': 'ap_set_content_type(r, ""application/octet-stream"");', 'explanation': 'The RFC specifies that a sender generating a message containing content SHOULD include a Content-Type header field. This function always sets a Content-Type header by calling ap_set_content_type(), thereby ensuring the header is present in the generated message.'}}]","The function generates response content (by writing chunks of data to the brigade) and explicitly sets a Content-Type header via ap_set_content_type(). This directly addresses the RFC requirement for including a Content-Type header in messages that include content. Although the chosen media type is 'application/octet-stream' (and not the text/html suggested by the sr_context), the obligation of providing the header is met by the function itself, thus it is considered to fully match the specified requirement.",success,
18903,h2test_delay_handler,"If one or more encodings have been applied to a representation, the sender that applied the encodings MUST generate a Content-Encoding header field that lists the content codings in the order in which they were applied.",37,Does Not Match,[],"The RFC specifies that if one or more encodings have been applied to a representation, the sender MUST generate a Content-Encoding header listing the codings in the order applied. In this function, instead of generating such a header, the code explicitly removes the header (using apr_table_unset on ""Content-Encoding"") and sets environment flags (""no-gzip"" and ""no-brotli"") to discourage encoding. As a result, the function does not implement the requirement of listing applied encodings; it actively prevents content-encoding, and therefore does not address the RFC constraint.",success,
18903,h2test_delay_handler,"Likewise, a sender MUST NOT forward a message with a Content-Length header field value that does not match the ABNF above, with one exception: a recipient of a Content-Length header field value consisting of the same decimal value repeated as a comma-separated list (e.g, ""Content-Length: 42, 42"") MAY either reject the message as invalid or replace that invalid field value with a single instance of the decimal value, since this likely indicates that a duplicate was generated or combined by an upstream message processor.",49,Does Not Match,[],"The RFC requires that a sender must not forward a message with an incorrect Content-Length header value and must handle cases where duplicate, comma‐separated values appear by either rejecting the message or correcting the header. In function_body, there is no logic handling verification of the Content-Length value or addressing the case of duplicate Content-Length header values. The function instead unsets the Content-Length header and opts for chunked transfer encoding. Therefore, no part of the function directly implements the RFC constraint regarding Content-Length header validation as specified.",success,
18903,h2test_delay_handler,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'A1': {'code': 'r->clength = -1;\n...\napr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'The function explicitly removes the Content-Length header from the response and sets the clength to -1 while using chunked encoding. This prevents the forwarding of a potentially incorrect Content-Length header, which aligns with the RFC requirement that a sender MUST NOT forward a message with an incorrect Content-Length. However, it does not validate any incoming Content-Length header for correctness or handle the special case of duplicated valid values, so it only partially addresses the specification.'}}]","The RFC specifies that a sender must not forward messages with an incorrect Content-Length header. In the function_body, the Content-Length header is proactively removed from the outgoing headers (via apr_table_unset) and the response is configured to use chunked transfer encoding. This approach avoids sending any potentially incorrect Content-Length header. Yet, the function does not perform any validation to determine if an incoming Content-Length is indeed incorrect or handle the exemption case for duplicate valid values. Thus, while the function takes steps to avoid forwarding an incorrect Content-Length, it only partially matches the full intention of the RFC requirement.",success,
18903,h2test_delay_handler,"If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type.",35,Partially Matches,"[{'A1': {'code': 'ap_set_content_type(r, ""application/octet-stream"");', 'explanation': ""The function unconditionally sets the Content-Type header to 'application/octet-stream', which addresses the RFC's guideline that if no Content-Type is provided, the recipient may assume this media type. This directly corresponds to the action of setting a default Content-Type as described in the spec.""}}]","The function implements a part of the RFC by explicitly setting the Content-Type to 'application/octet-stream'. However, the function does not check whether a Content-Type header is already present and does not include logic for inspecting the data (i.e., MIME sniffing) in cases where the media type is ambiguous. Thus, while it visibly addresses the default media type action (A1), it does not cover all aspects of the specification, leading to the conclusion of a partial match.",success,
18903,h2test_delay_handler,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Partially Matches,"[{'A1': {'code': 'r->clength = -1;\napr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'The function explicitly unsets the Content-Length header and resets r->clength. This shows an intention to avoid sending a Content-Length header. However, it does so unconditionally while the RFC specifically requires this only for responses with status codes 1xx or 204. Since this function sets r->status to 200, it does not fully implement the RFC constraint in the intended context.'}}]","The function shows effort to remove the Content-Length header by unsetting it and setting r->clength to -1. This matches the action of not sending a Content-Length header. However, the RFC specifies that this removal must occur in responses with a status code of 1xx or 204, while the function explicitly sets the status to 200. Thus, although part of the constraint is addressed—unsetting Content-Length—the specific condition of checking for 1xx/204 statuses is not implemented in this function. Therefore, it only partially matches the provided specification.",success,
18904,h2test_trailer_handler,"Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",308,Does Not Match,[],"The provided function does not contain any logic that addresses the RFC specification regarding transfer codings defining a parameter called 'q'. There is no code within 'h2test_trailer_handler' that checks for, prevents, or handles parameters related to 'q'. Instead, the function is focused on handling a request by setting response headers and trailers related to content length. Therefore, it does not attempt to implement the specific RFC requirement.",success,
18904,h2test_trailer_handler,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Does Not Match,[],"The RFC requires that a Content-Length header must not be sent when a message contains a Transfer-Encoding header. In the provided function_body, the code unconditionally sets a Content-Length header via 'r->clength = body_len;' and 'ap_set_content_length(r, body_len);' without any check to determine whether a Transfer-Encoding header is present. While the function does add a Trailer header and corresponding trailer content, it does not implement any logic to suppress the Content-Length header when Transfer-Encoding is used. Therefore, there is no visible code addressing the specified RFC constraint within this function.",success,
18904,h2test_trailer_handler,A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.,214,Does Not Match,[],"The spec requires that the sender must not generate protocol elements that do not match the grammar defined by the ABNF rules. This function does not include any explicit logic to validate or enforce that generated protocol elements (such as header or trailer values) conform to the ABNF grammar. It simply sets headers and trailers using helper routines (e.g., apr_table_mergen, apr_table_set) and writes a response body without any validation checks. Therefore, in isolation, this function does not visibly address the constraint (labeled as C1) of ensuring generated protocol elements match the defined grammar.",success,
18904,h2test_trailer_handler,"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",215,Does Not Match,[],"The RFC requires that a sender must not generate protocol elements or syntax alternatives that are reserved for other roles. In this function, although trailer headers are generated (using apr_table_mergen and apr_table_set), there is no explicit logic checking or enforcing that these elements conform strictly to the sender‐role grammar or that they exclude elements reserved for other roles. No part of the function visibly distinguishes between permitted sender-generated protocol elements versus those that should be generated by other participants. As a result, none of the spec’s labeled constraints (e.g., C1 for role‐based generation restrictions) are directly and fully implemented within this function.",success,
18904,h2test_trailer_handler,"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT",71,Does Not Match,[],"The RFC describes a service that, after receiving a state-changing request, should select a proper URI (implying a redirection or URI selection process) and emphasizes using POST rather than PUT for such operations. In the function_body, the only related check is that it accepts GET and POST methods and declines any other method (including PUT). However, the function does not implement any logic to select a proper URI or to send any 3xx redirection response when a PUT is received. Its primary behavior is to generate a response body with trailer headers, not to manage URI redirection based on state changes. Therefore, this code function does not visibly address the core condition or action specified in the RFC.",success,
18904,h2test_trailer_handler,A sender that intends to generate one or more trailer fields in a message SHOULD generate a Trailer header field in the header section of that message to indicate which fields might be present in the trailers.,20,Fully Matches,"[{'C1': {'code': 'apr_table_mergen(r->headers_out, ""Trailer"", ""trailer-content-length"");', 'explanation': ""This line explicitly adds a Trailer header to the response, indicating that trailer fields (in this case, 'trailer-content-length') might follow.""}}, {'A1': {'code': 'apr_table_set(r->trailers_out, ""trailer-content-length"", apr_psprintf(r->pool, ""%d"", body_len));', 'explanation': 'This code sets the actual trailer field value that will be sent at the end of the message, completing the mechanism required by the RFC.'}}]",The function directly implements the RFC requirement for a sender that intends to include trailer fields by generating a Trailer header (C1) in the header section and by setting the trailer field in the outgoing trailers (A1). Both key aspects of the specification are visibly addressed within this function's logic.,success,
18904,h2test_trailer_handler,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Does Not Match,[],"The provided function does not include any logic to verify if the Content-Length header field value is incorrect, nor does it reject or adjust a message based on an incorrect Content-Length value. It merely sets the Content-Length based on its input (r->args) and passes the response through. There is no code within this function that checks or validates the Content-Length header against the expected framing as required by the RFC, and thus it does not visibly address the spec constraint.",success,
18904,h2test_trailer_handler,"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the content size is known prior to sending the complete header section.",47,Fully Matches,"[{'C1': {'code': 'r->clength = body_len;\nap_set_content_length(r, body_len);', 'explanation': 'The RFC specifies that if the content size is known and Transfer-Encoding is absent, the origin server SHOULD send a Content-Length header field. In the function, after computing the body length from r->args, the code explicitly sets the status to 200, assigns r->clength and calls ap_set_content_length(r, body_len), thereby embedding the Content-Length header into the response.'}}, {'A1': {'code': 'if (r->args) {\n    body_len = (int)apr_atoi64(r->args);\n    if (body_len < 0) body_len = 0;\n}\n...\nap_set_content_length(r, body_len);', 'explanation': 'This action in the code computes the known content length (when provided) and then ensures that the Content-Length header is sent, matching the spec’s requirement that the header is sent when the content size is known and when the response is not one of the exceptions (e.g., 1xx, 204, CONNECT in 2xx).'}}]","The function_body directly implements the relevant part of the HTTP RFC by determining the content length from r->args and setting the Content-Length header using ap_set_content_length, provided that the request satisfies the conditions (i.e. it is a GET or POST and not in an exceptional case). Although additional header manipulation is performed (namely, adding a trailer header field), the key requirement from the RFC is visibly met within this function.",success,
18904,h2test_trailer_handler,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Fully Matches,"[{'A1': {'code': 'r->clength = body_len;\nap_set_content_length(r, body_len);', 'explanation': 'This code explicitly sets the Content-Length header to the exact byte count (body_len) and registers it with the request record. This ensures that the response is length-delimited, which is the core recommendation in the RFC (i.e. to avoid using close-delimiting when possible).'}}, {'A2': {'code': 'apr_table_mergen(r->headers_out, ""Trailer"", ""trailer-content-length"");\napr_table_set(r->trailers_out, ""trailer-content-length"", apr_psprintf(r->pool, ""%d"", body_len));', 'explanation': 'By adding a Trailer header and setting the corresponding trailer value, the function indicates that additional header fields will be sent after the message body, reinforcing the server’s intent to construct a well‐framed response message.'}}]","The function 'h2test_trailer_handler' visibly implements the RFC guidance by ensuring the response message is length-delimited. It sets the Content-Length header and sends exactly that many bytes, appending trailer information as well. These actions directly address the specification's recommendation that a server SHOULD generate encoding or length-delimited messages whenever possible. All relevant logic for response framing is contained within this function, so the implementation fully meets the intended constraints.",success,
18904,h2test_trailer_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Partially Matches,"[{'C1': {'code': 'ap_set_content_type(r, ""application/octet-stream"");', 'explanation': ""This line explicitly sets a Content-Type header field in the response when content is being generated. This attempts to satisfy the RFC requirement that a sender SHOULD include a Content-Type header for messages with content. However, the code does not include logic to determine the intended media type (for example, using the provided media type 'text/html; charset=ISO-8859-4' from the spec context) or to handle the case when the media type is unknown, resulting in a partial match.""}}]","The RFC specifies that a sender generating content should include a Content-Type header field unless the media type is unknown. The function unconditionally sets the header (using a static value 'application/octet-stream') when content is present, which addresses the requirement to include the header. However, it does not incorporate any conditional logic to check whether the intended media type is known before setting the header. Since only the header-setting aspect is visibly implemented in the function (and not the full decision process described in the spec context), the function partially matches the RFC implementation.",success,
18906,h2test_error_handler,A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.,200,Fully Matches,"[{'C1': {'code': 'r->clength = -1;\nr->chunked = 1;\napr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'The function sets the response to use chunked transfer encoding (r->chunked = 1) and, importantly, explicitly unsets the Content-Length header. This directly implements the RFC requirement that no Content-Length header must be sent in any message that includes a Transfer-Encoding header.'}}]","The function_body directly implements the RFC spec requirement by ensuring that when Transfer-Encoding (in this case, chunked encoding) is used, the Content-Length header is removed from the response. It sets r->clength to -1, enables chunked encoding, and unsets the Content-Length header, thereby fully matching the constraint.",success,
18906,h2test_error_handler,"This means that, aside from the well-known exception noted below, a sender MUST NOT generate multiple field lines with the same name in a message (whether in the headers or trailers) or append a field line when a field line of the same name already exists in the message, unless that field's definition allows multiple field line values to be recombined as a comma-separated list (i.e., at least one alternative of the field's definition allows a comma-separated list, such as an ABNF rule of #(values) defined in Section 5.6.1).",232,Does Not Match,[],"The RFC specification requires careful handling of header field lines to avoid generating or altering the order of multiple headers with the same name unless explicitly permitted. In the function_body, there is no visible logic that inspects, orders, or composes header field lines according to these constraints. The function simply unsets a couple of header values (Content-Length and Content-Encoding) and sets environment variables to discourage compression, but it does not address the conditions of not generating multiple header fields or preserving their order as required by the spec. Therefore, the code function does not attempt to implement the specified HTTP RFC requirement regarding multiple field lines.",success,
18906,h2test_error_handler,"Future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) in order to avoid ambiguities.",308,Does Not Match,[],"The RFC specification requires that future registrations of transfer codings SHOULD NOT define parameters called ""q"" (case-insensitively) to avoid ambiguities. In the function_body provided, the code processes query parameters such as ""status"", ""error"", ""error_bucket"", ""body_error"", ""delay"", and ""body_delay"", but there is no logic that handles or checks for a parameter named ""q"". Therefore, none of the spec constraints related to avoiding the use of ""q"" are implemented within this function.",success,
18906,h2test_error_handler,A sender that generates a message containing content SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.,34,Fully Matches,"[{'C1': {'code': 'ap_set_content_type(r, ""application/octet-stream"");', 'explanation': 'The function explicitly sets the Content-Type header field regardless of other conditions. This satisfies the RFC specification that when content is generated, a Content-Type header should be included.'}}]","The RFC requires that a message containing content should include a Content-Type header unless the media type is unknown. In this function, content is generated and the header is explicitly set with a call to ap_set_content_type, using 'application/octet-stream' as a fallback. This direct implementation inside the function addresses the specification, and no significant parts of the requirement are deferred to other dependencies.",success,
18906,h2test_error_handler,"As a result, a sender MUST NOT forward a message with a Content-Length header field value that is known to be incorrect.",48,Partially Matches,"[{'C1': {'code': 'r->clength = -1;\napr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': ""The function explicitly clears the content length by setting r->clength to -1 and unsetting the 'Content-Length' header. This prevents an incorrect Content-Length header from being forwarded, which is in line with the RFC requirement that a sender MUST NOT forward a message with an incorrect Content-Length value. However, the function does not specifically detect or validate duplicate comma‐separated Content-Length values (the allowed exception) or otherwise check for an incorrect value—it simply removes any Content-Length header. Therefore, only part of the spec requirement is visibly implemented.""}}]","The provided code function ensures that no Content-Length header is forwarded by clearing the internal content length and unsetting the header in the outgoing response. This aligns with the RFC’s directive to not forward a message with a known incorrect Content-Length. However, because the function does not implement additional logic to handle or validate duplicate comma-separated Content-Length values (or other detailed validations specified by the RFC), its implementation only partially meets the complete spec constraints.",success,
18906,h2test_error_handler,"If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type.",35,Fully Matches,"[{'A1': {'code': 'ap_set_content_type(r, ""application/octet-stream"");', 'explanation': ""The function explicitly sets the Content-Type to 'application/octet-stream'. This follows the RFC specification that states if no Content-Type header is present, the recipient may assume 'application/octet-stream'.""}}]","Within the function_body, the key RFC requirement is addressed by unconditionally setting the Content-Type header to 'application/octet-stream'. This directly implements the action from the spec, making the function's behavior compliant when no Content-Type header is provided.",success,
18906,h2test_error_handler,A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).,45,Partially Matches,"[{'A1': {'code': 'r->clength = -1;\napr_table_unset(r->headers_out, ""Content-Length"");', 'explanation': 'The function explicitly clears any previously set Content-Length header. This ensures that for responses that must not include Content-Length (e.g. 1xx or 204 as per the RFC), the header is not sent. However, it unsets the header unconditionally regardless of the status code, rather than conditionally applying the removal only for status codes 1xx or 204. Hence, it only partially matches the spec.'}}]","The RFC specifies that a server MUST NOT send a Content-Length header in responses with status codes 1xx or 204. In this function, the code segment that unsets the Content-Length header (via r->clength being set to -1 and apr_table_unset) addresses the requirement by ensuring that no Content-Length appears in the final headers. However, because this removal is applied for all responses (even when the header might be useful or allowed), the implementation does not reflect a conditional application based on the status code. Thus, while the function does implement the intended behavior for disallowed status codes, it does so in a manner that is broader than necessary, resulting in a partial match of the RFC constraint.",success,
18909,h1test_echo_handler,"A sender MUST NOT apply the chunked transfer coding more than once to a message body (i.e., chunking an already chunked message is not allowed).",188,Partially Matches,[],"The RFC requires that a sender must not apply the chunked transfer coding more than once. In the provided function, the response is set to be sent using chunked transfer encoding (by setting r->clength = -1 and r->chunked = 1) and the incoming request body is processed with dechunking (via ap_setup_client_block with REQUEST_CHUNKED_DECHUNK). This shows that the function is aware of using chunked coding to frame messages. However, there is no explicit logic that checks whether chunked encoding has already been applied to the message. In other words, the function does not verify that there isn’t a prior application of chunked transfer coding before setting the flag for chunking the output. Because it only sets the chunked flag without guarding against potential double application (if that were to occur within its own context) the function only partially addresses the RFC requirement. Note that even though dechunking is performed on the incoming body, preventing double-chunking on the output would require an explicit check within this function, which is absent. Thus, in isolation, the function partially matches the intended behavior required by the RFC.",success,
18909,h1test_echo_handler,"A server MUST read the entire request message body or close the connection after sending its response; otherwise, the remaining data on a persistent connection would be misinterpreted as the next request.",312,Fully Matches,"[{'C1': {'code': 'if ((rv = ap_setup_client_block(r, REQUEST_CHUNKED_DECHUNK))) goto cleanup;\nif (ap_should_client_block(r)) {\n    while (0 < (l = ap_get_client_block(r, &buffer[0], sizeof(buffer)))) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, ""echo_handler: copying %ld bytes from request body"", l);\n        rv = apr_brigade_write(bb, NULL, NULL, buffer, l);\n        if (APR_SUCCESS != rv) goto cleanup;\n        rv = ap_pass_brigade(r->output_filters, bb);\n        if (APR_SUCCESS != rv) goto cleanup;\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, ""echo_handler: passed %ld bytes from request body"", l);\n    }\n}', 'explanation': 'This segment sets up and then repeatedly calls ap_get_client_block to read from the request body until no more data is available. By doing so, the function ensures that it reads the entire request message body as required by the HTTP RFC.'}}]","The function 'h1test_echo_handler' directly implements the requirement that the server must read the entire request message body. It initializes client block reading with ap_setup_client_block, then it checks with ap_should_client_block and loops through the body using ap_get_client_block. This ensures that the complete request data is processed, thereby fulfilling the specified RFC constraint within the function itself.",success,
18909,h1test_echo_handler,"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT",71,Does Not Match,[],"The RFC specification requires that a service which selects a proper URI on behalf of the client after receiving a state-changing request should be implemented using the POST method rather than PUT. The provided code function (h1test_echo_handler) merely echoes the request body and supports GET and POST methods without any logic to select a proper URI or handle state-changing requests in the way described. It does not implement any logic associated with state-redirection (e.g., sending a 3xx response or modifying the target resource's state) as required. Hence, no part of the function visibly addresses any labeled condition or action from the spec constraints.",success,
18909,h1test_echo_handler,A recipient that removes the chunked coding from a message MAY selectively retain or discard the received trailer fields.,205,Fully Matches,"[{'C1': {'code': 'if (r->trailers_in && !apr_is_empty_table(r->trailers_in)) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                      ""echo_handler: seeing incoming trailers"");\n        apr_table_setn(r->trailers_out, ""h1test-trailers-in"",\n                       apr_itoa(r->pool, 1));\n    }', 'explanation': 'This code checks whether trailer fields have been received (i.e. if r->trailers_in is non-null and non-empty) and then assigns them (or an indication thereof) to the separate trailers_out table. This meets the RFC requirement that a recipient MAY selectively retain the trailer fields and, if retained, must store them separately from the header fields.'}}, {'A1': {'code': 'if (apr_table_get(r->headers_in, ""Add-Trailer"")) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                      ""echo_handler: seeing incoming Add-Trailer header"");\n        apr_table_setn(r->trailers_out, ""h1test-add-trailer"",\n                      apr_table_get(r->headers_in, ""Add-Trailer""));\n    }', 'explanation': ""This segment conditionally adds a trailer field based on an 'Add-Trailer' header in the input, thereby further demonstrating that trailer handling is performed separately, in compliance with the RFC guidelines to either store them separately or merge only when specifically permitted.""}}]","The function inspects for incoming trailer fields and, if they exist, stores them in the r->trailers_out table rather than merging them into the main header fields. This logic directly addresses the RFC specification that requires a recipient to selectively retain or discard trailer fields, and if retained, to store them separately. All trailer handling logic is contained within the function itself, fulfilling the relevant conditions and actions.",success,
18909,h1test_echo_handler,A recipient MUST NOT merge a received trailer field into the header section unless its corresponding header field definition explicitly permits and instructs how the trailer field value can be safely merged.,207,Fully Matches,"[{'C1': {'code': 'if (r->trailers_in && !apr_is_empty_table(r->trailers_in)) {\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                  ""echo_handler: seeing incoming trailers"");\n    apr_table_setn(r->trailers_out, ""h1test-trailers-in"",\n                   apr_itoa(r->pool, 1));\n}', 'explanation': 'This segment checks for the presence of incoming trailers and explicitly stores a marker in a dedicated trailer table (r->trailers_out) rather than merging them into the header section, thereby complying with the RFC requirement.'}}, {'A1': {'code': 'if (apr_table_get(r->headers_in, ""Add-Trailer"")) {\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                  ""echo_handler: seeing incoming Add-Trailer header"");\n    apr_table_setn(r->trailers_out, ""h1test-add-trailer"",\n                   apr_table_get(r->headers_in, ""Add-Trailer""));\n}', 'explanation': 'This code detects a specific header (""Add-Trailer"") and deliberately places its value into the trailer table (r->trailers_out) rather than merging it into the headers, in accordance with the RFC\'s directive.'}}]","The function explicitly handles incoming trailer fields by directing them into the r->trailers_out table instead of merging them into the header section. Both the check for any received trailers and the special handling of an ""Add-Trailer"" header demonstrate that the code function addresses the RFC requirement regarding trailer field management. All the relevant logic is contained within the function itself, with no merging into the headers occurring.",success,
18909,h1test_echo_handler,"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads rather than terminate connections with the expectation that clients will retry.",317,Does Not Match,[],"The provided code function (h1test_echo_handler) primarily handles echoing the request body to the response, including handling chunked transfer and related logging. It does not contain any logic or mechanisms that address sustaining persistent connections or managing overload using underlying transport flow-control mechanisms, as required by the RFC specification. Furthermore, there is no visible implementation in this function that monitors network conditions during message transmission or attempts to gracefully handle overload rather than terminating connections. Therefore, this function does not implement the specified RFC constraints.",success,
18909,h1test_echo_handler,A recipient MUST NOT merge a trailer field into a header section unless the recipient understands the corresponding header field definition and that definition explicitly permits and defines how trailer field values can be safely merged.,11,Partially Matches,"[{'C1': {'code': 'if (r->trailers_in && !apr_is_empty_table(r->trailers_in)) {\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, ""echo_handler: seeing incoming trailers"");\n    apr_table_setn(r->trailers_out, ""h1test-trailers-in"", apr_itoa(r->pool, 1));\n}', 'explanation': 'This segment checks for incoming trailer fields and deliberately places an indicator in the trailers_out table rather than merging them into the header section. This avoids the prohibited action, although it does not perform any validation whether the trailer field definition explicitly permits merging.'}}, {'A1': {'code': 'if (apr_table_get(r->headers_in, ""Add-Trailer"")) {\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, ""echo_handler: seeing incoming Add-Trailer header"");\n    apr_table_setn(r->trailers_out, ""h1test-add-trailer"", apr_table_get(r->headers_in, ""Add-Trailer""));\n}', 'explanation': 'This code detects a specific header (""Add-Trailer"") and sets a related trailer field in trailers_out. It handles trailer-related data without merging it into headers, but again does not verify the header field definitions as required by the RFC.'}}]","The provided function shows visible handling of trailer fields by checking incoming trailers and selectively writing values into the trailers_out table instead of merging them into the header section. This behavior aligns with the RFC’s mandate to not merge trailer fields into the header unless explicitly permitted. However, the function does not include logic to validate or check if the trailer field definitions allow such merging. As a result, the function only partially matches the RFC constraint by preventing unsafe merging without implementing the full verification required by the specification.",success,
18909,h1test_echo_handler,"Because of the potential for trailer fields to be discarded in transit, a server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive.",12,Does Not Match,[],"The RFC specifies that a server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive. In this code function, trailer fields are added in two instances: when incoming trailers are detected (using r->trailers_in) and when the header 'Add-Trailer' is present. There is no logic within the function that assesses whether those trailer fields are critical for the user agent or if the client even supports processing them (e.g., by checking for the 'trailers' token in the TE header). Therefore, the function does not implement the spec constraint by conditionally avoiding generation of critical trailers.",success,
18909,h1test_echo_handler,"Since there is no way to distinguish a successfully completed, close-delimited response message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible.",304,Partially Matches,"[{'A1': {'code': 'r->clength = -1;\n r->chunked = 1;', 'explanation': 'This segment configures the response to use chunked transfer encoding, which is an example of generating an encoding-delimited message as recommended by the RFC. It sets the content length to -1 (unknown) and explicitly enables chunked encoding.'}}]","The function shows an attempt to align with the RFC's recommendation of generating an encoding or length-delimited message by enabling chunked transfer encoding. However, while it handles the creation and passing of chunks (and even processes trailers), it does not implement additional error checking or handling for invalid Content-Length header scenarios described in the specification context. Therefore, the implementation only partially matches the RFC conditions and actions.",success,
