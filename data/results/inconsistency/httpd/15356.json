{
  "function_id": 15356, //yes, te and ct
  "function_name": "ap_proxy_ajp_request",
  "file_path": "/data/a/ykw/RFC/final/data/httpd/source_code/modules/proxy/mod_proxy_ajp.c",
  "sr_content": "A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.",
  "sr_context": {
    "Previous Paragraph": "When a message does not have a Transfer-Encoding header field, a Content-Length header field (Section 8.6 of [HTTP]) can provide the anticipated size, as a decimal number of octets, for potential content. For messages that do include content, the Content-Length field value provides the framing information necessary for determining where the data (and message) ends. For messages that do not include content, the Content-Length indicates the size of the selected representation (Section 8.6 of [HTTP]).",
    "Current Paragraph": "A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field."
  },
  "dsr1_result": {
    "conformance": "PARTIAL",
    "reasoning": "The code partially addresses the specification by checking for Transfer-Encoding and handling chunked encoding, but it does not ensure that Content-Length is omitted when Transfer-Encoding is present. It also doesn't handle other Transfer-Encoding values correctly.",
    "issues": [
      {
        "description": "The code does not remove or ignore the Content-Length header when Transfer-Encoding is present, violating the specification.",
        "code_segment": "The section where Transfer-Encoding is checked and Content-Length is processed.",
        "line_numbers": "Approximately lines 100-150.",
        "expected_behavior": "When Transfer-Encoding is present, Content-Length should not be sent.",
        "actual_behavior": "Content-Length is processed and may be sent alongside Transfer-Encoding.",
        "severity": "HIGH"
      },
      {
        "description": "The code only handles 'chunked' Transfer-Encoding and logs an error for others, not adhering to the spec which applies to any Transfer-Encoding.",
        "code_segment": "The Transfer-Encoding check and handling.",
        "line_numbers": "Approximately lines 100-120.",
        "expected_behavior": "Any Transfer-Encoding should prevent Content-Length from being sent.",
        "actual_behavior": "Only 'chunked' is handled, others are logged as errors.",
        "severity": "MEDIUM"
      }
    ],
    "conclusion": "The implementation partially meets the specification but fails to correctly handle all cases where Transfer-Encoding is present, leading to potential violations of the requirement."
  },
  "openai_result": {
    "conformance": "PARTIAL",
    "reasoning": "The specification requires that if a message contains a Transfer\u2010Encoding header field, then no Content\u2010Length header field is sent. In this AJP request function the code explicitly checks for a Transfer-Encoding header (using apr_table_get on 'Transfer-Encoding') and, if it exists, only allows the value 'chunked'. In that case it does not attempt to retrieve or use the Content-Length (the call to get_content_length(r) is only made when there is no Transfer-Encoding header). Thus the intent is to not process any client-provided Content-Length if a Transfer-Encoding header is present. However, there is a caveat: the code calls ajp_send_header very early (before this branch) and passes the unmodified request record. It is not visible here whether ajp_send_header itself removes the Content-Length header when a Transfer-Encoding header is present. If ajp_send_header does not perform that filtering, then an HTTP message might be forwarded containing both headers, which would violate the RFC requirement. In other words, while the checking logic in this function shows awareness of the issue, the separation of concerns (header\u2010sending versus data\u2010processing) means that the actual removal of the Content-Length header is likely delegated to ajp_send_header. Without seeing its implementation there is some uncertainty. Additionally, if both headers are inadvertently provided (with Transfer-Encoding equal to \u2018chunked\u2019 and a Content-Length by mistake), this code does not explicitly remove Content-Length from the request record in this function. Hence, the implementation is intended to conform to the spec but does so only partially in this module \u2013 it relies on other parts of the code (likely ajp_send_header) to perform the actual removal of Content-Length when Transfer-Encoding is present.",
    "issues": [
      {
        "description": "Potential ordering/locality issue: ajp_send_header is called before the function explicitly checks for a Transfer-Encoding header. If ajp_send_header does not itself filter out the Content-Length header when Transfer-Encoding is present, then a message containing both headers may be sent.",
        "code_segment": "status = ajp_send_header(conn->sock, r, maxsize, uri, secret);\n...\n tenc = apr_table_get(r->headers_in, \"Transfer-Encoding\");\n if (tenc) { ... } else { /* Get client provided Content-Length header */ ... }",
        "line_numbers": "Around the beginning of the function (first 40-50 lines)",
        "expected_behavior": "If the request contains a Transfer-Encoding header, then no Content-Length header should be sent. In particular, the header\u2010sending function should omit any Content-Length header when Transfer-Encoding is detected.",
        "actual_behavior": "The function checks for Transfer-Encoding only after ajp_send_header has been called; the removal of Content-Length is therefore not handled here and must be done in ajp_send_header. The code does not explicitly remove Content-Length.",
        "severity": "MEDIUM"
      }
    ],
    "conclusion": "The code is clearly written with the awareness of the specification requirement \u2013 it distinguishes between messages with Transfer-Encoding and those using Content-Length. However, because the actual header\u2010sending (handled by ajp_send_header) is invoked before the check in this function, and because the removal of Content-Length is not done explicitly here, there is a partial conformance: the intent is implemented correctly but the guarantee depends on the behavior of the underlying header\u2010generation function. As such, the implementation is intended to meet the spec but only partially guarantees that no Content-Length header is sent when Transfer-Encoding is present."
  },
  "function_code": "static int ap_proxy_ajp_request(apr_pool_t *p, request_rec *r,\n                                proxy_conn_rec *conn,\n                                conn_rec *origin,\n                                proxy_dir_conf *conf,\n                                apr_uri_t *uri,\n                                char *url, char *server_portstr)\n{\n    apr_status_t status;\n    int result;\n    apr_bucket *e;\n    apr_bucket_brigade *input_brigade;\n    apr_bucket_brigade *output_brigade;\n    ajp_msg_t *msg;\n    apr_size_t bufsiz = 0;\n    char *buff;\n    char *send_body_chunk_buff;\n    apr_uint16_t size;\n    apr_byte_t conn_reuse = 0;\n    const char *tenc;\n    int havebody = 1;\n    int client_failed = 0;\n    int backend_failed = 0;\n    apr_off_t bb_len;\n    int data_sent = 0;\n    int request_ended = 0;\n    int headers_sent = 0;\n    int rv = OK;\n    apr_int32_t conn_poll_fd;\n    apr_pollfd_t *conn_poll;\n    proxy_server_conf *psf =\n    ap_get_module_config(r->server->module_config, &proxy_module);\n    apr_size_t maxsize = AJP_MSG_BUFFER_SZ;\n    int send_body = 0;\n    apr_off_t content_length = 0;\n    int original_status = r->status;\n    const char *original_status_line = r->status_line;\n    const char *secret = NULL;\n\n    if (psf->io_buffer_size_set)\n       maxsize = psf->io_buffer_size;\n    if (maxsize > AJP_MAX_BUFFER_SZ)\n       maxsize = AJP_MAX_BUFFER_SZ;\n    else if (maxsize < AJP_MSG_BUFFER_SZ)\n       maxsize = AJP_MSG_BUFFER_SZ;\n    maxsize = APR_ALIGN(maxsize, 1024);\n\n    if (*conn->worker->s->secret)\n        secret = conn->worker->s->secret;\n\n    /*\n     * Send the AJP request to the remote server\n     */\n\n    /* send request headers */\n    status = ajp_send_header(conn->sock, r, maxsize, uri, secret);\n    if (status != APR_SUCCESS) {\n        conn->close = 1;\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00868)\n                      \"request failed to %pI (%s:%hu)\",\n                      conn->addr, conn->hostname, conn->port);\n        if (status == AJP_EOVERFLOW)\n            return HTTP_BAD_REQUEST;\n        else {\n            /*\n             * This is only non fatal when the method is idempotent. In this\n             * case we can dare to retry it with a different worker if we are\n             * a balancer member.\n             */\n            if (is_idempotent(r) == METHOD_IDEMPOTENT) {\n                return HTTP_SERVICE_UNAVAILABLE;\n            }\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n    }\n\n    /* allocate an AJP message to store the data of the buckets */\n    bufsiz = maxsize;\n    status = ajp_alloc_data_msg(r->pool, &buff, &bufsiz, &msg);\n    if (status != APR_SUCCESS) {\n        /* We had a failure: Close connection to backend */\n        conn->close = 1;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00869)\n                      \"ajp_alloc_data_msg failed\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /* read the first block of data */\n    input_brigade = apr_brigade_create(p, r->connection->bucket_alloc);\n    tenc = apr_table_get(r->headers_in, \"Transfer-Encoding\");\n    if (tenc) {\n        if (ap_cstr_casecmp(tenc, \"chunked\") == 0) {\n            /* The AJP protocol does not want body data yet */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00870)\n                          \"request is chunked\");\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10396)\n                          \"%s Transfer-Encoding is not supported\",\n                          tenc);\n            /* We had a failure: Close connection to backend */\n            conn->close = 1;\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n    } else {\n        /* Get client provided Content-Length header */\n        content_length = get_content_length(r);\n        if (content_length < 0) {\n            status = APR_EINVAL;\n        }\n        else {\n            status = ap_get_brigade(r->input_filters, input_brigade,\n                                    AP_MODE_READBYTES, APR_BLOCK_READ,\n                                    maxsize - AJP_HEADER_SZ);\n        }\n        if (status != APR_SUCCESS) {\n            /* We had a failure: Close connection to backend */\n            conn->close = 1;\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00871)\n                          \"ap_get_brigade failed\");\n            apr_brigade_destroy(input_brigade);\n            return ap_map_http_request_error(status, HTTP_BAD_REQUEST);\n        }\n\n        /* have something */\n        if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(input_brigade))) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00872) \"APR_BUCKET_IS_EOS\");\n        }\n\n        /* Try to send something */\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00873)\n                      \"data to read (max %\" APR_SIZE_T_FMT\n                      \" at %\" APR_SIZE_T_FMT \")\", bufsiz, msg->pos);\n\n        status = apr_brigade_flatten(input_brigade, buff, &bufsiz);\n        if (status != APR_SUCCESS) {\n            /* We had a failure: Close connection to backend */\n            conn->close = 1;\n            apr_brigade_destroy(input_brigade);\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00874)\n                          \"apr_brigade_flatten\");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n        apr_brigade_cleanup(input_brigade);\n\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00875)\n                      \"got %\" APR_SIZE_T_FMT \" bytes of data\", bufsiz);\n        if (bufsiz > 0) {\n            status = ajp_send_data_msg(conn->sock, msg, bufsiz);\n            ajp_msg_log(r, msg, \"First ajp_send_data_msg: ajp_ilink_send packet dump\");\n            if (status != APR_SUCCESS) {\n                /* We had a failure: Close connection to backend */\n                conn->close = 1;\n                apr_brigade_destroy(input_brigade);\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00876)\n                              \"send failed to %pI (%s:%hu)\",\n                              conn->addr, conn->hostname, conn->port);\n                /*\n                 * It is fatal when we failed to send a (part) of the request\n                 * body.\n                 */\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n            conn->worker->s->transferred += bufsiz;\n            send_body = 1;\n        }\n        else if (content_length > 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00877)\n                          \"read zero bytes, expecting\"\n                          \" %\" APR_OFF_T_FMT \" bytes\",\n                          content_length);\n            /*\n             * We can only get here if the client closed the connection\n             * to us without sending the body.\n             * Now the connection is in the wrong state on the backend.\n             * Sending an empty data msg doesn't help either as it does\n             * not move this connection to the correct state on the backend\n             * for later resusage by the next request again.\n             * Close it to clean things up.\n             */\n            conn->close = 1;\n            apr_brigade_destroy(input_brigade);\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    /* read the response */\n    conn->data = NULL;\n    status = ajp_read_header(conn->sock, r, maxsize,\n                             (ajp_msg_t **)&(conn->data));\n    if (status != APR_SUCCESS) {\n        /* We had a failure: Close connection to backend */\n        conn->close = 1;\n        apr_brigade_destroy(input_brigade);\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00878)\n                      \"read response failed from %pI (%s:%hu)\",\n                      conn->addr, conn->hostname, conn->port);\n\n        /* If we had a successful cping/cpong and then a timeout\n         * we assume it is a request that cause a back-end timeout,\n         * but doesn't affect the whole worker.\n         */\n        if (APR_STATUS_IS_TIMEUP(status) &&\n                conn->worker->s->ping_timeout_set) {\n            apr_table_setn(r->notes, \"proxy_timedout\", \"1\");\n            return HTTP_GATEWAY_TIME_OUT;\n        }\n\n        /*\n         * This is only non fatal when we have not sent (parts) of a possible\n         * request body so far (we do not store it and thus cannot send it\n         * again) and the method is idempotent. In this case we can dare to\n         * retry it with a different worker if we are a balancer member.\n         */\n        if (!send_body && (is_idempotent(r) == METHOD_IDEMPOTENT)) {\n            return HTTP_SERVICE_UNAVAILABLE;\n        }\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    /* parse the response */\n    result = ajp_parse_type(r, conn->data);\n    output_brigade = apr_brigade_create(p, r->connection->bucket_alloc);\n\n    /*\n     * Prepare apr_pollfd_t struct for possible later check if there is currently\n     * data available from the backend (do not flush response to client)\n     * or not (flush response to client)\n     */\n    conn_poll = apr_pcalloc(p, sizeof(apr_pollfd_t));\n    conn_poll->reqevents = APR_POLLIN;\n    conn_poll->desc_type = APR_POLL_SOCKET;\n    conn_poll->desc.s = conn->sock;\n\n    bufsiz = maxsize;\n    for (;;) {\n        switch (result) {\n            case CMD_AJP13_GET_BODY_CHUNK:\n                if (havebody) {\n                    if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(input_brigade))) {\n                        /* This is the end */\n                        bufsiz = 0;\n                        havebody = 0;\n                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00879)\n                                      \"APR_BUCKET_IS_EOS\");\n                    } else {\n                        status = ap_get_brigade(r->input_filters, input_brigade,\n                                                AP_MODE_READBYTES,\n                                                APR_BLOCK_READ,\n                                                maxsize - AJP_HEADER_SZ);\n                        if (status != APR_SUCCESS) {\n                            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00880)\n                                          \"ap_get_brigade failed\");\n                            if (APR_STATUS_IS_TIMEUP(status)) {\n                                rv = HTTP_REQUEST_TIME_OUT;\n                            }\n                            else if (status == AP_FILTER_ERROR) {\n                                rv = AP_FILTER_ERROR;\n                            }\n                            client_failed = 1;\n                            break;\n                        }\n                        bufsiz = maxsize;\n                        status = apr_brigade_flatten(input_brigade, buff,\n                                                     &bufsiz);\n                        apr_brigade_cleanup(input_brigade);\n                        if (status != APR_SUCCESS) {\n                            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00881)\n                                         \"apr_brigade_flatten failed\");\n                            rv = HTTP_INTERNAL_SERVER_ERROR;\n                            client_failed = 1;\n                            break;\n                        }\n                    }\n\n                    ajp_msg_reset(msg);\n                    /* will go in ajp_send_data_msg */\n                    status = ajp_send_data_msg(conn->sock, msg, bufsiz);\n                    ajp_msg_log(r, msg, \"ajp_send_data_msg after CMD_AJP13_GET_BODY_CHUNK: ajp_ilink_send packet dump\");\n                    if (status != APR_SUCCESS) {\n                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00882)\n                                      \"ajp_send_data_msg failed\");\n                        backend_failed = 1;\n                        break;\n                    }\n                    conn->worker->s->transferred += bufsiz;\n                } else {\n                    /*\n                     * something is wrong TC asks for more body but we are\n                     * already at the end of the body data\n                     */\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00883)\n                                  \"ap_proxy_ajp_request error read after end\");\n                    backend_failed = 1;\n                }\n                break;\n            case CMD_AJP13_SEND_HEADERS:\n                if (headers_sent) {\n                    /* Do not send anything to the client.\n                     * Backend already send us the headers.\n                     */\n                    backend_failed = 1;\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00884)\n                                  \"Backend sent headers twice.\");\n                    break;\n                }\n                /* AJP13_SEND_HEADERS: process them */\n                status = ajp_parse_header(r, conf, conn->data);\n                if (status != APR_SUCCESS) {\n                    backend_failed = 1;\n                }\n                else if ((r->status == 401) && conf->error_override) {\n                    const char *buf;\n                    const char *wa = \"WWW-Authenticate\";\n                    if ((buf = apr_table_get(r->headers_out, wa))) {\n                        apr_table_set(r->err_headers_out, wa, buf);\n                    } else {\n                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00885)\n                                      \"ap_proxy_ajp_request: origin server \"\n                                      \"sent 401 without WWW-Authenticate header\");\n                    }\n                }\n                headers_sent = 1;\n                break;\n            case CMD_AJP13_SEND_BODY_CHUNK:\n                /* AJP13_SEND_BODY_CHUNK: piece of data */\n                status = ajp_parse_data(r, conn->data, &size, &send_body_chunk_buff);\n                if (status == APR_SUCCESS) {\n                    /* If we are overriding the errors, we can't put the content\n                     * of the page into the brigade.\n                     */\n                    if (!ap_proxy_should_override(conf, r->status)) {\n                        /* AJP13_SEND_BODY_CHUNK with zero length\n                         * is explicit flush message\n                         */\n                        if (size == 0) {\n                            if (headers_sent) {\n                                e = apr_bucket_flush_create(r->connection->bucket_alloc);\n                                APR_BRIGADE_INSERT_TAIL(output_brigade, e);\n                            }\n                            else {\n                                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00886)\n                                              \"Ignoring flush message \"\n                                              \"received before headers\");\n                            }\n                        }\n                        else {\n                            apr_status_t rv;\n\n                            /* Handle the case where the error document is itself reverse\n                             * proxied and was successful. We must maintain any previous\n                             * error status so that an underlying error (eg HTTP_NOT_FOUND)\n                             * doesn't become an HTTP_OK.\n                             */\n                            if (ap_proxy_should_override(conf, original_status)) {\n                                r->status = original_status;\n                                r->status_line = original_status_line;\n                            }\n\n                            e = apr_bucket_transient_create(send_body_chunk_buff, size,\n                                                        r->connection->bucket_alloc);\n                            APR_BRIGADE_INSERT_TAIL(output_brigade, e);\n\n                            if ((conn->worker->s->flush_packets == flush_on) ||\n                                ((conn->worker->s->flush_packets == flush_auto) &&\n                                ((rv = apr_poll(conn_poll, 1, &conn_poll_fd,\n                                                 conn->worker->s->flush_wait))\n                                                 != APR_SUCCESS) &&\n                                  APR_STATUS_IS_TIMEUP(rv))) {\n                                e = apr_bucket_flush_create(r->connection->bucket_alloc);\n                                APR_BRIGADE_INSERT_TAIL(output_brigade, e);\n                            }\n                            apr_brigade_length(output_brigade, 0, &bb_len);\n                            if (bb_len != -1)\n                                conn->worker->s->read += bb_len;\n                        }\n                        if (headers_sent) {\n                            if (ap_pass_brigade(r->output_filters,\n                                                output_brigade) != APR_SUCCESS) {\n                                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00887)\n                                              \"error processing body.%s\",\n                                              r->connection->aborted ?\n                                              \" Client aborted connection.\" : \"\");\n                                client_failed = 1;\n                            }\n                            data_sent = 1;\n                            apr_brigade_cleanup(output_brigade);\n                        }\n                    }\n                }\n                else {\n                    backend_failed = 1;\n                }\n                break;\n            case CMD_AJP13_END_RESPONSE:\n                /* If we are overriding the errors, we must not send anything to\n                 * the client, especially as the brigade already contains headers.\n                 * So do nothing here, and it will be cleaned up below.\n                 */\n                status = ajp_parse_reuse(r, conn->data, &conn_reuse);\n                if (status != APR_SUCCESS) {\n                    backend_failed = 1;\n                }\n                if (!ap_proxy_should_override(conf, r->status)) {\n                    e = apr_bucket_eos_create(r->connection->bucket_alloc);\n                    APR_BRIGADE_INSERT_TAIL(output_brigade, e);\n                    if (ap_pass_brigade(r->output_filters,\n                                        output_brigade) != APR_SUCCESS) {\n                        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00888)\n                                      \"error processing end\");\n                        client_failed = 1;\n                    }\n                    /* XXX: what about flush here? See mod_jk */\n                    data_sent = 1;\n                }\n                request_ended = 1;\n                break;\n            default:\n                backend_failed = 1;\n                break;\n        }\n\n        /*\n         * If connection has been aborted by client: Stop working.\n         * Pretend we are done (data_sent) to avoid further processing.\n         */\n        if (r->connection->aborted) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02821)\n                          \"client connection aborted\");\n            /* no response yet (or ever), set status for access log */\n            if (!headers_sent) {\n                r->status = HTTP_BAD_REQUEST;\n            }\n            client_failed = 1;\n            /* return DONE */\n            data_sent = 1;\n            break;\n        }\n\n        /*\n         * We either have finished successfully or we failed.\n         * So bail out\n         */\n        if ((result == CMD_AJP13_END_RESPONSE)\n                || backend_failed || client_failed)\n            break;\n\n        /* read the response */\n        status = ajp_read_header(conn->sock, r, maxsize,\n                                 (ajp_msg_t **)&(conn->data));\n        if (status != APR_SUCCESS) {\n            backend_failed = 1;\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00889)\n                          \"ajp_read_header failed\");\n            break;\n        }\n        result = ajp_parse_type(r, conn->data);\n    }\n    apr_brigade_destroy(input_brigade);\n\n    /*\n     * Clear output_brigade to remove possible buckets that remained there\n     * after an error.\n     */\n    apr_brigade_cleanup(output_brigade);\n\n    if (backend_failed || client_failed) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00890)\n                      \"Processing of request failed backend: %i, client: %i\",\n                      backend_failed, client_failed);\n        /* We had a failure: Close connection to backend */\n        conn->close = 1;\n        if (data_sent) {\n            /* Return DONE to avoid error messages being added to the stream */\n            rv = DONE;\n        }\n    }\n    else if (!request_ended) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00891)\n                      \"Processing of request didn't terminate cleanly\");\n        /* We had a failure: Close connection to backend */\n        conn->close = 1;\n        backend_failed = 1;\n        if (data_sent) {\n            /* Return DONE to avoid error messages being added to the stream */\n            rv = DONE;\n        }\n    }\n    else if (!conn_reuse) {\n        /* Our backend signalled connection close */\n        conn->close = 1;\n    }\n    else {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00892)\n                      \"got response from %pI (%s:%hu)\",\n                      conn->addr, conn->hostname, conn->port);\n\n        if (ap_proxy_should_override(conf, r->status)) {\n            /* clear r->status for override error, otherwise ErrorDocument\n             * thinks that this is a recursive error, and doesn't find the\n             * custom error page\n             */\n            rv = r->status;\n            r->status = HTTP_OK;\n            /*\n             * prevent proxy_handler() from treating this as an\n             * internal error.\n             */\n            apr_table_setn(r->notes, \"proxy-error-override\", \"1\");\n        }\n        else {\n            rv = OK;\n        }\n    }\n\n    if (backend_failed) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00893)\n                      \"dialog to %pI (%s:%hu) failed\",\n                      conn->addr, conn->hostname, conn->port);\n        /*\n         * If we already send data, signal a broken backend connection\n         * upwards in the chain.\n         */\n        if (data_sent) {\n            ap_proxy_fill_error_brigade(r, HTTP_BAD_GATEWAY, output_brigade, -1);\n        } else if (!send_body && (is_idempotent(r) == METHOD_IDEMPOTENT)) {\n            /*\n             * This is only non fatal when we have not send (parts) of a possible\n             * request body so far (we do not store it and thus cannot send it\n             * again) and the method is idempotent. In this case we can dare to\n             * retry it with a different worker if we are a balancer member.\n             */\n            rv = HTTP_SERVICE_UNAVAILABLE;\n        } else {\n            /* If we had a successful cping/cpong and then a timeout\n             * we assume it is a request that cause a back-end timeout,\n             * but doesn't affect the whole worker.\n             */\n            if (APR_STATUS_IS_TIMEUP(status) &&\n                    conn->worker->s->ping_timeout_set) {\n                apr_table_setn(r->notes, \"proxy_timedout\", \"1\");\n                rv = HTTP_GATEWAY_TIME_OUT;\n            }\n            else {\n                rv = HTTP_INTERNAL_SERVER_ERROR;\n            }\n        }\n    }\n    else if (client_failed) {\n        int level = (r->connection->aborted) ? APLOG_DEBUG : APLOG_ERR;\n        ap_log_rerror(APLOG_MARK, level, status, r, APLOGNO(02822)\n                      \"dialog with client %pI failed\",\n                      r->connection->client_addr);\n        if (rv == OK) {\n            rv = HTTP_BAD_REQUEST;\n        }\n    }\n\n    /*\n     * Ensure that we sent an EOS bucket thru the filter chain, if we already\n     * have sent some data.\n     */\n    if (data_sent && !r->eos_sent && !r->connection->aborted) {\n        e = apr_bucket_eos_create(r->connection->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(output_brigade, e);\n    }\n\n    /* If we have added something to the brigade above, send it */\n    if (!APR_BRIGADE_EMPTY(output_brigade)\n        && ap_pass_brigade(r->output_filters, output_brigade) != APR_SUCCESS) {\n        rv = AP_FILTER_ERROR;\n    }\n\n    apr_brigade_destroy(output_brigade);\n\n    if (apr_table_get(r->subprocess_env, \"proxy-nokeepalive\")) {\n        conn->close = 1;\n    }\n\n    return rv;\n}"
}